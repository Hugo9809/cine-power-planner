var __CINE_VERSION_MARKERS__ = {
  modern: 'const APP_VERSION = "1.0.5";',
  legacy: 'var APP_VERSION = "1.0.5";'
};
var __cineVersionMarkerScope = typeof globalThis !== 'undefined' ? globalThis : typeof self !== 'undefined' ? self : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : Function('return this')();
if (!__cineVersionMarkerScope.__CINE_VERSION_MARKERS__ || __cineVersionMarkerScope.__CINE_VERSION_MARKERS__.modern !== __CINE_VERSION_MARKERS__.modern || __cineVersionMarkerScope.__CINE_VERSION_MARKERS__.legacy !== __CINE_VERSION_MARKERS__.legacy) {
  __cineVersionMarkerScope.__CINE_VERSION_MARKERS__ = __CINE_VERSION_MARKERS__;
}
var MONOLITH_SOURCE = "// script.js \u2013 Main logic for the Cine Power Planner app\n/* global texts, categoryNames, gearItems, loadSessionState, saveSessionState, loadProject, saveProject, deleteProject, renameSetup, registerDevice, loadFavorites, saveFavorites, exportAllData, importAllData, clearAllData, loadAutoGearRules, saveAutoGearRules, loadAutoGearBackups, saveAutoGearBackups, loadAutoGearSeedFlag, saveAutoGearSeedFlag, loadAutoGearPresets, saveAutoGearPresets, loadAutoGearActivePresetId, saveAutoGearActivePresetId, loadAutoGearAutoPresetId, saveAutoGearAutoPresetId, loadAutoGearBackupVisibility, saveAutoGearBackupVisibility, AUTO_GEAR_RULES_STORAGE_KEY, AUTO_GEAR_SEEDED_STORAGE_KEY, AUTO_GEAR_BACKUPS_STORAGE_KEY, AUTO_GEAR_PRESETS_STORAGE_KEY, AUTO_GEAR_ACTIVE_PRESET_STORAGE_KEY, AUTO_GEAR_AUTO_PRESET_STORAGE_KEY, AUTO_GEAR_BACKUP_VISIBILITY_STORAGE_KEY, SAFE_LOCAL_STORAGE, getSafeLocalStorage, CUSTOM_FONT_STORAGE_KEY, CUSTOM_FONT_STORAGE_KEY_NAME */\n\n// Use `var` here instead of `let` because `index.html` loads the lz-string\n// library from a CDN which defines a global `LZString` variable. Using `let`\n// would attempt to create a new lexical binding and throw a SyntaxError in\n// browsers that already have the global property. `var` simply reuses the\n// existing global variable if present.\nvar LZString;\ntry {\n  LZString = require('lz-string');\n} catch {\n  if (typeof window !== 'undefined' && window.LZString) {\n    LZString = window.LZString;\n  } else {\n    // Fallback no-op implementation to avoid runtime errors when the\n    // dependency is unavailable (e.g. during tests).\n    LZString = {\n      compressToEncodedURIComponent: s => s,\n      decompressFromEncodedURIComponent: s => s\n    };\n  }\n}\n\nvar generatePrintableOverview;\ntry {\n  ({ generatePrintableOverview } = require('./overview.js'));\n} catch {\n  // overview generation not needed in test environments without module support\n}\n\nif (typeof window !== 'undefined') {\n  const lottie = window.lottie;\n  if (lottie && typeof lottie.useWebWorker === 'function') {\n    try {\n      lottie.useWebWorker(false);\n    } catch (error) {\n      console.warn('Unable to disable Lottie web workers', error);\n    }\n  }\n}\n\nconst APP_VERSION = \"1.0.5\";\nconst IOS_PWA_HELP_STORAGE_KEY = 'iosPwaHelpShown';\n\nconst DEVICE_SCHEMA_PATH = 'src/data/schema.json';\nconst DEVICE_SCHEMA_STORAGE_KEY = 'cameraPowerPlanner_schemaCache';\nconst AUTO_GEAR_RULES_KEY =\n  typeof AUTO_GEAR_RULES_STORAGE_KEY !== 'undefined'\n    ? AUTO_GEAR_RULES_STORAGE_KEY\n    : 'cameraPowerPlanner_autoGearRules';\nconst AUTO_GEAR_SEEDED_KEY =\n  typeof AUTO_GEAR_SEEDED_STORAGE_KEY !== 'undefined'\n    ? AUTO_GEAR_SEEDED_STORAGE_KEY\n    : 'cameraPowerPlanner_autoGearSeeded';\nconst AUTO_GEAR_BACKUPS_KEY =\n  typeof AUTO_GEAR_BACKUPS_STORAGE_KEY !== 'undefined'\n    ? AUTO_GEAR_BACKUPS_STORAGE_KEY\n    : 'cameraPowerPlanner_autoGearBackups';\nconst AUTO_GEAR_PRESETS_KEY =\n  typeof AUTO_GEAR_PRESETS_STORAGE_KEY !== 'undefined'\n    ? AUTO_GEAR_PRESETS_STORAGE_KEY\n    : 'cameraPowerPlanner_autoGearPresets';\nconst AUTO_GEAR_ACTIVE_PRESET_KEY =\n  typeof AUTO_GEAR_ACTIVE_PRESET_STORAGE_KEY !== 'undefined'\n    ? AUTO_GEAR_ACTIVE_PRESET_STORAGE_KEY\n    : 'cameraPowerPlanner_autoGearActivePreset';\nconst AUTO_GEAR_AUTO_PRESET_KEY =\n  typeof AUTO_GEAR_AUTO_PRESET_STORAGE_KEY !== 'undefined'\n    ? AUTO_GEAR_AUTO_PRESET_STORAGE_KEY\n    : 'cameraPowerPlanner_autoGearAutoPreset';\nconst AUTO_GEAR_BACKUP_VISIBILITY_KEY =\n  typeof AUTO_GEAR_BACKUP_VISIBILITY_STORAGE_KEY !== 'undefined'\n    ? AUTO_GEAR_BACKUP_VISIBILITY_STORAGE_KEY\n    : 'cameraPowerPlanner_autoGearShowBackups';\nconst AUTO_GEAR_BACKUP_INTERVAL_MS = 10 * 60 * 1000;\nconst AUTO_GEAR_BACKUP_LIMIT = 12;\nconst AUTO_GEAR_MULTI_SELECT_MIN_ROWS = 8;\nconst AUTO_GEAR_MULTI_SELECT_MAX_ROWS = 12;\nconst TEMPERATURE_UNIT_STORAGE_KEY = 'cameraPowerPlanner_temperatureUnit';\nconst TEMPERATURE_UNITS = {\n  celsius: 'celsius',\n  fahrenheit: 'fahrenheit'\n};\nconst TEMPERATURE_SCENARIOS = [\n  { celsius: 40, factor: 1.0, color: '#d9534f' },\n  { celsius: 25, factor: 1.0, color: '#5cb85c' },\n  { celsius: 0, factor: 0.8, color: '#f0ad4e' },\n  { celsius: -10, factor: 0.625, color: '#5bc0de' },\n  { celsius: -20, factor: 0.5, color: '#0275d8' }\n];\nconst FEEDBACK_TEMPERATURE_MIN = -20;\nconst FEEDBACK_TEMPERATURE_MAX = 50;\nlet temperatureUnit = TEMPERATURE_UNITS.celsius;\nconst autoGearBackupDateFormatter =\n  typeof Intl !== 'undefined' && typeof Intl.DateTimeFormat === 'function'\n    ? new Intl.DateTimeFormat(undefined, { dateStyle: 'medium', timeStyle: 'short' })\n    : null;\n\nlet newCategorySelect;\nlet newSubcategorySelect;\nlet subcategoryFieldDiv;\nlet newNameInput;\nlet newWattInput;\nlet wattFieldDiv;\nlet dynamicFieldsDiv;\nlet cameraFieldsDiv;\nlet cameraWattInput;\nlet cameraVoltageInput;\nlet cameraPortTypeInput;\nlet monitorFieldsDiv;\nlet monitorScreenSizeInput;\nlet monitorBrightnessInput;\nlet monitorWattInput;\nlet monitorVoltageInput;\nlet monitorPortTypeInput;\nlet monitorVideoInputsContainer;\n\ntry {\n  if (typeof localStorage !== 'undefined') {\n    const storedTemperatureUnit = localStorage.getItem(TEMPERATURE_UNIT_STORAGE_KEY);\n    if (storedTemperatureUnit) {\n      temperatureUnit = normalizeTemperatureUnit(storedTemperatureUnit);\n    }\n  }\n} catch (error) {\n  console.warn('Could not load temperature unit preference', error);\n}\n\nconst schemaStorage = (() => {\n  if (typeof window === 'undefined') return null;\n  try {\n    if (!('localStorage' in window)) return null;\n    const { localStorage } = window;\n    const testKey = '__schema_cache__';\n    localStorage.setItem(testKey, '1');\n    localStorage.removeItem(testKey);\n    return localStorage;\n  } catch (error) {\n    console.warn('Device schema cache disabled', error);\n    return null;\n  }\n})();\n\nfunction loadCachedDeviceSchema() {\n  if (!schemaStorage) return null;\n  try {\n    const raw = schemaStorage.getItem(DEVICE_SCHEMA_STORAGE_KEY);\n    if (!raw) return null;\n    const parsed = JSON.parse(raw);\n    return parsed && typeof parsed === 'object' ? parsed : null;\n  } catch (error) {\n    console.warn('Failed to read cached device schema', error);\n    try {\n      schemaStorage.removeItem(DEVICE_SCHEMA_STORAGE_KEY);\n    } catch (removeError) {\n      console.warn('Failed to clear invalid cached device schema', removeError);\n    }\n    return null;\n  }\n}\n\nfunction persistDeviceSchema(schema) {\n  if (!schemaStorage) return;\n  try {\n    schemaStorage.setItem(DEVICE_SCHEMA_STORAGE_KEY, JSON.stringify(schema));\n  } catch (error) {\n    console.warn('Failed to cache device schema', error);\n  }\n}\n\nfunction isValidDeviceSchema(candidate) {\n  return candidate && typeof candidate === 'object' && !Array.isArray(candidate);\n}\n\nasync function loadDeviceSchemaFromCacheStorage() {\n  if (typeof caches === 'undefined' || !caches || typeof caches.match !== 'function') {\n    return null;\n  }\n\n  const candidates = new Set([DEVICE_SCHEMA_PATH]);\n  if (!DEVICE_SCHEMA_PATH.startsWith('./')) {\n    candidates.add(`./${DEVICE_SCHEMA_PATH}`);\n  }\n\n  if (typeof window !== 'undefined' && window.location) {\n    try {\n      candidates.add(new URL(DEVICE_SCHEMA_PATH, window.location.href).toString());\n    } catch (error) {\n      console.warn('Failed to resolve schema.json cache URL', error);\n    }\n  }\n\n  for (const url of candidates) {\n    try {\n      const response = await caches.match(url, { ignoreSearch: true });\n      if (response) {\n        return await response.clone().json();\n      }\n    } catch (error) {\n      console.warn('Failed to read schema.json from cache entry', url, error);\n    }\n  }\n\n  return null;\n}\n\n/**\n * Final step once a schema candidate has been retrieved.\n *\n * The schema can come from different places (bundled JSON, fetch, cache\n * storage, localStorage fallback). Centralizing the logic in a single helper\n * keeps the success path easy to reason about and guarantees that we only\n * call `populateCategoryOptions` once we have a valid object to work with.\n *\n * @param {unknown} candidate Potentially parsed schema object.\n */\nfunction finalizeDeviceSchemaLoad(candidate) {\n  if (isValidDeviceSchema(candidate)) {\n    deviceSchema = candidate;\n    persistDeviceSchema(candidate);\n  } else if (!deviceSchema) {\n    deviceSchema = cachedDeviceSchema || {};\n  }\n\n  populateCategoryOptions();\n}\n\nconst cachedDeviceSchema = loadCachedDeviceSchema();\n\nlet deviceSchema;\ntry {\n  deviceSchema = require('../data/schema.json');\n} catch {\n  // Falling back to the cached copy allows the app to keep functioning when\n  // users are offline, which is critical for field usage.\n  deviceSchema = cachedDeviceSchema;\n  if (typeof fetch === 'function') {\n    fetch(DEVICE_SCHEMA_PATH)\n      .then(response => {\n        if (!response || !response.ok) {\n          throw new Error(`Unexpected response when loading schema.json: ${response ? response.status : 'no response'}`);\n        }\n        return response.json();\n      })\n      .then(finalizeDeviceSchemaLoad)\n      .catch(error => {\n        console.warn('Failed to fetch schema.json', error);\n        if (typeof caches === 'undefined' || !caches || typeof caches.match !== 'function') {\n          finalizeDeviceSchemaLoad(deviceSchema);\n          return;\n        }\n\n        loadDeviceSchemaFromCacheStorage()\n          .then(schemaFromCache => {\n            if (isValidDeviceSchema(schemaFromCache)) {\n              finalizeDeviceSchemaLoad(schemaFromCache);\n            } else {\n              finalizeDeviceSchemaLoad(deviceSchema);\n            }\n          })\n          .catch(cacheError => {\n            console.warn('Failed to load schema.json from cache storage', cacheError);\n            finalizeDeviceSchemaLoad(deviceSchema);\n          });\n      });\n  } else {\n    finalizeDeviceSchemaLoad(deviceSchema);\n  }\n}\n\nconst LEGAL_LINKS = {\n  de: {\n    imprint: \"legal/impressum.html\",\n    privacy: \"legal/datenschutz.html\",\n  },\n  en: {\n    imprint: \"legal/impressum-en.html\",\n    privacy: \"legal/datenschutz-en.html\",\n  },\n  es: {\n    imprint: \"legal/impressum-es.html\",\n    privacy: \"legal/datenschutz-es.html\",\n  },\n  fr: {\n    imprint: \"legal/impressum-fr.html\",\n    privacy: \"legal/datenschutz-fr.html\",\n  },\n  it: {\n    imprint: \"legal/impressum-it.html\",\n    privacy: \"legal/datenschutz-it.html\",\n  },\n};\n\nconst AUTO_GEAR_CUSTOM_CATEGORY = '';\nconst GEAR_LIST_CATEGORIES = [\n  'Camera',\n  'Camera Support',\n  'Media',\n  'Lens',\n  'Lens Support',\n  'Matte box + filter',\n  'LDS (FIZ)',\n  'Camera Batteries',\n  'Monitoring Batteries',\n  'Chargers',\n  'Monitoring',\n  'Monitoring support',\n  'Rigging',\n  'Power',\n  'Grip',\n  'Carts and Transportation',\n  'Miscellaneous',\n  'Consumables',\n];\nconst AUTO_GEAR_SELECTOR_TYPES = ['none', 'monitor', 'directorMonitor'];\nconst AUTO_GEAR_SELECTOR_TYPE_SET = new Set(AUTO_GEAR_SELECTOR_TYPES);\n\n/**\n * Produce a deterministic-looking id for Auto Gear rules/presets.\n *\n * The IDs are stored alongside user data in localStorage, so we use the\n * strongest source of randomness that is available without requiring network\n * access. When `crypto.randomUUID` is not present we fall back to a timestamp\n * + Math.random combination to avoid collisions.\n *\n * @param {string} [prefix]\n * @returns {string}\n */\nfunction generateAutoGearId(prefix) {\n  const base = prefix || 'rule';\n  if (typeof crypto !== 'undefined' && crypto.randomUUID) {\n    return `${base}-${crypto.randomUUID()}`;\n  }\n  return `${base}-${Math.random().toString(36).slice(2)}-${Date.now()}`;\n}\n\n/**\n * Ensure that quantity values loaded from user input always resolve to a\n * positive integer. Keeping this logic in one place protects every feature\n * that relies on the quantity (lists, backups, exports, etc.) against\n * malformed form data.\n *\n * @param {unknown} value\n * @returns {number}\n */\nfunction normalizeAutoGearQuantity(value) {\n  const num = parseInt(value, 10);\n  return Number.isFinite(num) && num > 0 ? num : 1;\n}\n\n/**\n * Convert the multi-line textarea input for Auto Gear lists into a structured\n * array.\n *\n * Besides providing a nicer UI this helper also keeps the import/export\n * behaviour easy to audit because the exact parsing rules are documented in\n * one place.\n *\n * @param {unknown} value\n * @returns {Array<{ name: string, quantity?: number, listType?: 'add'|'remove' }>} Parsed entries.\n */\nfunction parseAutoGearDraftNames(value) {\n  if (typeof value !== 'string') return [];\n  const raw = value.trim();\n  if (!raw) return [];\n  const hasDelimiters = /[;\\n\\r]/.test(raw);\n  const parts = hasDelimiters ? raw.split(/[;\\n\\r]+/) : [raw];\n  return parts\n    .map(part => {\n      const segment = part.trim();\n      if (!segment) return null;\n      const signMatch = segment.match(/^([+-])\\s*(.+)$/);\n      const listType = signMatch ? (signMatch[1] === '-' ? 'remove' : 'add') : null;\n      const content = signMatch ? signMatch[2].trim() : segment;\n      if (!content) return null;\n      const quantityMatch = content.match(/^(\\d+)\\s*[x\xD7]\\s*(.+)$/i);\n      if (quantityMatch) {\n        const name = quantityMatch[2].trim();\n        if (!name) return null;\n        return { name, quantity: normalizeAutoGearQuantity(quantityMatch[1]), listType };\n      }\n      return { name: content, listType };\n    })\n    .filter(Boolean);\n}\n\n/**\n * Shared helper that normalizes free-text fields used across the Auto Gear UI\n * and persistence layer. Normalization protects user data from spurious\n * whitespace differences when synchronizing or restoring from backups.\n *\n * @param {unknown} value Raw input value.\n * @param {{ collapseWhitespace?: boolean }} [options]\n * @returns {string}\n */\nfunction normalizeAutoGearText(value, { collapseWhitespace = true } = {}) {\n  if (typeof value === 'number' && Number.isFinite(value)) {\n    return String(value);\n  }\n  if (typeof value !== 'string') return '';\n  const trimmed = value.trim();\n  if (!collapseWhitespace) return trimmed;\n  return trimmed.replace(/\\s+/g, ' ');\n}\n\n/**\n * Normalize selector types to one of the supported strings so that stored\n * rules remain compatible even if the list of valid selectors is extended in\n * the future.\n *\n * @param {unknown} value\n * @returns {'none'|'monitor'|'directorMonitor'}\n */\nfunction normalizeAutoGearSelectorType(value) {\n  const candidate = typeof value === 'string' ? value.trim().toLowerCase() : '';\n  if (!candidate) return 'none';\n  return AUTO_GEAR_SELECTOR_TYPE_SET.has(candidate) ? candidate : 'none';\n}\n\n/**\n * Make sure the default value for selector inputs is both human readable and\n * validated against the available options so that restoring backups never\n * yields an impossible selection.\n *\n * @param {'none'|'monitor'|'directorMonitor'} type\n * @param {unknown} value\n * @returns {string}\n */\nfunction normalizeAutoGearSelectorDefault(type, value) {\n  const text = normalizeAutoGearText(value);\n  if (!text) return '';\n  const options = getAutoGearSelectorOptions(type);\n  if (!options.length) return text;\n  const match = options.find(option => option.toLowerCase() === text.toLowerCase());\n  return match || text;\n}\n\nfunction getAutoGearSelectorOptions(type) {\n  const normalizedType = normalizeAutoGearSelectorType(type);\n  if (normalizedType === 'monitor') {\n    const monitorDb = devices && devices.monitors ? devices.monitors : null;\n    if (!monitorDb || typeof monitorDb !== 'object') return [];\n    return Object.keys(monitorDb).filter(name => name && name !== 'None').sort(localeSort);\n  }\n  if (normalizedType === 'directorMonitor') {\n    const directorDb = devices && devices.directorMonitors ? devices.directorMonitors : null;\n    if (!directorDb || typeof directorDb !== 'object') return [];\n    return Object.keys(directorDb).filter(name => name && name !== 'None').sort(localeSort);\n  }\n  return [];\n}\n\nfunction getAutoGearSelectorLabel(type) {\n  const normalizedType = normalizeAutoGearSelectorType(type);\n  const langTexts = texts[currentLang] || texts.en || {};\n  if (normalizedType === 'monitor') {\n    return langTexts.autoGearSelectorMonitorOption\n      || texts.en?.autoGearSelectorMonitorOption\n      || 'Monitor selector';\n  }\n  if (normalizedType === 'directorMonitor') {\n    return langTexts.autoGearSelectorDirectorOption\n      || texts.en?.autoGearSelectorDirectorOption\n      || 'Director monitor selector';\n  }\n  return langTexts.autoGearSelectorNoneOption\n    || texts.en?.autoGearSelectorNoneOption\n    || 'No selector';\n}\n\nfunction getAutoGearSelectorScrollHint() {\n  const langTexts = texts[currentLang] || texts.en || {};\n  return langTexts.autoGearSelectorScrollHint\n    || texts.en?.autoGearSelectorScrollHint\n    || 'Scroll to see more devices.';\n}\n\nfunction isAutoGearMonitoringCategory(value) {\n  if (typeof value !== 'string') return false;\n  return value.trim().toLowerCase() === 'monitoring';\n}\n\nfunction updateAutoGearMonitorFieldGroup(group) {\n  if (!group || !group.select) return;\n  const {\n    select,\n    screenSizeField,\n    screenSizeInput,\n    selectorTypeField,\n    selectorTypeSelect,\n    selectorDefaultField,\n    selectorDefaultInput,\n    selectorIncludeField,\n    selectorIncludeCheckbox,\n  } = group;\n  const isMonitoring = isAutoGearMonitoringCategory(select.value || '');\n  const managedFields = [screenSizeField, selectorTypeField, selectorDefaultField, selectorIncludeField];\n  managedFields.forEach(field => {\n    if (!field) return;\n    if (isMonitoring) {\n      field.removeAttribute('hidden');\n    } else {\n      field.setAttribute('hidden', '');\n    }\n  });\n  if (!isMonitoring) {\n    if (screenSizeInput) screenSizeInput.value = '';\n    if (selectorTypeSelect) selectorTypeSelect.value = 'none';\n    if (selectorDefaultInput) selectorDefaultInput.value = '';\n    if (selectorIncludeCheckbox) selectorIncludeCheckbox.checked = false;\n  }\n}\n\nfunction normalizeAutoGearItem(entry) {\n  if (!entry || typeof entry !== 'object') return null;\n  const name = normalizeAutoGearText(entry.name);\n  if (!name) return null;\n  const category = normalizeAutoGearText(entry.category);\n  const quantity = normalizeAutoGearQuantity(entry.quantity);\n  const id = typeof entry.id === 'string' && entry.id ? entry.id : generateAutoGearId('item');\n  const screenSize = normalizeAutoGearText(entry.screenSize);\n  const selectorType = normalizeAutoGearSelectorType(entry.selectorType);\n  const selectorDefault = normalizeAutoGearSelectorDefault(selectorType, entry.selectorDefault);\n  const selectorEnabled = !!entry.selectorEnabled;\n  const notes = normalizeAutoGearText(entry.notes);\n  return { id, name, category, quantity, screenSize, selectorType, selectorDefault, selectorEnabled, notes };\n}\n\nfunction normalizeAutoGearTriggerList(values) {\n  if (!Array.isArray(values)) return [];\n  return Array.from(new Set(values\n    .map(value => (typeof value === 'string' ? value.trim() : ''))\n    .filter(Boolean)));\n}\n\nfunction normalizeVideoDistributionTriggerList(values) {\n  if (!Array.isArray(values)) return [];\n  const base = normalizeAutoGearTriggerList(values);\n  const seen = new Set();\n  const result = [];\n  base.forEach(value => {\n    const lower = value.toLowerCase();\n    const normalized = lower === '__none__' || lower === 'none'\n      ? '__none__'\n      : value;\n    if (!normalized || seen.has(normalized)) return;\n    seen.add(normalized);\n    result.push(normalized);\n  });\n  return result;\n}\n\nfunction normalizeAutoGearTriggerValue(value) {\n  return typeof value === 'string' ? value.trim().toLowerCase() : '';\n}\n\nfunction autoGearRuleMatteboxKey(rule) {\n  if (!rule || typeof rule !== 'object') return '';\n  const matteboxList = Array.isArray(rule.mattebox) ? rule.mattebox : [];\n  if (!matteboxList.length) return '';\n  return matteboxList\n    .map(normalizeAutoGearTriggerValue)\n    .filter(Boolean)\n    .sort((a, b) => a.localeCompare(b))\n    .join('|');\n}\n\nfunction normalizeAutoGearRule(rule) {\n  if (!rule || typeof rule !== 'object') return null;\n  const id = typeof rule.id === 'string' && rule.id ? rule.id : generateAutoGearId('rule');\n  const label = typeof rule.label === 'string' ? rule.label.trim() : '';\n  const scenarios = normalizeAutoGearTriggerList(rule.scenarios).sort((a, b) => a.localeCompare(b));\n  const mattebox = normalizeAutoGearTriggerList(rule.mattebox).sort((a, b) => a.localeCompare(b));\n  const cameraHandle = normalizeAutoGearTriggerList(rule.cameraHandle).sort((a, b) => a.localeCompare(b));\n  const viewfinderExtension = normalizeAutoGearTriggerList(rule.viewfinderExtension).sort((a, b) => a.localeCompare(b));\n  const videoDistribution = normalizeVideoDistributionTriggerList(rule.videoDistribution)\n    .sort((a, b) => a.localeCompare(b));\n  const camera = normalizeAutoGearTriggerList(rule.camera).sort((a, b) => a.localeCompare(b));\n  const monitor = normalizeAutoGearTriggerList(rule.monitor).sort((a, b) => a.localeCompare(b));\n  const wireless = normalizeAutoGearTriggerList(rule.wireless).sort((a, b) => a.localeCompare(b));\n  const motors = normalizeAutoGearTriggerList(rule.motors).sort((a, b) => a.localeCompare(b));\n  const controllers = normalizeAutoGearTriggerList(rule.controllers).sort((a, b) => a.localeCompare(b));\n  const distance = normalizeAutoGearTriggerList(rule.distance).sort((a, b) => a.localeCompare(b));\n  if (\n    !scenarios.length\n    && !mattebox.length\n    && !cameraHandle.length\n    && !viewfinderExtension.length\n    && !videoDistribution.length\n    && !camera.length\n    && !monitor.length\n    && !wireless.length\n    && !motors.length\n    && !controllers.length\n    && !distance.length\n  ) return null;\n  const add = Array.isArray(rule.add) ? rule.add.map(normalizeAutoGearItem).filter(Boolean) : [];\n  const remove = Array.isArray(rule.remove) ? rule.remove.map(normalizeAutoGearItem).filter(Boolean) : [];\n  if (!add.length && !remove.length) return null;\n  return {\n    id,\n    label,\n    scenarios,\n    mattebox,\n    cameraHandle,\n    viewfinderExtension,\n    videoDistribution,\n    camera,\n    monitor,\n    wireless,\n    motors,\n    controllers,\n    distance,\n    add,\n    remove,\n  };\n}\n\nfunction autoGearItemSnapshot(item) {\n  const normalized = normalizeAutoGearItem(item);\n  if (!normalized) {\n    return {\n      name: '',\n      category: '',\n      quantity: 0,\n      screenSize: '',\n      selectorType: 'none',\n      selectorDefault: '',\n      selectorEnabled: false,\n      notes: '',\n    };\n  }\n  const {\n    name,\n    category,\n    quantity,\n    screenSize,\n    selectorType,\n    selectorDefault,\n    selectorEnabled,\n    notes,\n  } = normalized;\n  return {\n    name,\n    category,\n    quantity: normalizeAutoGearQuantity(quantity),\n    screenSize,\n    selectorType,\n    selectorDefault,\n    selectorEnabled,\n    notes,\n  };\n}\n\nfunction autoGearItemSortKey(item) {\n  const snapshot = autoGearItemSnapshot(item);\n  const name = snapshot.name || '';\n  const category = snapshot.category || '';\n  const quantity = normalizeAutoGearQuantity(snapshot.quantity);\n  const screenSize = snapshot.screenSize || '';\n  const selectorType = snapshot.selectorType || 'none';\n  const selectorDefault = snapshot.selectorDefault || '';\n  const selectorEnabled = snapshot.selectorEnabled ? '1' : '0';\n  const notes = snapshot.notes || '';\n  return `${name}|${category}|${quantity}|${screenSize}|${selectorType}|${selectorEnabled}|${selectorDefault}|${notes}`;\n}\n\nfunction snapshotAutoGearRuleForFingerprint(rule) {\n  const normalized = normalizeAutoGearRule(rule);\n  if (!normalized) return null;\n  const mapItems = items => items\n    .map(autoGearItemSnapshot)\n    .sort((a, b) => autoGearItemSortKey(a).localeCompare(autoGearItemSortKey(b)));\n  return {\n    label: normalized.label || '',\n    scenarios: normalized.scenarios.slice().sort((a, b) => a.localeCompare(b)),\n    mattebox: normalized.mattebox.slice().sort((a, b) => a.localeCompare(b)),\n    cameraHandle: normalized.cameraHandle.slice().sort((a, b) => a.localeCompare(b)),\n    viewfinderExtension: normalized.viewfinderExtension.slice().sort((a, b) => a.localeCompare(b)),\n    videoDistribution: normalized.videoDistribution.slice().sort((a, b) => a.localeCompare(b)),\n    camera: normalized.camera.slice().sort((a, b) => a.localeCompare(b)),\n    monitor: normalized.monitor.slice().sort((a, b) => a.localeCompare(b)),\n    wireless: normalized.wireless.slice().sort((a, b) => a.localeCompare(b)),\n    motors: normalized.motors.slice().sort((a, b) => a.localeCompare(b)),\n    controllers: normalized.controllers.slice().sort((a, b) => a.localeCompare(b)),\n    distance: normalized.distance.slice().sort((a, b) => a.localeCompare(b)),\n    add: mapItems(normalized.add),\n    remove: mapItems(normalized.remove),\n  };\n}\n\nfunction autoGearRuleSortKey(rule) {\n  const scenarioKey = Array.isArray(rule.scenarios) ? rule.scenarios.join('|') : '';\n  const matteboxKey = Array.isArray(rule.mattebox) ? rule.mattebox.join('|') : '';\n  const cameraHandleKey = Array.isArray(rule.cameraHandle) ? rule.cameraHandle.join('|') : '';\n  const viewfinderKey = Array.isArray(rule.viewfinderExtension) ? rule.viewfinderExtension.join('|') : '';\n  const videoDistributionKey = Array.isArray(rule.videoDistribution) ? rule.videoDistribution.join('|') : '';\n  const cameraKey = Array.isArray(rule.camera) ? rule.camera.join('|') : '';\n  const monitorKey = Array.isArray(rule.monitor) ? rule.monitor.join('|') : '';\n  const wirelessKey = Array.isArray(rule.wireless) ? rule.wireless.join('|') : '';\n  const motorsKey = Array.isArray(rule.motors) ? rule.motors.join('|') : '';\n  const controllersKey = Array.isArray(rule.controllers) ? rule.controllers.join('|') : '';\n  const distanceKey = Array.isArray(rule.distance) ? rule.distance.join('|') : '';\n  const addKey = Array.isArray(rule.add) ? rule.add.map(autoGearItemSortKey).join('|') : '';\n  const removeKey = Array.isArray(rule.remove) ? rule.remove.map(autoGearItemSortKey).join('|') : '';\n  return `${scenarioKey}|${matteboxKey}|${cameraHandleKey}|${viewfinderKey}|${videoDistributionKey}|${cameraKey}|${monitorKey}|${wirelessKey}|${motorsKey}|${controllersKey}|${distanceKey}|${rule.label || ''}|${addKey}|${removeKey}`;\n}\n\nfunction createAutoGearRulesFingerprint(rules) {\n  const snapshot = (Array.isArray(rules) ? rules : [])\n    .map(snapshotAutoGearRuleForFingerprint)\n    .filter(Boolean)\n    .sort((a, b) => autoGearRuleSortKey(a).localeCompare(autoGearRuleSortKey(b)));\n  return stableStringify(snapshot);\n}\n\nfunction normalizeAutoGearPreset(entry) {\n  if (!entry || typeof entry !== 'object') return null;\n  const label = typeof entry.label === 'string' ? entry.label.trim() : '';\n  if (!label) return null;\n  const rawRules = Array.isArray(entry.rules) ? entry.rules : [];\n  const rules = rawRules.map(normalizeAutoGearRule).filter(Boolean);\n  const id = typeof entry.id === 'string' && entry.id ? entry.id : generateAutoGearId('preset');\n  const fingerprint = createAutoGearRulesFingerprint(rules);\n  return { id, label, rules, fingerprint };\n}\n\nfunction normalizeAutoGearBackupEntry(entry) {\n  if (!entry || typeof entry !== 'object') return null;\n  const rawCreatedAt = typeof entry.createdAt === 'string' ? entry.createdAt : null;\n  const timestamp = rawCreatedAt ? Date.parse(rawCreatedAt) : NaN;\n  if (!Number.isFinite(timestamp)) return null;\n  const createdAt = new Date(timestamp).toISOString();\n  const rawRules = Array.isArray(entry.rules) ? entry.rules : [];\n  const normalizedRules = rawRules.map(normalizeAutoGearRule).filter(Boolean);\n  const rules = rawRules.length === 0 ? [] : normalizedRules;\n  const id = typeof entry.id === 'string' && entry.id ? entry.id : generateAutoGearId('backup');\n  return { id, createdAt, rules };\n}\n\nfunction readAutoGearBackupsFromStorage() {\n  let stored = [];\n  if (typeof loadAutoGearBackups === 'function') {\n    try {\n      stored = loadAutoGearBackups();\n    } catch (error) {\n      console.warn('Failed to load automatic gear backups', error);\n      stored = [];\n    }\n  } else if (typeof localStorage !== 'undefined') {\n    try {\n      const raw = localStorage.getItem(AUTO_GEAR_BACKUPS_KEY);\n      stored = raw ? JSON.parse(raw) : [];\n    } catch (error) {\n      console.warn('Failed to read automatic gear backups from storage', error);\n      stored = [];\n    }\n  }\n  if (!Array.isArray(stored)) return [];\n  return stored\n    .map(normalizeAutoGearBackupEntry)\n    .filter(Boolean)\n    .sort((a, b) => {\n      if (a.createdAt === b.createdAt) return 0;\n      return a.createdAt > b.createdAt ? -1 : 1;\n    })\n    .slice(0, AUTO_GEAR_BACKUP_LIMIT);\n}\n\nfunction sortAutoGearPresets(list) {\n  return list.sort((a, b) => a.label.localeCompare(b.label, undefined, { sensitivity: 'base', numeric: true }));\n}\n\nfunction readAutoGearPresetsFromStorage() {\n  let stored = [];\n  if (typeof loadAutoGearPresets === 'function') {\n    try {\n      stored = loadAutoGearPresets();\n    } catch (error) {\n      console.warn('Failed to load automatic gear presets', error);\n      stored = [];\n    }\n  } else if (typeof localStorage !== 'undefined') {\n    try {\n      const raw = localStorage.getItem(AUTO_GEAR_PRESETS_KEY);\n      stored = raw ? JSON.parse(raw) : [];\n    } catch (error) {\n      console.warn('Failed to read automatic gear presets from storage', error);\n      stored = [];\n    }\n  }\n  if (!Array.isArray(stored)) return [];\n  return sortAutoGearPresets(stored.map(normalizeAutoGearPreset).filter(Boolean));\n}\n\nfunction persistAutoGearPresets(presets) {\n  const payload = Array.isArray(presets)\n    ? presets.map(preset => ({\n        id: preset.id,\n        label: preset.label,\n        rules: Array.isArray(preset.rules) ? preset.rules : [],\n      }))\n    : [];\n  if (typeof saveAutoGearPresets === 'function') {\n    try {\n      saveAutoGearPresets(payload);\n      return;\n    } catch (error) {\n      console.warn('Failed to save automatic gear presets', error);\n    }\n  }\n  if (typeof localStorage === 'undefined') return;\n  try {\n    localStorage.setItem(AUTO_GEAR_PRESETS_KEY, JSON.stringify(payload));\n  } catch (error) {\n    console.warn('Failed to persist automatic gear presets', error);\n  }\n}\n\nfunction readActiveAutoGearPresetIdFromStorage() {\n  if (typeof loadAutoGearActivePresetId === 'function') {\n    try {\n      const value = loadAutoGearActivePresetId();\n      return typeof value === 'string' ? value : '';\n    } catch (error) {\n      console.warn('Failed to load automatic gear active preset id', error);\n      return '';\n    }\n  }\n  if (typeof localStorage === 'undefined') return '';\n  try {\n    const value = localStorage.getItem(AUTO_GEAR_ACTIVE_PRESET_KEY);\n    return typeof value === 'string' ? value : '';\n  } catch (error) {\n    console.warn('Failed to read automatic gear active preset id from storage', error);\n    return '';\n  }\n}\n\nfunction persistActiveAutoGearPresetId(presetId) {\n  if (typeof saveAutoGearActivePresetId === 'function') {\n    try {\n      saveAutoGearActivePresetId(typeof presetId === 'string' ? presetId : '');\n      return;\n    } catch (error) {\n      console.warn('Failed to save automatic gear active preset id', error);\n    }\n  }\n  if (typeof localStorage === 'undefined') return;\n  try {\n    if (presetId) {\n      localStorage.setItem(AUTO_GEAR_ACTIVE_PRESET_KEY, presetId);\n    } else {\n      localStorage.removeItem(AUTO_GEAR_ACTIVE_PRESET_KEY);\n    }\n  } catch (error) {\n    console.warn('Failed to persist automatic gear active preset id', error);\n  }\n}\n\nfunction readAutoGearAutoPresetIdFromStorage() {\n  if (typeof loadAutoGearAutoPresetId === 'function') {\n    try {\n      const value = loadAutoGearAutoPresetId();\n      return typeof value === 'string' ? value : '';\n    } catch (error) {\n      console.warn('Failed to load automatic gear auto preset id', error);\n      return '';\n    }\n  }\n  if (typeof localStorage === 'undefined') return '';\n  try {\n    const value = localStorage.getItem(AUTO_GEAR_AUTO_PRESET_KEY);\n    return typeof value === 'string' ? value : '';\n  } catch (error) {\n    console.warn('Failed to read automatic gear auto preset id from storage', error);\n    return '';\n  }\n}\n\nfunction persistAutoGearAutoPresetId(presetId) {\n  if (typeof saveAutoGearAutoPresetId === 'function') {\n    try {\n      saveAutoGearAutoPresetId(typeof presetId === 'string' ? presetId : '');\n      return;\n    } catch (error) {\n      console.warn('Failed to save automatic gear auto preset id', error);\n    }\n  }\n  if (typeof localStorage === 'undefined') return;\n  try {\n    if (presetId) {\n      localStorage.setItem(AUTO_GEAR_AUTO_PRESET_KEY, presetId);\n    } else {\n      localStorage.removeItem(AUTO_GEAR_AUTO_PRESET_KEY);\n    }\n  } catch (error) {\n    console.warn('Failed to persist automatic gear auto preset id', error);\n  }\n}\n\nfunction readAutoGearBackupVisibilityFromStorage() {\n  if (typeof loadAutoGearBackupVisibility === 'function') {\n    try {\n      return !!loadAutoGearBackupVisibility();\n    } catch (error) {\n      console.warn('Failed to load automatic gear backup visibility', error);\n      return false;\n    }\n  }\n  if (typeof localStorage === 'undefined') return false;\n  try {\n    return localStorage.getItem(AUTO_GEAR_BACKUP_VISIBILITY_KEY) === '1';\n  } catch (error) {\n    console.warn('Failed to read automatic gear backup visibility from storage', error);\n    return false;\n  }\n}\n\nfunction persistAutoGearBackupVisibility(flag) {\n  const enabled = !!flag;\n  if (typeof saveAutoGearBackupVisibility === 'function') {\n    try {\n      saveAutoGearBackupVisibility(enabled);\n      return;\n    } catch (error) {\n      console.warn('Failed to save automatic gear backup visibility', error);\n    }\n  }\n  if (typeof localStorage === 'undefined') return;\n  try {\n    if (enabled) {\n      localStorage.setItem(AUTO_GEAR_BACKUP_VISIBILITY_KEY, '1');\n    } else {\n      localStorage.removeItem(AUTO_GEAR_BACKUP_VISIBILITY_KEY);\n    }\n  } catch (error) {\n    console.warn('Failed to persist automatic gear backup visibility', error);\n  }\n}\n\nfunction persistAutoGearBackups(backups) {\n  const payload = Array.isArray(backups)\n    ? backups.map(entry => ({\n        id: entry.id,\n        createdAt: entry.createdAt,\n        rules: Array.isArray(entry.rules) ? entry.rules : [],\n      }))\n    : [];\n  if (typeof saveAutoGearBackups === 'function') {\n    saveAutoGearBackups(payload);\n    return;\n  }\n  if (typeof localStorage === 'undefined') {\n    throw new Error('Storage unavailable');\n  }\n  localStorage.setItem(AUTO_GEAR_BACKUPS_KEY, JSON.stringify(payload));\n}\n\nfunction readAutoGearRulesFromStorage() {\n  let stored = [];\n  if (typeof loadAutoGearRules !== 'undefined' && typeof loadAutoGearRules === 'function') {\n    try {\n      stored = loadAutoGearRules();\n    } catch (error) {\n      console.warn('Failed to load automatic gear rules', error);\n      stored = [];\n    }\n  } else if (typeof localStorage !== 'undefined') {\n    try {\n      const raw = localStorage.getItem(AUTO_GEAR_RULES_KEY);\n      stored = raw ? JSON.parse(raw) : [];\n    } catch (error) {\n      console.warn('Failed to load automatic gear rules', error);\n      stored = [];\n    }\n  }\n  if (!Array.isArray(stored)) return [];\n  return stored.map(normalizeAutoGearRule).filter(Boolean);\n}\n\nlet autoGearRules = readAutoGearRulesFromStorage();\nlet baseAutoGearRules = autoGearRules.slice();\nlet projectScopedAutoGearRules = null;\nlet autoGearBackups = readAutoGearBackupsFromStorage();\nlet autoGearPresets = readAutoGearPresetsFromStorage();\nlet activeAutoGearPresetId = readActiveAutoGearPresetIdFromStorage();\nlet autoGearAutoPresetId = readAutoGearAutoPresetIdFromStorage();\nlet autoGearBackupsVisible = readAutoGearBackupVisibilityFromStorage();\nlet factoryAutoGearRulesSnapshot = null;\nlet factoryAutoGearSeedContext = null;\nconst initialAutoGearRulesSignature = stableStringify(autoGearRules);\nlet autoGearRulesLastBackupSignature = autoGearBackups.length\n  ? stableStringify(autoGearBackups[0].rules || [])\n  : initialAutoGearRulesSignature;\nlet autoGearRulesLastPersistedSignature = initialAutoGearRulesSignature;\nlet autoGearRulesDirtySinceBackup =\n  autoGearRulesLastPersistedSignature !== autoGearRulesLastBackupSignature;\n\nreconcileAutoGearAutoPresetState({ persist: true, skipRender: true });\nalignActiveAutoGearPreset({ skipRender: true });\n\nfunction assignAutoGearRules(rules) {\n  autoGearRules = Array.isArray(rules)\n    ? rules.map(normalizeAutoGearRule).filter(Boolean)\n    : [];\n  return autoGearRules;\n}\n\nfunction syncBaseAutoGearRulesState() {\n  const signature = stableStringify(baseAutoGearRules);\n  autoGearRulesLastPersistedSignature = signature;\n  autoGearRulesDirtySinceBackup = signature !== autoGearRulesLastBackupSignature;\n}\n\nfunction persistAutoGearRules() {\n  if (typeof saveAutoGearRules !== 'undefined' && typeof saveAutoGearRules === 'function') {\n    try {\n      saveAutoGearRules(autoGearRules);\n      return;\n    } catch (error) {\n      console.warn('Failed to save automatic gear rules', error);\n    }\n  }\n  if (typeof localStorage === 'undefined') return;\n  try {\n    localStorage.setItem(AUTO_GEAR_RULES_KEY, JSON.stringify(autoGearRules));\n  } catch (error) {\n    console.warn('Failed to save automatic gear rules', error);\n  }\n}\n\nfunction setAutoGearRules(rules) {\n  const normalized = assignAutoGearRules(rules);\n  baseAutoGearRules = normalized.slice();\n  projectScopedAutoGearRules = null;\n  persistAutoGearRules();\n  syncBaseAutoGearRulesState();\n  alignActiveAutoGearPreset({ skipRender: true });\n  syncAutoGearAutoPreset(normalized);\n  renderAutoGearPresetsControls();\n}\n\nfunction getAutoGearRules() {\n  return autoGearRules.slice();\n}\n\nfunction syncAutoGearRulesFromStorage(rules) {\n  if (Array.isArray(rules)) {\n    setAutoGearRules(rules);\n  } else {\n    baseAutoGearRules = readAutoGearRulesFromStorage();\n    projectScopedAutoGearRules = null;\n    assignAutoGearRules(baseAutoGearRules);\n    syncBaseAutoGearRulesState();\n  }\n  autoGearBackups = readAutoGearBackupsFromStorage();\n  autoGearPresets = readAutoGearPresetsFromStorage();\n  activeAutoGearPresetId = readActiveAutoGearPresetIdFromStorage();\n  autoGearAutoPresetId = readAutoGearAutoPresetIdFromStorage();\n  autoGearBackupsVisible = readAutoGearBackupVisibilityFromStorage();\n  reconcileAutoGearAutoPresetState({ persist: true, skipRender: true });\n  syncAutoGearAutoPreset(baseAutoGearRules);\n  alignActiveAutoGearPreset({ skipRender: true });\n  renderAutoGearBackupControls();\n  renderAutoGearPresetsControls();\n  closeAutoGearEditor();\n  renderAutoGearRulesList();\n  updateAutoGearCatalogOptions();\n}\n\nfunction useProjectAutoGearRules(rules) {\n  if (Array.isArray(rules) && rules.length) {\n    projectScopedAutoGearRules = assignAutoGearRules(rules).slice();\n  } else {\n    projectScopedAutoGearRules = null;\n    assignAutoGearRules(baseAutoGearRules);\n  }\n}\n\nfunction clearProjectAutoGearRules() {\n  if (!projectScopedAutoGearRules || !projectScopedAutoGearRules.length) {\n    projectScopedAutoGearRules = null;\n    assignAutoGearRules(baseAutoGearRules);\n    return;\n  }\n  projectScopedAutoGearRules = null;\n  assignAutoGearRules(baseAutoGearRules);\n}\n\nfunction getProjectScopedAutoGearRules() {\n  return projectScopedAutoGearRules ? projectScopedAutoGearRules.slice() : null;\n}\n\nfunction usingProjectAutoGearRules() {\n  return Array.isArray(projectScopedAutoGearRules) && projectScopedAutoGearRules.length > 0;\n}\n\nfunction getBaseAutoGearRules() {\n  return baseAutoGearRules.slice();\n}\n\nfunction autoGearRuleSignature(rule) {\n  const snapshot = snapshotAutoGearRuleForFingerprint(rule);\n  if (!snapshot) return '';\n  return stableStringify(snapshot);\n}\n\nfunction mergeAutoGearRules(existing, incoming) {\n  const normalizedExisting = Array.isArray(existing)\n    ? existing.map(normalizeAutoGearRule).filter(Boolean)\n    : [];\n  const seen = new Set(normalizedExisting.map(autoGearRuleSignature));\n  (Array.isArray(incoming) ? incoming : []).forEach(rule => {\n    const normalized = normalizeAutoGearRule(rule);\n    if (!normalized) return;\n    const signature = autoGearRuleSignature(normalized);\n    if (seen.has(signature)) return;\n    normalizedExisting.push(normalized);\n    seen.add(signature);\n  });\n  return normalizedExisting;\n}\n\nfunction looksLikeGearName(name) {\n  return typeof name === 'string' && name !== 'None' && (/[A-Z]/.test(name) || /\\d/.test(name) || name.includes(' '));\n}\n\nfunction hasSeededAutoGearDefaults() {\n  if (typeof loadAutoGearSeedFlag !== 'undefined' && typeof loadAutoGearSeedFlag === 'function') {\n    try {\n      return !!loadAutoGearSeedFlag();\n    } catch (error) {\n      console.warn('Failed to read automatic gear seed flag', error);\n      return false;\n    }\n  }\n  if (typeof localStorage === 'undefined') return false;\n  try {\n    return localStorage.getItem(AUTO_GEAR_SEEDED_KEY) === '1';\n  } catch (error) {\n    console.warn('Failed to read automatic gear seed flag', error);\n    return false;\n  }\n}\n\nfunction markAutoGearDefaultsSeeded() {\n  if (typeof saveAutoGearSeedFlag !== 'undefined' && typeof saveAutoGearSeedFlag === 'function') {\n    try {\n      saveAutoGearSeedFlag(true);\n      return;\n    } catch (error) {\n      console.warn('Failed to persist automatic gear seed flag', error);\n    }\n  }\n  if (typeof localStorage === 'undefined') return;\n  try {\n    localStorage.setItem(AUTO_GEAR_SEEDED_KEY, '1');\n  } catch (error) {\n    console.warn('Failed to persist automatic gear seed flag', error);\n  }\n}\n\nfunction clearAutoGearDefaultsSeeded() {\n  if (typeof saveAutoGearSeedFlag !== 'undefined' && typeof saveAutoGearSeedFlag === 'function') {\n    try {\n      saveAutoGearSeedFlag(false);\n      return;\n    } catch (error) {\n      console.warn('Failed to clear automatic gear seed flag', error);\n    }\n  }\n  if (typeof localStorage === 'undefined') return;\n  try {\n    localStorage.removeItem(AUTO_GEAR_SEEDED_KEY);\n  } catch (error) {\n    console.warn('Failed to clear automatic gear seed flag', error);\n  }\n}\n\nfunction parseGearTableForAutoRules(html) {\n  if (!html || typeof DOMParser !== 'function') return null;\n  let doc;\n  try {\n    doc = new DOMParser().parseFromString(html, 'text/html');\n  } catch (error) {\n    console.warn('Failed to parse gear table for automatic rule seeding', error);\n    return null;\n  }\n  const table = doc.querySelector('.gear-table');\n  if (!table) return null;\n  const categoryMaps = new Map();\n  table.querySelectorAll('tbody.category-group').forEach(group => {\n    const header = group.querySelector('.category-row td');\n    if (!header) return;\n    const category = header.textContent ? header.textContent.trim() : '';\n    if (!category) return;\n    const items = categoryMaps.get(category) || new Map();\n    group.querySelectorAll('.gear-item').forEach(span => {\n      const name = span.getAttribute('data-gear-name');\n      if (!looksLikeGearName(name)) return;\n      const text = span.textContent ? span.textContent.trim() : '';\n      const match = text.match(/^(\\d+)x\\s+/);\n      const quantity = match ? parseInt(match[1], 10) : 1;\n      if (!Number.isFinite(quantity) || quantity <= 0) return;\n      items.set(name, (items.get(name) || 0) + quantity);\n    });\n    if (items.size) categoryMaps.set(category, items);\n  });\n  return categoryMaps;\n}\n\nfunction diffGearTableMaps(baseMap, variantMap) {\n  if (!baseMap || !variantMap) return { add: [], remove: [] };\n  const add = [];\n  const remove = [];\n  const categories = new Set([...baseMap.keys(), ...variantMap.keys()]);\n  categories.forEach(category => {\n    const baseItems = baseMap.get(category) || new Map();\n    const variantItems = variantMap.get(category) || new Map();\n    const names = new Set([...baseItems.keys(), ...variantItems.keys()]);\n    names.forEach(name => {\n      const baseQty = baseItems.get(name) || 0;\n      const variantQty = variantItems.get(name) || 0;\n      if (variantQty > baseQty) {\n        add.push({ name, category, quantity: variantQty - baseQty });\n      } else if (variantQty < baseQty) {\n        remove.push({ name, category, quantity: baseQty - variantQty });\n      }\n    });\n  });\n  return { add, remove };\n}\n\nfunction cloneAutoGearItems(items) {\n  return items\n    .map(item => {\n      const normalized = normalizeAutoGearItem(item);\n      if (!normalized) return null;\n      return { ...normalized };\n    })\n    .filter(Boolean);\n}\n\nfunction cloneAutoGearRuleItem(item) {\n  if (!item || typeof item !== 'object') {\n    return {\n      id: '',\n      name: '',\n      category: '',\n      quantity: 0,\n      screenSize: '',\n      selectorType: 'none',\n      selectorDefault: '',\n      selectorEnabled: false,\n      notes: '',\n    };\n  }\n  return {\n    id: typeof item.id === 'string' ? item.id : '',\n    name: typeof item.name === 'string' ? item.name : '',\n    category: typeof item.category === 'string' ? item.category : '',\n    quantity: normalizeAutoGearQuantity(item.quantity),\n    screenSize: typeof item.screenSize === 'string' ? item.screenSize : '',\n    selectorType: typeof item.selectorType === 'string' ? item.selectorType : 'none',\n    selectorDefault: typeof item.selectorDefault === 'string' ? item.selectorDefault : '',\n    selectorEnabled: !!item.selectorEnabled,\n    notes: typeof item.notes === 'string' ? item.notes : '',\n  };\n}\n\nfunction cloneAutoGearRule(rule) {\n  if (!rule || typeof rule !== 'object') return null;\n  return {\n    id: typeof rule.id === 'string' ? rule.id : '',\n    label: typeof rule.label === 'string' ? rule.label : '',\n    scenarios: Array.isArray(rule.scenarios) ? rule.scenarios.slice() : [],\n    mattebox: Array.isArray(rule.mattebox) ? rule.mattebox.slice() : [],\n    cameraHandle: Array.isArray(rule.cameraHandle) ? rule.cameraHandle.slice() : [],\n    viewfinderExtension: Array.isArray(rule.viewfinderExtension)\n      ? rule.viewfinderExtension.slice()\n      : [],\n    videoDistribution: Array.isArray(rule.videoDistribution)\n      ? rule.videoDistribution.slice()\n      : [],\n    camera: Array.isArray(rule.camera) ? rule.camera.slice() : [],\n    monitor: Array.isArray(rule.monitor) ? rule.monitor.slice() : [],\n    wireless: Array.isArray(rule.wireless) ? rule.wireless.slice() : [],\n    motors: Array.isArray(rule.motors) ? rule.motors.slice() : [],\n    controllers: Array.isArray(rule.controllers) ? rule.controllers.slice() : [],\n    distance: Array.isArray(rule.distance) ? rule.distance.slice() : [],\n    add: Array.isArray(rule.add) ? rule.add.map(cloneAutoGearRuleItem) : [],\n    remove: Array.isArray(rule.remove) ? rule.remove.map(cloneAutoGearRuleItem) : [],\n  };\n}\n\nfunction cloneAutoGearRules(rules) {\n  return Array.isArray(rules)\n    ? rules.map(cloneAutoGearRule).filter(Boolean)\n    : [];\n}\n\nfunction setFactoryAutoGearRulesSnapshot(rules) {\n  if (!Array.isArray(rules)) {\n    factoryAutoGearRulesSnapshot = null;\n    return;\n  }\n  factoryAutoGearRulesSnapshot = cloneAutoGearRules(rules);\n}\n\nfunction subtractScenarioContributions(diff, scenarioKeys, scenarioDiffMap) {\n  const adjust = (items, type) => items\n    .map(item => {\n      let remaining = normalizeAutoGearQuantity(item.quantity);\n      scenarioKeys.forEach(key => {\n        const scenarioDiff = scenarioDiffMap.get(key);\n        if (!scenarioDiff) return;\n        const match = scenarioDiff[type].find(entry => entry.name === item.name && entry.category === item.category);\n        if (match) {\n          remaining -= normalizeAutoGearQuantity(match.quantity);\n        }\n      });\n      remaining = Math.max(remaining, 0);\n      if (remaining <= 0) return null;\n      const normalized = normalizeAutoGearItem(item);\n      if (!normalized) return null;\n      return { ...normalized, quantity: remaining };\n    })\n    .filter(Boolean);\n  return { add: adjust(diff.add, 'add'), remove: adjust(diff.remove, 'remove') };\n}\n\nfunction extractAutoGearSelections(value) {\n  if (typeof value !== 'string') return [];\n  return value\n    .split(',')\n    .map(part => part.trim())\n    .filter(Boolean);\n}\n\nfunction buildViewfinderExtensionAutoRules(baseInfo, baselineMap) {\n  if (!baselineMap || typeof generateGearListHtml !== 'function' || typeof parseGearTableForAutoRules !== 'function') {\n    return [];\n  }\n\n  const selections = extractAutoGearSelections(baseInfo && baseInfo.viewfinderExtension);\n  if (!selections.length) return [];\n\n  const uniqueSelections = Array.from(new Set(selections));\n  const rules = [];\n\n  uniqueSelections.forEach(selection => {\n    const trimmed = selection.trim();\n    if (!trimmed) return;\n\n    const remainingSelections = selections.filter(value => value !== trimmed);\n    const variantInfo = { ...baseInfo, viewfinderExtension: remainingSelections.join(', ') };\n    const variantHtml = generateGearListHtml({ ...variantInfo, requiredScenarios: '' });\n    const variantMap = parseGearTableForAutoRules(variantHtml);\n    if (!variantMap) return;\n\n    const diff = diffGearTableMaps(variantMap, baselineMap);\n    if (!diff.add.length && !diff.remove.length) return;\n\n    const additions = cloneAutoGearItems(diff.add);\n    if (!additions.length) return;\n    const removals = cloneAutoGearItems(diff.add);\n\n    rules.push({\n      id: generateAutoGearId('rule'),\n      label: getViewfinderFallbackLabel(trimmed),\n      scenarios: [],\n      mattebox: [],\n      cameraHandle: [],\n      viewfinderExtension: [trimmed],\n      videoDistribution: [],\n      add: additions,\n      remove: removals,\n    });\n  });\n\n  return rules;\n}\n\nfunction buildVideoDistributionAutoRules(baseInfo, baselineMap) {\n  if (!baselineMap || typeof generateGearListHtml !== 'function' || typeof parseGearTableForAutoRules !== 'function') {\n    return [];\n  }\n\n  const selections = extractAutoGearSelections(baseInfo && baseInfo.videoDistribution);\n  if (!selections.length) return [];\n\n  const uniqueSelections = Array.from(new Set(selections));\n  const rules = [];\n\n  uniqueSelections.forEach(selection => {\n    const trimmed = selection.trim();\n    if (!trimmed) return;\n    const lower = trimmed.toLowerCase();\n    if (lower === '__none__' || lower === 'none') return;\n\n    const remainingSelections = selections.filter(value => value !== trimmed);\n    const variantInfo = { ...baseInfo, videoDistribution: remainingSelections.join(', ') };\n    const variantHtml = generateGearListHtml({ ...variantInfo, requiredScenarios: '' });\n    const variantMap = parseGearTableForAutoRules(variantHtml);\n    if (!variantMap) return;\n\n    const diff = diffGearTableMaps(variantMap, baselineMap);\n    if (!diff.add.length && !diff.remove.length) return;\n\n    const additions = cloneAutoGearItems(diff.add);\n    if (!additions.length) return;\n    const removals = cloneAutoGearItems(diff.add);\n\n    rules.push({\n      id: generateAutoGearId('rule'),\n      label: getVideoDistributionFallbackLabel(trimmed),\n      scenarios: [],\n      mattebox: [],\n      cameraHandle: [],\n      viewfinderExtension: [],\n      videoDistribution: [trimmed],\n      add: additions,\n      remove: removals,\n    });\n  });\n\n  return rules;\n}\n\nfunction buildDefaultVideoDistributionAutoGearRules(baseInfo = {}) {\n  if (typeof generateGearListHtml !== 'function' || typeof parseGearTableForAutoRules !== 'function') {\n    return [];\n  }\n\n  const select = document.getElementById('videoDistribution');\n  if (!select) return [];\n\n  const optionValues = [];\n  const seen = new Set();\n  Array.from(select.options || []).forEach(option => {\n    if (!option) return;\n    const rawValue = typeof option.value === 'string' ? option.value.trim() : '';\n    const normalized = normalizeVideoDistributionOptionValue(rawValue);\n    if (!normalized || normalized === '__none__') return;\n    if (seen.has(normalized)) return;\n    seen.add(normalized);\n    optionValues.push(rawValue);\n  });\n\n  if (!optionValues.length) return [];\n\n  const info = { ...(baseInfo || {}), videoDistribution: optionValues.join(', ') };\n  const baselineHtml = generateGearListHtml({ ...info, requiredScenarios: '' });\n  const baselineMap = parseGearTableForAutoRules(baselineHtml);\n  if (!baselineMap) return [];\n  const generatedRules = buildVideoDistributionAutoRules(info, baselineMap);\n\n  const hasIosOption = optionValues.some(value => value && value.toLowerCase() === 'ios video');\n  if (hasIosOption) {\n    const iosLabel = optionValues.find(value => value && value.toLowerCase() === 'ios video') || 'IOS Video';\n    const normalizedIos = normalizeAutoGearTriggerValue(iosLabel);\n    const hasGeneratedIosRule = generatedRules.some(rule =>\n      Array.isArray(rule.videoDistribution)\n        && rule.videoDistribution.some(value => normalizeAutoGearTriggerValue(value) === normalizedIos)\n    );\n    if (!hasGeneratedIosRule) {\n      const createdNames = new Set();\n      const createItem = (name, category, quantity = 1) => {\n        if (!name || !category || quantity <= 0) return null;\n        const key = `${name}|${category}`;\n        if (createdNames.has(key)) return null;\n        createdNames.add(key);\n        return {\n          id: generateAutoGearId('item'),\n          name,\n          category,\n          quantity,\n          screenSize: '',\n          selectorType: 'none',\n          selectorDefault: '',\n          selectorEnabled: false,\n          notes: '',\n        };\n      };\n\n      const additions = [];\n      const iosDevices = devices && typeof devices === 'object' ? devices.iosVideo : null;\n      if (iosDevices && typeof iosDevices === 'object') {\n        Object.keys(iosDevices).forEach(deviceName => {\n          const item = createItem(deviceName, 'Monitoring');\n          if (item) additions.push(item);\n        });\n      }\n\n      if (!additions.length) {\n        const fallback = createItem('Teradek Serv + Link', 'Monitoring');\n        if (fallback) additions.push(fallback);\n      }\n\n      const pushSupport = (name, category, quantity = 1) => {\n        const item = createItem(name, category, quantity);\n        if (item) additions.push(item);\n      };\n\n      pushSupport('iPad receiver (Director)', 'Monitoring');\n      pushSupport('iPad receiver (DoP)', 'Monitoring');\n      pushSupport('iPad receiver (Gaffer)', 'Monitoring');\n      pushSupport('USB-C Charger (iOS Video)', 'Monitoring support', 2);\n      pushSupport('Wi-Fi Router (iOS Video Village)', 'Monitoring support');\n\n      if (additions.length) {\n        generatedRules.push({\n          id: generateAutoGearId('rule'),\n          label: getVideoDistributionFallbackLabel(iosLabel),\n          scenarios: [],\n          mattebox: [],\n          cameraHandle: [],\n          viewfinderExtension: [],\n          videoDistribution: [iosLabel],\n          add: additions,\n          remove: [],\n        });\n      }\n    }\n  }\n\n  return generatedRules;\n}\n\nfunction buildDefaultMatteboxAutoGearRules() {\n  const category = 'Matte box + filter';\n  const createItems = names => names.map(name => ({\n    id: generateAutoGearId('item'),\n    name,\n    category,\n    quantity: 1,\n  }));\n  return [\n    {\n      id: generateAutoGearId('rule'),\n      label: 'Mattebox: Swing Away',\n      scenarios: [],\n      mattebox: ['Swing Away'],\n      add: createItems([\n        'ARRI LMB 4x5 Pro Set',\n        'ARRI LMB 19mm Studio Rod Adapter',\n        'ARRI LMB 4x5 / LMB-6 Tray Catcher',\n      ]),\n      remove: [],\n    },\n    {\n      id: generateAutoGearId('rule'),\n      label: 'Mattebox: Rod based',\n      scenarios: [],\n      mattebox: ['Rod based'],\n      add: createItems([\n        'ARRI LMB 4x5 15mm LWS Set 3-Stage',\n        'ARRI LMB 19mm Studio Rod Adapter',\n        'ARRI LMB 4x5 / LMB-6 Tray Catcher',\n        'ARRI LMB 4x5 Side Flags',\n        'ARRI LMB Flag Holders',\n        'ARRI LMB 4x5 Set of Mattes spherical',\n        'ARRI LMB Accessory Adapter',\n        'ARRI Anti-Reflection Frame 4x5.65',\n      ]),\n      remove: [],\n    },\n    {\n      id: generateAutoGearId('rule'),\n      label: 'Mattebox: Clamp On',\n      scenarios: [],\n      mattebox: ['Clamp On'],\n      add: createItems([\n        'ARRI LMB 4x5 Clamp-On (3-Stage)',\n        'ARRI LMB 4x5 / LMB-6 Tray Catcher',\n        'ARRI LMB 4x5 Side Flags',\n        'ARRI LMB Flag Holders',\n        'ARRI LMB 4x5 Set of Mattes spherical',\n        'ARRI LMB Accessory Adapter',\n        'ARRI Anti-Reflection Frame 4x5.65',\n        'ARRI LMB 4x5 Clamp Adapter Set Pro',\n      ]),\n      remove: [],\n    }\n  ];\n}\n\nfunction ensureDefaultMatteboxAutoGearRules() {\n  const defaults = buildDefaultMatteboxAutoGearRules();\n  if (!defaults.length) return false;\n  const existingKeys = new Set(\n    autoGearRules\n      .map(autoGearRuleMatteboxKey)\n      .filter(Boolean)\n  );\n  const additions = defaults.filter(rule => {\n    const key = autoGearRuleMatteboxKey(rule);\n    if (!key) return false;\n    if (existingKeys.has(key)) return false;\n    existingKeys.add(key);\n    return true;\n  });\n  if (!additions.length) return false;\n  setAutoGearRules(autoGearRules.concat(additions));\n  return true;\n}\n\nfunction captureSetupSelectValues() {\n  const captureList = list => list.map(sel => (sel && typeof sel.value === 'string') ? sel.value : '');\n  return {\n    camera: cameraSelect && typeof cameraSelect.value === 'string' ? cameraSelect.value : '',\n    monitor: monitorSelect && typeof monitorSelect.value === 'string' ? monitorSelect.value : '',\n    video: videoSelect && typeof videoSelect.value === 'string' ? videoSelect.value : '',\n    cage: cageSelect && typeof cageSelect.value === 'string' ? cageSelect.value : '',\n    distance: distanceSelect && typeof distanceSelect.value === 'string' ? distanceSelect.value : '',\n    battery: batterySelect && typeof batterySelect.value === 'string' ? batterySelect.value : '',\n    batteryPlate: batteryPlateSelect && typeof batteryPlateSelect.value === 'string'\n      ? batteryPlateSelect.value\n      : '',\n    hotswap: hotswapSelect && typeof hotswapSelect.value === 'string' ? hotswapSelect.value : '',\n    motors: captureList(motorSelects),\n    controllers: captureList(controllerSelects),\n    sliderBowl: typeof getSliderBowlValue === 'function' ? getSliderBowlValue() : '',\n    easyrig: typeof getEasyrigValue === 'function' ? getEasyrigValue() : '',\n  };\n}\n\nfunction applySetupSelectValues(values) {\n  if (!values || typeof values !== 'object') return;\n  if (cameraSelect) {\n    setSelectValue(cameraSelect, values.camera);\n    if (typeof updateBatteryPlateVisibility === 'function') {\n      updateBatteryPlateVisibility();\n    }\n    if (typeof updateBatteryOptions === 'function') {\n      updateBatteryOptions();\n    }\n  }\n  if (batteryPlateSelect) setSelectValue(batteryPlateSelect, values.batteryPlate);\n  if (monitorSelect) setSelectValue(monitorSelect, values.monitor);\n  if (videoSelect) setSelectValue(videoSelect, values.video);\n  if (cageSelect) setSelectValue(cageSelect, values.cage);\n  if (distanceSelect) setSelectValue(distanceSelect, values.distance);\n  if (Array.isArray(values.motors)) {\n    values.motors.forEach((val, index) => {\n      if (motorSelects[index]) setSelectValue(motorSelects[index], val);\n    });\n  }\n  if (Array.isArray(values.controllers)) {\n    values.controllers.forEach((val, index) => {\n      if (controllerSelects[index]) setSelectValue(controllerSelects[index], val);\n    });\n  }\n  if (batterySelect) setSelectValue(batterySelect, values.battery);\n  if (hotswapSelect) setSelectValue(hotswapSelect, values.hotswap);\n  if (typeof setSliderBowlValue === 'function') setSliderBowlValue(values.sliderBowl);\n  if (typeof setEasyrigValue === 'function') setEasyrigValue(values.easyrig);\n}\n\nfunction captureAutoGearSeedContext() {\n  if (factoryAutoGearSeedContext) return;\n  if (typeof collectProjectFormData !== 'function') return;\n  const baseInfo = collectProjectFormData() || {};\n  let projectDataClone;\n  try {\n    projectDataClone = JSON.parse(JSON.stringify(baseInfo));\n  } catch (cloneError) {\n    void cloneError;\n    projectDataClone = { ...baseInfo };\n  }\n  const scenarioValues = requiredScenariosSelect\n    ? Array.from(requiredScenariosSelect.options || [])\n        .map(opt => opt && typeof opt.value === 'string' ? opt.value : '')\n        .filter(value => value)\n    : [];\n  factoryAutoGearSeedContext = {\n    projectFormData: projectDataClone,\n    scenarioValues,\n    setupValues: captureSetupSelectValues(),\n  };\n}\n\nfunction buildAutoGearRulesFromBaseInfo(baseInfo, scenarioValues) {\n  const rules = [];\n  const canGenerateRules = typeof generateGearListHtml === 'function'\n    && typeof parseGearTableForAutoRules === 'function';\n  const scenarios = Array.isArray(scenarioValues)\n    ? scenarioValues.filter(value => typeof value === 'string' && value)\n    : [];\n\n  let baselineMap = null;\n  if (canGenerateRules) {\n    const baselineHtml = generateGearListHtml({ ...baseInfo, requiredScenarios: '' });\n    baselineMap = parseGearTableForAutoRules(baselineHtml);\n\n    if (baselineMap && scenarios.length) {\n      const scenarioDiffMap = new Map();\n      scenarios.forEach(value => {\n        const scenarioHtml = generateGearListHtml({ ...baseInfo, requiredScenarios: value });\n        const scenarioMap = parseGearTableForAutoRules(scenarioHtml);\n        if (!scenarioMap) return;\n        const diff = diffGearTableMaps(baselineMap, scenarioMap);\n        const add = cloneAutoGearItems(diff.add);\n        const remove = cloneAutoGearItems(diff.remove);\n        if (!add.length && !remove.length) return;\n        scenarioDiffMap.set(value, { add, remove });\n        rules.push({\n          id: generateAutoGearId('rule'),\n          label: value,\n          scenarios: [value],\n          add,\n          remove,\n        });\n      });\n\n      const comboCandidates = [\n        ['Handheld', 'Easyrig'],\n        ['Slider', 'Undersling mode']\n      ].filter(combo => combo.every(value => scenarios.includes(value)));\n\n      comboCandidates.forEach(combo => {\n        const combinedLabel = combo.join(' + ');\n        const scenarioHtml = generateGearListHtml({\n          ...baseInfo,\n          requiredScenarios: combo.join(', ')\n        });\n        const scenarioMap = parseGearTableForAutoRules(scenarioHtml);\n        if (!scenarioMap) return;\n        const diff = diffGearTableMaps(baselineMap, scenarioMap);\n        const adjusted = subtractScenarioContributions({\n          add: cloneAutoGearItems(diff.add),\n          remove: cloneAutoGearItems(diff.remove)\n        }, combo, scenarioDiffMap);\n        if (!adjusted.add.length && !adjusted.remove.length) return;\n        rules.push({\n          id: generateAutoGearId('rule'),\n          label: combinedLabel,\n          scenarios: combo.slice(),\n          add: adjusted.add,\n          remove: adjusted.remove,\n        });\n      });\n    }\n  }\n\n  if (baselineMap) {\n    buildViewfinderExtensionAutoRules(baseInfo, baselineMap).forEach(rule => rules.push(rule));\n    buildVideoDistributionAutoRules(baseInfo, baselineMap).forEach(rule => rules.push(rule));\n\n    const defaultVideoDistributionRules = buildDefaultVideoDistributionAutoGearRules(baseInfo);\n    if (defaultVideoDistributionRules.length) {\n      const existingSignatures = new Set(\n        rules\n          .map(autoGearRuleSignature)\n          .filter(signature => typeof signature === 'string' && signature)\n      );\n      defaultVideoDistributionRules.forEach(rule => {\n        const signature = autoGearRuleSignature(rule);\n        if (!signature || existingSignatures.has(signature)) return;\n        rules.push(rule);\n        existingSignatures.add(signature);\n      });\n    }\n  }\n\n  buildDefaultMatteboxAutoGearRules().forEach(rule => rules.push(rule));\n  return rules;\n}\n\nfunction computeFactoryAutoGearRules() {\n  captureAutoGearSeedContext();\n  const context = factoryAutoGearSeedContext;\n  if (!context) return null;\n\n  const previousSelectValues = captureSetupSelectValues();\n  const seededBeforeCompute = hasSeededAutoGearDefaults();\n  const savedAutoGearRules = autoGearRules.slice();\n  const savedBaseAutoGearRules = baseAutoGearRules.slice();\n  const savedProjectScopedRules = projectScopedAutoGearRules\n    ? projectScopedAutoGearRules.slice()\n    : null;\n  const savedBackupSignature = autoGearRulesLastBackupSignature;\n  const savedPersistedSignature = autoGearRulesLastPersistedSignature;\n  const savedDirtyFlag = autoGearRulesDirtySinceBackup;\n  try {\n    if (seededBeforeCompute) {\n      clearAutoGearDefaultsSeeded();\n    }\n    assignAutoGearRules([]);\n    baseAutoGearRules = [];\n    projectScopedAutoGearRules = null;\n    autoGearRulesLastBackupSignature = savedBackupSignature;\n    autoGearRulesLastPersistedSignature = savedPersistedSignature;\n    autoGearRulesDirtySinceBackup = savedDirtyFlag;\n    applySetupSelectValues(context.setupValues);\n    const baseInfoSource = context.projectFormData || {};\n    let baseInfo;\n    try {\n      baseInfo = JSON.parse(JSON.stringify(baseInfoSource));\n    } catch (cloneErr) {\n      void cloneErr;\n      baseInfo = { ...baseInfoSource };\n    }\n    const rules = buildAutoGearRulesFromBaseInfo(baseInfo, context.scenarioValues || []);\n    if (rules.length) {\n      setFactoryAutoGearRulesSnapshot(rules);\n    }\n    return rules;\n  } finally {\n    applySetupSelectValues(previousSelectValues);\n    assignAutoGearRules(savedAutoGearRules);\n    baseAutoGearRules = savedBaseAutoGearRules.slice();\n    projectScopedAutoGearRules = savedProjectScopedRules\n      ? savedProjectScopedRules.slice()\n      : null;\n    autoGearRulesLastBackupSignature = savedBackupSignature;\n    autoGearRulesLastPersistedSignature = savedPersistedSignature;\n    autoGearRulesDirtySinceBackup = savedDirtyFlag;\n    if (seededBeforeCompute) {\n      markAutoGearDefaultsSeeded();\n    }\n  }\n}\n\nfunction seedAutoGearRulesFromCurrentProject() {\n  captureAutoGearSeedContext();\n  const seededBefore = hasSeededAutoGearDefaults();\n\n  if (autoGearRules.length) {\n    const addedDefaults = ensureDefaultMatteboxAutoGearRules();\n    if (addedDefaults && !seededBefore) {\n      markAutoGearDefaultsSeeded();\n      setFactoryAutoGearRulesSnapshot(getAutoGearRules());\n    } else if (!factoryAutoGearRulesSnapshot) {\n      setFactoryAutoGearRulesSnapshot(getAutoGearRules());\n    }\n    return;\n  }\n\n  if (seededBefore) {\n    const addedDefaults = ensureDefaultMatteboxAutoGearRules();\n    if (addedDefaults && !factoryAutoGearRulesSnapshot) {\n      setFactoryAutoGearRulesSnapshot(getAutoGearRules());\n    }\n    return;\n  }\n\n  const baseInfo = factoryAutoGearSeedContext && factoryAutoGearSeedContext.projectFormData\n    ? { ...factoryAutoGearSeedContext.projectFormData }\n    : (collectProjectFormData ? collectProjectFormData() : {});\n  const scenarioValues = factoryAutoGearSeedContext && Array.isArray(factoryAutoGearSeedContext.scenarioValues)\n    ? factoryAutoGearSeedContext.scenarioValues\n    : (requiredScenariosSelect\n        ? Array.from(requiredScenariosSelect.options || [])\n            .map(opt => opt && opt.value)\n            .filter(Boolean)\n        : []);\n\n  const rules = buildAutoGearRulesFromBaseInfo(baseInfo, scenarioValues);\n  if (!rules.length) {\n    const addedDefaults = ensureDefaultMatteboxAutoGearRules();\n    if (addedDefaults) {\n      markAutoGearDefaultsSeeded();\n      setFactoryAutoGearRulesSnapshot(getAutoGearRules());\n    }\n    return;\n  }\n  setAutoGearRules(rules);\n  markAutoGearDefaultsSeeded();\n  setFactoryAutoGearRulesSnapshot(rules);\n}\n\nfunction resetAutoGearRulesToFactoryAdditions() {\n  const langTexts = texts[currentLang] || texts.en || {};\n  const confirmation = langTexts.autoGearResetFactoryConfirm\n    || texts.en?.autoGearResetFactoryConfirm\n    || 'Replace your automatic gear rules with the default additions?';\n  if (typeof confirm === 'function' && !confirm(confirmation)) {\n    return;\n  }\n\n  const backupName = ensureAutoBackupBeforeDeletion('reset automatic gear rules');\n  if (!backupName) {\n    return;\n  }\n\n  try {\n    const factoryRules = computeFactoryAutoGearRules();\n    let appliedRules = [];\n    if (Array.isArray(factoryRules) && factoryRules.length) {\n      setAutoGearRules(factoryRules);\n      markAutoGearDefaultsSeeded();\n      appliedRules = getAutoGearRules();\n      setFactoryAutoGearRulesSnapshot(appliedRules);\n    } else {\n      setAutoGearRules([]);\n      clearAutoGearDefaultsSeeded();\n      setFactoryAutoGearRulesSnapshot([]);\n    }\n    closeAutoGearEditor();\n    const updatedRules = appliedRules.length ? appliedRules : getAutoGearRules();\n    renderAutoGearRulesList();\n    renderAutoGearDraftLists();\n    updateAutoGearCatalogOptions();\n    const messageKey = updatedRules.length\n      ? 'autoGearResetFactoryDone'\n      : 'autoGearResetFactoryEmpty';\n    const fallback = updatedRules.length\n      ? 'Automatic gear rules restored to factory additions.'\n      : 'Factory additions unavailable. Automatic gear rules cleared.';\n    const message = langTexts[messageKey]\n      || texts.en?.[messageKey]\n      || fallback;\n    const type = updatedRules.length ? 'success' : 'warning';\n    showNotification(type, message);\n  } catch (error) {\n    console.error('Failed to reset automatic gear rules to factory additions', error);\n    const errorMsg = langTexts.autoGearResetFactoryError\n      || texts.en?.autoGearResetFactoryError\n      || 'Reset failed. Please try again.';\n    showNotification('error', errorMsg);\n  }\n}\n\nfunction collectAutoGearCatalogNames() {\n  const names = new Set();\n  const addName = name => {\n    if (looksLikeGearName(name)) names.add(name);\n  };\n  const seen = typeof WeakSet === 'function' ? new WeakSet() : null;\n  const visit = obj => {\n    if (!obj || typeof obj !== 'object') return;\n    if (seen) {\n      if (seen.has(obj)) return;\n      seen.add(obj);\n    }\n    Object.entries(obj).forEach(([key, value]) => {\n      if (!value || typeof value !== 'object' || Array.isArray(value)) return;\n      addName(key);\n      visit(value);\n    });\n  };\n  if (typeof devices === 'object' && devices) {\n    visit(devices);\n  }\n  autoGearRules.forEach(rule => {\n    [...rule.add, ...rule.remove].forEach(item => addName(item.name));\n  });\n  return Array.from(names).sort((a, b) => a.localeCompare(b, undefined, { sensitivity: 'base' }));\n}\n\nfunction normalizeAutoGearMonitorCatalogMode(value) {\n  const normalized = normalizeAutoGearSelectorType(value);\n  return normalized === 'directorMonitor' ? 'directorMonitor' : 'monitor';\n}\n\nlet autoGearMonitorCatalogMode = 'monitor';\n\nfunction collectAutoGearMonitorNames(type = autoGearMonitorCatalogMode) {\n  const mode = normalizeAutoGearMonitorCatalogMode(type);\n  const includeMonitor = mode === 'monitor';\n  const includeDirectorMonitor = mode === 'directorMonitor';\n  const acceptedTypes = new Set();\n  if (includeMonitor) acceptedTypes.add('monitor');\n  if (includeDirectorMonitor) acceptedTypes.add('directorMonitor');\n\n  const names = new Set();\n  const addName = name => {\n    if (typeof name === 'string') {\n      const trimmed = name.trim();\n      if (trimmed) names.add(trimmed);\n    }\n  };\n  if (includeMonitor) {\n    const monitorDb = devices && devices.monitors ? devices.monitors : null;\n    if (monitorDb && typeof monitorDb === 'object') {\n      Object.keys(monitorDb).forEach(addName);\n    }\n  }\n  if (includeDirectorMonitor) {\n    const directorDb = devices && devices.directorMonitors ? devices.directorMonitors : null;\n    if (directorDb && typeof directorDb === 'object') {\n      Object.keys(directorDb)\n        .filter(name => name && name !== 'None')\n        .forEach(addName);\n    }\n  }\n  autoGearRules.forEach(rule => {\n    const processItem = item => {\n      if (!item || typeof item !== 'object') return;\n      const selectorDefault = item.selectorDefault;\n      if (!selectorDefault) return;\n      const selectorType = normalizeAutoGearSelectorType(item.selectorType);\n      if (acceptedTypes.has(selectorType)) addName(selectorDefault);\n    };\n    (rule.add || []).forEach(processItem);\n    (rule.remove || []).forEach(processItem);\n  });\n  return Array.from(names).sort(localeSort);\n}\n\nfunction updateAutoGearMonitorCatalogOptions(type = autoGearMonitorCatalogMode) {\n  if (!autoGearMonitorCatalog) return;\n  autoGearMonitorCatalogMode = normalizeAutoGearMonitorCatalogMode(type);\n  const names = collectAutoGearMonitorNames(autoGearMonitorCatalogMode);\n  autoGearMonitorCatalog.innerHTML = '';\n  names.forEach(name => {\n    const option = document.createElement('option');\n    option.value = name;\n    autoGearMonitorCatalog.appendChild(option);\n  });\n}\n\nconst getCssVariableValue = (name, fallback = '') => {\n  if (typeof document === 'undefined') return fallback;\n  const root = document.documentElement;\n  if (!root) return fallback;\n  const computed = typeof window !== 'undefined' && typeof window.getComputedStyle === 'function'\n    ? window.getComputedStyle(root).getPropertyValue(name).trim()\n    : '';\n  if (computed) return computed;\n  const inline = root.style.getPropertyValue(name).trim();\n  return inline || fallback;\n};\n\nif (typeof window !== 'undefined' && 'serviceWorker' in navigator) {\n  window.addEventListener('load', () => {\n    navigator.serviceWorker.register('service-worker.js');\n  });\n}\n\nfunction updateInstallBannerPosition() {\n  if (typeof document === 'undefined') return;\n  const installBanner = document.getElementById('installPromptBanner');\n  if (!installBanner) return;\n  const offlineIndicator = document.getElementById('offlineIndicator');\n  if (offlineIndicator && offlineIndicator.style.display !== 'none') {\n    const rect = typeof offlineIndicator.getBoundingClientRect === 'function'\n      ? offlineIndicator.getBoundingClientRect()\n      : null;\n    const height = rect && typeof rect.height === 'number' && rect.height > 0\n      ? rect.height\n      : offlineIndicator.offsetHeight || 0;\n    installBanner.style.top = `${height}px`;\n  } else {\n    installBanner.style.top = '0';\n  }\n}\n\n/**\n * Initialize the offline status indicator.\n *\n * Looks for an element with the id `offlineIndicator` and toggles its\n * visibility based on the browser's online state. If the element is not\n * found, the function quietly does nothing.\n */\nfunction setupOfflineIndicator() {\n  const offlineIndicator = document.getElementById('offlineIndicator');\n  if (!offlineIndicator) return;\n  const updateOnlineStatus = () => {\n    offlineIndicator.style.display = navigator.onLine ? 'none' : 'block';\n    updateInstallBannerPosition();\n  };\n  window.addEventListener('online', updateOnlineStatus);\n  window.addEventListener('offline', updateOnlineStatus);\n  updateOnlineStatus();\n}\n\nif (typeof window !== 'undefined') {\n  setupOfflineIndicator();\n}\n\n/**\n * Close the sidebar menu if it is open.\n */\nfunction closeSideMenu() {\n  const menu = document.getElementById('sideMenu');\n  const overlay = document.getElementById('menuOverlay');\n  const toggle = document.getElementById('menuToggle');\n  if (!menu || !overlay || !toggle) return;\n  menu.classList.remove('open');\n  menu.setAttribute('hidden', '');\n  overlay.classList.add('hidden');\n  toggle.setAttribute('aria-expanded', 'false');\n  toggle.setAttribute('aria-label', 'Menu');\n}\n\n/**\n * Open the sidebar menu if it is currently closed.\n */\nfunction openSideMenu() {\n  const menu = document.getElementById('sideMenu');\n  const overlay = document.getElementById('menuOverlay');\n  const toggle = document.getElementById('menuToggle');\n  if (!menu || !overlay || !toggle) return;\n  if (menu.classList.contains('open')) return;\n  menu.classList.add('open');\n  menu.removeAttribute('hidden');\n  overlay.classList.remove('hidden');\n  toggle.setAttribute('aria-expanded', 'true');\n  toggle.setAttribute('aria-label', 'Close menu');\n}\n\n/**\n * Initialize sidebar menu toggle.\n */\nfunction setupSideMenu() {\n  const toggle = document.getElementById('menuToggle');\n  const menu = document.getElementById('sideMenu');\n  const overlay = document.getElementById('menuOverlay');\n  if (!toggle || !menu || !overlay) return;\n\n  toggle.addEventListener('click', () => {\n    if (menu.classList.contains('open')) {\n      closeSideMenu();\n    } else {\n      openSideMenu();\n    }\n  });\n\n  overlay.addEventListener('click', closeSideMenu);\n  document.addEventListener('keydown', event => {\n    if (event.key === 'Escape' && menu.classList.contains('open')) {\n      closeSideMenu();\n      toggle.focus();\n    }\n  });\n  menu.querySelectorAll('a').forEach(link => {\n    link.addEventListener('click', event => {\n      const hash = link.getAttribute('href');\n      if (hash && hash.startsWith('#')) {\n        event.preventDefault();\n        document.querySelector(hash)?.scrollIntoView();\n        history.replaceState(null, '', window.location.pathname + window.location.search);\n      }\n      closeSideMenu();\n    });\n  });\n\n  const triggerSidebarAction = action => {\n    if (!action) return;\n    if (action === 'open-settings') {\n      document.getElementById('settingsButton')?.click();\n    } else if (action === 'open-help') {\n      document.getElementById('helpButton')?.click();\n    }\n  };\n\n  menu.querySelectorAll('[data-sidebar-action]').forEach(button => {\n    button.addEventListener('click', event => {\n      event.preventDefault();\n      triggerSidebarAction(button.dataset.sidebarAction);\n      closeSideMenu();\n    });\n  });\n}\n\nfunction setupResponsiveControls() {\n  const topBar = document.getElementById('topBar');\n  const featureSearch = topBar?.querySelector('.feature-search');\n  const controls = topBar?.querySelector('.controls');\n  const sidebarControls = document.querySelector('#sideMenu .sidebar-controls');\n  if (\n    !topBar ||\n    !featureSearch ||\n    !controls ||\n    !sidebarControls ||\n    typeof window.matchMedia !== 'function'\n  )\n    return;\n\n  const mql = window.matchMedia('(max-width: 768px)');\n\n  const relocate = () => {\n    if (mql.matches) {\n      sidebarControls.appendChild(featureSearch);\n      sidebarControls.appendChild(controls);\n    } else {\n      topBar.appendChild(featureSearch);\n      topBar.appendChild(controls);\n    }\n  };\n\n  mql.addEventListener('change', relocate);\n  relocate();\n}\n\nfunction initializeLayoutControls() {\n  setupSideMenu();\n  setupResponsiveControls();\n}\n\nif (typeof window !== 'undefined' && typeof document !== 'undefined') {\n  const runLayoutInitialization = () => {\n    initializeLayoutControls();\n  };\n\n  if (document.readyState === 'loading') {\n    document.addEventListener('DOMContentLoaded', runLayoutInitialization, { once: true });\n  } else {\n    runLayoutInitialization();\n  }\n}\n\n/**\n * Escape a string for safe insertion into HTML.\n *\n * The helper delays touching the DOM until first use to avoid\n * ReferenceErrors in environments where `document` is defined as an\n * uninitialised `let` binding (e.g. Safari). When no DOM is present the\n * original string is returned unchanged.\n *\n * @param {string} str - Text that may contain HTML characters.\n * @returns {string} The escaped string.\n */\nlet escapeDiv;\nfunction escapeHtml(str) {\n  if (!escapeDiv && typeof globalThis !== 'undefined' && globalThis.document) {\n    escapeDiv = globalThis.document.createElement('div');\n  }\n  if (!escapeDiv) return String(str);\n  escapeDiv.textContent = str;\n  return escapeDiv.innerHTML;\n}\n\n// Use a Set for O(1) lookups when validating video output types\nconst VIDEO_OUTPUT_TYPES = new Set([\n  '3G-SDI',\n  '6G-SDI',\n  '12G-SDI',\n  'Mini BNC',\n  'HDMI',\n  'Mini HDMI',\n  'Micro HDMI',\n  'DisplayPort'\n]);\n\nconst collator = new Intl.Collator(undefined, { numeric: true, sensitivity: 'base' });\nconst localeSort = (a, b) => collator.compare(a, b);\n\nconst DEFAULT_FILTER_SIZE = '4x5.65';\n\nlet showAutoBackups = false;\ntry {\n  if (typeof localStorage !== 'undefined') {\n    showAutoBackups = localStorage.getItem('showAutoBackups') === 'true';\n  }\n} catch (e) {\n  console.warn('Could not load auto backup visibility preference', e);\n}\n\n// Labels for B-Mount support are defined in translations.js using the keys\n// batteryBMountLabel, totalCurrent336Label and totalCurrent216Label.\n\nfunction getSetups() {\n  return loadSetups();\n}\n\nfunction storeSetups(setups) {\n  saveSetups(setups);\n}\n\nfunction storeDevices(deviceData) {\n  saveDeviceData(deviceData);\n}\n\nfunction loadSession() {\n  return typeof loadSessionState === 'function' ? loadSessionState() : null;\n}\n\nfunction storeSession(state) {\n  if (typeof saveSessionState === 'function') {\n    saveSessionState(state);\n  }\n}\n\n/**\n * Toggle a dialog element's visibility, gracefully handling browsers that do\n * not support the dialog `showModal` or `close` APIs. When those methods are\n * unavailable the function falls back to manipulating the `open` attribute\n * directly.\n *\n * @param {HTMLDialogElement} dialog - The dialog to operate on.\n * @param {boolean} shouldOpen - Whether the dialog should be opened or\n *   closed.\n */\nfunction toggleDialog(dialog, shouldOpen) {\n  if (!dialog) return;\n  if (shouldOpen) {\n    if (typeof dialog.showModal === 'function') {\n      dialog.showModal();\n    } else {\n      dialog.setAttribute('open', '');\n    }\n  } else if (typeof dialog.close === 'function') {\n    dialog.close();\n  } else {\n    dialog.removeAttribute('open');\n  }\n}\n\n/**\n * Open a dialog element, falling back to setting the `open` attribute when\n * the `showModal` method is unavailable.\n *\n * @param {HTMLDialogElement} dialog - The dialog to open.\n */\nfunction openDialog(dialog) {\n  toggleDialog(dialog, true);\n}\n\n/**\n * Close a dialog element, removing the `open` attribute if the `close`\n * method is not supported.\n *\n * @param {HTMLDialogElement} dialog - The dialog to close.\n */\nfunction closeDialog(dialog) {\n  toggleDialog(dialog, false);\n}\n\n/**\n * Determine whether a dialog element is currently open.\n *\n * @param {HTMLDialogElement} dialog - The dialog to inspect.\n * @returns {boolean} True if the dialog is open.\n */\nfunction isDialogOpen(dialog) {\n  if (!dialog) return false;\n  if (typeof dialog.open === 'boolean') {\n    return dialog.open;\n  }\n  return dialog.hasAttribute('open');\n}\n\n/**\n * Memoize a normalisation function for repeated lookups.\n *\n * The provided function receives both the original trimmed string and a\n * lowercase key. Results are cached to avoid recomputing normalisations for\n * the same input.\n *\n * @param {(value: string, key: string) => string} fn - Function that performs\n *   normalisation.\n * @returns {(value: string) => string} Wrapped function with memoisation and\n *   empty-string fallback for falsy inputs.\n */\nfunction memoizeNormalization(fn) {\n  const cache = new Map();\n  return value => {\n    if (!value) return '';\n    const str = String(value)\n      .replace(/[\u2122\xAE]/g, '')\n      .trim();\n    const key = str.toLowerCase();\n    if (!cache.has(key)) cache.set(key, fn(str, key));\n    return cache.get(key);\n  };\n}\n\nconst VIDEO_TYPE_PATTERNS = [\n  { needles: ['12g'], value: '12G-SDI' },\n  { needles: ['6g'], value: '6G-SDI' },\n  { needles: ['3g'], value: '3G-SDI' },\n  // Accept both \"HD-SDI\" and \"HD SDI\" spellings\n  { needles: ['hd', 'sdi'], value: '3G-SDI' },\n  { needles: ['mini', 'bnc'], value: 'Mini BNC' },\n  { needles: ['micro', 'hdmi'], value: 'Micro HDMI' },\n  { needles: ['mini', 'hdmi'], value: 'Mini HDMI' },\n  { needles: ['hdmi'], value: 'HDMI' },\n  { needles: ['displayport'], value: 'DisplayPort' },\n  { needles: ['display', 'port'], value: 'DisplayPort' },\n  { needles: ['dp'], value: 'DisplayPort' }\n];\n\nconst normalizeVideoType = memoizeNormalization((_, key) => {\n  const match = VIDEO_TYPE_PATTERNS.find(({ needles }) =>\n    needles.every(n => key.includes(n))\n  );\n  return match ? match.value : '';\n});\n\nconst FIZ_CONNECTOR_MAP = {\n  'lemo 4-pin (lbus)': 'LBUS (LEMO 4-pin)',\n  'lbus (lemo 4-pin)': 'LBUS (LEMO 4-pin)',\n  'lbus (4-pin lemo)': 'LBUS (LEMO 4-pin)',\n  'lbus (4-pin lemo for motors)': 'LBUS (LEMO 4-pin)',\n  '4-pin lemo (lbus)': 'LBUS (LEMO 4-pin)',\n  'lemo 4-pin': 'LEMO 4-pin',\n  '4-pin lemo': 'LEMO 4-pin',\n  'lemo 7-pin': 'LEMO 7-pin',\n  'lemo 7-pin 1b': 'LEMO 7-pin',\n  '7-pin lemo': 'LEMO 7-pin',\n  '7-pin lemo (lcs)': 'LEMO 7-pin (LCS)',\n  '7-pin lemo (cam)': 'LEMO 7-pin (CAM)',\n  'ext (lemo 7-pin)': 'EXT LEMO 7-pin',\n  'hirose 12pin': 'Hirose 12-pin',\n  '12-pin hirose': 'Hirose 12-pin',\n  '12pin broadcast connector': 'Hirose 12-pin',\n  'lens 12 pin': 'Hirose 12-pin',\n  'lens terminal 12-pin': 'Hirose 12-pin',\n  'lens terminal 12-pin jack': 'Hirose 12-pin',\n  'lens terminal': 'Hirose 12-pin',\n  'usb type-c': 'USB-C',\n  'usb-c': 'USB-C',\n  'usb-c (usb 3.2 / 3.1 gen 1)': 'USB-C',\n  'usb-c / gigabit ethernet (via adapter)': 'USB-C',\n  'active ef mount': 'Active EF mount',\n  'lanc (2.5mm stereo mini jack)': 'LANC',\n  '2.5 mm sub-mini (lanc)': 'LANC',\n  'remote a (2.5mm)': 'REMOTE A connector',\n  'remote control terminal': 'REMOTE A connector',\n  'remote 8 pin': 'REMOTE B connector'\n};\n\nfunction createMapNormalizer(map) {\n  return memoizeNormalization((str, key) => map[key] || str);\n}\n\nconst normalizeFizConnectorType = createMapNormalizer(FIZ_CONNECTOR_MAP);\n\nconst VIEWFINDER_TYPE_MAP = {\n  'dsmc3 red touch 7\" lcd (optional)': 'RED Touch 7\" LCD (Optional)',\n  'red touch 7.0\" lcd (optional)': 'RED Touch 7\" LCD (Optional)',\n  'lcd touch panel': 'LCD touchscreen',\n  'lcd touchscreen': 'LCD touchscreen',\n  'native lcd capacitive touchscreen': 'LCD touchscreen',\n  'integrated touchscreen lcd': 'LCD touchscreen',\n  'free-angle lcd': 'Vari-angle LCD',\n  'lcd monitor (native)': 'Integrated LCD monitor',\n  'native lcd viewfinder': 'Integrated LCD monitor',\n  'lcd monitor lm-v2 (supplied)': 'LCD Monitor LM-V2',\n  'integrated main monitor': 'Integrated LCD monitor',\n  'optional evf-v70 viewfinder': 'EVF-V70 (Optional)',\n  'optional evf-v50': 'EVF-V50 (Optional)',\n  'optional oled viewfinder': 'OLED EVF (Optional)',\n  'blackmagic pocket cinema camera pro evf (optional)': 'Blackmagic Pro EVF (Optional)',\n  'external backlit lcd status display': 'LCD status display',\n  'built-in fold-out lcd': 'Fold-out LCD',\n  'oled lvf (live view finder)': 'OLED EVF',\n  'lcd capacitive touchscreen': 'LCD touchscreen',\n  'lemo 26 pin': 'LEMO 26-pin port'\n};\n\nconst normalizeViewfinderType = createMapNormalizer(VIEWFINDER_TYPE_MAP);\n\nconst POWER_PORT_TYPE_MAP = {\n  'lemo 8-pin (dc in / bat)': 'Bat LEMO 8-pin',\n  'lemo 8-pin (bat)': 'Bat LEMO 8-pin',\n  'bat (lemo 8-pin)': 'Bat LEMO 8-pin',\n  'lemo 8-pin': 'Bat LEMO 8-pin',\n  '2-pin dc-input': '2-pin DC-IN',\n  '2-pin xlr': 'XLR 2-pin',\n  '2-pin locking connector': 'LEMO 2-pin',\n  '2-pin locking connector / 2-pin lemo': 'LEMO 2-pin',\n  '4-pin xlr / dc in 12v': 'XLR 4-pin',\n  '4-pin xlr / v-lock': 'XLR 4-pin',\n  'xlr 4-pin jack': 'XLR 4-pin',\n  'xlr 4-pin (main input)': 'XLR 4-pin',\n  'xlr-type 4 pin (male) / square-shaped 5 pin connector (battery)': 'XLR 4-pin / Square 5-pin',\n  '12-pin molex connector (at battery plate rear) / 4-pin xlr (external power)': 'Molex 12-pin / XLR 4-pin',\n  'battery slot': 'Battery Slot',\n  'usb-c': 'USB-C',\n  'usb type-c': 'USB-C',\n  'usb-c pd': 'USB-C PD',\n  'usb-c (power delivery)': 'USB-C PD',\n  'dc input': 'DC IN',\n  'weipu sf610/s2 (12vdc) input': 'Weipu SF610/S2',\n  '6-pin 1b dc-in / tb50 battery mount': '6-pin 1B DC-IN / TB50'\n};\n\nconst mapPowerPortOne = createMapNormalizer(POWER_PORT_TYPE_MAP);\n\nfunction normalizePowerPortType(type) {\n  if (!type) return [];\n  const toArray = val =>\n    mapPowerPortOne(val)\n      .split('/')\n      .map(p => mapPowerPortOne(p))\n      .filter(Boolean);\n  return Array.isArray(type) ? type.flatMap(toArray) : toArray(type);\n}\n\nfunction ensureList(list, defaults) {\n  if (!Array.isArray(list)) return [];\n  return list.map(item =>\n    typeof item === 'string'\n      ? { ...defaults, type: item }\n      : { ...defaults, ...(item || {}) }\n  );\n}\n\nfunction fixPowerInput(dev) {\n  if (!dev) return;\n  if (dev.powerInput && !dev.power?.input) {\n    dev.power = { ...(dev.power || {}), input: { type: normalizePowerPortType(dev.powerInput) } };\n    delete dev.powerInput;\n  }\n  const input = dev.power?.input;\n  if (!input) return;\n  const normalizeEntry = it => {\n    if (typeof it === 'string') {\n      return { type: normalizePowerPortType(it) };\n    }\n    if (it) {\n      const { portType: pType, type: tType, ...rest } = it;\n      const typeField = (!tType && pType) ? pType : tType;\n      return { ...rest, type: typeField ? normalizePowerPortType(typeField) : [] };\n    }\n    return { type: [] };\n  };\n  dev.power.input = Array.isArray(input) ? input.map(normalizeEntry) : normalizeEntry(input);\n}\n\nfunction applyFixPowerInput(collection) {\n  if (!collection || typeof collection !== 'object') return;\n  Object.values(collection).forEach(fixPowerInput);\n}\n\n\n// Normalize various camera properties so downstream logic works with\n// consistent structures and value formats.\nfunction unifyDevices(devicesData) {\n  if (!devicesData || typeof devicesData !== 'object') return;\n  Object.values(devicesData.cameras || {}).forEach(cam => {\n    if (cam.power?.input && cam.power.input.powerDrawWatts !== undefined) {\n      delete cam.power.input.powerDrawWatts;\n    }\n    fixPowerInput(cam);\n    if (Array.isArray(cam.power?.batteryPlateSupport)) {\n      cam.power.batteryPlateSupport = cam.power.batteryPlateSupport.map(it => {\n        if (typeof it === 'string') {\n          const m = it.match(/([^()]+)(?:\\(([^)]+)\\))?(?:\\s*-\\s*(.*))?/);\n          const type = m ? m[1].trim() : it;\n          let mount = m && m[2] ? m[2].trim().toLowerCase() : '';\n          if (!mount) {\n            mount = /adapted|via adapter/i.test(it) ? 'adapted' : 'native';\n          } else if (/via adapter/i.test(mount)) {\n            mount = 'adapted';\n          }\n          const notes = m && m[3] ? m[3].trim() : (/via adapter/i.test(it) ? 'via adapter' : '');\n          return { type, mount, notes };\n        }\n        return {\n          type: it.type || '',\n          mount: (it.mount ? it.mount : (it.native ? 'native' : (it.adapted ? 'adapted' : 'native'))).toLowerCase(),\n          notes: it.notes || ''\n        };\n      });\n    }\n    if (cam.power) {\n      cam.power.powerDistributionOutputs = ensureList(cam.power.powerDistributionOutputs, {\n        type: '',\n        voltage: '',\n        current: '',\n        wattage: null,\n        notes: ''\n      });\n    }\n    cam.videoOutputs = ensureList(cam.videoOutputs, { type: '', notes: '' }).flatMap(vo => {\n      const { count, ...rest } = vo || {};\n      const norm = normalizeVideoType(rest.type);\n      if (!VIDEO_OUTPUT_TYPES.has(norm)) return [];\n      const parsedCount = parseInt(count, 10);\n      const num = Number.isFinite(parsedCount) && parsedCount > 0 ? parsedCount : 1;\n      const base = { ...rest, type: norm, notes: rest.notes || '' };\n      return Array.from({ length: num }, () => ({ ...base }));\n    });\n    cam.fizConnectors = ensureList(cam.fizConnectors, { type: '', notes: '' }).map(fc => {\n      const { type, ...rest } = fc || {};\n      return { ...rest, type: normalizeFizConnectorType(type) };\n    });\n    cam.viewfinder = ensureList(cam.viewfinder, { type: '', resolution: '', connector: '', notes: '' }).map(vf => {\n      const { type, ...rest } = vf || {};\n      return {\n        ...rest,\n        type: normalizeViewfinderType(type)\n      };\n    });\n    cam.recordingMedia = ensureList(cam.recordingMedia, { type: '', notes: '' }).map(m => {\n      let { type = '', notes = '' } = m || {};\n      const match = type.match(/^(.*?)(?:\\((.*)\\))?$/);\n      if (match) {\n        type = match[1].trim();\n        notes = notes || (match[2] ? match[2].trim() : '');\n      }\n      if (/^SD UHS-II$/i.test(type)) {\n        type = 'SD Card';\n        notes = notes ? `${notes}; UHS-II` : 'UHS-II';\n      } else if (/^SD \\(UHS-II\\/UHS-I\\)$/i.test(type)) {\n        type = 'SD Card';\n        notes = 'UHS-II/UHS-I';\n      } else if (type === 'CFast 2.0 card slots') {\n        type = 'CFast 2.0';\n        notes = notes || 'Dual Slots';\n      } else if (type === 'CFexpress Type B (Dual Slots)') {\n        type = 'CFexpress Type B';\n        notes = notes || 'Dual Slots';\n      } else if (type === 'CFexpress Type B (via adapter)') {\n        type = 'CFexpress Type B';\n        notes = notes || 'via adapter';\n      } else if (/^SD UHS-II \\(Dual Slots\\)$/i.test(type)) {\n        type = 'SD Card';\n        notes = notes ? `${notes}; UHS-II (Dual Slots)` : 'UHS-II (Dual Slots)';\n      } else if (type === 'SD Card (Dual Slots)') {\n        type = 'SD Card';\n        notes = notes || 'Dual Slots';\n      } else if (type === 'SD card slot (for proxy/backup)') {\n        type = 'SD Card';\n        notes = notes || 'for proxy/backup';\n      }\n      return { type, notes };\n    });\n    cam.timecode = ensureList(cam.timecode, { type: '', notes: '' });\n    cam.lensMount = ensureList(cam.lensMount, { type: '', mount: 'native', notes: '' })\n      .map(lm => ({\n        type: lm.type,\n        mount: (lm.mount ? lm.mount.toLowerCase() : 'native'),\n        notes: lm.notes || ''\n      }))\n      .filter((lm, idx, arr) =>\n        idx === arr.findIndex(o => o.type === lm.type && o.mount === lm.mount && o.notes === lm.notes)\n      );\n  });\n\n  ['monitors', 'video', 'viewfinders'].forEach(key => {\n    applyFixPowerInput(devicesData[key]);\n  });\n\n  const fizGroups = devicesData.fiz || {};\n  ['motors', 'controllers', 'distance'].forEach(key => {\n    applyFixPowerInput(fizGroups[key]);\n  });\n\n  // Normalize FIZ motors\n  Object.values(devicesData.fiz?.motors || {}).forEach(m => {\n    if (!m) return;\n    if (m.connector && !m.fizConnector) {\n      m.fizConnector = m.connector;\n      delete m.connector;\n    }\n    if (m.fizConnector) {\n      m.fizConnector = normalizeFizConnectorType(m.fizConnector);\n    }\n  });\n\n  // Normalize FIZ controllers\n  Object.values(devicesData.fiz?.controllers || {}).forEach(c => {\n    if (!c) return;\n    if (c.FIZ_connector && !c.fizConnector && !c.fizConnectors) {\n      c.fizConnector = c.FIZ_connector;\n      delete c.FIZ_connector;\n    }\n    if (Array.isArray(c.fizConnectors)) {\n      c.fizConnectors = c.fizConnectors.map(fc => {\n        if (!fc) return { type: '' };\n        const type = normalizeFizConnectorType(fc.type || fc);\n        const notes = fc.notes || undefined;\n        return notes ? { type, notes } : { type };\n      });\n    } else if (c.fizConnector) {\n      const parts = String(c.fizConnector)\n        .split(',')\n        .map(s => s.trim())\n        .filter(Boolean);\n      c.fizConnectors = parts.map(p => ({ type: normalizeFizConnectorType(p) }));\n      delete c.fizConnector;\n    } else {\n      c.fizConnectors = [];\n    }\n  });\n}\n\n// Store a deep copy of the initial 'devices' data as defined in the device files.\n// This 'defaultDevices' will be used when reverting the database.\n// Initialize defaultDevices only if it hasn't been declared yet, to prevent\n// \"already declared\" errors if the script is loaded multiple times.\nif (window.defaultDevices === undefined) {\n  window.defaultDevices = JSON.parse(JSON.stringify(devices));\n  unifyDevices(window.defaultDevices);\n}\n\n// Load any saved device data from localStorage\nlet storedDevices = loadDeviceData();\nif (storedDevices) {\n  // Merge stored devices with the defaults so that categories missing\n  // from saved data (e.g. FIZ) fall back to the built-in definitions.\n  const merged = JSON.parse(JSON.stringify(window.defaultDevices));\n  for (const [key, value] of Object.entries(storedDevices)) {\n    if (key === 'fiz' && value && typeof value === 'object') {\n      merged.fiz = merged.fiz || {};\n      for (const [sub, subVal] of Object.entries(value)) {\n        merged.fiz[sub] = {\n          ...(merged.fiz[sub] || {}),\n          ...(subVal || {}),\n        };\n      }\n    } else if (merged[key] && typeof merged[key] === 'object') {\n      merged[key] = { ...merged[key], ...(value || {}) };\n    } else {\n      merged[key] = value;\n    }\n  }\n  devices = merged;\n}\nunifyDevices(devices);\n\nfunction getBatteryPlateSupport(name) {\n  const cam = devices.cameras[name];\n  if (!cam || !cam.power || !Array.isArray(cam.power.batteryPlateSupport)) return [];\n  return cam.power.batteryPlateSupport.filter(Boolean);\n}\n\nfunction getSupportedBatteryPlates(name) {\n  return getBatteryPlateSupport(name)\n    .map(bp => bp.type)\n    .filter(Boolean);\n}\n\nfunction getAvailableBatteryPlates(name) {\n  const support = getBatteryPlateSupport(name);\n  if (!support.length) return [];\n  const nativeTypes = new Set(\n    support\n      .filter(bp => bp.mount === 'native' && bp.type)\n      .map(bp => bp.type)\n  );\n  if (nativeTypes.size === 1 && nativeTypes.has('B-Mount')) {\n    return ['B-Mount'];\n  }\n  return [...new Set(getSupportedBatteryPlates(name))];\n}\n\nfunction supportsMountCamera(name, mountType) {\n  return getAvailableBatteryPlates(name).includes(mountType);\n}\n\nfunction supportsBMountCamera(name) {\n  return supportsMountCamera(name, 'B-Mount');\n}\n\nfunction supportsGoldMountCamera(name) {\n  return supportsMountCamera(name, 'Gold-Mount');\n}\n\nfunction getBatteriesByMount(mountType) {\n  const out = {};\n  for (const [name, info] of Object.entries(devices.batteries)) {\n    if (info && info.mount_type === mountType) out[name] = info;\n  }\n  return out;\n}\n\nfunction getHotswapsByMount(mountType) {\n  const out = {};\n  for (const [name, info] of Object.entries(devices.batteryHotswaps || {})) {\n    if (info && info.mount_type === mountType) out[name] = info;\n  }\n  return out;\n}\n\nfunction getSelectedPlate() {\n  const camName = cameraSelect.value;\n  const plates = getAvailableBatteryPlates(camName);\n  if (!plates.length) return null;\n  return batteryPlateSelect.value || (plates.includes('V-Mount') ? 'V-Mount' : plates[0]);\n}\n\nfunction isSelectedPlateNative(camName) {\n  const plate = getSelectedPlate();\n  const cam = devices.cameras[camName];\n  if (!plate || !cam || !cam.power || !Array.isArray(cam.power.batteryPlateSupport)) return false;\n  return cam.power.batteryPlateSupport.some(bp => bp.type === plate && bp.mount === 'native');\n}\n\nfunction shortConnLabel(type) {\n  if (!type) return '';\n  return String(type).replace(/\\(.*?\\)/, '').trim();\n}\n\nfunction formatConnLabel(from, to) {\n  const a = shortConnLabel(from);\n  const b = shortConnLabel(to);\n  if (!a) return b || '';\n  if (!b || a.toLowerCase() === b.toLowerCase()) return a;\n  return `${a} to ${b}`;\n}\n\n\nconst hasCamConnector = str => /CAM/i.test(str);\nconst hasLemo7PinConnector = str => /7-pin/i.test(str);\n\n// Collect a list of FIZ connector type strings from a device definition.\nfunction getFizConnectorTypes(device) {\n  if (!device) return [];\n  if (Array.isArray(device.fizConnectors)) {\n    return device.fizConnectors.map(fc => fc.type);\n  }\n  return device.fizConnector ? [device.fizConnector] : [];\n}\n\nfunction controllerCamPort(name) {\n  const isRf = /cforce.*rf/i.test(name) || /RIA-1/i.test(name);\n  if (isRf) return 'Cam';\n  const c = devices.fiz?.controllers?.[name];\n  if (c) {\n    if (/UMC-4/i.test(name)) return '3-Pin R/S';\n    const connStr = getFizConnectorTypes(c).join(', ');\n    if (hasCamConnector(connStr)) return 'Cam';\n    if (hasLemo7PinConnector(connStr)) return 'LEMO 7-pin';\n  }\n  const m = devices.fiz?.motors?.[name];\n  if (m) {\n    const connStr = getFizConnectorTypes(m).join(', ');\n    if (hasCamConnector(connStr)) return 'Cam';\n    if (hasLemo7PinConnector(connStr)) return 'LEMO 7-pin';\n  }\n  if (isArriOrCmotion(name) && !isRf) return 'LBUS';\n  return 'FIZ Port';\n}\n\nfunction controllerDistancePort(name) {\n  const c = devices.fiz?.controllers?.[name];\n  if (/RIA-1/i.test(name) || /UMC-4/i.test(name)) return 'Serial';\n  if (getFizConnectorTypes(c).some(type => /SERIAL/i.test(type))) return 'Serial';\n  return 'LBUS';\n}\n\nfunction controllerPriority(name) {\n  if (/cforce.*rf/i.test(name) || /RIA-1/i.test(name) || /UMC-4/i.test(name)) return 0;\n  if (/Master Grip/i.test(name) || /ZMU-4/i.test(name) || /OCU-1/i.test(name)) return 1;\n  return 2;\n}\n\nfunction motorPriority(name) {\n  const m = devices.fiz?.motors?.[name];\n  if (m && m.internalController && /CAM/i.test(m.fizConnector || '')) return 0;\n  return 1;\n}\nfunction isArriOrCmotion(name) {\n  return /^(ARRI|Arri)/i.test(name) || /cmotion/i.test(name);\n}\n\nfunction isArri(name) {\n  return /arri/i.test(name);\n}\nfunction fizNeedsPower(name) {\n  const d = devices.fiz?.controllers?.[name] || devices.fiz?.motors?.[name];\n  if (!d) return false;\n  const ps = String(d.powerSource || '').toLowerCase();\n  if (ps.includes('internal battery') && !ps.includes('external')) return false;\n  return true;\n}\n\n\nfunction firstConnector(str) {\n  if (!str) return '';\n  return str.split(',')[0].trim();\n}\n\n/**\n * Returns the first FIZ connector for a device, optionally prioritizing\n * connectors that match a set of regular expressions. This consolidates the\n * repeated logic for choosing between `fizConnector` and `fizConnectors` while\n * keeping any existing preference order.\n *\n * @param {object} device - Device object that may include `fizConnector` or\n *   `fizConnectors`.\n * @param {RegExp[]} [preferredMatchers=[]] - Regex patterns to prioritize.\n * @returns {string} The normalized connector label or an empty string if none\n *   is found.\n */\nfunction getFizPort(device, preferredMatchers = []) {\n  if (!device) return '';\n  const connectors = Array.isArray(device.fizConnectors)\n    ? device.fizConnectors\n    : [];\n  for (const matcher of preferredMatchers) {\n    const match = connectors.find(fc => matcher.test(fc.type));\n    if (match) return firstConnector(match.type);\n  }\n  const portStr = device.fizConnector || connectors[0]?.type;\n  return firstConnector(portStr);\n}\n\nfunction cameraFizPort(camName, controllerPort, deviceName = '') {\n  const cam = devices.cameras[camName];\n  if (!cam || !Array.isArray(cam.fizConnectors) || cam.fizConnectors.length === 0) return 'LBUS';\n  if (!controllerPort) return cam.fizConnectors[0].type;\n\n  // If a non-ARRI FIZ device is attached to an ARRI camera, prefer the EXT port\n  if (isArri(camName) && deviceName && !isArri(deviceName)) {\n    const ext = cam.fizConnectors.find(fc => /ext/i.test(fc.type));\n    if (ext) return ext.type;\n  }\n\n  const norm = shortConnLabel(firstConnector(controllerPort)).toLowerCase();\n  const match = cam.fizConnectors.find(fc => shortConnLabel(fc.type).toLowerCase() === norm);\n  return match ? match.type : cam.fizConnectors[0].type;\n}\n\nfunction controllerFizPort(name) {\n  const c = devices.fiz?.controllers?.[name];\n  if (/UMC-4/i.test(name)) {\n    return getFizPort(c, [/LCS/i]) || 'LCS (LEMO 7-pin)';\n  }\n  const port = getFizPort(c);\n  return port || (isArriOrCmotion(name) ? 'LBUS' : 'Proprietary');\n}\n\nfunction motorFizPort(name) {\n  const m = devices.fiz?.motors?.[name];\n  const port = getFizPort(m);\n  return port || (isArriOrCmotion(name) ? 'LBUS' : 'Proprietary');\n}\n\nfunction distanceFizPort(name) {\n  const d = devices.fiz?.distance?.[name];\n  if (!d) return 'LBUS';\n  const port = getFizPort(d, [/LBUS/i, /SERIAL/i]);\n  if (port) return port;\n  return /preston/i.test(name) ? 'Serial' : 'LBUS';\n}\n\nfunction fizPort(name) {\n  if (devices.fiz?.controllers?.[name]) return controllerFizPort(name);\n  if (devices.fiz?.motors?.[name]) return motorFizPort(name);\n  if (devices.fiz?.distance?.[name]) return distanceFizPort(name);\n  return 'LBUS';\n}\n\nfunction fizPowerPort(name) {\n  if (/cforce.*rf/i.test(name) || /RIA-1/i.test(name)) return 'Cam';\n  return fizPort(name);\n}\n\nfunction sdiRate(type) {\n  const m = /([\\d.]+)G-SDI/i.exec(type || '');\n  if (m) return parseFloat(m[1]);\n  return /SDI/i.test(type || '') ? 1 : null;\n}\nfunction connectionLabel(outType, inType) {\n  if (!outType || !inType) return \"\";\n  if (/HDMI/i.test(outType) && /HDMI/i.test(inType)) return \"HDMI\";\n  if (/SDI/i.test(outType) && /SDI/i.test(inType)) {\n    const rate = Math.min(sdiRate(outType) || 0, sdiRate(inType) || 0) || sdiRate(outType) || sdiRate(inType) || 0;\n    if (rate >= 12) return \"12G-SDI\";\n    if (rate >= 6) return \"6G-SDI\";\n    if (rate >= 3) return \"3G-SDI\";\n    if (rate >= 1.5) return \"1.5G-SDI\";\n    return \"SDI\";\n  }\n  if (/HDMI/i.test(outType)) return \"HDMI\";\n  if (/SDI/i.test(outType)) return \"SDI\";\n  return \"\";\n}\n\n\nfunction updateBatteryPlateVisibility() {\n  const camName = cameraSelect.value;\n  const plates = getAvailableBatteryPlates(camName);\n  const current = batteryPlateSelect.value;\n  batteryPlateSelect.innerHTML = '';\n  if (plates.length) {\n    plates.forEach(pt => {\n      const opt = document.createElement('option');\n      opt.value = pt;\n      opt.textContent = pt;\n      batteryPlateSelect.appendChild(opt);\n    });\n    let def = current;\n    if (!plates.includes(def)) {\n      def = plates.includes('V-Mount') ? 'V-Mount' : plates[0];\n    }\n    batteryPlateSelect.value = def;\n    batteryPlateRow.style.display = '';\n  } else {\n    batteryPlateRow.style.display = 'none';\n    batteryPlateSelect.value = '';\n  }\n  updateViewfinderSettingsVisibility();\n  updateViewfinderExtensionVisibility();\n  updateMonitoringConfigurationOptions();\n}\n\nfunction updateViewfinderSettingsVisibility() {\n  const cam = devices?.cameras?.[cameraSelect?.value];\n  const hasViewfinder = Array.isArray(cam?.viewfinder) && cam.viewfinder.length > 0;\n  const config = monitoringConfigurationSelect?.value;\n  const show = hasViewfinder && (config === 'Viewfinder only' || config === 'Viewfinder and Onboard');\n  if (viewfinderSettingsRow) {\n    if (show) {\n      viewfinderSettingsRow.classList.remove('hidden');\n    } else {\n      viewfinderSettingsRow.classList.add('hidden');\n      const vfSelect = document.getElementById('viewfinderSettings');\n      if (vfSelect) {\n        Array.from(vfSelect.options).forEach(o => { o.selected = false; });\n      }\n    }\n  }\n}\n\nfunction updateMonitoringConfigurationOptions() {\n  if (!monitoringConfigurationSelect) return;\n  const cam = devices?.cameras?.[cameraSelect?.value];\n  const hasViewfinder = Array.isArray(cam?.viewfinder) && cam.viewfinder.length > 0;\n  const monitorSelected = monitorSelect && monitorSelect.value && monitorSelect.value !== 'None';\n  const vfOnlyOption = Array.from(monitoringConfigurationSelect.options || [])\n    .find(o => o.value === 'Viewfinder only');\n  if (!vfOnlyOption) return;\n  const show = hasViewfinder && !monitorSelected;\n  vfOnlyOption.hidden = !show;\n  if (monitoringConfigurationUserChanged) {\n    if (!show && monitoringConfigurationSelect.value === 'Viewfinder only') {\n      monitoringConfigurationSelect.value = hasViewfinder ? 'Viewfinder and Onboard' : 'Onboard Only';\n    }\n    updateViewfinderSettingsVisibility();\n    return;\n  }\n\n  if (monitorSelected) {\n    monitoringConfigurationSelect.value = hasViewfinder ? 'Viewfinder and Onboard' : 'Onboard Only';\n  } else if (!hasViewfinder) {\n    monitoringConfigurationSelect.value = 'Onboard Only';\n  } else {\n    monitoringConfigurationSelect.value = 'Viewfinder only';\n  }\n  updateViewfinderSettingsVisibility();\n}\n\nfunction updateViewfinderExtensionVisibility() {\n  const cam = devices?.cameras?.[cameraSelect?.value];\n  const hasViewfinder = Array.isArray(cam?.viewfinder) && cam.viewfinder.length > 0;\n  if (viewfinderExtensionRow) {\n    if (hasViewfinder) {\n      viewfinderExtensionRow.classList.remove('hidden');\n    } else {\n      viewfinderExtensionRow.classList.add('hidden');\n      const vfExtSel = document.getElementById('viewfinderExtension');\n      if (vfExtSel) {\n        vfExtSel.value = '';\n      }\n    }\n  }\n}\n\nfunction updateBatteryLabel() {\n  const label = document.getElementById('batteryLabel');\n  if (!label) return;\n  label.setAttribute('data-help', texts[currentLang].batterySelectHelp);\n  if (getSelectedPlate() === 'B-Mount') {\n    label.textContent = texts[currentLang].batteryBMountLabel || 'B-Mount Battery:';\n  } else {\n    label.textContent = texts[currentLang].batteryLabel;\n  }\n}\n\nfunction updateBatteryOptions() {\n  const current = batterySelect.value;\n  const currentSwap = hotswapSelect.value;\n  const plate = getSelectedPlate();\n  const camName = cameraSelect.value;\n  const supportsB = supportsBMountCamera(camName);\n  const supportsGold = supportsGoldMountCamera(camName);\n  let swaps;\n  if (plate === 'B-Mount') {\n    populateSelect(batterySelect, getBatteriesByMount('B-Mount'), true);\n    swaps = getHotswapsByMount('B-Mount');\n  } else if (plate === 'V-Mount') {\n    populateSelect(batterySelect, getBatteriesByMount('V-Mount'), true);\n    swaps = getHotswapsByMount('V-Mount');\n  } else if (plate === 'Gold-Mount') {\n    populateSelect(batterySelect, getBatteriesByMount('Gold-Mount'), true);\n    swaps = getHotswapsByMount('Gold-Mount');\n  } else {\n    let bats = devices.batteries;\n    if (!supportsB) {\n      bats = Object.fromEntries(Object.entries(bats).filter(([, b]) => b.mount_type !== 'B-Mount'));\n    }\n    if (!supportsGold) {\n      bats = Object.fromEntries(Object.entries(bats).filter(([, b]) => b.mount_type !== 'Gold-Mount'));\n    }\n    populateSelect(batterySelect, bats, true);\n    swaps = devices.batteryHotswaps || {};\n    if (!supportsB) {\n      swaps = Object.fromEntries(Object.entries(swaps).filter(([, b]) => b.mount_type !== 'B-Mount'));\n    }\n    if (!supportsGold) {\n      swaps = Object.fromEntries(Object.entries(swaps).filter(([, b]) => b.mount_type !== 'Gold-Mount'));\n    }\n  }\n  if (!/FXLion Nano/i.test(current)) {\n    swaps = Object.fromEntries(\n      Object.entries(swaps).filter(([name]) => name !== 'FX-Lion NANO Dual V-Mount Hot-Swap Plate')\n    );\n  }\n\n  // Filter out hotswaps that cannot supply the required current\n  const totalCurrentLow = parseFloat(totalCurrent12Elem.textContent);\n  if (isFinite(totalCurrentLow) && totalCurrentLow > 0) {\n    swaps = Object.fromEntries(\n      Object.entries(swaps).filter(([, info]) => typeof info.pinA !== 'number' || info.pinA >= totalCurrentLow)\n    );\n  }\n\n  populateSelect(hotswapSelect, swaps, true);\n  if (Array.from(batterySelect.options).some(o => o.value === current)) {\n    batterySelect.value = current;\n  }\n  updateFavoriteButton(batterySelect);\n  if (Array.from(hotswapSelect.options).some(o => o.value === currentSwap)) {\n    hotswapSelect.value = currentSwap;\n  }\n  updateFavoriteButton(hotswapSelect);\n  updateBatteryLabel();\n}\n\nconst BRAND_KEYWORDS = {\n  arri: 'arri',\n  cmotion: 'cmotion',\n  focusbug: 'focusbug',\n  tilta: 'tilta',\n  preston: 'preston',\n  chrosziel: 'chrosziel',\n  smallrig: 'smallrig',\n  dji: 'dji',\n  redrock: 'redrock',\n  teradek: 'teradek'\n};\n\nfunction detectBrand(name) {\n  if (!name) return null;\n  const n = String(name).trim().toLowerCase();\n  if (n === 'none') return null;\n  for (const [keyword, brand] of Object.entries(BRAND_KEYWORDS)) {\n    if (n.includes(keyword)) return brand;\n  }\n  return 'other';\n}\n\nconst STATUS_CLASS_BY_LEVEL = {\n  info: 'status-message--info',\n  success: 'status-message--success',\n  warning: 'status-message--warning',\n  danger: 'status-message--danger'\n};\n\nfunction setStatusLevel(element, level) {\n  if (!element) return;\n\n  const severityClasses = Object.values(STATUS_CLASS_BY_LEVEL);\n  if (element.classList) {\n    severityClasses.forEach(cls => element.classList.remove(cls));\n  } else if (typeof element.className === 'string') {\n    const remaining = element.className\n      .split(/\\s+/)\n      .filter(Boolean)\n      .filter(cls => !severityClasses.includes(cls));\n    element.className = remaining.join(' ');\n  }\n\n  const normalized = level && STATUS_CLASS_BY_LEVEL[level] ? level : null;\n  if (normalized) {\n    const severityClass = STATUS_CLASS_BY_LEVEL[normalized];\n    if (element.classList) {\n      if (!element.classList.contains('status-message')) {\n        element.classList.add('status-message');\n      }\n      element.classList.add(severityClass);\n    } else if (typeof element.className === 'string') {\n      const classes = element.className.split(/\\s+/).filter(Boolean);\n      if (!classes.includes('status-message')) {\n        classes.push('status-message');\n      }\n      classes.push(severityClass);\n      element.className = Array.from(new Set(classes)).join(' ');\n    }\n    if (element.dataset) {\n      element.dataset.statusLevel = normalized;\n    } else if (element.setAttribute) {\n      element.setAttribute('data-status-level', normalized);\n    }\n  } else if (element.dataset && 'statusLevel' in element.dataset) {\n    delete element.dataset.statusLevel;\n  } else if (element.removeAttribute) {\n    element.removeAttribute('data-status-level');\n  }\n}\n\nfunction formatStatusMessage(message) {\n  if (typeof message !== 'string' || message.length === 0) {\n    return '';\n  }\n\n  const match = message.match(/^([A-Z\xC0-\xD6\xD8-\xDD]+(?:[\\s\\u00A0-][A-Z\xC0-\xD6\xD8-\xDD]+)*)([\\s\\u00A0]*:)([\\s\\u00A0]*)/u);\n  if (match) {\n    const [, label, colonPart, trailingSpace] = match;\n    const rest = message.slice(match[0].length);\n    return `<strong>${escapeHtml(label)}${escapeHtml(colonPart)}</strong>${escapeHtml(trailingSpace)}${escapeHtml(rest)}`;\n  }\n\n  return escapeHtml(message);\n}\n\nfunction setStatusMessage(element, message) {\n  if (!element) return;\n  if (!message) {\n    element.textContent = '';\n    return;\n  }\n\n  element.innerHTML = formatStatusMessage(message);\n}\n\nfunction checkFizCompatibility() {\n  const brands = new Set();\n  motorSelects.forEach(sel => { const b = detectBrand(sel.value); if (b) brands.add(b); });\n  controllerSelects.forEach(sel => { const b = detectBrand(sel.value); if (b) brands.add(b); });\n  const distB = detectBrand(distanceSelect.value);\n  if (distB) brands.add(distB);\n  const cameraBrand = detectBrand(cameraSelect.value);\n\n  const compatElem = document.getElementById('compatWarning');\n  if (!compatElem) return;\n\n  let incompatible = false;\n  const arr = Array.from(brands);\n\n  if (cameraBrand === 'dji' && arr.some(b => b && b !== 'dji')) {\n    incompatible = true;\n  } else if (arr.length > 1) {\n    const allowed = ['arri', 'cmotion', 'focusbug'];\n    if (arr.every(b => allowed.includes(b))) {\n      incompatible = false;\n    } else {\n      const filtered = arr.filter(b => b !== 'other');\n      const distinct = new Set(filtered);\n      if (distinct.size > 1) incompatible = true;\n    }\n  }\n\n  if (incompatible) {\n    setStatusMessage(compatElem, texts[currentLang].incompatibleFIZWarning);\n    setStatusLevel(compatElem, 'danger');\n  } else {\n    setStatusMessage(compatElem, '');\n    setStatusLevel(compatElem, null);\n  }\n}\n\nfunction checkFizController() {\n  const compatElem = document.getElementById('compatWarning');\n  if (!compatElem) return;\n\n  const motors = motorSelects.map(sel => sel.value).filter(v => v && v !== 'None');\n  if (!motors.length) return;\n\n  const controllers = controllerSelects.map(sel => sel.value).filter(v => v && v !== 'None');\n  const camName = cameraSelect.value;\n  const cam = devices.cameras[camName];\n\n  const isAmira = /Arri Amira/i.test(camName);\n  const onlyCforceMiniPlus = motors.length > 0 && motors.every(n => {\n    const lower = n.toLowerCase();\n    return ((lower.includes('cforce mini') && !lower.includes('rf')) || lower.includes('cforce plus'));\n  });\n  const hasRemoteController = controllers.some(n => /ria-1|umc-4|cforce.*rf/i.test(n)) || motors.some(n => /cforce.*rf/i.test(n));\n  if (isAmira && onlyCforceMiniPlus && !hasRemoteController) {\n    setStatusMessage(compatElem, texts[currentLang].amiraCforceRemoteWarning);\n    setStatusLevel(compatElem, 'danger');\n    return;\n  }\n\n  const cameraHasLBUS = Array.isArray(cam?.fizConnectors) &&\n    cam.fizConnectors.some(fc => /LBUS/i.test(fc.type));\n  let hasController = cameraHasLBUS && /arri/i.test(camName);\n\n  controllers.forEach(name => {\n    const c = devices.fiz.controllers[name];\n    if (!c) return;\n    const connStr = (c.fizConnectors || []).map(fc => fc.type).join(', ');\n    if (/CAM|SERIAL|Motor/i.test(connStr)) hasController = true;\n    if (c.internalController) hasController = true;\n  });\n\n  motors.forEach(name => {\n    const m = devices.fiz.motors[name];\n    if (m && m.internalController) hasController = true;\n  });\n\n  const needController = motors.some(name => {\n    const m = devices.fiz.motors[name];\n    return m && m.internalController === false;\n  });\n\n  if (needController && !hasController) {\n    setStatusMessage(compatElem, texts[currentLang].missingFIZControllerWarning);\n    setStatusLevel(compatElem, 'danger');\n  }\n}\n\nfunction checkArriCompatibility() {\n  const compatElem = document.getElementById('compatWarning');\n  if (!compatElem || compatElem.textContent) return;\n\n  let motors = motorSelects.map(sel => sel.value).filter(v => v && v !== 'None');\n  motors.sort((a, b) => motorPriority(a) - motorPriority(b));\n  const internalIdx = motors.findIndex(name => devices.fiz?.motors?.[name]?.internalController);\n  const hasInternalMotor = internalIdx !== -1;\n  if (hasInternalMotor && internalIdx > 0) {\n    const [m] = motors.splice(internalIdx, 1);\n    motors.unshift(m);\n  }\n  let controllers = controllerSelects.map(sel => sel.value).filter(v => v && v !== 'None');\n  controllers.sort((a, b) => controllerPriority(a) - controllerPriority(b));\n  const distance = distanceSelect.value;\n\n  const camName = cameraSelect.value;\n  const cam = devices.cameras[camName];\n  const cameraHasLBUS = Array.isArray(cam?.fizConnectors) &&\n    cam.fizConnectors.some(fc => /LBUS/i.test(fc.type));\n  const builtInController = cameraHasLBUS && /arri/i.test(camName);\n\n  const usesUMC4 = controllers.some(n => /UMC-4/i.test(n));\n  const usesRIA1 = controllers.some(n => /RIA-1/i.test(n));\n  const usesRF = controllers.some(n => /cforce.*rf/i.test(n)) || motors.some(m => /cforce.*rf/i.test(m));\n\n  const camCounts = /(Alexa Mini LF|Alexa Mini|Alexa 35)/i.test(camName);\n  const onlyMasterGrip =\n    controllers.length > 0 &&\n    controllers.every(n => /Master Grip/i.test(n)) &&\n    !camCounts;\n\n  let msg = '';\n  const clmRegex = /CLM-[345]/i;\n  const hasCLM = motors.some(m => clmRegex.test(m));\n  if (hasCLM && !usesUMC4) {\n    msg = texts[currentLang].arriCLMNoUMC4Warning;\n  } else if (usesUMC4 && motors.some(m => !clmRegex.test(m))) {\n    msg = texts[currentLang].arriUMC4Warning;\n  } else if ((usesRIA1 || usesRF) && motors.some(m => clmRegex.test(m))) {\n    msg = texts[currentLang].arriRIA1Warning;\n  } else if (\n    distance &&\n    distance !== 'None' &&\n    !(usesUMC4 || usesRIA1 || usesRF || builtInController)\n  ) {\n    msg = texts[currentLang].distanceControllerWarning;\n  } else if (onlyMasterGrip && !usesRF) {\n    msg = texts[currentLang].masterGripWirelessWarning;\n  }\n\n  if (msg) {\n    setStatusMessage(compatElem, msg);\n    if (msg === texts[currentLang].arriUMC4Warning) {\n      setStatusLevel(compatElem, 'warning');\n    } else {\n      setStatusLevel(compatElem, 'danger');\n    }\n  }\n}\n\nlet gearItemTranslations = {};\n// Load translations when not already present (mainly for tests)\nif (typeof texts === 'undefined') {\n  try {\n    const translations = require('./translations.js');\n    window.texts = translations.texts;\n    window.categoryNames = translations.categoryNames;\n    window.gearItems = translations.gearItems;\n    gearItemTranslations = translations.gearItems || {};\n  } catch (e) {\n    console.warn('Failed to load translations', e);\n  }\n} else {\n  gearItemTranslations = typeof gearItems !== 'undefined' ? gearItems : {};\n}\n\n\n// Determine initial language (default English)\nlet currentLang = \"en\";\nlet updateHelpQuickLinksForLanguage;\nlet updateHelpResultsSummaryText;\nlet lastRuntimeHours = null;\ntry {\n  const savedLang = localStorage.getItem(\"language\");\n  const supported = [\"en\", \"de\", \"es\", \"fr\", \"it\"];\n  if (savedLang && supported.includes(savedLang)) {\n    currentLang = savedLang;\n  } else if (typeof navigator !== \"undefined\") {\n    const navLangs = Array.isArray(navigator.languages)\n      ? navigator.languages\n      : [navigator.language];\n    for (const lang of navLangs) {\n      const short = String(lang).slice(0, 2).toLowerCase();\n      if (supported.includes(short)) {\n        currentLang = short;\n        break;\n      }\n    }\n  }\n} catch (e) {\n  console.warn(\"Could not load language from localStorage\", e);\n}\n\n// Helper to apply translations to all UI text\nfunction setLanguage(lang) {\n  currentLang = lang;\n  // persist selected language\n  try {\n    localStorage.setItem(\"language\", lang);\n  } catch (e) {\n    console.warn(\"Could not save language to localStorage\", e);\n  }\n  // ensure dropdown reflects the active language\n  if (languageSelect) {\n    languageSelect.value = lang;\n  }\n  if (settingsLanguage) {\n    settingsLanguage.value = lang;\n  }\n  // update html lang attribute for better persistence\n  document.documentElement.lang = lang;\n  // Document title and main heading share the same text\n  document.title = texts[lang].appTitle;\n  document.getElementById(\"mainTitle\").textContent = texts[lang].appTitle;\n  document.getElementById(\"tagline\").textContent = texts[lang].tagline;\n  if (skipLink) skipLink.textContent = texts[lang].skipToContent;\n  const offlineElem = document.getElementById(\"offlineIndicator\");\n  if (offlineElem) {\n    offlineElem.textContent = texts[lang].offlineIndicator;\n    const offlineHelp =\n      texts[lang].offlineIndicatorHelp || texts[lang].offlineIndicator;\n    offlineElem.setAttribute(\"data-help\", offlineHelp);\n  }\n  applyInstallTexts(lang);\n  const legalLinks = LEGAL_LINKS[lang] || LEGAL_LINKS.en;\n  const impressumElem = document.getElementById(\"impressumLink\");\n  if (impressumElem) {\n    impressumElem.textContent = texts[lang].impressum;\n    if (legalLinks?.imprint) {\n      impressumElem.setAttribute(\"href\", legalLinks.imprint);\n    }\n  }\n  const privacyElem = document.getElementById(\"privacyLink\");\n  if (privacyElem) {\n    privacyElem.textContent = texts[lang].privacy;\n    if (legalLinks?.privacy) {\n      privacyElem.setAttribute(\"href\", legalLinks.privacy);\n    }\n  }\n  // Section headings with descriptive hover help\n  const setupManageHeadingElem = document.getElementById(\"setupManageHeading\");\n  setupManageHeadingElem.textContent = texts[lang].setupManageHeading;\n  setupManageHeadingElem.setAttribute(\n    \"data-help\",\n    texts[lang].setupManageHeadingHelp\n  );\n\n  const deviceSelectionHeadingElem = document.getElementById(\"deviceSelectionHeading\");\n  deviceSelectionHeadingElem.textContent = texts[lang].deviceSelectionHeading;\n  deviceSelectionHeadingElem.setAttribute(\n    \"data-help\",\n    texts[lang].deviceSelectionHeadingHelp\n  );\n\n  const resultsHeadingElem = document.getElementById(\"resultsHeading\");\n  resultsHeadingElem.textContent = texts[lang].resultsHeading; // Fixed typo here\n  resultsHeadingElem.setAttribute(\n    \"data-help\",\n    texts[lang].resultsHeadingHelp\n  );\n\n  const deviceManagerHeadingElem = document.getElementById(\"deviceManagerHeading\");\n  deviceManagerHeadingElem.textContent = texts[lang].deviceManagerHeading;\n  deviceManagerHeadingElem.setAttribute(\n    \"data-help\",\n    texts[lang].deviceManagerHeadingHelp\n  );\n\n  const batteryComparisonHeadingElem = document.getElementById(\"batteryComparisonHeading\");\n  batteryComparisonHeadingElem.textContent = texts[lang].batteryComparisonHeading;\n  batteryComparisonHeadingElem.setAttribute(\n    \"data-help\",\n    texts[lang].batteryComparisonHeadingHelp\n  );\n\n  const setupDiagramHeadingElem = document.getElementById(\"setupDiagramHeading\");\n  setupDiagramHeadingElem.textContent = texts[lang].setupDiagramHeading;\n  setupDiagramHeadingElem.setAttribute(\n    \"data-help\",\n    texts[lang].setupDiagramHeadingHelp\n  );\n\n  const sideMenuLinks = document.querySelectorAll(\"#sideMenu [data-nav-key]\");\n  sideMenuLinks.forEach((link) => {\n    const navKey = link.dataset.navKey;\n    if (!navKey) {\n      return;\n    }\n    const label = texts[lang][navKey];\n    if (label) {\n      link.textContent = label;\n      link.setAttribute(\"aria-label\", label);\n    }\n    const helpKey = `${navKey}Help`;\n    const helpText = texts[lang][helpKey];\n    if (helpText) {\n      link.setAttribute(\"title\", helpText);\n      link.setAttribute(\"data-help\", helpText);\n    } else {\n      link.removeAttribute(\"title\");\n      link.removeAttribute(\"data-help\");\n    }\n  });\n  // Setup manager labels and buttons\n  const savedSetupsLabelElem = document.getElementById(\"savedSetupsLabel\");\n  savedSetupsLabelElem.textContent = texts[lang].savedSetupsLabel;\n  savedSetupsLabelElem.setAttribute(\"data-help\", texts[lang].setupSelectHelp);\n  const setupNameLabelElem = document.getElementById(\"setupNameLabel\");\n  setupNameLabelElem.textContent = texts[lang].setupNameLabel;\n  setupNameLabelElem.setAttribute(\"data-help\", texts[lang].setupNameHelp);\n  setButtonLabelWithIcon(deleteSetupBtn, texts[lang].deleteSetupBtn, ICON_GLYPHS.trash);\n  const sharedLinkLabelElem = document.getElementById(\"sharedLinkLabel\");\n  sharedLinkLabelElem.textContent = texts[lang].sharedLinkLabel;\n  sharedLinkLabelElem.setAttribute(\"data-help\", texts[lang].sharedLinkHelp);\n  setButtonLabelWithIcon(\n    applySharedLinkBtn,\n    texts[lang].loadSharedLinkBtn,\n    ICON_GLYPHS.fileImport\n  );\n\n  // Descriptive hover help for setup management controls\n  setupSelect.setAttribute(\"data-help\", texts[lang].setupSelectHelp);\n  setupNameInput.setAttribute(\"data-help\", texts[lang].setupNameHelp);\n\n  deleteSetupBtn.setAttribute(\"title\", texts[lang].deleteSetupHelp);\n  deleteSetupBtn.setAttribute(\"aria-label\", texts[lang].deleteSetupHelp);\n  deleteSetupBtn.setAttribute(\"data-help\", texts[lang].deleteSetupHelp);\n\n  saveSetupBtn.setAttribute(\"title\", texts[lang].saveSetupHelp);\n  saveSetupBtn.setAttribute(\"aria-label\", texts[lang].saveSetupHelp);\n  saveSetupBtn.setAttribute(\"data-help\", texts[lang].saveSetupHelp);\n\n  generateOverviewBtn.setAttribute(\"title\", texts[lang].generateOverviewBtn);\n  generateOverviewBtn.setAttribute(\"data-help\", texts[lang].generateOverviewHelp);\n\n  generateGearListBtn.setAttribute(\"title\", texts[lang].generateGearListBtn);\n  generateGearListBtn.setAttribute(\"data-help\", texts[lang].generateGearListHelp);\n\n  const deleteGearListHelp =\n    texts[lang].deleteGearListBtnHelp || texts[lang].deleteGearListBtn;\n  if (deleteGearListProjectBtn) {\n    setButtonLabelWithIcon(\n      deleteGearListProjectBtn,\n      texts[lang].deleteGearListBtn,\n      ICON_GLYPHS.trash\n    );\n    deleteGearListProjectBtn.setAttribute(\"title\", deleteGearListHelp);\n    deleteGearListProjectBtn.setAttribute(\"data-help\", deleteGearListHelp);\n    deleteGearListProjectBtn.setAttribute(\"aria-label\", deleteGearListHelp);\n  }\n\n  const editProjectBtnElem = document.getElementById(\"editProjectBtn\");\n  if (editProjectBtnElem) {\n    editProjectBtnElem.textContent = texts[lang].editProjectBtn;\n    editProjectBtnElem.setAttribute(\"title\", texts[lang].editProjectBtn);\n    editProjectBtnElem.setAttribute(\"data-help\", texts[lang].editProjectBtn);\n  }\n\n  shareSetupBtn.setAttribute(\"title\", texts[lang].shareSetupBtn);\n  shareSetupBtn.setAttribute(\"data-help\", texts[lang].shareSetupHelp);\n\n  if (shareDialogHeadingElem) {\n    const heading = texts[lang].shareDialogTitle\n      || texts.en?.shareDialogTitle\n      || shareDialogHeadingElem.textContent;\n    shareDialogHeadingElem.textContent = heading;\n  }\n\n  if (shareFilenameLabelElem) {\n    const filenameLabel = texts[lang].shareFilenameLabel\n      || texts.en?.shareFilenameLabel\n      || shareFilenameLabelElem.textContent;\n    shareFilenameLabelElem.textContent = filenameLabel;\n  }\n\n  if (shareConfirmBtn) {\n    const confirmLabel = texts[lang].shareDialogConfirm\n      || texts.en?.shareDialogConfirm\n      || shareConfirmBtn.textContent;\n    setButtonLabelWithIcon(shareConfirmBtn, confirmLabel, ICON_GLYPHS.fileExport);\n    shareConfirmBtn.setAttribute('title', confirmLabel);\n    shareConfirmBtn.setAttribute('aria-label', confirmLabel);\n    shareConfirmBtn.setAttribute('data-help', texts[lang].shareSetupHelp);\n  }\n\n  if (shareCancelBtn) {\n    const cancelLabel = texts[lang].shareDialogCancel\n      || texts.en?.shareDialogCancel\n      || shareCancelBtn.textContent;\n    setButtonLabelWithIcon(shareCancelBtn, cancelLabel, ICON_GLYPHS.circleX);\n    shareCancelBtn.setAttribute('title', cancelLabel);\n    shareCancelBtn.setAttribute('aria-label', cancelLabel);\n  }\n\n  if (shareIncludeAutoGearText) {\n    const label = texts[lang].shareIncludeAutoGearLabel\n      || texts.en?.shareIncludeAutoGearLabel\n      || shareIncludeAutoGearText.textContent;\n    shareIncludeAutoGearText.textContent = label;\n    const help = texts[lang].shareIncludeAutoGearHelp\n      || texts.en?.shareIncludeAutoGearHelp\n      || label;\n    if (shareIncludeAutoGearLabelElem) {\n      shareIncludeAutoGearLabelElem.setAttribute('data-help', help);\n    }\n    if (shareIncludeAutoGearCheckbox) {\n      shareIncludeAutoGearCheckbox.setAttribute('aria-label', label);\n    }\n  }\n\n  let sharedImportLegendText = sharedImportLegend ? sharedImportLegend.textContent : '';\n  if (sharedImportDialogHeading) {\n    const title = texts[lang].sharedImportDialogTitle\n      || texts.en?.sharedImportDialogTitle\n      || sharedImportDialogHeading.textContent;\n    sharedImportDialogHeading.textContent = title;\n  }\n  if (sharedImportDialogMessage) {\n    const message = texts[lang].sharedImportDialogMessage\n      || texts.en?.sharedImportDialogMessage\n      || sharedImportDialogMessage.textContent;\n    sharedImportDialogMessage.textContent = message;\n    sharedImportDialogMessage.setAttribute('data-help', message);\n  }\n  if (sharedImportConfirmBtn) {\n    const label = texts[lang].sharedImportDialogConfirm\n      || texts.en?.sharedImportDialogConfirm\n      || sharedImportConfirmBtn.textContent;\n    setButtonLabelWithIcon(sharedImportConfirmBtn, label, ICON_GLYPHS.check);\n    sharedImportConfirmBtn.setAttribute('data-help', label);\n  }\n  if (sharedImportCancelBtn) {\n    const label = texts[lang].sharedImportDialogCancel\n      || texts.en?.sharedImportDialogCancel\n      || sharedImportCancelBtn.textContent;\n    setButtonLabelWithIcon(sharedImportCancelBtn, label, ICON_GLYPHS.circleX);\n    sharedImportCancelBtn.setAttribute('data-help', label);\n  }\n  if (sharedImportLegend) {\n    const legend = texts[lang].sharedImportAutoGearLabel\n      || texts.en?.sharedImportAutoGearLabel\n      || sharedImportLegend.textContent;\n    sharedImportLegend.textContent = legend;\n    sharedImportLegendText = legend;\n    if (sharedImportOptions) {\n      sharedImportOptions.setAttribute('data-help', legend);\n    }\n  }\n  if (sharedImportModeSelect && sharedImportLegendText) {\n    sharedImportModeSelect.setAttribute('aria-label', sharedImportLegendText);\n    sharedImportModeSelect.setAttribute('data-help', sharedImportLegendText);\n  }\n  if (sharedImportModeNoneOption) {\n    const label = texts[lang].sharedImportAutoGearNone\n      || texts.en?.sharedImportAutoGearNone\n      || sharedImportModeNoneOption.textContent;\n    sharedImportModeNoneOption.textContent = label;\n    const help = texts[lang].sharedImportAutoGearNoneHelp\n      || texts.en?.sharedImportAutoGearNoneHelp\n      || label;\n    sharedImportModeNoneOption.setAttribute('data-help', help);\n    sharedImportModeNoneOption.setAttribute('title', help);\n    sharedImportModeNoneOption.setAttribute('aria-label', label);\n  }\n  if (sharedImportModeProjectOption) {\n    const label = texts[lang].sharedImportAutoGearProject\n      || texts.en?.sharedImportAutoGearProject\n      || sharedImportModeProjectOption.textContent;\n    sharedImportModeProjectOption.textContent = label;\n    const help = texts[lang].sharedImportAutoGearProjectHelp\n      || texts.en?.sharedImportAutoGearProjectHelp\n      || label;\n    sharedImportModeProjectOption.setAttribute('data-help', help);\n    sharedImportModeProjectOption.setAttribute('title', help);\n    sharedImportModeProjectOption.setAttribute('aria-label', label);\n  }\n  if (sharedImportModeGlobalOption) {\n    const label = texts[lang].sharedImportAutoGearGlobal\n      || texts.en?.sharedImportAutoGearGlobal\n      || sharedImportModeGlobalOption.textContent;\n    sharedImportModeGlobalOption.textContent = label;\n    const help = texts[lang].sharedImportAutoGearGlobalHelp\n      || texts.en?.sharedImportAutoGearGlobalHelp\n      || label;\n    sharedImportModeGlobalOption.setAttribute('data-help', help);\n    sharedImportModeGlobalOption.setAttribute('title', help);\n    sharedImportModeGlobalOption.setAttribute('aria-label', label);\n  }\n\n  applySharedLinkBtn.setAttribute(\"title\", texts[lang].loadSharedLinkBtn);\n  applySharedLinkBtn.setAttribute(\"data-help\", texts[lang].applySharedLinkHelp);\n\n  runtimeFeedbackBtn.setAttribute(\"title\", texts[lang].runtimeFeedbackBtn);\n  runtimeFeedbackBtn.setAttribute(\"data-help\", texts[lang].runtimeFeedbackBtnHelp);\n  setButtonLabelWithIcon(runtimeFeedbackBtn, texts[lang].runtimeFeedbackBtn, ICON_GLYPHS.feedback);\n  // Update the \"-- New Setup --\" option text\n  if (setupSelect.options.length > 0) {\n    setupSelect.options[0].textContent = texts[lang].newSetupOption;\n  }\n  checkSetupChanged();\n  // Device selection labels with help\n  const cameraLabelElem = document.getElementById(\"cameraLabel\");\n  cameraLabelElem.textContent = texts[lang].cameraLabel;\n  cameraLabelElem.setAttribute(\"data-help\", texts[lang].cameraSelectHelp);\n\n  const monitorLabelElem = document.getElementById(\"monitorLabel\");\n  monitorLabelElem.textContent = texts[lang].monitorLabel;\n  monitorLabelElem.setAttribute(\"data-help\", texts[lang].monitorSelectHelp);\n\n  const videoLabelElem = document.getElementById(\"videoLabel\");\n  videoLabelElem.textContent = texts[lang].videoLabel;\n  videoLabelElem.setAttribute(\"data-help\", texts[lang].videoSelectHelp);\n\n  const cageLabelElem = document.getElementById(\"cageLabel\");\n  if (cageLabelElem) {\n    cageLabelElem.textContent = texts[lang].cageLabel;\n    cageLabelElem.setAttribute(\"data-help\", texts[lang].cageSelectHelp);\n  }\n\n  const distanceLabelElem = document.getElementById(\"distanceLabel\");\n  distanceLabelElem.textContent = texts[lang].distanceLabel;\n  distanceLabelElem.setAttribute(\"data-help\", texts[lang].distanceSelectHelp);\n\n  const batteryPlateLabelElem = document.getElementById(\"batteryPlateLabel\");\n  batteryPlateLabelElem.textContent = texts[lang].batteryPlateLabel;\n  batteryPlateLabelElem.setAttribute(\"data-help\", texts[lang].batteryPlateSelectHelp);\n\n  const batteryHotswapLabelElem = document.getElementById(\"batteryHotswapLabel\");\n  if (batteryHotswapLabelElem) {\n    batteryHotswapLabelElem.textContent = texts[lang].batteryHotswapLabel;\n    batteryHotswapLabelElem.setAttribute(\"data-help\", texts[lang].batteryHotswapSelectHelp);\n  }\n\n  updateBatteryLabel();\n  // FIZ legend and labels\n  const fizLegendElem = document.getElementById(\"fizLegend\");\n  if (fizLegendElem) {\n    fizLegendElem.textContent = texts[lang].fizLegend;\n    fizLegendElem.setAttribute(\"data-help\", texts[lang].fizLegendHelp);\n  }\n  const fizMotorsLabelElem = document.getElementById(\"fizMotorsLabel\");\n  if (fizMotorsLabelElem) {\n    fizMotorsLabelElem.textContent = texts[lang].fizMotorsLabel;\n    fizMotorsLabelElem.setAttribute(\"data-help\", texts[lang].fizMotorsHelp);\n  }\n  const fizControllersLabelElem = document.getElementById(\"fizControllersLabel\");\n  if (fizControllersLabelElem) {\n    fizControllersLabelElem.textContent = texts[lang].fizControllersLabel;\n    fizControllersLabelElem.setAttribute(\n      \"data-help\",\n      texts[lang].fizControllersHelp\n    );\n  }\n  document\n    .querySelectorAll('#motorNotesLabel,#controllerNotesLabel,#distanceNotesLabel')\n    .forEach(el => {\n      el.textContent = texts[lang].notesLabel;\n    });\n  // Results labels\n  if (breakdownListElem)\n    breakdownListElem.setAttribute(\"data-help\", texts[lang].breakdownListHelp);\n\n  const totalPowerLabelElem = document.getElementById(\"totalPowerLabel\");\n  totalPowerLabelElem.textContent = texts[lang].totalPowerLabel;\n  totalPowerLabelElem.setAttribute(\"data-help\", texts[lang].totalPowerHelp);\n\n  const totalCurrent144LabelElem = document.getElementById(\n    \"totalCurrent144Label\"\n  );\n  totalCurrent144LabelElem.textContent = texts[lang].totalCurrent144Label;\n  totalCurrent144LabelElem.setAttribute(\n    \"data-help\",\n    texts[lang].totalCurrent144Help\n  );\n\n  const totalCurrent12LabelElem = document.getElementById(\"totalCurrent12Label\");\n  totalCurrent12LabelElem.textContent = texts[lang].totalCurrent12Label;\n  totalCurrent12LabelElem.setAttribute(\n    \"data-help\",\n    texts[lang].totalCurrent12Help\n  );\n\n  const batteryCountLabelElem = document.getElementById(\"batteryCountLabel\");\n  batteryCountLabelElem.textContent = texts[lang].batteryCountLabel;\n  batteryCountLabelElem.setAttribute(\n    \"data-help\",\n    texts[lang].batteryCountHelp\n  );\n\n  if (pinWarnElem)\n    pinWarnElem.setAttribute(\"data-help\", texts[lang].pinWarningHelp);\n  if (dtapWarnElem)\n    dtapWarnElem.setAttribute(\"data-help\", texts[lang].dtapWarningHelp);\n  if (hotswapWarnElem)\n    hotswapWarnElem.setAttribute(\"data-help\", texts[lang].hotswapWarningHelp);\n  const unitElem = document.getElementById(\"batteryLifeUnit\");\n  if (unitElem) unitElem.textContent = texts[lang].batteryLifeUnit;\n  const fb = renderFeedbackTable(getCurrentSetupKey());\n  if (batteryLifeLabelElem) {\n    let label = texts[lang].batteryLifeLabel;\n    if (fb) {\n      const userNote = texts[lang].runtimeUserCountNote.replace('{count}', fb.count);\n      const idx = label.indexOf(')');\n      if (idx !== -1) {\n        label = `${label.slice(0, idx)}, ${userNote}${label.slice(idx)}`;\n      }\n    }\n    batteryLifeLabelElem.textContent = label;\n    batteryLifeLabelElem.setAttribute(\n      \"data-help\",\n      texts[lang].batteryLifeHelp\n    );\n  }\n  if (runtimeAverageNoteElem) {\n    runtimeAverageNoteElem.textContent =\n      fb && fb.count > 4 ? texts[lang].runtimeAverageNote : '';\n  }\n  renderTemperatureNote(lastRuntimeHours);\n  updateFeedbackTemperatureLabel(lang, temperatureUnit);\n  updateFeedbackTemperatureOptions(lang, temperatureUnit);\n  const tempNoteElem = document.getElementById(\"temperatureNote\");\n  if (tempNoteElem)\n    tempNoteElem.setAttribute(\"data-help\", texts[lang].temperatureNoteHelp);\n  // Add device form labels and button\n  document.getElementById(\"addDeviceHeading\").textContent = texts[lang].addDeviceHeading;\n  document.getElementById(\"categoryLabel\").textContent = texts[lang].categoryLabel;\n  document.getElementById(\"subcategoryLabel\").textContent = texts[lang].subcategoryLabel;\n  document.getElementById(\"deviceNameLabel\").textContent = texts[lang].deviceNameLabel;\n  document.getElementById(\"consumptionLabel\").textContent = texts[lang].consumptionLabel;\n  document.getElementById(\"capacityLabel\").textContent = texts[lang].capacityLabel;\n  document.getElementById(\"pinLabel\").textContent = texts[lang].pinLabel;\n  document.getElementById(\"dtapLabel\").textContent = texts[lang].dtapLabel;\n  document.getElementById(\"cameraWattLabel\").textContent = texts[lang].cameraWattLabel;\n  document.getElementById(\"cameraVoltageLabel\").textContent = texts[lang].cameraVoltageLabel;\n  document.getElementById(\"cameraPortTypeLabel\").textContent = texts[lang].cameraPortTypeLabel;\n  document.getElementById(\"cameraPlatesLabel\").textContent = texts[lang].cameraPlatesLabel;\n  document.getElementById(\"cameraMediaLabel\").textContent = texts[lang].cameraMediaLabel;\n  document.getElementById(\"cameraLensMountLabel\").textContent = texts[lang].cameraLensMountLabel;\n  document.getElementById(\"cameraPowerDistLabel\").textContent = texts[lang].powerDistributionLabel;\n  document.getElementById(\"cameraVideoOutputsLabel\").textContent = texts[lang].videoOutputsLabel;\n  document.getElementById(\"cameraFIZConnectorLabel\").textContent = texts[lang].fizConnectorLabel;\n  document.getElementById(\"cameraViewfinderLabel\").textContent = texts[lang].viewfinderLabel;\n  document.getElementById(\"cameraTimecodeLabel\").textContent = texts[lang].timecodeLabel;\n  document.getElementById(\"powerInputsHeading\").textContent = texts[lang].powerInputsHeading;\n  document.getElementById(\"powerDistributionHeading\").textContent = texts[lang].powerDistributionHeading;\n  document.getElementById(\"videoOutputsHeading\").textContent = texts[lang].videoOutputsHeading;\n  document.getElementById(\"fizConnectorHeading\").textContent = texts[lang].fizConnectorHeading;\n  document.getElementById(\"mediaHeading\").textContent = texts[lang].mediaHeading;\n  document.getElementById(\"viewfinderHeading\").textContent = texts[lang].viewfinderHeading;\n  document.getElementById(\"lensMountHeading\").textContent = texts[lang].lensMountHeading;\n  document.getElementById(\"timecodeHeading\").textContent = texts[lang].timecodeHeading;\n  document.getElementById(\"monitorScreenSizeLabel\").textContent = texts[lang].monitorScreenSizeLabel;\n  document.getElementById(\"monitorBrightnessLabel\").textContent = texts[lang].monitorBrightnessLabel;\n  document.getElementById(\"monitorWattLabel\").textContent = texts[lang].monitorWattLabel;\n  document.getElementById(\"monitorVoltageLabel\").textContent = texts[lang].monitorVoltageLabel;\n  document.getElementById(\"monitorPortTypeLabel\").textContent = texts[lang].monitorPortTypeLabel;\n  document.getElementById(\"monitorVideoInputsHeading\").textContent = texts[lang].monitorVideoInputsHeading;\n  document.getElementById(\"monitorVideoOutputsHeading\").textContent = texts[lang].monitorVideoOutputsHeading;\n  document.getElementById(\"monitorVideoInputsLabel\").textContent = texts[lang].monitorVideoInputsLabel;\n  document.getElementById(\"monitorVideoOutputsLabel\").textContent = texts[lang].monitorVideoOutputsLabel;\n  document.getElementById(\"monitorWirelessTxLabel\").textContent = texts[lang].monitorWirelessTxLabel;\n  document.getElementById(\"monitorLatencyLabel\").textContent = texts[lang].monitorLatencyLabel;\n  document.getElementById(\"monitorAudioOutputLabel\").textContent = texts[lang].monitorAudioOutputLabel;\n  document.getElementById(\"viewfinderDetailsHeading\").textContent = texts[lang].viewfinderDetailsHeading;\n  document.getElementById(\"viewfinderScreenSizeLabel\").textContent = texts[lang].viewfinderScreenSizeLabel;\n  document.getElementById(\"viewfinderBrightnessLabel\").textContent = texts[lang].viewfinderBrightnessLabel;\n  document.getElementById(\"viewfinderWattLabel\").textContent = texts[lang].viewfinderWattLabel;\n  document.getElementById(\"viewfinderVoltageLabel\").textContent = texts[lang].viewfinderVoltageLabel;\n  document.getElementById(\"viewfinderPortTypeLabel\").textContent = texts[lang].viewfinderPortTypeLabel;\n  document.getElementById(\"viewfinderVideoInputsHeading\").textContent = texts[lang].viewfinderVideoInputsHeading;\n  document.getElementById(\"viewfinderVideoOutputsHeading\").textContent = texts[lang].viewfinderVideoOutputsHeading;\n  document.getElementById(\"viewfinderVideoInputsLabel\").textContent = texts[lang].viewfinderVideoInputsLabel;\n  document.getElementById(\"viewfinderVideoOutputsLabel\").textContent = texts[lang].viewfinderVideoOutputsLabel;\n  document.getElementById(\"viewfinderWirelessTxLabel\").textContent = texts[lang].viewfinderWirelessTxLabel;\n  document.getElementById(\"viewfinderLatencyLabel\").textContent = texts[lang].viewfinderLatencyLabel;\n  document.getElementById(\"videoVideoInputsHeading\").textContent = texts[lang].videoVideoInputsHeading;\n  document.getElementById(\"videoVideoInputsLabel\").textContent = texts[lang].videoVideoInputsLabel;\n  document.getElementById(\"videoVideoOutputsHeading\").textContent = texts[lang].videoVideoOutputsHeading;\n  document.getElementById(\"videoVideoOutputsLabel\").textContent = texts[lang].videoVideoOutputsLabel;\n  document.getElementById(\"monitorDetailsHeading\").textContent = texts[lang].monitorDetailsHeading;\n  document.getElementById(\"monitorPowerHeading\").textContent = texts[lang].monitorPowerHeading;\n  // Determine text for Add/Update button\n  const addDeviceLabel = texts[lang].addDeviceBtn;\n  const updateDeviceLabel = texts[lang].updateDeviceBtn;\n  if (addDeviceBtn.dataset.mode === \"edit\") {\n    setButtonLabelWithIcon(addDeviceBtn, updateDeviceLabel, ICON_GLYPHS.save);\n    addDeviceBtn.setAttribute('data-help', texts[lang].updateDeviceBtnHelp);\n  } else {\n    setButtonLabelWithIcon(addDeviceBtn, addDeviceLabel, ICON_GLYPHS.add);\n    addDeviceBtn.setAttribute('data-help', texts[lang].addDeviceBtnHelp);\n  }\n  setButtonLabelWithIcon(cancelEditBtn, texts[lang].cancelEditBtn, ICON_GLYPHS.circleX);\n  cancelEditBtn.setAttribute('data-help', texts[lang].cancelEditBtnHelp);\n  setButtonLabelWithIcon(exportBtn, texts[lang].exportDataBtn, ICON_GLYPHS.fileExport);\n  exportBtn.setAttribute('data-help', texts[lang].exportDataBtnHelp);\n  setButtonLabelWithIcon(importDataBtn, texts[lang].importDataBtn, ICON_GLYPHS.fileImport);\n  importDataBtn.setAttribute('data-help', texts[lang].importDataBtnHelp);\n  // Placeholders for inputs\n  setupNameInput.placeholder = texts[lang].setupNameLabel.replace(\":\", \"\");\n  newNameInput.placeholder = texts[lang].placeholder_deviceName;\n  newWattInput.placeholder = texts[lang].placeholder_watt;\n  newCapacityInput.placeholder = texts[lang].placeholder_capacity;\n  newPinAInput.placeholder = texts[lang].placeholder_pin;\n  newDtapAInput.placeholder = texts[lang].placeholder_dtap;\n  cameraVoltageInput.placeholder = texts[lang].placeholder_voltage;\n  monitorVoltageInput.placeholder = texts[lang].placeholder_voltage;\n  updateDeviceManagerLocalization(lang);\n  // Toggle device manager button text (depends on current visibility)\n  if (deviceManagerSection.classList.contains('hidden')) {\n    setButtonLabelWithIcon(toggleDeviceBtn, texts[lang].toggleDeviceManager, ICON_GLYPHS.gears);\n    toggleDeviceBtn.setAttribute(\"title\", texts[lang].toggleDeviceManager);\n    toggleDeviceBtn.setAttribute(\"data-help\", texts[lang].toggleDeviceManagerHelp);\n    toggleDeviceBtn.setAttribute(\"aria-expanded\", \"false\");\n  } else {\n    setButtonLabelWithIcon(toggleDeviceBtn, texts[lang].hideDeviceManager, ICON_GLYPHS.minus);\n    toggleDeviceBtn.setAttribute(\"title\", texts[lang].hideDeviceManager);\n    toggleDeviceBtn.setAttribute(\"data-help\", texts[lang].hideDeviceManagerHelp);\n    toggleDeviceBtn.setAttribute(\"aria-expanded\", \"true\");\n  }\n  // Update newCategory select option texts\n  Array.from(newCategorySelect.options).forEach(opt => {\n    opt.textContent = getCategoryLabel(opt.value, lang);\n  });\n  // Update \"None\" option text in all dropdowns\n  const noneMap = { de: \"Keine Auswahl\", es: \"Ninguno\", fr: \"Aucun\" };\n  document.querySelectorAll('select option[value=\"None\"]').forEach(opt => {\n    opt.textContent = noneMap[lang] || \"None\";\n  });\n  // Save language preference\n  try {\n    localStorage.setItem(\"language\", lang);\n  } catch (e) {\n    console.warn(\"Could not save language to localStorage\", e);\n  }\n  // Recalculate and update dynamic content (results, breakdown, battery comparison)\n  refreshDeviceLists(); // Call refreshDeviceLists to update Edit/Delete buttons in the list\n  applyFilters();\n  updateCalculations();\n\n  if (existingDevicesHeading) {\n    existingDevicesHeading.textContent = texts[lang].existingDevicesHeading;\n  }\n  if (darkModeToggle) {\n    darkModeToggle.setAttribute(\"title\", texts[lang].darkModeLabel);\n    darkModeToggle.setAttribute(\"aria-label\", texts[lang].darkModeLabel);\n    darkModeToggle.setAttribute(\n      \"data-help\",\n      texts[lang].darkModeHelp || texts[lang].darkModeLabel\n    );\n  }\n  if (pinkModeToggle) {\n    pinkModeToggle.setAttribute(\"title\", texts[lang].pinkModeLabel);\n    pinkModeToggle.setAttribute(\"aria-label\", texts[lang].pinkModeLabel);\n    pinkModeToggle.setAttribute(\n      \"data-help\",\n      texts[lang].pinkModeHelp || texts[lang].pinkModeLabel\n    );\n  }\n  if (settingsButton) {\n    settingsButton.setAttribute(\"title\", texts[lang].settingsButton);\n    settingsButton.setAttribute(\"aria-label\", texts[lang].settingsButton);\n    settingsButton.setAttribute(\n      \"data-help\",\n      texts[lang].settingsButtonHelp || texts[lang].settingsButton\n    );\n  }\n  const settingsTitleElem = document.getElementById(\"settingsTitle\");\n  if (settingsTitleElem) {\n    settingsTitleElem.textContent = texts[lang].settingsHeading;\n    settingsTitleElem.setAttribute(\n      \"data-help\",\n      texts[lang].settingsHeadingHelp || texts[lang].settingsHeading\n    );\n  }\n  if (settingsTablist) {\n    const sectionsLabel =\n      texts[lang].settingsSectionsLabel ||\n      texts.en?.settingsSectionsLabel ||\n      settingsTablist.getAttribute('aria-label') ||\n      texts[lang].settingsHeading ||\n      'Settings sections';\n    settingsTablist.setAttribute('aria-label', sectionsLabel);\n  }\n  const getSettingsTabLabelText = button => {\n    if (!button || typeof button !== 'object') return '';\n    const labelNode = button.querySelector?.('.settings-tab-label');\n    if (labelNode && typeof labelNode.textContent === 'string') {\n      const trimmed = labelNode.textContent.trim();\n      if (trimmed) return trimmed;\n    }\n    return typeof button.textContent === 'string' ? button.textContent.trim() : '';\n  };\n  const summarizeSettingsTabHelp = helpText => {\n    if (typeof helpText !== 'string') return '';\n    const trimmed = helpText.trim();\n    if (!trimmed) return '';\n    const sentenceMatch = trimmed.match(/^[^.!?\u3002\uFF01\uFF1F]*[.!?\u3002\uFF01\uFF1F]/u);\n    if (sentenceMatch && sentenceMatch[0]) {\n      const sentence = sentenceMatch[0].trim();\n      if (sentence.length >= 24 || trimmed.length <= 90) {\n        return sentence;\n      }\n    }\n    if (trimmed.length <= 90) return trimmed;\n    const truncated = trimmed.slice(0, 90);\n    let cutIndex = truncated.length;\n    while (cutIndex > 0 && truncated[cutIndex - 1] && truncated[cutIndex - 1].trim() !== '') {\n      cutIndex -= 1;\n    }\n    const safeCut = cutIndex > 0 ? truncated.slice(0, cutIndex).trimEnd() : '';\n    return `${safeCut || truncated.trim()}\u2026`;\n  };\n  const applySettingsTabLabel = (button, labelValue, helpValue) => {\n    if (!button) return;\n    const label = (labelValue || getSettingsTabLabelText(button) || '').trim();\n    const labelElement = button.querySelector?.('.settings-tab-label');\n    if (labelElement) {\n      labelElement.textContent = label;\n    } else {\n      button.textContent = label;\n    }\n    if (label) {\n      button.setAttribute('aria-label', label);\n    } else {\n      button.removeAttribute('aria-label');\n    }\n    const help = (helpValue || label || '').trim();\n    if (help) {\n      button.setAttribute('data-help', help);\n      button.setAttribute('title', help);\n    } else {\n      button.removeAttribute('data-help');\n      button.removeAttribute('title');\n    }\n    const summary = summarizeSettingsTabHelp(help);\n    if (summary) {\n      button.setAttribute('data-summary', summary);\n    } else {\n      button.removeAttribute('data-summary');\n    }\n    const captionElement = button.querySelector?.('.settings-tab-caption');\n    if (captionElement) {\n      const captionText = summary || label;\n      captionElement.textContent = captionText;\n      if (captionText) {\n        captionElement.removeAttribute('hidden');\n      } else {\n        captionElement.setAttribute('hidden', '');\n      }\n    }\n  };\n  if (settingsTabGeneral) {\n    const generalLabel =\n      texts[lang].settingsTabGeneral ||\n      texts.en?.settingsTabGeneral ||\n      getSettingsTabLabelText(settingsTabGeneral) ||\n      'General';\n    const generalHelp =\n      texts[lang].settingsTabGeneralHelp ||\n      texts.en?.settingsTabGeneralHelp ||\n      texts[lang].settingsHeadingHelp ||\n      generalLabel;\n    applySettingsTabLabel(settingsTabGeneral, generalLabel, generalHelp);\n    if (generalSettingsHeading) {\n      generalSettingsHeading.textContent = generalLabel;\n      generalSettingsHeading.setAttribute('data-help', generalHelp);\n    }\n  }\n  applySettingsTabLabel(\n    settingsTabAutoGear,\n    texts[lang].settingsTabAutoGear ||\n      texts.en?.settingsTabAutoGear ||\n      texts[lang].autoGearHeading ||\n      texts.en?.autoGearHeading,\n    texts[lang].settingsTabAutoGearHelp ||\n      texts.en?.settingsTabAutoGearHelp ||\n      texts[lang].autoGearHeadingHelp ||\n      texts.en?.autoGearHeadingHelp\n  );\n  applySettingsTabLabel(\n    settingsTabAccessibility,\n    texts[lang].settingsTabAccessibility ||\n      texts.en?.settingsTabAccessibility ||\n      texts[lang].accessibilityHeading ||\n      texts.en?.accessibilityHeading,\n    texts[lang].settingsTabAccessibilityHelp ||\n      texts.en?.settingsTabAccessibilityHelp ||\n      texts[lang].accessibilityHeadingHelp ||\n      texts.en?.accessibilityHeadingHelp\n  );\n  applySettingsTabLabel(\n    settingsTabBackup,\n    texts[lang].settingsTabBackup ||\n      texts.en?.settingsTabBackup ||\n      texts[lang].backupHeading ||\n      texts.en?.backupHeading,\n    texts[lang].settingsTabBackupHelp ||\n      texts.en?.settingsTabBackupHelp ||\n      texts[lang].backupHeadingHelp ||\n      texts.en?.backupHeadingHelp\n  );\n  applySettingsTabLabel(\n    settingsTabData,\n    texts[lang].settingsTabData ||\n      texts.en?.settingsTabData ||\n      texts[lang].dataHeading ||\n      texts.en?.dataHeading,\n    texts[lang].settingsTabDataHelp ||\n      texts.en?.settingsTabDataHelp ||\n      texts[lang].dataHeadingHelp ||\n      texts.en?.dataHeadingHelp\n  );\n  applySettingsTabLabel(\n    settingsTabAbout,\n    texts[lang].settingsTabAbout ||\n      texts.en?.settingsTabAbout ||\n      texts[lang].aboutHeading ||\n      texts.en?.aboutHeading,\n    texts[lang].settingsTabAboutHelp ||\n      texts.en?.settingsTabAboutHelp ||\n      texts[lang].aboutHeadingHelp ||\n      texts.en?.aboutHeadingHelp\n  );\n  const settingsLanguageLabel = document.getElementById(\"settingsLanguageLabel\");\n  if (settingsLanguageLabel) {\n    settingsLanguageLabel.textContent = texts[lang].languageSetting;\n    const languageHelp =\n      texts[lang].settingsLanguageHelp || texts[lang].languageSetting;\n    settingsLanguageLabel.setAttribute(\"data-help\", languageHelp);\n    if (settingsLanguage) {\n      settingsLanguage.setAttribute(\"data-help\", languageHelp);\n      settingsLanguage.setAttribute(\"aria-label\", texts[lang].languageSetting);\n    }\n  }\n  const settingsDarkLabel = document.getElementById(\"settingsDarkModeLabel\");\n  if (settingsDarkLabel) {\n    settingsDarkLabel.textContent = texts[lang].darkModeSetting;\n    const darkModeHelp =\n      texts[lang].settingsDarkModeHelp || texts[lang].darkModeSetting;\n    settingsDarkLabel.setAttribute(\"data-help\", darkModeHelp);\n    if (settingsDarkMode) {\n      settingsDarkMode.setAttribute(\"data-help\", darkModeHelp);\n      settingsDarkMode.setAttribute(\"aria-label\", texts[lang].darkModeSetting);\n    }\n  }\n  const settingsPinkLabel = document.getElementById(\"settingsPinkModeLabel\");\n  if (settingsPinkLabel) {\n    settingsPinkLabel.textContent = texts[lang].pinkModeSetting;\n    const pinkModeHelp =\n      texts[lang].settingsPinkModeHelp || texts[lang].pinkModeSetting;\n    settingsPinkLabel.setAttribute(\"data-help\", pinkModeHelp);\n    if (settingsPinkMode) {\n      settingsPinkMode.setAttribute(\"data-help\", pinkModeHelp);\n      settingsPinkMode.setAttribute(\"aria-label\", texts[lang].pinkModeSetting);\n    }\n  }\n  const accentLabel = document.getElementById(\"accentColorLabel\");\n  if (accentLabel) {\n    accentLabel.textContent = texts[lang].accentColorSetting;\n    const accentHelp =\n      texts[lang].accentColorHelp || texts[lang].accentColorSetting;\n    accentLabel.setAttribute(\"data-help\", accentHelp);\n    if (accentColorInput) {\n      accentColorInput.setAttribute(\"data-help\", accentHelp);\n      accentColorInput.setAttribute(\"aria-label\", texts[lang].accentColorSetting);\n    }\n  }\n  const settingsTemperatureUnitLabel = document.getElementById('settingsTemperatureUnitLabel');\n  if (settingsTemperatureUnitLabel) {\n    settingsTemperatureUnitLabel.textContent = texts[lang].temperatureUnitSetting;\n    const tempUnitHelp =\n      texts[lang].temperatureUnitSettingHelp || texts[lang].temperatureUnitSetting;\n    settingsTemperatureUnitLabel.setAttribute('data-help', tempUnitHelp);\n    if (typeof settingsTemperatureUnit !== 'undefined' && settingsTemperatureUnit) {\n      settingsTemperatureUnit.setAttribute('data-help', tempUnitHelp);\n      settingsTemperatureUnit.setAttribute('aria-label', texts[lang].temperatureUnitSetting);\n      Array.from(settingsTemperatureUnit.options || []).forEach(option => {\n        if (!option) return;\n        const normalized = normalizeTemperatureUnit(option.value);\n        option.textContent = getTemperatureUnitLabelForLang(lang, normalized);\n      });\n      settingsTemperatureUnit.value = temperatureUnit;\n    }\n  }\n  const fontSizeLabel = document.getElementById(\"settingsFontSizeLabel\");\n  if (fontSizeLabel) {\n    fontSizeLabel.textContent = texts[lang].fontSizeSetting;\n    const sizeHelp =\n      texts[lang].fontSizeSettingHelp || texts[lang].fontSizeSetting;\n    fontSizeLabel.setAttribute(\"data-help\", sizeHelp);\n    if (settingsFontSize) {\n      settingsFontSize.setAttribute(\"data-help\", sizeHelp);\n      settingsFontSize.setAttribute(\"aria-label\", texts[lang].fontSizeSetting);\n    }\n  }\n  const fontFamilyLabel = document.getElementById(\"settingsFontFamilyLabel\");\n  if (fontFamilyLabel) {\n    fontFamilyLabel.textContent = texts[lang].fontFamilySetting;\n    const familyHelp =\n      texts[lang].fontFamilySettingHelp || texts[lang].fontFamilySetting;\n    fontFamilyLabel.setAttribute(\"data-help\", familyHelp);\n    if (settingsFontFamily) {\n      settingsFontFamily.setAttribute(\"data-help\", familyHelp);\n      settingsFontFamily.setAttribute(\"aria-label\", texts[lang].fontFamilySetting);\n    }\n  }\n  if (localFontsButton) {\n    const localFontsHelp =\n      texts[lang].localFontsButtonHelp || localFontsButton.textContent;\n    localFontsButton.setAttribute(\"data-help\", localFontsHelp);\n    localFontsButton.setAttribute(\"title\", localFontsHelp);\n    localFontsButton.setAttribute(\"aria-label\", localFontsHelp);\n  }\n  if (bundledFontGroup) {\n    const builtInLabel =\n      (texts[lang] && texts[lang].bundledFontsGroup) ||\n      (texts.en && texts.en.bundledFontsGroup) ||\n      bundledFontGroup.label;\n    if (builtInLabel) bundledFontGroup.label = builtInLabel;\n  }\n  if (localFontsGroup) {\n    const localLabel =\n      (texts[lang] && texts[lang].localFontsGroup) ||\n      (texts.en && texts.en.localFontsGroup) ||\n      localFontsGroup.label;\n    if (localLabel) localFontsGroup.label = localLabel;\n  }\n  if (localFontsButton) {\n    const localFontsLabel =\n      (texts[lang] && texts[lang].localFontsButton) ||\n      (texts.en && texts.en.localFontsButton) ||\n      localFontsButton.textContent;\n    if (localFontsLabel) {\n      setButtonLabelWithIcon(localFontsButton, localFontsLabel, ICON_GLYPHS.add);\n      localFontsButton.setAttribute('aria-label', localFontsLabel);\n      localFontsButton.setAttribute('title', localFontsLabel);\n    }\n  }\n  if (localFontsStatus && localFontsStatus.dataset.statusKey) {\n    const statusKey = localFontsStatus.dataset.statusKey;\n    const arg = localFontsStatus.dataset.statusArg;\n    let template =\n      (texts[lang] && texts[lang][statusKey]) ||\n      (texts.en && texts.en[statusKey]) ||\n      '';\n    if (template && arg !== undefined && arg !== null) {\n      template = template.replace('%s', arg);\n    } else if (!template && arg !== undefined && arg !== null) {\n      template = arg;\n    }\n    localFontsStatus.textContent = template;\n  }\n  const settingsLogoLabel = document.getElementById(\"settingsLogoLabel\");\n  if (settingsLogoLabel) {\n    settingsLogoLabel.textContent = texts[lang].logoSetting;\n    const logoHelp = texts[lang].logoSettingHelp || texts[lang].logoSetting;\n    settingsLogoLabel.setAttribute(\"data-help\", logoHelp);\n    if (settingsLogo) {\n      settingsLogo.setAttribute(\"data-help\", logoHelp);\n      settingsLogo.setAttribute(\"aria-label\", texts[lang].logoSetting);\n    }\n  }\n  if (autoGearHeadingElem) {\n    autoGearHeadingElem.textContent = texts[lang].autoGearHeading || texts.en?.autoGearHeading || 'Automatic Gear Rules';\n    const headingHelp = texts[lang].autoGearHeadingHelp || texts.en?.autoGearHeadingHelp;\n    if (headingHelp) autoGearHeadingElem.setAttribute('data-help', headingHelp);\n  }\n  if (autoGearDescriptionElem) {\n    autoGearDescriptionElem.textContent = texts[lang].autoGearDescription || texts.en?.autoGearDescription || '';\n  }\n  if (autoGearPresetDescription) {\n    autoGearPresetDescription.textContent = texts[lang].autoGearPresetDescription\n      || texts.en?.autoGearPresetDescription\n      || '';\n  }\n  if (autoGearPresetLabel) {\n    const label = texts[lang].autoGearPresetLabel\n      || texts.en?.autoGearPresetLabel\n      || autoGearPresetLabel.textContent;\n    const help = texts[lang].autoGearPresetDescription\n      || texts.en?.autoGearPresetDescription\n      || label;\n    autoGearPresetLabel.textContent = label;\n    autoGearPresetLabel.setAttribute('data-help', help);\n    if (autoGearPresetSelect) {\n      autoGearPresetSelect.setAttribute('aria-label', label);\n      autoGearPresetSelect.setAttribute('data-help', help);\n    }\n  }\n  if (autoGearSavePresetButton) {\n    const label = texts[lang].autoGearSavePresetButton\n      || texts.en?.autoGearSavePresetButton\n      || autoGearSavePresetButton.textContent;\n    setButtonLabelWithIcon(autoGearSavePresetButton, label, ICON_GLYPHS.save);\n    autoGearSavePresetButton.setAttribute('data-help', label);\n    autoGearSavePresetButton.setAttribute('aria-label', label);\n  }\n  if (autoGearDeletePresetButton) {\n    const label = texts[lang].autoGearDeletePresetButton\n      || texts.en?.autoGearDeletePresetButton\n      || autoGearDeletePresetButton.textContent;\n    setButtonLabelWithIcon(autoGearDeletePresetButton, label, ICON_GLYPHS.trash);\n    autoGearDeletePresetButton.setAttribute('data-help', label);\n    autoGearDeletePresetButton.setAttribute('aria-label', label);\n  }\n  if (autoGearAddRuleBtn) {\n    const label = texts[lang].autoGearAddRule || texts.en?.autoGearAddRule || autoGearAddRuleBtn.textContent;\n    setButtonLabelWithIcon(autoGearAddRuleBtn, label, ICON_GLYPHS.add);\n    const help = texts[lang].autoGearHeadingHelp || texts.en?.autoGearHeadingHelp || label;\n    autoGearAddRuleBtn.setAttribute('data-help', help);\n  }\n  if (autoGearResetFactoryButton) {\n    const label = texts[lang].autoGearResetFactoryButton\n      || texts.en?.autoGearResetFactoryButton\n      || autoGearResetFactoryButton.textContent;\n    const help = texts[lang].autoGearResetFactoryHelp\n      || texts.en?.autoGearResetFactoryHelp\n      || label;\n    setButtonLabelWithIcon(autoGearResetFactoryButton, label, ICON_GLYPHS.reload);\n    autoGearResetFactoryButton.setAttribute('data-help', help);\n    autoGearResetFactoryButton.setAttribute('title', help);\n    autoGearResetFactoryButton.setAttribute('aria-label', label);\n  }\n  if (autoGearExportButton) {\n    const label = texts[lang].autoGearExportButton\n      || texts.en?.autoGearExportButton\n      || autoGearExportButton.textContent;\n    const help = texts[lang].autoGearExportHelp\n      || texts.en?.autoGearExportHelp\n      || label;\n    setButtonLabelWithIcon(autoGearExportButton, label, ICON_GLYPHS.fileExport);\n    autoGearExportButton.setAttribute('data-help', help);\n    autoGearExportButton.setAttribute('title', help);\n    autoGearExportButton.setAttribute('aria-label', label);\n  }\n  if (autoGearImportButton) {\n    const label = texts[lang].autoGearImportButton\n      || texts.en?.autoGearImportButton\n      || autoGearImportButton.textContent;\n    const help = texts[lang].autoGearImportHelp\n      || texts.en?.autoGearImportHelp\n      || label;\n    setButtonLabelWithIcon(autoGearImportButton, label, ICON_GLYPHS.fileImport);\n    autoGearImportButton.setAttribute('data-help', help);\n    autoGearImportButton.setAttribute('title', help);\n    autoGearImportButton.setAttribute('aria-label', label);\n  }\n  if (autoGearBackupsHeading) {\n    autoGearBackupsHeading.textContent = texts[lang].autoGearBackupsHeading\n      || texts.en?.autoGearBackupsHeading\n      || autoGearBackupsHeading.textContent;\n  }\n  if (autoGearBackupsDescription) {\n    const description = texts[lang].autoGearBackupsDescription\n      || texts.en?.autoGearBackupsDescription\n      || '';\n    autoGearBackupsDescription.textContent = description;\n    if (description) {\n      autoGearBackupsDescription.setAttribute('data-help', description);\n    }\n  }\n  if (autoGearShowBackupsLabel) {\n    const label = texts[lang].autoGearShowBackupsLabel\n      || texts.en?.autoGearShowBackupsLabel\n      || autoGearShowBackupsLabel.textContent;\n    const help = texts[lang].autoGearShowBackupsHelp\n      || texts.en?.autoGearShowBackupsHelp\n      || label;\n    autoGearShowBackupsLabel.textContent = label;\n    autoGearShowBackupsLabel.setAttribute('data-help', help);\n    if (autoGearShowBackupsCheckbox) {\n      autoGearShowBackupsCheckbox.setAttribute('aria-label', label);\n      autoGearShowBackupsCheckbox.setAttribute('data-help', help);\n    }\n  }\n  if (autoGearBackupsHiddenNotice) {\n    const hiddenText = texts[lang].autoGearBackupsHidden\n      || texts.en?.autoGearBackupsHidden\n      || autoGearBackupsHiddenNotice.textContent;\n    autoGearBackupsHiddenNotice.textContent = hiddenText;\n  }\n  if (autoGearBackupSelectLabel) {\n    const label = texts[lang].autoGearBackupSelectLabel\n      || texts.en?.autoGearBackupSelectLabel\n      || autoGearBackupSelectLabel.textContent;\n    autoGearBackupSelectLabel.textContent = label;\n    if (autoGearBackupSelect) {\n      autoGearBackupSelect.setAttribute('aria-label', label);\n      autoGearBackupSelect.setAttribute('title', label);\n    }\n  }\n  if (autoGearBackupRestoreButton) {\n    const label = texts[lang].autoGearBackupRestore\n      || texts.en?.autoGearBackupRestore\n      || autoGearBackupRestoreButton.textContent;\n    setButtonLabelWithIcon(autoGearBackupRestoreButton, label, ICON_GLYPHS.fileImport);\n    autoGearBackupRestoreButton.setAttribute('aria-label', label);\n    autoGearBackupRestoreButton.setAttribute('title', label);\n  }\n  if (autoGearBackupEmptyMessage) {\n    const emptyText = texts[lang].autoGearBackupEmpty\n      || texts.en?.autoGearBackupEmpty\n      || autoGearBackupEmptyMessage.textContent;\n    autoGearBackupEmptyMessage.textContent = emptyText;\n  }\n  if (autoGearBackupSelect) {\n    renderAutoGearBackupControls();\n  }\n  if (autoGearRuleNameLabel) {\n    const label = texts[lang].autoGearRuleNameLabel || texts.en?.autoGearRuleNameLabel || autoGearRuleNameLabel.textContent;\n    autoGearRuleNameLabel.textContent = label;\n    const help = texts[lang].autoGearRuleNameHelp || texts.en?.autoGearRuleNameHelp || label;\n    autoGearRuleNameLabel.setAttribute('data-help', help);\n    if (autoGearRuleNameInput) {\n      autoGearRuleNameInput.setAttribute('data-help', help);\n      autoGearRuleNameInput.setAttribute('aria-label', label);\n    }\n  }\n  if (autoGearScenariosLabel) {\n    const label = texts[lang].autoGearScenariosLabel || texts.en?.autoGearScenariosLabel || autoGearScenariosLabel.textContent;\n    autoGearScenariosLabel.textContent = label;\n    const help = texts[lang].autoGearScenariosHelp || texts.en?.autoGearScenariosHelp || label;\n    autoGearScenariosLabel.setAttribute('data-help', help);\n    if (autoGearScenariosSelect) {\n      autoGearScenariosSelect.setAttribute('data-help', help);\n      autoGearScenariosSelect.setAttribute('aria-label', label);\n    }\n  }\n  if (autoGearMatteboxLabel) {\n    const label = texts[lang].autoGearMatteboxLabel || texts.en?.autoGearMatteboxLabel || autoGearMatteboxLabel.textContent;\n    autoGearMatteboxLabel.textContent = label;\n    const help = texts[lang].autoGearMatteboxHelp || texts.en?.autoGearMatteboxHelp || label;\n    autoGearMatteboxLabel.setAttribute('data-help', help);\n    if (autoGearMatteboxSelect) {\n      autoGearMatteboxSelect.setAttribute('data-help', help);\n      autoGearMatteboxSelect.setAttribute('aria-label', label);\n    }\n  }\n  if (autoGearCameraHandleLabel) {\n    const label = texts[lang].autoGearCameraHandleLabel || texts.en?.autoGearCameraHandleLabel || autoGearCameraHandleLabel.textContent;\n    autoGearCameraHandleLabel.textContent = label;\n    const help = texts[lang].autoGearCameraHandleHelp || texts.en?.autoGearCameraHandleHelp || label;\n    autoGearCameraHandleLabel.setAttribute('data-help', help);\n    if (autoGearCameraHandleSelect) {\n      autoGearCameraHandleSelect.setAttribute('data-help', help);\n      autoGearCameraHandleSelect.setAttribute('aria-label', label);\n    }\n  }\n  if (autoGearViewfinderExtensionLabel) {\n    const label = texts[lang].autoGearViewfinderExtensionLabel || texts.en?.autoGearViewfinderExtensionLabel || autoGearViewfinderExtensionLabel.textContent;\n    autoGearViewfinderExtensionLabel.textContent = label;\n    const help = texts[lang].autoGearViewfinderExtensionHelp || texts.en?.autoGearViewfinderExtensionHelp || label;\n    autoGearViewfinderExtensionLabel.setAttribute('data-help', help);\n    if (autoGearViewfinderExtensionSelect) {\n      autoGearViewfinderExtensionSelect.setAttribute('data-help', help);\n      autoGearViewfinderExtensionSelect.setAttribute('aria-label', label);\n    }\n  }\n  if (autoGearVideoDistributionLabel) {\n    const label = texts[lang].autoGearVideoDistributionLabel || texts.en?.autoGearVideoDistributionLabel || autoGearVideoDistributionLabel.textContent;\n    autoGearVideoDistributionLabel.textContent = label;\n    const help = texts[lang].autoGearVideoDistributionHelp || texts.en?.autoGearVideoDistributionHelp || label;\n    autoGearVideoDistributionLabel.setAttribute('data-help', help);\n    if (autoGearVideoDistributionSelect) {\n      autoGearVideoDistributionSelect.setAttribute('data-help', help);\n      autoGearVideoDistributionSelect.setAttribute('aria-label', label);\n    }\n  }\n  if (autoGearCameraLabel) {\n    const label = texts[lang].autoGearCameraLabel || texts.en?.autoGearCameraLabel || autoGearCameraLabel.textContent;\n    autoGearCameraLabel.textContent = label;\n    const help = texts[lang].autoGearCameraHelp || texts.en?.autoGearCameraHelp || label;\n    autoGearCameraLabel.setAttribute('data-help', help);\n    if (autoGearCameraSelect) {\n      autoGearCameraSelect.setAttribute('data-help', help);\n      autoGearCameraSelect.setAttribute('aria-label', label);\n    }\n  }\n  if (autoGearMonitorLabel) {\n    const label = texts[lang].autoGearMonitorLabel || texts.en?.autoGearMonitorLabel || autoGearMonitorLabel.textContent;\n    autoGearMonitorLabel.textContent = label;\n    const help = texts[lang].autoGearMonitorHelp || texts.en?.autoGearMonitorHelp || label;\n    autoGearMonitorLabel.setAttribute('data-help', help);\n    if (autoGearMonitorSelect) {\n      autoGearMonitorSelect.setAttribute('data-help', help);\n      autoGearMonitorSelect.setAttribute('aria-label', label);\n    }\n  }\n  if (autoGearWirelessLabel) {\n    const label = texts[lang].autoGearWirelessLabel || texts.en?.autoGearWirelessLabel || autoGearWirelessLabel.textContent;\n    autoGearWirelessLabel.textContent = label;\n    const help = texts[lang].autoGearWirelessHelp || texts.en?.autoGearWirelessHelp || label;\n    autoGearWirelessLabel.setAttribute('data-help', help);\n    if (autoGearWirelessSelect) {\n      autoGearWirelessSelect.setAttribute('data-help', help);\n      autoGearWirelessSelect.setAttribute('aria-label', label);\n    }\n  }\n  if (autoGearMotorsLabel) {\n    const label = texts[lang].autoGearMotorsLabel || texts.en?.autoGearMotorsLabel || autoGearMotorsLabel.textContent;\n    autoGearMotorsLabel.textContent = label;\n    const help = texts[lang].autoGearMotorsHelp || texts.en?.autoGearMotorsHelp || label;\n    autoGearMotorsLabel.setAttribute('data-help', help);\n    if (autoGearMotorsSelect) {\n      autoGearMotorsSelect.setAttribute('data-help', help);\n      autoGearMotorsSelect.setAttribute('aria-label', label);\n    }\n  }\n  if (autoGearControllersLabel) {\n    const label = texts[lang].autoGearControllersLabel || texts.en?.autoGearControllersLabel || autoGearControllersLabel.textContent;\n    autoGearControllersLabel.textContent = label;\n    const help = texts[lang].autoGearControllersHelp || texts.en?.autoGearControllersHelp || label;\n    autoGearControllersLabel.setAttribute('data-help', help);\n    if (autoGearControllersSelect) {\n      autoGearControllersSelect.setAttribute('data-help', help);\n      autoGearControllersSelect.setAttribute('aria-label', label);\n    }\n  }\n  if (autoGearDistanceLabel) {\n    const label = texts[lang].autoGearDistanceLabel || texts.en?.autoGearDistanceLabel || autoGearDistanceLabel.textContent;\n    autoGearDistanceLabel.textContent = label;\n    const help = texts[lang].autoGearDistanceHelp || texts.en?.autoGearDistanceHelp || label;\n    autoGearDistanceLabel.setAttribute('data-help', help);\n    if (autoGearDistanceSelect) {\n      autoGearDistanceSelect.setAttribute('data-help', help);\n      autoGearDistanceSelect.setAttribute('aria-label', label);\n    }\n  }\n  if (autoGearAddItemsHeading) {\n    autoGearAddItemsHeading.textContent = texts[lang].autoGearAddItemsHeading || texts.en?.autoGearAddItemsHeading || autoGearAddItemsHeading.textContent;\n  }\n  if (autoGearAddItemLabel) {\n    const label = texts[lang].autoGearAddItemLabel || texts.en?.autoGearAddItemLabel || autoGearAddItemLabel.textContent;\n    const hint = texts[lang].autoGearAddMultipleHint || texts.en?.autoGearAddMultipleHint || '';\n    const helpText = hint ? `${label} \u2013 ${hint}` : label;\n    autoGearAddItemLabel.textContent = label;\n    autoGearAddItemLabel.setAttribute('data-help', helpText);\n    if (autoGearAddNameInput) {\n      autoGearAddNameInput.setAttribute('aria-label', label);\n      autoGearAddNameInput.setAttribute('data-help', helpText);\n      if (hint) {\n        autoGearAddNameInput.setAttribute('placeholder', hint);\n      } else {\n        autoGearAddNameInput.removeAttribute('placeholder');\n      }\n    }\n  }\n  if (autoGearAddCategoryLabel) {\n    const label = texts[lang].autoGearAddCategoryLabel || texts.en?.autoGearAddCategoryLabel || autoGearAddCategoryLabel.textContent;\n    autoGearAddCategoryLabel.textContent = label;\n    if (autoGearAddCategorySelect) {\n      autoGearAddCategorySelect.setAttribute('aria-label', label);\n    }\n  }\n  if (autoGearAddQuantityLabel) {\n    const label = texts[lang].autoGearAddQuantityLabel || texts.en?.autoGearAddQuantityLabel || autoGearAddQuantityLabel.textContent;\n    autoGearAddQuantityLabel.textContent = label;\n    if (autoGearAddQuantityInput) {\n      autoGearAddQuantityInput.setAttribute('aria-label', label);\n    }\n  }\n  if (autoGearAddScreenSizeLabel) {\n    const label = texts[lang].autoGearAddScreenSizeLabel || texts.en?.autoGearAddScreenSizeLabel || autoGearAddScreenSizeLabel.textContent;\n    autoGearAddScreenSizeLabel.textContent = label;\n    if (autoGearAddScreenSizeInput) {\n      autoGearAddScreenSizeInput.setAttribute('aria-label', label);\n    }\n  }\n  if (autoGearAddSelectorTypeLabel) {\n    const label = texts[lang].autoGearAddSelectorTypeLabel || texts.en?.autoGearAddSelectorTypeLabel || autoGearAddSelectorTypeLabel.textContent;\n    autoGearAddSelectorTypeLabel.textContent = label;\n    if (autoGearAddSelectorTypeSelect) {\n      autoGearAddSelectorTypeSelect.setAttribute('aria-label', label);\n      const noneLabel = texts[lang].autoGearSelectorNoneOption || texts.en?.autoGearSelectorNoneOption || 'No selector';\n      const monitorLabel = texts[lang].autoGearSelectorMonitorOption || texts.en?.autoGearSelectorMonitorOption || 'Monitor selector';\n      const directorLabel = texts[lang].autoGearSelectorDirectorOption || texts.en?.autoGearSelectorDirectorOption || 'Director monitor selector';\n      Array.from(autoGearAddSelectorTypeSelect.options || []).forEach(opt => {\n        if (opt.value === 'none') opt.textContent = noneLabel;\n        if (opt.value === 'monitor') opt.textContent = monitorLabel;\n        if (opt.value === 'directorMonitor') opt.textContent = directorLabel;\n      });\n    }\n  }\n  if (autoGearAddSelectorDefaultLabel) {\n    const label = texts[lang].autoGearAddSelectorDefaultLabel || texts.en?.autoGearAddSelectorDefaultLabel || autoGearAddSelectorDefaultLabel.textContent;\n    autoGearAddSelectorDefaultLabel.textContent = label;\n    if (autoGearAddSelectorDefaultInput) {\n      autoGearAddSelectorDefaultInput.setAttribute('aria-label', label);\n    }\n  }\n  if (autoGearAddSelectorIncludeLabel) {\n    const label = texts[lang].autoGearAddSelectorIncludeLabel || texts.en?.autoGearAddSelectorIncludeLabel || autoGearAddSelectorIncludeLabel.textContent;\n    autoGearAddSelectorIncludeLabel.textContent = label;\n    if (autoGearAddSelectorIncludeCheckbox) {\n      autoGearAddSelectorIncludeCheckbox.setAttribute('aria-label', label);\n    }\n  }\n  if (autoGearAddNotesLabel) {\n    const label = texts[lang].autoGearAddNotesLabel || texts.en?.autoGearAddNotesLabel || autoGearAddNotesLabel.textContent;\n    autoGearAddNotesLabel.textContent = label;\n    if (autoGearAddNotesInput) {\n      autoGearAddNotesInput.setAttribute('aria-label', label);\n    }\n  }\n  if (autoGearAddItemButton) {\n    const label = texts[lang].autoGearAddItemButton || texts.en?.autoGearAddItemButton || autoGearAddItemButton.textContent;\n    setButtonLabelWithIcon(autoGearAddItemButton, label, ICON_GLYPHS.add);\n    autoGearAddItemButton.setAttribute('data-help', label);\n  }\n  if (autoGearRemoveItemsHeading) {\n    autoGearRemoveItemsHeading.textContent = texts[lang].autoGearRemoveItemsHeading || texts.en?.autoGearRemoveItemsHeading || autoGearRemoveItemsHeading.textContent;\n  }\n  if (autoGearRemoveItemLabel) {\n    const label = texts[lang].autoGearRemoveItemLabel || texts.en?.autoGearRemoveItemLabel || autoGearRemoveItemLabel.textContent;\n    const hint = texts[lang].autoGearRemoveMultipleHint || texts.en?.autoGearRemoveMultipleHint || '';\n    const helpText = hint ? `${label} \u2013 ${hint}` : label;\n    autoGearRemoveItemLabel.textContent = label;\n    autoGearRemoveItemLabel.setAttribute('data-help', helpText);\n    if (autoGearRemoveNameInput) {\n      autoGearRemoveNameInput.setAttribute('aria-label', label);\n      autoGearRemoveNameInput.setAttribute('data-help', helpText);\n      if (hint) {\n        autoGearRemoveNameInput.setAttribute('placeholder', hint);\n      } else {\n        autoGearRemoveNameInput.removeAttribute('placeholder');\n      }\n    }\n  }\n  if (autoGearRemoveCategoryLabel) {\n    const label = texts[lang].autoGearRemoveCategoryLabel || texts.en?.autoGearRemoveCategoryLabel || autoGearRemoveCategoryLabel.textContent;\n    autoGearRemoveCategoryLabel.textContent = label;\n    if (autoGearRemoveCategorySelect) {\n      autoGearRemoveCategorySelect.setAttribute('aria-label', label);\n    }\n  }\n  if (autoGearRemoveQuantityLabel) {\n    const label = texts[lang].autoGearRemoveQuantityLabel || texts.en?.autoGearRemoveQuantityLabel || autoGearRemoveQuantityLabel.textContent;\n    autoGearRemoveQuantityLabel.textContent = label;\n    if (autoGearRemoveQuantityInput) {\n      autoGearRemoveQuantityInput.setAttribute('aria-label', label);\n    }\n  }\n  if (autoGearRemoveScreenSizeLabel) {\n    const label = texts[lang].autoGearRemoveScreenSizeLabel || texts.en?.autoGearRemoveScreenSizeLabel || autoGearRemoveScreenSizeLabel.textContent;\n    autoGearRemoveScreenSizeLabel.textContent = label;\n    if (autoGearRemoveScreenSizeInput) {\n      autoGearRemoveScreenSizeInput.setAttribute('aria-label', label);\n    }\n  }\n  if (autoGearRemoveSelectorTypeLabel) {\n    const label = texts[lang].autoGearRemoveSelectorTypeLabel || texts.en?.autoGearRemoveSelectorTypeLabel || autoGearRemoveSelectorTypeLabel.textContent;\n    autoGearRemoveSelectorTypeLabel.textContent = label;\n    if (autoGearRemoveSelectorTypeSelect) {\n      autoGearRemoveSelectorTypeSelect.setAttribute('aria-label', label);\n      const noneLabel = texts[lang].autoGearSelectorNoneOption || texts.en?.autoGearSelectorNoneOption || 'No selector';\n      const monitorLabel = texts[lang].autoGearSelectorMonitorOption || texts.en?.autoGearSelectorMonitorOption || 'Monitor selector';\n      const directorLabel = texts[lang].autoGearSelectorDirectorOption || texts.en?.autoGearSelectorDirectorOption || 'Director monitor selector';\n      Array.from(autoGearRemoveSelectorTypeSelect.options || []).forEach(opt => {\n        if (opt.value === 'none') opt.textContent = noneLabel;\n        if (opt.value === 'monitor') opt.textContent = monitorLabel;\n        if (opt.value === 'directorMonitor') opt.textContent = directorLabel;\n      });\n    }\n  }\n  if (autoGearRemoveSelectorDefaultLabel) {\n    const label = texts[lang].autoGearRemoveSelectorDefaultLabel || texts.en?.autoGearRemoveSelectorDefaultLabel || autoGearRemoveSelectorDefaultLabel.textContent;\n    autoGearRemoveSelectorDefaultLabel.textContent = label;\n    if (autoGearRemoveSelectorDefaultInput) {\n      autoGearRemoveSelectorDefaultInput.setAttribute('aria-label', label);\n    }\n  }\n  if (autoGearRemoveSelectorIncludeLabel) {\n    const label = texts[lang].autoGearRemoveSelectorIncludeLabel || texts.en?.autoGearRemoveSelectorIncludeLabel || autoGearRemoveSelectorIncludeLabel.textContent;\n    autoGearRemoveSelectorIncludeLabel.textContent = label;\n    if (autoGearRemoveSelectorIncludeCheckbox) {\n      autoGearRemoveSelectorIncludeCheckbox.setAttribute('aria-label', label);\n    }\n  }\n  if (autoGearRemoveNotesLabel) {\n    const label = texts[lang].autoGearRemoveNotesLabel || texts.en?.autoGearRemoveNotesLabel || autoGearRemoveNotesLabel.textContent;\n    autoGearRemoveNotesLabel.textContent = label;\n    if (autoGearRemoveNotesInput) {\n      autoGearRemoveNotesInput.setAttribute('aria-label', label);\n    }\n  }\n  if (autoGearRemoveItemButton) {\n    const label = texts[lang].autoGearRemoveItemButton || texts.en?.autoGearRemoveItemButton || autoGearRemoveItemButton.textContent;\n    setButtonLabelWithIcon(autoGearRemoveItemButton, label, ICON_GLYPHS.minus);\n    autoGearRemoveItemButton.setAttribute('data-help', label);\n  }\n  if (autoGearSaveRuleButton) {\n    const label = texts[lang].autoGearSaveRule || texts.en?.autoGearSaveRule || autoGearSaveRuleButton.textContent;\n    setButtonLabelWithIcon(autoGearSaveRuleButton, label);\n    autoGearSaveRuleButton.setAttribute('data-help', label);\n  }\n  if (autoGearCancelEditButton) {\n    const label = texts[lang].autoGearCancelEdit || texts.en?.autoGearCancelEdit || autoGearCancelEditButton.textContent;\n    setButtonLabelWithIcon(autoGearCancelEditButton, label, ICON_GLYPHS.circleX);\n    autoGearCancelEditButton.setAttribute('data-help', label);\n  }\n  if (autoGearAddCategorySelect) {\n    populateAutoGearCategorySelect(autoGearAddCategorySelect, autoGearAddCategorySelect.value);\n  }\n  if (autoGearRemoveCategorySelect) {\n    populateAutoGearCategorySelect(autoGearRemoveCategorySelect, autoGearRemoveCategorySelect.value);\n  }\n  syncAutoGearMonitorFieldVisibility();\n  if (autoGearScenariosSelect) {\n    refreshAutoGearScenarioOptions(autoGearEditorDraft?.scenarios);\n  }\n  if (autoGearMatteboxSelect) {\n    refreshAutoGearMatteboxOptions(autoGearEditorDraft?.mattebox);\n  }\n  if (autoGearCameraHandleSelect) {\n    refreshAutoGearCameraHandleOptions(autoGearEditorDraft?.cameraHandle);\n  }\n  if (autoGearViewfinderExtensionSelect) {\n    refreshAutoGearViewfinderExtensionOptions(autoGearEditorDraft?.viewfinderExtension);\n  }\n  if (autoGearVideoDistributionSelect) {\n    refreshAutoGearVideoDistributionOptions(autoGearEditorDraft?.videoDistribution);\n  }\n  seedAutoGearRulesFromCurrentProject();\n  renderAutoGearRulesList();\n  renderAutoGearDraftLists();\n  updateAutoGearCatalogOptions();\n  renderAutoGearPresetsControls();\n  applyAutoGearBackupVisibility();\n  const contrastLabel = document.getElementById(\"settingsHighContrastLabel\");\n  if (contrastLabel) {\n    contrastLabel.textContent = texts[lang].highContrastSetting;\n    const contrastHelp =\n      texts[lang].highContrastSettingHelp || texts[lang].highContrastSetting;\n    contrastLabel.setAttribute(\"data-help\", contrastHelp);\n    if (settingsHighContrast) {\n      settingsHighContrast.setAttribute(\"data-help\", contrastHelp);\n      settingsHighContrast.setAttribute(\n        \"aria-label\",\n        texts[lang].highContrastSetting\n      );\n    }\n  }\n  const accessibilityHeading = document.getElementById(\"accessibilityHeading\");\n  if (accessibilityHeading) {\n    accessibilityHeading.textContent = texts[lang].accessibilityHeading;\n    accessibilityHeading.setAttribute(\n      \"data-help\",\n      texts[lang].accessibilityHeadingHelp || texts[lang].accessibilityHeading\n    );\n  }\n  const backupHeading = document.getElementById(\"backupHeading\");\n  if (backupHeading) {\n    backupHeading.textContent = texts[lang].backupHeading;\n    backupHeading.setAttribute(\n      \"data-help\",\n      texts[lang].backupHeadingHelp || texts[lang].backupHeading\n    );\n  }\n  if (dataHeading) {\n    dataHeading.textContent = texts[lang].dataHeading;\n    const dataHelp = texts[lang].dataHeadingHelp || texts[lang].dataHeading;\n    dataHeading.setAttribute(\"data-help\", dataHelp);\n  }\n  if (storageSummaryIntro) {\n    storageSummaryIntro.textContent = texts[lang].storageSummaryIntro;\n  }\n  if (storageSummaryFootnote) {\n    storageSummaryFootnote.textContent = texts[lang].storageSummaryFootnote;\n  }\n  if (storageSummaryEmpty) {\n    storageSummaryEmpty.textContent = texts[lang].storageSummaryEmpty;\n  }\n  const showAutoBackupsLabel = document.getElementById(\"settingsShowAutoBackupsLabel\");\n  if (showAutoBackupsLabel) {\n    showAutoBackupsLabel.textContent = texts[lang].showAutoBackupsSetting;\n    const autoBackupsHelp =\n      texts[lang].showAutoBackupsHelp || texts[lang].showAutoBackupsSetting;\n    showAutoBackupsLabel.setAttribute(\"data-help\", autoBackupsHelp);\n    if (settingsShowAutoBackups) {\n      settingsShowAutoBackups.setAttribute(\"data-help\", autoBackupsHelp);\n      settingsShowAutoBackups.setAttribute(\n        \"aria-label\",\n        texts[lang].showAutoBackupsSetting\n      );\n    }\n  }\n  if (backupSettings) {\n    const backupLabel = texts[lang].backupSettings;\n    setButtonLabelWithIcon(backupSettings, backupLabel, ICON_GLYPHS.fileExport);\n    const backupHelp =\n      texts[lang].backupSettingsHelp || backupLabel;\n    backupSettings.setAttribute(\"data-help\", backupHelp);\n    backupSettings.setAttribute(\"title\", backupHelp);\n    backupSettings.setAttribute(\"aria-label\", backupHelp);\n  }\n  if (restoreSettings) {\n    const restoreLabel = texts[lang].restoreSettings;\n    setButtonLabelWithIcon(restoreSettings, restoreLabel, ICON_GLYPHS.fileImport);\n    const restoreHelp =\n      texts[lang].restoreSettingsHelp || restoreLabel;\n    restoreSettings.setAttribute(\"data-help\", restoreHelp);\n    restoreSettings.setAttribute(\"title\", restoreHelp);\n    restoreSettings.setAttribute(\"aria-label\", restoreHelp);\n  }\n  if (factoryResetButton) {\n    const resetLabel = texts[lang].factoryResetButton || \"Factory reset\";\n    const resetHelp =\n      texts[lang].factoryResetButtonHelp || resetLabel;\n    setButtonLabelWithIcon(factoryResetButton, resetLabel, ICON_GLYPHS.reload);\n    factoryResetButton.setAttribute(\"data-help\", resetHelp);\n    factoryResetButton.setAttribute(\"title\", resetHelp);\n    factoryResetButton.setAttribute(\"aria-label\", resetHelp);\n  }\n  const aboutHeading = document.getElementById(\"aboutHeading\");\n  if (aboutHeading) {\n    aboutHeading.textContent = texts[lang].aboutHeading;\n    aboutHeading.setAttribute(\n      \"data-help\",\n      texts[lang].aboutHeadingHelp || texts[lang].aboutHeading\n    );\n  }\n  if (aboutVersionElem)\n    aboutVersionElem.textContent = `${texts[lang].versionLabel} ${APP_VERSION}`;\n  if (supportLink) {\n    supportLink.textContent = texts[lang].supportLink;\n    const supportHelp =\n      texts[lang].supportLinkHelp || texts[lang].supportLink;\n    supportLink.setAttribute(\"data-help\", supportHelp);\n    supportLink.setAttribute(\"title\", supportHelp);\n  }\n  if (settingsSave) {\n    const label = texts[lang].saveSettings || texts.en?.saveSettings || settingsSave.textContent;\n    setButtonLabelWithIcon(settingsSave, label);\n    const saveHelp = texts[lang].saveSettingsHelp || texts[lang].saveSettings || label;\n    settingsSave.setAttribute(\"data-help\", saveHelp);\n    settingsSave.setAttribute(\"title\", saveHelp);\n    settingsSave.setAttribute(\"aria-label\", saveHelp);\n  }\n  if (settingsCancel) {\n    const cancelLabel =\n      texts[lang].cancelSettings || texts.en?.cancelSettings || settingsCancel.textContent;\n    setButtonLabelWithIcon(settingsCancel, cancelLabel, ICON_GLYPHS.circleX);\n    const cancelHelp =\n      texts[lang].cancelSettingsHelp || texts[lang].cancelSettings || cancelLabel;\n    settingsCancel.setAttribute(\"data-help\", cancelHelp);\n    settingsCancel.setAttribute(\"title\", cancelHelp);\n    settingsCancel.setAttribute(\"aria-label\", cancelHelp);\n  }\n  const menuToggle = document.getElementById(\"menuToggle\");\n  if (menuToggle) {\n    const menuLabel =\n      texts[lang].menuToggleLabel ||\n      texts.en?.menuToggleLabel ||\n      menuToggle.getAttribute(\"aria-label\") ||\n      \"Menu\";\n    menuToggle.setAttribute(\"title\", menuLabel);\n    menuToggle.setAttribute(\"aria-label\", menuLabel);\n    const menuHelp = texts[lang].menuToggleHelp || menuLabel;\n    menuToggle.setAttribute(\"data-help\", menuHelp);\n  }\n  const sideMenu = document.getElementById(\"sideMenu\");\n  if (sideMenu) {\n    const sideMenuHelp = texts[lang].sideMenuHelp;\n    if (sideMenuHelp) {\n      sideMenu.setAttribute(\"data-help\", sideMenuHelp);\n    } else {\n      sideMenu.removeAttribute(\"data-help\");\n    }\n  }\n  if (reloadButton) {\n    reloadButton.setAttribute(\"title\", texts[lang].reloadAppLabel);\n    reloadButton.setAttribute(\"aria-label\", texts[lang].reloadAppLabel);\n    reloadButton.setAttribute(\n      \"data-help\",\n      texts[lang].reloadAppHelp || texts[lang].reloadAppLabel\n    );\n  }\n  if (featureSearch) {\n    featureSearch.setAttribute(\"placeholder\", texts[lang].featureSearchPlaceholder);\n    featureSearch.setAttribute(\"aria-label\", texts[lang].featureSearchLabel);\n    featureSearch.setAttribute(\n      \"data-help\",\n      texts[lang].featureSearchHelp || texts[lang].featureSearchLabel\n    );\n  }\n  if (helpButton) {\n    helpButton.setAttribute(\"title\", texts[lang].helpButtonTitle || texts[lang].helpButtonLabel);\n    helpButton.setAttribute(\"aria-label\", texts[lang].helpButtonLabel);\n    helpButton.setAttribute(\n      \"data-help\",\n      texts[lang].helpButtonHelp ||\n        texts[lang].helpButtonTitle ||\n        texts[lang].helpButtonLabel\n    );\n  if (hoverHelpButton) {\n    setButtonLabelWithIcon(hoverHelpButton, texts[lang].hoverHelpButtonLabel, ICON_GLYPHS.note);\n    hoverHelpButton.setAttribute(\"aria-label\", texts[lang].hoverHelpButtonLabel);\n    hoverHelpButton.setAttribute(\n      \"data-help\",\n      texts[lang].hoverHelpButtonHelp || texts[lang].hoverHelpButtonLabel\n    );\n    }\n    if (helpSearch) {\n      helpSearch.setAttribute(\"placeholder\", texts[lang].helpSearchPlaceholder);\n      helpSearch.setAttribute(\"aria-label\", texts[lang].helpSearchLabel);\n      helpSearch.setAttribute(\n        \"data-help\",\n        texts[lang].helpSearchHelp || texts[lang].helpSearchLabel\n      );\n    }\n    if (helpSearchClear) {\n      helpSearchClear.setAttribute(\"title\", texts[lang].helpSearchClear);\n      helpSearchClear.setAttribute(\"aria-label\", texts[lang].helpSearchClear);\n      helpSearchClear.setAttribute(\n        \"data-help\",\n        texts[lang].helpSearchClearHelp || texts[lang].helpSearchClear\n      );\n    }\n    if (closeHelpBtn) {\n      setButtonLabelWithIcon(closeHelpBtn, texts[lang].helpClose, ICON_GLYPHS.circleX);\n      closeHelpBtn.setAttribute(\"title\", texts[lang].helpClose);\n      closeHelpBtn.setAttribute(\"aria-label\", texts[lang].helpClose);\n      closeHelpBtn.setAttribute(\n        \"data-help\",\n        texts[lang].helpCloseHelp || texts[lang].helpClose\n      );\n    }\n    if (document.getElementById(\"helpTitle\")) {\n      document.getElementById(\"helpTitle\").textContent = texts[lang].helpTitle;\n    }\n    if (helpNoResults) helpNoResults.textContent = texts[lang].helpNoResults;\n    if (typeof updateHelpResultsSummaryText === 'function') {\n      updateHelpResultsSummaryText();\n    }\n    if (typeof updateHelpQuickLinksForLanguage === 'function') {\n      updateHelpQuickLinksForLanguage(lang);\n    }\n  }\n\n  // NEW SETUP MANAGEMENT BUTTONS TEXTS\n  setButtonLabelWithIcon(\n    document.getElementById(\"generateOverviewBtn\"),\n    texts[lang].generateOverviewBtn,\n    ICON_GLYPHS.overview\n  );\n  setButtonLabelWithIcon(\n    document.getElementById(\"generateGearListBtn\"),\n    texts[lang].generateGearListBtn,\n    ICON_GLYPHS.gearList\n  );\n  setButtonLabelWithIcon(\n    document.getElementById(\"shareSetupBtn\"),\n    texts[lang].shareSetupBtn,\n    ICON_GLYPHS.fileExport\n  );\n  const exportRevert = document.getElementById(\"exportAndRevertBtn\");\n  if (exportRevert) {\n    setButtonLabelWithIcon(exportRevert, texts[lang].exportAndRevertBtn, ICON_GLYPHS.reload);\n    exportRevert.setAttribute('data-help', texts[lang].exportAndRevertBtnHelp);\n  }\n\n  if (downloadDiagramBtn) {\n    downloadDiagramBtn.textContent = texts[lang].downloadDiagramBtn;\n    downloadDiagramBtn.setAttribute(\"title\", texts[lang].downloadDiagramBtn);\n    downloadDiagramBtn.setAttribute(\"aria-label\", texts[lang].downloadDiagramBtn);\n    downloadDiagramBtn.setAttribute(\"data-help\", texts[lang].downloadDiagramHelp);\n  }\n  if (gridSnapToggleBtn) {\n    setButtonLabelWithIcon(gridSnapToggleBtn, texts[lang].gridSnapToggle, ICON_GLYPHS.magnet);\n    gridSnapToggleBtn.setAttribute(\"title\", texts[lang].gridSnapToggle);\n    gridSnapToggleBtn.setAttribute(\"aria-label\", texts[lang].gridSnapToggle);\n    gridSnapToggleBtn.setAttribute(\"data-help\", texts[lang].gridSnapToggleHelp);\n    gridSnapToggleBtn.setAttribute(\"aria-pressed\", gridSnap ? \"true\" : \"false\");\n  }\n  if (resetViewBtn) {\n    setButtonLabelWithIcon(resetViewBtn, texts[lang].resetViewBtn, ICON_GLYPHS.resetView);\n    resetViewBtn.setAttribute(\"title\", texts[lang].resetViewBtn);\n    resetViewBtn.setAttribute(\"aria-label\", texts[lang].resetViewBtn);\n    resetViewBtn.setAttribute(\"data-help\", texts[lang].resetViewHelp);\n  }\n  if (zoomInBtn) {\n    setButtonLabelWithIcon(zoomInBtn, '', ICON_GLYPHS.add);\n    zoomInBtn.setAttribute(\"title\", texts[lang].zoomInLabel);\n    zoomInBtn.setAttribute(\"aria-label\", texts[lang].zoomInLabel);\n    zoomInBtn.setAttribute(\"data-help\", texts[lang].zoomInHelp);\n  }\n  if (zoomOutBtn) {\n    setButtonLabelWithIcon(zoomOutBtn, '', ICON_GLYPHS.minus);\n    zoomOutBtn.setAttribute(\"title\", texts[lang].zoomOutLabel);\n    zoomOutBtn.setAttribute(\"aria-label\", texts[lang].zoomOutLabel);\n    zoomOutBtn.setAttribute(\"data-help\", texts[lang].zoomOutHelp);\n  }\n  if (diagramHint) {\n    diagramHint.textContent = texts[lang].diagramMoveHint;\n  }\n  const fallbackProjectForm = texts.en && texts.en.projectForm ? texts.en.projectForm : {};\n  const projectFormTexts = texts[lang].projectForm || fallbackProjectForm;\n  if (projectFormTexts) {\n    const setLabelText = (element, key) => {\n      if (!element) return;\n      const value = projectFormTexts[key] || fallbackProjectForm[key];\n      if (value) element.textContent = value;\n    };\n    setLabelText(projectDialogHeading, 'heading');\n    setLabelText(projectNameLabel, 'projectName');\n    setLabelText(productionCompanyLabel, 'productionCompany');\n    setLabelText(rentalHouseLabel, 'rentalHouse');\n    setLabelText(crewHeadingElem, 'crewHeading');\n    if (crewLabelElem) {\n      const crewLabelText = projectFormTexts.crewHeading || fallbackProjectForm.crewHeading;\n      if (crewLabelText) {\n        crewLabelElem.textContent = `${crewLabelText}:`;\n      }\n    }\n    setLabelText(prepLabelElem, 'prepLabel');\n    setLabelText(shootLabelElem, 'shootLabel');\n    setLabelText(deliveryResolutionLabel, 'deliveryResolution');\n    setLabelText(recordingResolutionLabel, 'recordingResolution');\n    setLabelText(sensorModeLabel, 'sensorMode');\n    setLabelText(aspectRatioLabel, 'aspectRatio');\n    setLabelText(codecLabel, 'codec');\n    setLabelText(baseFrameRateLabel, 'baseFrameRate');\n    setLabelText(lensesHeadingElem, 'lensesHeading');\n    setLabelText(lensesLabelElem, 'lensesLabel');\n    setLabelText(riggingHeadingElem, 'riggingHeading');\n    setLabelText(requiredScenariosLabel, 'requiredScenarios');\n    setLabelText(cameraHandleLabel, 'cameraHandle');\n    setLabelText(viewfinderExtensionLabel, 'viewfinderExtension');\n    setLabelText(matteboxFilterHeadingElem, 'matteboxFilterHeading');\n    setLabelText(matteboxLabel, 'mattebox');\n    setLabelText(filterLabel, 'filter');\n    setLabelText(monitoringHeadingElem, 'monitoringHeading');\n    setLabelText(monitoringConfigurationLabel, 'monitoringConfiguration');\n    setLabelText(viewfinderSettingsLabel, 'viewfinderSettings');\n    setLabelText(frameGuidesLabel, 'frameGuides');\n    setLabelText(aspectMaskOpacityLabel, 'aspectMaskOpacity');\n    setLabelText(videoDistributionLabel, 'videoDistribution');\n    setLabelText(monitorUserButtonsLabel, 'monitorUserButtons');\n    setLabelText(cameraUserButtonsLabel, 'cameraUserButtons');\n    setLabelText(viewfinderUserButtonsLabel, 'viewfinderUserButtons');\n    setLabelText(tripodPreferencesHeading, 'tripodPreferencesHeading');\n    setLabelText(tripodHeadBrandLabel, 'tripodHeadBrand');\n    setLabelText(tripodBowlLabel, 'tripodBowl');\n    setLabelText(tripodTypesLabel, 'tripodTypes');\n    setLabelText(tripodSpreaderLabel, 'tripodSpreader');\n    if (viewfinderExtensionSelect && viewfinderExtensionSelect.options.length >= 2) {\n      const noneLabel = projectFormTexts.viewfinderExtensionNone || fallbackProjectForm.viewfinderExtensionNone;\n      const yesLabel = projectFormTexts.viewfinderExtensionYes || fallbackProjectForm.viewfinderExtensionYes;\n      if (noneLabel) viewfinderExtensionSelect.options[0].textContent = noneLabel;\n      if (yesLabel) viewfinderExtensionSelect.options[1].textContent = yesLabel;\n    }\n    const cancelText =\n      projectFormTexts.cancel ||\n      fallbackProjectForm.cancel ||\n      (projectCancelBtn ? projectCancelBtn.textContent : projectDialogCloseBtn?.getAttribute('aria-label')) ||\n      'Cancel';\n    if (projectCancelBtn) {\n      setButtonLabelWithIcon(projectCancelBtn, cancelText, ICON_GLYPHS.circleX);\n    }\n    if (projectDialogCloseBtn) {\n      projectDialogCloseBtn.innerHTML = iconMarkup(ICON_GLYPHS.circleX, 'btn-icon');\n      projectDialogCloseBtn.setAttribute('aria-label', cancelText);\n      projectDialogCloseBtn.setAttribute('title', cancelText);\n      projectDialogCloseBtn.setAttribute('data-help', cancelText);\n    }\n    if (projectSubmitBtn) {\n      const submitText = projectFormTexts.submit || fallbackProjectForm.submit;\n      if (submitText) {\n        setButtonLabelWithIcon(projectSubmitBtn, submitText, ICON_GLYPHS.check);\n        projectSubmitBtn.setAttribute('aria-label', submitText);\n      }\n    }\n    const crewPlaceholders = {\n      name: projectFormTexts.crewNamePlaceholder || fallbackProjectForm.crewNamePlaceholder,\n      phone: projectFormTexts.crewPhonePlaceholder || fallbackProjectForm.crewPhonePlaceholder,\n      email: projectFormTexts.crewEmailPlaceholder || fallbackProjectForm.crewEmailPlaceholder\n    };\n    const crewRoleLabels = texts[lang].crewRoles || (texts.en && texts.en.crewRoles) || {};\n    document.querySelectorAll('#crewContainer .person-row').forEach(row => {\n      const roleSelect = row.querySelector('select');\n      if (roleSelect) {\n        const currentValue = roleSelect.value;\n        Array.from(roleSelect.options).forEach(opt => {\n          const roleKey = opt.value;\n          opt.textContent = crewRoleLabels[roleKey] || roleKey;\n        });\n        roleSelect.value = currentValue;\n      }\n      const nameInput = row.querySelector('.person-name');\n      if (nameInput && crewPlaceholders.name) nameInput.placeholder = crewPlaceholders.name;\n      const phoneInput = row.querySelector('.person-phone');\n      if (phoneInput && crewPlaceholders.phone) phoneInput.placeholder = crewPlaceholders.phone;\n      const emailInput = row.querySelector('.person-email');\n      if (emailInput && crewPlaceholders.email) emailInput.placeholder = crewPlaceholders.email;\n    });\n    const stripTrailingPunctuation = value => (typeof value === 'string' ? value.replace(/[\\s\\u00a0]*[:\uFF1A]\\s*$/, '') : value);\n    const addEntryLabel = projectFormTexts.addEntry || fallbackProjectForm.addEntry || 'Add';\n    if (addPersonBtn) {\n      const crewLabel = stripTrailingPunctuation(projectFormTexts.crewHeading || fallbackProjectForm.crewHeading || 'Crew');\n      const label = `${addEntryLabel} ${crewLabel}`.trim();\n      setButtonLabelWithIcon(addPersonBtn, label, ICON_GLYPHS.add);\n      addPersonBtn.setAttribute('aria-label', label);\n      addPersonBtn.setAttribute('data-help', label);\n    }\n    if (addPrepBtn) {\n      const prepLabel = stripTrailingPunctuation(projectFormTexts.prepLabel || fallbackProjectForm.prepLabel || 'Prep');\n      const label = `${addEntryLabel} ${prepLabel}`.trim();\n      setButtonLabelWithIcon(addPrepBtn, label, ICON_GLYPHS.add);\n      addPrepBtn.setAttribute('aria-label', label);\n      addPrepBtn.setAttribute('data-help', label);\n    }\n    if (addShootBtn) {\n      const shootLabel = stripTrailingPunctuation(projectFormTexts.shootLabel || fallbackProjectForm.shootLabel || 'Shoot');\n      const label = `${addEntryLabel} ${shootLabel}`.trim();\n      setButtonLabelWithIcon(addShootBtn, label, ICON_GLYPHS.add);\n      addShootBtn.setAttribute('aria-label', label);\n      addShootBtn.setAttribute('data-help', label);\n    }\n  }\n  if (iosPwaHelpTitle) iosPwaHelpTitle.textContent = texts[lang].iosPwaHelpTitle;\n  if (iosPwaHelpIntro) iosPwaHelpIntro.textContent = texts[lang].iosPwaHelpIntro;\n  if (iosPwaHelpStep1) iosPwaHelpStep1.textContent = texts[lang].iosPwaHelpStep1;\n  if (iosPwaHelpStep2) iosPwaHelpStep2.textContent = texts[lang].iosPwaHelpStep2;\n  if (iosPwaHelpStep3) iosPwaHelpStep3.textContent = texts[lang].iosPwaHelpStep3;\n  if (iosPwaHelpStep4) iosPwaHelpStep4.textContent = texts[lang].iosPwaHelpStep4;\n  if (iosPwaHelpNote) iosPwaHelpNote.textContent = texts[lang].iosPwaHelpNote;\n  if (iosPwaHelpClose) {\n    const closeText = texts[lang].iosPwaHelpClose;\n    setButtonLabelWithIcon(iosPwaHelpClose, closeText, ICON_GLYPHS.check);\n    iosPwaHelpClose.setAttribute('aria-label', closeText);\n  }\n\n  document.querySelectorAll('.favorite-toggle').forEach(btn => {\n    btn.setAttribute('aria-label', texts[lang].favoriteToggleLabel);\n    btn.setAttribute('title', texts[lang].favoriteToggleLabel);\n    btn.setAttribute(\n      'data-help',\n      texts[lang].favoriteToggleHelp || texts[lang].favoriteToggleLabel\n    );\n  });\n  ensureGearListActions();\n  updateDiagramLegend();\n  updateStorageSummary();\n  populateFeatureSearch();\n}\n\n// Reference elements (DOM Elements)\nconst cameraSelect    = document.getElementById(\"cameraSelect\");\nconst monitorSelect   = document.getElementById(\"monitorSelect\");\nconst videoSelect     = document.getElementById(\"videoSelect\");\nconst videoDistributionSelect = document.getElementById(\"videoDistribution\");\nconst cageSelect      = document.getElementById(\"cageSelect\");\nconst motorSelects    = [\n  document.getElementById(\"motor1Select\"),\n  document.getElementById(\"motor2Select\"),\n  document.getElementById(\"motor3Select\"),\n  document.getElementById(\"motor4Select\")\n];\nconst controllerSelects = [\n  document.getElementById(\"controller1Select\"),\n  document.getElementById(\"controller2Select\"),\n  document.getElementById(\"controller3Select\"),\n  document.getElementById(\"controller4Select\")\n];\nconst distanceSelect = document.getElementById(\"distanceSelect\");\nconst batterySelect  = document.getElementById(\"batterySelect\");\nconst hotswapSelect  = document.getElementById(\"batteryHotswapSelect\");\nconst lensSelect     = document.getElementById(\"lenses\");\nconst requiredScenariosSelect = document.getElementById(\"requiredScenarios\");\nconst requiredScenariosSummary = document.getElementById(\"requiredScenariosSummary\");\nconst remoteHeadOption = requiredScenariosSelect ?\n  requiredScenariosSelect.querySelector('option[value=\"Remote Head\"]') : null;\nconst tripodPreferencesSection = document.getElementById(\"tripodPreferencesSection\");\nconst tripodPreferencesRow = document.getElementById(\"tripodPreferencesRow\");\nconst tripodPreferencesHeading = document.getElementById(\"tripodPreferencesHeading\");\nconst tripodHeadBrandSelect = document.getElementById(\"tripodHeadBrand\");\nconst tripodBowlSelect = document.getElementById(\"tripodBowl\");\nconst tripodTypesSelect = document.getElementById(\"tripodTypes\");\nconst tripodSpreaderSelect = document.getElementById(\"tripodSpreader\");\nconst monitoringConfigurationSelect = document.getElementById(\"monitoringConfiguration\");\nconst viewfinderSettingsRow = document.getElementById(\"viewfinderSettingsRow\");\nconst viewfinderExtensionRow = document.getElementById(\"viewfinderExtensionRow\");\nconst projectDialogHeading = document.getElementById(\"projectDialogHeading\");\nconst projectDialogCloseBtn = document.getElementById(\"projectDialogClose\");\nconst projectNameLabel = document.getElementById(\"projectNameLabel\");\nconst productionCompanyLabel = document.getElementById(\"productionCompanyLabel\");\nconst rentalHouseLabel = document.getElementById(\"rentalHouseLabel\");\nconst crewHeadingElem = document.getElementById(\"crewHeading\");\nconst crewLabelElem = document.getElementById(\"crewLabel\");\nconst prepLabelElem = document.getElementById(\"prepLabel\");\nconst shootLabelElem = document.getElementById(\"shootLabel\");\nconst deliveryResolutionLabel = document.getElementById(\"deliveryResolutionLabel\");\nconst recordingResolutionLabel = document.getElementById(\"recordingResolutionLabel\");\nconst sensorModeLabel = document.getElementById(\"sensorModeLabel\");\nconst aspectRatioLabel = document.getElementById(\"aspectRatioLabel\");\nconst codecLabel = document.getElementById(\"codecLabel\");\nconst baseFrameRateLabel = document.getElementById(\"baseFrameRateLabel\");\nconst lensesHeadingElem = document.getElementById(\"lensesHeading\");\nconst lensesLabelElem = document.getElementById(\"lensesLabel\");\nconst riggingHeadingElem = document.getElementById(\"riggingHeading\");\nconst requiredScenariosLabel = document.getElementById(\"requiredScenariosLabel\");\nconst cameraHandleLabel = document.getElementById(\"cameraHandleLabel\");\nconst viewfinderExtensionLabel = document.getElementById(\"viewfinderExtensionLabel\");\nconst viewfinderExtensionSelect = document.getElementById(\"viewfinderExtension\");\nconst matteboxFilterHeadingElem = document.getElementById(\"matteboxFilterHeading\");\nconst matteboxLabel = document.getElementById(\"matteboxLabel\");\nconst filterLabel = document.getElementById(\"filterLabel\");\nconst monitoringHeadingElem = document.getElementById(\"monitoringHeading\");\nconst monitoringConfigurationLabel = document.getElementById(\"monitoringConfigurationLabel\");\nconst viewfinderSettingsLabel = document.getElementById(\"viewfinderSettingsLabel\");\nconst frameGuidesLabel = document.getElementById(\"frameGuidesLabel\");\nconst aspectMaskOpacityLabel = document.getElementById(\"aspectMaskOpacityLabel\");\nconst videoDistributionLabel = document.getElementById(\"videoDistributionLabel\");\nconst monitorUserButtonsLabel = document.getElementById(\"monitorUserButtonsLabel\");\nconst cameraUserButtonsLabel = document.getElementById(\"cameraUserButtonsLabel\");\nconst viewfinderUserButtonsLabel = document.getElementById(\"viewfinderUserButtonsLabel\");\nconst tripodHeadBrandLabel = document.getElementById(\"tripodHeadBrandLabel\");\nconst tripodBowlLabel = document.getElementById(\"tripodBowlLabel\");\nconst tripodTypesLabel = document.getElementById(\"tripodTypesLabel\");\nconst tripodSpreaderLabel = document.getElementById(\"tripodSpreaderLabel\");\nconst projectSubmitBtn = document.getElementById(\"projectSubmit\");\nconst crewContainer = document.getElementById(\"crewContainer\");\nconst addPersonBtn = document.getElementById(\"addPersonBtn\");\nconst prepContainer = document.getElementById(\"prepContainer\");\nconst addPrepBtn = document.getElementById(\"addPrepBtn\");\nconst shootContainer = document.getElementById(\"shootContainer\");\nconst addShootBtn = document.getElementById(\"addShootBtn\");\n\nlet monitoringConfigurationUserChanged = false;\n\nconst crewRoles = [\n  // Production\n  'Producer',\n  'Production Manager',\n  'Director',\n  'Assistant Director',\n  'Production Assistant',\n\n  // Camera\n  'DoP',\n  'Camera Operator',\n  'B-Camera Operator',\n  'Steadicam Operator',\n  'Drone Operator',\n  '1st AC',\n  '2nd AC',\n  'DIT',\n  'Video Operator',\n\n  // Lighting\n  'Key Gaffer',\n  'Gaffer',\n  'Best Boy Electric',\n  'Electrician',\n  'Rigging Gaffer',\n\n  // Grip\n  'Key Grip',\n  'Best Boy Grip',\n  'Grip',\n  'Dolly Grip',\n  'Rigging Grip'\n];\n\nconst ICON_FONT_KEYS = Object.freeze({\n  ESSENTIAL: 'essential',\n  FILM: 'film',\n  GADGET: 'gadget',\n  UICONS: 'uicons',\n  TEXT: 'text'\n});\n\nconst VALID_ICON_FONTS = new Set(Object.values(ICON_FONT_KEYS));\n\nfunction iconGlyph(char, font = ICON_FONT_KEYS.UICONS) {\n  const normalizedFont = VALID_ICON_FONTS.has(font) ? font : ICON_FONT_KEYS.UICONS;\n  return Object.freeze({ char, font: normalizedFont });\n}\n\nfunction resolveIconGlyph(glyph) {\n  if (!glyph) {\n    return { char: '', font: ICON_FONT_KEYS.UICONS, className: '', size: undefined };\n  }\n  if (glyph.markup) {\n    const size = Number.isFinite(glyph.size) ? glyph.size : undefined;\n    return {\n      markup: glyph.markup,\n      className: glyph.className || '',\n      font: ICON_FONT_KEYS.UICONS,\n      size\n    };\n  }\n  if (typeof glyph === 'string') {\n    return { char: glyph, font: ICON_FONT_KEYS.UICONS, className: '', size: undefined };\n  }\n  if (typeof glyph === 'object') {\n    const char = typeof glyph.char === 'string' ? glyph.char : '';\n    const fontKey = glyph.font && VALID_ICON_FONTS.has(glyph.font)\n      ? glyph.font\n      : ICON_FONT_KEYS.UICONS;\n    const className = typeof glyph.className === 'string' ? glyph.className : '';\n    const size = Number.isFinite(glyph.size) ? glyph.size : undefined;\n    if (glyph.markup) {\n      return {\n        markup: glyph.markup,\n        className,\n        font: fontKey,\n        size\n      };\n    }\n    return { char, font: fontKey, className, size };\n  }\n  return { char: '', font: ICON_FONT_KEYS.UICONS, className: '', size: undefined };\n}\n\nfunction applyIconGlyph(element, glyph) {\n  if (!element) return;\n  const resolved = resolveIconGlyph(glyph);\n  if (resolved.markup) {\n    element.innerHTML = ensureSvgHasAriaHidden(resolved.markup);\n    element.setAttribute('aria-hidden', 'true');\n    if (resolved.className) {\n      resolved.className\n        .split(/\\s+/)\n        .filter(Boolean)\n        .forEach(cls => element.classList.add(cls));\n    }\n    element.removeAttribute('data-icon-font');\n    return;\n  }\n  const char = resolved.char || '';\n  element.textContent = char;\n  if (char) {\n    element.setAttribute('data-icon-font', resolved.font);\n  } else {\n    element.removeAttribute('data-icon-font');\n  }\n}\n\nfunction formatSvgCoordinate(value) {\n  if (!Number.isFinite(value)) return '0';\n  const rounded = Math.round(value * 100) / 100;\n  if (Number.isInteger(rounded)) return String(rounded);\n  return rounded.toFixed(2).replace(/0+$/, '').replace(/\\.$/, '');\n}\n\nfunction positionSvgMarkup(markup, centerX, centerY, size = 24) {\n  if (typeof markup !== 'string') {\n    return { markup: '', x: '0', y: '0' };\n  }\n  const trimmed = markup.trim();\n  if (!trimmed) {\n    return { markup: '', x: '0', y: '0' };\n  }\n  const half = size / 2;\n  const x = formatSvgCoordinate(centerX);\n  const y = formatSvgCoordinate(centerY);\n  const width = formatSvgCoordinate(size);\n  const height = formatSvgCoordinate(size);\n  const cleaned = trimmed.replace(/<svg\\b([^>]*)>/i, (match, attrs = '') => {\n    let attrText = attrs\n      .replace(/\\s+x\\s*=\\s*\"[^\"]*\"/gi, '')\n      .replace(/\\s+y\\s*=\\s*\"[^\"]*\"/gi, '')\n      .trim();\n    const additions = [];\n    const hasWidth = /(?:^|\\s)width\\s*=/i.test(attrText);\n    const hasHeight = /(?:^|\\s)height\\s*=/i.test(attrText);\n    if (!hasWidth) additions.push(`width=\"${width}\"`);\n    if (!hasHeight) additions.push(`height=\"${height}\"`);\n    additions.push(`x=\"-${formatSvgCoordinate(half)}\"`);\n    additions.push(`y=\"-${formatSvgCoordinate(half)}\"`);\n    attrText = [attrText, ...additions].filter(Boolean).join(' ').trim();\n    return attrText ? `<svg ${attrText}>` : '<svg>';\n  });\n  return { markup: cleaned, x, y };\n}\n\nfunction glyphText(glyph) {\n  const resolved = resolveIconGlyph(glyph);\n  return resolved.char || '';\n}\n\nconst FEEDBACK_ICON_SVG = `\n  <svg viewBox=\"0 0 24 24\" xmlns=\"http://www.w3.org/2000/svg\" aria-hidden=\"true\">\n    <path\n      d=\"M5 4.5H19Q21.5 4.5 21.5 7V13Q21.5 15.5 19 15.5H15.5L12 19 8.5 15.5H5Q2.5 15.5 2.5 13V7Q2.5 4.5 5 4.5Z\"\n      fill=\"none\"\n      stroke=\"currentColor\"\n      stroke-width=\"1.5\"\n      stroke-linecap=\"round\"\n      stroke-linejoin=\"round\"\n    />\n    <path\n      d=\"M8.5 10.5 10.5 12.5 14.5 8.5\"\n      fill=\"none\"\n      stroke=\"currentColor\"\n      stroke-width=\"1.5\"\n      stroke-linecap=\"round\"\n      stroke-linejoin=\"round\"\n    />\n  </svg>\n`.trim();\n\nconst PRODUCTION_COMPANY_ICON = iconGlyph('\\uE2D5', ICON_FONT_KEYS.UICONS);\nconst RENTAL_HOUSE_ICON = iconGlyph('\\uEA09', ICON_FONT_KEYS.UICONS);\nconst ASPECT_RATIO_ICON = iconGlyph('\\uE86E', ICON_FONT_KEYS.UICONS);\nconst REQUIRED_SCENARIOS_ICON = iconGlyph('\\uF4D4', ICON_FONT_KEYS.UICONS);\nconst MONITORING_SUPPORT_ICON = iconGlyph('\\uEFFC', ICON_FONT_KEYS.UICONS);\n\nconst STAR_ICON_SVG = `\n  <svg viewBox=\"0 0 24 24\" xmlns=\"http://www.w3.org/2000/svg\">\n    <path\n      d=\"M12 17.25 6.545 20.2 7.9 13.975 3 9.45l6.272-.7L12 3l2.728 5.75L21 9.45l-4.9 4.525 1.355 6.225Z\"\n      fill=\"currentColor\"\n      stroke=\"currentColor\"\n      stroke-width=\"0\"\n    />\n  </svg>\n`.trim();\n\nconst ICON_GLYPHS = Object.freeze({\n  batteryBolt: iconGlyph('\\uE1A6', ICON_FONT_KEYS.UICONS),\n  batteryFull: iconGlyph('\\uE1A9', ICON_FONT_KEYS.UICONS),\n  bolt: iconGlyph('\\uF1F8', ICON_FONT_KEYS.ESSENTIAL),\n  plug: iconGlyph('\\uEE75', ICON_FONT_KEYS.UICONS),\n  sliders: iconGlyph('\\uF143', ICON_FONT_KEYS.ESSENTIAL),\n  screen: iconGlyph('\\uF11D', ICON_FONT_KEYS.GADGET),\n  brightness: iconGlyph('\\uE2B3', ICON_FONT_KEYS.UICONS),\n  wifi: iconGlyph('\\uF4AC', ICON_FONT_KEYS.UICONS),\n  gears: iconGlyph('\\uE8AF', ICON_FONT_KEYS.UICONS),\n  controller: iconGlyph('\\uF117', ICON_FONT_KEYS.GADGET),\n  distance: iconGlyph('\\uEFB9', ICON_FONT_KEYS.UICONS),\n  sensor: iconGlyph('\\uEC2B', ICON_FONT_KEYS.UICONS),\n  viewfinder: iconGlyph('\\uF114', ICON_FONT_KEYS.FILM),\n  camera: iconGlyph('\\uE333', ICON_FONT_KEYS.UICONS),\n  trash: iconGlyph('\\uF254', ICON_FONT_KEYS.ESSENTIAL),\n  reload: iconGlyph('\\uF202', ICON_FONT_KEYS.ESSENTIAL),\n  load: iconGlyph('\\uE0E0', ICON_FONT_KEYS.UICONS),\n  add: Object.freeze({ char: '+', font: ICON_FONT_KEYS.TEXT, className: 'icon-text' }),\n  minus: Object.freeze({ char: '\u2212', font: ICON_FONT_KEYS.TEXT, className: 'icon-text' }),\n  check: iconGlyph('\\uE3D8', ICON_FONT_KEYS.UICONS),\n  fileExport: iconGlyph('\\uE7AB', ICON_FONT_KEYS.UICONS),\n  fileImport: iconGlyph('\\uE7C7', ICON_FONT_KEYS.UICONS),\n  save: iconGlyph('\\uF207', ICON_FONT_KEYS.ESSENTIAL),\n  share: iconGlyph('\\uF219', ICON_FONT_KEYS.ESSENTIAL),\n  paperPlane: iconGlyph('\\uED67', ICON_FONT_KEYS.UICONS),\n  magnet: iconGlyph('\\uF1B5', ICON_FONT_KEYS.ESSENTIAL),\n  codec: iconGlyph('\\uE4CD', ICON_FONT_KEYS.UICONS),\n  timecode: iconGlyph('\\uF10E', ICON_FONT_KEYS.FILM),\n  audioIn: iconGlyph('\\uF1C3', ICON_FONT_KEYS.ESSENTIAL),\n  audioOut: iconGlyph('\\uF22F', ICON_FONT_KEYS.ESSENTIAL),\n  note: iconGlyph('\\uF13E', ICON_FONT_KEYS.ESSENTIAL),\n  overview: iconGlyph('\\uF1F5', ICON_FONT_KEYS.UICONS),\n  gearList: iconGlyph('\\uE467', ICON_FONT_KEYS.UICONS),\n  feedback: Object.freeze({ markup: FEEDBACK_ICON_SVG, className: 'icon-svg' }),\n  resetView: iconGlyph('\\uEB6D', ICON_FONT_KEYS.UICONS),\n  pin: iconGlyph('\\uF1EF', ICON_FONT_KEYS.ESSENTIAL),\n  sun: iconGlyph('\\uF1FE', ICON_FONT_KEYS.UICONS),\n  moon: iconGlyph('\\uEC7E', ICON_FONT_KEYS.UICONS),\n  circleX: iconGlyph('\\uF131', ICON_FONT_KEYS.ESSENTIAL),\n  star: Object.freeze({\n    markup: STAR_ICON_SVG,\n    className: 'icon-svg favorite-star-icon'\n  }),\n  warning: iconGlyph('\\uF26F', ICON_FONT_KEYS.ESSENTIAL)\n});\n\nfunction iconMarkup(glyph, classNameOrOptions = 'info-icon', options = null) {\n  if (!glyph) return '';\n  let opts = {};\n  let resolvedClassName = 'info-icon';\n  if (typeof classNameOrOptions === 'string' || classNameOrOptions === null) {\n    resolvedClassName = classNameOrOptions || '';\n    if (options && typeof options === 'object') {\n      opts = options;\n    }\n  } else if (classNameOrOptions && typeof classNameOrOptions === 'object') {\n    opts = classNameOrOptions;\n    resolvedClassName = classNameOrOptions.className || 'info-icon';\n  }\n  if (typeof opts.className === 'string') {\n    resolvedClassName = opts.className;\n  }\n  const styleParts = [];\n  if (typeof opts.size === 'string' && opts.size.trim()) {\n    styleParts.push(`--icon-size: ${opts.size.trim()}`);\n  }\n  if (typeof opts.scale === 'string' && opts.scale.trim()) {\n    styleParts.push(`--icon-scale: ${opts.scale.trim()}`);\n  }\n  if (typeof opts.style === 'string' && opts.style.trim()) {\n    styleParts.push(opts.style.trim());\n  }\n  const styleAttr = styleParts.length ? ` style=\"${styleParts.join(';')}\"` : '';\n  const resolved = resolveIconGlyph(glyph);\n  const classes = ['icon-glyph'];\n  if (resolvedClassName) classes.unshift(resolvedClassName);\n  if (resolved.markup) {\n    if (resolved.className) classes.push(resolved.className);\n    const markup = ensureSvgHasAriaHidden(resolved.markup);\n    return `<span class=\"${classes.join(' ')}\"${styleAttr} aria-hidden=\"true\">${markup}</span>`;\n  }\n  const char = resolved.char || '';\n  if (!char) return '';\n  return `<span class=\"${classes.join(' ')}\"${styleAttr} data-icon-font=\"${resolved.font}\" aria-hidden=\"true\">${char}</span>`;\n}\n\nconst HORSE_ICON_SVG = `\n  <svg viewBox=\"0 0 60 60\" xmlns=\"http://www.w3.org/2000/svg\" aria-hidden=\"true\">\n    <path\n      d=\"m1 40c0-8 3-17 3-17a4.84 4.84 0 0 0-1.829-3.064 1 1 0 0 1 .45-1.716 19.438 19.438 0 0 1 4.379-.22c.579-2.317-1.19-3.963-2.782-4.938a1 1 0 0 1 .393-1.85 14.128 14.128 0 0 1 6.389.788c0-.958-1.147-2.145-2.342-3.122a1 1 0 0 1 .708-1.773 40.655 40.655 0 0 1 6.634.895 3.723 3.723 0 0 0-1.049-2.264 1 1 0 0 1 .823-1.652c6.151.378 9.226 1.916 9.226 1.916l10-1s8.472-2.311 15.954.5a1 1 0 0 1-.084 1.9c-1.455.394-2.87 1.143-2.87 2.6 0 0 4.426.738 5.675 4.114a1 1 0 0 1-1.228 1.317c-1.64-.48-4.273-.88-6.447.569Z\"\n      fill=\"#805333\"\n    />\n    <path\n      d=\"m30.18 42.82c1.073 2.7 2.6 9.993 3.357 13.8a2 2 0 0 1-1.964 2.38h-28.573a2 2 0 0 1-2-2v-18c0-2.55 10.03-22.11 23.99-23.87Z\"\n      fill=\"#a56a43\"\n    />\n    <path\n      d=\"m55.67 48.46-6.34 2.97a6 6 0 0 1-7.98-2.88l-.25-.54-.76-1.6a4.956 4.956 0 0 0-4.68-2.87c-.22.01-.44.02-.66.02a16.019 16.019 0 0 1-8.28-29.66c-1.81-2.97-3.45-8.03 2.03-12.49a2.1 2.1 0 0 1 2.5 0c4.23 3.45 4.21 7.25 3.16 10.17a16 16 0 0 1 15.91 11.36l5.31 11.31 2.92 6.22a6.008 6.008 0 0 1-2.88 7.99Z\"\n      fill=\"#cb8252\"\n    />\n    <circle cx=\"42\" cy=\"26\" r=\"3\" fill=\"#2c2f38\" />\n    <circle cx=\"54\" cy=\"43\" r=\"1\" fill=\"#805333\" />\n    <path\n      d=\"m58.55 40.47-2.92-6.22-14.53 13.76.25.54a6 6 0 0 0 7.98 2.88l6.34-2.97a6.008 6.008 0 0 0 2.88-7.99Zm-4.55 3.53a1 1 0 1 1 1-1 1 1 0 0 1-1 1Z\"\n      fill=\"#cf976a\"\n    />\n    <circle cx=\"41\" cy=\"25\" r=\"1.25\" fill=\"#ecf0f1\" />\n  </svg>\n`.trim();\n\nconst PINK_MODE_ICON_FILES = Object.freeze([\n  'src/illustrations/unicorns/unicorn.svg',\n  'src/illustrations/unicorns/unicorn-2.svg',\n  'src/illustrations/unicorns/celebrate.svg',\n  'src/illustrations/unicorns/sunglasses.svg',\n  'src/illustrations/unicorns/toy.svg'\n]);\n\nfunction createPinkModeIconImageMarkup(path) {\n  if (typeof path !== 'string' || !path) {\n    return '';\n  }\n  const safePath = escapeHtml(path);\n  return `<img src=\"${safePath}\" alt=\"\" loading=\"lazy\" decoding=\"async\" aria-hidden=\"true\" class=\"pink-mode-icon-image\">`;\n}\n\nconst PINK_MODE_ICON_FALLBACK_MARKUP = Object.freeze(\n  PINK_MODE_ICON_FILES.map(createPinkModeIconImageMarkup).filter(Boolean)\n);\n\nconst PINK_MODE_ANIMATED_ICON_FILES = Object.freeze([\n  'src/animations/cat.json',\n  'src/animations/cup.json',\n  'src/animations/cupcake.json',\n  'src/animations/flamingo.json',\n  'src/animations/float.json',\n  'src/animations/float-2.json',\n  'src/animations/fox.json',\n  'src/animations/heart.json',\n  'src/animations/horn.json',\n  'src/animations/invitation.json',\n  'src/animations/mask.json',\n  'src/animations/rainbow.json',\n  'src/animations/rocking-horse.json',\n  'src/animations/slippers.json',\n  'src/animations/sunglasses.json',\n  'src/animations/unicorn.json',\n  'animated icons 3/camera.json',\n  'animated icons 3/director-chair.json',\n  'animated icons 3/dog.json',\n  'animated icons 3/fox.json',\n  'animated icons 3/fox-2.json',\n  'animated icons 3/fox-3.json',\n  'animated icons 3/horse.json',\n  'animated icons 3/mountains.json',\n  'animated icons 3/movie-camera.json',\n  'animated icons 3/pinata.json',\n  'animated icons 3/script.json',\n  'animated icons 3/video-camera.json'\n]);\n\nconst pinkModeIcons = {\n  off: Object.freeze({\n    className: 'icon-svg pink-mode-icon',\n    markup: HORSE_ICON_SVG\n  }),\n  onSequence: Object.freeze([])\n};\n\nlet pinkModeIconRotationTimer = null;\nlet pinkModeIconIndex = 0;\n\nconst PINK_MODE_ANIMATED_ICON_MIN_INTERVAL_MS = 14800;\nconst PINK_MODE_ANIMATED_ICON_MAX_INTERVAL_MS = 23800;\nconst PINK_MODE_ANIMATED_ICON_MIN_DURATION_MS = 6400;\nconst PINK_MODE_ANIMATED_ICON_MAX_DURATION_MS = 10800;\nconst PINK_MODE_ANIMATED_ICON_MIN_SIZE_PX = 72;\nconst PINK_MODE_ANIMATED_ICON_MAX_SIZE_PX = 72;\nconst PINK_MODE_ANIMATED_ICON_MAX_ACTIVE = 4;\nconst PINK_MODE_ANIMATED_ICON_MAX_PLACEMENT_ATTEMPTS = 12;\nconst PINK_MODE_ANIMATED_ICON_AVOID_MARGIN_PX = 28;\nconst PINK_MODE_ANIMATED_ICON_MIN_SCALE = 0.65;\nconst PINK_MODE_ANIMATED_ICON_FULL_SIZE_VIEWPORT_MIN = 920;\nconst PINK_MODE_ANIMATED_ICON_AVOID_SELECTOR =\n  'a, button, input, select, textarea, label, summary, h1, h2, h3, h4, h5, h6, p, li, td, th, [role=\"button\"], [role=\"link\"], [role=\"menu\"], [role=\"dialog\"], [role=\"listbox\"], [role=\"combobox\"], [role=\"textbox\"], [contenteditable=\"true\"], .form-row, .form-row-actions, .form-actions';\nconst PINK_MODE_ANIMATED_ICON_PROBE_POINTS = Object.freeze([\n  Object.freeze({ x: 0, y: 0 }),\n  Object.freeze({ x: 0.35, y: 0 }),\n  Object.freeze({ x: -0.35, y: 0 }),\n  Object.freeze({ x: 0, y: 0.35 }),\n  Object.freeze({ x: 0, y: -0.35 }),\n  Object.freeze({ x: 0.25, y: 0.25 }),\n  Object.freeze({ x: -0.25, y: 0.25 }),\n  Object.freeze({ x: 0.25, y: -0.25 }),\n  Object.freeze({ x: -0.25, y: -0.25 })\n]);\n\nlet pinkModeAnimatedIconLayer = null;\nlet pinkModeAnimatedIconTimeoutId = null;\nlet pinkModeAnimatedIconsActive = false;\nlet pinkModeAnimatedIconTemplates = null;\nlet pinkModeAnimatedIconTemplatesPromise = null;\nconst pinkModeAnimatedIconInstances = new Set();\nlet pinkModeAnimatedIconLastTemplateName = null;\n\nconst pinkModeReduceMotionQuery =\n  typeof window !== 'undefined' && typeof window.matchMedia === 'function'\n    ? window.matchMedia('(prefers-reduced-motion: reduce)')\n    : null;\n\nfunction ensureSvgHasAriaHidden(markup) {\n  if (typeof markup !== 'string') return '';\n  const trimmed = markup.trim();\n  if (!trimmed) return '';\n  if (!/^<svg\\b/i.test(trimmed)) return trimmed;\n  if (/\\baria-hidden\\s*=\\s*['\"]/i.test(trimmed)) return trimmed;\n  return trimmed.replace(/<svg\\b/i, match => `${match} aria-hidden=\"true\"`);\n}\n\nfunction setPinkModeIconSequence(markupList) {\n  if (!Array.isArray(markupList) || !markupList.length) {\n    return false;\n  }\n  const configs = markupList\n    .map(ensureSvgHasAriaHidden)\n    .filter(Boolean)\n    .map(markup =>\n      Object.freeze({\n        className: 'icon-svg pink-mode-icon',\n        markup\n      })\n    );\n  if (!configs.length) {\n    return false;\n  }\n  pinkModeIcons.onSequence = Object.freeze(configs);\n  if (\n    typeof document !== 'undefined' &&\n    document.body &&\n    document.body.classList.contains('pink-mode')\n  ) {\n    stopPinkModeIconRotation();\n    pinkModeIconIndex = 0;\n    applyPinkModeIcon(pinkModeIcons.onSequence[pinkModeIconIndex], { animate: false });\n    startPinkModeIconRotation();\n  }\n  return true;\n}\n\nasync function loadPinkModeIconsFromFiles() {\n  if (typeof fetch !== 'function') {\n    return;\n  }\n  const responses = await Promise.all(\n    PINK_MODE_ICON_FILES.map(path =>\n      fetch(path)\n        .then(response => (response.ok ? response.text() : null))\n        .catch(() => null)\n    )\n  );\n  const markupList = responses.filter(Boolean);\n  if (markupList.length) {\n    setPinkModeIconSequence(markupList);\n  }\n}\n\nasync function loadPinkModeAnimatedIconTemplates() {\n  if (pinkModeAnimatedIconTemplates) {\n    return pinkModeAnimatedIconTemplates;\n  }\n  if (pinkModeAnimatedIconTemplatesPromise) {\n    return pinkModeAnimatedIconTemplatesPromise;\n  }\n  if (typeof fetch !== 'function') {\n    pinkModeAnimatedIconTemplates = Object.freeze([]);\n    return pinkModeAnimatedIconTemplates;\n  }\n  pinkModeAnimatedIconTemplatesPromise = Promise.all(\n    PINK_MODE_ANIMATED_ICON_FILES.map(path =>\n      fetch(path)\n        .then(response => (response.ok ? response.text() : null))\n        .catch(() => null)\n    )\n  )\n    .then(contents =>\n      Object.freeze(\n        contents\n          .map((content, index) =>\n            content\n              ? Object.freeze({\n                  name: PINK_MODE_ANIMATED_ICON_FILES[index],\n                  data: content\n                })\n              : null\n          )\n          .filter(Boolean)\n      )\n    )\n    .catch(error => {\n      console.warn('Could not load pink mode animated icons', error);\n      return Object.freeze([]);\n    })\n    .then(templates => {\n      pinkModeAnimatedIconTemplates = templates;\n      return templates;\n    });\n  return pinkModeAnimatedIconTemplatesPromise;\n}\n\nfunction ensurePinkModeAnimationLayer() {\n  if (!document) {\n    return null;\n  }\n  const host = document.getElementById('mainContent') || document.body;\n  if (!host) {\n    return null;\n  }\n  if (\n    pinkModeAnimatedIconLayer &&\n    pinkModeAnimatedIconLayer.isConnected &&\n    host.contains(pinkModeAnimatedIconLayer)\n  ) {\n    return pinkModeAnimatedIconLayer;\n  }\n  if (pinkModeAnimatedIconLayer && pinkModeAnimatedIconLayer.parentNode) {\n    pinkModeAnimatedIconLayer.parentNode.removeChild(pinkModeAnimatedIconLayer);\n  }\n  const layer = document.createElement('div');\n  layer.className = 'pink-mode-animation-layer';\n  layer.setAttribute('aria-hidden', 'true');\n  host.appendChild(layer);\n  pinkModeAnimatedIconLayer = layer;\n  return layer;\n}\n\nfunction computePinkModeAnimationAvoidRegions(layer) {\n  if (\n    typeof document === 'undefined' ||\n    typeof document.querySelectorAll !== 'function'\n  ) {\n    return Object.freeze([]);\n  }\n  const elements = document.querySelectorAll(PINK_MODE_ANIMATED_ICON_AVOID_SELECTOR);\n  if (!elements || !elements.length) {\n    return Object.freeze([]);\n  }\n  const regions = [];\n  for (const element of elements) {\n    if (!element) {\n      continue;\n    }\n    if (layer && layer.contains(element)) {\n      continue;\n    }\n    if (typeof element.getBoundingClientRect !== 'function') {\n      continue;\n    }\n    const rect = element.getBoundingClientRect();\n    if (!rect) {\n      continue;\n    }\n    const { width, height, left, right, top, bottom } = rect;\n    if (!Number.isFinite(width) || !Number.isFinite(height)) {\n      continue;\n    }\n    if (width <= 0 || height <= 0) {\n      continue;\n    }\n    const margin = Math.max(\n      PINK_MODE_ANIMATED_ICON_AVOID_MARGIN_PX,\n      Math.min(width, height) * 0.3\n    );\n    regions.push({ left, right, top, bottom, margin });\n  }\n  return Object.freeze(regions);\n}\n\nfunction collectPinkModeAnimationInstanceRegions(layer) {\n  if (!pinkModeAnimatedIconInstances.size) {\n    return Object.freeze([]);\n  }\n  const regions = [];\n  for (const instance of pinkModeAnimatedIconInstances) {\n    if (!instance || !instance.container) {\n      continue;\n    }\n    const node = instance.container;\n    if (!node.isConnected) {\n      continue;\n    }\n    if (layer && node.parentNode && layer !== node.parentNode && !layer.contains(node)) {\n      continue;\n    }\n    if (typeof node.getBoundingClientRect !== 'function') {\n      continue;\n    }\n    const rect = node.getBoundingClientRect();\n    if (!rect) {\n      continue;\n    }\n    const { left, right, top, bottom, width, height } = rect;\n    if (!Number.isFinite(width) || !Number.isFinite(height)) {\n      continue;\n    }\n    if (width <= 0 || height <= 0) {\n      continue;\n    }\n    const largestSide = Math.max(width, height);\n    regions.push({\n      left,\n      right,\n      top,\n      bottom,\n      margin: Math.max(PINK_MODE_ANIMATED_ICON_AVOID_MARGIN_PX * 1.25, largestSide * 0.6)\n    });\n  }\n  return Object.freeze(regions);\n}\n\nfunction isPinkModeAnimationSpotClear(layer, hostRect, x, y, size, avoidRegions) {\n  if (\n    typeof document === 'undefined' ||\n    typeof document.elementFromPoint !== 'function'\n  ) {\n    return true;\n  }\n  const viewportWidth =\n    typeof window !== 'undefined' && typeof window.innerWidth === 'number'\n      ? window.innerWidth\n      : document.documentElement && typeof document.documentElement.clientWidth === 'number'\n        ? document.documentElement.clientWidth\n        : null;\n  const viewportHeight =\n    typeof window !== 'undefined' && typeof window.innerHeight === 'number'\n      ? window.innerHeight\n      : document.documentElement && typeof document.documentElement.clientHeight === 'number'\n        ? document.documentElement.clientHeight\n        : null;\n  const baseX = (hostRect ? hostRect.left : 0) + x;\n  const baseY = (hostRect ? hostRect.top : 0) + y;\n  const candidate = {\n    left: baseX - size / 2,\n    right: baseX + size / 2,\n    top: baseY - size / 2,\n    bottom: baseY + size / 2\n  };\n\n  if (Array.isArray(avoidRegions) && avoidRegions.length) {\n    for (const region of avoidRegions) {\n      if (!region) {\n        continue;\n      }\n      const regionMargin =\n        typeof region.margin === 'number'\n          ? Math.max(\n              PINK_MODE_ANIMATED_ICON_AVOID_MARGIN_PX,\n              size * 0.25,\n              region.margin\n            )\n          : Math.max(PINK_MODE_ANIMATED_ICON_AVOID_MARGIN_PX, size * 0.25);\n      if (\n        candidate.left < region.right + regionMargin &&\n        candidate.right > region.left - regionMargin &&\n        candidate.top < region.bottom + regionMargin &&\n        candidate.bottom > region.top - regionMargin\n      ) {\n        return false;\n      }\n    }\n  }\n\n  for (const point of PINK_MODE_ANIMATED_ICON_PROBE_POINTS) {\n    const sampleX = baseX + point.x * size;\n    const sampleY = baseY + point.y * size;\n    if (\n      viewportWidth !== null && (sampleX < 0 || sampleX > viewportWidth)\n    ) {\n      continue;\n    }\n    if (\n      viewportHeight !== null && (sampleY < 0 || sampleY > viewportHeight)\n    ) {\n      continue;\n    }\n    const elementsAtPoint =\n      typeof document.elementsFromPoint === 'function'\n        ? document.elementsFromPoint(sampleX, sampleY)\n        : [document.elementFromPoint(sampleX, sampleY)].filter(Boolean);\n    for (const element of elementsAtPoint) {\n      if (!element) {\n        continue;\n      }\n      if (layer && element === layer) {\n        continue;\n      }\n      if (layer && layer.contains(element)) {\n        return false;\n      }\n      if (\n        (typeof element.matches === 'function' && element.matches(PINK_MODE_ANIMATED_ICON_AVOID_SELECTOR)) ||\n        (typeof element.closest === 'function' && element.closest(PINK_MODE_ANIMATED_ICON_AVOID_SELECTOR))\n      ) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\nfunction findPinkModeAnimationPlacement({\n  layer,\n  hostRect,\n  hostTop,\n  visibleTop,\n  visibleBottom,\n  horizontalPadding,\n  verticalPadding,\n  hostWidth,\n  size,\n  avoidRegions\n}) {\n  const minY = Math.max(visibleTop - hostTop + verticalPadding, verticalPadding);\n  const maxY = Math.max(visibleBottom - hostTop - verticalPadding, minY);\n  const minX = horizontalPadding;\n  const maxX = Math.max(hostWidth - horizontalPadding, minX);\n\n  for (let attempt = 0; attempt < PINK_MODE_ANIMATED_ICON_MAX_PLACEMENT_ATTEMPTS; attempt += 1) {\n    const y = maxY > minY ? minY + Math.random() * (maxY - minY) : minY;\n    const x = maxX > minX ? minX + Math.random() * (maxX - minX) : minX;\n    if (isPinkModeAnimationSpotClear(layer, hostRect, x, y, size, avoidRegions)) {\n      return { x, y };\n    }\n  }\n  return null;\n}\n\nfunction destroyPinkModeAnimatedIconInstance(instance) {\n  if (!instance || instance.destroyed) {\n    return;\n  }\n  instance.destroyed = true;\n  if (instance.animation && typeof instance.animation.destroy === 'function') {\n    try {\n      instance.animation.destroy();\n    } catch (error) {\n      console.warn('Could not dispose pink mode animation', error);\n    }\n  }\n  if (instance.container && instance.container.parentNode) {\n    instance.container.parentNode.removeChild(instance.container);\n  }\n  pinkModeAnimatedIconInstances.delete(instance);\n}\n\nfunction spawnPinkModeAnimatedIconInstance(templates) {\n  if (\n    !pinkModeAnimatedIconsActive ||\n    !Array.isArray(templates) ||\n    !templates.length ||\n    typeof window === 'undefined' ||\n    !window.lottie ||\n    typeof window.lottie.loadAnimation !== 'function'\n  ) {\n    return false;\n  }\n  const layer = ensurePinkModeAnimationLayer();\n  if (!layer) {\n    return false;\n  }\n  const sanitizedTemplates = templates.filter(Boolean);\n  if (!sanitizedTemplates.length) {\n    return false;\n  }\n\n  const activeTemplateNames = new Set();\n  for (const instance of pinkModeAnimatedIconInstances) {\n    if (!instance) {\n      continue;\n    }\n    const templateName =\n      typeof instance.templateName === 'string' && instance.templateName\n        ? instance.templateName\n        : null;\n    if (templateName) {\n      activeTemplateNames.add(templateName);\n    }\n  }\n\n  let availableTemplates = sanitizedTemplates.filter(template => {\n    if (!template || typeof template.name !== 'string') {\n      return true;\n    }\n    return !activeTemplateNames.has(template.name);\n  });\n\n  if (!availableTemplates.length) {\n    return false;\n  }\n\n  if (availableTemplates.length > 1 && pinkModeAnimatedIconLastTemplateName) {\n    const filteredTemplates = availableTemplates.filter(\n      template => template && template.name !== pinkModeAnimatedIconLastTemplateName\n    );\n    if (filteredTemplates.length) {\n      availableTemplates = filteredTemplates;\n    }\n  }\n\n  const template =\n    availableTemplates[Math.floor(Math.random() * availableTemplates.length)];\n  if (!template || !template.data) {\n    return false;\n  }\n  const container = document.createElement('div');\n  container.className = 'pink-mode-animation-instance';\n  container.setAttribute('aria-hidden', 'true');\n  const duration = Math.round(\n    Math.random() * (PINK_MODE_ANIMATED_ICON_MAX_DURATION_MS - PINK_MODE_ANIMATED_ICON_MIN_DURATION_MS) +\n      PINK_MODE_ANIMATED_ICON_MIN_DURATION_MS\n  );\n  const baseSize =\n    Math.random() * (PINK_MODE_ANIMATED_ICON_MAX_SIZE_PX - PINK_MODE_ANIMATED_ICON_MIN_SIZE_PX) +\n    PINK_MODE_ANIMATED_ICON_MIN_SIZE_PX;\n  const viewportWidth =\n    typeof window !== 'undefined' && typeof window.innerWidth === 'number'\n      ? window.innerWidth\n      : document.documentElement && typeof document.documentElement.clientWidth === 'number'\n        ? document.documentElement.clientWidth\n        : null;\n  const viewportScale =\n    viewportWidth && viewportWidth < PINK_MODE_ANIMATED_ICON_FULL_SIZE_VIEWPORT_MIN\n      ? Math.max(\n          PINK_MODE_ANIMATED_ICON_MIN_SCALE,\n          viewportWidth / PINK_MODE_ANIMATED_ICON_FULL_SIZE_VIEWPORT_MIN\n        )\n      : 1;\n  const size = Math.max(\n    Math.round(baseSize * viewportScale),\n    Math.round(PINK_MODE_ANIMATED_ICON_MIN_SIZE_PX * PINK_MODE_ANIMATED_ICON_MIN_SCALE)\n  );\n  const host = layer.parentElement || document.body;\n  const viewportHeight =\n    typeof window !== 'undefined' && window.innerHeight\n      ? window.innerHeight\n      : document.documentElement && document.documentElement.clientHeight\n        ? document.documentElement.clientHeight\n        : size * 4;\n  const viewportTop =\n    typeof window !== 'undefined' && typeof window.scrollY === 'number'\n      ? window.scrollY\n      : document.documentElement && typeof document.documentElement.scrollTop === 'number'\n        ? document.documentElement.scrollTop\n        : 0;\n  const viewportBottom = viewportTop + viewportHeight;\n  const hostRect = host ? host.getBoundingClientRect() : null;\n  const hostTop = hostRect ? hostRect.top + viewportTop : 0;\n  const hostHeight =\n    host && typeof host.scrollHeight === 'number' && host.scrollHeight > 0\n      ? host.scrollHeight\n      : hostRect && hostRect.height\n        ? hostRect.height\n        : viewportHeight;\n  const hostBottom = hostTop + hostHeight;\n  let visibleTop = Math.max(hostTop, viewportTop);\n  let visibleBottom = Math.min(hostBottom, viewportBottom);\n  if (visibleBottom <= visibleTop) {\n    visibleTop = hostTop;\n    visibleBottom = hostBottom;\n  }\n  const hostWidth =\n    host && typeof host.clientWidth === 'number' && host.clientWidth > 0\n      ? host.clientWidth\n      : viewportWidth || size * 4;\n  const safeHorizontalRange = Math.max(hostWidth, size * 3);\n  const safeVerticalRange = Math.max(hostHeight, size * 3);\n  const horizontalPadding = Math.min(\n    Math.max(size * 0.6 + 48, 48),\n    safeHorizontalRange / 2\n  );\n  const verticalPadding = Math.min(\n    Math.max(size * 0.6 + 64, 64),\n    safeVerticalRange / 2\n  );\n  const avoidRegions = [\n    ...computePinkModeAnimationAvoidRegions(layer),\n    ...collectPinkModeAnimationInstanceRegions(layer)\n  ];\n  const placement = findPinkModeAnimationPlacement({\n    layer,\n    hostRect,\n    hostTop,\n    visibleTop,\n    visibleBottom,\n    horizontalPadding,\n    verticalPadding,\n    hostWidth,\n    size,\n    avoidRegions\n  });\n  if (!placement) {\n    if (container.parentNode) {\n      container.parentNode.removeChild(container);\n    }\n    return false;\n  }\n  const { x, y } = placement;\n  container.style.setProperty('--pink-mode-animation-duration', `${duration}ms`);\n  container.style.setProperty('--pink-mode-animation-size', `${size}px`);\n  container.style.setProperty('--pink-mode-animation-x', `${x}px`);\n  container.style.setProperty('--pink-mode-animation-y', `${y}px`);\n  layer.appendChild(container);\n\n  let animationData;\n  try {\n    animationData = JSON.parse(template.data);\n  } catch (error) {\n    console.warn('Could not parse pink mode animation', error);\n    if (container.parentNode) {\n      container.parentNode.removeChild(container);\n    }\n    return false;\n  }\n\n  let animationInstance;\n  try {\n    animationInstance = window.lottie.loadAnimation({\n      container,\n      renderer: 'svg',\n      loop: true,\n      autoplay: true,\n      animationData\n    });\n  } catch (error) {\n    console.warn('Could not start pink mode animation', error);\n    if (container.parentNode) {\n      container.parentNode.removeChild(container);\n    }\n    return false;\n  }\n\n  const instance = {\n    container,\n    animation: animationInstance,\n    destroyed: false,\n    templateName: typeof template.name === 'string' ? template.name : null\n  };\n\n  container.addEventListener(\n    'animationend',\n    () => {\n      destroyPinkModeAnimatedIconInstance(instance);\n    },\n    { once: true }\n  );\n\n  pinkModeAnimatedIconInstances.add(instance);\n  if (pinkModeAnimatedIconInstances.size > PINK_MODE_ANIMATED_ICON_MAX_ACTIVE) {\n    const oldest = pinkModeAnimatedIconInstances.values().next().value;\n    if (oldest && oldest !== instance) {\n      destroyPinkModeAnimatedIconInstance(oldest);\n    }\n  }\n\n  pinkModeAnimatedIconLastTemplateName = typeof template.name === 'string' ? template.name : null;\n\n  return true;\n}\n\nfunction scheduleNextPinkModeAnimatedIcon(templates) {\n  if (!pinkModeAnimatedIconsActive) {\n    return;\n  }\n  const delay = Math.round(\n    Math.random() * (PINK_MODE_ANIMATED_ICON_MAX_INTERVAL_MS - PINK_MODE_ANIMATED_ICON_MIN_INTERVAL_MS) +\n      PINK_MODE_ANIMATED_ICON_MIN_INTERVAL_MS\n  );\n  pinkModeAnimatedIconTimeoutId = window.setTimeout(() => {\n    pinkModeAnimatedIconTimeoutId = null;\n    if (!pinkModeAnimatedIconsActive) {\n      return;\n    }\n    spawnPinkModeAnimatedIconInstance(templates);\n    if (pinkModeAnimatedIconsActive) {\n      scheduleNextPinkModeAnimatedIcon(templates);\n    }\n  }, delay);\n}\n\nfunction startPinkModeAnimatedIcons() {\n  if (pinkModeAnimatedIconsActive) {\n    return;\n  }\n  if (!document || !document.body) {\n    return;\n  }\n  if (pinkModeReduceMotionQuery && pinkModeReduceMotionQuery.matches) {\n    return;\n  }\n  if (\n    typeof window === 'undefined' ||\n    !window.lottie ||\n    typeof window.lottie.loadAnimation !== 'function'\n  ) {\n    return;\n  }\n  pinkModeAnimatedIconsActive = true;\n  loadPinkModeAnimatedIconTemplates()\n    .then(templates => {\n      if (!pinkModeAnimatedIconsActive) {\n        return templates;\n      }\n      if (!templates.length) {\n        stopPinkModeAnimatedIcons();\n        return templates;\n      }\n      spawnPinkModeAnimatedIconInstance(templates);\n      scheduleNextPinkModeAnimatedIcon(templates);\n      return templates;\n    })\n    .catch(error => {\n      console.warn('Could not prepare pink mode animated icons', error);\n      stopPinkModeAnimatedIcons();\n    });\n}\n\nfunction stopPinkModeAnimatedIcons() {\n  pinkModeAnimatedIconsActive = false;\n  if (pinkModeAnimatedIconTimeoutId) {\n    clearTimeout(pinkModeAnimatedIconTimeoutId);\n    pinkModeAnimatedIconTimeoutId = null;\n  }\n  if (pinkModeAnimatedIconInstances.size) {\n    Array.from(pinkModeAnimatedIconInstances).forEach(instance => {\n      destroyPinkModeAnimatedIconInstance(instance);\n    });\n    pinkModeAnimatedIconInstances.clear();\n  }\n  if (pinkModeAnimatedIconLayer && pinkModeAnimatedIconLayer.parentNode) {\n    pinkModeAnimatedIconLayer.parentNode.removeChild(pinkModeAnimatedIconLayer);\n  }\n  pinkModeAnimatedIconLayer = null;\n  pinkModeAnimatedIconLastTemplateName = null;\n}\n\nif (pinkModeReduceMotionQuery) {\n  const handlePinkModeReduceMotionChange = event => {\n    if (event.matches) {\n      stopPinkModeAnimatedIcons();\n    } else if (document.body && document.body.classList.contains('pink-mode')) {\n      startPinkModeAnimatedIcons();\n    }\n  };\n  if (typeof pinkModeReduceMotionQuery.addEventListener === 'function') {\n    pinkModeReduceMotionQuery.addEventListener('change', handlePinkModeReduceMotionChange);\n  } else if (typeof pinkModeReduceMotionQuery.addListener === 'function') {\n    pinkModeReduceMotionQuery.addListener(handlePinkModeReduceMotionChange);\n  }\n}\n\nconst PINK_MODE_ICON_INTERVAL_MS = 30000;\nconst PINK_MODE_ICON_ANIMATION_CLASS = 'pink-mode-icon-pop';\nconst PINK_MODE_ICON_ANIMATION_RESET_DELAY = 450;\n\nconst projectFieldIcons = {\n  productionCompany: PRODUCTION_COMPANY_ICON,\n  rentalHouse: RENTAL_HOUSE_ICON,\n  crew: iconGlyph('\\uF404', ICON_FONT_KEYS.UICONS),\n  prepDays: iconGlyph('\\uE312', ICON_FONT_KEYS.UICONS),\n  shootingDays: iconGlyph('\\uE311', ICON_FONT_KEYS.UICONS),\n  deliveryResolution: iconGlyph('\\uEF69', ICON_FONT_KEYS.UICONS),\n  recordingResolution: ICON_GLYPHS.camera,\n  aspectRatio: ASPECT_RATIO_ICON,\n  codec: ICON_GLYPHS.codec,\n  baseFrameRate: iconGlyph('\\uE46F', ICON_FONT_KEYS.UICONS),\n  sensorMode: ICON_GLYPHS.sensor,\n  requiredScenarios: REQUIRED_SCENARIOS_ICON,\n  lenses: iconGlyph('\\uE0A3', ICON_FONT_KEYS.UICONS),\n  cameraHandle: iconGlyph('\\uF2DC', ICON_FONT_KEYS.UICONS),\n  viewfinderExtension: iconGlyph('\\uE338', ICON_FONT_KEYS.UICONS),\n  gimbal: iconGlyph('\\uEA9C', ICON_FONT_KEYS.UICONS),\n  monitoringSupport: MONITORING_SUPPORT_ICON,\n  monitoringConfiguration: iconGlyph('\\uF0D0', ICON_FONT_KEYS.UICONS),\n  monitorUserButtons: iconGlyph('\\uF0D1', ICON_FONT_KEYS.UICONS),\n  cameraUserButtons: iconGlyph('\\uF0D1', ICON_FONT_KEYS.UICONS),\n  viewfinderUserButtons: iconGlyph('\\uF0D1', ICON_FONT_KEYS.UICONS)\n};\n\nfunction updateSelectIconBoxes(sel) {\n  if (!sel) return;\n  let container = sel.parentNode.querySelector('.icon-box-summary');\n  if (!container) {\n    container = document.createElement('div');\n    container.className = 'icon-box-summary';\n    sel.parentNode.insertBefore(container, sel.nextSibling);\n  }\n  container.innerHTML = '';\n  const opts = sel.multiple\n    ? Array.from(sel.selectedOptions)\n    : (sel.value ? [sel.options[sel.selectedIndex]] : []);\n  opts.forEach(opt => {\n    const box = document.createElement('span');\n    box.className = 'icon-box';\n    const iconSpan = document.createElement('span');\n    iconSpan.className = 'icon icon-glyph';\n    let glyph = projectFieldIcons[sel.name] || ICON_GLYPHS.pin;\n    if (opt.dataset.icon) {\n      glyph = iconGlyph(opt.dataset.icon, opt.dataset.iconFont || ICON_FONT_KEYS.UICONS);\n    }\n    applyIconGlyph(iconSpan, glyph);\n    box.appendChild(iconSpan);\n    box.appendChild(document.createTextNode(opt.value));\n    container.appendChild(box);\n  });\n}\n\nfunction setButtonLabelWithIcon(button, label, glyph = ICON_GLYPHS.save) {\n  if (!button) return;\n  const safeLabel = typeof label === 'string' ? escapeHtml(label) : '';\n  const iconHtml = iconMarkup(glyph, 'btn-icon');\n  button.innerHTML = `${iconHtml}${safeLabel}`;\n}\n\nfunction getLocalizedPathText(path, fallback = '') {\n  if (!path) return fallback;\n  const keys = Array.isArray(path) ? path : typeof path === 'string' ? [path] : [];\n  if (!keys.length) return fallback;\n  const langTexts = (texts && texts[currentLang]) || {};\n  const fallbackTexts = (texts && texts.en) || {};\n  const resolve = (source) => keys.reduce((acc, key) => {\n    if (acc && Object.prototype.hasOwnProperty.call(acc, key)) {\n      return acc[key];\n    }\n    return undefined;\n  }, source);\n  const localized = resolve(langTexts);\n  if (localized !== undefined && localized !== null && localized !== '') {\n    return String(localized);\n  }\n  const fallbackValue = resolve(fallbackTexts);\n  if (fallbackValue !== undefined && fallbackValue !== null && fallbackValue !== '') {\n    return String(fallbackValue);\n  }\n  return fallback;\n}\n\nfunction configureIconOnlyButton(button, glyph, options = {}) {\n  if (!button) return;\n  const {\n    contextPaths = [],\n    fallbackContext = '',\n    actionKey = 'addEntry'\n  } = options || {};\n  setButtonLabelWithIcon(button, '', glyph || ICON_GLYPHS.add);\n  const actionLabel = getLocalizedPathText(['projectForm', actionKey], actionKey === 'removeEntry' ? 'Remove' : 'Add');\n  const paths = Array.isArray(contextPaths) ? contextPaths : [contextPaths];\n  let contextLabel = '';\n  for (const path of paths) {\n    if (!path) continue;\n    const resolved = getLocalizedPathText(path, '');\n    if (resolved) {\n      contextLabel = resolved;\n      break;\n    }\n  }\n  if (!contextLabel && typeof fallbackContext === 'string') {\n    contextLabel = fallbackContext;\n  }\n  const normalizedContext = contextLabel ? contextLabel.replace(/[:\uFF1A]\\s*$/, '').trim() : '';\n  const combinedLabel = [actionLabel, normalizedContext].filter(Boolean).join(' ').trim();\n  if (combinedLabel) {\n    button.setAttribute('aria-label', combinedLabel);\n    button.setAttribute('title', combinedLabel);\n  }\n}\n\nfunction createCrewRow(data = {}) {\n  if (!crewContainer) return;\n  const row = document.createElement('div');\n  row.className = 'person-row';\n  const roleSel = document.createElement('select');\n  crewRoles.forEach(r => {\n    const opt = document.createElement('option');\n    opt.value = r;\n    const roleLabels = texts[currentLang]?.crewRoles || texts.en?.crewRoles || {};\n    opt.textContent = roleLabels[r] || r;\n    roleSel.appendChild(opt);\n  });\n  if (data.role) roleSel.value = data.role;\n  const nameInput = document.createElement('input');\n  nameInput.type = 'text';\n  const fallbackProjectForm = texts.en?.projectForm || {};\n  const projectFormTexts = texts[currentLang]?.projectForm || fallbackProjectForm;\n  nameInput.placeholder = projectFormTexts.crewNamePlaceholder || fallbackProjectForm.crewNamePlaceholder || 'Name';\n  nameInput.className = 'person-name';\n  nameInput.value = data.name || '';\n  const phoneInput = document.createElement('input');\n  phoneInput.type = 'tel';\n  phoneInput.placeholder = projectFormTexts.crewPhonePlaceholder || fallbackProjectForm.crewPhonePlaceholder || 'Phone';\n  phoneInput.className = 'person-phone';\n  phoneInput.value = data.phone || '';\n  const emailInput = document.createElement('input');\n  emailInput.type = 'email';\n  emailInput.placeholder = projectFormTexts.crewEmailPlaceholder || fallbackProjectForm.crewEmailPlaceholder || 'Email';\n  emailInput.className = 'person-email';\n  emailInput.value = data.email || '';\n  const removeBtn = document.createElement('button');\n  removeBtn.type = 'button';\n  const removeBase = texts[currentLang]?.projectForm?.removeEntry\n    || texts.en?.projectForm?.removeEntry\n    || 'Remove';\n  const crewHeading = texts[currentLang]?.projectForm?.crewHeading\n    || texts.en?.projectForm?.crewHeading\n    || 'Crew';\n  const removeCrewLabel = `${removeBase} ${crewHeading}`.trim();\n  removeBtn.innerHTML = iconMarkup(ICON_GLYPHS.minus, 'btn-icon');\n  removeBtn.setAttribute('aria-label', removeCrewLabel);\n  removeBtn.setAttribute('title', removeCrewLabel);\n  removeBtn.setAttribute('data-help', removeCrewLabel);\n  removeBtn.addEventListener('click', () => {\n    row.remove();\n    scheduleProjectAutoSave(true);\n  });\n  row.append(roleSel, nameInput, phoneInput, emailInput, removeBtn);\n  crewContainer.appendChild(row);\n}\n\nfunction createPrepRow(data = {}) {\n  if (!prepContainer) return;\n  const row = document.createElement('div');\n  row.className = 'period-row';\n  const start = document.createElement('input');\n  start.type = 'date';\n  start.className = 'prep-start';\n  start.value = data.start || '';\n  start.setAttribute('aria-labelledby', 'prepLabel');\n  const span = document.createElement('span');\n  span.textContent = 'to';\n  const end = document.createElement('input');\n  end.type = 'date';\n  end.className = 'prep-end';\n  end.value = data.end || '';\n  end.setAttribute('aria-labelledby', 'prepLabel');\n  const removeBtn = document.createElement('button');\n  removeBtn.type = 'button';\n  const removeBase = texts[currentLang]?.projectForm?.removeEntry\n    || texts.en?.projectForm?.removeEntry\n    || 'Remove';\n  const prepLabelText = texts[currentLang]?.projectForm?.prepLabel || texts.en?.projectForm?.prepLabel || 'Prep';\n  const removePrepLabel = `${removeBase} ${prepLabelText}`.trim();\n  removeBtn.innerHTML = iconMarkup(ICON_GLYPHS.minus, 'btn-icon');\n  removeBtn.setAttribute('aria-label', removePrepLabel);\n  removeBtn.setAttribute('title', removePrepLabel);\n  removeBtn.setAttribute('data-help', removePrepLabel);\n  removeBtn.addEventListener('click', () => {\n    row.remove();\n    scheduleProjectAutoSave(true);\n  });\n  row.append(start, span, end, removeBtn);\n  prepContainer.appendChild(row);\n}\n\nfunction createShootRow(data = {}) {\n  if (!shootContainer) return;\n  const row = document.createElement('div');\n  row.className = 'period-row';\n  const start = document.createElement('input');\n  start.type = 'date';\n  start.className = 'shoot-start';\n  start.value = data.start || '';\n  start.setAttribute('aria-labelledby', 'shootLabel');\n  const span = document.createElement('span');\n  span.textContent = 'to';\n  const end = document.createElement('input');\n  end.type = 'date';\n  end.className = 'shoot-end';\n  end.value = data.end || '';\n  end.setAttribute('aria-labelledby', 'shootLabel');\n  const removeBtn = document.createElement('button');\n  removeBtn.type = 'button';\n  const removeBase = texts[currentLang]?.projectForm?.removeEntry\n    || texts.en?.projectForm?.removeEntry\n    || 'Remove';\n  const shootLabelText = texts[currentLang]?.projectForm?.shootLabel || texts.en?.projectForm?.shootLabel || 'Shoot';\n  const removeShootLabel = `${removeBase} ${shootLabelText}`.trim();\n  removeBtn.innerHTML = iconMarkup(ICON_GLYPHS.minus, 'btn-icon');\n  removeBtn.setAttribute('aria-label', removeShootLabel);\n  removeBtn.setAttribute('title', removeShootLabel);\n  removeBtn.setAttribute('data-help', removeShootLabel);\n  removeBtn.addEventListener('click', () => {\n    row.remove();\n    scheduleProjectAutoSave(true);\n  });\n  row.append(start, span, end, removeBtn);\n  shootContainer.appendChild(row);\n}\n\nif (addPersonBtn) {\n  addPersonBtn.addEventListener('click', () => createCrewRow());\n}\nif (addPrepBtn) {\n  addPrepBtn.addEventListener('click', () => createPrepRow());\n}\nif (addShootBtn) {\n  addShootBtn.addEventListener('click', () => createShootRow());\n}\n\nfunction updateTripodOptions() {\n  const headBrand = tripodHeadBrandSelect ? tripodHeadBrandSelect.value : '';\n  const bowl = tripodBowlSelect ? tripodBowlSelect.value : '';\n  const headOpts = tripodHeadBrandSelect ? Array.from(tripodHeadBrandSelect.options) : [];\n  const bowlOpts = tripodBowlSelect ? Array.from(tripodBowlSelect.options) : [];\n  headOpts.forEach(o => { o.hidden = false; });\n  bowlOpts.forEach(o => { o.hidden = false; });\n  if (headBrand === 'OConnor') {\n    const opt = bowlOpts.find(o => o.value === '75mm bowl');\n    if (opt) opt.hidden = true;\n    if (tripodBowlSelect.value === '75mm bowl') tripodBowlSelect.value = '';\n  }\n  if (headBrand === 'Sachtler') {\n    const opt = bowlOpts.find(o => o.value === 'Mitchell Mount');\n    if (opt) opt.hidden = true;\n    if (tripodBowlSelect.value === 'Mitchell Mount') tripodBowlSelect.value = '';\n  }\n  if (bowl === '75mm bowl') {\n    const opt = headOpts.find(o => o.value === 'OConnor');\n    if (opt) opt.hidden = true;\n    if (tripodHeadBrandSelect.value === 'OConnor') tripodHeadBrandSelect.value = '';\n  }\n  if (bowl === 'Mitchell Mount') {\n    const opt = headOpts.find(o => o.value === 'Sachtler');\n    if (opt) opt.hidden = true;\n    if (tripodHeadBrandSelect.value === 'Sachtler') tripodHeadBrandSelect.value = '';\n  }\n}\n\nconst totalPowerElem      = document.getElementById(\"totalPower\");\nconst totalCurrent144Elem = document.getElementById(\"totalCurrent144\");\nconst totalCurrent12Elem  = document.getElementById(\"totalCurrent12\");\nconst batteryLifeElem     = document.getElementById(\"batteryLife\");\nconst batteryLifeLabelElem = document.getElementById(\"batteryLifeLabel\");\nconst runtimeAverageNoteElem = document.getElementById(\"runtimeAverageNote\");\nconst batteryCountElem    = document.getElementById(\"batteryCount\");\nconst pinWarnElem         = document.getElementById(\"pinWarning\");\nconst dtapWarnElem        = document.getElementById(\"dtapWarning\");\nconst hotswapWarnElem     = document.getElementById(\"hotswapWarning\");\nconst powerDiagramElem    = document.getElementById(\"powerDiagram\");\nconst powerDiagramBarElem = document.getElementById(\"powerDiagramBar\");\nconst maxPowerTextElem    = document.getElementById(\"maxPowerText\");\nconst powerDiagramLegendElem = document.getElementById(\"powerDiagramLegend\");\n\nfunction drawPowerDiagram(availableWatt, segments, maxPinA) {\n  if (!powerDiagramElem || !powerDiagramBarElem || !maxPowerTextElem || !powerDiagramLegendElem) return;\n  if (!availableWatt || availableWatt <= 0) {\n    powerDiagramElem.classList.add(\"hidden\");\n    powerDiagramBarElem.innerHTML = \"\";\n    powerDiagramLegendElem.innerHTML = \"\";\n    maxPowerTextElem.textContent = \"\";\n    setStatusLevel(maxPowerTextElem, null);\n    return;\n  }\n  powerDiagramElem.classList.remove(\"hidden\");\n  powerDiagramBarElem.innerHTML = \"\";\n  powerDiagramLegendElem.innerHTML = \"\";\n  const MAX_WIDTH = 300;\n  const total = segments.reduce((sum, s) => sum + s.power, 0);\n  const scale = MAX_WIDTH / Math.max(availableWatt, total);\n  const limitPos = availableWatt * scale;\n\n  segments.forEach(seg => {\n    const width = seg.power * scale;\n    if (width <= 0) return;\n    const div = document.createElement(\"div\");\n    div.className = `segment ${seg.className}`;\n    div.style.width = `${width}px`;\n    div.setAttribute(\"title\", `${seg.label} ${seg.power.toFixed(1)} W`);\n    powerDiagramBarElem.appendChild(div);\n\n    const legendItem = document.createElement(\"span\");\n    const swatch = document.createElement(\"span\");\n    swatch.className = `swatch ${seg.className}`;\n    legendItem.appendChild(swatch);\n    legendItem.appendChild(document.createTextNode(seg.label.replace(/:$/, \"\")));\n    powerDiagramLegendElem.appendChild(legendItem);\n  });\n\n  if (total > availableWatt) {\n    const over = document.createElement(\"div\");\n    over.className = \"over-usage\";\n    over.style.left = `${limitPos}px`;\n    powerDiagramBarElem.appendChild(over);\n  }\n\n  const limit = document.createElement(\"div\");\n  limit.className = \"limit-line\";\n  limit.style.left = `${limitPos}px`;\n  if (typeof maxPinA === 'number' && maxPinA > 0) {\n    const label = document.createElement(\"span\");\n    label.className = \"limit-label\";\n    label.textContent = `${texts[currentLang].pinLabel} ${maxPinA} A`;\n    limit.appendChild(label);\n  }\n  powerDiagramBarElem.appendChild(limit);\n\n  powerDiagramElem.classList.toggle(\"over\", total > availableWatt);\n  maxPowerTextElem.textContent = `${texts[currentLang].availablePowerLabel} ${availableWatt.toFixed(0)} W`;\n  setStatusLevel(maxPowerTextElem, total > availableWatt ? 'danger' : null);\n}\n\nconst setupSelect     = document.getElementById(\"setupSelect\");\nconst setupNameInput  = document.getElementById(\"setupName\");\nconst saveSetupBtn    = document.getElementById(\"saveSetupBtn\");\nconst deleteSetupBtn  = document.getElementById(\"deleteSetupBtn\");\nconst shareSetupBtn   = document.getElementById(\"shareSetupBtn\");\nconst sharedLinkRow   = document.getElementById(\"sharedLinkRow\");\nconst sharedLinkInput = document.getElementById(\"sharedLinkInput\");\nconst shareLinkMessage = document.getElementById(\"shareLinkMessage\");\nconst shareIncludeAutoGearCheckbox = document.getElementById(\"shareIncludeAutoGear\");\n\nfunction sanitizeShareFilename(name) {\n  if (!name) return '';\n  const trimmed = String(name).trim();\n  if (!trimmed) return '';\n  const sanitized = trimmed\n    .replace(/[\\\\/:*?\"<>|]+/g, '_')\n    .replace(/\\s+/g, ' ')\n    .replace(/^\\.+/, '')\n    .replace(/\\.+$/, '')\n    .trim();\n  return sanitized;\n}\n\nfunction ensureJsonExtension(filename) {\n  if (!filename) return '';\n  return /\\.json$/i.test(filename) ? filename : `${filename}.json`;\n}\n\nfunction getDefaultShareFilename(setupName) {\n  const sanitized = sanitizeShareFilename(setupName);\n  return sanitized || 'project';\n}\n\nfunction promptForSharedFilename(setupName) {\n  const defaultName = getDefaultShareFilename(setupName);\n  const template = getLocalizedText('shareFilenamePrompt') || '';\n  const promptMessage = template.includes('{defaultName}')\n    ? template.replace('{defaultName}', defaultName)\n    : template || 'Enter a name for the exported project file:';\n  if (typeof window !== 'undefined' && typeof window.prompt === 'function') {\n    const response = window.prompt(promptMessage, defaultName);\n    if (response === null) {\n      return null;\n    }\n    const sanitized = sanitizeShareFilename(response);\n    if (!sanitized) {\n      const invalidMessage =\n        getLocalizedText('shareFilenameInvalid')\n        || 'Please enter a valid file name to continue.';\n      if (typeof window.alert === 'function') {\n        window.alert(invalidMessage);\n      }\n      return null;\n    }\n    return ensureJsonExtension(sanitized);\n  }\n  return ensureJsonExtension(defaultName);\n}\n\nfunction confirmAutoGearSelection(defaultInclude) {\n  const confirmMessage =\n    getLocalizedText('shareIncludeAutoGearConfirm')\n    || 'Include automatic gear rules in the shared file? Select OK to include them or Cancel to skip.';\n  if (typeof window !== 'undefined' && typeof window.confirm === 'function') {\n    return window.confirm(confirmMessage);\n  }\n  return !!defaultInclude;\n}\nconst shareDialog = document.getElementById(\"shareDialog\");\nconst shareForm = document.getElementById(\"shareForm\");\nconst shareDialogHeadingElem = document.getElementById(\"shareDialogHeading\");\nconst shareFilenameInput = document.getElementById(\"shareFilename\");\nconst shareFilenameLabelElem = document.getElementById(\"shareFilenameLabel\");\nconst shareFilenameMessage = document.getElementById(\"shareFilenameMessage\");\nconst shareCancelBtn = document.getElementById(\"shareCancelBtn\");\nconst shareConfirmBtn = document.getElementById(\"shareConfirmBtn\");\nconst shareIncludeAutoGearText = document.getElementById(\"shareIncludeAutoGearText\");\nconst shareIncludeAutoGearLabelElem = document.getElementById(\"shareIncludeAutoGearLabel\");\nif (shareFilenameInput && shareFilenameMessage) {\n  shareFilenameInput.setAttribute('aria-describedby', 'shareFilenameMessage');\n}\nconst sharedImportDialog = document.getElementById(\"sharedImportDialog\");\nconst sharedImportForm = document.getElementById(\"sharedImportForm\");\nconst sharedImportDialogHeading = document.getElementById(\"sharedImportDialogHeading\");\nconst sharedImportDialogMessage = document.getElementById(\"sharedImportDialogMessage\");\nconst sharedImportOptions = document.getElementById(\"sharedImportOptions\");\nconst sharedImportLegend = document.getElementById(\"sharedImportLegend\");\nconst sharedImportModeSelect = document.getElementById(\"sharedImportModeSelect\");\nconst sharedImportModeNoneOption = document.getElementById(\"sharedImportModeNoneOption\");\nconst sharedImportModeProjectOption = document.getElementById(\"sharedImportModeProjectOption\");\nconst sharedImportModeGlobalOption = document.getElementById(\"sharedImportModeGlobalOption\");\nconst sharedImportConfirmBtn = document.getElementById(\"sharedImportConfirmBtn\");\nconst sharedImportCancelBtn = document.getElementById(\"sharedImportCancelBtn\");\nif (sharedImportModeSelect) {\n  Array.from(sharedImportModeSelect.options || []).forEach(option => {\n    if (option.value === \"none\") return;\n    option.disabled = true;\n  });\n}\nlet sharedImportPromptActive = false;\nlet pendingSharedLinkListener = null;\nlet lastSetupName = setupSelect ? setupSelect.value : '';\nconst applySharedLinkBtn = document.getElementById(\"applySharedLinkBtn\");\nconst sharedKeyMap = {\n  setupName: \"s\",\n  camera: \"c\",\n  monitor: \"m\",\n  video: \"v\",\n  cage: \"g\",\n  motors: \"o\",\n  controllers: \"r\",\n  distance: \"d\",\n  batteryPlate: \"p\",\n  battery: \"b\",\n  batteryHotswap: \"h\",\n  projectInfo: \"i\",\n  projectHtml: \"q\",\n  gearSelectors: \"e\",\n  gearList: \"l\",\n  changedDevices: \"x\",\n  feedback: \"f\",\n  autoGearRules: \"a\"\n};\n\nlet lastSharedSetupData = null;\nlet lastSharedAutoGearRules = null;\nlet sharedImportPreviousPresetId = '';\nlet sharedImportProjectPresetActive = false;\nlet sharedImportPreparedForImport = false;\n\nfunction cloneSharedImportValue(value) {\n  if (value == null) return null;\n  try {\n    return JSON.parse(JSON.stringify(value));\n  } catch (error) {\n    console.warn('Failed to clone shared import value', error);\n    return null;\n  }\n}\n\nfunction storeSharedImportData(data, rules) {\n  lastSharedSetupData = cloneSharedImportValue(data);\n  lastSharedAutoGearRules = cloneSharedImportValue(rules);\n}\n\nfunction clearStoredSharedImportData() {\n  lastSharedSetupData = null;\n  lastSharedAutoGearRules = null;\n  sharedImportPreparedForImport = false;\n}\n\nfunction resetSharedImportStateForFactoryReset() {\n  clearStoredSharedImportData();\n  sharedImportPromptActive = false;\n  if (sharedImportDialog) {\n    closeDialog(sharedImportDialog);\n  }\n  if (typeof configureSharedImportOptions === 'function') {\n    configureSharedImportOptions([]);\n  }\n  if (sharedLinkInput) {\n    if (\n      pendingSharedLinkListener\n      && typeof sharedLinkInput.removeEventListener === 'function'\n    ) {\n      sharedLinkInput.removeEventListener('change', pendingSharedLinkListener);\n    }\n    sharedLinkInput.value = '';\n  }\n  pendingSharedLinkListener = null;\n  sharedImportPreviousPresetId = '';\n  sharedImportProjectPresetActive = false;\n}\n\nfunction deactivateSharedImportProjectPreset() {\n  if (!sharedImportProjectPresetActive) return;\n  const targetPresetId = sharedImportPreviousPresetId || '';\n  setActiveAutoGearPresetId(targetPresetId, { persist: false, skipRender: true });\n  sharedImportProjectPresetActive = false;\n  sharedImportPreviousPresetId = '';\n  renderAutoGearPresetsControls();\n}\n\nfunction activateSharedImportProjectPreset(presetId) {\n  if (!presetId) return;\n  if (!sharedImportProjectPresetActive) {\n    sharedImportPreviousPresetId = activeAutoGearPresetId || '';\n  }\n  sharedImportProjectPresetActive = true;\n  setActiveAutoGearPresetId(presetId, { persist: false, skipRender: true });\n  renderAutoGearPresetsControls();\n}\n\nfunction getSharedImportProjectName(sharedData) {\n  if (!sharedData || typeof sharedData !== 'object') return '';\n  const projectName = sharedData.projectInfo && typeof sharedData.projectInfo.projectName === 'string'\n    ? sharedData.projectInfo.projectName.trim()\n    : '';\n  if (projectName) return projectName;\n  if (typeof sharedData.setupName === 'string') {\n    const normalized = sharedData.setupName.trim();\n    if (normalized) return normalized;\n  }\n  return '';\n}\n\nfunction getSharedImportPresetLabel(sharedData) {\n  const langTexts = texts[currentLang] || texts.en || {};\n  const fallback = langTexts.sharedImportAutoGearPresetFallback\n    || texts.en?.sharedImportAutoGearPresetFallback\n    || 'Shared automatic gear rules';\n  const projectName = getSharedImportProjectName(sharedData);\n  if (!projectName) {\n    return fallback;\n  }\n  const template = langTexts.sharedImportAutoGearPresetName\n    || texts.en?.sharedImportAutoGearPresetName\n    || '%s';\n  if (template.includes('%s')) {\n    return formatWithPlaceholders(template, projectName);\n  }\n  return `${template} ${projectName}`.trim();\n}\n\nfunction ensureSharedAutoGearPreset(rules, sharedData) {\n  const normalizedRules = Array.isArray(rules)\n    ? rules.map(normalizeAutoGearRule).filter(Boolean)\n    : [];\n  if (!normalizedRules.length) return null;\n  const label = getSharedImportPresetLabel(sharedData);\n  const fingerprint = createAutoGearRulesFingerprint(normalizedRules);\n  let preset = autoGearPresets.find(entry => entry.fingerprint === fingerprint) || null;\n  const fallback = texts[currentLang]?.sharedImportAutoGearPresetFallback\n    || texts.en?.sharedImportAutoGearPresetFallback\n    || 'Shared automatic gear rules';\n  if (preset) {\n    if (label && preset.label !== label && preset.label === fallback) {\n      preset = { ...preset, label };\n      autoGearPresets = autoGearPresets.map(entry => (entry.id === preset.id ? preset : entry));\n      autoGearPresets = sortAutoGearPresets(autoGearPresets.slice());\n      persistAutoGearPresets(autoGearPresets);\n      renderAutoGearPresetsControls();\n    }\n    return preset;\n  }\n  const normalizedPreset = normalizeAutoGearPreset({\n    id: generateAutoGearId('preset'),\n    label,\n    rules: normalizedRules,\n  });\n  if (!normalizedPreset) return null;\n  autoGearPresets.push(normalizedPreset);\n  autoGearPresets = sortAutoGearPresets(autoGearPresets.slice());\n  persistAutoGearPresets(autoGearPresets);\n  if (autoGearAutoPresetId) {\n    setAutoGearAutoPresetId('', { persist: true, skipRender: true });\n  }\n  renderAutoGearPresetsControls();\n  return normalizedPreset;\n}\n\nfunction configureSharedImportOptions(sharedRules) {\n  if (!sharedImportModeSelect) {\n    return Array.isArray(sharedRules) && sharedRules.length > 0;\n  }\n  const hasRules = Array.isArray(sharedRules) && sharedRules.length > 0;\n  const options = Array.from(sharedImportModeSelect.options || []);\n  options.forEach(option => {\n    if (option.value === 'none') {\n      option.disabled = false;\n      option.selected = !hasRules;\n    } else {\n      option.disabled = !hasRules;\n      option.selected = hasRules && option.value === 'project';\n    }\n  });\n  return hasRules;\n}\n\nfunction sharedImportRulesDiffer(sharedRules) {\n  if (!Array.isArray(sharedRules) || !sharedRules.length) return false;\n  if (typeof getAutoGearRules !== 'function') return true;\n  try {\n    const currentRules = getAutoGearRules();\n    return stableStringify(sharedRules) !== stableStringify(currentRules || []);\n  } catch (error) {\n    console.warn('Failed to compare automatic gear rules', error);\n    return true;\n  }\n}\n\nfunction applyStoredSharedImport() {\n  if (lastSharedSetupData === null) return;\n  reapplySharedImportSelection();\n}\n\nfunction finalizeSharedImportPrompt() {\n  sharedImportPromptActive = false;\n  if (sharedImportDialog) closeDialog(sharedImportDialog);\n}\n\nfunction openSharedImportPrompt() {\n  if (!sharedImportDialog) return;\n  sharedImportPromptActive = true;\n  openDialog(sharedImportDialog);\n  const focusTarget = sharedImportModeSelect || sharedImportConfirmBtn || sharedImportCancelBtn;\n  if (focusTarget && typeof focusTarget.focus === 'function') {\n    focusTarget.focus();\n  }\n}\n\nfunction processSharedProjectData(data) {\n  try {\n    sharedImportPromptActive = false;\n    const parsed = typeof data === 'string' ? JSON.parse(data) : data;\n    const sharedRules = Array.isArray(parsed.autoGearRules) ? parsed.autoGearRules : null;\n    sharedImportPreparedForImport = false;\n    prepareSharedImportContext();\n    storeSharedImportData(parsed, sharedRules);\n    const hasRules = configureSharedImportOptions(sharedRules);\n    const shouldPrompt = hasRules && sharedImportRulesDiffer(sharedRules) && !!sharedImportDialog;\n    if (shouldPrompt) {\n      openSharedImportPrompt();\n      return;\n    }\n    applyStoredSharedImport();\n  } catch (error) {\n    clearStoredSharedImportData();\n    console.error('Failed to parse shared project', error);\n    alert(texts[currentLang].invalidSharedLink);\n  }\n}\n\nfunction readSharedProjectFile(file) {\n  if (!file) return;\n  const reader = new FileReader();\n  reader.onload = () => {\n    processSharedProjectData(reader.result);\n  };\n  reader.onerror = () => {\n    console.error('Failed to load shared project file', reader.error);\n    clearStoredSharedImportData();\n    alert(texts[currentLang].invalidSharedLink);\n  };\n  reader.readAsText(file);\n}\n\nfunction prepareSharedImportContext() {\n  if (sharedImportPreparedForImport) {\n    return;\n  }\n  sharedImportPreparedForImport = true;\n\n  try {\n    if (typeof scheduleProjectAutoSave === 'function') {\n      scheduleProjectAutoSave(true);\n    } else if (typeof saveCurrentSession === 'function') {\n      saveCurrentSession();\n      if (typeof saveCurrentGearList === 'function') {\n        saveCurrentGearList();\n      }\n    }\n  } catch (error) {\n    console.warn('Failed to persist current project before shared import', error);\n  }\n\n  let selectionCleared = false;\n  if (setupSelect && typeof setupSelect.dispatchEvent === 'function') {\n    try {\n      const currentValue = typeof setupSelect.value === 'string' ? setupSelect.value : '';\n      const typedName = setupNameInput && typeof setupNameInput.value === 'string'\n        ? setupNameInput.value.trim()\n        : '';\n      const previousSelection = typeof lastSetupName === 'string' ? lastSetupName : '';\n      const shouldDispatch = Boolean(currentValue || previousSelection || typedName);\n      setupSelect.value = '';\n      if (shouldDispatch) {\n        setupSelect.dispatchEvent(new Event('change'));\n      }\n      selectionCleared = true;\n    } catch (error) {\n      console.warn('Failed to reset setup selection before shared import', error);\n    }\n  }\n\n  if (selectionCleared && setupNameInput) {\n    try {\n      if (setupNameInput.value) {\n        setupNameInput.value = '';\n        setupNameInput.dispatchEvent(new Event('input'));\n      }\n    } catch (error) {\n      console.warn('Failed to reset setup name before shared import', error);\n    }\n  }\n}\n\nfunction reapplySharedImportSelection() {\n  if (lastSharedSetupData === null) return;\n  const storedData = cloneSharedImportValue(lastSharedSetupData);\n  if (!storedData) return;\n  const storedRules = cloneSharedImportValue(lastSharedAutoGearRules);\n  const mode = resolveSharedImportMode(storedRules);\n  applySharedSetup(storedData, {\n    autoGearMode: mode,\n    sharedAutoGearRules: storedRules,\n  });\n  updateCalculations();\n}\n\nfunction resolveSharedImportMode(sharedRules) {\n  const hasRules = Array.isArray(sharedRules) && sharedRules.length > 0;\n  if (!sharedImportModeSelect) {\n    return hasRules ? 'project' : 'none';\n  }\n  const selectedValues = Array.from(sharedImportModeSelect.selectedOptions || [])\n    .map(option => option.value)\n    .filter(value => value === 'none' || value === 'project' || value === 'global');\n  if (!hasRules) {\n    return 'none';\n  }\n  let modes = Array.from(new Set(selectedValues));\n  if (!modes.length) {\n    return 'project';\n  }\n  if (modes.length > 1 && modes.includes('none')) {\n    modes = modes.filter(value => value !== 'none');\n  }\n  if (!modes.length) {\n    return 'project';\n  }\n  if (modes.length === 1) {\n    return modes[0];\n  }\n  return modes;\n}\n\nfunction encodeSharedSetup(setup) {\n  const out = {};\n  Object.keys(sharedKeyMap).forEach(key => {\n    if (setup[key] != null) out[sharedKeyMap[key]] = setup[key];\n  });\n  return out;\n}\n\nfunction decodeSharedSetup(setup) {\n  if (setup.setupName || setup.camera) return setup;\n  const out = {};\n  Object.keys(sharedKeyMap).forEach(key => {\n    const short = sharedKeyMap[key];\n    if (setup[short] != null) out[key] = setup[short];\n  });\n  return out;\n}\nconst deviceManagerSection = document.getElementById(\"device-manager\");\nconst toggleDeviceBtn = document.getElementById(\"toggleDeviceManager\");\nconst deviceListContainer = document.getElementById(\"deviceListContainer\");\nconst deviceManagerLists = new Map();\nconst deviceManagerPreferredOrder = [\n  \"cameras\",\n  \"viewfinders\",\n  \"monitors\",\n  \"video\",\n  \"wirelessReceivers\",\n  \"directorMonitors\",\n  \"iosVideo\",\n  \"lenses\",\n  \"fiz.motors\",\n  \"fiz.controllers\",\n  \"fiz.handUnits\",\n  \"fiz.distance\",\n  \"batteries\",\n  \"batteryHotswaps\",\n  \"accessories.batteries\",\n  \"accessories.powerPlates\",\n  \"accessories.cables\",\n  \"accessories.cages\",\n  \"accessories.cameraSupport\",\n  \"accessories.cameraStabiliser\",\n  \"accessories.chargers\",\n  \"accessories.videoAssist\",\n  \"accessories.media\",\n  \"accessories.filters\",\n  \"accessories.matteboxes\",\n  \"accessories.rigging\",\n  \"accessories.grip\",\n  \"accessories.sliders\",\n  \"accessories.tripodHeads\",\n  \"accessories.tripods\",\n  \"accessories.carts\"\n];\n\nfunction normalizeCategoryKey(key) {\n  if (!key) return null;\n  if (key === \"accessories\" || key === \"fiz\" || key === \"filterOptions\") return null;\n  if (key.startsWith(\"accessories.cables.\")) return \"accessories.cables\";\n  if (key === \"videoAssist\" && devices?.accessories?.videoAssist) return \"accessories.videoAssist\";\n  if (key === \"media\" && devices?.accessories?.media) return \"accessories.media\";\n  return key;\n}\n\nfunction getCategoryLabel(categoryKey, lang = currentLang) {\n  if (!categoryKey) return \"\";\n  const langNames = (typeof categoryNames === \"object\" && categoryNames && categoryNames[lang]) || {};\n  if (langNames[categoryKey]) return langNames[categoryKey];\n  const fallbackNames = (typeof categoryNames === \"object\" && categoryNames && categoryNames.en) || {};\n  if (fallbackNames[categoryKey]) return fallbackNames[categoryKey];\n  const parts = categoryKey.split('.');\n  if (parts[0] === \"accessories\" && parts.length > 1) {\n    const rest = parts.slice(1).map(part => humanizeKey(part));\n    return `${humanizeKey('accessory')} ${rest.join(' ')}`.trim();\n  }\n  if (parts[0] === \"fiz\" && parts.length > 1) {\n    const rest = parts.slice(1).map(part => humanizeKey(part));\n    return `FIZ ${rest.join(' ')}`.trim();\n  }\n  return parts.map(part => humanizeKey(part)).join(' ');\n}\n\nfunction collectDeviceManagerCategories() {\n  const categories = new Set();\n  const addCategory = (key) => {\n    const normalized = normalizeCategoryKey(key);\n    if (!normalized) return;\n    categories.add(normalized);\n  };\n\n  const traverseSchema = (node, path = []) => {\n    if (!node || typeof node !== 'object') return;\n    if (Array.isArray(node.attributes)) {\n      addCategory(path.join('.'));\n    }\n    Object.entries(node).forEach(([childKey, value]) => {\n      if (childKey === 'attributes') return;\n      if (value && typeof value === 'object') {\n        traverseSchema(value, path.concat(childKey));\n      }\n    });\n  };\n\n  if (deviceSchema) {\n    traverseSchema(deviceSchema, []);\n  }\n\n  const addFromData = (data) => {\n    if (!data || typeof data !== 'object' || Array.isArray(data)) return;\n    Object.entries(data).forEach(([key, value]) => {\n      if (key === 'accessories') {\n        if (value && typeof value === 'object') {\n          Object.entries(value).forEach(([subKey, subValue]) => {\n            if (subValue && typeof subValue === 'object' && !Array.isArray(subValue)) {\n              addCategory(`accessories.${subKey}`);\n            }\n          });\n        }\n      } else if (key === 'fiz') {\n        if (value && typeof value === 'object') {\n          Object.entries(value).forEach(([subKey, subValue]) => {\n            if (subValue && typeof subValue === 'object' && !Array.isArray(subValue)) {\n              addCategory(`fiz.${subKey}`);\n            }\n          });\n        }\n      } else if (value && typeof value === 'object' && !Array.isArray(value)) {\n        addCategory(key);\n      }\n    });\n  };\n\n  addFromData(devices);\n\n  const sorted = Array.from(categories);\n  const orderMap = new Map(deviceManagerPreferredOrder.map((key, index) => [key, index]));\n  sorted.sort((a, b) => {\n    const idxA = orderMap.has(a) ? orderMap.get(a) : deviceManagerPreferredOrder.length;\n    const idxB = orderMap.has(b) ? orderMap.get(b) : deviceManagerPreferredOrder.length;\n    if (idxA !== idxB) return idxA - idxB;\n    return a.localeCompare(b);\n  });\n  return sorted;\n}\n\nfunction createDeviceCategorySection(categoryKey) {\n  if (!deviceListContainer || deviceManagerLists.has(categoryKey)) return deviceManagerLists.get(categoryKey) || null;\n  const section = document.createElement('div');\n  section.className = 'device-category';\n  const sanitizedId = categoryKey.replace(/[^a-z0-9]+/gi, '_');\n  const heading = document.createElement('h4');\n  heading.id = `category_${sanitizedId}`;\n  heading.dataset.categoryKey = categoryKey;\n  section.appendChild(heading);\n  const filterInput = document.createElement('input');\n  filterInput.type = 'search';\n  filterInput.className = 'list-filter';\n  filterInput.id = `${sanitizedId}ListFilter`;\n  filterInput.dataset.categoryKey = categoryKey;\n  section.appendChild(filterInput);\n  const list = document.createElement('ul');\n  list.className = 'device-ul';\n  const listId = sanitizedId === 'cameras' ? 'cameraList' : `${sanitizedId}List`;\n  list.id = listId;\n  if (sanitizedId === 'cameras') {\n    list.setAttribute('data-current-id', 'camerasList');\n  }\n  section.appendChild(list);\n  deviceListContainer.appendChild(section);\n  bindFilterInput(filterInput, () => filterDeviceList(list, filterInput.value));\n  const entry = { section, heading, filterInput, list, sanitizedId };\n  deviceManagerLists.set(categoryKey, entry);\n  return entry;\n}\n\nfunction updateDeviceManagerLocalization(lang = currentLang) {\n  if (!deviceManagerLists.size) return;\n  const placeholderTemplate = (texts[lang] && texts[lang].placeholder_filter) || 'Filter {item}...';\n  const clearLabel = (texts[lang] && texts[lang].clearFilter) || 'Clear filter';\n  deviceManagerLists.forEach((entry, categoryKey) => {\n    const label = getCategoryLabel(categoryKey, lang);\n    if (entry.heading) {\n      entry.heading.textContent = label;\n    }\n    if (entry.filterInput) {\n      const placeholder = placeholderTemplate.replace('{item}', label.toLowerCase());\n      entry.filterInput.placeholder = placeholder;\n      entry.filterInput.setAttribute('aria-label', placeholder);\n      entry.filterInput.setAttribute('autocomplete', 'off');\n      entry.filterInput.setAttribute('autocorrect', 'off');\n      entry.filterInput.setAttribute('autocapitalize', 'off');\n      entry.filterInput.setAttribute('spellcheck', 'false');\n      entry.filterInput.setAttribute('inputmode', 'search');\n      const clearBtn = entry.filterInput.nextElementSibling;\n      if (clearBtn && clearBtn.classList.contains('clear-input-btn')) {\n        clearBtn.setAttribute('aria-label', clearLabel);\n        clearBtn.title = clearLabel;\n      }\n    }\n  });\n}\n\nfunction syncDeviceManagerCategories() {\n  if (!deviceListContainer) return;\n  const categories = collectDeviceManagerCategories();\n  const desiredSet = new Set(categories);\n  const existingKeys = Array.from(deviceManagerLists.keys());\n  categories.forEach(categoryKey => {\n    if (!deviceManagerLists.has(categoryKey)) {\n      createDeviceCategorySection(categoryKey);\n    }\n  });\n  existingKeys.forEach(categoryKey => {\n    if (!desiredSet.has(categoryKey)) {\n      const entry = deviceManagerLists.get(categoryKey);\n      if (entry && entry.section && entry.section.parentNode) {\n        entry.section.parentNode.removeChild(entry.section);\n      }\n      deviceManagerLists.delete(categoryKey);\n    }\n  });\n  categories.forEach(categoryKey => {\n    const entry = deviceManagerLists.get(categoryKey);\n    if (entry && entry.section) {\n      deviceListContainer.appendChild(entry.section);\n    }\n  });\n  updateDeviceManagerLocalization(currentLang);\n}\nfunction getCurrentProjectName() {\n  const typedName =\n    (setupNameInput && typeof setupNameInput.value === 'string'\n      ? setupNameInput.value.trim()\n      : '') || '';\n  if (typedName) {\n    return typedName;\n  }\n  return (setupSelect && setupSelect.value) || '';\n}\n\nfunction getCurrentProjectStorageKey(options = {}) {\n  const typedName =\n    setupNameInput && typeof setupNameInput.value === 'string'\n      ? setupNameInput.value.trim()\n      : '';\n  const selectedName =\n    setupSelect && typeof setupSelect.value === 'string'\n      ? setupSelect.value.trim()\n      : '';\n\n  if (options.allowTyped && typedName) {\n    return typedName;\n  }\n\n  if (selectedName) {\n    return selectedName;\n  }\n\n  if (!setupSelect) {\n    return '';\n  }\n\n  if (\n    typedName &&\n    Array.from((setupSelect && setupSelect.options) || []).some(\n      option => option && option.value === typedName\n    )\n  ) {\n    return typedName;\n  }\n\n  return '';\n}\nnewCategorySelect = document.getElementById(\"newCategory\");\nnewSubcategorySelect = document.getElementById(\"newSubcategory\");\nsubcategoryFieldDiv = document.getElementById(\"subcategoryField\");\nnewNameInput = document.getElementById(\"newName\");\nnewWattInput = document.getElementById(\"newWatt\");\nwattFieldDiv = document.getElementById(\"wattField\");\ndynamicFieldsDiv = document.getElementById(\"dynamicFields\");\ncameraFieldsDiv = document.getElementById(\"cameraFields\");\ncameraWattInput = document.getElementById(\"cameraWatt\");\ncameraVoltageInput = document.getElementById(\"cameraVoltage\");\ncameraPortTypeInput = document.getElementById(\"cameraPortType\");\nmonitorFieldsDiv = document.getElementById(\"monitorFields\");\nmonitorScreenSizeInput = document.getElementById(\"monitorScreenSize\");\nmonitorBrightnessInput = document.getElementById(\"monitorBrightness\");\nmonitorWattInput = document.getElementById(\"monitorWatt\");\nmonitorVoltageInput = document.getElementById(\"monitorVoltage\");\nmonitorPortTypeInput = document.getElementById(\"monitorPortType\");\nmonitorVideoInputsContainer = document.getElementById(\"monitorVideoInputsContainer\");\n\nfunction populateCategoryOptions() {\n  if (!newCategorySelect && typeof document !== 'undefined') {\n    newCategorySelect = document.getElementById('newCategory');\n  }\n  if (!newCategorySelect) return;\n  newCategorySelect.innerHTML = '';\n  const addOpt = (val) => {\n    const opt = document.createElement('option');\n    opt.value = val;\n    opt.textContent = getCategoryLabel(val, currentLang);\n    newCategorySelect.appendChild(opt);\n  };\n\n  // Add categories from schema when available\n  if (deviceSchema) {\n    if (deviceSchema.accessories) {\n      for (const [sub, obj] of Object.entries(deviceSchema.accessories)) {\n        if (sub === 'cables') {\n          addOpt('accessories.cables');\n        } else if (obj && obj.attributes) {\n          addOpt(`accessories.${sub}`);\n        }\n      }\n    }\n    for (const [key, obj] of Object.entries(deviceSchema)) {\n      if (key === 'accessories' || key === 'fiz') continue;\n      if (obj && obj.attributes) addOpt(key);\n    }\n    if (deviceSchema.fiz) {\n      for (const [sub, obj] of Object.entries(deviceSchema.fiz)) {\n        if (obj && obj.attributes) addOpt(`fiz.${sub}`);\n      }\n    }\n  }\n\n  // Include any categories present in the device database that were not in the schema\n  if (typeof devices === 'object') {\n    const existing = new Set(Array.from(newCategorySelect.options).map(o => o.value));\n    const addIfMissing = (val) => { if (!existing.has(val)) { addOpt(val); existing.add(val); } };\n    for (const [key, obj] of Object.entries(devices)) {\n      if (key === 'accessories') {\n        for (const sub of Object.keys(obj || {})) {\n          addIfMissing(`accessories.${sub}`);\n        }\n      } else if (key === 'fiz') {\n        for (const sub of Object.keys(obj || {})) {\n          addIfMissing(`fiz.${sub}`);\n        }\n      } else if (obj && typeof obj === 'object' && !Array.isArray(obj)) {\n        addIfMissing(key);\n      }\n    }\n  }\n\n  syncDeviceManagerCategories();\n}\n\npopulateCategoryOptions();\n\nfunction getCategoryContainer(categoryKey, subcategory, { create = false } = {}) {\n  if (!categoryKey) {\n    return null;\n  }\n  if (categoryKey === 'accessories.cables') {\n    if (!subcategory) {\n      return null;\n    }\n    if (!devices.accessories) {\n      if (!create) return null;\n      devices.accessories = {};\n    }\n    if (!devices.accessories.cables) {\n      if (!create) return null;\n      devices.accessories.cables = {};\n    }\n    if (!devices.accessories.cables[subcategory]) {\n      if (!create) return null;\n      devices.accessories.cables[subcategory] = {};\n    }\n    return devices.accessories.cables[subcategory];\n  }\n\n  if (categoryKey.includes('.')) {\n    const [mainCat, subCat] = categoryKey.split('.');\n    if (!devices[mainCat]) {\n      if (!create) return null;\n      devices[mainCat] = {};\n    }\n    if (!devices[mainCat][subCat]) {\n      if (!create) return null;\n      devices[mainCat][subCat] = {};\n    }\n    return devices[mainCat][subCat];\n  }\n\n  if (!devices[categoryKey]) {\n    if (!create) return null;\n    devices[categoryKey] = {};\n  }\n  return devices[categoryKey];\n}\n\nfunction removeOriginalDeviceEntry(originalCategory, originalSubcategory, originalName, newCategory, newSubcategory, newName) {\n  if (!originalCategory || !originalName) {\n    return;\n  }\n  const movedCategory = originalCategory !== newCategory;\n  const movedSubcategory =\n    originalCategory === 'accessories.cables' && originalSubcategory !== newSubcategory;\n  const renamed = originalName !== newName;\n  if (!movedCategory && !movedSubcategory && !renamed) {\n    return;\n  }\n\n  const container = getCategoryContainer(\n    originalCategory,\n    originalCategory === 'accessories.cables' ? originalSubcategory : null,\n    { create: false }\n  );\n  if (!container || !Object.prototype.hasOwnProperty.call(container, originalName)) {\n    return;\n  }\n  delete container[originalName];\n  if (\n    originalCategory === 'accessories.cables' &&\n    devices.accessories?.cables &&\n    container &&\n    originalSubcategory &&\n    !Object.keys(container).length\n  ) {\n    delete devices.accessories.cables[originalSubcategory];\n  }\n}\nconst monitorVideoOutputsContainer = document.getElementById(\"monitorVideoOutputsContainer\");\nconst monitorWirelessTxInput = document.getElementById(\"monitorWirelessTx\");\nconst monitorLatencyInput = document.getElementById(\"monitorLatency\");\nconst monitorAudioOutputInput = document.getElementById(\"monitorAudioOutput\");\nconst viewfinderFieldsDiv = document.getElementById(\"viewfinderFields\");\nconst viewfinderScreenSizeInput = document.getElementById(\"viewfinderScreenSize\");\nconst viewfinderBrightnessInput = document.getElementById(\"viewfinderBrightness\");\nconst viewfinderWattInput = document.getElementById(\"viewfinderWatt\");\nconst viewfinderVoltageInput = document.getElementById(\"viewfinderVoltage\");\nconst viewfinderPortTypeInput = document.getElementById(\"viewfinderPortType\");\nconst viewfinderVideoInputsContainer = document.getElementById(\"viewfinderVideoInputsContainer\");\nconst viewfinderVideoOutputsContainer = document.getElementById(\"viewfinderVideoOutputsContainer\");\nconst viewfinderWirelessTxInput = document.getElementById(\"viewfinderWirelessTx\");\nconst viewfinderLatencyInput = document.getElementById(\"viewfinderLatency\");\nconst videoFieldsDiv = document.getElementById(\"videoFields\");\nconst videoPowerInput = document.getElementById(\"videoPower\");\nconst videoVideoInputsContainer = document.getElementById(\"videoVideoInputsContainer\");\nconst videoVideoOutputsContainer = document.getElementById(\"videoVideoOutputsContainer\");\nconst videoFrequencyInput = document.getElementById(\"videoFrequency\");\nconst videoLatencyInput = document.getElementById(\"videoLatency\");\n\nfunction showFormSection(section) {\n  if (!section) return;\n  section.classList.remove('hidden');\n  if (typeof section.removeAttribute === 'function') {\n    section.removeAttribute('hidden');\n  }\n  section.hidden = false;\n  section.style.display = '';\n}\n\nfunction hideFormSection(section) {\n  if (!section) return;\n  section.classList.add('hidden');\n  if (typeof section.setAttribute === 'function') {\n    section.setAttribute('hidden', '');\n  }\n  section.hidden = true;\n  section.style.display = 'none';\n}\nconst addDeviceForm = wattFieldDiv ? wattFieldDiv.parentNode : null;\nfunction placeWattField(category, data) {\n  if (!wattFieldDiv || !addDeviceForm) return;\n  const isVideoLike =\n    category === \"video\" ||\n    category === \"wirelessReceivers\" ||\n    category === \"iosVideo\" ||\n    (data && (data.videoInputs || data.videoOutputs || data.frequency));\n  if (isVideoLike) {\n    videoFieldsDiv.insertBefore(wattFieldDiv, videoFieldsDiv.firstChild);\n  } else {\n    addDeviceForm.insertBefore(wattFieldDiv, cameraFieldsDiv);\n  }\n}\nconst motorFieldsDiv = document.getElementById(\"motorFields\");\nconst motorConnectorInput = document.getElementById(\"motorConnector\");\nconst motorInternalInput = document.getElementById(\"motorInternal\");\nconst motorTorqueInput = document.getElementById(\"motorTorque\");\nconst motorGearInput = document.getElementById(\"motorGearTypes\");\nconst motorNotesInput = document.getElementById(\"motorNotes\");\nconst controllerFieldsDiv = document.getElementById(\"controllerFields\");\nconst controllerConnectorInput = document.getElementById(\"controllerConnector\");\nconst controllerPowerInput = document.getElementById(\"controllerPower\");\nconst controllerBatteryInput = document.getElementById(\"controllerBattery\");\nconst controllerConnectivityInput = document.getElementById(\"controllerConnectivity\");\nconst controllerNotesInput = document.getElementById(\"controllerNotes\");\nconst distanceFieldsDiv = document.getElementById(\"distanceFields\");\nconst distanceConnectionInput = document.getElementById(\"distanceConnection\");\nconst distanceMethodInput = document.getElementById(\"distanceMethod\");\nconst distanceRangeInput = document.getElementById(\"distanceRange\");\nconst distanceAccuracyInput = document.getElementById(\"distanceAccuracy\");\nconst distanceOutputInput = document.getElementById(\"distanceOutput\");\nconst distanceNotesInput = document.getElementById(\"distanceNotes\");\nconst batteryPlatesContainer = document.getElementById(\"batteryPlatesContainer\");\nconst cameraMediaContainer = document.getElementById(\"cameraMediaContainer\");\nconst lensMountContainer = document.getElementById(\"lensMountContainer\");\nconst powerDistContainer = document.getElementById(\"powerDistContainer\");\nconst videoOutputsContainer = document.getElementById(\"videoOutputsContainer\");\nconst fizConnectorContainer = document.getElementById(\"fizConnectorContainer\");\nconst viewfinderContainer = document.getElementById(\"viewfinderContainer\");\nconst timecodeContainer = document.getElementById(\"timecodeContainer\");\nconst batteryFieldsDiv = document.getElementById(\"batteryFields\");\nconst batteryPlateRow = document.getElementById(\"batteryPlateRow\");\nconst batteryPlateSelect = document.getElementById(\"batteryPlateSelect\");\nconst newCapacityInput = document.getElementById(\"newCapacity\");\nconst newPinAInput    = document.getElementById(\"newPinA\");\nconst newDtapAInput   = document.getElementById(\"newDtapA\");\nconst dtapRow         = newDtapAInput ? newDtapAInput.parentElement : null;\nconst addDeviceBtn    = document.getElementById(\"addDeviceBtn\");\nconst cancelEditBtn  = document.getElementById(\"cancelEditBtn\");\nconst exportBtn       = document.getElementById(\"exportDataBtn\");\nconst exportOutput    = document.getElementById(\"exportOutput\");\nconst importFileInput = document.getElementById(\"importFileInput\");\nconst importDataBtn   = document.getElementById(\"importDataBtn\");\nconst skipLink       = document.getElementById(\"skipLink\");\n\nconst categoryExcludedAttrs = {\n  batteries: [\"capacity\", \"pinA\", \"dtapA\"],\n  batteryHotswaps: [\"capacity\", \"pinA\"],\n  \"accessories.batteries\": [\"capacity\", \"pinA\"],\n  cameras: [\"powerDrawWatts\", \"power\", \"recordingMedia\", \"lensMount\", \"videoOutputs\", \"fizConnectors\", \"viewfinder\", \"timecode\"],\n  monitors: [\"screenSizeInches\", \"brightnessNits\", \"power\", \"powerDrawWatts\", \"videoInputs\", \"videoOutputs\", \"wirelessTx\", \"latencyMs\", \"audioOutput\"],\n  viewfinders: [\"screenSizeInches\", \"brightnessNits\", \"power\", \"powerDrawWatts\", \"videoInputs\", \"videoOutputs\", \"wirelessTx\", \"latencyMs\"],\n  video: [\"powerDrawWatts\", \"power\", \"videoInputs\", \"videoOutputs\", \"frequency\", \"latencyMs\"],\n  wirelessReceivers: [\"powerDrawWatts\", \"power\", \"videoInputs\", \"videoOutputs\", \"frequency\", \"latencyMs\"],\n  iosVideo: [\"powerDrawWatts\", \"power\", \"videoInputs\", \"videoOutputs\", \"frequency\", \"latencyMs\"],\n  \"fiz.motors\": [\"fizConnectors\", \"gearTypes\", \"internalController\", \"notes\", \"powerDrawWatts\", \"torqueNm\"],\n  \"fiz.controllers\": [\"batteryType\", \"connectivity\", \"fizConnectors\", \"internalController\", \"notes\", \"powerDrawWatts\", \"powerSource\"],\n  \"fiz.distance\": [\"accuracy\", \"connectionCompatibility\", \"measurementMethod\", \"measurementRange\", \"notes\", \"outputDisplay\", \"powerDrawWatts\"]\n};\n\nconst schemaFieldConfigs = {\n  '*': {\n    brand: { type: 'text', placeholder: 'ARRI' },\n    model: { type: 'text', placeholder: 'Mini LF' },\n    notes: { type: 'textarea', rows: 3, placeholder: 'Additional notes' }\n  },\n  batteries: {\n    mount_type: { type: 'text', placeholder: 'V-Mount' },\n    pinV: { type: 'number', step: '0.1', suffix: 'V' },\n    weight_g: { type: 'number', step: '1', suffix: 'g' }\n  },\n  'accessories.batteries': {\n    mount_type: { type: 'text', placeholder: 'V-Mount' },\n    pinV: { type: 'number', step: '0.1', suffix: 'V' },\n    weight_g: { type: 'number', step: '1', suffix: 'g' }\n  },\n  batteryHotswaps: {\n    mount_type: { type: 'text', placeholder: 'Gold Mount' },\n    pinV: { type: 'number', step: '0.1', suffix: 'V' },\n    weight_g: { type: 'number', step: '1', suffix: 'g' }\n  },\n  cameras: {\n    recordingCodecs: { type: 'list', placeholder: 'ProRes 422 HQ' },\n    resolutions: { type: 'list', placeholder: '4.5K Open Gate' },\n    sensorModes: { type: 'list', placeholder: 'LF Open Gate' },\n    viewfinder: { type: 'json', rows: 4 },\n    timecode: { type: 'json', rows: 3 },\n    weight_g: { type: 'number', step: '1', suffix: 'g' }\n  },\n  monitors: {\n    audioInput: { type: 'text', placeholder: '3.5mm stereo' },\n    audioIo: { type: 'text', placeholder: 'SDI / HDMI' },\n    audioOutput: { type: 'text', placeholder: '3.5mm stereo' },\n    bluetooth: { type: 'boolean' },\n    latencyMs: { type: 'text', placeholder: '< 1ms' },\n    wireless: { type: 'text', placeholder: 'Bolt 6' },\n    wirelessRX: { type: 'boolean' },\n    wirelessTx: { type: 'boolean' }\n  },\n  video: {\n    frequency: { type: 'text', placeholder: '5 GHz' },\n    latencyMs: { type: 'text', placeholder: '1 ms' }\n  },\n  wirelessReceivers: {\n    frequency: { type: 'text', placeholder: '5 GHz' },\n    latencyMs: { type: 'text', placeholder: '1 ms' }\n  },\n  iosVideo: {\n    frequency: { type: 'text', placeholder: '5 GHz' },\n    latencyMs: { type: 'text', placeholder: '1 ms' }\n  },\n  'fiz.motors': {\n    gearTypes: { type: 'list', placeholder: '0.8 MOD' },\n    internalController: { type: 'boolean' }\n  },\n  'fiz.controllers': {\n    connectivity: { type: 'text', placeholder: '2.4 GHz' },\n    internalController: { type: 'boolean' }\n  },\n  'fiz.distance': {\n    accuracy: { type: 'text', placeholder: '\xB1 1\"' }\n  }\n};\n\nfunction formatAttributeLabel(attr) {\n  return attr\n    .replace(/([A-Z])/g, ' $1')\n    .replace(/_/g, ' ')\n    .replace(/^./, ch => ch.toUpperCase())\n    .trim();\n}\n\nfunction resolveSchemaFieldConfig(category, attr) {\n  if (!category) return schemaFieldConfigs['*'][attr] || null;\n  const parts = category.split('.');\n  while (parts.length) {\n    const key = parts.join('.');\n    if (schemaFieldConfigs[key] && schemaFieldConfigs[key][attr]) {\n      return schemaFieldConfigs[key][attr];\n    }\n    parts.pop();\n  }\n  return schemaFieldConfigs['*'][attr] || null;\n}\n\nfunction autoRows(text, min = 3, max = 10) {\n  if (!text) return min;\n  const lines = text.split('\\n').length + 1;\n  return Math.max(min, Math.min(max, lines));\n}\n\nfunction createSchemaField(category, attr, value) {\n  const config = resolveSchemaFieldConfig(category, attr) || {};\n  const attrId = `attr-${attr}`;\n  const labelText = config.label || formatAttributeLabel(attr);\n  let inputType = config.type;\n\n  if (!inputType) {\n    if (Array.isArray(value)) {\n      inputType = value.every(item => typeof item === 'string') ? 'list' : 'json';\n    } else if (typeof value === 'number') {\n      inputType = 'number';\n    } else if (typeof value === 'boolean') {\n      inputType = 'boolean';\n    } else if (value && typeof value === 'object') {\n      inputType = 'json';\n    } else {\n      inputType = 'text';\n    }\n  }\n\n  if (inputType === 'boolean') {\n    const row = document.createElement('div');\n    row.className = 'form-row schema-form-row';\n\n    const label = document.createElement('label');\n    label.setAttribute('for', attrId);\n    label.textContent = labelText;\n    row.appendChild(label);\n\n    const controlContainer = document.createElement('div');\n    controlContainer.className = 'schema-control schema-control--checkbox';\n    const inlineWrap = document.createElement('div');\n    inlineWrap.className = 'schema-control-inline';\n\n    const input = document.createElement('input');\n    input.type = 'checkbox';\n    input.id = attrId;\n    input.className = 'schema-input schema-input--checkbox';\n    input.dataset.attrType = 'boolean';\n    input.checked = value === undefined ? !!config.default : !!value;\n    inlineWrap.appendChild(input);\n\n    controlContainer.appendChild(inlineWrap);\n    if (config.help) {\n      const help = document.createElement('p');\n      help.className = 'schema-field-help';\n      help.textContent = config.help;\n      controlContainer.appendChild(help);\n    }\n\n    row.appendChild(controlContainer);\n    return row;\n  }\n\n  const row = document.createElement('div');\n  row.className = 'form-row schema-form-row';\n  const label = document.createElement('label');\n  label.setAttribute('for', attrId);\n  label.textContent = labelText;\n  row.appendChild(label);\n\n  let control;\n  if (inputType === 'list' || inputType === 'json' || inputType === 'textarea') {\n    control = document.createElement('textarea');\n    control.className = 'schema-input schema-input--textarea';\n    control.id = attrId;\n    const textValue = value === undefined || value === null\n      ? ''\n      : inputType === 'list' && Array.isArray(value)\n        ? value.join('\\n')\n        : typeof value === 'string'\n          ? value\n          : JSON.stringify(value, null, 2);\n    control.value = textValue;\n    control.rows = config.rows || autoRows(control.value);\n  } else {\n    control = document.createElement('input');\n    control.className = 'schema-input';\n    control.id = attrId;\n    control.type = inputType === 'number' ? 'number' : 'text';\n    if (inputType === 'number') {\n      if (config.step) control.step = config.step;\n    }\n    if (value !== undefined && value !== null) {\n      control.value = value;\n    }\n  }\n\n  control.dataset.attrType = inputType;\n  if (config.placeholder && !control.value) {\n    control.placeholder = config.placeholder;\n  }\n\n  const controlContainer = document.createElement('div');\n  controlContainer.className = 'schema-control';\n  const inlineWrap = document.createElement('div');\n  inlineWrap.className = 'schema-control-inline';\n  inlineWrap.appendChild(control);\n  if (config.suffix) {\n    const suffix = document.createElement('span');\n    suffix.className = 'schema-field-suffix';\n    suffix.textContent = config.suffix;\n    inlineWrap.appendChild(suffix);\n  }\n  controlContainer.appendChild(inlineWrap);\n\n  if (config.help) {\n    const help = document.createElement('p');\n    help.className = 'schema-field-help';\n    help.textContent = config.help;\n    controlContainer.appendChild(help);\n  }\n\n  row.appendChild(controlContainer);\n\n  return row;\n}\n\nfunction getSchemaAttributesForCategory(category) {\n  if (!deviceSchema) return [];\n  const parts = category.split('.');\n  let node = deviceSchema;\n  for (const p of parts) {\n    node = node && node[p];\n    if (!node) return [];\n  }\n  return Array.isArray(node.attributes) ? node.attributes : [];\n}\n\nfunction getCombinedCategoryAttributes(category, data = {}, exclude = []) {\n  const seen = new Set();\n  const attrs = [];\n  const skip = (attr) => !attr || exclude.includes(attr) || seen.has(attr);\n\n  for (const attr of getSchemaAttributesForCategory(category)) {\n    if (skip(attr)) continue;\n    seen.add(attr);\n    attrs.push(attr);\n  }\n\n  if (data && typeof data === 'object' && !Array.isArray(data)) {\n    for (const key of Object.keys(data)) {\n      if (skip(key)) continue;\n      seen.add(key);\n      attrs.push(key);\n    }\n  }\n\n  return attrs;\n}\n\nfunction clearDynamicFields() {\n  if (!dynamicFieldsDiv) return;\n  dynamicFieldsDiv.innerHTML = '';\n  dynamicFieldsDiv.hidden = true;\n  if (dynamicFieldsDiv.dataset) {\n    delete dynamicFieldsDiv.dataset.attrs;\n  }\n}\n\nfunction buildDynamicFields(category, data = {}, exclude = []) {\n  if (!dynamicFieldsDiv) return;\n  const attrs = getCombinedCategoryAttributes(category, data, exclude);\n  dynamicFieldsDiv.innerHTML = '';\n  if (!attrs.length) {\n    dynamicFieldsDiv.hidden = true;\n    if (dynamicFieldsDiv.dataset) {\n      delete dynamicFieldsDiv.dataset.attrs;\n    }\n    return;\n  }\n  dynamicFieldsDiv.hidden = false;\n  if (dynamicFieldsDiv.dataset) {\n    dynamicFieldsDiv.dataset.attrs = JSON.stringify(attrs);\n  }\n  const list = document.createElement('div');\n  list.className = 'schema-attribute-list';\n  for (const attr of attrs) {\n    const value = data && data[attr] !== undefined ? data[attr] : undefined;\n    list.appendChild(createSchemaField(category, attr, value));\n  }\n  dynamicFieldsDiv.appendChild(list);\n}\n\nfunction collectDynamicFieldValues(category, exclude = []) {\n  let attrs = [];\n  if (dynamicFieldsDiv && dynamicFieldsDiv.dataset && dynamicFieldsDiv.dataset.attrs) {\n    try {\n      const parsed = JSON.parse(dynamicFieldsDiv.dataset.attrs);\n      if (Array.isArray(parsed)) {\n        attrs = parsed;\n      }\n    } catch (err) {\n      console.warn('Failed to parse dynamic field attributes', err);\n    }\n  }\n  if (!attrs.length) {\n    attrs = getCombinedCategoryAttributes(category, {}, exclude);\n  }\n  const result = {};\n  for (const attr of attrs) {\n    if (exclude.includes(attr)) continue;\n    const el = document.getElementById(`attr-${attr}`);\n    if (el) {\n      const type = el.dataset.attrType || el.type;\n      if (type === 'boolean') {\n        result[attr] = el.checked;\n        continue;\n      }\n      if (type === 'list') {\n        const list = el.value\n          .split('\\n')\n          .map(item => item.trim())\n          .filter(Boolean);\n        if (list.length) {\n          result[attr] = list;\n        }\n        continue;\n      }\n      if (type === 'json') {\n        const raw = el.value.trim();\n        if (raw) {\n          try {\n            result[attr] = JSON.parse(raw);\n          } catch {\n            result[attr] = raw;\n          }\n        }\n        continue;\n      }\n      if (type === 'number') {\n        const num = parseFloat(el.value);\n        if (!isNaN(num)) {\n          result[attr] = num;\n        }\n        continue;\n      }\n      if (el.value !== '') {\n        result[attr] = el.value;\n      }\n    }\n  }\n  return result;\n}\nconst languageSelect  = document.getElementById(\"languageSelect\");\nconst pinkModeToggle  = document.getElementById(\"pinkModeToggle\");\nconst pinkModeHelpIcon = document.getElementById(\"pinkModeHelpIcon\");\nconst darkModeToggle  = document.getElementById(\"darkModeToggle\");\nconst helpButton      = document.getElementById(\"helpButton\");\nconst reloadButton    = document.getElementById(\"reloadButton\");\nconst helpDialog      = document.getElementById(\"helpDialog\");\nconst closeHelpBtn    = document.getElementById(\"closeHelp\");\nconst helpSearch      = document.getElementById(\"helpSearch\");\nconst helpNoResults   = document.getElementById(\"helpNoResults\");\nconst helpResultsSummary = document.getElementById(\"helpResultsSummary\");\nconst helpSearchClear = document.getElementById(\"helpSearchClear\");\nconst helpSectionsContainer = document.getElementById(\"helpSections\");\nconst helpQuickLinksNav = document.getElementById(\"helpQuickLinks\");\nconst helpQuickLinksHeading = document.getElementById(\"helpQuickLinksHeading\");\nconst helpQuickLinksList = document.getElementById(\"helpQuickLinksList\");\nconst installPromptBanner = document.getElementById(\"installPromptBanner\");\nconst installPromptBannerText = document.getElementById(\"installPromptBannerText\");\nconst installGuideDialog = document.getElementById(\"installGuideDialog\");\nconst installGuideTitle = document.getElementById(\"installGuideTitle\");\nconst installGuideIntro = document.getElementById(\"installGuideIntro\");\nconst installGuideSteps = document.getElementById(\"installGuideSteps\");\nconst installGuideNote = document.getElementById(\"installGuideNote\");\nconst installGuideMigration = document.getElementById(\"installGuideMigration\");\nconst installGuideMigrationTitle = document.getElementById(\"installGuideMigrationTitle\");\nconst installGuideMigrationIntro = document.getElementById(\"installGuideMigrationIntro\");\nconst installGuideMigrationSteps = document.getElementById(\"installGuideMigrationSteps\");\nconst installGuideMigrationNote = document.getElementById(\"installGuideMigrationNote\");\nconst installGuideClose = document.getElementById(\"installGuideClose\");\nconst iosPwaHelpDialog = document.getElementById(\"iosPwaHelpDialog\");\nconst iosPwaHelpTitle = document.getElementById(\"iosPwaHelpTitle\");\nconst iosPwaHelpIntro = document.getElementById(\"iosPwaHelpIntro\");\nconst iosPwaHelpStep1 = document.getElementById(\"iosPwaHelpStep1\");\nconst iosPwaHelpStep2 = document.getElementById(\"iosPwaHelpStep2\");\nconst iosPwaHelpStep3 = document.getElementById(\"iosPwaHelpStep3\");\n\nsetPinkModeIconSequence(PINK_MODE_ICON_FALLBACK_MARKUP);\n\nif (typeof window !== 'undefined' && typeof document !== 'undefined') {\n  loadPinkModeIconsFromFiles().catch(() => {});\n}\nconst iosPwaHelpStep4 = document.getElementById(\"iosPwaHelpStep4\");\nconst iosPwaHelpNote = document.getElementById(\"iosPwaHelpNote\");\nconst iosPwaHelpClose = document.getElementById(\"iosPwaHelpClose\");\nconst hoverHelpButton = document.getElementById(\"hoverHelpButton\");\nconst settingsButton  = document.getElementById(\"settingsButton\");\nconst settingsDialog  = document.getElementById(\"settingsDialog\");\nif (settingsButton) {\n  settingsButton.setAttribute('data-allow-hover-help', '');\n}\nif (settingsDialog) {\n  settingsDialog.setAttribute('data-allow-hover-help', '');\n}\nconst settingsTablist = document.getElementById('settingsTablist');\nconst settingsTabButtons = settingsTablist\n  ? Array.from(settingsTablist.querySelectorAll('[role=\"tab\"]'))\n  : [];\nconst settingsTabsContainer = settingsTablist\n  ? settingsTablist.closest('.settings-tabs-container') || settingsTablist\n  : null;\nconst settingsTabsScrollPrev = document.getElementById('settingsTabsScrollPrev');\nconst settingsTabsScrollNext = document.getElementById('settingsTabsScrollNext');\nlet settingsTabsOverflowFrame = 0;\n\nfunction updateSettingsTabsOverflowIndicators() {\n  if (!settingsTablist || !settingsTabsContainer) {\n    if (settingsTabsScrollPrev) {\n      settingsTabsScrollPrev.hidden = true;\n    }\n    if (settingsTabsScrollNext) {\n      settingsTabsScrollNext.hidden = true;\n    }\n    return;\n  }\n\n  const scrollWidth = typeof settingsTablist.scrollWidth === 'number'\n    ? settingsTablist.scrollWidth\n    : 0;\n  const clientWidth = typeof settingsTablist.clientWidth === 'number'\n    ? settingsTablist.clientWidth\n    : 0;\n  const rawScrollLeft = typeof settingsTablist.scrollLeft === 'number'\n    ? settingsTablist.scrollLeft\n    : Number(settingsTablist.scrollLeft) || 0;\n  const maxScrollLeft = Math.max(0, scrollWidth - clientWidth);\n  const scrollLeft = Math.min(maxScrollLeft, Math.max(0, rawScrollLeft));\n  const canScroll = scrollWidth > clientWidth + 4;\n  const atStart = !canScroll || scrollLeft <= 1;\n  const atEnd = !canScroll || Math.abs(scrollWidth - clientWidth - scrollLeft) <= 1;\n\n  settingsTabsContainer.classList.toggle('is-scrollable', canScroll);\n  settingsTabsContainer.classList.toggle('is-at-start', atStart);\n  settingsTabsContainer.classList.toggle('is-at-end', atEnd);\n\n  if (settingsTabsScrollPrev) {\n    settingsTabsScrollPrev.hidden = !canScroll;\n    settingsTabsScrollPrev.disabled = atStart;\n  }\n\n  if (settingsTabsScrollNext) {\n    settingsTabsScrollNext.hidden = !canScroll;\n    settingsTabsScrollNext.disabled = atEnd;\n  }\n}\n\nfunction scheduleSettingsTabsOverflowUpdate() {\n  if (!settingsTablist) return;\n\n  if (\n    typeof window !== 'undefined' &&\n    typeof window.requestAnimationFrame === 'function'\n  ) {\n    if (settingsTabsOverflowFrame) {\n      if (typeof window.cancelAnimationFrame === 'function') {\n        window.cancelAnimationFrame(settingsTabsOverflowFrame);\n      }\n      settingsTabsOverflowFrame = 0;\n    }\n\n    settingsTabsOverflowFrame = window.requestAnimationFrame(() => {\n      settingsTabsOverflowFrame = 0;\n      updateSettingsTabsOverflowIndicators();\n    });\n  } else {\n    updateSettingsTabsOverflowIndicators();\n  }\n}\n\nfunction scrollSettingsTabs(direction) {\n  if (!settingsTablist) return;\n\n  const distance = settingsTablist.clientWidth\n    ? settingsTablist.clientWidth * 0.75\n    : 200;\n  const amount = direction * distance;\n\n  if (typeof settingsTablist.scrollBy === 'function') {\n    try {\n      settingsTablist.scrollBy({ left: amount, behavior: 'smooth' });\n    } catch {\n      settingsTablist.scrollLeft += amount;\n    }\n  } else {\n    settingsTablist.scrollLeft += amount;\n  }\n\n  scheduleSettingsTabsOverflowUpdate();\n}\n\nif (settingsTabsScrollPrev) {\n  settingsTabsScrollPrev.addEventListener('click', () => {\n    scrollSettingsTabs(-1);\n  });\n}\n\nif (settingsTabsScrollNext) {\n  settingsTabsScrollNext.addEventListener('click', () => {\n    scrollSettingsTabs(1);\n  });\n}\n\nif (settingsTablist) {\n  let settingsTabsPassiveOptions = false;\n  if (typeof window !== 'undefined' && typeof window.addEventListener === 'function') {\n    try {\n      const passiveTestHandler = () => {};\n      const passiveTestOptions = Object.defineProperty({}, 'passive', {\n        get() {\n          settingsTabsPassiveOptions = { passive: true };\n          return false;\n        },\n      });\n      window.addEventListener('testPassive', passiveTestHandler, passiveTestOptions);\n      window.removeEventListener('testPassive', passiveTestHandler, passiveTestOptions);\n    } catch {\n      settingsTabsPassiveOptions = false;\n    }\n  }\n\n  settingsTablist.addEventListener(\n    'scroll',\n    () => {\n      scheduleSettingsTabsOverflowUpdate();\n    },\n    settingsTabsPassiveOptions\n  );\n\n  if (typeof window !== 'undefined' && typeof window.addEventListener === 'function') {\n    window.addEventListener('resize', scheduleSettingsTabsOverflowUpdate, settingsTabsPassiveOptions);\n  }\n}\nconst settingsTabPanels = settingsDialog\n  ? Array.from(settingsDialog.querySelectorAll('.settings-panel'))\n  : [];\nconst settingsTabGeneral = document.getElementById('settingsTab-general');\nconst settingsTabAutoGear = document.getElementById('settingsTab-autoGear');\nconst settingsTabAccessibility = document.getElementById('settingsTab-accessibility');\nconst settingsTabBackup = document.getElementById('settingsTab-backup');\nconst settingsTabData = document.getElementById('settingsTab-data');\nconst settingsTabAbout = document.getElementById('settingsTab-about');\nconst generalSettingsHeading = document.getElementById('generalSettingsHeading');\nconst settingsLanguage = document.getElementById(\"settingsLanguage\");\nconst settingsDarkMode = document.getElementById(\"settingsDarkMode\");\nconst settingsPinkMode = document.getElementById(\"settingsPinkMode\");\nconst accentColorInput = document.getElementById(\"accentColorInput\");\nconst settingsTemperatureUnit = document.getElementById('settingsTemperatureUnit');\nconst settingsFontSize = document.getElementById(\"settingsFontSize\");\nconst settingsFontFamily = document.getElementById(\"settingsFontFamily\");\nconst localFontsButton = document.getElementById(\"localFontsButton\");\nconst localFontsInput = document.getElementById(\"localFontsInput\");\nconst localFontsStatus = document.getElementById(\"localFontsStatus\");\nconst localFontsGroup = document.getElementById(\"localFontsGroup\");\nconst bundledFontGroup = document.getElementById(\"bundledFontOptions\");\nconst settingsLogo = document.getElementById(\"settingsLogo\");\nconst settingsLogoPreview = document.getElementById(\"settingsLogoPreview\");\n\nlet activeSettingsTabId = '';\nif (settingsTabButtons.length) {\n  const initiallySelected = settingsTabButtons.find(button => button.getAttribute('aria-selected') === 'true');\n  activeSettingsTabId = initiallySelected?.id || settingsTabButtons[0].id;\n  try {\n    const storedTab = localStorage.getItem('settingsActiveTab');\n    if (storedTab && settingsTabButtons.some(button => button.id === storedTab)) {\n      activeSettingsTabId = storedTab;\n    }\n  } catch (e) {\n    console.warn('Could not load settings tab preference', e);\n  }\n}\n\nfunction activateSettingsTab(tabId, options = {}) {\n  if (!settingsTabButtons.length) return;\n  const { focusTab = false } = options || {};\n  let target = settingsTabButtons.find(button => button.id === tabId);\n  if (!target) {\n    target = settingsTabButtons[0];\n  }\n  if (!target) return;\n\n  settingsTabButtons.forEach(button => {\n    const selected = button === target;\n    button.setAttribute('aria-selected', selected ? 'true' : 'false');\n    button.tabIndex = selected ? 0 : -1;\n    if (selected && focusTab) {\n      try {\n        button.focus({ preventScroll: true });\n      } catch {\n        button.focus();\n      }\n    }\n    button.classList.toggle('active', selected);\n  });\n\n  settingsTabPanels.forEach(panel => {\n    if (!panel) return;\n    const labelledBy = panel.getAttribute('aria-labelledby') || '';\n    const labelledIds = labelledBy\n      .split(/\\s+/)\n      .map(id => id.trim())\n      .filter(Boolean);\n    if (labelledIds.includes(target.id)) {\n      panel.removeAttribute('hidden');\n    } else {\n      panel.setAttribute('hidden', '');\n    }\n  });\n\n  if (\n    settingsTablist &&\n    typeof settingsTablist.scrollWidth === 'number' &&\n    typeof settingsTablist.clientWidth === 'number' &&\n    settingsTablist.scrollWidth > settingsTablist.clientWidth + 4 &&\n    typeof target.scrollIntoView === 'function'\n  ) {\n    try {\n      target.scrollIntoView({ block: 'nearest', inline: 'center', behavior: 'smooth' });\n    } catch {\n      target.scrollIntoView();\n    }\n  }\n\n  scheduleSettingsTabsOverflowUpdate();\n\n  activeSettingsTabId = target.id;\n  try {\n    localStorage.setItem('settingsActiveTab', activeSettingsTabId);\n  } catch (e) {\n    console.warn('Could not save settings tab preference', e);\n  }\n}\n\nif (settingsTabButtons.length) {\n  activateSettingsTab(activeSettingsTabId);\n  settingsTabButtons.forEach(button => {\n    button.addEventListener('click', () => {\n      activateSettingsTab(button.id);\n    });\n    button.addEventListener('keydown', event => {\n      const { key } = event;\n      if (!key) return;\n      if (!['ArrowLeft', 'ArrowUp', 'ArrowRight', 'ArrowDown', 'Home', 'End'].includes(key)) {\n        return;\n      }\n      event.preventDefault();\n      const currentIndex = settingsTabButtons.indexOf(button);\n      if (currentIndex === -1) return;\n      let nextIndex = currentIndex;\n      if (key === 'ArrowLeft' || key === 'ArrowUp') {\n        nextIndex = (currentIndex - 1 + settingsTabButtons.length) % settingsTabButtons.length;\n      } else if (key === 'ArrowRight' || key === 'ArrowDown') {\n        nextIndex = (currentIndex + 1) % settingsTabButtons.length;\n      } else if (key === 'Home') {\n        nextIndex = 0;\n      } else if (key === 'End') {\n        nextIndex = settingsTabButtons.length - 1;\n      }\n      const nextTab = settingsTabButtons[nextIndex];\n      if (nextTab) {\n        activateSettingsTab(nextTab.id, { focusTab: true });\n      }\n    });\n  });\n}\n\nconst autoGearHeadingElem = document.getElementById('autoGearHeading');\nconst autoGearDescriptionElem = document.getElementById('autoGearDescription');\nconst autoGearRulesList = document.getElementById('autoGearRulesList');\nconst autoGearPresetDescription = document.getElementById('autoGearPresetDescription');\nconst autoGearPresetLabel = document.getElementById('autoGearPresetLabel');\nconst autoGearPresetSelect = document.getElementById('autoGearPresetSelect');\nconst autoGearSavePresetButton = document.getElementById('autoGearSavePreset');\nconst autoGearDeletePresetButton = document.getElementById('autoGearDeletePreset');\nconst autoGearAddRuleBtn = document.getElementById('autoGearAddRule');\nconst autoGearResetFactoryButton = document.getElementById('autoGearResetFactory');\nconst autoGearEditor = document.getElementById('autoGearEditor');\nconst autoGearRuleNameInput = document.getElementById('autoGearRuleName');\nconst autoGearRuleNameLabel = document.getElementById('autoGearRuleNameLabel');\nconst autoGearScenariosSelect = document.getElementById('autoGearScenarios');\nconst autoGearScenariosLabel = document.getElementById('autoGearScenariosLabel');\nconst autoGearMatteboxSelect = document.getElementById('autoGearMattebox');\nconst autoGearMatteboxLabel = document.getElementById('autoGearMatteboxLabel');\nconst autoGearCameraHandleSelect = document.getElementById('autoGearCameraHandle');\nconst autoGearCameraHandleLabel = document.getElementById('autoGearCameraHandleLabel');\nconst autoGearViewfinderExtensionSelect = document.getElementById('autoGearViewfinderExtension');\nconst autoGearViewfinderExtensionLabel = document.getElementById('autoGearViewfinderExtensionLabel');\nconst autoGearVideoDistributionSelect = document.getElementById('autoGearVideoDistribution');\nconst autoGearVideoDistributionLabel = document.getElementById('autoGearVideoDistributionLabel');\nconst autoGearCameraSelect = document.getElementById('autoGearCamera');\nconst autoGearCameraLabel = document.getElementById('autoGearCameraLabel');\nconst autoGearMonitorSelect = document.getElementById('autoGearMonitor');\nconst autoGearMonitorLabel = document.getElementById('autoGearMonitorLabel');\nconst autoGearWirelessSelect = document.getElementById('autoGearWireless');\nconst autoGearWirelessLabel = document.getElementById('autoGearWirelessLabel');\nconst autoGearMotorsSelect = document.getElementById('autoGearMotors');\nconst autoGearMotorsLabel = document.getElementById('autoGearMotorsLabel');\nconst autoGearControllersSelect = document.getElementById('autoGearControllers');\nconst autoGearControllersLabel = document.getElementById('autoGearControllersLabel');\nconst autoGearDistanceSelect = document.getElementById('autoGearDistance');\nconst autoGearDistanceLabel = document.getElementById('autoGearDistanceLabel');\nconst autoGearAddItemsHeading = document.getElementById('autoGearAddItemsHeading');\nconst autoGearAddItemLabel = document.getElementById('autoGearAddItemLabel');\nconst autoGearAddCategoryLabel = document.getElementById('autoGearAddCategoryLabel');\nconst autoGearAddQuantityLabel = document.getElementById('autoGearAddQuantityLabel');\nconst autoGearAddScreenSizeLabel = document.getElementById('autoGearAddScreenSizeLabel');\nconst autoGearAddSelectorTypeLabel = document.getElementById('autoGearAddSelectorTypeLabel');\nconst autoGearAddSelectorDefaultLabel = document.getElementById('autoGearAddSelectorDefaultLabel');\nconst autoGearAddSelectorIncludeLabel = document.getElementById('autoGearAddSelectorIncludeLabel');\nconst autoGearAddNotesLabel = document.getElementById('autoGearAddNotesLabel');\nconst autoGearAddNameInput = document.getElementById('autoGearAddName');\nconst autoGearAddCategorySelect = document.getElementById('autoGearAddCategory');\nconst autoGearAddQuantityInput = document.getElementById('autoGearAddQuantity');\nconst autoGearAddScreenSizeInput = document.getElementById('autoGearAddScreenSize');\nconst autoGearAddSelectorTypeSelect = document.getElementById('autoGearAddSelectorType');\nconst autoGearAddSelectorDefaultInput = document.getElementById('autoGearAddSelectorDefault');\nconst autoGearAddSelectorIncludeCheckbox = document.getElementById('autoGearAddSelectorInclude');\nconst autoGearAddNotesInput = document.getElementById('autoGearAddNotes');\nconst autoGearAddItemButton = document.getElementById('autoGearAddItemButton');\nconst autoGearAddList = document.getElementById('autoGearAddList');\nconst autoGearRemoveItemsHeading = document.getElementById('autoGearRemoveItemsHeading');\nconst autoGearRemoveItemLabel = document.getElementById('autoGearRemoveItemLabel');\nconst autoGearRemoveCategoryLabel = document.getElementById('autoGearRemoveCategoryLabel');\nconst autoGearRemoveQuantityLabel = document.getElementById('autoGearRemoveQuantityLabel');\nconst autoGearRemoveScreenSizeLabel = document.getElementById('autoGearRemoveScreenSizeLabel');\nconst autoGearRemoveSelectorTypeLabel = document.getElementById('autoGearRemoveSelectorTypeLabel');\nconst autoGearRemoveSelectorDefaultLabel = document.getElementById('autoGearRemoveSelectorDefaultLabel');\nconst autoGearRemoveSelectorIncludeLabel = document.getElementById('autoGearRemoveSelectorIncludeLabel');\nconst autoGearRemoveNotesLabel = document.getElementById('autoGearRemoveNotesLabel');\nconst autoGearRemoveNameInput = document.getElementById('autoGearRemoveName');\nconst autoGearRemoveCategorySelect = document.getElementById('autoGearRemoveCategory');\nconst autoGearRemoveQuantityInput = document.getElementById('autoGearRemoveQuantity');\nconst autoGearRemoveScreenSizeInput = document.getElementById('autoGearRemoveScreenSize');\nconst autoGearRemoveSelectorTypeSelect = document.getElementById('autoGearRemoveSelectorType');\nconst autoGearRemoveSelectorDefaultInput = document.getElementById('autoGearRemoveSelectorDefault');\nconst autoGearRemoveSelectorIncludeCheckbox = document.getElementById('autoGearRemoveSelectorInclude');\nconst autoGearRemoveNotesInput = document.getElementById('autoGearRemoveNotes');\nconst autoGearRemoveItemButton = document.getElementById('autoGearRemoveItemButton');\nconst autoGearRemoveList = document.getElementById('autoGearRemoveList');\nconst autoGearSaveRuleButton = document.getElementById('autoGearSaveRule');\nconst autoGearCancelEditButton = document.getElementById('autoGearCancelEdit');\nconst autoGearItemCatalog = document.getElementById('autoGearItemCatalog');\nconst autoGearMonitorCatalog = document.getElementById('autoGearMonitorCatalog');\n\nfunction enableAutoGearMultiSelectToggle(select) {\n  if (!select || !select.multiple) return;\n\n  const handlePointerToggle = event => {\n    if (!select.multiple || event.defaultPrevented) return;\n\n    const isPointerEvent = typeof PointerEvent !== 'undefined' && event instanceof PointerEvent;\n    if (isPointerEvent && event.pointerType && event.pointerType !== 'mouse') {\n      return;\n    }\n\n    if (typeof event.button === 'number' && event.button !== 0) {\n      return;\n    }\n\n    if (event.ctrlKey || event.metaKey || event.shiftKey || event.altKey) {\n      return;\n    }\n\n    const option = event.target instanceof HTMLOptionElement ? event.target : null;\n    if (!option || option.disabled) {\n      return;\n    }\n\n    event.preventDefault();\n\n    option.selected = !option.selected;\n\n    const dispatchEvent = type => {\n      try {\n        const evt = new Event(type, { bubbles: true });\n        select.dispatchEvent(evt);\n      } catch {\n        const evt = document.createEvent('Event');\n        evt.initEvent(type, true, true);\n        select.dispatchEvent(evt);\n      }\n    };\n\n    dispatchEvent('input');\n    dispatchEvent('change');\n\n    if (typeof select.focus === 'function') {\n      try {\n        select.focus({ preventScroll: true });\n      } catch {\n        select.focus();\n      }\n    }\n  };\n\n  if (typeof window !== 'undefined' && typeof window.PointerEvent !== 'undefined') {\n    select.addEventListener('pointerdown', handlePointerToggle);\n  } else {\n    select.addEventListener('mousedown', handlePointerToggle);\n  }\n}\n\n[\n  autoGearScenariosSelect,\n  autoGearMatteboxSelect,\n  autoGearCameraHandleSelect,\n  autoGearViewfinderExtensionSelect,\n  autoGearVideoDistributionSelect,\n  autoGearCameraSelect,\n  autoGearMonitorSelect,\n  autoGearWirelessSelect,\n  autoGearMotorsSelect,\n  autoGearControllersSelect,\n  autoGearDistanceSelect,\n].forEach(enableAutoGearMultiSelectToggle);\n\nconst autoGearAddScreenSizeField = autoGearAddScreenSizeInput?.closest('.auto-gear-field')\n  || autoGearAddScreenSizeLabel?.closest('.auto-gear-field')\n  || null;\nconst autoGearAddSelectorTypeField = autoGearAddSelectorTypeSelect?.closest('.auto-gear-field')\n  || autoGearAddSelectorTypeLabel?.closest('.auto-gear-field')\n  || null;\nconst autoGearAddSelectorDefaultField = autoGearAddSelectorDefaultInput?.closest('.auto-gear-field')\n  || autoGearAddSelectorDefaultLabel?.closest('.auto-gear-field')\n  || null;\nconst autoGearAddSelectorIncludeField = autoGearAddSelectorIncludeCheckbox?.closest('.auto-gear-field')\n  || autoGearAddSelectorIncludeLabel?.closest('.auto-gear-field')\n  || null;\nconst autoGearRemoveScreenSizeField = autoGearRemoveScreenSizeInput?.closest('.auto-gear-field')\n  || autoGearRemoveScreenSizeLabel?.closest('.auto-gear-field')\n  || null;\nconst autoGearRemoveSelectorTypeField = autoGearRemoveSelectorTypeSelect?.closest('.auto-gear-field')\n  || autoGearRemoveSelectorTypeLabel?.closest('.auto-gear-field')\n  || null;\nconst autoGearRemoveSelectorDefaultField = autoGearRemoveSelectorDefaultInput?.closest('.auto-gear-field')\n  || autoGearRemoveSelectorDefaultLabel?.closest('.auto-gear-field')\n  || null;\nconst autoGearRemoveSelectorIncludeField = autoGearRemoveSelectorIncludeCheckbox?.closest('.auto-gear-field')\n  || autoGearRemoveSelectorIncludeLabel?.closest('.auto-gear-field')\n  || null;\n\nconst autoGearAddMonitorFieldGroup = {\n  select: autoGearAddCategorySelect,\n  screenSizeField: autoGearAddScreenSizeField,\n  screenSizeInput: autoGearAddScreenSizeInput,\n  selectorTypeField: autoGearAddSelectorTypeField,\n  selectorTypeSelect: autoGearAddSelectorTypeSelect,\n  selectorDefaultField: autoGearAddSelectorDefaultField,\n  selectorDefaultInput: autoGearAddSelectorDefaultInput,\n  selectorIncludeField: autoGearAddSelectorIncludeField,\n  selectorIncludeCheckbox: autoGearAddSelectorIncludeCheckbox,\n};\n\nconst autoGearRemoveMonitorFieldGroup = {\n  select: autoGearRemoveCategorySelect,\n  screenSizeField: autoGearRemoveScreenSizeField,\n  screenSizeInput: autoGearRemoveScreenSizeInput,\n  selectorTypeField: autoGearRemoveSelectorTypeField,\n  selectorTypeSelect: autoGearRemoveSelectorTypeSelect,\n  selectorDefaultField: autoGearRemoveSelectorDefaultField,\n  selectorDefaultInput: autoGearRemoveSelectorDefaultInput,\n  selectorIncludeField: autoGearRemoveSelectorIncludeField,\n  selectorIncludeCheckbox: autoGearRemoveSelectorIncludeCheckbox,\n};\n\nfunction syncAutoGearMonitorFieldVisibility() {\n  updateAutoGearMonitorFieldGroup(autoGearAddMonitorFieldGroup);\n  updateAutoGearMonitorFieldGroup(autoGearRemoveMonitorFieldGroup);\n}\nconst autoGearExportButton = document.getElementById('autoGearExport');\nconst autoGearImportButton = document.getElementById('autoGearImport');\nconst autoGearImportInput = document.getElementById('autoGearImportInput');\nconst autoGearBackupsSection = document.getElementById('autoGearBackupsSection');\nconst autoGearBackupsHeading = document.getElementById('autoGearBackupsHeading');\nconst autoGearBackupsDescription = document.getElementById('autoGearBackupsDescription');\nconst autoGearBackupSelectLabel = document.getElementById('autoGearBackupSelectLabel');\nconst autoGearBackupSelect = document.getElementById('autoGearBackupSelect');\nconst autoGearBackupRestoreButton = document.getElementById('autoGearBackupRestore');\nconst autoGearBackupControls = document.getElementById('autoGearBackupControls');\nconst autoGearBackupEmptyMessage = document.getElementById('autoGearBackupEmpty');\nconst autoGearShowBackupsCheckbox = document.getElementById('autoGearShowBackups');\nconst autoGearShowBackupsLabel = document.getElementById('autoGearShowBackupsLabel');\nconst autoGearBackupsHiddenNotice = document.getElementById('autoGearBackupsHidden');\nconst dataHeading = document.getElementById(\"dataHeading\");\nconst storageSummaryIntro = document.getElementById(\"storageSummaryIntro\");\nconst storageSummaryList = document.getElementById(\"storageSummaryList\");\nconst storageSummaryEmpty = document.getElementById(\"storageSummaryEmpty\");\nconst storageSummaryFootnote = document.getElementById(\"storageSummaryFootnote\");\n\nfunction computeAutoGearMultiSelectSize(optionCount, {\n  fallback,\n  minRows = AUTO_GEAR_MULTI_SELECT_MIN_ROWS,\n  maxRows = AUTO_GEAR_MULTI_SELECT_MAX_ROWS,\n} = {}) {\n  const effectiveFallback = Number.isFinite(fallback) && fallback >= minRows\n    ? fallback\n    : minRows;\n  if (!Number.isFinite(optionCount) || optionCount <= 0) {\n    return effectiveFallback;\n  }\n  const boundedMax = Number.isFinite(maxRows) && maxRows >= minRows ? maxRows : minRows;\n  return Math.max(minRows, Math.min(optionCount, boundedMax));\n}\n\nlet autoGearEditorDraft = null;\n\nfunction cloneAutoGearDraftItem(item) {\n  const normalized = normalizeAutoGearItem(item);\n  if (normalized) return normalized;\n  return {\n    id: generateAutoGearId('item'),\n    name: '',\n    category: '',\n    quantity: 1,\n    screenSize: '',\n    selectorType: 'none',\n    selectorDefault: '',\n    selectorEnabled: false,\n    notes: '',\n  };\n}\n\nfunction createAutoGearDraft(rule) {\n  if (rule) {\n    return {\n      id: rule.id,\n      label: rule.label || '',\n      scenarios: Array.isArray(rule.scenarios) ? rule.scenarios.slice() : [],\n      mattebox: Array.isArray(rule.mattebox) ? rule.mattebox.slice() : [],\n      cameraHandle: Array.isArray(rule.cameraHandle) ? rule.cameraHandle.slice() : [],\n      viewfinderExtension: Array.isArray(rule.viewfinderExtension) ? rule.viewfinderExtension.slice() : [],\n      videoDistribution: Array.isArray(rule.videoDistribution) ? rule.videoDistribution.slice() : [],\n      camera: Array.isArray(rule.camera) ? rule.camera.slice() : [],\n      monitor: Array.isArray(rule.monitor) ? rule.monitor.slice() : [],\n      wireless: Array.isArray(rule.wireless) ? rule.wireless.slice() : [],\n      motors: Array.isArray(rule.motors) ? rule.motors.slice() : [],\n      controllers: Array.isArray(rule.controllers) ? rule.controllers.slice() : [],\n      distance: Array.isArray(rule.distance) ? rule.distance.slice() : [],\n      add: Array.isArray(rule.add) ? rule.add.map(cloneAutoGearDraftItem) : [],\n      remove: Array.isArray(rule.remove) ? rule.remove.map(cloneAutoGearDraftItem) : [],\n    };\n  }\n  return {\n    id: generateAutoGearId('rule'),\n    label: '',\n    scenarios: [],\n    mattebox: [],\n    cameraHandle: [],\n    viewfinderExtension: [],\n    videoDistribution: [],\n    camera: [],\n    monitor: [],\n    wireless: [],\n    motors: [],\n    controllers: [],\n    distance: [],\n    add: [],\n    remove: [],\n  };\n}\n\nfunction refreshAutoGearScenarioOptions(selected) {\n  if (!autoGearScenariosSelect) return;\n\n  const candidateValues = Array.isArray(selected)\n    ? selected\n    : typeof selected === 'string' && selected\n      ? [selected]\n      : Array.isArray(autoGearEditorDraft?.scenarios)\n        ? autoGearEditorDraft.scenarios\n        : [];\n\n  const selectedValues = Array.from(\n    new Set(\n      candidateValues\n        .filter(value => typeof value === 'string')\n        .map(value => value.trim())\n        .filter(Boolean)\n    )\n  );\n\n  autoGearScenariosSelect.innerHTML = '';\n  autoGearScenariosSelect.multiple = true;\n\n  const source = document.getElementById('requiredScenarios');\n  let hasOptions = false;\n\n  if (source) {\n    Array.from(source.options).forEach(opt => {\n      if (!opt.value) return;\n      const option = document.createElement('option');\n      option.value = opt.value;\n      option.textContent = opt.textContent;\n      if (selectedValues.includes(opt.value)) {\n        option.selected = true;\n      }\n      autoGearScenariosSelect.appendChild(option);\n      hasOptions = true;\n    });\n  }\n\n  if (!hasOptions) {\n    const placeholder = document.createElement('option');\n    placeholder.value = '';\n    placeholder.textContent = texts[currentLang]?.autoGearScenarioPlaceholder\n      || texts.en?.autoGearScenarioPlaceholder\n      || 'Select scenarios';\n    placeholder.disabled = true;\n    placeholder.selected = true;\n    autoGearScenariosSelect.appendChild(placeholder);\n  } else {\n    selectedValues.forEach(value => {\n      const exists = Array.from(autoGearScenariosSelect.options || []).some(\n        option => option && option.value === value\n      );\n      if (!exists) {\n        const fallbackOption = document.createElement('option');\n        fallbackOption.value = value;\n        fallbackOption.textContent = value;\n        fallbackOption.selected = true;\n        autoGearScenariosSelect.appendChild(fallbackOption);\n      }\n    });\n  }\n\n  const selectableOptions = Array.from(autoGearScenariosSelect.options || []).filter(option => !option.disabled);\n  autoGearScenariosSelect.size = computeAutoGearMultiSelectSize(selectableOptions.length);\n}\n\nfunction refreshAutoGearMatteboxOptions(selected) {\n  if (!autoGearMatteboxSelect) return;\n\n  const candidateValues = Array.isArray(selected)\n    ? selected\n    : typeof selected === 'string' && selected\n      ? [selected]\n      : Array.isArray(autoGearEditorDraft?.mattebox)\n        ? autoGearEditorDraft.mattebox\n        : [];\n\n  const selectedValues = Array.from(new Set(\n    candidateValues\n      .filter(value => typeof value === 'string')\n      .map(value => value.trim())\n      .filter(Boolean)\n  ));\n\n  autoGearMatteboxSelect.innerHTML = '';\n  autoGearMatteboxSelect.multiple = true;\n\n  const source = document.getElementById('mattebox');\n  let hasOptions = false;\n\n  if (source) {\n    Array.from(source.options).forEach(opt => {\n      if (!opt.value) return;\n      const option = document.createElement('option');\n      option.value = opt.value;\n      option.textContent = opt.textContent;\n      if (selectedValues.includes(opt.value)) {\n        option.selected = true;\n      }\n      autoGearMatteboxSelect.appendChild(option);\n      hasOptions = true;\n    });\n  }\n\n  if (!hasOptions) {\n    const placeholder = document.createElement('option');\n    placeholder.value = '';\n    placeholder.textContent = texts[currentLang]?.autoGearMatteboxPlaceholder\n      || texts.en?.autoGearMatteboxPlaceholder\n      || 'Select mattebox options';\n    placeholder.disabled = true;\n    placeholder.selected = true;\n    autoGearMatteboxSelect.appendChild(placeholder);\n  } else {\n    selectedValues.forEach(value => {\n      const exists = Array.from(autoGearMatteboxSelect.options || []).some(\n        option => option && option.value === value\n      );\n      if (!exists) {\n        const fallbackOption = document.createElement('option');\n        fallbackOption.value = value;\n        fallbackOption.textContent = value;\n        fallbackOption.selected = true;\n        autoGearMatteboxSelect.appendChild(fallbackOption);\n      }\n    });\n  }\n\n  const selectableOptions = Array.from(autoGearMatteboxSelect.options || []).filter(option => !option.disabled);\n  autoGearMatteboxSelect.size = computeAutoGearMultiSelectSize(selectableOptions.length);\n}\n\nfunction refreshAutoGearCameraHandleOptions(selected) {\n  if (!autoGearCameraHandleSelect) return;\n\n  const candidateValues = Array.isArray(selected)\n    ? selected\n    : typeof selected === 'string' && selected\n      ? [selected]\n      : Array.isArray(autoGearEditorDraft?.cameraHandle)\n        ? autoGearEditorDraft.cameraHandle\n        : [];\n\n  const selectedValues = Array.from(new Set(\n    candidateValues\n      .filter(value => typeof value === 'string')\n      .map(value => value.trim())\n      .filter(Boolean)\n  ));\n\n  autoGearCameraHandleSelect.innerHTML = '';\n  autoGearCameraHandleSelect.multiple = true;\n\n  const source = document.getElementById('cameraHandle');\n  let hasOptions = false;\n\n  if (source) {\n    Array.from(source.options).forEach(opt => {\n      if (!opt.value) return;\n      const option = document.createElement('option');\n      option.value = opt.value;\n      option.textContent = opt.textContent;\n      if (selectedValues.includes(opt.value)) {\n        option.selected = true;\n      }\n      autoGearCameraHandleSelect.appendChild(option);\n      hasOptions = true;\n    });\n  }\n\n  if (!hasOptions) {\n    const placeholder = document.createElement('option');\n    placeholder.value = '';\n    placeholder.textContent = texts[currentLang]?.autoGearCameraHandlePlaceholder\n      || texts.en?.autoGearCameraHandlePlaceholder\n      || 'Select camera handles';\n    placeholder.disabled = true;\n    placeholder.selected = true;\n    autoGearCameraHandleSelect.appendChild(placeholder);\n  } else {\n    selectedValues.forEach(value => {\n      const exists = Array.from(autoGearCameraHandleSelect.options || []).some(\n        option => option && option.value === value\n      );\n      if (!exists) {\n        const fallbackOption = document.createElement('option');\n        fallbackOption.value = value;\n        fallbackOption.textContent = value;\n        fallbackOption.selected = true;\n        autoGearCameraHandleSelect.appendChild(fallbackOption);\n      }\n    });\n  }\n\n  const selectableOptions = Array.from(autoGearCameraHandleSelect.options || []).filter(option => !option.disabled);\n  autoGearCameraHandleSelect.size = computeAutoGearMultiSelectSize(selectableOptions.length);\n}\n\nfunction resolveViewfinderOptionValue(option) {\n  if (!option) return '';\n  const raw = typeof option.value === 'string' ? option.value : '';\n  return raw ? raw : '__none__';\n}\n\nfunction getViewfinderFallbackLabel(value) {\n  if (value === '__none__') {\n    return texts[currentLang]?.viewfinderExtensionNone\n      || texts.en?.viewfinderExtensionNone\n      || 'No';\n  }\n  return value;\n}\n\nfunction getVideoDistributionFallbackLabel(value) {\n  if (value === '__none__') {\n    return texts[currentLang]?.autoGearVideoDistributionNone\n      || texts.en?.autoGearVideoDistributionNone\n      || 'No video distribution selected';\n  }\n  return value;\n}\n\nfunction normalizeVideoDistributionOptionValue(value) {\n  if (typeof value !== 'string') return '';\n  const trimmed = value.trim();\n  if (!trimmed) return '';\n  const lower = trimmed.toLowerCase();\n  if (lower === '__none__' || lower === 'none') return '__none__';\n  return trimmed;\n}\n\nfunction refreshAutoGearViewfinderExtensionOptions(selected) {\n  if (!autoGearViewfinderExtensionSelect) return;\n\n  const candidateValues = Array.isArray(selected)\n    ? selected\n    : typeof selected === 'string' && selected\n      ? [selected]\n      : Array.isArray(autoGearEditorDraft?.viewfinderExtension)\n        ? autoGearEditorDraft.viewfinderExtension\n        : [];\n\n  const selectedValues = Array.from(new Set(\n    candidateValues\n      .filter(value => typeof value === 'string')\n      .map(value => value.trim())\n      .filter(Boolean)\n  ));\n\n  autoGearViewfinderExtensionSelect.innerHTML = '';\n  autoGearViewfinderExtensionSelect.multiple = true;\n\n  const source = document.getElementById('viewfinderExtension');\n  let hasOptions = false;\n\n  if (source) {\n    Array.from(source.options).forEach(opt => {\n      const option = document.createElement('option');\n      const value = resolveViewfinderOptionValue(opt);\n      option.value = value;\n      option.textContent = opt.textContent;\n      if (selectedValues.includes(value)) {\n        option.selected = true;\n      }\n      autoGearViewfinderExtensionSelect.appendChild(option);\n      hasOptions = true;\n    });\n  }\n\n  if (!hasOptions) {\n    const placeholder = document.createElement('option');\n    placeholder.value = '';\n    placeholder.textContent = texts[currentLang]?.autoGearViewfinderExtensionPlaceholder\n      || texts.en?.autoGearViewfinderExtensionPlaceholder\n      || 'Select viewfinder extension options';\n    placeholder.disabled = true;\n    placeholder.selected = true;\n    autoGearViewfinderExtensionSelect.appendChild(placeholder);\n  } else {\n    selectedValues.forEach(value => {\n      const exists = Array.from(autoGearViewfinderExtensionSelect.options || []).some(\n        option => option && option.value === value\n      );\n      if (!exists) {\n        const fallbackOption = document.createElement('option');\n        fallbackOption.value = value;\n        fallbackOption.textContent = getViewfinderFallbackLabel(value);\n        fallbackOption.selected = true;\n        autoGearViewfinderExtensionSelect.appendChild(fallbackOption);\n      }\n    });\n  }\n\n  const selectableOptions = Array.from(autoGearViewfinderExtensionSelect.options || []).filter(option => !option.disabled);\n  autoGearViewfinderExtensionSelect.size = computeAutoGearMultiSelectSize(selectableOptions.length);\n}\n\nfunction refreshAutoGearVideoDistributionOptions(selected) {\n  if (!autoGearVideoDistributionSelect) return;\n\n  const candidateValues = Array.isArray(selected)\n    ? selected\n    : typeof selected === 'string' && selected\n      ? [selected]\n      : Array.isArray(autoGearEditorDraft?.videoDistribution)\n        ? autoGearEditorDraft.videoDistribution\n        : [];\n\n  const normalizedSelections = Array.from(new Set(\n    candidateValues\n      .map(normalizeVideoDistributionOptionValue)\n      .filter(Boolean)\n  ));\n  const hasNoneSelection = normalizedSelections.includes('__none__');\n  const selectedValues = normalizedSelections.filter(value => value !== '__none__');\n\n  autoGearVideoDistributionSelect.innerHTML = '';\n  autoGearVideoDistributionSelect.multiple = true;\n\n  const noneOption = document.createElement('option');\n  noneOption.value = '__none__';\n  noneOption.textContent = getVideoDistributionFallbackLabel('__none__');\n  if (hasNoneSelection) {\n    noneOption.selected = true;\n  }\n  autoGearVideoDistributionSelect.appendChild(noneOption);\n\n  const source = document.getElementById('videoDistribution');\n  let hasOptions = false;\n\n  if (source) {\n    Array.from(source.options).forEach(opt => {\n      const value = normalizeVideoDistributionOptionValue(opt.value);\n      if (!value) return;\n      if (value === '__none__') {\n        if (hasNoneSelection) {\n          noneOption.selected = true;\n        }\n        return;\n      }\n      const option = document.createElement('option');\n      option.value = value;\n      option.textContent = opt.textContent;\n      if (selectedValues.includes(value)) {\n        option.selected = true;\n      }\n      autoGearVideoDistributionSelect.appendChild(option);\n      hasOptions = true;\n    });\n  }\n\n  if (!hasOptions) {\n    const placeholder = document.createElement('option');\n    placeholder.value = '';\n    placeholder.textContent = texts[currentLang]?.autoGearVideoDistributionPlaceholder\n      || texts.en?.autoGearVideoDistributionPlaceholder\n      || 'Select video distribution options';\n    placeholder.disabled = true;\n    placeholder.selected = true;\n    autoGearVideoDistributionSelect.appendChild(placeholder);\n  } else {\n    selectedValues.forEach(value => {\n      const exists = Array.from(autoGearVideoDistributionSelect.options || []).some(\n        option => option && option.value === value\n      );\n      if (!exists) {\n        const fallbackOption = document.createElement('option');\n        fallbackOption.value = value;\n        fallbackOption.textContent = getVideoDistributionFallbackLabel(value);\n        fallbackOption.selected = true;\n        autoGearVideoDistributionSelect.appendChild(fallbackOption);\n      }\n    });\n  }\n\n  const selectableOptions = Array.from(autoGearVideoDistributionSelect.options || []).filter(option => !option.disabled);\n  autoGearVideoDistributionSelect.size = computeAutoGearMultiSelectSize(selectableOptions.length);\n}\n\nfunction collectAutoGearSelectedValues(selected, key) {\n  const candidateValues = Array.isArray(selected)\n    ? selected\n    : typeof selected === 'string' && selected\n      ? [selected]\n      : Array.isArray(autoGearEditorDraft?.[key])\n        ? autoGearEditorDraft[key]\n        : [];\n  return Array.from(new Set(\n    candidateValues\n      .filter(value => typeof value === 'string')\n      .map(value => value.trim())\n      .filter(Boolean)\n  ));\n}\n\nfunction refreshAutoGearCameraOptions(selected) {\n  if (!autoGearCameraSelect) return;\n\n  const selectedValues = collectAutoGearSelectedValues(selected, 'camera');\n\n  autoGearCameraSelect.innerHTML = '';\n  autoGearCameraSelect.multiple = true;\n\n  const seen = new Set();\n  const addOption = value => {\n    if (!value || seen.has(value)) return;\n    const option = document.createElement('option');\n    option.value = value;\n    option.textContent = value;\n    if (selectedValues.includes(value)) {\n      option.selected = true;\n    }\n    autoGearCameraSelect.appendChild(option);\n    seen.add(value);\n  };\n\n  if (cameraSelect) {\n    Array.from(cameraSelect.options || []).forEach(opt => {\n      if (!opt || !opt.value || opt.value === 'None') return;\n      const label = (opt.textContent || opt.value || '').trim();\n      if (!label) return;\n      addOption(label);\n    });\n  }\n\n  selectedValues.forEach(value => {\n    if (!seen.has(value)) addOption(value);\n  });\n\n  const visibleCount = Array.from(autoGearCameraSelect.options || []).filter(option => !option.disabled).length;\n  autoGearCameraSelect.size = computeAutoGearMultiSelectSize(visibleCount);\n}\n\nfunction refreshAutoGearMonitorOptions(selected) {\n  if (!autoGearMonitorSelect) return;\n\n  const selectedValues = collectAutoGearSelectedValues(selected, 'monitor');\n\n  autoGearMonitorSelect.innerHTML = '';\n  autoGearMonitorSelect.multiple = true;\n\n  const seen = new Set();\n  const addOption = value => {\n    if (!value || seen.has(value)) return;\n    const option = document.createElement('option');\n    option.value = value;\n    option.textContent = value;\n    if (selectedValues.includes(value)) {\n      option.selected = true;\n    }\n    autoGearMonitorSelect.appendChild(option);\n    seen.add(value);\n  };\n\n  if (monitorSelect) {\n    Array.from(monitorSelect.options || []).forEach(opt => {\n      if (!opt || !opt.value || opt.value === 'None') return;\n      const label = (opt.textContent || opt.value || '').trim();\n      if (!label) return;\n      addOption(label);\n    });\n  }\n\n  selectedValues.forEach(value => {\n    if (!seen.has(value)) addOption(value);\n  });\n\n  const visibleCount = Array.from(autoGearMonitorSelect.options || []).filter(option => !option.disabled).length;\n  autoGearMonitorSelect.size = computeAutoGearMultiSelectSize(visibleCount);\n}\n\nfunction refreshAutoGearWirelessOptions(selected) {\n  if (!autoGearWirelessSelect) return;\n\n  const selectedValues = collectAutoGearSelectedValues(selected, 'wireless');\n\n  autoGearWirelessSelect.innerHTML = '';\n  autoGearWirelessSelect.multiple = true;\n\n  const seen = new Set();\n  const addOption = value => {\n    if (!value || seen.has(value)) return;\n    const option = document.createElement('option');\n    option.value = value;\n    option.textContent = value;\n    if (selectedValues.includes(value)) {\n      option.selected = true;\n    }\n    autoGearWirelessSelect.appendChild(option);\n    seen.add(value);\n  };\n\n  if (videoSelect) {\n    Array.from(videoSelect.options || []).forEach(opt => {\n      if (!opt || !opt.value || opt.value === 'None') return;\n      const label = (opt.textContent || opt.value || '').trim();\n      if (!label) return;\n      addOption(label);\n    });\n  }\n\n  selectedValues.forEach(value => {\n    if (!seen.has(value)) addOption(value);\n  });\n\n  const visibleCount = Array.from(autoGearWirelessSelect.options || []).filter(option => !option.disabled).length;\n  autoGearWirelessSelect.size = computeAutoGearMultiSelectSize(visibleCount);\n}\n\nfunction refreshAutoGearMotorsOptions(selected) {\n  if (!autoGearMotorsSelect) return;\n\n  const selectedValues = collectAutoGearSelectedValues(selected, 'motors');\n\n  autoGearMotorsSelect.innerHTML = '';\n  autoGearMotorsSelect.multiple = true;\n\n  const seen = new Set();\n  const addOption = value => {\n    if (!value || seen.has(value)) return;\n    const option = document.createElement('option');\n    option.value = value;\n    option.textContent = value;\n    if (selectedValues.includes(value)) {\n      option.selected = true;\n    }\n    autoGearMotorsSelect.appendChild(option);\n    seen.add(value);\n  };\n\n  const sourceSelects = Array.isArray(motorSelects) ? motorSelects : [];\n  sourceSelects.forEach(sel => {\n    Array.from(sel?.options || []).forEach(opt => {\n      if (!opt || !opt.value || opt.value === 'None') return;\n      const label = (opt.textContent || opt.value || '').trim();\n      if (!label) return;\n      addOption(label);\n    });\n  });\n\n  selectedValues.forEach(value => {\n    if (!seen.has(value)) addOption(value);\n  });\n\n  const visibleCount = Array.from(autoGearMotorsSelect.options || []).filter(option => !option.disabled).length;\n  autoGearMotorsSelect.size = computeAutoGearMultiSelectSize(visibleCount);\n}\n\nfunction refreshAutoGearControllersOptions(selected) {\n  if (!autoGearControllersSelect) return;\n\n  const selectedValues = collectAutoGearSelectedValues(selected, 'controllers');\n\n  autoGearControllersSelect.innerHTML = '';\n  autoGearControllersSelect.multiple = true;\n\n  const seen = new Set();\n  const addOption = value => {\n    if (!value || seen.has(value)) return;\n    const option = document.createElement('option');\n    option.value = value;\n    option.textContent = value;\n    if (selectedValues.includes(value)) {\n      option.selected = true;\n    }\n    autoGearControllersSelect.appendChild(option);\n    seen.add(value);\n  };\n\n  const sourceSelects = Array.isArray(controllerSelects) ? controllerSelects : [];\n  sourceSelects.forEach(sel => {\n    Array.from(sel?.options || []).forEach(opt => {\n      if (!opt || !opt.value || opt.value === 'None') return;\n      const label = (opt.textContent || opt.value || '').trim();\n      if (!label) return;\n      addOption(label);\n    });\n  });\n\n  selectedValues.forEach(value => {\n    if (!seen.has(value)) addOption(value);\n  });\n\n  const visibleCount = Array.from(autoGearControllersSelect.options || []).filter(option => !option.disabled).length;\n  autoGearControllersSelect.size = computeAutoGearMultiSelectSize(visibleCount);\n}\n\nfunction refreshAutoGearDistanceOptions(selected) {\n  if (!autoGearDistanceSelect) return;\n\n  const selectedValues = collectAutoGearSelectedValues(selected, 'distance');\n\n  autoGearDistanceSelect.innerHTML = '';\n  autoGearDistanceSelect.multiple = true;\n\n  const seen = new Set();\n  const addOption = value => {\n    if (!value || seen.has(value)) return;\n    const option = document.createElement('option');\n    option.value = value;\n    option.textContent = value;\n    if (selectedValues.includes(value)) {\n      option.selected = true;\n    }\n    autoGearDistanceSelect.appendChild(option);\n    seen.add(value);\n  };\n\n  if (distanceSelect) {\n    Array.from(distanceSelect.options || []).forEach(opt => {\n      if (!opt || !opt.value || opt.value === 'None') return;\n      const label = (opt.textContent || opt.value || '').trim();\n      if (!label) return;\n      addOption(label);\n    });\n  }\n\n  selectedValues.forEach(value => {\n    if (!seen.has(value)) addOption(value);\n  });\n\n  const visibleCount = Array.from(autoGearDistanceSelect.options || []).filter(option => !option.disabled).length;\n  autoGearDistanceSelect.size = computeAutoGearMultiSelectSize(visibleCount);\n}\n\nfunction populateAutoGearCategorySelect(select, currentValue) {\n  if (!select) return;\n  const current = typeof currentValue === 'string' ? currentValue : '';\n  select.innerHTML = '';\n  GEAR_LIST_CATEGORIES.forEach(cat => {\n    const opt = document.createElement('option');\n    opt.value = cat;\n    opt.textContent = cat;\n    if (current === cat) opt.selected = true;\n    select.appendChild(opt);\n  });\n  const customOpt = document.createElement('option');\n  customOpt.value = AUTO_GEAR_CUSTOM_CATEGORY;\n  customOpt.textContent = texts[currentLang]?.autoGearCustomCategory\n    || texts.en?.autoGearCustomCategory\n    || 'Custom Additions';\n  if (!current) customOpt.selected = true;\n  select.appendChild(customOpt);\n}\n\nfunction updateAutoGearCatalogOptions() {\n  if (!autoGearItemCatalog) return;\n  const names = collectAutoGearCatalogNames();\n  autoGearItemCatalog.innerHTML = '';\n  names.forEach(name => {\n    const option = document.createElement('option');\n    option.value = name;\n    autoGearItemCatalog.appendChild(option);\n  });\n  updateAutoGearMonitorCatalogOptions();\n}\n\nfunction formatAutoGearCount(count, singularKey, pluralKey) {\n  const langTexts = texts[currentLang] || texts.en || {};\n  if (count === 1) {\n    const template = langTexts[singularKey] || texts.en?.[singularKey];\n    return template ? template.replace('%s', '1') : '1';\n  }\n  const template = langTexts[pluralKey] || texts.en?.[pluralKey];\n  return template ? template.replace('%s', String(count)) : String(count);\n}\n\nfunction formatAutoGearItemSummary(item, options = {}) {\n  if (!item || typeof item !== 'object') return '';\n  const normalized = normalizeAutoGearItem(item);\n  if (!normalized) return '';\n  const {\n    quantity,\n    name,\n    category,\n    screenSize,\n    selectorType,\n    selectorDefault,\n    selectorEnabled,\n    notes,\n  } = normalized;\n  const langTexts = texts[currentLang] || texts.en || {};\n  const includeSign = !!options.includeSign;\n  const listType = options.listType || (options.includeSign ? 'add' : '');\n  const includeCategory = options.includeCategory !== false;\n  const baseQuantity = normalizeAutoGearQuantity(quantity);\n  const signPrefix = includeSign\n    ? (listType === 'remove' ? '\u2212' : '+')\n    : '';\n  const quantityText = signPrefix ? `${signPrefix}${baseQuantity}` : String(baseQuantity);\n  const nameText = name || '';\n  if (!nameText) return quantityText;\n  const categoryLabel = category\n    ? category\n    : (langTexts.autoGearCustomCategory || texts.en?.autoGearCustomCategory || '');\n  let summary;\n  if (includeCategory && categoryLabel) {\n    const withCategoryTemplate = langTexts.autoGearItemSummaryWithCategory\n      || texts.en?.autoGearItemSummaryWithCategory\n      || '%s \xD7 %s (%s)';\n    summary = formatWithPlaceholders(withCategoryTemplate, quantityText, nameText, categoryLabel);\n  } else {\n    const baseTemplate = langTexts.autoGearItemSummary\n      || texts.en?.autoGearItemSummary\n      || '%s \xD7 %s';\n    summary = formatWithPlaceholders(baseTemplate, quantityText, nameText);\n  }\n  const details = [];\n  if (screenSize) {\n    details.push(screenSize);\n  }\n  if (selectorType && selectorType !== 'none') {\n    const selectorLabel = getAutoGearSelectorLabel(selectorType);\n    const formattedDefault = selectorDefault ? addArriKNumber(selectorDefault) : '';\n    if (selectorEnabled) {\n      const selectorTemplate = formattedDefault\n        ? (langTexts.autoGearSelectorSummaryWithDefault\n          || texts.en?.autoGearSelectorSummaryWithDefault\n          || '%s selector (default: %s)')\n        : (langTexts.autoGearSelectorSummary\n          || texts.en?.autoGearSelectorSummary\n          || '%s selector');\n      const selectorText = formattedDefault\n        ? formatWithPlaceholders(selectorTemplate, selectorLabel, formattedDefault)\n        : formatWithPlaceholders(selectorTemplate, selectorLabel);\n      details.push(selectorText);\n    } else if (formattedDefault) {\n      const defaultTemplate = langTexts.autoGearSelectorSummaryNoSelector\n        || texts.en?.autoGearSelectorSummaryNoSelector\n        || '%s default: %s';\n      details.push(formatWithPlaceholders(defaultTemplate, selectorLabel, formattedDefault));\n    } else if (selectorLabel) {\n      details.push(selectorLabel);\n    }\n  }\n  if (notes) {\n    details.push(notes);\n  }\n  if (details.length) {\n    summary += ` \u2013 ${details.join(' \u2013 ')}`;\n  }\n  return summary;\n}\n\nfunction formatWithPlaceholders(template, ...values) {\n  if (typeof template !== 'string') {\n    return values.join(' ');\n  }\n  return values.reduce((acc, value) => acc.replace('%s', value), template);\n}\n\nfunction formatAutoGearRuleCount(count) {\n  const langTexts = texts[currentLang] || texts.en || {};\n  if (count === 1) {\n    const template = langTexts.autoGearRulesCountOne || texts.en?.autoGearRulesCountOne;\n    return template ? template.replace('%s', '1') : '1';\n  }\n  const template = langTexts.autoGearRulesCountOther || texts.en?.autoGearRulesCountOther;\n  return template ? template.replace('%s', String(count)) : String(count);\n}\n\nfunction formatAutoGearBackupTime(isoString) {\n  if (typeof isoString !== 'string') return '';\n  const date = new Date(isoString);\n  if (Number.isNaN(date.valueOf())) return isoString;\n  if (autoGearBackupDateFormatter) {\n    try {\n      return autoGearBackupDateFormatter.format(date);\n    } catch (error) {\n      console.warn('Failed to format automatic gear backup timestamp', error);\n    }\n  }\n  if (typeof date.toLocaleString === 'function') {\n    return date.toLocaleString();\n  }\n  return date.toISOString();\n}\n\nfunction formatAutoGearBackupMeta(backup) {\n  if (!backup) return '';\n  const langTexts = texts[currentLang] || texts.en || {};\n  const timeLabel = formatAutoGearBackupTime(backup.createdAt);\n  const ruleCount = Array.isArray(backup.rules) ? backup.rules.length : 0;\n  const rulesLabel = ruleCount === 0\n    ? (langTexts.autoGearBackupClearsRules\n        || texts.en?.autoGearBackupClearsRules\n        || 'Clears all rules')\n    : formatAutoGearRuleCount(ruleCount);\n  const template = langTexts.autoGearBackupMeta || texts.en?.autoGearBackupMeta;\n  if (template && template.includes('%s')) {\n    return formatWithPlaceholders(template, timeLabel, rulesLabel);\n  }\n  return `${timeLabel} \xB7 ${rulesLabel}`;\n}\n\nfunction getAutoGearBackupSelectPlaceholder() {\n  return texts[currentLang]?.autoGearBackupSelectPlaceholder\n    || texts.en?.autoGearBackupSelectPlaceholder\n    || 'Select a backup to restore';\n}\n\nfunction updateAutoGearBackupRestoreButtonState() {\n  if (!autoGearBackupRestoreButton) return;\n  const hasSelection = Boolean(autoGearBackupSelect && autoGearBackupSelect.value);\n  autoGearBackupRestoreButton.disabled = !hasSelection;\n}\n\nfunction getAutoGearPresetById(presetId) {\n  if (!presetId) return null;\n  return autoGearPresets.find(preset => preset.id === presetId) || null;\n}\n\nfunction getAutoGearAutoPresetLabel() {\n  const langTexts = texts[currentLang] || texts.en || {};\n  return langTexts.autoGearAutoPresetLabel\n    || texts.en?.autoGearAutoPresetLabel\n    || 'Autosaved rules';\n}\n\nfunction setAutoGearAutoPresetId(presetId, options = {}) {\n  const normalized = typeof presetId === 'string' ? presetId : '';\n  const persist = options.persist !== false;\n  const skipRender = options.skipRender === true;\n  if (autoGearAutoPresetId === normalized) {\n    if (!skipRender) renderAutoGearPresetsControls();\n    return;\n  }\n  autoGearAutoPresetId = normalized;\n  if (persist) {\n    persistAutoGearAutoPresetId(autoGearAutoPresetId);\n  }\n  if (!skipRender) {\n    renderAutoGearPresetsControls();\n  }\n}\n\nfunction reconcileAutoGearAutoPresetState(options = {}) {\n  if (!autoGearAutoPresetId) {\n    if (options.persist !== false) {\n      persistAutoGearAutoPresetId('');\n    }\n    return false;\n  }\n  const managedExists = autoGearPresets.some(preset => preset.id === autoGearAutoPresetId);\n  const otherExists = autoGearPresets.some(preset => preset.id !== autoGearAutoPresetId);\n  if (!managedExists || otherExists) {\n    setAutoGearAutoPresetId('', {\n      persist: options.persist !== false,\n      skipRender: options.skipRender === true,\n    });\n    return true;\n  }\n  return false;\n}\n\nfunction syncAutoGearAutoPreset(rules) {\n  const normalizedRules = Array.isArray(rules) ? rules : [];\n  reconcileAutoGearAutoPresetState({ persist: true, skipRender: true });\n  if (!autoGearAutoPresetId) {\n    if (autoGearPresets.length > 0) {\n      return false;\n    }\n    const label = getAutoGearAutoPresetLabel();\n    const normalizedPreset = normalizeAutoGearPreset({\n      id: generateAutoGearId('preset'),\n      label,\n      rules: normalizedRules,\n    });\n    if (!normalizedPreset) {\n      return false;\n    }\n    autoGearPresets.push(normalizedPreset);\n    autoGearPresets = sortAutoGearPresets(autoGearPresets.slice());\n    persistAutoGearPresets(autoGearPresets);\n    setAutoGearAutoPresetId(normalizedPreset.id, { persist: true, skipRender: true });\n    setActiveAutoGearPresetId(normalizedPreset.id, { persist: true, skipRender: true });\n    return true;\n  }\n  const managedIndex = autoGearPresets.findIndex(preset => preset.id === autoGearAutoPresetId);\n  if (managedIndex === -1) {\n    setAutoGearAutoPresetId('', { persist: true, skipRender: true });\n    return false;\n  }\n  if (autoGearPresets.length > 1) {\n    setAutoGearAutoPresetId('', { persist: true, skipRender: true });\n    return false;\n  }\n  const managedPreset = autoGearPresets[managedIndex];\n  const updatedPreset = normalizeAutoGearPreset({\n    id: managedPreset.id,\n    label: managedPreset.label,\n    rules: normalizedRules,\n  });\n  if (!updatedPreset) {\n    autoGearPresets.splice(managedIndex, 1);\n    autoGearPresets = sortAutoGearPresets(autoGearPresets.slice());\n    persistAutoGearPresets(autoGearPresets);\n    setAutoGearAutoPresetId('', { persist: true, skipRender: true });\n    setActiveAutoGearPresetId('', { persist: true, skipRender: true });\n    return true;\n  }\n  if (managedPreset.fingerprint !== updatedPreset.fingerprint) {\n    autoGearPresets[managedIndex] = updatedPreset;\n    autoGearPresets = sortAutoGearPresets(autoGearPresets.slice());\n    persistAutoGearPresets(autoGearPresets);\n  }\n  setActiveAutoGearPresetId(updatedPreset.id, { persist: true, skipRender: true });\n  return managedPreset.fingerprint !== updatedPreset.fingerprint;\n}\n\nfunction setActiveAutoGearPresetId(presetId, options = {}) {\n  const normalized = typeof presetId === 'string' ? presetId : '';\n  const persist = options.persist !== false;\n  const skipRender = options.skipRender === true;\n  if (activeAutoGearPresetId === normalized) {\n    if (!skipRender) renderAutoGearPresetsControls();\n    return;\n  }\n  activeAutoGearPresetId = normalized;\n  if (persist) {\n    persistActiveAutoGearPresetId(activeAutoGearPresetId);\n  }\n  if (!skipRender) {\n    renderAutoGearPresetsControls();\n  }\n}\n\nfunction alignActiveAutoGearPreset(options = {}) {\n  const skipRender = options.skipRender === true;\n  const fingerprint = createAutoGearRulesFingerprint(baseAutoGearRules);\n  const matching = autoGearPresets.find(preset => preset.fingerprint === fingerprint) || null;\n  if (matching) {\n    setActiveAutoGearPresetId(matching.id, { persist: true, skipRender: true });\n  } else if (activeAutoGearPresetId) {\n    setActiveAutoGearPresetId('', { persist: true, skipRender: true });\n  }\n  if (!skipRender) {\n    renderAutoGearPresetsControls();\n  }\n}\n\nfunction renderAutoGearPresetsControls() {\n  if (!autoGearPresetSelect) return;\n  const placeholderText = texts[currentLang]?.autoGearPresetPlaceholder\n    || texts.en?.autoGearPresetPlaceholder\n    || 'Custom rules';\n  const presets = sortAutoGearPresets(autoGearPresets.slice());\n  autoGearPresets = presets;\n\n  autoGearPresetSelect.innerHTML = '';\n\n  const placeholderOption = document.createElement('option');\n  placeholderOption.value = '';\n  placeholderOption.textContent = placeholderText;\n  autoGearPresetSelect.appendChild(placeholderOption);\n\n  presets.forEach(preset => {\n    const option = document.createElement('option');\n    option.value = preset.id;\n    option.textContent = preset.label;\n    autoGearPresetSelect.appendChild(option);\n  });\n\n  const targetValue = activeAutoGearPresetId || '';\n  autoGearPresetSelect.value = targetValue;\n  if (!targetValue) {\n    placeholderOption.selected = true;\n  }\n\n  autoGearPresetSelect.disabled = presets.length === 0;\n  autoGearPresetSelect.setAttribute('aria-disabled', presets.length === 0 ? 'true' : 'false');\n\n  if (autoGearDeletePresetButton) {\n    autoGearDeletePresetButton.disabled = !activeAutoGearPresetId;\n  }\n\n}\n\nfunction applyAutoGearBackupVisibility() {\n  const show = !!autoGearBackupsVisible;\n  if (autoGearShowBackupsCheckbox) {\n    autoGearShowBackupsCheckbox.checked = show;\n    autoGearShowBackupsCheckbox.setAttribute('aria-pressed', show ? 'true' : 'false');\n  }\n  if (autoGearBackupsSection) {\n    autoGearBackupsSection.classList.toggle('auto-gear-backups-collapsed', !show);\n    autoGearBackupsSection.setAttribute('aria-expanded', show ? 'true' : 'false');\n  }\n  if (autoGearBackupControls) {\n    autoGearBackupControls.hidden = !show;\n    autoGearBackupControls.setAttribute('aria-hidden', show ? 'false' : 'true');\n  }\n  if (autoGearBackupsHiddenNotice) {\n    autoGearBackupsHiddenNotice.hidden = show;\n  }\n  if (!show) {\n    if (autoGearBackupSelect) autoGearBackupSelect.disabled = true;\n    if (autoGearBackupRestoreButton) autoGearBackupRestoreButton.disabled = true;\n  } else {\n    updateAutoGearBackupRestoreButtonState();\n  }\n}\n\nfunction setAutoGearBackupsVisible(show) {\n  const next = !!show;\n  if (autoGearBackupsVisible === next) {\n    applyAutoGearBackupVisibility();\n    return;\n  }\n  autoGearBackupsVisible = next;\n  persistAutoGearBackupVisibility(autoGearBackupsVisible);\n  if (autoGearBackupsVisible) {\n    renderAutoGearBackupControls();\n  } else {\n    applyAutoGearBackupVisibility();\n  }\n}\n\nfunction handleAutoGearPresetSelection(event) {\n  if (!event || !autoGearPresetSelect) return;\n  if (sharedImportProjectPresetActive) {\n    sharedImportProjectPresetActive = false;\n    sharedImportPreviousPresetId = '';\n  }\n  const presetId = event.target.value;\n  if (!presetId) {\n    setActiveAutoGearPresetId('', { persist: true });\n    return;\n  }\n  const preset = getAutoGearPresetById(presetId);\n  if (!preset) {\n    setActiveAutoGearPresetId('', { persist: true });\n    renderAutoGearPresetsControls();\n    return;\n  }\n  const confirmTemplate = texts[currentLang]?.autoGearPresetApplyConfirm\n    || texts.en?.autoGearPresetApplyConfirm\n    || `Replace your automatic gear rules with the preset \"${preset.label}\"?`;\n  const confirmMessage = confirmTemplate.includes('%s')\n    ? formatWithPlaceholders(confirmTemplate, preset.label)\n    : confirmTemplate;\n  let confirmed = true;\n  if (typeof window !== 'undefined' && typeof window.confirm === 'function') {\n    confirmed = window.confirm(confirmMessage);\n  }\n  if (!confirmed) {\n    autoGearPresetSelect.value = activeAutoGearPresetId || '';\n    return;\n  }\n  setAutoGearRules(preset.rules);\n  updateAutoGearCatalogOptions();\n  renderAutoGearRulesList();\n  const appliedMessage = texts[currentLang]?.autoGearPresetApplied\n    || texts.en?.autoGearPresetApplied\n    || 'Preset applied.';\n  showNotification('success', appliedMessage);\n}\n\nfunction handleAutoGearSavePreset() {\n  const rules = getAutoGearRules();\n  const activePreset = getAutoGearPresetById(activeAutoGearPresetId);\n  const promptTemplate = texts[currentLang]?.autoGearPresetNamePrompt\n    || texts.en?.autoGearPresetNamePrompt\n    || 'Name this preset';\n  const defaultName = activePreset ? activePreset.label : '';\n  if (typeof window === 'undefined' || typeof window.prompt !== 'function') {\n    const requiredMessage = texts[currentLang]?.autoGearPresetNameRequired\n      || texts.en?.autoGearPresetNameRequired\n      || 'Enter a preset name to continue.';\n    if (typeof window !== 'undefined' && typeof window.alert === 'function') {\n      window.alert(requiredMessage);\n    }\n    return;\n  }\n  const response = window.prompt(promptTemplate, defaultName);\n  if (response === null) return;\n  const trimmed = response.trim();\n  if (!trimmed) {\n    const requiredMessage = texts[currentLang]?.autoGearPresetNameRequired\n      || texts.en?.autoGearPresetNameRequired\n      || 'Enter a preset name to continue.';\n    if (typeof window.alert === 'function') {\n      window.alert(requiredMessage);\n    }\n    return;\n  }\n  const normalizedName = trimmed;\n  const existingByName = autoGearPresets.find(preset => preset.label.toLowerCase() === normalizedName.toLowerCase());\n  let targetId = activePreset?.id || '';\n  if (existingByName && existingByName.id !== targetId) {\n    const overwriteTemplate = texts[currentLang]?.autoGearPresetOverwriteConfirm\n      || texts.en?.autoGearPresetOverwriteConfirm\n      || `Replace the existing preset \"${normalizedName}\"?`;\n    const overwriteMessage = overwriteTemplate.includes('%s')\n      ? formatWithPlaceholders(overwriteTemplate, normalizedName)\n      : overwriteTemplate;\n    let overwriteConfirmed = true;\n    if (typeof window.confirm === 'function') {\n      overwriteConfirmed = window.confirm(overwriteMessage);\n    }\n    if (!overwriteConfirmed) {\n      return;\n    }\n    targetId = existingByName.id;\n  }\n  const presetId = targetId || generateAutoGearId('preset');\n  const normalizedPreset = normalizeAutoGearPreset({ id: presetId, label: normalizedName, rules });\n  if (!normalizedPreset) {\n    const requiredMessage = texts[currentLang]?.autoGearPresetNameRequired\n      || texts.en?.autoGearPresetNameRequired\n      || 'Enter a preset name to continue.';\n    if (typeof window.alert === 'function') {\n      window.alert(requiredMessage);\n    }\n    return;\n  }\n  if (autoGearAutoPresetId) {\n    setAutoGearAutoPresetId('', { persist: true, skipRender: true });\n  }\n  const existingIndex = autoGearPresets.findIndex(preset => preset.id === normalizedPreset.id);\n  if (existingIndex >= 0) {\n    autoGearPresets[existingIndex] = normalizedPreset;\n  } else {\n    autoGearPresets.push(normalizedPreset);\n  }\n  autoGearPresets = sortAutoGearPresets(autoGearPresets.slice());\n  persistAutoGearPresets(autoGearPresets);\n  setActiveAutoGearPresetId(normalizedPreset.id, { persist: true, skipRender: true });\n  renderAutoGearPresetsControls();\n  const savedMessage = texts[currentLang]?.autoGearPresetSaved\n    || texts.en?.autoGearPresetSaved\n    || 'Automatic gear preset saved.';\n  showNotification('success', savedMessage);\n}\n\nfunction handleAutoGearDeletePreset() {\n  if (!activeAutoGearPresetId) return;\n  const preset = getAutoGearPresetById(activeAutoGearPresetId);\n  const label = preset ? preset.label : '';\n  const confirmTemplate = texts[currentLang]?.autoGearPresetDeleteConfirm\n    || texts.en?.autoGearPresetDeleteConfirm\n    || 'Delete this preset?';\n  const confirmMessage = label && confirmTemplate.includes('%s')\n    ? formatWithPlaceholders(confirmTemplate, label)\n    : confirmTemplate;\n  let confirmed = true;\n  if (typeof window !== 'undefined' && typeof window.confirm === 'function') {\n    confirmed = window.confirm(confirmMessage);\n  }\n  if (!confirmed) return;\n  if (autoGearAutoPresetId && autoGearAutoPresetId === activeAutoGearPresetId) {\n    setAutoGearAutoPresetId('', { persist: true, skipRender: true });\n  }\n  autoGearPresets = autoGearPresets.filter(entry => entry.id !== activeAutoGearPresetId);\n  autoGearPresets = sortAutoGearPresets(autoGearPresets.slice());\n  persistAutoGearPresets(autoGearPresets);\n  setActiveAutoGearPresetId('', { persist: true, skipRender: true });\n  renderAutoGearPresetsControls();\n  const deletedMessage = texts[currentLang]?.autoGearPresetDeleted\n    || texts.en?.autoGearPresetDeleted\n    || 'Automatic gear preset deleted.';\n  showNotification('success', deletedMessage);\n}\n\nfunction handleAutoGearShowBackupsToggle() {\n  if (!autoGearShowBackupsCheckbox) return;\n  setAutoGearBackupsVisible(autoGearShowBackupsCheckbox.checked);\n}\n\nfunction renderAutoGearBackupControls() {\n  if (!autoGearBackupSelect || !autoGearBackupEmptyMessage) return;\n\n  const previousValue = autoGearBackupSelect.value;\n  const placeholderText = getAutoGearBackupSelectPlaceholder();\n\n  autoGearBackupSelect.innerHTML = '';\n\n  const placeholder = document.createElement('option');\n  placeholder.value = '';\n  placeholder.textContent = placeholderText;\n  placeholder.disabled = true;\n  autoGearBackupSelect.appendChild(placeholder);\n\n  const availableIds = new Set(autoGearBackups.map(backup => backup.id));\n  const retainSelection = previousValue && availableIds.has(previousValue);\n\n  autoGearBackups.forEach(backup => {\n    const option = document.createElement('option');\n    option.value = backup.id;\n    option.textContent = formatAutoGearBackupMeta(backup);\n    if (backup.createdAt) {\n      option.title = backup.createdAt;\n    }\n    if (retainSelection && backup.id === previousValue) {\n      option.selected = true;\n    }\n    autoGearBackupSelect.appendChild(option);\n  });\n\n  if (!autoGearBackups.length) {\n    placeholder.selected = true;\n    autoGearBackupSelect.value = '';\n    autoGearBackupSelect.disabled = true;\n    autoGearBackupEmptyMessage.hidden = false;\n  } else {\n    autoGearBackupSelect.disabled = false;\n    autoGearBackupEmptyMessage.hidden = true;\n    if (retainSelection) {\n      placeholder.selected = false;\n      autoGearBackupSelect.value = previousValue;\n    } else {\n      placeholder.selected = true;\n      autoGearBackupSelect.value = '';\n    }\n  }\n\n  updateAutoGearBackupRestoreButtonState();\n  applyAutoGearBackupVisibility();\n}\n\nfunction renderAutoGearRulesList() {\n  if (!autoGearRulesList) return;\n  autoGearRulesList.innerHTML = '';\n  const rules = getAutoGearRules();\n  if (!rules.length) {\n    const empty = document.createElement('p');\n    empty.className = 'auto-gear-empty';\n    empty.textContent = texts[currentLang]?.autoGearNoRules\n      || texts.en?.autoGearNoRules\n      || 'No custom rules yet.';\n    autoGearRulesList.appendChild(empty);\n    return;\n  }\n  rules.forEach(rule => {\n    const wrapper = document.createElement('div');\n    wrapper.className = 'auto-gear-rule';\n    wrapper.dataset.ruleId = rule.id;\n    const info = document.createElement('div');\n    info.className = 'auto-gear-rule-info';\n    const title = document.createElement('p');\n    title.className = 'auto-gear-rule-title';\n    const scenarioList = Array.isArray(rule.scenarios) ? rule.scenarios : [];\n    const matteboxList = Array.isArray(rule.mattebox) ? rule.mattebox : [];\n    const cameraHandleList = Array.isArray(rule.cameraHandle) ? rule.cameraHandle : [];\n    const rawViewfinderList = Array.isArray(rule.viewfinderExtension) ? rule.viewfinderExtension : [];\n    const viewfinderDisplayList = rawViewfinderList.map(getViewfinderFallbackLabel);\n    const videoDistributionList = Array.isArray(rule.videoDistribution) ? rule.videoDistribution : [];\n    const videoDistributionDisplayList = videoDistributionList.map(getVideoDistributionFallbackLabel);\n    const cameraList = Array.isArray(rule.camera) ? rule.camera : [];\n    const monitorList = Array.isArray(rule.monitor) ? rule.monitor : [];\n    const wirelessList = Array.isArray(rule.wireless) ? rule.wireless : [];\n    const motorsList = Array.isArray(rule.motors) ? rule.motors : [];\n    const controllersList = Array.isArray(rule.controllers) ? rule.controllers : [];\n    const distanceList = Array.isArray(rule.distance) ? rule.distance : [];\n    const fallbackCandidates = [\n      cameraList,\n      monitorList,\n      wirelessList,\n      motorsList,\n      controllersList,\n      distanceList,\n      matteboxList,\n      cameraHandleList,\n      viewfinderDisplayList,\n      videoDistributionDisplayList,\n    ];\n    const fallbackSource = scenarioList.length\n      ? scenarioList\n      : (fallbackCandidates.find(list => Array.isArray(list) && list.length) || []);\n    const fallbackTitle = fallbackSource.length ? fallbackSource.join(' + ') : '';\n    title.textContent = rule.label || fallbackTitle;\n    info.appendChild(title);\n    if (scenarioList.length) {\n      const scenarioLabel = texts[currentLang]?.projectFields?.requiredScenarios\n        || texts.en?.projectFields?.requiredScenarios\n        || 'Required Scenarios';\n      const scenarioMeta = document.createElement('p');\n      scenarioMeta.className = 'auto-gear-rule-meta';\n      scenarioMeta.textContent = `${scenarioLabel}: ${scenarioList.join(' + ')}`;\n      info.appendChild(scenarioMeta);\n    }\n    if (cameraList.length) {\n      const cameraLabelText = texts[currentLang]?.autoGearCameraLabel\n        || texts.en?.autoGearCameraLabel\n        || 'Camera selection';\n      const cameraMeta = document.createElement('p');\n      cameraMeta.className = 'auto-gear-rule-meta';\n      cameraMeta.textContent = `${cameraLabelText}: ${cameraList.join(' + ')}`;\n      info.appendChild(cameraMeta);\n    }\n    if (monitorList.length) {\n      const monitorLabelText = texts[currentLang]?.autoGearMonitorLabel\n        || texts.en?.autoGearMonitorLabel\n        || 'Onboard monitors';\n      const monitorMeta = document.createElement('p');\n      monitorMeta.className = 'auto-gear-rule-meta';\n      monitorMeta.textContent = `${monitorLabelText}: ${monitorList.join(' + ')}`;\n      info.appendChild(monitorMeta);\n    }\n    if (wirelessList.length) {\n      const wirelessLabelText = texts[currentLang]?.autoGearWirelessLabel\n        || texts.en?.autoGearWirelessLabel\n        || 'Wireless transmitters';\n      const wirelessMeta = document.createElement('p');\n      wirelessMeta.className = 'auto-gear-rule-meta';\n      wirelessMeta.textContent = `${wirelessLabelText}: ${wirelessList.join(' + ')}`;\n      info.appendChild(wirelessMeta);\n    }\n    if (motorsList.length) {\n      const motorsLabelText = texts[currentLang]?.autoGearMotorsLabel\n        || texts.en?.autoGearMotorsLabel\n        || 'FIZ motors';\n      const motorsMeta = document.createElement('p');\n      motorsMeta.className = 'auto-gear-rule-meta';\n      motorsMeta.textContent = `${motorsLabelText}: ${motorsList.join(' + ')}`;\n      info.appendChild(motorsMeta);\n    }\n    if (controllersList.length) {\n      const controllersLabelText = texts[currentLang]?.autoGearControllersLabel\n        || texts.en?.autoGearControllersLabel\n        || 'FIZ controllers';\n      const controllersMeta = document.createElement('p');\n      controllersMeta.className = 'auto-gear-rule-meta';\n      controllersMeta.textContent = `${controllersLabelText}: ${controllersList.join(' + ')}`;\n      info.appendChild(controllersMeta);\n    }\n    if (distanceList.length) {\n      const distanceLabelText = texts[currentLang]?.autoGearDistanceLabel\n        || texts.en?.autoGearDistanceLabel\n        || 'FIZ distance devices';\n      const distanceMeta = document.createElement('p');\n      distanceMeta.className = 'auto-gear-rule-meta';\n      distanceMeta.textContent = `${distanceLabelText}: ${distanceList.join(' + ')}`;\n      info.appendChild(distanceMeta);\n    }\n    if (matteboxList.length) {\n      const matteboxLabelText = texts[currentLang]?.autoGearMatteboxLabel\n        || texts.en?.autoGearMatteboxLabel\n        || 'Mattebox options';\n      const matteboxMeta = document.createElement('p');\n      matteboxMeta.className = 'auto-gear-rule-meta';\n      matteboxMeta.textContent = `${matteboxLabelText}: ${matteboxList.join(' + ')}`;\n      info.appendChild(matteboxMeta);\n    }\n    if (cameraHandleList.length) {\n      const cameraHandleLabelText = texts[currentLang]?.autoGearCameraHandleLabel\n        || texts.en?.autoGearCameraHandleLabel\n        || 'Camera handles';\n      const cameraHandleMeta = document.createElement('p');\n      cameraHandleMeta.className = 'auto-gear-rule-meta';\n      cameraHandleMeta.textContent = `${cameraHandleLabelText}: ${cameraHandleList.join(' + ')}`;\n      info.appendChild(cameraHandleMeta);\n    }\n    if (rawViewfinderList.length) {\n      const viewfinderLabelText = texts[currentLang]?.autoGearViewfinderExtensionLabel\n        || texts.en?.autoGearViewfinderExtensionLabel\n        || 'Viewfinder extension';\n      const viewfinderMeta = document.createElement('p');\n      viewfinderMeta.className = 'auto-gear-rule-meta';\n      viewfinderMeta.textContent = `${viewfinderLabelText}: ${viewfinderDisplayList.join(' + ')}`;\n      info.appendChild(viewfinderMeta);\n    }\n    if (videoDistributionDisplayList.length) {\n      const videoDistLabelText = texts[currentLang]?.autoGearVideoDistributionLabel\n        || texts.en?.autoGearVideoDistributionLabel\n        || 'Video distribution';\n      const videoDistMeta = document.createElement('p');\n      videoDistMeta.className = 'auto-gear-rule-meta';\n      videoDistMeta.textContent = `${videoDistLabelText}: ${videoDistributionDisplayList.join(' + ')}`;\n      info.appendChild(videoDistMeta);\n    }\n    const addSummary = formatAutoGearCount(rule.add.length, 'autoGearAddsCountOne', 'autoGearAddsCountOther');\n    const removeSummary = formatAutoGearCount(rule.remove.length, 'autoGearRemovalsCountOne', 'autoGearRemovalsCountOther');\n    const countsMeta = document.createElement('p');\n    countsMeta.className = 'auto-gear-rule-meta';\n    countsMeta.textContent = `${addSummary} \xB7 ${removeSummary}`;\n    info.appendChild(countsMeta);\n    if (rule.add.length) {\n      const addsLabel = document.createElement('p');\n      addsLabel.className = 'auto-gear-rule-meta auto-gear-rule-items-label';\n      addsLabel.textContent = texts[currentLang]?.autoGearAddsListLabel\n        || texts.en?.autoGearAddsListLabel\n        || 'Adds';\n      info.appendChild(addsLabel);\n      const addList = document.createElement('ul');\n      addList.className = 'auto-gear-rule-items';\n      rule.add.forEach(item => {\n        const listItem = document.createElement('li');\n        listItem.className = 'auto-gear-rule-item';\n        listItem.textContent = formatAutoGearItemSummary(item);\n        addList.appendChild(listItem);\n      });\n      info.appendChild(addList);\n    }\n    wrapper.appendChild(info);\n    const actions = document.createElement('div');\n    actions.className = 'auto-gear-rule-actions';\n    const editBtn = document.createElement('button');\n    editBtn.type = 'button';\n    editBtn.className = 'auto-gear-edit';\n    editBtn.dataset.ruleId = rule.id;\n    const editLabel = texts[currentLang]?.editBtn || texts.en?.editBtn || 'Edit';\n    editBtn.textContent = editLabel;\n    editBtn.setAttribute('data-help', editLabel);\n    actions.appendChild(editBtn);\n    const deleteBtn = document.createElement('button');\n    deleteBtn.type = 'button';\n    deleteBtn.className = 'auto-gear-delete';\n    deleteBtn.dataset.ruleId = rule.id;\n    const deleteLabel = texts[currentLang]?.autoGearDeleteRule\n      || texts.en?.autoGearDeleteRule\n      || 'Delete';\n    deleteBtn.textContent = deleteLabel;\n    deleteBtn.setAttribute('data-help', deleteLabel);\n    actions.appendChild(deleteBtn);\n    wrapper.appendChild(actions);\n    autoGearRulesList.appendChild(wrapper);\n  });\n}\n\nfunction renderAutoGearDraftLists() {\n  if (!autoGearEditorDraft) {\n    if (autoGearAddList) autoGearAddList.innerHTML = '';\n    if (autoGearRemoveList) autoGearRemoveList.innerHTML = '';\n    return;\n  }\n  const renderList = (element, items, type) => {\n    if (!element) return;\n    element.innerHTML = '';\n    if (!items.length) {\n      const empty = document.createElement('li');\n      empty.className = 'auto-gear-empty';\n      empty.textContent = texts[currentLang]?.autoGearEmptyList\n        || texts.en?.autoGearEmptyList\n        || 'No items yet.';\n      element.appendChild(empty);\n      return;\n    }\n    items.forEach(item => {\n      const li = document.createElement('li');\n      li.className = 'auto-gear-item';\n      const span = document.createElement('span');\n      span.textContent = formatAutoGearItemSummary(item, { includeSign: true, listType: type });\n      li.appendChild(span);\n      const removeBtn = document.createElement('button');\n      removeBtn.type = 'button';\n      removeBtn.className = 'auto-gear-remove-entry';\n      removeBtn.dataset.listType = type;\n      removeBtn.dataset.itemId = item.id;\n      const removeLabel = texts[currentLang]?.autoGearListRemove\n        || texts.en?.autoGearListRemove\n        || 'Remove';\n      removeBtn.textContent = removeLabel;\n      removeBtn.setAttribute('data-help', removeLabel);\n      li.appendChild(removeBtn);\n      element.appendChild(li);\n    });\n  };\n  renderList(autoGearAddList, autoGearEditorDraft.add, 'add');\n  renderList(autoGearRemoveList, autoGearEditorDraft.remove, 'remove');\n}\n\nfunction openAutoGearEditor(ruleId) {\n  if (!autoGearEditor) return;\n  const rules = getAutoGearRules();\n  const existing = ruleId ? rules.find(rule => rule.id === ruleId) : null;\n  autoGearEditorDraft = createAutoGearDraft(existing);\n  autoGearEditor.hidden = false;\n  if (autoGearRuleNameInput) {\n    autoGearRuleNameInput.value = autoGearEditorDraft.label || '';\n  }\n  refreshAutoGearScenarioOptions(autoGearEditorDraft.scenarios);\n  refreshAutoGearMatteboxOptions(autoGearEditorDraft.mattebox);\n  refreshAutoGearCameraHandleOptions(autoGearEditorDraft.cameraHandle);\n  refreshAutoGearViewfinderExtensionOptions(autoGearEditorDraft.viewfinderExtension);\n  refreshAutoGearVideoDistributionOptions(autoGearEditorDraft.videoDistribution);\n  refreshAutoGearCameraOptions(autoGearEditorDraft.camera);\n  refreshAutoGearMonitorOptions(autoGearEditorDraft.monitor);\n  refreshAutoGearWirelessOptions(autoGearEditorDraft.wireless);\n  refreshAutoGearMotorsOptions(autoGearEditorDraft.motors);\n  refreshAutoGearControllersOptions(autoGearEditorDraft.controllers);\n  refreshAutoGearDistanceOptions(autoGearEditorDraft.distance);\n  populateAutoGearCategorySelect(autoGearAddCategorySelect, autoGearEditorDraft.add[0]?.category || '');\n  populateAutoGearCategorySelect(autoGearRemoveCategorySelect, autoGearEditorDraft.remove[0]?.category || '');\n  syncAutoGearMonitorFieldVisibility();\n  if (autoGearAddNameInput) autoGearAddNameInput.value = '';\n  if (autoGearAddQuantityInput) autoGearAddQuantityInput.value = '1';\n  if (autoGearAddScreenSizeInput) autoGearAddScreenSizeInput.value = '';\n  if (autoGearAddSelectorTypeSelect) autoGearAddSelectorTypeSelect.value = 'none';\n  if (autoGearAddSelectorDefaultInput) autoGearAddSelectorDefaultInput.value = '';\n  if (autoGearAddSelectorIncludeCheckbox) autoGearAddSelectorIncludeCheckbox.checked = false;\n  if (autoGearAddNotesInput) autoGearAddNotesInput.value = '';\n  if (autoGearRemoveNameInput) autoGearRemoveNameInput.value = '';\n  if (autoGearRemoveQuantityInput) autoGearRemoveQuantityInput.value = '1';\n  if (autoGearRemoveScreenSizeInput) autoGearRemoveScreenSizeInput.value = '';\n  if (autoGearRemoveSelectorTypeSelect) autoGearRemoveSelectorTypeSelect.value = 'none';\n  if (autoGearRemoveSelectorDefaultInput) autoGearRemoveSelectorDefaultInput.value = '';\n  if (autoGearRemoveSelectorIncludeCheckbox) autoGearRemoveSelectorIncludeCheckbox.checked = false;\n  if (autoGearRemoveNotesInput) autoGearRemoveNotesInput.value = '';\n  renderAutoGearDraftLists();\n  if (autoGearRuleNameInput) autoGearRuleNameInput.focus();\n}\n\nfunction closeAutoGearEditor() {\n  if (!autoGearEditor) return;\n  autoGearEditor.hidden = true;\n  autoGearEditorDraft = null;\n  if (autoGearRuleNameInput) autoGearRuleNameInput.value = '';\n  refreshAutoGearScenarioOptions([]);\n  refreshAutoGearMatteboxOptions([]);\n  refreshAutoGearCameraHandleOptions([]);\n  refreshAutoGearViewfinderExtensionOptions([]);\n  refreshAutoGearVideoDistributionOptions([]);\n  refreshAutoGearCameraOptions([]);\n  refreshAutoGearMonitorOptions([]);\n  refreshAutoGearWirelessOptions([]);\n  refreshAutoGearMotorsOptions([]);\n  refreshAutoGearControllersOptions([]);\n  refreshAutoGearDistanceOptions([]);\n  if (autoGearAddNameInput) autoGearAddNameInput.value = '';\n  if (autoGearAddQuantityInput) autoGearAddQuantityInput.value = '1';\n  if (autoGearAddScreenSizeInput) autoGearAddScreenSizeInput.value = '';\n  if (autoGearAddSelectorTypeSelect) autoGearAddSelectorTypeSelect.value = 'none';\n  if (autoGearAddSelectorDefaultInput) autoGearAddSelectorDefaultInput.value = '';\n  if (autoGearAddSelectorIncludeCheckbox) autoGearAddSelectorIncludeCheckbox.checked = false;\n  if (autoGearAddNotesInput) autoGearAddNotesInput.value = '';\n  if (autoGearRemoveNameInput) autoGearRemoveNameInput.value = '';\n  if (autoGearRemoveQuantityInput) autoGearRemoveQuantityInput.value = '1';\n  if (autoGearRemoveScreenSizeInput) autoGearRemoveScreenSizeInput.value = '';\n  if (autoGearRemoveSelectorTypeSelect) autoGearRemoveSelectorTypeSelect.value = 'none';\n  if (autoGearRemoveSelectorDefaultInput) autoGearRemoveSelectorDefaultInput.value = '';\n  if (autoGearRemoveSelectorIncludeCheckbox) autoGearRemoveSelectorIncludeCheckbox.checked = false;\n  if (autoGearRemoveNotesInput) autoGearRemoveNotesInput.value = '';\n  syncAutoGearMonitorFieldVisibility();\n}\n\nfunction addAutoGearDraftItem(type) {\n  if (!autoGearEditorDraft) return;\n  const isAdd = type === 'add';\n  const nameInput = isAdd ? autoGearAddNameInput : autoGearRemoveNameInput;\n  const categorySelect = isAdd ? autoGearAddCategorySelect : autoGearRemoveCategorySelect;\n  const quantityInput = isAdd ? autoGearAddQuantityInput : autoGearRemoveQuantityInput;\n  const screenSizeInput = isAdd ? autoGearAddScreenSizeInput : autoGearRemoveScreenSizeInput;\n  const selectorTypeSelect = isAdd ? autoGearAddSelectorTypeSelect : autoGearRemoveSelectorTypeSelect;\n  const selectorDefaultInput = isAdd ? autoGearAddSelectorDefaultInput : autoGearRemoveSelectorDefaultInput;\n  const selectorIncludeCheckbox = isAdd ? autoGearAddSelectorIncludeCheckbox : autoGearRemoveSelectorIncludeCheckbox;\n  const notesInput = isAdd ? autoGearAddNotesInput : autoGearRemoveNotesInput;\n  if (!nameInput || !categorySelect || !quantityInput) return;\n  const parsedNames = parseAutoGearDraftNames(nameInput.value);\n  if (!parsedNames.length) {\n    const message = texts[currentLang]?.autoGearItemNameRequired\n      || texts.en?.autoGearItemNameRequired\n      || 'Enter an item name first.';\n    window.alert(message);\n    return;\n  }\n  const baseValues = {\n    category: categorySelect.value || '',\n    quantity: normalizeAutoGearQuantity(quantityInput.value),\n    screenSize: screenSizeInput ? screenSizeInput.value : '',\n    selectorType: selectorTypeSelect ? selectorTypeSelect.value : 'none',\n    selectorDefault: selectorDefaultInput ? selectorDefaultInput.value : '',\n    selectorEnabled: selectorIncludeCheckbox ? !!selectorIncludeCheckbox.checked : false,\n    notes: notesInput ? notesInput.value : '',\n  };\n  if (!isAutoGearMonitoringCategory(baseValues.category)) {\n    baseValues.screenSize = '';\n    baseValues.selectorType = 'none';\n    baseValues.selectorDefault = '';\n    baseValues.selectorEnabled = false;\n  }\n  parsedNames.forEach(entry => {\n    const quantity = Object.prototype.hasOwnProperty.call(entry, 'quantity')\n      ? normalizeAutoGearQuantity(entry.quantity)\n      : baseValues.quantity;\n    const targetType = entry.listType || (isAdd ? 'add' : 'remove');\n    const targetList = targetType === 'remove' ? autoGearEditorDraft.remove : autoGearEditorDraft.add;\n    const itemData = normalizeAutoGearItem({\n      id: generateAutoGearId('item'),\n      name: entry.name,\n      category: baseValues.category,\n      quantity,\n      screenSize: baseValues.screenSize,\n      selectorType: baseValues.selectorType,\n      selectorDefault: baseValues.selectorDefault,\n      selectorEnabled: baseValues.selectorEnabled,\n      notes: baseValues.notes,\n    });\n    if (itemData) {\n      targetList.push(itemData);\n    }\n  });\n  nameInput.value = '';\n  quantityInput.value = '1';\n  if (screenSizeInput) screenSizeInput.value = '';\n  if (selectorTypeSelect) selectorTypeSelect.value = 'none';\n  if (selectorDefaultInput) selectorDefaultInput.value = '';\n  if (selectorIncludeCheckbox) selectorIncludeCheckbox.checked = false;\n  if (notesInput) notesInput.value = '';\n  renderAutoGearDraftLists();\n  updateAutoGearCatalogOptions();\n}\n\nfunction saveAutoGearRuleFromEditor() {\n  if (!autoGearEditorDraft) return;\n  const scenarios = autoGearScenariosSelect\n    ? Array.from(autoGearScenariosSelect.selectedOptions || [])\n        .map(option => option.value)\n        .filter(Boolean)\n    : [];\n  const matteboxSelections = autoGearMatteboxSelect\n    ? Array.from(autoGearMatteboxSelect.selectedOptions || [])\n        .map(option => option.value)\n        .filter(Boolean)\n    : [];\n  const cameraHandleSelections = autoGearCameraHandleSelect\n    ? Array.from(autoGearCameraHandleSelect.selectedOptions || [])\n        .map(option => option.value)\n        .filter(Boolean)\n    : [];\n  const viewfinderSelections = autoGearViewfinderExtensionSelect\n    ? Array.from(autoGearViewfinderExtensionSelect.selectedOptions || [])\n        .map(option => option.value)\n        .filter(value => typeof value === 'string' && value.trim())\n    : [];\n  let videoDistributionSelections = autoGearVideoDistributionSelect\n    ? Array.from(autoGearVideoDistributionSelect.selectedOptions || [])\n        .map(option => option.value)\n        .filter(Boolean)\n    : [];\n  if (videoDistributionSelections.includes('__none__') && videoDistributionSelections.length > 1) {\n    videoDistributionSelections = videoDistributionSelections.filter(value => value !== '__none__');\n  }\n  const cameraSelections = autoGearCameraSelect\n    ? Array.from(autoGearCameraSelect.selectedOptions || [])\n        .map(option => option.value)\n        .filter(value => typeof value === 'string' && value.trim())\n    : [];\n  const monitorSelections = autoGearMonitorSelect\n    ? Array.from(autoGearMonitorSelect.selectedOptions || [])\n        .map(option => option.value)\n        .filter(value => typeof value === 'string' && value.trim())\n    : [];\n  const wirelessSelections = autoGearWirelessSelect\n    ? Array.from(autoGearWirelessSelect.selectedOptions || [])\n        .map(option => option.value)\n        .filter(value => typeof value === 'string' && value.trim())\n    : [];\n  const motorSelections = autoGearMotorsSelect\n    ? Array.from(autoGearMotorsSelect.selectedOptions || [])\n        .map(option => option.value)\n        .filter(value => typeof value === 'string' && value.trim())\n    : [];\n  const controllerSelections = autoGearControllersSelect\n    ? Array.from(autoGearControllersSelect.selectedOptions || [])\n        .map(option => option.value)\n        .filter(value => typeof value === 'string' && value.trim())\n    : [];\n  const distanceSelections = autoGearDistanceSelect\n    ? Array.from(autoGearDistanceSelect.selectedOptions || [])\n        .map(option => option.value)\n        .filter(value => typeof value === 'string' && value.trim())\n    : [];\n  if (\n    !scenarios.length\n    && !matteboxSelections.length\n    && !cameraHandleSelections.length\n    && !viewfinderSelections.length\n    && !videoDistributionSelections.length\n    && !cameraSelections.length\n    && !monitorSelections.length\n    && !wirelessSelections.length\n    && !motorSelections.length\n    && !controllerSelections.length\n    && !distanceSelections.length\n  ) {\n    const message = texts[currentLang]?.autoGearRuleConditionRequired\n      || texts.en?.autoGearRuleConditionRequired\n      || texts[currentLang]?.autoGearRuleScenarioRequired\n      || texts.en?.autoGearRuleScenarioRequired\n      || 'Select at least one scenario, mattebox option, camera handle, viewfinder extension or video distribution before saving.';\n    window.alert(message);\n    return;\n  }\n  if (autoGearRuleNameInput) {\n    autoGearEditorDraft.label = autoGearRuleNameInput.value.trim();\n  }\n  autoGearEditorDraft.scenarios = scenarios;\n  autoGearEditorDraft.mattebox = matteboxSelections;\n  autoGearEditorDraft.cameraHandle = cameraHandleSelections;\n  autoGearEditorDraft.viewfinderExtension = viewfinderSelections;\n  autoGearEditorDraft.videoDistribution = videoDistributionSelections;\n  autoGearEditorDraft.camera = cameraSelections;\n  autoGearEditorDraft.monitor = monitorSelections;\n  autoGearEditorDraft.wireless = wirelessSelections;\n  autoGearEditorDraft.motors = motorSelections;\n  autoGearEditorDraft.controllers = controllerSelections;\n  autoGearEditorDraft.distance = distanceSelections;\n  if (!autoGearEditorDraft.add.length && !autoGearEditorDraft.remove.length) {\n    const message = texts[currentLang]?.autoGearRuleNeedsItems\n      || texts.en?.autoGearRuleNeedsItems\n      || 'Add at least one item to add or remove.';\n    window.alert(message);\n    return;\n  }\n  const draftRule = normalizeAutoGearRule(autoGearEditorDraft);\n  if (!draftRule) return;\n  const rules = getAutoGearRules();\n  const index = rules.findIndex(rule => rule.id === draftRule.id);\n  if (index >= 0) {\n    rules[index] = draftRule;\n  } else {\n    rules.push(draftRule);\n  }\n  setAutoGearRules(rules);\n  updateAutoGearCatalogOptions();\n  renderAutoGearRulesList();\n  const successMessage = texts[currentLang]?.autoGearRuleSaved\n    || texts.en?.autoGearRuleSaved\n    || 'Automatic gear rule saved.';\n  showNotification('success', successMessage);\n  closeAutoGearEditor();\n}\n\nfunction deleteAutoGearRule(ruleId) {\n  const rules = getAutoGearRules();\n  const index = rules.findIndex(rule => rule.id === ruleId);\n  if (index < 0) return;\n  const confirmation = texts[currentLang]?.autoGearDeleteConfirm\n    || texts.en?.autoGearDeleteConfirm\n    || 'Delete this rule?';\n  if (!window.confirm(confirmation)) return;\n  const backupName = ensureAutoBackupBeforeDeletion('delete automatic gear rule');\n  if (!backupName) return;\n  rules.splice(index, 1);\n  setAutoGearRules(rules);\n  updateAutoGearCatalogOptions();\n  renderAutoGearRulesList();\n  if (autoGearEditorDraft && autoGearEditorDraft.id === ruleId) {\n    closeAutoGearEditor();\n  }\n}\n\nfunction parseAutoGearImportPayload(data) {\n  if (Array.isArray(data)) return data;\n  if (!data || typeof data !== 'object') return null;\n  if (Array.isArray(data.rules)) return data.rules;\n  if (Array.isArray(data.autoGearRules)) return data.autoGearRules;\n  if (data.data && Array.isArray(data.data.autoGearRules)) {\n    return data.data.autoGearRules;\n  }\n  return null;\n}\n\nfunction importAutoGearRulesFromData(data, options = {}) {\n  const parsed = parseAutoGearImportPayload(data);\n  if (parsed === null) {\n    throw new Error('Invalid automatic gear rules import payload');\n  }\n  setAutoGearRules(Array.isArray(parsed) ? parsed : []);\n  closeAutoGearEditor();\n  renderAutoGearRulesList();\n  updateAutoGearCatalogOptions();\n  if (!options.silent) {\n    const message = texts[currentLang]?.autoGearImportSuccess\n      || texts.en?.autoGearImportSuccess\n      || 'Automatic gear rules imported.';\n    showNotification('success', message);\n  }\n  return getAutoGearRules();\n}\n\nfunction formatAutoGearExportFilename(date) {\n  const { iso } = formatFullBackupFilename(date);\n  const safeIso = iso.replace(/[:]/g, '-');\n  return `${safeIso} auto gear rules.json`;\n}\n\nfunction exportAutoGearRules() {\n  if (typeof document === 'undefined') return null;\n  try {\n    const rules = getBaseAutoGearRules();\n    const payload = {\n      type: 'camera-power-planner/auto-gear-rules',\n      version: APP_VERSION,\n      createdAt: new Date().toISOString(),\n      rules,\n    };\n    const json = JSON.stringify(payload, null, 2);\n    if (typeof Blob !== 'function' || !URL || typeof URL.createObjectURL !== 'function') {\n      throw new Error('Blob or URL APIs unavailable');\n    }\n    const blob = new Blob([json], { type: 'application/json' });\n    const url = URL.createObjectURL(blob);\n    const anchor = document.createElement('a');\n    anchor.href = url;\n    const fileName = formatAutoGearExportFilename(new Date());\n    anchor.download = fileName;\n    document.body.appendChild(anchor);\n    anchor.click();\n    document.body.removeChild(anchor);\n    if (typeof URL.revokeObjectURL === 'function') {\n      URL.revokeObjectURL(url);\n    }\n    const message = texts[currentLang]?.autoGearExportSuccess\n      || texts.en?.autoGearExportSuccess\n      || 'Automatic gear rules downloaded.';\n    showNotification('success', message);\n    return fileName;\n  } catch (error) {\n    console.warn('Automatic gear rules export failed', error);\n    const message = texts[currentLang]?.autoGearExportError\n      || texts.en?.autoGearExportError\n      || 'Automatic gear rules export failed.';\n    showNotification('error', message);\n    return null;\n  }\n}\n\nfunction createAutoGearBackup() {\n  if (!autoGearRulesDirtySinceBackup) return false;\n  const rules = getBaseAutoGearRules();\n  const signature = stableStringify(rules);\n  if (signature === autoGearRulesLastBackupSignature) {\n    autoGearRulesDirtySinceBackup = false;\n    return false;\n  }\n  const entry = {\n    id: generateAutoGearId('backup'),\n    createdAt: new Date().toISOString(),\n    rules,\n  };\n  const updatedBackups = [entry, ...autoGearBackups].slice(0, AUTO_GEAR_BACKUP_LIMIT);\n  try {\n    persistAutoGearBackups(updatedBackups);\n    autoGearBackups = updatedBackups;\n    autoGearRulesLastBackupSignature = signature;\n    autoGearRulesLastPersistedSignature = signature;\n    autoGearRulesDirtySinceBackup = false;\n    renderAutoGearBackupControls();\n    const message = texts[currentLang]?.autoGearBackupSaved\n      || texts.en?.autoGearBackupSaved\n      || 'Automatic gear backup saved.';\n    showNotification('success', message);\n    return true;\n  } catch (error) {\n    console.warn('Automatic gear backup failed', error);\n    autoGearRulesDirtySinceBackup = true;\n    const message = texts[currentLang]?.autoGearBackupFailed\n      || texts.en?.autoGearBackupFailed\n      || 'Automatic gear backup failed.';\n    showNotification('error', message);\n    return false;\n  }\n}\n\nfunction restoreAutoGearBackup(backupId) {\n  if (!backupId) return false;\n  const backup = autoGearBackups.find(entry => entry.id === backupId);\n  if (!backup) return false;\n  const confirmation = texts[currentLang]?.autoGearBackupRestoreConfirm\n    || texts.en?.autoGearBackupRestoreConfirm\n    || 'Replace your automatic gear rules with this backup?';\n  if (typeof window !== 'undefined' && typeof window.confirm === 'function') {\n    if (!window.confirm(confirmation)) return false;\n  }\n  try {\n    setAutoGearRules(Array.isArray(backup.rules) ? backup.rules : []);\n    closeAutoGearEditor();\n    renderAutoGearRulesList();\n    updateAutoGearCatalogOptions();\n    autoGearRulesLastBackupSignature = stableStringify(backup.rules || []);\n    autoGearRulesLastPersistedSignature = autoGearRulesLastBackupSignature;\n    autoGearRulesDirtySinceBackup = false;\n    const message = texts[currentLang]?.autoGearBackupRestoreSuccess\n      || texts.en?.autoGearBackupRestoreSuccess\n      || 'Automatic gear backup restored.';\n    showNotification('success', message);\n    return true;\n  } catch (error) {\n    console.warn('Failed to restore automatic gear backup', error);\n    const message = texts[currentLang]?.autoGearBackupRestoreError\n      || texts.en?.autoGearBackupRestoreError\n      || 'Automatic gear backup restore failed.';\n    showNotification('error', message);\n    return false;\n  }\n}\n\nfunction handleAutoGearImportSelection(event) {\n  const input = event?.target;\n  const file = input && input.files && input.files[0];\n  if (!file) return;\n  const confirmation = texts[currentLang]?.autoGearImportConfirm\n    || texts.en?.autoGearImportConfirm\n    || 'Replace your automatic gear rules with the imported file?';\n  if (typeof window !== 'undefined' && typeof window.confirm === 'function') {\n    if (!window.confirm(confirmation)) {\n      if (input) input.value = '';\n      return;\n    }\n  }\n  if (typeof FileReader === 'undefined') {\n    const errorMsg = texts[currentLang]?.autoGearImportError\n      || texts.en?.autoGearImportError\n      || 'Import failed. Please choose a valid automatic gear rules file.';\n    showNotification('error', errorMsg);\n    if (input) input.value = '';\n    return;\n  }\n  const reader = new FileReader();\n  reader.onload = e => {\n    try {\n      const text = e?.target?.result;\n      const parsed = JSON.parse(typeof text === 'string' ? text : '');\n      importAutoGearRulesFromData(parsed);\n    } catch (error) {\n      console.warn('Automatic gear rules import failed', error);\n      const errorMsg = texts[currentLang]?.autoGearImportError\n        || texts.en?.autoGearImportError\n        || 'Import failed. Please choose a valid automatic gear rules file.';\n      showNotification('error', errorMsg);\n    } finally {\n      if (input) input.value = '';\n    }\n  };\n  reader.onerror = () => {\n    const errorMsg = texts[currentLang]?.autoGearImportError\n      || texts.en?.autoGearImportError\n      || 'Import failed. Please choose a valid automatic gear rules file.';\n    showNotification('error', errorMsg);\n    if (input) input.value = '';\n  };\n  reader.readAsText(file);\n}\n\nlet lastActiveBeforeIosHelp = null;\nlet lastActiveBeforeInstallGuide = null;\nlet currentInstallGuidePlatform = null;\n\nfunction isIosDevice() {\n  if (typeof navigator === 'undefined') return false;\n  const ua = navigator.userAgent || '';\n  const platform = navigator.platform || '';\n  const hasTouch = typeof navigator.maxTouchPoints === 'number' && navigator.maxTouchPoints > 1;\n  return /iphone|ipad|ipod/i.test(ua) || (platform === 'MacIntel' && hasTouch);\n}\n\nfunction isAndroidDevice() {\n  if (typeof navigator === 'undefined') return false;\n  const ua = navigator.userAgent || '';\n  const vendor = navigator.vendor || '';\n  return /android/i.test(ua) || /android/i.test(vendor);\n}\n\nfunction isStandaloneDisplayMode() {\n  if (typeof window === 'undefined') return false;\n  if (typeof window.matchMedia === 'function') {\n    try {\n      if (window.matchMedia('(display-mode: standalone)').matches) {\n        return true;\n      }\n    } catch (error) {\n      console.warn('matchMedia display-mode check failed', error);\n    }\n  }\n  if (typeof navigator !== 'undefined' && typeof navigator.standalone === 'boolean') {\n    return navigator.standalone;\n  }\n  return false;\n}\n\nfunction hasDismissedIosPwaHelp() {\n  try {\n    return localStorage.getItem(IOS_PWA_HELP_STORAGE_KEY) === '1';\n  } catch (error) {\n    console.warn('Could not read iOS PWA help dismissal flag', error);\n    return false;\n  }\n}\n\nfunction markIosPwaHelpDismissed() {\n  try {\n    localStorage.setItem(IOS_PWA_HELP_STORAGE_KEY, '1');\n  } catch (error) {\n    console.warn('Could not store iOS PWA help dismissal', error);\n  }\n}\n\nfunction shouldShowInstallBanner() {\n  if (!installPromptBanner) return false;\n  if (isStandaloneDisplayMode()) return false;\n  return isIosDevice() || isAndroidDevice();\n}\n\nfunction updateInstallBannerVisibility() {\n  if (!installPromptBanner) return;\n  if (shouldShowInstallBanner()) {\n    installPromptBanner.removeAttribute('hidden');\n    updateInstallBannerPosition();\n  } else {\n    installPromptBanner.setAttribute('hidden', '');\n  }\n}\n\nfunction renderInstallGuideContent(platform, lang = currentLang) {\n  if (!installGuideDialog) return;\n  const fallbackTexts = texts.en || {};\n  const langTexts = texts[lang] || fallbackTexts;\n  const isIos = platform === 'ios';\n\n  const titleKey = isIos ? 'installHelpTitleIos' : 'installHelpTitleAndroid';\n  const introKey = isIos ? 'installHelpIntroIos' : 'installHelpIntroAndroid';\n  const stepsKey = isIos ? 'installHelpStepsIos' : 'installHelpStepsAndroid';\n  const noteKey = isIos ? 'installHelpNoteIos' : 'installHelpNoteAndroid';\n\n  const title = langTexts[titleKey] || fallbackTexts[titleKey] || '';\n  if (installGuideTitle) installGuideTitle.textContent = title;\n\n  const intro = langTexts[introKey] || fallbackTexts[introKey] || '';\n  if (installGuideIntro) installGuideIntro.textContent = intro;\n\n  const stepsSource = langTexts[stepsKey];\n  const fallbackStepsSource = fallbackTexts[stepsKey];\n  const toArray = value => {\n    if (!value) return [];\n    return Array.isArray(value) ? value : [value];\n  };\n  const steps = toArray(stepsSource);\n  const fallbackSteps = toArray(fallbackStepsSource);\n  const effectiveSteps = steps.length ? steps : fallbackSteps;\n  if (installGuideSteps) {\n    installGuideSteps.textContent = '';\n    effectiveSteps.forEach(step => {\n      if (!step) return;\n      const li = document.createElement('li');\n      li.textContent = step;\n      installGuideSteps.appendChild(li);\n    });\n  }\n\n  const note = langTexts[noteKey] || fallbackTexts[noteKey] || '';\n  if (installGuideNote) installGuideNote.textContent = note;\n\n  if (installGuideDialog) {\n    installGuideDialog.setAttribute('data-platform', platform);\n  }\n\n  if (!installGuideMigration || !installGuideMigrationTitle || !installGuideMigrationIntro || !installGuideMigrationSteps || !installGuideMigrationNote) {\n    return;\n  }\n\n  if (isIos) {\n    installGuideMigration.removeAttribute('hidden');\n    const migrationTitle = langTexts.installHelpMigrationTitle || fallbackTexts.installHelpMigrationTitle || '';\n    installGuideMigrationTitle.textContent = migrationTitle;\n    const migrationIntro = langTexts.iosPwaHelpIntro || fallbackTexts.iosPwaHelpIntro || '';\n    installGuideMigrationIntro.textContent = migrationIntro;\n    const migrationSteps = [\n      langTexts.iosPwaHelpStep1 || fallbackTexts.iosPwaHelpStep1,\n      langTexts.iosPwaHelpStep2 || fallbackTexts.iosPwaHelpStep2,\n      langTexts.iosPwaHelpStep3 || fallbackTexts.iosPwaHelpStep3,\n      langTexts.iosPwaHelpStep4 || fallbackTexts.iosPwaHelpStep4,\n    ].filter(Boolean);\n    installGuideMigrationSteps.textContent = '';\n    migrationSteps.forEach(step => {\n      const li = document.createElement('li');\n      li.textContent = step;\n      installGuideMigrationSteps.appendChild(li);\n    });\n    const migrationNote = langTexts.iosPwaHelpNote || fallbackTexts.iosPwaHelpNote || '';\n    installGuideMigrationNote.textContent = migrationNote;\n  } else {\n    installGuideMigration.setAttribute('hidden', '');\n    installGuideMigrationTitle.textContent = '';\n    installGuideMigrationIntro.textContent = '';\n    installGuideMigrationSteps.textContent = '';\n    installGuideMigrationNote.textContent = '';\n  }\n}\n\nfunction openInstallGuide(platform) {\n  if (!installGuideDialog) return;\n  currentInstallGuidePlatform = platform;\n  lastActiveBeforeInstallGuide = document.activeElement;\n  renderInstallGuideContent(platform);\n  installGuideDialog.removeAttribute('hidden');\n  const focusTarget = installGuideClose || installGuideDialog.querySelector('button, [href], [tabindex]:not([tabindex=\"-1\"])');\n  if (focusTarget && typeof focusTarget.focus === 'function') {\n    focusTarget.focus();\n  }\n}\n\nfunction closeInstallGuide() {\n  if (!installGuideDialog) return;\n  installGuideDialog.setAttribute('hidden', '');\n  currentInstallGuidePlatform = null;\n  if (lastActiveBeforeInstallGuide && typeof lastActiveBeforeInstallGuide.focus === 'function') {\n    lastActiveBeforeInstallGuide.focus();\n  }\n}\n\nfunction setupInstallBanner() {\n  if (!installPromptBanner) return;\n\n  installPromptBanner.addEventListener('click', () => {\n    const platform = isIosDevice() ? 'ios' : 'android';\n    openInstallGuide(platform);\n  });\n\n  if (installGuideClose) {\n    installGuideClose.addEventListener('click', closeInstallGuide);\n  }\n\n  if (installGuideDialog) {\n    installGuideDialog.addEventListener('click', event => {\n      if (event.target === installGuideDialog) {\n        closeInstallGuide();\n      }\n    });\n  }\n\n  applyInstallTexts(currentLang);\n  updateInstallBannerVisibility();\n  updateInstallBannerPosition();\n\n  if (typeof window !== 'undefined') {\n    window.addEventListener('resize', updateInstallBannerPosition);\n    window.addEventListener('appinstalled', updateInstallBannerVisibility);\n    if (typeof window.matchMedia === 'function') {\n      try {\n        const media = window.matchMedia('(display-mode: standalone)');\n        const handleChange = () => updateInstallBannerVisibility();\n        if (typeof media.addEventListener === 'function') {\n          media.addEventListener('change', handleChange);\n        } else if (typeof media.addListener === 'function') {\n          media.addListener(handleChange);\n        }\n      } catch (error) {\n        console.warn('matchMedia display-mode listener failed', error);\n      }\n    }\n  }\n}\n\nfunction applyInstallTexts(lang) {\n  const fallbackTexts = texts.en || {};\n  const langTexts = texts[lang] || fallbackTexts;\n  const bannerText = langTexts.installBannerText || fallbackTexts.installBannerText;\n  if (installPromptBannerText && bannerText) {\n    installPromptBannerText.textContent = bannerText;\n  }\n  if (installPromptBanner && bannerText) {\n    installPromptBanner.setAttribute('aria-label', bannerText);\n  }\n  const closeLabel = langTexts.installHelpClose || fallbackTexts.installHelpClose;\n  if (installGuideClose && closeLabel) {\n    setButtonLabelWithIcon(installGuideClose, closeLabel, ICON_GLYPHS.circleX);\n    installGuideClose.setAttribute('aria-label', closeLabel);\n    installGuideClose.setAttribute('title', closeLabel);\n  }\n  if (installGuideDialog && !installGuideDialog.hasAttribute('hidden') && currentInstallGuidePlatform) {\n    renderInstallGuideContent(currentInstallGuidePlatform, lang);\n  }\n}\n\nfunction shouldShowIosPwaHelp() {\n  return (\n    !!iosPwaHelpDialog &&\n    isIosDevice() &&\n    isStandaloneDisplayMode() &&\n    !hasDismissedIosPwaHelp()\n  );\n}\n\nfunction openIosPwaHelp() {\n  if (!iosPwaHelpDialog) return;\n  if (!shouldShowIosPwaHelp()) return;\n  lastActiveBeforeIosHelp = document.activeElement;\n  iosPwaHelpDialog.removeAttribute('hidden');\n  const focusTarget = iosPwaHelpClose || iosPwaHelpDialog.querySelector('button, [href], [tabindex]:not([tabindex=\"-1\"])');\n  if (focusTarget && typeof focusTarget.focus === 'function') {\n    focusTarget.focus();\n  }\n}\n\nfunction closeIosPwaHelp(storeDismissal = false) {\n  if (!iosPwaHelpDialog) return;\n  iosPwaHelpDialog.setAttribute('hidden', '');\n  if (storeDismissal) {\n    markIosPwaHelpDismissed();\n  }\n  if (lastActiveBeforeIosHelp && typeof lastActiveBeforeIosHelp.focus === 'function') {\n    lastActiveBeforeIosHelp.focus();\n  }\n}\n\nfunction maybeShowIosPwaHelp() {\n  openIosPwaHelp();\n}\n\nif (iosPwaHelpClose) {\n  iosPwaHelpClose.addEventListener('click', () => closeIosPwaHelp(true));\n}\n\nif (iosPwaHelpDialog) {\n  iosPwaHelpDialog.addEventListener('click', event => {\n    if (event.target === iosPwaHelpDialog) {\n      closeIosPwaHelp(true);\n    }\n  });\n}\n\ndocument.addEventListener('keydown', event => {\n  if (event.key !== 'Escape' && event.key !== 'Esc') return;\n  let handled = false;\n  if (iosPwaHelpDialog && !iosPwaHelpDialog.hasAttribute('hidden')) {\n    closeIosPwaHelp(true);\n    handled = true;\n  }\n  if (installGuideDialog && !installGuideDialog.hasAttribute('hidden')) {\n    closeInstallGuide();\n    handled = true;\n  }\n  if (handled) {\n    event.preventDefault();\n  }\n});\n\nfunction renderSettingsLogoPreview(dataUrl) {\n  if (!settingsLogoPreview) return;\n  if (dataUrl) {\n    settingsLogoPreview.textContent = '';\n    const img = document.createElement('img');\n    img.src = dataUrl;\n    img.alt = '';\n    settingsLogoPreview.appendChild(img);\n    settingsLogoPreview.removeAttribute('hidden');\n  } else {\n    settingsLogoPreview.textContent = '';\n    settingsLogoPreview.setAttribute('hidden', '');\n  }\n}\n\nfunction loadStoredLogoPreview() {\n  if (!settingsLogoPreview || typeof localStorage === 'undefined') return;\n  let stored = null;\n  try {\n    stored = localStorage.getItem('customLogo');\n  } catch (e) {\n    console.warn('Could not load custom logo preview', e);\n  }\n  renderSettingsLogoPreview(stored);\n}\n\nconst isPlainObjectValue = (val) => val !== null && typeof val === 'object' && !Array.isArray(val);\n\nconst REQUIRED_DEVICE_CATEGORIES = [\n  'cameras',\n  'monitors',\n  'video',\n  'viewfinders',\n  'directorMonitors',\n  'iosVideo',\n  'videoAssist',\n  'media',\n  'lenses',\n  'fiz',\n  'batteries',\n  'batteryHotswaps',\n  'wirelessReceivers',\n  'accessories',\n];\nconst DEFAULT_FIZ_COLLECTIONS = ['motors', 'handUnits', 'controllers', 'distance'];\nconst DEFAULT_ACCESSORY_COLLECTIONS = [\n  'chargers',\n  'cages',\n  'powerPlates',\n  'cameraSupport',\n  'matteboxes',\n  'filters',\n  'rigging',\n  'batteries',\n  'cables',\n  'videoAssist',\n  'media',\n  'tripodHeads',\n  'tripods',\n  'sliders',\n  'cameraStabiliser',\n  'grip',\n  'carts',\n];\nconst MAX_DEVICE_IMPORT_ERRORS = 5;\n\nfunction isDeviceEntryObject(value) {\n  if (!isPlainObjectValue(value)) {\n    return false;\n  }\n  return Object.values(value).some((entry) => entry === null || typeof entry !== 'object' || Array.isArray(entry));\n}\n\nfunction countDeviceDatabaseEntries(collection) {\n  if (!isPlainObjectValue(collection)) {\n    return 0;\n  }\n  let total = 0;\n  for (const [name, value] of Object.entries(collection)) {\n    if (name === 'filterOptions' || name === 'None') {\n      continue;\n    }\n    if (!isPlainObjectValue(value)) {\n      continue;\n    }\n    if (isDeviceEntryObject(value)) {\n      total += 1;\n    } else {\n      total += countDeviceDatabaseEntries(value);\n    }\n  }\n  return total;\n}\n\nfunction looksLikeDeviceDatabase(candidate) {\n  if (!isPlainObjectValue(candidate)) {\n    return false;\n  }\n  let matched = 0;\n  for (const key of REQUIRED_DEVICE_CATEGORIES) {\n    if (Object.prototype.hasOwnProperty.call(candidate, key)) {\n      matched += 1;\n    }\n  }\n  return matched >= 3;\n}\n\nfunction collectReferenceFizKeys() {\n  const reference = typeof globalThis !== 'undefined' && isPlainObjectValue(globalThis.defaultDevices)\n    ? globalThis.defaultDevices\n    : (typeof globalThis !== 'undefined' && isPlainObjectValue(globalThis.devices) ? globalThis.devices : null);\n  if (reference && isPlainObjectValue(reference.fiz)) {\n    const keys = Object.keys(reference.fiz).filter(Boolean);\n    if (keys.length) {\n      return keys;\n    }\n  }\n  return DEFAULT_FIZ_COLLECTIONS;\n}\n\nfunction collectReferenceAccessoryKeys() {\n  const reference = typeof globalThis !== 'undefined' && isPlainObjectValue(globalThis.defaultDevices)\n    ? globalThis.defaultDevices\n    : (typeof globalThis !== 'undefined' && isPlainObjectValue(globalThis.devices) ? globalThis.devices : null);\n  if (reference && isPlainObjectValue(reference.accessories)) {\n    const keys = Object.keys(reference.accessories).filter(Boolean);\n    if (keys.length) {\n      return keys;\n    }\n  }\n  return DEFAULT_ACCESSORY_COLLECTIONS;\n}\n\nfunction validateDeviceDatabaseStructure(candidate) {\n  if (!isPlainObjectValue(candidate)) {\n    return { devices: null, errors: ['Imported data must be a JSON object.'] };\n  }\n\n  const errors = [];\n  const missing = [];\n\n  for (const category of REQUIRED_DEVICE_CATEGORIES) {\n    if (category === 'fiz') {\n      if (!isPlainObjectValue(candidate.fiz)) {\n        missing.push('fiz');\n        continue;\n      }\n      const expectedFizKeys = collectReferenceFizKeys();\n      const missingFiz = expectedFizKeys.filter((key) => !isPlainObjectValue(candidate.fiz[key]));\n      if (missingFiz.length) {\n        errors.push(`Missing FIZ categories: ${missingFiz.join(', ')}`);\n      }\n      continue;\n    }\n    if (category === 'accessories') {\n      if (!isPlainObjectValue(candidate.accessories)) {\n        missing.push('accessories');\n        continue;\n      }\n      const expectedAccessoryKeys = collectReferenceAccessoryKeys();\n      const missingAccessories = expectedAccessoryKeys.filter((key) => !isPlainObjectValue(candidate.accessories[key]));\n      if (missingAccessories.length) {\n        errors.push(`Missing accessory categories: ${missingAccessories.join(', ')}`);\n      }\n      continue;\n    }\n    if (!isPlainObjectValue(candidate[category])) {\n      missing.push(category);\n    }\n  }\n\n  if (missing.length) {\n    errors.push(`Missing categories: ${missing.join(', ')}`);\n  }\n\n  if (candidate.accessories !== undefined) {\n    if (!isPlainObjectValue(candidate.accessories)) {\n      errors.push('Accessory collections must be objects.');\n    } else {\n      for (const [subKey, subValue] of Object.entries(candidate.accessories)) {\n        if (!isPlainObjectValue(subValue)) {\n          errors.push(`Accessory category \"${subKey}\" must be an object.`);\n        }\n      }\n    }\n  }\n\n  if (candidate.filterOptions !== undefined && !Array.isArray(candidate.filterOptions)) {\n    errors.push('Filter options must be provided as an array.');\n  }\n\n  if (candidate.fiz && isPlainObjectValue(candidate.fiz)) {\n    for (const [subKey, subValue] of Object.entries(candidate.fiz)) {\n      if (subValue !== undefined && !isPlainObjectValue(subValue)) {\n        errors.push(`FIZ category \"${subKey}\" must be an object.`);\n      }\n    }\n  }\n\n  const structureErrors = [];\n  const inspectCollections = (collection, path = []) => {\n    if (!isPlainObjectValue(collection)) {\n      return;\n    }\n    for (const [name, value] of Object.entries(collection)) {\n      if (name === 'None' || name === 'filterOptions') {\n        continue;\n      }\n      const nextPath = path.concat(name);\n      if (!isPlainObjectValue(value)) {\n        if (!Array.isArray(value)) {\n          structureErrors.push(`${nextPath.join('.')} must be an object.`);\n        }\n      } else if (!isDeviceEntryObject(value)) {\n        inspectCollections(value, nextPath);\n      }\n      if (structureErrors.length >= MAX_DEVICE_IMPORT_ERRORS) {\n        return;\n      }\n    }\n  };\n\n  inspectCollections(candidate);\n  errors.push(...structureErrors);\n\n  const deviceCount = countDeviceDatabaseEntries(candidate);\n  if (!deviceCount) {\n    errors.push('The imported database does not contain any devices.');\n  }\n\n  const uniqueErrors = [];\n  for (const message of errors) {\n    if (message && !uniqueErrors.includes(message)) {\n      uniqueErrors.push(message);\n    }\n    if (uniqueErrors.length >= MAX_DEVICE_IMPORT_ERRORS) {\n      break;\n    }\n  }\n\n  return {\n    devices: uniqueErrors.length ? null : candidate,\n    errors: uniqueErrors,\n  };\n}\n\nfunction parseDeviceDatabaseImport(rawData) {\n  if (Array.isArray(rawData)) {\n    return { devices: null, errors: ['Import file must contain a JSON object, but found an array.'] };\n  }\n  if (!isPlainObjectValue(rawData)) {\n    return { devices: null, errors: ['Import file must contain a JSON object.'] };\n  }\n\n  if (Object.prototype.hasOwnProperty.call(rawData, 'devices') && !isPlainObjectValue(rawData.devices)) {\n    return { devices: null, errors: ['The \"devices\" property must be an object.'] };\n  }\n\n  const candidate = Object.prototype.hasOwnProperty.call(rawData, 'devices') && isPlainObjectValue(rawData.devices)\n    ? rawData.devices\n    : (looksLikeDeviceDatabase(rawData) ? rawData : null);\n\n  if (!candidate) {\n    return { devices: null, errors: ['Could not find a device database in the selected file.'] };\n  }\n\n  return validateDeviceDatabaseStructure(candidate);\n}\n\nfunction formatDeviceImportErrors(errors) {\n  if (!Array.isArray(errors) || !errors.length) {\n    return '';\n  }\n  const lines = errors.slice(0, MAX_DEVICE_IMPORT_ERRORS).map((message) => `- ${message}`);\n  return lines.join('\\n');\n}\n\nfunction resolveLanguageCode(lang) {\n  if (lang && texts && Object.prototype.hasOwnProperty.call(texts, lang)) {\n    return lang;\n  }\n  return 'en';\n}\n\nfunction getLanguageTexts(lang) {\n  const resolved = resolveLanguageCode(lang);\n  return (texts && texts[resolved]) || texts.en || {};\n}\n\nconst DEFAULT_INTL_CACHE_KEY = '__default__';\n\nconst numberFormatCache = new Map();\nconst pluralRulesCache = new Map();\nconst listFormatCache = new Map();\nconst LIST_FORMAT_OPTIONS = Object.freeze({ style: 'long', type: 'conjunction' });\n\nfunction serializeIntlOptions(options) {\n  if (!options || typeof options !== 'object') {\n    return options == null ? DEFAULT_INTL_CACHE_KEY : String(options);\n  }\n  const entries = [];\n  for (const [key, value] of Object.entries(options)) {\n    if (typeof value === 'undefined') continue;\n    let normalizedValue;\n    if (value && typeof value === 'object') {\n      normalizedValue = serializeIntlOptions(value);\n    } else {\n      normalizedValue = String(value);\n    }\n    entries.push(`${key}:${normalizedValue}`);\n  }\n  if (!entries.length) {\n    return DEFAULT_INTL_CACHE_KEY;\n  }\n  return entries.sort().join('|');\n}\n\nfunction getCachedIntlObject(cache, locale, options, factory) {\n  const key = serializeIntlOptions(options);\n  let localeCache = cache.get(locale);\n  if (!localeCache) {\n    localeCache = new Map();\n    cache.set(locale, localeCache);\n  }\n  if (localeCache.has(key)) {\n    return localeCache.get(key);\n  }\n  try {\n    const instance = factory(locale, options);\n    localeCache.set(key, instance);\n    return instance;\n  } catch (error) {\n    localeCache.delete(key);\n    throw error;\n  }\n}\n\nfunction getNumberFormatter(locale, options) {\n  return getCachedIntlObject(numberFormatCache, locale, options, (loc, opts) => new Intl.NumberFormat(loc, opts));\n}\n\nfunction getPluralRules(locale) {\n  return getCachedIntlObject(pluralRulesCache, locale, undefined, loc => new Intl.PluralRules(loc));\n}\n\nfunction getListFormatter(locale) {\n  return getCachedIntlObject(listFormatCache, locale, LIST_FORMAT_OPTIONS, loc => new Intl.ListFormat(loc, LIST_FORMAT_OPTIONS));\n}\n\nfunction formatNumberForLang(lang, value, options) {\n  const resolved = resolveLanguageCode(lang);\n  try {\n    return getNumberFormatter(resolved, options).format(value);\n  } catch (firstError) {\n    if (resolved !== 'en') {\n      try {\n        return getNumberFormatter('en', options).format(value);\n      } catch (fallbackError) {\n        console.warn('Number formatting failed', firstError, fallbackError);\n        return String(value);\n      }\n    }\n    console.warn('Number formatting failed', firstError);\n    return String(value);\n  }\n}\n\nfunction formatCountText(lang, langTexts, baseKey, count) {\n  const resolved = resolveLanguageCode(lang);\n  const localeTexts = langTexts || getLanguageTexts(resolved);\n  const englishTexts = getLanguageTexts('en');\n  let suffix = 'Other';\n  try {\n    const plural = getPluralRules(resolved).select(count);\n    if (plural === 'one' && (localeTexts[`${baseKey}One`] || englishTexts[`${baseKey}One`])) {\n      suffix = 'One';\n    }\n  } catch (firstError) {\n    if (resolved !== 'en') {\n      try {\n        const fallbackPlural = getPluralRules('en').select(count);\n        if (fallbackPlural === 'one' && (localeTexts[`${baseKey}One`] || englishTexts[`${baseKey}One`])) {\n          suffix = 'One';\n        }\n      } catch (fallbackError) {\n        console.warn('Plural rules failed', firstError, fallbackError);\n        if (count === 1 && (localeTexts[`${baseKey}One`] || englishTexts[`${baseKey}One`])) {\n          suffix = 'One';\n        }\n      }\n    } else if (count === 1 && (localeTexts[`${baseKey}One`] || englishTexts[`${baseKey}One`])) {\n      suffix = 'One';\n    }\n  }\n  const key = `${baseKey}${suffix}`;\n  const template = localeTexts[key] || englishTexts[key] || '%s';\n  const formatted = formatNumberForLang(resolved, count);\n  return template.replace('%s', formatted);\n}\n\nfunction formatListForLang(lang, items) {\n  const resolved = resolveLanguageCode(lang);\n  if (!Array.isArray(items) || !items.length) return '';\n  try {\n    return getListFormatter(resolved).format(items);\n  } catch (firstError) {\n    if (resolved !== 'en') {\n      try {\n        return getListFormatter('en').format(items);\n      } catch (fallbackError) {\n        console.warn('List formatting failed', firstError, fallbackError);\n        return items.join(', ');\n      }\n    }\n    console.warn('List formatting failed', firstError);\n    return items.join(', ');\n  }\n}\n\nfunction normalizeTemperatureUnit(unit) {\n  if (typeof unit === 'string') {\n    const normalized = unit.trim().toLowerCase();\n    if (normalized === TEMPERATURE_UNITS.fahrenheit) {\n      return TEMPERATURE_UNITS.fahrenheit;\n    }\n    if (normalized === TEMPERATURE_UNITS.celsius) {\n      return TEMPERATURE_UNITS.celsius;\n    }\n  }\n  if (unit === TEMPERATURE_UNITS.fahrenheit) {\n    return TEMPERATURE_UNITS.fahrenheit;\n  }\n  return TEMPERATURE_UNITS.celsius;\n}\n\nfunction convertCelsiusToUnit(value, unit = temperatureUnit) {\n  const numeric = Number(value);\n  if (!Number.isFinite(numeric)) {\n    return Number.NaN;\n  }\n  const resolvedUnit = normalizeTemperatureUnit(unit);\n  if (resolvedUnit === TEMPERATURE_UNITS.fahrenheit) {\n    return (numeric * 9) / 5 + 32;\n  }\n  return numeric;\n}\n\nfunction getTemperatureUnitSymbolForLang(lang = currentLang, unit = temperatureUnit) {\n  const resolvedUnit = normalizeTemperatureUnit(unit);\n  const textsForLang = getLanguageTexts(lang);\n  const fallbackTexts = getLanguageTexts('en');\n  const key =\n    resolvedUnit === TEMPERATURE_UNITS.fahrenheit\n      ? 'temperatureUnitSymbolFahrenheit'\n      : 'temperatureUnitSymbolCelsius';\n  return (\n    textsForLang[key] ||\n    fallbackTexts[key] ||\n    (resolvedUnit === TEMPERATURE_UNITS.fahrenheit ? '\xB0F' : '\xB0C')\n  );\n}\n\nfunction getTemperatureUnitLabelForLang(lang = currentLang, unit = temperatureUnit) {\n  const resolvedUnit = normalizeTemperatureUnit(unit);\n  const textsForLang = getLanguageTexts(lang);\n  const fallbackTexts = getLanguageTexts('en');\n  const key =\n    resolvedUnit === TEMPERATURE_UNITS.fahrenheit\n      ? 'temperatureUnitFahrenheit'\n      : 'temperatureUnitCelsius';\n  return (\n    textsForLang[key] ||\n    fallbackTexts[key] ||\n    (resolvedUnit === TEMPERATURE_UNITS.fahrenheit ? 'Fahrenheit (\xB0F)' : 'Celsius (\xB0C)')\n  );\n}\n\nfunction getTemperatureColumnLabelForLang(lang = currentLang, unit = temperatureUnit) {\n  const textsForLang = getLanguageTexts(lang);\n  const fallbackTexts = getLanguageTexts('en');\n  const baseLabel =\n    textsForLang.temperatureLabel || fallbackTexts.temperatureLabel || 'Temperature';\n  const symbol = getTemperatureUnitSymbolForLang(lang, unit);\n  return `${baseLabel} (${symbol})`;\n}\n\nfunction formatTemperatureForDisplay(celsius, options = {}) {\n  const {\n    unit = temperatureUnit,\n    lang = currentLang,\n    includeSign = true\n  } = options || {};\n  const resolvedUnit = normalizeTemperatureUnit(unit);\n  let converted = convertCelsiusToUnit(celsius, resolvedUnit);\n  if (!Number.isFinite(converted)) {\n    return '';\n  }\n  if (Math.abs(converted) < 1e-6) {\n    converted = 0;\n  }\n  const isNegative = converted < 0;\n  const isPositive = converted > 0;\n  const absolute = Math.abs(converted);\n  const isInteger = Math.abs(absolute - Math.round(absolute)) < 1e-6;\n  const fractionDigits =\n    resolvedUnit === TEMPERATURE_UNITS.fahrenheit && !isInteger ? 1 : 0;\n  const formatted = formatNumberForLang(lang, absolute, {\n    minimumFractionDigits: fractionDigits,\n    maximumFractionDigits: fractionDigits\n  });\n  let prefix = '';\n  if (includeSign === 'none') {\n    prefix = '';\n  } else if (includeSign === false || includeSign === 'negative') {\n    if (isNegative) {\n      prefix = '\\u2013';\n    }\n  } else {\n    if (isPositive) {\n      prefix = '+';\n    } else if (isNegative) {\n      prefix = '\\u2013';\n    }\n  }\n  const symbol = getTemperatureUnitSymbolForLang(lang, resolvedUnit);\n  return `${prefix}${formatted} ${symbol}`;\n}\n\nfunction summarizeCustomDevices() {\n  if (typeof getDeviceChanges !== 'function') {\n    return { total: 0, categories: [] };\n  }\n  const diff = getDeviceChanges();\n  if (!diff || typeof diff !== 'object') {\n    return { total: 0, categories: [] };\n  }\n  const categories = [];\n  let total = 0;\n  Object.entries(diff).forEach(([cat, entries]) => {\n    if (!isPlainObjectValue(entries)) return;\n    if (cat === 'fiz') {\n      Object.entries(entries).forEach(([sub, subEntries]) => {\n        if (!isPlainObjectValue(subEntries)) return;\n        const keys = Object.keys(subEntries);\n        if (!keys.length) return;\n        categories.push({ key: `fiz.${sub}`, count: keys.length });\n        total += keys.length;\n      });\n    } else {\n      const keys = Object.keys(entries);\n      if (!keys.length) return;\n      categories.push({ key: cat, count: keys.length });\n      total += keys.length;\n    }\n  });\n  return { total, categories };\n}\n\nfunction hasGearListContent(entry) {\n  if (!entry) return false;\n  if (typeof entry === 'string') {\n    return entry.trim().length > 0;\n  }\n  if (!isPlainObjectValue(entry)) {\n    return false;\n  }\n\n  if (typeof entry.gearList === 'string') {\n    return entry.gearList.trim().length > 0;\n  }\n\n  if (isPlainObjectValue(entry.gearList)) {\n    return Object.values(entry.gearList).some((value) => (\n      typeof value === 'string' && value.trim().length > 0\n    ));\n  }\n\n  const legacyProjectHtml = typeof entry.projectHtml === 'string' && entry.projectHtml.trim().length > 0;\n  const legacyGearHtml = typeof entry.gearHtml === 'string' && entry.gearHtml.trim().length > 0;\n  if (legacyProjectHtml || legacyGearHtml) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction computeGearListCount(projectData, setupsData) {\n  let count = 0;\n  const countedNames = new Set();\n\n  const addCount = (name, candidate) => {\n    if (!hasGearListContent(candidate)) {\n      return;\n    }\n    const normalizedName = typeof name === 'string' ? name : '';\n    if (countedNames.has(normalizedName)) {\n      return;\n    }\n    countedNames.add(normalizedName);\n    count += 1;\n  };\n\n  if (typeof projectData === 'string') {\n    addCount('', projectData);\n  } else if (Array.isArray(projectData)) {\n    projectData.forEach((entry, index) => {\n      const key = isPlainObjectValue(entry) && typeof entry.name === 'string'\n        ? entry.name\n        : `legacy-${index}`;\n      addCount(key, entry);\n    });\n  } else if (isPlainObjectValue(projectData)) {\n    Object.entries(projectData).forEach(([name, entry]) => {\n      addCount(name, entry);\n    });\n  } else {\n    addCount('', projectData);\n  }\n\n  if (isPlainObjectValue(setupsData)) {\n    Object.entries(setupsData).forEach(([name, setup]) => {\n      addCount(name, setup);\n    });\n  }\n\n  return count;\n}\n\nfunction computeFavoritesCount(favorites) {\n  if (!isPlainObjectValue(favorites)) return 0;\n  return Object.values(favorites).reduce((count, entry) => {\n    if (Array.isArray(entry)) {\n      return count + entry.length;\n    }\n    return count;\n  }, 0);\n}\n\nfunction computeFeedbackCount(feedback) {\n  if (!isPlainObjectValue(feedback)) return 0;\n  return Object.values(feedback).reduce((count, entry) => {\n    if (Array.isArray(entry)) {\n      return count + entry.length;\n    }\n    if (isPlainObjectValue(entry) && Array.isArray(entry.entries)) {\n      return count + entry.entries.length;\n    }\n    return count;\n  }, 0);\n}\n\nfunction estimateBackupSize(data) {\n  if (typeof localStorage === 'undefined') return 0;\n  try {\n    const snapshot = {};\n    for (let i = 0; i < localStorage.length; i += 1) {\n      const key = localStorage.key(i);\n      if (typeof key !== 'string') continue;\n      snapshot[key] = localStorage.getItem(key);\n    }\n    const payload = {\n      version: typeof APP_VERSION !== 'undefined' ? APP_VERSION : '',\n      generatedAt: new Date().toISOString(),\n      settings: snapshot,\n      data,\n    };\n    const json = JSON.stringify(payload);\n    if (typeof TextEncoder !== 'undefined') {\n      return new TextEncoder().encode(json).length;\n    }\n    return json.length;\n  } catch (err) {\n    console.warn('Could not calculate backup size preview', err);\n    return 0;\n  }\n}\n\nfunction formatSizeText(lang, langTexts, bytes) {\n  const resolved = resolveLanguageCode(lang);\n  if (!Number.isFinite(bytes) || bytes <= 0) {\n    const zero = formatNumberForLang(resolved, 0, { maximumFractionDigits: 0 });\n    const template = langTexts.storageTotalSizeValue || (texts.en?.storageTotalSizeValue) || '~%s KB';\n    return template.replace('%s', zero);\n  }\n  const kilobytes = bytes / 1024;\n  let options;\n  if (kilobytes >= 100) {\n    options = { maximumFractionDigits: 0 };\n  } else if (kilobytes >= 10) {\n    options = { minimumFractionDigits: 1, maximumFractionDigits: 1 };\n  } else {\n    options = { minimumFractionDigits: 2, maximumFractionDigits: 2 };\n  }\n  const formatted = formatNumberForLang(resolved, kilobytes, options);\n  const template = langTexts.storageTotalSizeValue || (texts.en?.storageTotalSizeValue) || '~%s KB';\n  return template.replace('%s', formatted);\n}\n\nfunction formatDeviceCategories(lang, categories) {\n  if (!Array.isArray(categories) || !categories.length) return '';\n  const resolved = resolveLanguageCode(lang);\n  const lookup = (typeof categoryNames !== 'undefined' && categoryNames) || {};\n  const localized = lookup[resolved] || lookup.en || {};\n  const fallback = lookup.en || {};\n  const items = categories\n    .map(({ key, count }) => {\n      const label = localized[key] || fallback[key] || key;\n      const formattedCount = formatNumberForLang(resolved, count, { maximumFractionDigits: 0 });\n      return { label, text: `${label} (${formattedCount})` };\n    })\n    .sort((a, b) => a.label.localeCompare(b.label, resolved, { sensitivity: 'base' }))\n    .map((entry) => entry.text);\n  return formatListForLang(resolved, items);\n}\n\nfunction createSummaryItemElement(item) {\n  const li = document.createElement('li');\n  li.className = 'storage-summary-item';\n  const header = document.createElement('div');\n  header.className = 'storage-summary-header';\n  const label = document.createElement('span');\n  label.className = 'storage-summary-label';\n  label.textContent = item.label;\n  header.appendChild(label);\n  if (item.storageKey) {\n    const code = document.createElement('code');\n    code.className = 'storage-summary-key';\n    code.textContent = item.storageKey;\n    header.appendChild(code);\n  }\n  li.appendChild(header);\n  if (item.value) {\n    const valueElem = document.createElement('p');\n    valueElem.className = 'storage-summary-value';\n    valueElem.textContent = item.value;\n    li.appendChild(valueElem);\n  }\n  if (item.description) {\n    const desc = document.createElement('p');\n    desc.className = 'storage-summary-description';\n    desc.textContent = item.description;\n    li.appendChild(desc);\n  }\n  if (item.extra) {\n    const extras = Array.isArray(item.extra) ? item.extra : [item.extra];\n    extras.filter(Boolean).forEach((text) => {\n      const extraElem = document.createElement('p');\n      extraElem.className = 'storage-summary-extra';\n      extraElem.textContent = text;\n      li.appendChild(extraElem);\n    });\n  }\n  return li;\n}\n\nfunction updateStorageSummary() {\n  if (!storageSummaryList) return;\n  while (storageSummaryList.firstChild) {\n    storageSummaryList.removeChild(storageSummaryList.firstChild);\n  }\n  const lang = resolveLanguageCode(currentLang);\n  const langTexts = getLanguageTexts(lang);\n  const exportedData = typeof exportAllData === 'function' ? exportAllData() : null;\n  const data = isPlainObjectValue(exportedData) ? exportedData : {};\n  const setups = isPlainObjectValue(data.setups) ? data.setups : {};\n  const projectNames = Object.keys(setups);\n  const totalProjects = projectNames.length;\n  const autoBackups = projectNames.filter((name) => typeof name === 'string' && name.startsWith('auto-backup-')).length;\n  const gearListCount = computeGearListCount(data.project, setups);\n  const favoritesCount = computeFavoritesCount(data.favorites);\n  const feedbackCount = computeFeedbackCount(data.feedback);\n  const sessionData = data.session;\n  const hasSession = Boolean(\n    (isPlainObjectValue(sessionData) && Object.keys(sessionData).length)\n    || (Array.isArray(sessionData) && sessionData.length)\n    || (typeof sessionData === 'string' && sessionData.trim())\n  );\n  const deviceSummary = summarizeCustomDevices();\n  const approxBytes = estimateBackupSize(data);\n\n  const items = [\n    {\n      storageKey: 'cameraPowerPlanner_setups',\n      label: langTexts.storageKeyProjects || 'Saved projects',\n      value: formatCountText(lang, langTexts, 'storageProjectsCount', totalProjects),\n      description: langTexts.storageKeyProjectsDesc || '',\n      extra: autoBackups > 0\n        ? formatCountText(lang, langTexts, 'storageAutoBackupsCount', autoBackups)\n        : null,\n    },\n    {\n      storageKey: 'cameraPowerPlanner_project',\n      label: langTexts.storageKeyGearLists || 'Gear list snapshots',\n      value: formatCountText(lang, langTexts, 'storageGearListsCount', gearListCount),\n      description: langTexts.storageKeyGearListsDesc || '',\n    },\n    {\n      storageKey: 'cameraPowerPlanner_devices',\n      label: langTexts.storageKeyDevices || 'Custom or modified devices',\n      value: formatCountText(lang, langTexts, 'storageDevicesCount', deviceSummary.total),\n      description: langTexts.storageKeyDevicesDesc || '',\n      extra: deviceSummary.total > 0 && deviceSummary.categories.length\n        ? (langTexts.storageDeviceCategories || texts.en?.storageDeviceCategories || 'Affected categories: %s')\n          .replace('%s', formatDeviceCategories(lang, deviceSummary.categories))\n        : null,\n    },\n    {\n      storageKey: 'cameraPowerPlanner_favorites',\n      label: langTexts.storageKeyFavorites || 'Pinned favorites',\n      value: formatCountText(lang, langTexts, 'storageFavoritesCount', favoritesCount),\n      description: langTexts.storageKeyFavoritesDesc || '',\n    },\n    {\n      storageKey: 'cameraPowerPlanner_feedback',\n      label: langTexts.storageKeyFeedback || 'Runtime feedback',\n      value: formatCountText(lang, langTexts, 'storageFeedbackCount', feedbackCount),\n      description: langTexts.storageKeyFeedbackDesc || '',\n    },\n    {\n      storageKey: 'cameraPowerPlanner_session',\n      label: langTexts.storageKeySession || 'Unsaved session',\n      value: hasSession\n        ? langTexts.storageSessionStored || texts.en?.storageSessionStored || 'Stored'\n        : langTexts.storageSessionNotStored || texts.en?.storageSessionNotStored || 'Not stored',\n      description: langTexts.storageKeySessionDesc || '',\n    },\n    {\n      storageKey: 'localStorage',\n      label: langTexts.storageKeyTotalSize || 'Approximate backup size',\n      value: formatSizeText(lang, langTexts, approxBytes),\n      description: langTexts.storageKeyTotalSizeDesc || '',\n    },\n  ];\n\n  items.forEach((item) => {\n    storageSummaryList.appendChild(createSummaryItemElement(item));\n  });\n\n  if (storageSummaryEmpty) {\n    const hasData = Boolean(\n      totalProjects\n      || gearListCount\n      || deviceSummary.total\n      || favoritesCount\n      || feedbackCount\n      || hasSession\n    );\n    if (hasData) {\n      storageSummaryEmpty.setAttribute('hidden', '');\n    } else {\n      storageSummaryEmpty.removeAttribute('hidden');\n    }\n  }\n}\n\nif (settingsLogo) {\n  settingsLogo.addEventListener('change', () => {\n    const file = settingsLogo.files && settingsLogo.files[0];\n    if (!file) {\n      loadStoredLogoPreview();\n      return;\n    }\n    if (file.type !== 'image/svg+xml' && !file.name.toLowerCase().endsWith('.svg')) {\n      showNotification('error', texts[currentLang].logoFormatError || 'Unsupported logo format');\n      settingsLogo.value = '';\n      loadStoredLogoPreview();\n      return;\n    }\n    const reader = new FileReader();\n    reader.onload = () => {\n      renderSettingsLogoPreview(reader.result);\n    };\n    reader.readAsDataURL(file);\n  });\n}\nconst settingsHighContrast = document.getElementById(\"settingsHighContrast\");\nconst backupSettings = document.getElementById(\"backupSettings\");\nconst restoreSettings = document.getElementById(\"restoreSettings\");\nconst factoryResetButton = document.getElementById(\"factoryResetButton\");\nconst restoreSettingsInput = document.getElementById(\"restoreSettingsInput\");\nconst settingsShowAutoBackups = document.getElementById(\"settingsShowAutoBackups\");\nconst aboutVersionElem = document.getElementById(\"aboutVersion\");\nconst supportLink = document.getElementById(\"supportLink\");\nconst settingsSave    = document.getElementById(\"settingsSave\");\nconst settingsCancel  = document.getElementById(\"settingsCancel\");\nconst featureSearch   = document.getElementById(\"featureSearch\");\nconst featureList     = document.getElementById(\"featureList\");\nconst featureMap      = new Map();\nconst normalizeSearchValue = value =>\n  typeof value === 'string' ? value.trim().toLowerCase() : '';\nconst updateFeatureSearchValue = (newValue, originalNormalized) => {\n  if (!featureSearch || typeof newValue !== 'string') return;\n  const trimmed = newValue.trim();\n  if (!trimmed) {\n    featureSearch.value = '';\n    restoreFeatureSearchDefaults();\n    return;\n  }\n  if (originalNormalized && trimmed.toLowerCase() === originalNormalized) {\n    return;\n  }\n  featureSearch.value = newValue;\n  restoreFeatureSearchDefaults();\n};\nconst helpMap         = new Map();\nconst deviceMap       = new Map();\nlet runFeatureSearch = () => {};\n\nlet featureSearchEntries = [];\nlet featureSearchDefaultOptions = [];\n\nconst renderFeatureListOptions = values => {\n  if (!featureList || !Array.isArray(values)) return;\n  const fragment = document.createDocumentFragment();\n  for (const value of values) {\n    if (!value) continue;\n    const option = document.createElement('option');\n    option.value = value;\n    fragment.appendChild(option);\n  }\n  featureList.innerHTML = '';\n  featureList.appendChild(fragment);\n};\n\nfunction restoreFeatureSearchDefaults() {\n  renderFeatureListOptions(featureSearchDefaultOptions);\n}\n\nconst FEATURE_SEARCH_MATCH_PRIORITIES = {\n  none: 1,\n  partial: 2,\n  keySubset: 3,\n  keyPrefix: 4,\n  token: 5,\n  exactKey: 6\n};\n\nfunction scoreFeatureSearchEntry(entry, queryKey, queryTokens) {\n  if (!entry || !entry.key) return null;\n  const display = entry.display;\n  if (!display) return null;\n  const entryKey = entry.key;\n  const entryTokens = Array.isArray(entry.tokens) ? entry.tokens : [];\n  const validQueryTokens = Array.isArray(queryTokens)\n    ? queryTokens.filter(Boolean)\n    : [];\n  const tokenDetails = validQueryTokens.length\n    ? computeTokenMatchDetails(entryTokens, validQueryTokens)\n    : { score: 0, matched: 0 };\n\n  let bestType = 'none';\n  let bestPriority = FEATURE_SEARCH_MATCH_PRIORITIES.none;\n  const updateType = type => {\n    const priority = FEATURE_SEARCH_MATCH_PRIORITIES[type] || FEATURE_SEARCH_MATCH_PRIORITIES.none;\n    if (priority > bestPriority) {\n      bestType = type;\n      bestPriority = priority;\n    }\n  };\n\n  if (queryKey) {\n    if (entryKey === queryKey) {\n      updateType('exactKey');\n    }\n    if (entryKey.startsWith(queryKey)) {\n      updateType('keyPrefix');\n    }\n    if (queryKey.startsWith(entryKey)) {\n      updateType('keySubset');\n    }\n    if (entryKey.includes(queryKey) || queryKey.includes(entryKey)) {\n      updateType('partial');\n    }\n  }\n\n  if (tokenDetails.score > 0) {\n    updateType('token');\n  }\n\n  return {\n    entry,\n    matchType: bestType,\n    priority: bestPriority,\n    tokenScore: tokenDetails.score,\n    tokenMatches: tokenDetails.matched,\n    keyDistance: queryKey\n      ? Math.abs(entryKey.length - queryKey.length)\n      : Number.POSITIVE_INFINITY,\n    keyLength: entryKey.length\n  };\n}\n\nfunction updateFeatureSearchSuggestions(query) {\n  if (!featureList) return;\n  const trimmed = typeof query === 'string' ? query.trim() : '';\n  if (!trimmed) {\n    restoreFeatureSearchDefaults();\n    return;\n  }\n\n  const queryKey = searchKey(trimmed);\n  const queryTokens = searchTokens(trimmed);\n  if (!queryKey && (!Array.isArray(queryTokens) || queryTokens.length === 0)) {\n    restoreFeatureSearchDefaults();\n    return;\n  }\n\n  const scored = featureSearchEntries\n    .map(entry => scoreFeatureSearchEntry(entry, queryKey, queryTokens))\n    .filter(Boolean);\n\n  if (scored.length === 0) {\n    restoreFeatureSearchDefaults();\n    return;\n  }\n\n  const meaningful = scored.filter(\n    item =>\n      item.priority > FEATURE_SEARCH_MATCH_PRIORITIES.none || item.tokenScore > 0\n  );\n\n  const candidates = (meaningful.length > 0 ? meaningful : scored).sort((a, b) => {\n    if (b.priority !== a.priority) return b.priority - a.priority;\n    if (b.tokenScore !== a.tokenScore) return b.tokenScore - a.tokenScore;\n    if (b.tokenMatches !== a.tokenMatches) return b.tokenMatches - a.tokenMatches;\n    if (a.keyDistance !== b.keyDistance) return a.keyDistance - b.keyDistance;\n    if (a.keyLength !== b.keyLength) return a.keyLength - b.keyLength;\n    return a.entry.display.localeCompare(b.entry.display, undefined, {\n      sensitivity: 'base'\n    });\n  });\n\n  const values = [];\n  const seen = new Set();\n  for (const item of candidates.slice(0, 25)) {\n    const value = item.entry.display;\n    if (!value || seen.has(value)) continue;\n    seen.add(value);\n    values.push(value);\n  }\n\n  if (values.length === 0) {\n    restoreFeatureSearchDefaults();\n    return;\n  }\n\n  renderFeatureListOptions(values);\n}\n// Normalise strings for search comparisons by removing punctuation, diacritics\n// and treating symbols like \u201C&\u201D/\u201C+\u201D as their word equivalents. British and\n// American spelling variants are folded together so queries like \u201Cfavourites\u201D\n// still match \u201CFavorites\u201D. Falls back to whitespace-stripping when no\n// meaningful characters remain (e.g. emoji-only headings) so legacy behaviour\n// is preserved for those edge cases.\nconst ROMAN_NUMERAL_VALUES = {\n  i: 1,\n  v: 5,\n  x: 10,\n  l: 50,\n  c: 100,\n  d: 500,\n  m: 1000\n};\n\nconst ROMAN_NUMERAL_PATTERN = /^[ivxlcdm]+$/;\n\nconst parseMarkSuffix = value => {\n  if (!value) {\n    return { cleaned: '', number: null };\n  }\n  const cleaned = value.replace(/[^a-z0-9]+/g, '');\n  if (!cleaned) {\n    return { cleaned: '', number: null };\n  }\n  let number = null;\n  if (/^\\d+$/.test(cleaned)) {\n    number = parseInt(cleaned, 10);\n  } else if (ROMAN_NUMERAL_PATTERN.test(cleaned)) {\n    let total = 0;\n    let prev = 0;\n    for (let i = cleaned.length - 1; i >= 0; i -= 1) {\n      const char = cleaned[i];\n      const current = ROMAN_NUMERAL_VALUES[char];\n      if (!current) {\n        total = 0;\n        break;\n      }\n      if (current < prev) {\n        total -= current;\n      } else {\n        total += current;\n        prev = current;\n      }\n    }\n    if (total > 0) {\n      number = total;\n    }\n  }\n  return { cleaned, number };\n};\n\nconst normaliseMarkVariants = str =>\n  str.replace(/\\b(mark|mk)[\\s-]*(\\d+|[ivxlcdm]+)\\b/g, (_match, _prefix, rawValue) => {\n    const { cleaned, number } = parseMarkSuffix(rawValue);\n    if (!cleaned) return 'mk';\n    const suffix = number != null ? String(number) : cleaned;\n    return `mk${suffix}`;\n  });\n\nconst SPELLING_VARIANTS = new Map([\n  ['analyse', 'analyze'],\n  ['analysed', 'analyzed'],\n  ['analyses', 'analyzes'],\n  ['analysing', 'analyzing'],\n  ['behaviour', 'behavior'],\n  ['behaviours', 'behaviors'],\n  ['behavioural', 'behavioral'],\n  ['behaviourally', 'behaviorally'],\n  ['centre', 'center'],\n  ['centres', 'centers'],\n  ['colour', 'color'],\n  ['colourful', 'colorful'],\n  ['colouring', 'coloring'],\n  ['colourings', 'colorings'],\n  ['colourless', 'colorless'],\n  ['colours', 'colors'],\n  ['customisation', 'customization'],\n  ['customisations', 'customizations'],\n  ['customise', 'customize'],\n  ['customised', 'customized'],\n  ['customises', 'customizes'],\n  ['customising', 'customizing'],\n  ['defence', 'defense'],\n  ['defences', 'defenses'],\n  ['favour', 'favor'],\n  ['favourable', 'favorable'],\n  ['favourably', 'favorably'],\n  ['favoured', 'favored'],\n  ['favourite', 'favorite'],\n  ['favourites', 'favorites'],\n  ['favouring', 'favoring'],\n  ['favours', 'favors'],\n  ['licence', 'license'],\n  ['licences', 'licenses'],\n  ['localisation', 'localization'],\n  ['localisations', 'localizations'],\n  ['localise', 'localize'],\n  ['localised', 'localized'],\n  ['localises', 'localizes'],\n  ['localising', 'localizing'],\n  ['modelling', 'modeling'],\n  ['modeller', 'modeler'],\n  ['modellers', 'modelers'],\n  ['optimisation', 'optimization'],\n  ['optimisations', 'optimizations'],\n  ['optimise', 'optimize'],\n  ['optimised', 'optimized'],\n  ['optimises', 'optimizes'],\n  ['optimising', 'optimizing'],\n  ['organisation', 'organization'],\n  ['organisations', 'organizations'],\n  ['organise', 'organize'],\n  ['organised', 'organized'],\n  ['organises', 'organizes'],\n  ['organising', 'organizing'],\n  ['personalisation', 'personalization'],\n  ['personalisations', 'personalizations'],\n  ['personalise', 'personalize'],\n  ['personalised', 'personalized'],\n  ['personalises', 'personalizes'],\n  ['personalising', 'personalizing'],\n  ['practise', 'practice'],\n  ['practised', 'practiced'],\n  ['practises', 'practices'],\n  ['practising', 'practicing'],\n  ['theatre', 'theater'],\n  ['theatres', 'theaters'],\n  ['traveller', 'traveler'],\n  ['travellers', 'travelers'],\n  ['travelling', 'traveling']\n]);\n\nconst SPELLING_VARIANT_PATTERN =\n  SPELLING_VARIANTS.size > 0\n    ? new RegExp(`\\\\b(${Array.from(SPELLING_VARIANTS.keys()).join('|')})\\\\b`, 'g')\n    : null;\n\nconst normalizeSpellingVariants = (str) => {\n  if (!SPELLING_VARIANT_PATTERN) return str;\n  return str.replace(SPELLING_VARIANT_PATTERN, match => SPELLING_VARIANTS.get(match) || match);\n};\n\nconst searchKey       = str => {\n  if (!str) return '';\n  const value = String(str);\n  let normalized = value.toLowerCase();\n  if (typeof normalized.normalize === 'function') {\n    normalized = normalized.normalize('NFD');\n  }\n  normalized = normalized\n    .replace(/[\\u0300-\\u036f]/g, '')\n    .replace(/\xDF/g, 'ss')\n    .replace(/\xE6/g, 'ae')\n    .replace(/\u0153/g, 'oe')\n    .replace(/\xF8/g, 'o')\n    .replace(/&/g, 'and')\n    .replace(/\\+/g, 'plus')\n    .replace(/[\xB0\xBA\u02DA]/g, 'deg')\n    .replace(/\\bdegrees?\\b/g, 'deg')\n    .replace(/[\xD7\u2715\u2716\u2717\u2718]/g, 'x');\n  normalized = normalizeSpellingVariants(normalized);\n  normalized = normaliseMarkVariants(normalized);\n  const simplified = normalized.replace(/[^a-z0-9]+/g, '');\n  if (simplified) return simplified;\n  return value.toLowerCase().replace(/\\s+/g, '');\n};\n\nconst searchTokens = str => {\n  if (!str) return [];\n  let normalized = String(str).toLowerCase();\n  if (typeof normalized.normalize === 'function') {\n    normalized = normalized.normalize('NFD');\n  }\n  normalized = normalized\n    .replace(/[\\u0300-\\u036f]/g, '')\n    .replace(/\xDF/g, 'ss')\n    .replace(/\xE6/g, 'ae')\n    .replace(/\u0153/g, 'oe')\n    .replace(/\xF8/g, 'o')\n    .replace(/&/g, ' and ')\n    .replace(/\\+/g, ' plus ')\n    .replace(/[\xB0\xBA\u02DA]/g, ' deg ')\n    .replace(/\\bdegrees?\\b/g, ' deg ')\n    .replace(/[\xD7\u2715\u2716\u2717\u2718]/g, ' x by ');\n  const tokens = new Set();\n  const initialWords = [];\n  const addToken = token => {\n    if (!token) return;\n    const cleaned = token.replace(/[^a-z0-9]+/g, '');\n    if (cleaned) tokens.add(cleaned);\n  };\n  const processParts = (strToProcess, collectInitials = false) => {\n    strToProcess.split(/\\s+/).forEach(part => {\n      if (!part) return;\n      addToken(part);\n      part\n        .split(/[^a-z0-9]+/)\n        .filter(Boolean)\n        .forEach(segment => {\n          addToken(segment);\n          if (collectInitials && /^[a-z]/.test(segment)) {\n            initialWords.push(segment);\n          }\n        });\n    });\n  };\n  processParts(normalized, true);\n  const spellingNormalized = normalizeSpellingVariants(normalized);\n  if (spellingNormalized !== normalized) {\n    processParts(spellingNormalized);\n  }\n  const markNormalized = normaliseMarkVariants(spellingNormalized);\n  if (markNormalized !== spellingNormalized) {\n    processParts(markNormalized);\n  }\n  if (initialWords.length >= 2) {\n    const MAX_INITIALISM_LENGTH = 6;\n    const initials = initialWords.map(word => word[0]).filter(Boolean);\n    const limit = Math.min(initials.length, MAX_INITIALISM_LENGTH);\n    for (let start = 0; start < limit; start++) {\n      let current = '';\n      for (let index = start; index < limit; index++) {\n        current += initials[index];\n        if (current.length >= 2) {\n          addToken(current);\n        }\n      }\n    }\n  }\n  const markPattern = /\\b(mark|mk)[\\s-]*(\\d+|[ivxlcdm]+)\\b/g;\n  let match;\n  const variantSource = spellingNormalized || normalized;\n  while ((match = markPattern.exec(variantSource)) !== null) {\n    const prefix = match[1];\n    const rawValue = match[2];\n    const { cleaned, number } = parseMarkSuffix(rawValue);\n    if (!cleaned) continue;\n    const altPrefix = prefix === 'mk' ? 'mark' : 'mk';\n    addToken(prefix);\n    addToken(altPrefix);\n    addToken(cleaned);\n    addToken(`${prefix}${cleaned}`);\n    addToken(`${altPrefix}${cleaned}`);\n    if (number != null) {\n      const numberToken = String(number);\n      addToken(numberToken);\n      addToken(`${prefix}${numberToken}`);\n      addToken(`${altPrefix}${numberToken}`);\n    }\n  }\n  return Array.from(tokens);\n};\n\nconst FEATURE_CONTEXT_LIMIT = 3;\n\nconst toTitleCase = str =>\n  str.replace(/\\b([a-z])/g, (_, ch) => ch.toUpperCase());\n\nconst idToContextLabel = id => {\n  if (!id) return '';\n  const spaced = id\n    .replace(/[-_]+/g, ' ')\n    .replace(/([a-z\\d])([A-Z])/g, '$1 $2')\n    .replace(/\\s+/g, ' ')\n    .trim();\n  if (!spaced) return '';\n  return toTitleCase(spaced);\n};\n\nconst addUniqueContext = (contexts, seen, value, baseLabelLower) => {\n  if (!value) return;\n  const trimmed = value.trim();\n  if (!trimmed) return;\n  const normalized = trimmed.toLowerCase();\n  if (normalized === baseLabelLower || seen.has(normalized)) return;\n  contexts.push(trimmed);\n  seen.add(normalized);\n};\n\nconst collectFeatureContexts = (element, baseLabelLower) => {\n  if (!element || !element.parentElement) return [];\n  const contexts = [];\n  const seen = new Set();\n  let current = element.parentElement;\n  while (current && contexts.length < FEATURE_CONTEXT_LIMIT) {\n    if (typeof current.dataset?.featureContext === 'string') {\n      current.dataset.featureContext\n        .split(',')\n        .map(part => part.trim())\n        .filter(Boolean)\n        .forEach(value => addUniqueContext(contexts, seen, value, baseLabelLower));\n    }\n    const labelledBy = current.getAttribute('aria-labelledby');\n    if (labelledBy) {\n      labelledBy\n        .split(/\\s+/)\n        .map(id => id && document.getElementById(id))\n        .filter(labelEl => labelEl && labelEl !== element)\n        .forEach(labelEl => {\n          addUniqueContext(\n            contexts,\n            seen,\n            labelEl.textContent || '',\n            baseLabelLower\n          );\n        });\n    }\n    const heading = current.querySelector(\n      ':scope > h1, :scope > h2, :scope > h3, :scope > h4, :scope > legend'\n    );\n    if (heading && heading !== element) {\n      addUniqueContext(\n        contexts,\n        seen,\n        heading.textContent || '',\n        baseLabelLower\n      );\n    }\n    if (current.id) {\n      addUniqueContext(contexts, seen, idToContextLabel(current.id), baseLabelLower);\n    }\n    current = current.parentElement;\n  }\n  return contexts.reverse();\n};\n\nconst buildFeatureSearchEntry = (element, { label, keywords = '' }) => {\n  if (!element || !label) return null;\n  const baseLabel = label.trim();\n  if (!baseLabel) return null;\n  const baseKey = searchKey(baseLabel);\n  if (!baseKey) return null;\n  const baseLabelLower = baseLabel.toLowerCase();\n  const contextLabels = collectFeatureContexts(element, baseLabelLower);\n  let combinedLabel = baseLabel;\n  if (contextLabels.length) {\n    combinedLabel = `${baseLabel} (${contextLabels.join(' \u203A ')})`;\n  }\n  const combinedKeywords = [baseLabel, contextLabels.join(' '), keywords]\n    .filter(Boolean)\n    .join(' ');\n  const entry = {\n    element,\n    label: baseLabel,\n    baseLabel,\n    displayLabel: combinedLabel,\n    context: contextLabels,\n    tokens: searchTokens(combinedKeywords),\n    key: baseKey,\n    optionValue: combinedLabel\n  };\n  const existing = featureMap.get(baseKey);\n  if (!existing) {\n    featureMap.set(baseKey, entry);\n  } else if (Array.isArray(existing)) {\n    if (!existing.some(item => item && item.element === element)) {\n      existing.push(entry);\n    }\n  } else if (existing.element !== element) {\n    featureMap.set(baseKey, [existing, entry]);\n  }\n  return entry;\n};\n\nconst computeTokenMatchDetails = (entryTokens = [], queryTokens = []) => {\n  if (!Array.isArray(entryTokens) || entryTokens.length === 0) {\n    return { score: 0, matched: 0 };\n  }\n  const validQueryTokens = Array.isArray(queryTokens)\n    ? queryTokens.filter(Boolean)\n    : [];\n  if (validQueryTokens.length === 0) {\n    return { score: 0, matched: 0 };\n  }\n  let total = 0;\n  let matched = 0;\n  for (const token of validQueryTokens) {\n    let best = 0;\n    for (const entryToken of entryTokens) {\n      if (!entryToken) continue;\n      if (entryToken === token) {\n        best = 3;\n        break;\n      }\n      if (entryToken.startsWith(token) || token.startsWith(entryToken)) {\n        best = Math.max(best, 2);\n      } else if (entryToken.includes(token) || token.includes(entryToken)) {\n        best = Math.max(best, 1);\n      }\n    }\n    if (best > 0) {\n      matched += 1;\n      total += best;\n    }\n  }\n  if (matched === 0) {\n    return { score: 0, matched: 0 };\n  }\n  return { score: total, matched };\n};\n\nfunction findBestSearchMatch(map, key, tokens = []) {\n  const queryTokens = Array.isArray(tokens) ? tokens.filter(Boolean) : [];\n  const hasKey = Boolean(key);\n  if (!hasKey && queryTokens.length === 0) return null;\n\n  const toResult = (entryKey, entryValue, matchType, score = 0, matchedCount = 0) => ({\n    key: entryKey,\n    value: entryValue,\n    matchType,\n    score,\n    matchedCount\n  });\n\n  const flattened = [];\n  for (const [entryKey, entryValue] of map.entries()) {\n    if (!entryValue) continue;\n    if (Array.isArray(entryValue)) {\n      for (const value of entryValue) {\n        if (value) flattened.push([entryKey, value]);\n      }\n    } else {\n      flattened.push([entryKey, entryValue]);\n    }\n  }\n\n  if (hasKey) {\n    const exactCandidates = flattened.filter(([entryKey]) => entryKey === key);\n    if (exactCandidates.length) {\n      let bestEntry = exactCandidates[0][1];\n      let bestDetails = queryTokens.length > 0\n        ? computeTokenMatchDetails(bestEntry?.tokens || [], queryTokens)\n        : { score: Number.POSITIVE_INFINITY, matched: queryTokens.length };\n      for (const [, entryValue] of exactCandidates.slice(1)) {\n        if (!queryTokens.length) break;\n        const details = computeTokenMatchDetails(entryValue?.tokens || [], queryTokens);\n        if (\n          details.score > bestDetails.score ||\n          (details.score === bestDetails.score && details.matched > bestDetails.matched)\n        ) {\n          bestDetails = details;\n          bestEntry = entryValue;\n        }\n      }\n      return toResult(key, bestEntry, 'exactKey', bestDetails.score, bestDetails.matched);\n    }\n  }\n\n  let bestTokenMatch = null;\n  let bestTokenScore = 0;\n  let bestTokenMatched = 0;\n  let bestTokenKeyDistance = Number.POSITIVE_INFINITY;\n  let bestPrefixMatch = null;\n  let bestPrefixScore = Number.NEGATIVE_INFINITY;\n  let bestPrefixMatched = 0;\n  let bestPrefixLength = Number.POSITIVE_INFINITY;\n  let bestSubsetMatch = null;\n  let bestSubsetScore = Number.NEGATIVE_INFINITY;\n  let bestSubsetMatched = 0;\n  let bestSubsetLength = -1;\n  let bestPartialMatch = null;\n  let bestPartialScore = Number.NEGATIVE_INFINITY;\n  let bestPartialMatched = 0;\n\n  const keyLength = hasKey ? key.length : 0;\n\n  for (const [entryKey, entryValue] of flattened) {\n    if (!entryValue) continue;\n    const entryTokens = entryValue?.tokens || [];\n    const tokenDetails = queryTokens.length\n      ? computeTokenMatchDetails(entryTokens, queryTokens)\n      : { score: 0, matched: 0 };\n\n    if (hasKey && entryKey.startsWith(key)) {\n      const score = queryTokens.length > 0 ? tokenDetails.score : Number.POSITIVE_INFINITY;\n      const candidate = toResult(entryKey, entryValue, 'keyPrefix', score, tokenDetails.matched);\n      if (\n        !bestPrefixMatch ||\n        score > bestPrefixScore ||\n        (score === bestPrefixScore &&\n          (tokenDetails.matched > bestPrefixMatched ||\n            (tokenDetails.matched === bestPrefixMatched && entryKey.length < bestPrefixLength)))\n      ) {\n        bestPrefixMatch = candidate;\n        bestPrefixScore = score;\n        bestPrefixMatched = tokenDetails.matched;\n        bestPrefixLength = entryKey.length;\n      }\n    }\n\n    if (queryTokens.length) {\n      const distance = hasKey ? Math.abs(entryKey.length - keyLength) : Number.POSITIVE_INFINITY;\n      if (\n        tokenDetails.score > bestTokenScore ||\n        (tokenDetails.score === bestTokenScore &&\n          (tokenDetails.matched > bestTokenMatched ||\n            (tokenDetails.matched === bestTokenMatched && distance < bestTokenKeyDistance)))\n      ) {\n        bestTokenMatch = toResult(entryKey, entryValue, 'token', tokenDetails.score, tokenDetails.matched);\n        bestTokenScore = tokenDetails.score;\n        bestTokenMatched = tokenDetails.matched;\n        bestTokenKeyDistance = distance;\n      }\n    }\n\n    if (hasKey && key.startsWith(entryKey)) {\n      const score = queryTokens.length > 0 ? tokenDetails.score : Number.POSITIVE_INFINITY;\n      const candidate = toResult(entryKey, entryValue, 'keySubset', score, tokenDetails.matched);\n      if (\n        !bestSubsetMatch ||\n        score > bestSubsetScore ||\n        (score === bestSubsetScore &&\n          (entryKey.length > bestSubsetLength || tokenDetails.matched > bestSubsetMatched))\n      ) {\n        bestSubsetMatch = candidate;\n        bestSubsetScore = score;\n        bestSubsetMatched = tokenDetails.matched;\n        bestSubsetLength = entryKey.length;\n      }\n    } else if (\n      hasKey &&\n      (entryKey.includes(key) || key.includes(entryKey))\n    ) {\n      const candidate = toResult(entryKey, entryValue, 'partial', tokenDetails.score, tokenDetails.matched);\n      if (\n        !bestPartialMatch ||\n        tokenDetails.score > bestPartialScore ||\n        (tokenDetails.score === bestPartialScore && tokenDetails.matched > bestPartialMatched)\n      ) {\n        bestPartialMatch = candidate;\n        bestPartialScore = tokenDetails.score;\n        bestPartialMatched = tokenDetails.matched;\n      }\n    }\n  }\n\n  if (bestTokenMatch && bestTokenScore > 0) {\n    return bestTokenMatch;\n  }\n  if (bestPrefixMatch) {\n    return bestPrefixMatch;\n  }\n  if (bestSubsetMatch) {\n    return bestSubsetMatch;\n  }\n  if (bestPartialMatch) {\n    return bestPartialMatch;\n  }\n  return null;\n}\n\nconst STRONG_SEARCH_MATCH_TYPES = new Set(['exactKey', 'keyPrefix', 'keySubset']);\nconst existingDevicesHeading = document.getElementById(\"existingDevicesHeading\");\nconst batteryComparisonSection = document.getElementById(\"batteryComparison\");\nconst batteryTableElem = document.getElementById(\"batteryTable\");\nconst breakdownListElem = document.getElementById(\"breakdownList\");\nconst runtimeFeedbackBtn = document.getElementById(\"runtimeFeedbackBtn\");\nconst generateGearListBtn = document.getElementById(\"generateGearListBtn\");\nconst deleteGearListProjectBtn = document.getElementById('deleteGearListProjectBtn');\nconst gearListOutput = document.getElementById(\"gearListOutput\");\nconst projectRequirementsOutput = document.getElementById(\"projectRequirementsOutput\");\n\n// Load accent color from localStorage\nconst DEFAULT_ACCENT_COLOR = '#001589';\nlet accentColor = DEFAULT_ACCENT_COLOR;\nlet prevAccentColor = accentColor;\nconst HIGH_CONTRAST_ACCENT_COLOR = '#ffffff';\nconst DEFAULT_ACCENT_NORMALIZED = DEFAULT_ACCENT_COLOR.toLowerCase();\n\nconst normalizeAccentValue = value =>\n  typeof value === 'string' ? value.trim().toLowerCase() : '';\n\nconst DARK_MODE_ACCENT_BOOST_CLASS = 'dark-accent-boost';\nconst PINK_REFERENCE_COLOR = '#ff69b4';\nconst PINK_LUMINANCE_TOLERANCE = 0.06;\nconst BRIGHT_ACCENT_LUMINANCE_THRESHOLD = 0.6;\nconst BRIGHT_ACCENT_MIN_SATURATION = 0.35;\n\nfunction parseRgbComponent(value) {\n  const trimmed = value.trim();\n  if (!trimmed) return null;\n  if (trimmed.endsWith('%')) {\n    const percent = Number.parseFloat(trimmed.slice(0, -1));\n    if (Number.isNaN(percent)) return null;\n    return Math.max(0, Math.min(255, Math.round((percent / 100) * 255)));\n  }\n  const numeric = Number.parseFloat(trimmed);\n  if (Number.isNaN(numeric)) return null;\n  return Math.max(0, Math.min(255, Math.round(numeric)));\n}\n\nfunction parseColorToRgb(color) {\n  if (typeof color !== 'string') return null;\n  const trimmed = color.trim();\n  if (!trimmed) return null;\n  const hexMatch = trimmed.match(/^#([0-9a-f]{3}|[0-9a-f]{6})$/i);\n  if (hexMatch) {\n    const hex = hexMatch[1];\n    if (hex.length === 3) {\n      return {\n        r: Number.parseInt(hex[0] + hex[0], 16),\n        g: Number.parseInt(hex[1] + hex[1], 16),\n        b: Number.parseInt(hex[2] + hex[2], 16),\n      };\n    }\n    return {\n      r: Number.parseInt(hex.slice(0, 2), 16),\n      g: Number.parseInt(hex.slice(2, 4), 16),\n      b: Number.parseInt(hex.slice(4, 6), 16),\n    };\n  }\n  const rgbMatch = trimmed.match(/^rgba?\\(([^)]+)\\)$/i);\n  if (rgbMatch) {\n    const parts = rgbMatch[1].split(',');\n    if (parts.length < 3) return null;\n    const [r, g, b] = parts;\n    const red = parseRgbComponent(r);\n    const green = parseRgbComponent(g);\n    const blue = parseRgbComponent(b);\n    if ([red, green, blue].some(component => component === null)) return null;\n    return { r: red, g: green, b: blue };\n  }\n  return null;\n}\n\nfunction computeRelativeLuminance(rgb) {\n  if (!rgb || typeof rgb !== 'object') return 0;\n  const clamp = component => {\n    const numeric = Number(component);\n    if (!Number.isFinite(numeric)) return 0;\n    return Math.min(1, Math.max(0, numeric / 255));\n  };\n  const transform = value =>\n    value <= 0.03928\n      ? value / 12.92\n      : Math.pow((value + 0.055) / 1.055, 2.4);\n  const red = transform(clamp(rgb.r));\n  const green = transform(clamp(rgb.g));\n  const blue = transform(clamp(rgb.b));\n  return 0.2126 * red + 0.7152 * green + 0.0722 * blue;\n}\n\nfunction computeSaturation(rgb) {\n  if (!rgb || typeof rgb !== 'object') return 0;\n  const normalize = component => {\n    const numeric = Number(component);\n    if (!Number.isFinite(numeric)) return 0;\n    return Math.max(0, Math.min(1, numeric / 255));\n  };\n  const r = normalize(rgb.r);\n  const g = normalize(rgb.g);\n  const b = normalize(rgb.b);\n  const max = Math.max(r, g, b);\n  const min = Math.min(r, g, b);\n  if (max === 0) return 0;\n  if (max === min) return 0;\n  return (max - min) / max;\n}\n\nconst PINK_REFERENCE_LUMINANCE = (() => {\n  const pinkRgb = parseColorToRgb(PINK_REFERENCE_COLOR);\n  if (!pinkRgb) return 0.35;\n  return computeRelativeLuminance(pinkRgb);\n})();\n\nfunction shouldEnableDarkModeAccentBoost({ color, highContrast } = {}) {\n  if (typeof document === 'undefined') return false;\n  if (!document.body || !document.body.classList.contains('dark-mode')) return false;\n  if (document.body.classList.contains('pink-mode')) return false;\n  if (highContrast) return false;\n  if (typeof color !== 'string' || !color) return false;\n  const rgb = parseColorToRgb(color);\n  if (!rgb) return false;\n  const luminance = computeRelativeLuminance(rgb);\n  if (Math.abs(luminance - PINK_REFERENCE_LUMINANCE) <= PINK_LUMINANCE_TOLERANCE) {\n    return true;\n  }\n  const saturation = computeSaturation(rgb);\n  return (\n    luminance >= BRIGHT_ACCENT_LUMINANCE_THRESHOLD &&\n    saturation >= BRIGHT_ACCENT_MIN_SATURATION\n  );\n}\n\nfunction refreshDarkModeAccentBoost(options = {}) {\n  if (typeof document === 'undefined' || !document.body) return;\n  const shouldEnable = shouldEnableDarkModeAccentBoost(options);\n  document.body.classList.toggle(DARK_MODE_ACCENT_BOOST_CLASS, shouldEnable);\n}\n\nconst isHighContrastActive = () =>\n  typeof document !== 'undefined' &&\n  (document.documentElement.classList.contains('high-contrast') ||\n    (document.body && document.body.classList.contains('high-contrast')));\n\nconst hasCustomAccentSelection = () => {\n  const normalized = normalizeAccentValue(accentColor);\n  return normalized && normalized !== DEFAULT_ACCENT_NORMALIZED;\n};\n\nconst shouldPreserveAccentInPinkMode = () =>\n  hasCustomAccentSelection() || isHighContrastActive();\n\nconst applyAccentColor = (color) => {\n  const highContrast = isHighContrastActive();\n  const accentValue = highContrast ? HIGH_CONTRAST_ACCENT_COLOR : color;\n  const rootStyle = document.documentElement.style;\n  rootStyle.setProperty('--accent-color', accentValue);\n  if (highContrast) {\n    rootStyle.removeProperty('--link-color');\n  } else {\n    rootStyle.setProperty('--link-color', color);\n  }\n  if (document.body) {\n    const bodyStyle = document.body.style;\n    bodyStyle.setProperty('--accent-color', accentValue);\n    if (highContrast) {\n      bodyStyle.removeProperty('--link-color');\n    } else {\n      bodyStyle.setProperty('--link-color', color);\n    }\n  }\n  refreshDarkModeAccentBoost({ color: accentValue, highContrast });\n};\n\nconst clearAccentColorOverrides = () => {\n  const root = document.documentElement;\n  const rootStyle = root && root.style;\n  if (rootStyle) {\n    rootStyle.removeProperty('--accent-color');\n    rootStyle.removeProperty('--link-color');\n  }\n  if (document.body) {\n    const bodyStyle = document.body.style;\n    bodyStyle.removeProperty('--accent-color');\n    bodyStyle.removeProperty('--link-color');\n  }\n  refreshDarkModeAccentBoost({ color: null, highContrast: isHighContrastActive() });\n};\n\ntry {\n  const storedAccent = localStorage.getItem('accentColor');\n  if (storedAccent) {\n    accentColor = storedAccent;\n    applyAccentColor(accentColor);\n  }\n} catch (e) {\n  console.warn('Could not load accent color', e);\n}\nprevAccentColor = accentColor;\n\nif (accentColorInput) {\n  accentColorInput.addEventListener('input', () => {\n    if (document.body.classList.contains('pink-mode')) return;\n    const color = accentColorInput.value;\n    applyAccentColor(color);\n  });\n}\n\n// Font preferences\nlet fontSize = '16';\nlet fontFamily = \"'Ubuntu', sans-serif\";\n\nconst uiScaleRoot = document.documentElement;\nconst defaultUIScaleValues = {\n  '--page-padding': 20,\n  '--gap-size': 10,\n  '--button-size': 24,\n  '--border-radius': 5,\n  '--form-label-width': 150,\n  '--form-label-min-width': 120,\n  '--form-action-width': 110\n};\nconst uiScaleProperties = Object.keys(defaultUIScaleValues);\nconst baseUIScaleValues = { ...defaultUIScaleValues };\nlet baseFontSize = 16;\n\nif (uiScaleRoot) {\n  try {\n    const computedStyle = getComputedStyle(uiScaleRoot);\n    const computedFontSize = parseFloat(computedStyle.fontSize);\n    if (Number.isFinite(computedFontSize) && computedFontSize > 0) {\n      baseFontSize = computedFontSize;\n    }\n    for (const prop of uiScaleProperties) {\n      const value = parseFloat(computedStyle.getPropertyValue(prop));\n      if (Number.isFinite(value) && value > 0) {\n        baseUIScaleValues[prop] = value;\n      }\n    }\n  } catch (error) {\n    console.warn('Unable to read computed styles for UI scaling', error);\n  }\n}\n\nconst customFontStorageKeyName =\n  typeof CUSTOM_FONT_STORAGE_KEY_NAME !== 'undefined'\n    ? CUSTOM_FONT_STORAGE_KEY_NAME\n    : typeof CUSTOM_FONT_STORAGE_KEY !== 'undefined'\n      ? CUSTOM_FONT_STORAGE_KEY\n      : 'cameraPowerPlanner_customFonts';\nconst customFontEntries = new Map();\n\nconst SUPPORTED_FONT_TYPES = new Set([\n  'font/ttf',\n  'font/otf',\n  'font/woff',\n  'font/woff2',\n  'application/font-woff',\n  'application/font-woff2',\n  'application/x-font-ttf',\n  'application/x-font-opentype'\n]);\n\nconst SUPPORTED_FONT_EXTENSIONS = ['.ttf', '.otf', '.ttc', '.woff', '.woff2'];\n\nfunction loadCustomFontMetadataFromStorage() {\n  if (typeof localStorage === 'undefined') return [];\n  try {\n    const raw = localStorage.getItem(customFontStorageKeyName);\n    if (!raw) return [];\n    const parsed = JSON.parse(raw);\n    if (!Array.isArray(parsed)) return [];\n    return parsed\n      .map(entry => ({\n        id: entry && typeof entry.id === 'string' ? entry.id : null,\n        name: entry && typeof entry.name === 'string' ? entry.name : '',\n        data: entry && typeof entry.data === 'string' ? entry.data : ''\n      }))\n      .filter(entry => entry.id && entry.name && entry.data);\n  } catch (error) {\n    console.warn('Failed to load stored custom fonts', error);\n    return [];\n  }\n}\n\nfunction persistCustomFontsToStorage() {\n  if (typeof localStorage === 'undefined') return true;\n  try {\n    const payload = Array.from(customFontEntries.values()).map(entry => ({\n      id: entry.id,\n      name: entry.name,\n      data: entry.data\n    }));\n    localStorage.setItem(customFontStorageKeyName, JSON.stringify(payload));\n    return true;\n  } catch (error) {\n    console.warn('Could not save custom fonts', error);\n    return false;\n  }\n}\n\nfunction sanitizeCustomFontName(name) {\n  if (!name) return 'Custom Font';\n  const trimmed = String(name).trim();\n  if (!trimmed) return 'Custom Font';\n  return trimmed.replace(/\\s+/g, ' ').slice(0, 80);\n}\n\nfunction deriveFontNameFromFile(file) {\n  if (!file) return 'Custom Font';\n  const rawName = typeof file.name === 'string' ? file.name : '';\n  if (!rawName) return 'Custom Font';\n  const withoutExtension = rawName.replace(/\\.[^.]+$/, '');\n  const candidate = withoutExtension || rawName;\n  return sanitizeCustomFontName(candidate);\n}\n\nfunction ensureUniqueCustomFontName(baseName) {\n  const sanitizedBase = sanitizeCustomFontName(baseName);\n  if (!settingsFontFamily) return sanitizedBase;\n  let candidate = sanitizedBase;\n  let suffix = 2;\n  while (\n    Array.from(settingsFontFamily.options).some(\n      opt => opt.value === buildFontFamilyValue(candidate)\n    )\n  ) {\n    candidate = `${sanitizedBase} ${suffix}`;\n    suffix += 1;\n  }\n  return candidate;\n}\n\nfunction cssEscapeFontName(name) {\n  if (typeof CSS !== 'undefined' && CSS && typeof CSS.escape === 'function') {\n    return CSS.escape(name);\n  }\n  return String(name).replace(/['\"\\\\]/g, match => `\\\\${match}`);\n}\n\nasync function registerCustomFontSource(name, dataUrl, id) {\n  if (!name || !dataUrl || typeof document === 'undefined') return false;\n  let loaded = false;\n  if (\n    typeof FontFace === 'function' &&\n    document.fonts &&\n    typeof document.fonts.add === 'function'\n  ) {\n    try {\n      const fontFace = new FontFace(name, `url(${dataUrl})`);\n      await fontFace.load();\n      document.fonts.add(fontFace);\n      loaded = true;\n    } catch (error) {\n      console.warn('Failed to load custom font via FontFace', error);\n    }\n  }\n  if (!loaded) {\n    try {\n      const safeId = id || cssEscapeFontName(name).replace(/[^a-z0-9_-]+/gi, '-');\n      const styleId = `customFontStyle-${safeId}`;\n      let styleElement = document.getElementById(styleId);\n      if (!styleElement) {\n        styleElement = document.createElement('style');\n        styleElement.id = styleId;\n        if (document.head) {\n          document.head.appendChild(styleElement);\n        } else {\n          document.body.appendChild(styleElement);\n        }\n      }\n      const escapedName = cssEscapeFontName(name);\n      styleElement.textContent = `@font-face { font-family: '${escapedName}'; src: url(${dataUrl}); font-display: swap; }`;\n      loaded = true;\n    } catch (styleError) {\n      console.warn('Failed to inject custom font style', styleError);\n      return false;\n    }\n  }\n  return loaded;\n}\n\nasync function applyStoredCustomFont(entry) {\n  if (!entry || !entry.id) return null;\n  const value = buildFontFamilyValue(entry.name);\n  const { option } = ensureFontFamilyOption(value, entry.name, localFontsGroup, 'uploaded');\n  if (option) {\n    option.dataset.fontId = entry.id;\n  }\n  await registerCustomFontSource(entry.name, entry.data, entry.id);\n  return value;\n}\n\nasync function loadStoredCustomFonts() {\n  const stored = loadCustomFontMetadataFromStorage();\n  if (!stored.length) return;\n  for (const entry of stored) {\n    const normalized = {\n      id: entry.id,\n      name: sanitizeCustomFontName(entry.name),\n      data: entry.data\n    };\n    customFontEntries.set(normalized.id, normalized);\n    try {\n      await applyStoredCustomFont(normalized);\n    } catch (error) {\n      console.warn('Failed to restore custom font', normalized.name, error);\n    }\n  }\n}\n\nfunction resetCustomFontsForFactoryReset() {\n  const hadEntries = customFontEntries && typeof customFontEntries.size === 'number'\n    ? customFontEntries.size > 0\n    : false;\n\n  if (customFontEntries && typeof customFontEntries.clear === 'function') {\n    customFontEntries.clear();\n  }\n\n  let removedUploadedOption = false;\n\n  if (settingsFontFamily && settingsFontFamily.options) {\n    const options = Array.from(settingsFontFamily.options || []);\n    options.forEach(option => {\n      if (!option || !option.dataset || option.dataset.source !== 'uploaded') {\n        return;\n      }\n      removedUploadedOption = true;\n      const fontId = option.dataset.fontId || '';\n      if (option.parentNode && typeof option.parentNode.removeChild === 'function') {\n        option.parentNode.removeChild(option);\n      } else if (typeof settingsFontFamily.removeChild === 'function') {\n        settingsFontFamily.removeChild(option);\n      }\n      if (fontId && typeof document !== 'undefined') {\n        const styleId = `customFontStyle-${fontId}`;\n        const styleNode = document.getElementById(styleId);\n        if (styleNode && styleNode.parentNode) {\n          styleNode.parentNode.removeChild(styleNode);\n        }\n      }\n    });\n\n    const hasCurrentSelection = options.some(\n      option => option && option.value === settingsFontFamily.value,\n    );\n    if (!hasCurrentSelection) {\n      if (settingsFontFamily.options.length) {\n        settingsFontFamily.selectedIndex = 0;\n      } else {\n        settingsFontFamily.value = '';\n      }\n    }\n  }\n\n  if (typeof document !== 'undefined' && document.querySelectorAll) {\n    const inlineStyles = document.querySelectorAll('style[id^=\"customFontStyle-\"]');\n    inlineStyles.forEach(styleNode => {\n      if (styleNode && styleNode.parentNode) {\n        styleNode.parentNode.removeChild(styleNode);\n      }\n    });\n  }\n\n  if (typeof setLocalFontsStatus === 'function' && (hadEntries || removedUploadedOption)) {\n    setLocalFontsStatus(null);\n  }\n}\n\nfunction isSupportedFontFile(file) {\n  if (!file) return false;\n  const type = typeof file.type === 'string' ? file.type.toLowerCase() : '';\n  if (type && SUPPORTED_FONT_TYPES.has(type)) {\n    return true;\n  }\n  const name = typeof file.name === 'string' ? file.name.toLowerCase() : '';\n  return SUPPORTED_FONT_EXTENSIONS.some(ext => name.endsWith(ext));\n}\n\nfunction readFileAsDataURL(file) {\n  return new Promise((resolve, reject) => {\n    if (typeof FileReader !== 'function') {\n      reject(new Error('FileReader is unavailable'));\n      return;\n    }\n    const reader = new FileReader();\n    reader.onload = () => resolve(reader.result);\n    reader.onerror = () => reject(reader.error || new Error('Failed to read file'));\n    try {\n      reader.readAsDataURL(file);\n    } catch (error) {\n      reject(error);\n    }\n  });\n}\n\nasync function addCustomFontFromData(name, dataUrl, { persist = true } = {}) {\n  const uniqueName = ensureUniqueCustomFontName(name);\n  const value = buildFontFamilyValue(uniqueName);\n  const { option } = ensureFontFamilyOption(value, uniqueName, localFontsGroup, 'uploaded');\n  if (!option) {\n    return { name: uniqueName, value, persisted: false };\n  }\n  let entryId = option.dataset.fontId;\n  if (!entryId) {\n    entryId = `custom-font-${Date.now()}-${Math.random().toString(36).slice(2)}`;\n    option.dataset.fontId = entryId;\n  }\n  const entry = { id: entryId, name: uniqueName, data: dataUrl };\n  customFontEntries.set(entryId, entry);\n  await registerCustomFontSource(uniqueName, dataUrl, entryId);\n  let persisted = true;\n  if (persist && !persistCustomFontsToStorage()) {\n    persisted = false;\n  }\n  return { name: uniqueName, value, persisted };\n}\n\nasync function handleLocalFontFiles(fileList) {\n  if (!fileList || fileList.length === 0) {\n    setLocalFontsStatus('localFontsNoFonts');\n    return;\n  }\n  if (localFontsButton) {\n    localFontsButton.disabled = true;\n  }\n  const added = [];\n  const unsupported = [];\n  const failed = [];\n  let persistFailure = false;\n  for (const file of Array.from(fileList)) {\n    if (!isSupportedFontFile(file)) {\n      unsupported.push(file && typeof file.name === 'string' ? file.name : '');\n      continue;\n    }\n    try {\n      const dataUrl = await readFileAsDataURL(file);\n      if (!dataUrl) {\n        failed.push(file && file.name ? file.name : '');\n        continue;\n      }\n      const result = await addCustomFontFromData(deriveFontNameFromFile(file), dataUrl);\n      added.push(result);\n      if (!result.persisted) {\n        persistFailure = true;\n      }\n    } catch (error) {\n      console.warn('Failed to import custom font', error);\n      failed.push(file && typeof file.name === 'string' ? file.name : '');\n    }\n  }\n  if (added.length > 0) {\n    if (settingsFontFamily) {\n      settingsFontFamily.value = added[0].value;\n    }\n    setLocalFontsStatus(\n      'localFontsAdded',\n      added.map(item => item.name).join(', ')\n    );\n  } else if (unsupported.length > 0) {\n    setLocalFontsStatus('localFontsUnsupportedFiles', unsupported.join(', '));\n  } else if (failed.length > 0) {\n    setLocalFontsStatus('localFontsError');\n  } else {\n    setLocalFontsStatus('localFontsNoFonts');\n  }\n\n  if (persistFailure) {\n    const message = getLocalizedText('localFontsSaveError');\n    if (message) {\n      showNotification('warning', message);\n    }\n  }\n  if (unsupported.length > 0 && added.length > 0) {\n    const message = getLocalizedText('localFontsUnsupportedFiles');\n    if (message) {\n      showNotification(\n        'warning',\n        message.replace('%s', unsupported.join(', '))\n      );\n    }\n  }\n  if (failed.length > 0) {\n    const message = getLocalizedText('localFontsError');\n    if (message) {\n      showNotification('error', message);\n    }\n  }\n\n  if (localFontsButton) {\n    localFontsButton.disabled = false;\n  }\n}\n\nasync function normalizeFontResults(result) {\n  if (!result) return [];\n  if (Array.isArray(result)) return result;\n\n  const hasSymbol = typeof Symbol === 'function';\n  const asyncIteratorSymbol = hasSymbol && Symbol.asyncIterator;\n  if (asyncIteratorSymbol && typeof result[asyncIteratorSymbol] === 'function') {\n    const fonts = [];\n    for await (const font of result) {\n      fonts.push(font);\n    }\n    return fonts;\n  }\n\n  const iteratorSymbol = hasSymbol && Symbol.iterator;\n  if (iteratorSymbol && typeof result[iteratorSymbol] === 'function') {\n    return Array.from(result);\n  }\n\n  return [];\n}\n\nconst queryAvailableLocalFonts = (() => {\n  if (typeof window === 'undefined') return null;\n  if (typeof window.queryLocalFonts === 'function') {\n    return async options => normalizeFontResults(await window.queryLocalFonts(options));\n  }\n  if (\n    typeof navigator !== 'undefined' &&\n    navigator &&\n    navigator.fonts &&\n    typeof navigator.fonts.query === 'function'\n  ) {\n    const { fonts } = navigator;\n    return async options => normalizeFontResults(await fonts.query.call(fonts, options));\n  }\n  return null;\n})();\n\nconst supportsLocalFonts = typeof queryAvailableLocalFonts === 'function';\nconst canUploadFontFiles =\n  !!(\n    localFontsInput &&\n    typeof window !== 'undefined' &&\n    typeof window.FileReader === 'function' &&\n    typeof localFontsInput.click === 'function'\n  );\n\nfunction getLocalizedText(key) {\n  if (texts[currentLang] && texts[currentLang][key]) return texts[currentLang][key];\n  if (texts.en && texts.en[key]) return texts.en[key];\n  return '';\n}\n\nfunction guessFontFallback(name) {\n  if (!name) return 'sans-serif';\n  const lower = name.toLowerCase();\n  if (/(mono|code|console|courier|menlo|fixed|inconsolata|monaco)/.test(lower)) {\n    return 'monospace';\n  }\n  if (/(serif|times|garamond|georgia|baskerville|roman|palatino|bodoni|bookman)/.test(lower)) {\n    return 'serif';\n  }\n  if (/(script|hand|brush|cursive|callig|marker)/.test(lower)) {\n    return 'cursive';\n  }\n  return 'sans-serif';\n}\n\nfunction buildFontFamilyValue(name) {\n  if (!name) return fontFamily;\n  const escaped = name.replace(/\\\\/g, '\\\\').replace(/'/g, \"\\\\'\");\n  return `'${escaped}', ${guessFontFallback(name)}`;\n}\n\nfunction extractFontLabel(value) {\n  if (!value) return '';\n  const trimmed = value.trim();\n  if (!trimmed) return '';\n  const firstChar = trimmed[0];\n  if (firstChar === \"'\" || firstChar === '\"') {\n    let result = '';\n    for (let i = 1; i < trimmed.length; i += 1) {\n      const ch = trimmed[i];\n      if (ch === '\\\\') {\n        if (i + 1 < trimmed.length) {\n          result += trimmed[i + 1];\n          i += 1;\n        }\n      } else if (ch === firstChar) {\n        return result;\n      } else {\n        result += ch;\n      }\n    }\n    return result;\n  }\n  const commaIdx = trimmed.indexOf(',');\n  if (commaIdx !== -1) return trimmed.slice(0, commaIdx).trim();\n  return trimmed;\n}\n\nfunction ensureFontFamilyOption(value, label, targetGroup, source) {\n  if (!settingsFontFamily || !value) {\n    return { option: null, created: false };\n  }\n  const existing = Array.from(settingsFontFamily.options).find(opt => opt.value === value);\n  if (existing) {\n    if (source) existing.dataset.source = source;\n    if (label && !existing.textContent.trim()) existing.textContent = label;\n    return { option: existing, created: false };\n  }\n  const option = document.createElement('option');\n  option.value = value;\n  option.textContent = label || extractFontLabel(value);\n  if (source) option.dataset.source = source;\n  const container = targetGroup && typeof targetGroup.appendChild === 'function'\n    ? targetGroup\n    : settingsFontFamily;\n  container.appendChild(option);\n  return { option, created: true };\n}\n\nfunction setLocalFontsStatus(key, replacement) {\n  if (!localFontsStatus || !key) {\n    if (localFontsStatus) {\n      localFontsStatus.textContent = '';\n      localFontsStatus.setAttribute('hidden', '');\n      delete localFontsStatus.dataset.statusKey;\n      delete localFontsStatus.dataset.statusArg;\n    }\n    return;\n  }\n  const template = getLocalizedText(key);\n  const hasReplacement = replacement !== undefined && replacement !== null;\n  let message = template;\n  if (hasReplacement) {\n    const replacementText = String(replacement);\n    message = template ? template.replace('%s', replacementText) : replacementText;\n    localFontsStatus.dataset.statusArg = replacementText;\n  } else {\n    delete localFontsStatus.dataset.statusArg;\n  }\n  localFontsStatus.dataset.statusKey = key;\n  localFontsStatus.textContent = message;\n  localFontsStatus.removeAttribute('hidden');\n}\n\nasync function requestLocalFonts() {\n  if (!supportsLocalFonts || !localFontsButton || !queryAvailableLocalFonts) return;\n  localFontsButton.disabled = true;\n  try {\n    const fonts = await queryAvailableLocalFonts();\n    if (!Array.isArray(fonts) || fonts.length === 0) {\n      setLocalFontsStatus('localFontsNoFonts');\n      return;\n    }\n    const added = [];\n    const duplicates = [];\n    const seenValues = new Set();\n    for (const font of fonts) {\n      const rawName = font && (font.family || font.fullName || font.postscriptName);\n      const name = rawName ? String(rawName).trim() : '';\n      if (!name) continue;\n      const value = buildFontFamilyValue(name);\n      if (seenValues.has(value)) {\n        duplicates.push(name);\n        continue;\n      }\n      const { option, created } = ensureFontFamilyOption(\n        value,\n        name,\n        localFontsGroup,\n        'local'\n      );\n      if (!option) continue;\n      seenValues.add(option.value);\n      if (created) {\n        added.push({ name, value: option.value });\n      } else {\n        duplicates.push(name);\n      }\n    }\n    if (added.length > 0) {\n      if (settingsFontFamily) {\n        settingsFontFamily.value = added[0].value;\n      }\n      setLocalFontsStatus(\n        'localFontsAdded',\n        added.map(item => item.name).join(', ')\n      );\n    } else if (duplicates.length > 0) {\n      setLocalFontsStatus('localFontsAlreadyAdded', duplicates.join(', '));\n    } else {\n      setLocalFontsStatus('localFontsNoFonts');\n    }\n  } catch (err) {\n    console.error('Could not access local fonts', err);\n    if (\n      err &&\n      (err.name === 'NotAllowedError' || err.name === 'SecurityError') &&\n      canUploadFontFiles\n    ) {\n      setLocalFontsStatus('localFontsPermissionNeeded');\n    } else {\n      setLocalFontsStatus('localFontsError');\n    }\n  } finally {\n    localFontsButton.disabled = false;\n  }\n}\n\nif (localFontsButton) {\n  if (supportsLocalFonts || canUploadFontFiles) {\n    localFontsButton.removeAttribute('hidden');\n    localFontsButton.addEventListener('click', () => {\n      if (supportsLocalFonts) {\n        requestLocalFonts();\n      } else if (canUploadFontFiles && localFontsInput) {\n        localFontsInput.click();\n      }\n    });\n    if (!supportsLocalFonts && canUploadFontFiles) {\n      setLocalFontsStatus('localFontsFileFallback');\n    }\n  } else {\n    setLocalFontsStatus('localFontsUnsupported');\n  }\n}\n\nif (localFontsInput) {\n  localFontsInput.addEventListener('change', () => {\n    if (localFontsInput.files && localFontsInput.files.length > 0) {\n      handleLocalFontFiles(localFontsInput.files);\n    } else {\n      setLocalFontsStatus('localFontsNoFonts');\n    }\n    try {\n      localFontsInput.value = '';\n    } catch {\n      // ignore reset errors\n    }\n  });\n}\n\nloadStoredCustomFonts().catch(error => {\n  console.warn('Unable to restore stored custom fonts', error);\n});\n\nfunction applyFontSize(size) {\n  const numericSize = parseFloat(size);\n  if (!Number.isFinite(numericSize) || numericSize <= 0) {\n    return;\n  }\n\n  document.documentElement.style.fontSize = `${numericSize}px`;\n\n  if (!Number.isFinite(baseFontSize) || baseFontSize <= 0) {\n    return;\n  }\n\n  const scale = numericSize / baseFontSize;\n  for (const prop of uiScaleProperties) {\n    const baseValue = baseUIScaleValues[prop];\n    if (!Number.isFinite(baseValue) || baseValue <= 0) continue;\n    document.documentElement.style.setProperty(prop, `${baseValue * scale}px`);\n  }\n  document.documentElement.style.setProperty('--ui-scale', String(scale));\n}\n\nfunction applyFontFamily(family) {\n  document.documentElement.style.setProperty('--font-family', family);\n}\n\ntry {\n  const storedSize = localStorage.getItem('fontSize');\n  if (storedSize) {\n    fontSize = storedSize;\n    applyFontSize(fontSize);\n  }\n  const storedFamily = localStorage.getItem('fontFamily');\n  if (storedFamily) {\n    fontFamily = storedFamily;\n    applyFontFamily(fontFamily);\n  }\n} catch (e) {\n  console.warn('Could not load font preferences', e);\n}\n\nif (settingsFontSize) settingsFontSize.value = fontSize;\nif (settingsFontFamily) {\n  const hasStoredOption = Array.from(settingsFontFamily.options).some(\n    opt => opt.value === fontFamily\n  );\n  if (!hasStoredOption && fontFamily) {\n    ensureFontFamilyOption(fontFamily, extractFontLabel(fontFamily), localFontsGroup, 'local');\n  }\n  settingsFontFamily.value = fontFamily;\n}\n\nconst revertAccentColor = () => {\n  if (document.body && document.body.classList.contains('pink-mode')) {\n    if (shouldPreserveAccentInPinkMode()) {\n      applyAccentColor(prevAccentColor);\n    } else {\n      clearAccentColorOverrides();\n    }\n    return;\n  }\n  applyAccentColor(prevAccentColor);\n};\n\nfunction populateFeatureSearch() {\n  if (!featureList) return;\n  featureMap.clear();\n  helpMap.clear();\n  deviceMap.clear();\n  featureSearchEntries = [];\n  featureSearchDefaultOptions = [];\n  const registerOption = value => {\n    if (value) featureSearchDefaultOptions.push(value);\n  };\n  document\n    .querySelectorAll('h2[id], legend[id], h3[id], h4[id]')\n    .forEach(el => {\n      if (helpDialog && helpDialog.contains(el)) return;\n      const name = el.textContent.trim();\n      if (!name) return;\n      const keywords = el.dataset?.searchKeywords || el.getAttribute('data-search-keywords') || '';\n      const entry = buildFeatureSearchEntry(el, { label: name, keywords });\n      if (!entry || !entry.key) return;\n      const display = entry.optionValue || entry.displayLabel || entry.baseLabel;\n      if (!display) return;\n      registerOption(display);\n      featureSearchEntries.push({\n        type: 'feature',\n        key: entry.key,\n        display,\n        tokens: Array.isArray(entry.tokens) ? entry.tokens : [],\n        value: entry\n      });\n    });\n  if (helpDialog) {\n    helpDialog.querySelectorAll('section[data-help-section]').forEach(section => {\n      const heading = section.querySelector('h3');\n      if (!heading) return;\n      const label = heading.textContent.trim();\n      if (!label) return;\n      const keywords = section.dataset.helpKeywords || '';\n      const key = searchKey(label);\n      const tokens = searchTokens(`${label} ${keywords}`.trim());\n      const helpEntry = {\n        section,\n        label,\n        tokens\n      };\n      helpMap.set(key, helpEntry);\n      const optionValue = `${label} (help)`;\n      registerOption(optionValue);\n      featureSearchEntries.push({\n        type: 'help',\n        key,\n        display: optionValue,\n        tokens,\n        value: helpEntry\n      });\n    });\n  }\n\n  document.querySelectorAll('select').forEach(sel => {\n    sel.querySelectorAll('option').forEach(opt => {\n      const name = opt.textContent.trim();\n      if (!name || opt.value === 'None') return;\n      const key = searchKey(name);\n      if (!deviceMap.has(key)) {\n        const keywords =\n          opt.dataset?.searchKeywords ||\n          opt.getAttribute('data-search-keywords') ||\n          sel.dataset?.searchKeywords ||\n          sel.getAttribute('data-search-keywords') ||\n          '';\n        const tokens = searchTokens(`${name} ${keywords}`.trim());\n        const deviceEntry = {\n          select: sel,\n          value: opt.value,\n          label: name,\n          tokens\n        };\n        deviceMap.set(key, deviceEntry);\n        registerOption(name);\n        featureSearchEntries.push({\n          type: 'device',\n          key,\n          display: name,\n          tokens,\n          value: deviceEntry\n        });\n      }\n    });\n  });\n  renderFeatureListOptions(featureSearchDefaultOptions);\n  if (featureSearch && featureSearch.value) {\n    updateFeatureSearchSuggestions(featureSearch.value);\n  }\n}\n\nfunction setEditProjectBtnText() {\n  const btn = document.getElementById('editProjectBtn');\n  if (btn) {\n    btn.textContent = texts[currentLang].editProjectBtn;\n    btn.setAttribute('title', texts[currentLang].editProjectBtn);\n    btn.setAttribute('data-help', texts[currentLang].editProjectBtn);\n  }\n}\n\nfunction ensureEditProjectButton() {\n  let container = null;\n  if (projectRequirementsOutput && !projectRequirementsOutput.classList.contains('hidden')) {\n    container = projectRequirementsOutput;\n  } else if (gearListOutput && !gearListOutput.classList.contains('hidden')) {\n    container = gearListOutput;\n  }\n  if (!container) return;\n  let btn = document.getElementById('editProjectBtn');\n  if (!btn) {\n    btn = document.createElement('button');\n    btn.id = 'editProjectBtn';\n  }\n\n  const legacyButtonParent = btn.parentElement;\n  if (legacyButtonParent && legacyButtonParent !== container && legacyButtonParent.id !== 'editProjectBtn') {\n    legacyButtonParent.removeChild(btn);\n  }\n\n  if (!btn.dataset.editProjectBound) {\n    btn.type = 'button';\n    btn.addEventListener('click', () => {\n      const infoForDialog = currentProjectInfo\n        ? { ...currentProjectInfo }\n        : (projectForm ? collectProjectFormData() : {});\n      if (projectForm) {\n        populateProjectForm(infoForDialog || {});\n      }\n      openDialog(projectDialog);\n    });\n    btn.dataset.editProjectBound = 'true';\n  }\n  const title = container.querySelector('h2');\n  if (title && btn.parentElement !== container) {\n    title.insertAdjacentElement('afterend', btn);\n  } else if (!title && btn.parentElement !== container) {\n    container.prepend(btn);\n  }\n  btn.type = 'button';\n  setEditProjectBtnText();\n}\n\nfunction updateGearListButtonVisibility() {\n  const hasGear =\n    gearListOutput &&\n    !gearListOutput.classList.contains('hidden') &&\n    gearListOutput.innerHTML.trim() !== '';\n  if (hasGear) {\n    generateGearListBtn.classList.add('hidden');\n    if (deleteGearListProjectBtn) {\n      deleteGearListProjectBtn.classList.remove('hidden');\n    }\n    ensureEditProjectButton();\n  } else {\n    generateGearListBtn.classList.remove('hidden');\n    if (deleteGearListProjectBtn) {\n      deleteGearListProjectBtn.classList.add('hidden');\n    }\n    const btn = document.getElementById('editProjectBtn');\n    if (btn) btn.remove();\n  }\n}\n\nfunction ensureGearTableCategoryGrouping(table) {\n  if (!table) return;\n  const doc = table.ownerDocument || (typeof document !== 'undefined' ? document : null);\n  if (!doc) return;\n  const existingCategoryGroups = table.querySelectorAll('tbody.category-group');\n  if (existingCategoryGroups.length) {\n    existingCategoryGroups.forEach(group => {\n      if (!group.classList.contains('category-group')) {\n        group.classList.add('category-group');\n      }\n    });\n    table.querySelectorAll('tbody').forEach(group => {\n      if (group.querySelector('tr.category-row')) {\n        group.classList.add('category-group');\n      }\n    });\n    return;\n  }\n  const rows = Array.from(table.rows || []);\n  if (!rows.length) return;\n  const newGroups = [];\n  let currentGroup = null;\n  rows.forEach(row => {\n    if (row.classList.contains('category-row')) {\n      currentGroup = doc.createElement('tbody');\n      currentGroup.className = 'category-group';\n      currentGroup.appendChild(row);\n      newGroups.push(currentGroup);\n    } else {\n      if (!currentGroup) {\n        currentGroup = doc.createElement('tbody');\n        currentGroup.className = 'category-group';\n        newGroups.push(currentGroup);\n      }\n      currentGroup.appendChild(row);\n    }\n  });\n  Array.from(table.tBodies || []).forEach(body => {\n    if (!body.rows.length || !body.classList.contains('category-group')) {\n      body.remove();\n    }\n  });\n  newGroups.forEach(group => {\n    if (group.rows.length) table.appendChild(group);\n  });\n}\n\nlet overviewTitleCandidatesCache = null;\n\nfunction getOverviewTitleCandidates() {\n  if (overviewTitleCandidatesCache && overviewTitleCandidatesCache.length) {\n    return overviewTitleCandidatesCache;\n  }\n  const variants = new Set();\n  if (typeof texts === 'object' && texts !== null) {\n    Object.values(texts).forEach(lang => {\n      const label = lang && typeof lang.overviewTitle === 'string'\n        ? lang.overviewTitle.trim()\n        : '';\n      if (label) variants.add(label);\n    });\n  }\n  variants.add('Project Overview and Gear List');\n  variants.add('Project Overview');\n  overviewTitleCandidatesCache = Array.from(variants)\n    .filter(Boolean)\n    .sort((a, b) => b.length - a.length);\n  return overviewTitleCandidatesCache;\n}\n\nfunction extractProjectNameFromHeading(titleElement) {\n  if (!titleElement) return '';\n  if (typeof titleElement.getAttribute === 'function') {\n    const attrName = titleElement.getAttribute('data-project-name');\n    if (typeof attrName === 'string') {\n      const trimmed = attrName.trim();\n      if (trimmed) return trimmed;\n    }\n  }\n  const textValue = typeof titleElement.textContent === 'string'\n    ? titleElement.textContent.replace(/\\s+/g, ' ').trim()\n    : '';\n  if (!textValue) return '';\n\n  const quoteMatch = textValue.match(/[\u201C\"']([^\u201C\u201D\"']+)[\u201D\"']/);\n  if (quoteMatch && quoteMatch[1] && quoteMatch[1].trim()) {\n    return quoteMatch[1].trim();\n  }\n  const guillemetMatch = textValue.match(/[\xAB\u2039]([^\xBB\u203A]+)[\xBB\u203A]/);\n  if (guillemetMatch && guillemetMatch[1] && guillemetMatch[1].trim()) {\n    return guillemetMatch[1].trim();\n  }\n\n  const overviewCandidates = getOverviewTitleCandidates();\n  const lowerText = textValue.toLowerCase();\n  for (const label of overviewCandidates) {\n    const normalizedLabel = label.trim();\n    if (!normalizedLabel) continue;\n    const lowerLabel = normalizedLabel.toLowerCase();\n    if (lowerText.startsWith(lowerLabel)) {\n      let remainder = textValue.slice(normalizedLabel.length).trim();\n      if (!remainder) return '';\n      remainder = remainder.replace(/^(?:for|pour|f\xFCr|per|para)\\b\\s*/i, '').trim();\n      remainder = remainder.replace(/^(?:the|le|la|les|den|die|das|el|los|las)\\b\\s*/i, '').trim();\n      remainder = remainder.replace(/^[\u2013\u2014:-]+/, '').trim();\n      remainder = remainder.replace(/^[\"'\u201C\u201D\xAB\xBB\u2039\u203A]+/, '').replace(/[\"'\u201C\u201D\xAB\xBB\u2039\u203A]+$/, '').trim();\n      if (remainder) return remainder;\n      return '';\n    }\n  }\n\n  if (overviewCandidates.some(label => lowerText === label.toLowerCase())) {\n    return '';\n  }\n\n  const stripped = textValue.replace(/^[\"'\u201C\u201D\xAB\xBB\u2039\u203A]+/, '').replace(/[\"'\u201C\u201D\xAB\xBB\u2039\u203A]+$/, '').trim();\n  if (stripped && stripped !== textValue) {\n    return stripped;\n  }\n\n  return textValue;\n}\n\nfunction splitGearListHtml(html) {\n  if (!html) return { projectHtml: '', gearHtml: '' };\n  // Support legacy storage formats where the gear list and project\n  // requirements were saved separately as an object.\n  if (typeof html === 'object') {\n    const legacyProject = html.projectHtml || html.project || '';\n    const legacyGear = html.gearHtml || html.gear || '';\n    if (legacyProject || legacyGear) {\n      return { projectHtml: legacyProject, gearHtml: legacyGear };\n    }\n    // Some old exports used a gearList property.\n    html = html.gearList || '';\n  }\n  const doc = new DOMParser().parseFromString(html, 'text/html');\n  const title = doc.querySelector('h2');\n  const h3s = doc.querySelectorAll('h3');\n  const reqHeading = h3s[0];\n  const reqGrid = doc.querySelector('.requirements-grid');\n  const titleHtml = title ? title.outerHTML : '';\n  const projectHtml = reqHeading && reqGrid ? titleHtml + reqHeading.outerHTML + reqGrid.outerHTML : '';\n  const projectName = extractProjectNameFromHeading(title);\n  let table = doc.querySelector('.gear-table');\n  if (!table) {\n    const tables = Array.from(doc.querySelectorAll('table'));\n    if (tables.length === 1) {\n      table = tables[0];\n    } else if (tables.length > 1) {\n      const tableAfterGearHeading = tables.find(tbl => {\n        const prev = tbl.previousElementSibling;\n        return prev && prev.matches('h3') && /gear list/i.test(prev.textContent || '');\n      });\n      table = tableAfterGearHeading || tables[0];\n    }\n  }\n  const gearHeadingHtml = projectName ? `<h2>Gear List: \u201C${escapeHtml(projectName)}\u201D</h2>` : '';\n  let gearHtml = '';\n  if (table) {\n    ensureGearTableCategoryGrouping(table);\n    gearHtml = gearHeadingHtml + table.outerHTML;\n  }\n  if (!gearHtml) {\n    const bodyClone = doc.body ? doc.body.cloneNode(true) : null;\n    const bodyHtml = doc.body ? doc.body.innerHTML.trim() : '';\n    if (bodyClone) {\n      if (title) {\n        const cloneTitle = bodyClone.querySelector('h2');\n        if (cloneTitle) cloneTitle.remove();\n      }\n      if (reqHeading) {\n        const cloneHeading = bodyClone.querySelector('h3');\n        if (cloneHeading) cloneHeading.remove();\n      }\n      if (reqGrid) {\n        const cloneGrid = bodyClone.querySelector('.requirements-grid');\n        if (cloneGrid) cloneGrid.remove();\n      }\n      const fallbackHtml = bodyClone.innerHTML.trim();\n      if (fallbackHtml) {\n        gearHtml = fallbackHtml;\n      } else if (bodyHtml) {\n        gearHtml = bodyHtml;\n      }\n    } else if (bodyHtml) {\n      gearHtml = bodyHtml;\n    }\n  }\n  return { projectHtml, gearHtml };\n}\n\n// Expose for modules like overview.js\nif (typeof global !== 'undefined') {\n  global.splitGearListHtml = splitGearListHtml;\n}\n\nfunction describeRequirement(field, value) {\n  const val = value || '';\n  const parts = [];\n  if (field === 'requiredScenarios') {\n    const scenarios = val.split(',').map(s => s.trim());\n    if (scenarios.includes('Rain Machine') || scenarios.includes('Extreme rain')) {\n      parts.push('Adds rain deflector and cables for rain use.');\n    }\n    if (scenarios.includes('Trinity') || scenarios.includes('Steadicam')) {\n      parts.push('Includes D-Tap splitters and extension cables for Steadicam/Trinity rigs.');\n    }\n    if (scenarios.includes('Gimbal')) {\n      parts.push('Adds gimbal rigging and power accessories.');\n    }\n  } else if (field === 'mattebox') {\n    const v = val.toLowerCase();\n    if (v.includes('swing')) {\n      parts.push('Adds ARRI LMB 4x5 Pro Set and accessories.');\n    } else if (v.includes('rod')) {\n      parts.push('Adds ARRI LMB 4x5 15mm LWS Set and accessories.');\n    } else if (v.includes('clamp')) {\n      parts.push('Adds ARRI LMB 4x5 Clamp-On Set with adapter rings.');\n    }\n  } else if (field === 'cameraHandle') {\n    const selections = val.split(',').map(s => s.trim());\n    if (selections.includes('Hand Grips')) {\n      parts.push('Adds SHAPE Telescopic Handle kit.');\n    }\n    if (selections.includes('Handle Extension')) {\n      parts.push('Adds ARRI HEX-3 handle extension.');\n    }\n    if (selections.includes('L-Handle')) {\n      parts.push('Adds ARRI Handle Extension Set.');\n    }\n  } else if (field === 'viewfinderExtension') {\n    if (val) parts.push('Adds viewfinder extension to support accessories.');\n  } else if (field === 'gimbal') {\n    if (val) parts.push('Includes selected gimbal and support accessories.');\n  } else if (field === 'easyrig') {\n    if (val && val !== 'no further stabilisation') {\n      parts.push('Adds selected stabiliser to gear list.');\n    }\n  } else if (field === 'codec') {\n    if (val) parts.push('Notes chosen codec for post-production reference.');\n  } else if (field === 'monitoringConfiguration') {\n    if (val)\n      parts.push('Adds default monitors and cable sets for each role.');\n  } else if (field === 'videoDistribution') {\n    if (val) parts.push('Includes distribution hardware for the selected method.');\n  }\n  return parts.join(' ');\n}\n\nconst GEAR_TABLE_CATEGORY_META = Object.freeze({\n  Camera: {\n    summary: 'Primary camera body chosen for the current setup.',\n    logic: 'Always included so the crew preps the selected camera package.'\n  },\n  'Camera Support': {\n    summary: 'Baseplates, cages and handle accessories for mounting the camera.',\n    logic: 'Matched to your camera body, selected handles and any scenario add-ons.'\n  },\n  Media: {\n    summary: 'Recording media that works with the selected camera.',\n    logic: 'Picks capacities that cover the camera codecs without running out of space.'\n  },\n  Lens: {\n    summary: 'Optics selected in the project requirements.',\n    logic: 'Pulled directly from your lens choices so they travel with the kit.'\n  },\n  'Lens Support': {\n    summary: 'Lens support brackets, rails and rings sized for your glass.',\n    logic: 'Added automatically when lenses or matte box setups require additional support.'\n  },\n  'Matte box + filter': {\n    summary: 'Matte boxes, trays and filter packs.',\n    logic: 'Generated from your matte box preference and filter selections, including required adapters.'\n  },\n  'LDS (FIZ)': {\n    summary: 'Focus, iris and zoom control hardware.',\n    logic: 'Reflects the motors and controllers picked in the wireless FIZ section.'\n  },\n  'Camera Batteries': {\n    summary: 'Batteries dedicated to powering the camera body.',\n    logic: 'Sized from the camera power draw, runtime targets and hot-swap rules.'\n  },\n  'Monitoring Batteries': {\n    summary: 'Power for handheld and field monitors.',\n    logic: 'Ensures each monitor package includes enough charged batteries for the day.'\n  },\n  Chargers: {\n    summary: 'Charging stations for included battery systems.',\n    logic: 'Adds compatible chargers so battery rotations stay balanced during the shoot.'\n  },\n  Monitoring: {\n    summary: 'On-set monitoring packages for the crew.',\n    logic: 'Derived from monitoring configuration and distribution preferences in project details.'\n  },\n  'Monitoring support': {\n    summary: 'Stands, brackets, straps and cages supporting monitors.',\n    logic: 'Auto-matched to monitor sizes and usage (handheld, stand or cart setups).'\n  },\n  Rigging: {\n    summary: 'Arms, clamps and mounting hardware for accessories.',\n    logic: 'Includes core rigging plus extras triggered by scenarios like Steadicam or gimbal use.'\n  },\n  Power: {\n    summary: 'Power distribution cables and adapters.',\n    logic: 'Covers how accessories receive power from the main battery ecosystem.'\n  },\n  Grip: {\n    summary: 'Support gear like sliders, stabilisers and Easyrig options.',\n    logic: 'Reflects stabilisation preferences and active shooting scenarios.'\n  },\n  'Carts and Transportation': {\n    summary: 'Carts, cases and transport aids for the camera department.',\n    logic: 'Included so the crew can move, stage and secure the package efficiently.'\n  },\n  Miscellaneous: {\n    summary: 'Utility items that keep the crew efficient and comfortable.',\n    logic: 'Adds weather protection and helpful tools based on scenarios and best practices.'\n  },\n  Consumables: {\n    summary: 'Expendables such as tapes, wipes and covers.',\n    logic: 'Scaled to shoot length and weather needs so consumables never run short.'\n  }\n});\n\nconst DEFAULT_GEAR_TABLE_CATEGORY_META = Object.freeze({\n  summary: 'Automatically generated grouping of related equipment.',\n  logic: 'Filled using your project requirements, selections and saved auto gear rules.'\n});\n\nconst getGearTableCategoryMeta = category => {\n  if (!category) return DEFAULT_GEAR_TABLE_CATEGORY_META;\n  return GEAR_TABLE_CATEGORY_META[category] || DEFAULT_GEAR_TABLE_CATEGORY_META;\n};\n\nconst buildGearTableCategoryHelp = category => {\n  const meta = getGearTableCategoryMeta(category);\n  const parts = [];\n  if (category) parts.push(`${category} \u2013 ${meta.summary}`);\n  else parts.push(meta.summary);\n  if (meta.logic) parts.push(`Logic: ${meta.logic}`);\n  return parts.join(' ');\n};\n\nconst formatDeviceCategoryLabel = category => {\n  if (typeof category !== 'string' || !category.trim()) return '';\n  return category\n    .replace(/[_-]+/g, ' ')\n    .replace(/([a-z])([A-Z])/g, '$1 $2')\n    .split(/\\s+/)\n    .filter(Boolean)\n    .map(word => word.charAt(0).toUpperCase() + word.slice(1))\n    .join(' ');\n};\n\nconst formatDeviceCategoryPath = path => {\n  if (!Array.isArray(path) || !path.length) return '';\n  return path\n    .map(part => formatDeviceCategoryLabel(part))\n    .filter(Boolean)\n    .join(' \u203A ');\n};\n\nfunction displayGearAndRequirements(html) {\n  const { projectHtml, gearHtml } = splitGearListHtml(html);\n  if (projectRequirementsOutput) {\n    if (projectHtml) {\n      projectRequirementsOutput.innerHTML = projectHtml;\n      projectRequirementsOutput.classList.remove('hidden');\n      projectRequirementsOutput.querySelectorAll('.requirement-box').forEach(box => {\n        const label = box.querySelector('.req-label')?.textContent || '';\n        const value = box.querySelector('.req-value')?.textContent || '';\n        const field = box.getAttribute('data-field') || '';\n        const baseDesc = value ? `${label}: ${value}` : label;\n        const logic = describeRequirement(field, value);\n        const desc = logic ? `${baseDesc} \u2013 ${logic}` : baseDesc;\n        box.setAttribute('title', desc);\n        box.setAttribute('data-help', desc);\n        box.querySelectorAll('.req-label, .req-value').forEach(el => {\n          el.setAttribute('title', desc);\n          el.setAttribute('data-help', desc);\n        });\n      });\n      adjustGearListSelectWidths(projectRequirementsOutput);\n    } else {\n      projectRequirementsOutput.innerHTML = '';\n      projectRequirementsOutput.classList.add('hidden');\n    }\n  }\n  if (gearListOutput) {\n    if (gearHtml) {\n      gearListOutput.innerHTML = gearHtml;\n      gearListOutput.classList.remove('hidden');\n      applyFilterSelectionsToGearList();\n      renderFilterDetails();\n      const findDevice = name => {\n        if (typeof name !== 'string' || !name.trim()) {\n          return { info: null, category: '', categoryPath: [] };\n        }\n        const visited = new Set();\n        const search = (node, path) => {\n          if (!isPlainObjectValue(node) || visited.has(node)) return null;\n          visited.add(node);\n          if (\n            Object.prototype.hasOwnProperty.call(node, name) &&\n            isPlainObjectValue(node[name])\n          ) {\n            return { info: node[name], categoryPath: path };\n          }\n          for (const [key, value] of Object.entries(node)) {\n            if (!isPlainObjectValue(value)) continue;\n            const result = search(value, path.concat(key));\n            if (result) return result;\n          }\n          return null;\n        };\n        const result = search(devices, []);\n        if (result) {\n          return {\n            info: result.info,\n            category: formatDeviceCategoryPath(result.categoryPath),\n            categoryPath: result.categoryPath\n          };\n        }\n        return { info: null, category: '', categoryPath: [] };\n      };\n\n      const buildGearItemHelp = ({\n        name,\n        countText,\n        deviceInfo,\n        libraryCategory,\n        tableCategory\n      }) => {\n        const parts = [];\n        const label = `${countText || ''}${name}`.trim();\n        if (label) parts.push(label);\n        const meta = getGearTableCategoryMeta(tableCategory);\n        const categoryParts = [];\n        if (tableCategory) categoryParts.push(`Gear list section: ${tableCategory}`);\n        if (meta.summary) categoryParts.push(meta.summary);\n        if (meta.logic) categoryParts.push(`Logic: ${meta.logic}`);\n        if (!tableCategory && !categoryParts.length) {\n          const fallback = getGearTableCategoryMeta('');\n          if (fallback.summary) categoryParts.push(fallback.summary);\n          if (fallback.logic) categoryParts.push(`Logic: ${fallback.logic}`);\n        }\n        if (categoryParts.length) parts.push(categoryParts.join(' \u2013 '));\n        if (libraryCategory) parts.push(`Device library category: ${libraryCategory}`);\n        if (deviceInfo) {\n          let summary = generateConnectorSummary(deviceInfo);\n          summary = summary\n            ? summary.replace(/<[^>]+>/g, '').replace(/\\s+/g, ' ').trim()\n            : '';\n          if (deviceInfo.notes)\n            summary = summary ? `${summary}; Notes: ${deviceInfo.notes}` : deviceInfo.notes;\n          if (summary) parts.push(summary);\n        }\n        return parts.join(' \u2013 ');\n      };\n\n      gearListOutput.querySelectorAll('tbody.category-group').forEach(group => {\n        const headingCell = group.querySelector('.category-row td');\n        if (!headingCell) return;\n        const tableCategory = headingCell.textContent.trim();\n        group.setAttribute('data-gear-table-category', tableCategory);\n        const helpText = buildGearTableCategoryHelp(tableCategory);\n        headingCell.setAttribute('title', helpText);\n        headingCell.setAttribute('data-help', helpText);\n      });\n\n      gearListOutput.querySelectorAll('.gear-item').forEach(span => {\n        const name = span.getAttribute('data-gear-name') || span.textContent.trim();\n        const { info, category } = findDevice(name);\n        const countMatch = span.textContent.trim().match(/^(\\d+)x\\s+/);\n        const count = countMatch ? `${countMatch[1]}x ` : '';\n        const tableCategory = span\n          .closest('tbody.category-group')\n          ?.getAttribute('data-gear-table-category');\n        const desc = buildGearItemHelp({\n          name,\n          countText: count,\n          deviceInfo: info,\n          libraryCategory: category,\n          tableCategory: tableCategory || ''\n        });\n        span.setAttribute('title', desc);\n        span.setAttribute('data-help', desc);\n        span.querySelectorAll('select').forEach(sel => {\n          sel.setAttribute('title', desc);\n          sel.setAttribute('data-help', desc);\n          initFavoritableSelect(sel);\n        });\n      });\n\n      // Standalone selects (not wrapped in .gear-item) still need descriptive help\n      gearListOutput.querySelectorAll('select').forEach(sel => {\n        if (sel.getAttribute('data-help')) return;\n        const selected = sel.selectedOptions && sel.selectedOptions[0];\n        const name = selected ? selected.textContent.trim() : sel.value;\n        const { info, category } = findDevice(name);\n        const tableCategory = sel\n          .closest('tbody.category-group')\n          ?.getAttribute('data-gear-table-category');\n        const desc = buildGearItemHelp({\n          name,\n          countText: '1x ',\n          deviceInfo: info,\n          libraryCategory: category,\n          tableCategory: tableCategory || ''\n        });\n        sel.setAttribute('title', desc);\n        sel.setAttribute('data-help', desc);\n        initFavoritableSelect(sel);\n      });\n      adjustGearListSelectWidths(gearListOutput);\n    } else {\n      gearListOutput.innerHTML = '';\n      gearListOutput.classList.add('hidden');\n    }\n  }\n  if (loadedSetupState) {\n    setSliderBowlValue(loadedSetupState.sliderBowl || '');\n    setEasyrigValue(loadedSetupState.easyrig || '');\n  }\n  updateGearListButtonVisibility();\n}\nfunction getSliderBowlSelect() {\n  return gearListOutput ? gearListOutput.querySelector('#gearListSliderBowl') : null;\n}\nfunction getSliderBowlValue() {\n  const sel = getSliderBowlSelect();\n  if (sel) return sel.value;\n  return loadedSetupState && loadedSetupState.sliderBowl ? loadedSetupState.sliderBowl : '';\n}\nfunction setSliderBowlValue(val) {\n  const sel = getSliderBowlSelect();\n  if (sel && val && Array.from(sel.options).some(opt => opt.value === val)) {\n    sel.value = val;\n    adjustGearListSelectWidth(sel);\n  }\n}\nfunction getEasyrigSelect() {\n  return gearListOutput ? gearListOutput.querySelector('#gearListEasyrig') : null;\n}\nfunction getEasyrigValue() {\n  const sel = getEasyrigSelect();\n  if (sel) return sel.value;\n  return loadedSetupState && loadedSetupState.easyrig ? loadedSetupState.easyrig : '';\n}\nfunction setEasyrigValue(val) {\n  const sel = getEasyrigSelect();\n  if (sel && val && Array.from(sel.options).some(opt => opt.value === val)) {\n    sel.value = val;\n    adjustGearListSelectWidth(sel);\n  }\n}\n\nlet currentProjectInfo = null;\nlet loadedSetupState = null;\nlet loadedSetupStateSignature = '';\nlet restoringSession = false;\nlet skipNextGearListRefresh = false;\n\nlet defaultProjectInfoSnapshot = null;\n\nfunction sanitizeProjectInfoValue(value) {\n  if (value === null || value === undefined) return undefined;\n  if (typeof value === 'string') {\n    const trimmed = value.trim();\n    return trimmed ? trimmed : undefined;\n  }\n  if (typeof value === 'number') {\n    return Number.isNaN(value) ? undefined : value;\n  }\n  if (typeof value === 'boolean') {\n    return value ? value : undefined;\n  }\n  if (Array.isArray(value)) {\n    const sanitized = value\n      .map((item) => sanitizeProjectInfoValue(item))\n      .filter((item) => item !== undefined);\n    return sanitized.length ? sanitized : undefined;\n  }\n  if (typeof value === 'object') {\n    const sanitizedObj = sanitizeProjectInfo(value);\n    return sanitizedObj || undefined;\n  }\n  return undefined;\n}\n\nfunction sanitizeProjectInfo(info) {\n  if (!info || typeof info !== 'object') return null;\n  const result = {};\n  Object.entries(info).forEach(([key, value]) => {\n    const sanitized = sanitizeProjectInfoValue(value);\n    if (sanitized !== undefined) {\n      result[key] = sanitized;\n    }\n  });\n  return Object.keys(result).length > 0 ? result : null;\n}\n\nfunction projectInfoEquals(a, b) {\n  if (a === b) return true;\n  if (!a || !b) return false;\n  if (Array.isArray(a) && Array.isArray(b)) {\n    if (a.length !== b.length) return false;\n    for (let i = 0; i < a.length; i += 1) {\n      if (!projectInfoEquals(a[i], b[i])) return false;\n    }\n    return true;\n  }\n  if (typeof a === 'object' && typeof b === 'object') {\n    const aKeys = Object.keys(a);\n    const bKeys = Object.keys(b);\n    if (aKeys.length !== bKeys.length) return false;\n    return aKeys.every((key) => projectInfoEquals(a[key], b[key]));\n  }\n  return false;\n}\n\nfunction ensureDefaultProjectInfoSnapshot() {\n  if (defaultProjectInfoSnapshot !== null) return;\n  if (!projectForm) {\n    defaultProjectInfoSnapshot = {};\n    return;\n  }\n  const baseInfo = collectProjectFormData ? collectProjectFormData() : {};\n  baseInfo.sliderBowl = getSliderBowlValue();\n  baseInfo.easyrig = getEasyrigValue();\n  defaultProjectInfoSnapshot = sanitizeProjectInfo(baseInfo) || {};\n}\n\nfunction deriveProjectInfo(info) {\n  ensureDefaultProjectInfoSnapshot();\n  const sanitized = sanitizeProjectInfo(info);\n  if (!sanitized) return null;\n  if (\n    defaultProjectInfoSnapshot &&\n    projectInfoEquals(sanitized, defaultProjectInfoSnapshot)\n  ) {\n    return null;\n  }\n  return sanitized;\n}\n\nfunction setCurrentProjectInfo(info) {\n  currentProjectInfo = info;\n}\n\nfunction getCurrentProjectInfo() {\n  return currentProjectInfo;\n}\n\nfunction stableStringify(value) {\n  if (value === null) return 'null';\n  if (value === undefined) return 'undefined';\n  if (Array.isArray(value)) {\n    return `[${value.map(item => stableStringify(item)).join(',')}]`;\n  }\n  if (typeof value === 'object') {\n    const keys = Object.keys(value).sort();\n    const entries = keys.map(key => `${JSON.stringify(key)}:${stableStringify(value[key])}`);\n    return `{${entries.join(',')}}`;\n  }\n  return JSON.stringify(value);\n}\n\nfunction computeSetupSignature(state) {\n  if (!state) return '';\n  return [\n    state.camera || '',\n    state.monitor || '',\n    state.video || '',\n    state.cage || '',\n    stableStringify(state.motors || []),\n    stableStringify(state.controllers || []),\n    state.distance || '',\n    state.batteryPlate || '',\n    state.battery || '',\n    state.batteryHotswap || '',\n    state.sliderBowl || '',\n    state.easyrig || '',\n    stableStringify(state.projectInfo || null),\n    stableStringify(state.autoGearRules || null)\n  ].join('||');\n}\n\nfunction storeLoadedSetupState(state) {\n  loadedSetupState = state;\n  loadedSetupStateSignature = computeSetupSignature(state);\n}\n\nfunction getCurrentSetupState() {\n  const info = projectForm ? collectProjectFormData() : {};\n  info.sliderBowl = getSliderBowlValue();\n  info.easyrig = getEasyrigValue();\n  const projectInfo = deriveProjectInfo(info);\n  const state = {\n    camera: cameraSelect.value,\n    monitor: monitorSelect.value,\n    video: videoSelect.value,\n    cage: cageSelect.value,\n    motors: motorSelects.map(sel => sel.value),\n    controllers: controllerSelects.map(sel => sel.value),\n    distance: distanceSelect.value,\n    batteryPlate: batteryPlateSelect.value,\n    battery: batterySelect.value,\n    batteryHotswap: hotswapSelect.value,\n    sliderBowl: info.sliderBowl,\n    easyrig: info.easyrig,\n    projectInfo\n  };\n  const projectRules = getProjectScopedAutoGearRules();\n  if (projectRules && projectRules.length) {\n    state.autoGearRules = projectRules;\n  }\n  return state;\n}\n\nfunction hasAnyDeviceSelection(state) {\n  if (!state) return false;\n  const isMeaningfulSelection = (value) => {\n    if (Array.isArray(value)) {\n      return value.some((item) => isMeaningfulSelection(item));\n    }\n    if (value == null) return false;\n    const normalized = typeof value === 'string' ? value.trim() : value;\n    if (!normalized) return false;\n    if (typeof normalized === 'string' && normalized.toLowerCase() === 'none') {\n      return false;\n    }\n    return true;\n  };\n\n  const primarySelections = [\n    state.camera,\n    state.monitor,\n    state.video,\n    state.cage,\n    state.batteryPlate,\n    state.battery,\n    state.batteryHotswap\n  ];\n\n  if (primarySelections.some((value) => isMeaningfulSelection(value))) {\n    return true;\n  }\n\n  if (isMeaningfulSelection(state.motors)) {\n    return true;\n  }\n\n  if (isMeaningfulSelection(state.controllers)) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction checkSetupChanged() {\n  if (!saveSetupBtn) return;\n  const langTexts = texts[currentLang] || {};\n  const fallbackTexts = texts.en || {};\n  const saveLabel = langTexts.saveSetupBtn || fallbackTexts.saveSetupBtn || '';\n  const updateLabel = langTexts.updateSetupBtn || fallbackTexts.updateSetupBtn || saveLabel;\n  const typedName = setupNameInput && typeof setupNameInput.value === 'string'\n    ? setupNameInput.value.trim()\n    : '';\n  const selectedName = setupSelect && typeof setupSelect.value === 'string'\n    ? setupSelect.value\n    : '';\n  if (selectedName && typedName && typedName !== selectedName) {\n    setButtonLabelWithIcon(saveSetupBtn, updateLabel);\n    return;\n  }\n  if (\n    loadedSetupState &&\n    selectedName &&\n    typedName === selectedName\n  ) {\n    const currentSignature = computeSetupSignature(getCurrentSetupState());\n    if (currentSignature !== loadedSetupStateSignature) {\n      setButtonLabelWithIcon(saveSetupBtn, updateLabel);\n      return;\n    }\n  }\n  setButtonLabelWithIcon(saveSetupBtn, saveLabel);\n}\n\nconst projectDialog = document.getElementById(\"projectDialog\");\nconst projectForm = document.getElementById(\"projectForm\");\nconst filterSelectElem = document.getElementById('filter');\nconst filterDetailsStorage = document.getElementById('filterDetails');\nconst matteboxSelect = document.getElementById('mattebox');\nconst projectCancelBtn = document.getElementById(\"projectCancel\");\nconst feedbackDialog = document.getElementById(\"feedbackDialog\");\nconst feedbackForm = document.getElementById(\"feedbackForm\");\nconst feedbackCancelBtn = document.getElementById(\"fbCancel\");\nconst feedbackUseLocationBtn = document.getElementById(\"fbUseLocationBtn\");\nconst feedbackSubmitBtn = document.getElementById(\"fbSubmit\");\nif (feedbackCancelBtn) {\n  const cancelLabel =\n    feedbackCancelBtn.textContent?.trim() ||\n    texts[currentLang]?.cancelEditBtn ||\n    texts.en?.cancelEditBtn ||\n    'Cancel';\n  setButtonLabelWithIcon(feedbackCancelBtn, cancelLabel, ICON_GLYPHS.circleX);\n}\nif (feedbackUseLocationBtn) {\n  const locationLabel = feedbackUseLocationBtn.textContent?.trim() || 'Use Current Location';\n  setButtonLabelWithIcon(feedbackUseLocationBtn, locationLabel, ICON_GLYPHS.pin);\n}\nif (feedbackSubmitBtn) {\n  const submitLabel =\n    feedbackSubmitBtn.textContent?.trim() ||\n    texts[currentLang]?.feedbackSubmit ||\n    texts.en?.feedbackSubmit ||\n    'Save & Submit';\n  setButtonLabelWithIcon(feedbackSubmitBtn, submitLabel, ICON_GLYPHS.paperPlane);\n}\nconst loadFeedbackSafe = typeof loadFeedback === 'function' ? loadFeedback : () => ({});\nconst saveFeedbackSafe = typeof saveFeedback === 'function' ? saveFeedback : () => {};\nconst setupDiagramContainer = document.getElementById(\"diagramArea\");\nconst diagramLegend = document.getElementById(\"diagramLegend\");\nconst downloadDiagramBtn = document.getElementById(\"downloadDiagram\");\nconst zoomInBtn = document.getElementById(\"zoomIn\");\nconst zoomOutBtn = document.getElementById(\"zoomOut\");\nconst resetViewBtn = document.getElementById(\"resetView\");\nconst gridSnapToggleBtn = document.getElementById(\"gridSnapToggle\");\nconst diagramHint = document.getElementById(\"diagramHint\");\n\nlet manualPositions = {};\nlet lastDiagramPositions = {};\nlet gridSnap = false;\nlet cleanupDiagramInteractions = null;\n\n// CSS used when exporting the setup diagram\nconst diagramCssLight = `\n.node-box{fill:#f0f0f0;stroke:none;}\n.node-box.first-fiz{stroke:none;}\n.first-fiz-highlight{stroke:url(#firstFizGrad);stroke-width:1px;fill:none;}\n.node-icon{font-size:var(--font-size-diagram-icon, 24px);font-family:'UiconsThinStraightV2',system-ui,sans-serif;font-style:normal;}\n.node-icon[data-icon-font='essential']{font-family:'EssentialIconsV2',system-ui,sans-serif;}\n.conn{stroke:none;}\n.conn.red{fill:#d33;}\n.conn.blue{fill:#369;}\n.conn.green{fill:#090;}\ntext{font-family:system-ui,sans-serif;}\n.edge-label{font-size:var(--font-size-diagram-label, 11px);}\nline{stroke:#333;stroke-width:2px;}\npath.edge-path{stroke:#333;stroke-width:2px;fill:none;}\npath.power{stroke:#d33;}\npath.video{stroke:#369;}\npath.fiz{stroke:#090;}\n.diagram-placeholder{font-style:italic;color:#666;margin:0;}\n`;\nconst diagramCssDark = `\n.node-box{fill:#444;stroke:none;}\n.node-box.first-fiz{stroke:none;}\n.first-fiz-highlight{stroke:url(#firstFizGrad);}\n.node-icon{font-size:var(--font-size-diagram-icon, 24px);font-family:'UiconsThinStraightV2',system-ui,sans-serif;font-style:normal;}\n.node-icon[data-icon-font='essential']{font-family:'EssentialIconsV2',system-ui,sans-serif;}\ntext{fill:#fff;font-family:system-ui,sans-serif;}\n.edge-label{font-size:var(--font-size-diagram-label, 11px);}\nline{stroke:#fff;}\npath.edge-path{stroke:#fff;}\npath.power{stroke:#ff6666;}\npath.video{stroke:#7ec8ff;}\npath.fiz{stroke:#6f6;}\n.conn.red{fill:#ff6666;}\n.conn.blue{fill:#7ec8ff;}\n.conn.green{fill:#6f6;}\n.diagram-placeholder{color:#bbb;}\n`;\n\nfunction getDiagramCss(includeDark = true) {\n  return diagramCssLight + (includeDark ? `@media (prefers-color-scheme: dark){${diagramCssDark}}` : '');\n}\n\n// Dedicated Uicons for the setup diagram.\nconst DIAGRAM_BATTERY_ICON = iconGlyph('\\uE1A6');\nconst DIAGRAM_CAMERA_ICON = iconGlyph('\\uE333');\nconst DIAGRAM_MONITOR_ICON = iconGlyph('\\uEFFC');\nconst DIAGRAM_VIEWFINDER_ICON = iconGlyph('\\uE338');\nconst DIAGRAM_VIDEO_ICON = iconGlyph('\\uF42A');\nconst DIAGRAM_WIRELESS_ICON = iconGlyph('\\uF4AC');\nconst DIAGRAM_MOTORS_ICON = iconGlyph('\\uE8AF', ICON_FONT_KEYS.UICONS);\nconst DIAGRAM_CONTROLLER_ICON = iconGlyph('\\uE52A');\nconst DIAGRAM_DISTANCE_ICON = iconGlyph('\\uEFB9');\nconst DIAGRAM_POWER_OUTPUT_ICON = iconGlyph('\\uE212');\nconst DIAGRAM_POWER_INPUT_ICON = iconGlyph('\\uEE71');\nconst DIAGRAM_TIMECODE_ICON = iconGlyph('\\uE46F');\nconst DIAGRAM_AUDIO_IN_ICON = iconGlyph('\\uE6B7');\nconst DIAGRAM_AUDIO_OUT_ICON = iconGlyph('\\uECB5');\nconst DIAGRAM_AUDIO_IO_ICON = iconGlyph('\\uF487');\n\nconst diagramConnectorIcons = Object.freeze({\n  powerOut: DIAGRAM_POWER_OUTPUT_ICON,\n  powerIn: DIAGRAM_POWER_INPUT_ICON,\n  fiz: DIAGRAM_MOTORS_ICON,\n  video: DIAGRAM_VIDEO_ICON,\n  timecode: DIAGRAM_TIMECODE_ICON,\n  audioIn: DIAGRAM_AUDIO_IN_ICON,\n  audioOut: DIAGRAM_AUDIO_OUT_ICON,\n  audioIo: DIAGRAM_AUDIO_IO_ICON,\n  torque: DIAGRAM_MOTORS_ICON,\n  controller: DIAGRAM_CONTROLLER_ICON,\n  powerSpec: DIAGRAM_POWER_OUTPUT_ICON,\n  powerSource: DIAGRAM_POWER_INPUT_ICON\n});\n\nconst diagramIcons = {\n  battery: DIAGRAM_BATTERY_ICON,\n  camera: DIAGRAM_CAMERA_ICON,\n  monitor: DIAGRAM_MONITOR_ICON,\n  viewfinder: DIAGRAM_VIEWFINDER_ICON,\n  video: DIAGRAM_WIRELESS_ICON,\n  motors: DIAGRAM_MOTORS_ICON,\n  controllers: DIAGRAM_CONTROLLER_ICON,\n  handle: DIAGRAM_CONTROLLER_ICON,\n  distance: DIAGRAM_DISTANCE_ICON\n};\n\n// Map overview section keys to diagram icons\n/* exported overviewSectionIcons */\nconst overviewSectionIcons = {\n  category_batteries: diagramIcons.battery,\n  category_batteryHotswaps: diagramIcons.battery,\n  category_cameras: diagramIcons.camera,\n  category_viewfinders: diagramIcons.viewfinder,\n  category_monitors: diagramIcons.monitor,\n  category_video: diagramIcons.video,\n  category_fiz_motors: diagramIcons.motors,\n  category_fiz_controllers: diagramIcons.controllers,\n  category_fiz_distance: diagramIcons.distance\n};\n\nconst cameraProjectLegendIcon = document.getElementById('cameraProjectLegendIcon');\nif (cameraProjectLegendIcon) {\n  applyIconGlyph(cameraProjectLegendIcon, DIAGRAM_CAMERA_ICON);\n}\n\n// Load an image and optionally strip a solid background using Canvas\n// List filters for existing device categories\n\n// NEW SETUP MANAGEMENT DOM ELEMENTS\nconst generateOverviewBtn = document.getElementById('generateOverviewBtn');\n\nconst videoOutputOptions = [\n  '3G-SDI',\n  '6G-SDI',\n  '12G-SDI',\n  'Mini BNC',\n  'HDMI',\n  'Mini HDMI',\n  'Micro HDMI'\n];\n\nfunction getAllFizConnectorTypes() {\n  const types = new Set();\n  Object.values(devices.cameras).forEach(cam => {\n    if (Array.isArray(cam.fizConnectors)) {\n      cam.fizConnectors.forEach(fc => {\n        if (fc && fc.type) types.add(fc.type);\n      });\n    }\n  });\n  return Array.from(types).sort(localeSort);\n}\n\nlet fizConnectorOptions = getAllFizConnectorTypes();\n\nfunction updateFizConnectorOptions() {\n  fizConnectorOptions = getAllFizConnectorTypes();\n  document.querySelectorAll('.fiz-connector-select').forEach(sel => {\n    const current = sel.value;\n    sel.innerHTML = '';\n    addEmptyOption(sel);\n    fizConnectorOptions.forEach(optVal => {\n      const opt = document.createElement('option');\n      opt.value = optVal;\n      opt.textContent = optVal;\n      sel.appendChild(opt);\n    });\n    if (fizConnectorOptions.includes(current)) {\n      sel.value = current;\n    }\n  });\n}\n\nfunction getAllMotorConnectorTypes() {\n  const types = new Set();\n  Object.values(devices.fiz?.motors || {}).forEach(m => {\n    if (m && m.fizConnector) types.add(m.fizConnector);\n  });\n  return Array.from(types).filter(Boolean).sort(localeSort);\n}\n\nlet motorConnectorOptions = getAllMotorConnectorTypes();\n\nfunction updateMotorConnectorOptions() {\n  motorConnectorOptions = getAllMotorConnectorTypes();\n  if (motorConnectorInput) {\n    const cur = motorConnectorInput.value;\n    motorConnectorInput.innerHTML = '';\n    addEmptyOption(motorConnectorInput);\n    motorConnectorOptions.forEach(optVal => {\n      const opt = document.createElement('option');\n      opt.value = optVal;\n      opt.textContent = optVal;\n      motorConnectorInput.appendChild(opt);\n    });\n    if (motorConnectorOptions.includes(cur)) motorConnectorInput.value = cur;\n  }\n}\n\nfunction getAllControllerConnectors() {\n  const types = new Set();\n  Object.values(devices.fiz?.controllers || {}).forEach(c => {\n    if (c && Array.isArray(c.fizConnectors)) {\n      c.fizConnectors.forEach(fc => { if (fc && fc.type) types.add(fc.type); });\n    }\n  });\n  return Array.from(types).filter(Boolean).sort(localeSort);\n}\n\nfunction getAllControllerPowerSources() {\n  const types = new Set();\n  Object.values(devices.fiz?.controllers || {}).forEach(c => {\n    if (c && c.powerSource) types.add(c.powerSource);\n  });\n  return Array.from(types).filter(Boolean).sort(localeSort);\n}\n\nfunction getAllControllerBatteryTypes() {\n  const types = new Set();\n  Object.values(devices.fiz?.controllers || {}).forEach(c => {\n    if (c && c.batteryType) types.add(c.batteryType);\n  });\n  return Array.from(types).filter(Boolean).sort(localeSort);\n}\n\nfunction getAllControllerConnectivity() {\n  const types = new Set();\n  Object.values(devices.fiz?.controllers || {}).forEach(c => {\n    if (c && c.connectivity) types.add(c.connectivity);\n  });\n  return Array.from(types).filter(Boolean).sort(localeSort);\n}\n\nlet controllerConnectorOptions = getAllControllerConnectors();\nlet controllerPowerOptions = getAllControllerPowerSources();\nlet controllerBatteryOptions = getAllControllerBatteryTypes();\nlet controllerConnectivityOptions = getAllControllerConnectivity();\n\nfunction updateControllerConnectorOptions() {\n  controllerConnectorOptions = getAllControllerConnectors();\n  if (controllerConnectorInput) {\n    const cur = controllerConnectorInput.value;\n    controllerConnectorInput.innerHTML = '';\n    addEmptyOption(controllerConnectorInput);\n    controllerConnectorOptions.forEach(optVal => {\n      const opt = document.createElement('option');\n      opt.value = optVal;\n      opt.textContent = optVal;\n      controllerConnectorInput.appendChild(opt);\n    });\n    if (controllerConnectorOptions.includes(cur)) controllerConnectorInput.value = cur;\n  }\n}\n\nfunction updateControllerPowerOptions() {\n  controllerPowerOptions = getAllControllerPowerSources();\n  if (controllerPowerInput) {\n    const cur = controllerPowerInput.value;\n    controllerPowerInput.innerHTML = '';\n    addEmptyOption(controllerPowerInput);\n    controllerPowerOptions.forEach(optVal => {\n      const opt = document.createElement('option');\n      opt.value = optVal;\n      opt.textContent = optVal;\n      controllerPowerInput.appendChild(opt);\n    });\n    if (controllerPowerOptions.includes(cur)) controllerPowerInput.value = cur;\n  }\n}\n\nfunction updateControllerBatteryOptions() {\n  controllerBatteryOptions = getAllControllerBatteryTypes();\n  if (controllerBatteryInput) {\n    const cur = controllerBatteryInput.value;\n    controllerBatteryInput.innerHTML = '';\n    addEmptyOption(controllerBatteryInput);\n    controllerBatteryOptions.forEach(optVal => {\n      const opt = document.createElement('option');\n      opt.value = optVal;\n      opt.textContent = optVal;\n      controllerBatteryInput.appendChild(opt);\n    });\n    if (controllerBatteryOptions.includes(cur)) controllerBatteryInput.value = cur;\n  }\n}\n\nfunction updateControllerConnectivityOptions() {\n  controllerConnectivityOptions = getAllControllerConnectivity();\n  if (controllerConnectivityInput) {\n    const cur = controllerConnectivityInput.value;\n    controllerConnectivityInput.innerHTML = '';\n    addEmptyOption(controllerConnectivityInput);\n    controllerConnectivityOptions.forEach(optVal => {\n      const opt = document.createElement('option');\n      opt.value = optVal;\n      opt.textContent = optVal;\n      controllerConnectivityInput.appendChild(opt);\n    });\n    if (controllerConnectivityOptions.includes(cur)) controllerConnectivityInput.value = cur;\n  }\n}\n\nfunction getAllDistanceConnections() {\n  const types = new Set();\n  Object.values(devices.fiz?.distance || {}).forEach(d => {\n    if (d && d.connectionCompatibility) types.add(d.connectionCompatibility);\n  });\n  return Array.from(types).filter(Boolean).sort(localeSort);\n}\n\nfunction getAllDistanceMethods() {\n  const types = new Set();\n  Object.values(devices.fiz?.distance || {}).forEach(d => {\n    if (d && d.measurementMethod) types.add(d.measurementMethod);\n  });\n  return Array.from(types).filter(Boolean).sort(localeSort);\n}\n\nfunction getAllDistanceDisplays() {\n  const types = new Set();\n  Object.values(devices.fiz?.distance || {}).forEach(d => {\n    if (d && d.outputDisplay) types.add(d.outputDisplay);\n  });\n  return Array.from(types).filter(Boolean).sort(localeSort);\n}\n\nlet distanceConnectionOptions = getAllDistanceConnections();\nlet distanceMethodOptions = getAllDistanceMethods();\nlet distanceDisplayOptions = getAllDistanceDisplays();\n\nfunction updateDistanceConnectionOptions() {\n  distanceConnectionOptions = getAllDistanceConnections();\n  if (distanceConnectionInput) {\n    const cur = distanceConnectionInput.value;\n    distanceConnectionInput.innerHTML = '';\n    addEmptyOption(distanceConnectionInput);\n    distanceConnectionOptions.forEach(optVal => {\n      const opt = document.createElement('option');\n      opt.value = optVal;\n      opt.textContent = optVal;\n      distanceConnectionInput.appendChild(opt);\n    });\n    if (distanceConnectionOptions.includes(cur)) distanceConnectionInput.value = cur;\n  }\n}\n\nfunction updateDistanceMethodOptions() {\n  distanceMethodOptions = getAllDistanceMethods();\n  if (distanceMethodInput) {\n    const cur = distanceMethodInput.value;\n    distanceMethodInput.innerHTML = '';\n    addEmptyOption(distanceMethodInput);\n    distanceMethodOptions.forEach(optVal => {\n      const opt = document.createElement('option');\n      opt.value = optVal;\n      opt.textContent = optVal;\n      distanceMethodInput.appendChild(opt);\n    });\n    if (distanceMethodOptions.includes(cur)) distanceMethodInput.value = cur;\n  }\n}\n\nfunction updateDistanceDisplayOptions() {\n  distanceDisplayOptions = getAllDistanceDisplays();\n  if (distanceOutputInput) {\n    const cur = distanceOutputInput.value;\n    distanceOutputInput.innerHTML = '';\n    addEmptyOption(distanceOutputInput);\n    distanceDisplayOptions.forEach(optVal => {\n      const opt = document.createElement('option');\n      opt.value = optVal;\n      opt.textContent = optVal;\n      distanceOutputInput.appendChild(opt);\n    });\n    if (distanceDisplayOptions.includes(cur)) distanceOutputInput.value = cur;\n  }\n}\n\n// Wrap a form field with a div containing a data-label attribute for styling.\nfunction createFieldWithLabel(el, label) {\n  const wrapper = document.createElement('div');\n  wrapper.className = 'field-with-label';\n  wrapper.dataset.label = label;\n  wrapper.appendChild(el);\n  return wrapper;\n}\n\n// Helper used by select-row builders to insert an empty option.\n// Previously this inserted a blank option at the top of each select.\n// The UI no longer requires an empty choice, so this function is now a\n// no-op but kept for backward compatibility with existing calls.\nfunction addEmptyOption(/* select */) {\n  // Intentionally left blank\n}\n\n// Utility to remove entries with value \"None\" or empty string\nfunction filterNoneEntries(list, prop = 'type') {\n  if (!Array.isArray(list)) return [];\n  return list.filter(item => {\n    if (typeof item === 'string') {\n      return item && item !== 'None';\n    }\n    if (item && Object.prototype.hasOwnProperty.call(item, prop)) {\n      const val = item[prop];\n      return val !== undefined && val !== null && val !== '' && val !== 'None';\n    }\n    return true;\n  });\n}\n\n// Build a single row of the video output editor UI.\nfunction createVideoOutputRow(value = '') {\n  const row = document.createElement('div');\n  row.className = 'form-row';\n  const select = document.createElement('select');\n  select.className = 'video-output-select';\n  select.name = 'videoOutput';\n  addEmptyOption(select);\n  videoOutputOptions.forEach(optVal => {\n    const opt = document.createElement('option');\n    opt.value = optVal;\n    opt.textContent = optVal;\n    select.appendChild(opt);\n  });\n  select.value = value;\n  row.appendChild(createFieldWithLabel(select, 'Type'));\n  const addBtn = document.createElement('button');\n  addBtn.type = 'button';\n  configureIconOnlyButton(addBtn, ICON_GLYPHS.add, {\n    contextPaths: ['videoOutputsHeading', ['cameraVideoOutputsLabel']],\n    fallbackContext: 'Video Outputs',\n    actionKey: 'addEntry'\n  });\n  addBtn.addEventListener('click', () => {\n    row.after(createVideoOutputRow());\n  });\n  row.appendChild(addBtn);\n  const removeBtn = document.createElement('button');\n  removeBtn.type = 'button';\n  configureIconOnlyButton(removeBtn, ICON_GLYPHS.minus, {\n    contextPaths: ['videoOutputsHeading', ['cameraVideoOutputsLabel']],\n    fallbackContext: 'Video Outputs',\n    actionKey: 'removeEntry'\n  });\n  removeBtn.addEventListener('click', () => {\n    if (videoOutputsContainer.children.length > 1) row.remove();\n  });\n  row.appendChild(removeBtn);\n  return row;\n}\n\nfunction setVideoOutputs(list) {\n  videoOutputsContainer.innerHTML = '';\n  const filtered = filterNoneEntries(list);\n  if (filtered.length) {\n    filtered.forEach(item => {\n      const t = typeof item === 'string' ? item : item.type;\n      videoOutputsContainer.appendChild(createVideoOutputRow(t));\n    });\n  } else {\n    videoOutputsContainer.appendChild(createVideoOutputRow());\n  }\n}\n\nfunction getVideoOutputs() {\n  return Array.from(videoOutputsContainer.querySelectorAll('select'))\n    .map(sel => ({ type: sel.value }))\n    .filter(vo => vo.type && vo.type !== 'None');\n}\n\nfunction clearVideoOutputs() {\n  setVideoOutputs([]);\n}\n\nfunction createMonitorVideoInputRow(value = '') {\n  const row = document.createElement('div');\n  row.className = 'form-row';\n  const select = document.createElement('select');\n  select.className = 'monitor-video-input-select';\n  select.name = 'monitorVideoInput';\n  addEmptyOption(select);\n  videoOutputOptions.forEach(optVal => {\n    const opt = document.createElement('option');\n    opt.value = optVal;\n    opt.textContent = optVal;\n    select.appendChild(opt);\n  });\n  select.value = value;\n  row.appendChild(createFieldWithLabel(select, 'Type'));\n  const addBtn = document.createElement('button');\n  addBtn.type = 'button';\n  configureIconOnlyButton(addBtn, ICON_GLYPHS.add, {\n    contextPaths: ['monitorVideoInputsHeading', ['monitorVideoInputsLabel']],\n    fallbackContext: 'Video Inputs',\n    actionKey: 'addEntry'\n  });\n  addBtn.addEventListener('click', () => {\n    row.after(createMonitorVideoInputRow());\n  });\n  row.appendChild(addBtn);\n  const removeBtn = document.createElement('button');\n  removeBtn.type = 'button';\n  configureIconOnlyButton(removeBtn, ICON_GLYPHS.minus, {\n    contextPaths: ['monitorVideoInputsHeading', ['monitorVideoInputsLabel']],\n    fallbackContext: 'Video Inputs',\n    actionKey: 'removeEntry'\n  });\n  removeBtn.addEventListener('click', () => {\n    if (monitorVideoInputsContainer.children.length > 1) row.remove();\n  });\n  row.appendChild(removeBtn);\n  return row;\n}\n\nfunction setMonitorVideoInputs(list) {\n  monitorVideoInputsContainer.innerHTML = '';\n  const filtered = filterNoneEntries(list, 'type');\n  if (filtered.length) {\n    filtered.forEach(item => {\n      const t = typeof item === 'string' ? item : item.type || item.portType;\n      monitorVideoInputsContainer.appendChild(createMonitorVideoInputRow(t));\n    });\n  } else {\n    monitorVideoInputsContainer.appendChild(createMonitorVideoInputRow());\n  }\n}\n\nfunction getMonitorVideoInputs() {\n  return Array.from(monitorVideoInputsContainer.querySelectorAll('select'))\n    .map(sel => ({ type: sel.value }))\n    .filter(v => v.type && v.type !== 'None');\n}\n\nfunction clearMonitorVideoInputs() {\n  setMonitorVideoInputs([]);\n}\n\nfunction createMonitorVideoOutputRow(value = '') {\n  const row = document.createElement('div');\n  row.className = 'form-row';\n  const select = document.createElement('select');\n  select.className = 'monitor-video-output-select';\n  select.name = 'monitorVideoOutput';\n  addEmptyOption(select);\n  videoOutputOptions.forEach(optVal => {\n    const opt = document.createElement('option');\n    opt.value = optVal;\n    opt.textContent = optVal;\n    select.appendChild(opt);\n  });\n  select.value = value;\n  row.appendChild(createFieldWithLabel(select, 'Type'));\n  const addBtn = document.createElement('button');\n  addBtn.type = 'button';\n  configureIconOnlyButton(addBtn, ICON_GLYPHS.add, {\n    contextPaths: ['monitorVideoOutputsHeading', ['monitorVideoOutputsLabel']],\n    fallbackContext: 'Video Outputs',\n    actionKey: 'addEntry'\n  });\n  addBtn.addEventListener('click', () => {\n    row.after(createMonitorVideoOutputRow());\n  });\n  row.appendChild(addBtn);\n  const removeBtn = document.createElement('button');\n  removeBtn.type = 'button';\n  configureIconOnlyButton(removeBtn, ICON_GLYPHS.minus, {\n    contextPaths: ['monitorVideoOutputsHeading', ['monitorVideoOutputsLabel']],\n    fallbackContext: 'Video Outputs',\n    actionKey: 'removeEntry'\n  });\n  removeBtn.addEventListener('click', () => {\n    if (monitorVideoOutputsContainer.children.length > 1) row.remove();\n  });\n  row.appendChild(removeBtn);\n  return row;\n}\n\nfunction setMonitorVideoOutputs(list) {\n  monitorVideoOutputsContainer.innerHTML = '';\n  const filtered = filterNoneEntries(list, 'type');\n  if (filtered.length) {\n    filtered.forEach(item => {\n      const t = typeof item === 'string' ? item : item.type || item.portType;\n      monitorVideoOutputsContainer.appendChild(createMonitorVideoOutputRow(t));\n    });\n  } else {\n    monitorVideoOutputsContainer.appendChild(createMonitorVideoOutputRow());\n  }\n}\n\nfunction getMonitorVideoOutputs() {\n  return Array.from(monitorVideoOutputsContainer.querySelectorAll('select'))\n    .map(sel => ({ type: sel.value }))\n    .filter(v => v.type && v.type !== 'None');\n}\n\nfunction clearMonitorVideoOutputs() {\n  setMonitorVideoOutputs([]);\n}\n\nfunction createViewfinderVideoInputRow(value = '') {\n  const row = document.createElement('div');\n  row.className = 'form-row';\n  const select = document.createElement('select');\n  select.className = 'viewfinder-video-input-select';\n  select.name = 'viewfinderVideoInput';\n  addEmptyOption(select);\n  videoOutputOptions.forEach(optVal => {\n    const opt = document.createElement('option');\n    opt.value = optVal;\n    opt.textContent = optVal;\n    select.appendChild(opt);\n  });\n  select.value = value;\n  row.appendChild(createFieldWithLabel(select, 'Type'));\n  const addBtn = document.createElement('button');\n  addBtn.type = 'button';\n  configureIconOnlyButton(addBtn, ICON_GLYPHS.add, {\n    contextPaths: ['viewfinderVideoInputsHeading', ['viewfinderVideoInputsLabel']],\n    fallbackContext: 'Video Inputs',\n    actionKey: 'addEntry'\n  });\n  addBtn.addEventListener('click', () => {\n    row.after(createViewfinderVideoInputRow());\n  });\n  row.appendChild(addBtn);\n  const removeBtn = document.createElement('button');\n  removeBtn.type = 'button';\n  configureIconOnlyButton(removeBtn, ICON_GLYPHS.minus, {\n    contextPaths: ['viewfinderVideoInputsHeading', ['viewfinderVideoInputsLabel']],\n    fallbackContext: 'Video Inputs',\n    actionKey: 'removeEntry'\n  });\n  removeBtn.addEventListener('click', () => {\n    if (viewfinderVideoInputsContainer && viewfinderVideoInputsContainer.children.length > 1) row.remove();\n  });\n  row.appendChild(removeBtn);\n  return row;\n}\n\nfunction setViewfinderVideoInputs(list) {\n  if (!viewfinderVideoInputsContainer) return;\n  viewfinderVideoInputsContainer.innerHTML = '';\n  const filtered = filterNoneEntries(list, 'type');\n  if (filtered.length) {\n    filtered.forEach(item => {\n      const t = typeof item === 'string' ? item : item.type || item.portType;\n      viewfinderVideoInputsContainer.appendChild(createViewfinderVideoInputRow(t));\n    });\n  } else {\n    viewfinderVideoInputsContainer.appendChild(createViewfinderVideoInputRow());\n  }\n}\n\nfunction getViewfinderVideoInputs() {\n  if (!viewfinderVideoInputsContainer) return [];\n  return Array.from(viewfinderVideoInputsContainer.querySelectorAll('select'))\n    .map(sel => ({ type: sel.value }))\n    .filter(v => v.type && v.type !== 'None');\n}\n\nfunction clearViewfinderVideoInputs() {\n  setViewfinderVideoInputs([]);\n}\n\nfunction createViewfinderVideoOutputRow(value = '') {\n  const row = document.createElement('div');\n  row.className = 'form-row';\n  const select = document.createElement('select');\n  select.className = 'viewfinder-video-output-select';\n  select.name = 'viewfinderVideoOutput';\n  addEmptyOption(select);\n  videoOutputOptions.forEach(optVal => {\n    const opt = document.createElement('option');\n    opt.value = optVal;\n    opt.textContent = optVal;\n    select.appendChild(opt);\n  });\n  select.value = value;\n  row.appendChild(createFieldWithLabel(select, 'Type'));\n  const addBtn = document.createElement('button');\n  addBtn.type = 'button';\n  configureIconOnlyButton(addBtn, ICON_GLYPHS.add, {\n    contextPaths: ['viewfinderVideoOutputsHeading', ['viewfinderVideoOutputsLabel']],\n    fallbackContext: 'Video Outputs',\n    actionKey: 'addEntry'\n  });\n  addBtn.addEventListener('click', () => {\n    row.after(createViewfinderVideoOutputRow());\n  });\n  row.appendChild(addBtn);\n  const removeBtn = document.createElement('button');\n  removeBtn.type = 'button';\n  configureIconOnlyButton(removeBtn, ICON_GLYPHS.minus, {\n    contextPaths: ['viewfinderVideoOutputsHeading', ['viewfinderVideoOutputsLabel']],\n    fallbackContext: 'Video Outputs',\n    actionKey: 'removeEntry'\n  });\n  removeBtn.addEventListener('click', () => {\n    if (viewfinderVideoOutputsContainer && viewfinderVideoOutputsContainer.children.length > 1) row.remove();\n  });\n  row.appendChild(removeBtn);\n  return row;\n}\n\nfunction setViewfinderVideoOutputs(list) {\n  if (!viewfinderVideoOutputsContainer) return;\n  viewfinderVideoOutputsContainer.innerHTML = '';\n  const filtered = filterNoneEntries(list, 'type');\n  if (filtered.length) {\n    filtered.forEach(item => {\n      const t = typeof item === 'string' ? item : item.type || item.portType;\n      viewfinderVideoOutputsContainer.appendChild(createViewfinderVideoOutputRow(t));\n    });\n  } else {\n    viewfinderVideoOutputsContainer.appendChild(createViewfinderVideoOutputRow());\n  }\n}\n\nfunction getViewfinderVideoOutputs() {\n  if (!viewfinderVideoOutputsContainer) return [];\n  return Array.from(viewfinderVideoOutputsContainer.querySelectorAll('select'))\n    .map(sel => ({ type: sel.value }))\n    .filter(v => v.type && v.type !== 'None');\n}\n\nfunction clearViewfinderVideoOutputs() {\n  setViewfinderVideoOutputs([]);\n}\n\nsetViewfinderVideoInputs([]);\nsetViewfinderVideoOutputs([]);\n\nfunction createVideoInputRow(value = '') {\n  const row = document.createElement('div');\n  row.className = 'form-row';\n  const select = document.createElement('select');\n  select.className = 'video-input-select';\n  select.name = 'videoInput';\n  addEmptyOption(select);\n  videoOutputOptions.forEach(optVal => {\n    const opt = document.createElement('option');\n    opt.value = optVal;\n    opt.textContent = optVal;\n    select.appendChild(opt);\n  });\n  select.value = value;\n  row.appendChild(createFieldWithLabel(select, 'Type'));\n  const addBtn = document.createElement('button');\n  addBtn.type = 'button';\n  configureIconOnlyButton(addBtn, ICON_GLYPHS.add, {\n    contextPaths: ['videoVideoInputsHeading', ['videoVideoInputsLabel']],\n    fallbackContext: 'Video Inputs',\n    actionKey: 'addEntry'\n  });\n  addBtn.addEventListener('click', () => {\n    row.after(createVideoInputRow());\n  });\n  row.appendChild(addBtn);\n  const removeBtn = document.createElement('button');\n  removeBtn.type = 'button';\n  configureIconOnlyButton(removeBtn, ICON_GLYPHS.minus, {\n    contextPaths: ['videoVideoInputsHeading', ['videoVideoInputsLabel']],\n    fallbackContext: 'Video Inputs',\n    actionKey: 'removeEntry'\n  });\n  removeBtn.addEventListener('click', () => {\n    if (videoVideoInputsContainer.children.length > 1) row.remove();\n  });\n  row.appendChild(removeBtn);\n  return row;\n}\n\nfunction setVideoInputs(list) {\n  videoVideoInputsContainer.innerHTML = '';\n  const filtered = filterNoneEntries(list, 'type');\n  if (filtered.length) {\n    filtered.forEach(item => {\n      const t = typeof item === 'string' ? item : item.type || item.portType;\n      videoVideoInputsContainer.appendChild(createVideoInputRow(t));\n    });\n  } else {\n    videoVideoInputsContainer.appendChild(createVideoInputRow());\n  }\n}\n\nfunction getVideoInputs() {\n  return Array.from(videoVideoInputsContainer.querySelectorAll('select'))\n    .map(sel => ({ type: sel.value }))\n    .filter(v => v.type && v.type !== 'None');\n}\n\nfunction clearVideoInputs() { setVideoInputs([]); }\n\nfunction createVideoIOOutputRow(value = '') {\n  const row = document.createElement('div');\n  row.className = 'form-row';\n  const select = document.createElement('select');\n  select.className = 'video-output-select-io';\n  select.name = 'videoIOOutput';\n  addEmptyOption(select);\n  videoOutputOptions.forEach(optVal => {\n    const opt = document.createElement('option');\n    opt.value = optVal;\n    opt.textContent = optVal;\n    select.appendChild(opt);\n  });\n  select.value = value;\n  row.appendChild(createFieldWithLabel(select, 'Type'));\n  const addBtn = document.createElement('button');\n  addBtn.type = 'button';\n  configureIconOnlyButton(addBtn, ICON_GLYPHS.add, {\n    contextPaths: ['videoVideoOutputsHeading', ['videoVideoOutputsLabel']],\n    fallbackContext: 'Video Outputs',\n    actionKey: 'addEntry'\n  });\n  addBtn.addEventListener('click', () => {\n    row.after(createVideoIOOutputRow());\n  });\n  row.appendChild(addBtn);\n  const removeBtn = document.createElement('button');\n  removeBtn.type = 'button';\n  configureIconOnlyButton(removeBtn, ICON_GLYPHS.minus, {\n    contextPaths: ['videoVideoOutputsHeading', ['videoVideoOutputsLabel']],\n    fallbackContext: 'Video Outputs',\n    actionKey: 'removeEntry'\n  });\n  removeBtn.addEventListener('click', () => {\n    if (videoVideoOutputsContainer.children.length > 1) row.remove();\n  });\n  row.appendChild(removeBtn);\n  return row;\n}\n\nfunction setVideoOutputsIO(list) {\n  videoVideoOutputsContainer.innerHTML = '';\n  const filtered = filterNoneEntries(list, 'type');\n  if (filtered.length) {\n    filtered.forEach(item => {\n      const t = typeof item === 'string' ? item : item.type || item.portType;\n      videoVideoOutputsContainer.appendChild(createVideoIOOutputRow(t));\n    });\n  } else {\n    videoVideoOutputsContainer.appendChild(createVideoIOOutputRow());\n  }\n}\n\nfunction getVideoOutputsIO() {\n  return Array.from(videoVideoOutputsContainer.querySelectorAll('select'))\n    .map(sel => ({ type: sel.value }))\n    .filter(v => v.type && v.type !== 'None');\n}\n\nfunction clearVideoOutputsIO() { setVideoOutputsIO([]); }\n\n// Build a row for editing a FIZ connector entry.\nfunction createFizConnectorRow(value = '') {\n  const row = document.createElement('div');\n  row.className = 'form-row';\n  const select = document.createElement('select');\n  select.className = 'fiz-connector-select';\n  select.name = 'fizConnector';\n  addEmptyOption(select);\n  fizConnectorOptions.forEach(optVal => {\n    const opt = document.createElement('option');\n    opt.value = optVal;\n    opt.textContent = optVal;\n    select.appendChild(opt);\n  });\n  select.value = value;\n  row.appendChild(createFieldWithLabel(select, 'Type'));\n  const addBtn = document.createElement('button');\n  addBtn.type = 'button';\n  configureIconOnlyButton(addBtn, ICON_GLYPHS.add, {\n    contextPaths: ['fizConnectorHeading', ['cameraFIZConnectorLabel']],\n    fallbackContext: 'FIZ Connector',\n    actionKey: 'addEntry'\n  });\n  addBtn.addEventListener('click', () => {\n    row.after(createFizConnectorRow());\n  });\n  row.appendChild(addBtn);\n  const removeBtn = document.createElement('button');\n  removeBtn.type = 'button';\n  configureIconOnlyButton(removeBtn, ICON_GLYPHS.minus, {\n    contextPaths: ['fizConnectorHeading', ['cameraFIZConnectorLabel']],\n    fallbackContext: 'FIZ Connector',\n    actionKey: 'removeEntry'\n  });\n  removeBtn.addEventListener('click', () => {\n    if (fizConnectorContainer.children.length > 1) row.remove();\n  });\n  row.appendChild(removeBtn);\n  return row;\n}\n\nfunction setFizConnectors(list) {\n  fizConnectorContainer.innerHTML = '';\n  const filtered = filterNoneEntries(list);\n  if (filtered.length) {\n    filtered.forEach(item => {\n      const t = typeof item === 'string' ? item : item.type;\n      fizConnectorContainer.appendChild(createFizConnectorRow(t));\n    });\n  } else {\n    fizConnectorContainer.appendChild(createFizConnectorRow());\n  }\n}\n\nfunction getFizConnectors() {\n  return Array.from(fizConnectorContainer.querySelectorAll('select'))\n    .map(sel => ({ type: sel.value }))\n    .filter(fc => fc.type && fc.type !== 'None');\n}\n\nfunction clearFizConnectors() {\n  setFizConnectors([]);\n}\n\nfunction getAllRecordingMedia() {\n  const media = new Set();\n  Object.values(devices.cameras).forEach(cam => {\n    if (Array.isArray(cam.recordingMedia)) {\n      cam.recordingMedia.forEach(m => { if (m && m.type) media.add(m.type); });\n    }\n  });\n  return Array.from(media).sort(localeSort);\n}\n\nlet recordingMediaOptions = getAllRecordingMedia();\n\nfunction updateRecordingMediaOptions() {\n  recordingMediaOptions = getAllRecordingMedia();\n  document.querySelectorAll('.recording-media-select').forEach(sel => {\n    const cur = sel.value;\n    sel.innerHTML = '';\n    addEmptyOption(sel);\n    recordingMediaOptions.forEach(optVal => {\n      const opt = document.createElement('option');\n      opt.value = optVal;\n      opt.textContent = optVal;\n      sel.appendChild(opt);\n    });\n    if (recordingMediaOptions.includes(cur)) sel.value = cur;\n  });\n}\n\n// Build a row allowing the user to specify recording media details.\nfunction createRecordingMediaRow(type = '', notes = '') {\n  const row = document.createElement('div');\n  row.className = 'form-row';\n\n  const select = document.createElement('select');\n  select.className = 'recording-media-select';\n  select.name = 'recordingMediaType';\n  addEmptyOption(select);\n  recordingMediaOptions.forEach(optVal => {\n    const opt = document.createElement('option');\n    opt.value = optVal;\n    opt.textContent = optVal;\n    select.appendChild(opt);\n  });\n  if (type) {\n    if (!recordingMediaOptions.includes(type)) {\n      const opt = document.createElement('option');\n      opt.value = type;\n      opt.textContent = type;\n      select.appendChild(opt);\n    }\n    select.value = type;\n  }\n  row.appendChild(createFieldWithLabel(select, 'Type'));\n\n  const notesInput = document.createElement('input');\n  notesInput.type = 'text';\n  notesInput.placeholder = 'Notes';\n  notesInput.name = 'recordingMediaNotes';\n  notesInput.value = notes;\n  row.appendChild(createFieldWithLabel(notesInput, 'Notes'));\n\n  const addBtn = document.createElement('button');\n  addBtn.type = 'button';\n  configureIconOnlyButton(addBtn, ICON_GLYPHS.add, {\n    contextPaths: ['mediaHeading', ['cameraMediaLabel']],\n    fallbackContext: 'Recording Media',\n    actionKey: 'addEntry'\n  });\n  addBtn.addEventListener('click', () => {\n    row.after(createRecordingMediaRow());\n  });\n  row.appendChild(addBtn);\n\n  const removeBtn = document.createElement('button');\n  removeBtn.type = 'button';\n  configureIconOnlyButton(removeBtn, ICON_GLYPHS.minus, {\n    contextPaths: ['mediaHeading', ['cameraMediaLabel']],\n    fallbackContext: 'Recording Media',\n    actionKey: 'removeEntry'\n  });\n  removeBtn.addEventListener('click', () => {\n    if (cameraMediaContainer.children.length > 1) row.remove();\n  });\n  row.appendChild(removeBtn);\n\n  return row;\n}\n\nfunction setRecordingMedia(list) {\n  cameraMediaContainer.innerHTML = '';\n  const filtered = filterNoneEntries(list);\n  if (filtered.length) {\n    filtered.forEach(item => {\n      const { type = '', notes = '' } = item || {};\n      cameraMediaContainer.appendChild(createRecordingMediaRow(type, notes));\n    });\n  } else {\n    cameraMediaContainer.appendChild(createRecordingMediaRow());\n  }\n}\n\nfunction getRecordingMedia() {\n  return Array.from(cameraMediaContainer.querySelectorAll('.form-row'))\n    .map(row => {\n      const [sel, notesInput] = row.querySelectorAll('select, input');\n      return { type: sel.value, notes: notesInput.value };\n    })\n    .filter(m => m.type && m.type !== 'None');\n}\n\nfunction clearRecordingMedia() {\n  setRecordingMedia([]);\n}\n\nfunction powerInputTypes(dev) {\n  const out = [];\n  if (!dev) return out;\n  const add = t => {\n    normalizePowerPortType(t).forEach(pt => out.push(pt));\n  };\n  if (dev.powerInput) {\n    String(dev.powerInput)\n      .split('/')\n      .forEach(t => {\n        if (t.trim()) add(t.trim());\n      });\n  }\n  const inp = dev.power?.input;\n  if (Array.isArray(inp)) {\n    inp.forEach(i => {\n      const typeVal = i && (i.type || i.portType);\n      if (typeVal) add(typeVal);\n    });\n  } else if (inp) {\n    const typeVal = inp.type || inp.portType;\n    if (typeVal) add(typeVal);\n  }\n  return out;\n}\n\nfunction firstPowerInputType(dev) {\n  const list = powerInputTypes(dev);\n  return list.length ? list[0] : '';\n}\n\nfunction getAllPowerPortTypes() {\n  const types = new Set();\n  Object.values(devices.cameras).forEach(cam => powerInputTypes(cam).forEach(t => types.add(t)));\n  Object.values(devices.viewfinders || {}).forEach(vf => powerInputTypes(vf).forEach(t => types.add(t)));\n  Object.values(devices.monitors || {}).forEach(mon => powerInputTypes(mon).forEach(t => types.add(t)));\n  Object.values(devices.video || {}).forEach(vd => powerInputTypes(vd).forEach(t => types.add(t)));\n  Object.values(devices.fiz?.motors || {}).forEach(m => powerInputTypes(m).forEach(t => types.add(t)));\n  Object.values(devices.fiz?.controllers || {}).forEach(c => powerInputTypes(c).forEach(t => types.add(t)));\n  Object.values(devices.fiz?.distance || {}).forEach(d => powerInputTypes(d).forEach(t => types.add(t)));\n  return Array.from(types).sort(localeSort);\n}\n\nlet powerPortOptions = getAllPowerPortTypes();\n\nfunction updatePowerPortOptions() {\n  powerPortOptions = getAllPowerPortTypes();\n  const current = cameraPortTypeInput.value;\n  cameraPortTypeInput.innerHTML = '';\n  addEmptyOption(cameraPortTypeInput);\n  powerPortOptions.forEach(optVal => {\n    const opt = document.createElement('option');\n    opt.value = optVal;\n    opt.textContent = optVal;\n    cameraPortTypeInput.appendChild(opt);\n  });\n  if (powerPortOptions.includes(current)) cameraPortTypeInput.value = current;\n\n  if (monitorPortTypeInput) {\n    const curMon = monitorPortTypeInput.value;\n    monitorPortTypeInput.innerHTML = '';\n    addEmptyOption(monitorPortTypeInput);\n    powerPortOptions.forEach(optVal => {\n      const opt = document.createElement('option');\n      opt.value = optVal;\n      opt.textContent = optVal;\n      monitorPortTypeInput.appendChild(opt);\n    });\n    if (powerPortOptions.includes(curMon)) monitorPortTypeInput.value = curMon;\n  }\n}\n\nfunction getAllPlateTypes() {\n  const types = new Set();\n  Object.values(devices.cameras).forEach(cam => {\n    const list = cam.power?.batteryPlateSupport;\n    if (Array.isArray(list)) {\n      list.forEach(bp => {\n        if (bp && bp.type) types.add(bp.type);\n      });\n    }\n  });\n  return Array.from(types).sort(localeSort);\n}\n\nlet plateTypeOptions = getAllPlateTypes();\n\nfunction updatePlateTypeOptions() {\n  plateTypeOptions = getAllPlateTypes();\n  document.querySelectorAll('.battery-plate-type-select').forEach(sel => {\n    const current = sel.value;\n    sel.innerHTML = '';\n    addEmptyOption(sel);\n    plateTypeOptions.forEach(pt => {\n      const opt = document.createElement('option');\n      opt.value = pt;\n      opt.textContent = pt;\n      sel.appendChild(opt);\n    });\n    if (plateTypeOptions.includes(current)) sel.value = current;\n  });\n}\n\n// Build a battery plate row with type, mount and optional notes fields.\nfunction createBatteryPlateRow(type = '', mount = 'native', notes = '') {\n  const row = document.createElement('div');\n  row.className = 'form-row';\n\n  const typeSelect = document.createElement('select');\n  typeSelect.className = 'battery-plate-type-select';\n  typeSelect.name = 'batteryPlateType';\n  addEmptyOption(typeSelect);\n  plateTypeOptions.forEach(pt => {\n    const opt = document.createElement('option');\n    opt.value = pt;\n    opt.textContent = pt;\n    typeSelect.appendChild(opt);\n  });\n  if (type && !plateTypeOptions.includes(type)) {\n    const opt = document.createElement('option');\n    opt.value = type;\n    opt.textContent = type;\n    typeSelect.appendChild(opt);\n  }\n  typeSelect.value = type;\n  row.appendChild(createFieldWithLabel(typeSelect, 'Type'));\n\n  const mountSelect = document.createElement('select');\n  addEmptyOption(mountSelect);\n  mountSelect.name = 'batteryPlateMount';\n  ['native','adapted'].forEach(m => {\n    const opt = document.createElement('option');\n    opt.value = m;\n    opt.textContent = m;\n    mountSelect.appendChild(opt);\n  });\n  mountSelect.value = mount || '';\n  row.appendChild(createFieldWithLabel(mountSelect, 'Mount'));\n\n  const notesInput = document.createElement('input');\n  notesInput.type = 'text';\n  notesInput.placeholder = 'Notes';\n  notesInput.value = notes;\n  notesInput.name = 'batteryPlateNotes';\n  row.appendChild(createFieldWithLabel(notesInput, 'Notes'));\n\n  const addBtn = document.createElement('button');\n  addBtn.type = 'button';\n  configureIconOnlyButton(addBtn, ICON_GLYPHS.add, {\n    contextPaths: ['cameraPlatesLabel', ['powerInputsHeading']],\n    fallbackContext: 'Battery Plates',\n    actionKey: 'addEntry'\n  });\n  addBtn.addEventListener('click', () => {\n    row.after(createBatteryPlateRow());\n  });\n  row.appendChild(addBtn);\n\n  const removeBtn = document.createElement('button');\n  removeBtn.type = 'button';\n  configureIconOnlyButton(removeBtn, ICON_GLYPHS.minus, {\n    contextPaths: ['cameraPlatesLabel', ['powerInputsHeading']],\n    fallbackContext: 'Battery Plates',\n    actionKey: 'removeEntry'\n  });\n  removeBtn.addEventListener('click', () => {\n    if (batteryPlatesContainer.children.length > 1) row.remove();\n  });\n  row.appendChild(removeBtn);\n\n  return row;\n}\n\nfunction setBatteryPlates(list) {\n  batteryPlatesContainer.innerHTML = '';\n  const filtered = filterNoneEntries(list);\n  if (filtered.length) {\n    filtered.forEach(item => {\n      const { type = '', mount = 'native', notes = '' } = item || {};\n      batteryPlatesContainer.appendChild(createBatteryPlateRow(type, mount, notes));\n    });\n  } else {\n    batteryPlatesContainer.appendChild(createBatteryPlateRow());\n  }\n}\n\nfunction getBatteryPlates() {\n  return Array.from(batteryPlatesContainer.querySelectorAll('.form-row'))\n    .map(row => {\n      const [typeSel, mountSel, notesInput] = row.querySelectorAll('select, input');\n      return { type: typeSel.value, mount: mountSel.value, notes: notesInput.value };\n    })\n    .filter(bp => bp.type && bp.type !== 'None');\n}\n\nfunction clearBatteryPlates() {\n  setBatteryPlates([]);\n}\n\nfunction getAllViewfinderTypes() {\n  const types = new Set();\n  Object.values(devices.cameras).forEach(cam => {\n    if (Array.isArray(cam.viewfinder)) {\n      cam.viewfinder.forEach(vf => {\n        if (vf && vf.type) types.add(vf.type);\n      });\n    }\n  });\n  return Array.from(types).sort(localeSort);\n}\n\nfunction getAllViewfinderConnectors() {\n  const conns = new Set();\n  Object.values(devices.cameras).forEach(cam => {\n    if (Array.isArray(cam.viewfinder)) {\n      cam.viewfinder.forEach(vf => {\n        if (vf && vf.connector) conns.add(vf.connector);\n      });\n    }\n  });\n  return Array.from(conns).filter(c => c).sort(localeSort);\n}\n\nlet viewfinderTypeOptions = getAllViewfinderTypes();\nlet viewfinderConnectorOptions = getAllViewfinderConnectors();\n\n// Build a viewfinder configuration row used in the camera editor.\nfunction createViewfinderRow(type = '', resolution = '', connector = '', notes = '') {\n  const row = document.createElement('div');\n  row.className = 'form-row';\n\n  const typeSelect = document.createElement('select');\n  typeSelect.className = 'viewfinder-type-select';\n  typeSelect.name = 'viewfinderType';\n  addEmptyOption(typeSelect);\n  viewfinderTypeOptions.forEach(optVal => {\n    const opt = document.createElement('option');\n    opt.value = optVal;\n    opt.textContent = optVal;\n    typeSelect.appendChild(opt);\n  });\n  if (type && !viewfinderTypeOptions.includes(type)) {\n    const opt = document.createElement('option');\n    opt.value = type;\n    opt.textContent = type;\n    typeSelect.appendChild(opt);\n  }\n  typeSelect.value = type;\n  row.appendChild(createFieldWithLabel(typeSelect, 'Type'));\n\n  const resInput = document.createElement('input');\n  resInput.type = 'text';\n  resInput.placeholder = 'Resolution';\n  resInput.value = resolution;\n  resInput.name = 'viewfinderResolution';\n  row.appendChild(createFieldWithLabel(resInput, 'Resolution'));\n\n  const connSelect = document.createElement('select');\n  connSelect.className = 'viewfinder-connector-select';\n  addEmptyOption(connSelect);\n  connSelect.name = 'viewfinderConnector';\n  viewfinderConnectorOptions.forEach(optVal => {\n    const opt = document.createElement('option');\n    opt.value = optVal;\n    opt.textContent = optVal;\n    connSelect.appendChild(opt);\n  });\n  if (connector && !viewfinderConnectorOptions.includes(connector)) {\n    const opt = document.createElement('option');\n    opt.value = connector;\n    opt.textContent = connector;\n    connSelect.appendChild(opt);\n  }\n  connSelect.value = connector;\n  row.appendChild(createFieldWithLabel(connSelect, 'Connector'));\n\n  const notesInput = document.createElement('input');\n  notesInput.type = 'text';\n  notesInput.placeholder = 'Notes';\n  notesInput.value = notes;\n  notesInput.name = 'viewfinderNotes';\n  row.appendChild(createFieldWithLabel(notesInput, 'Notes'));\n\n  const addBtn = document.createElement('button');\n  addBtn.type = 'button';\n  configureIconOnlyButton(addBtn, ICON_GLYPHS.add, {\n    contextPaths: ['viewfinderHeading', ['cameraViewfinderLabel']],\n    fallbackContext: 'Viewfinder',\n    actionKey: 'addEntry'\n  });\n  addBtn.addEventListener('click', () => {\n    row.after(createViewfinderRow());\n  });\n  row.appendChild(addBtn);\n\n  const removeBtn = document.createElement('button');\n  removeBtn.type = 'button';\n  configureIconOnlyButton(removeBtn, ICON_GLYPHS.minus, {\n    contextPaths: ['viewfinderHeading', ['cameraViewfinderLabel']],\n    fallbackContext: 'Viewfinder',\n    actionKey: 'removeEntry'\n  });\n  removeBtn.addEventListener('click', () => {\n    if (viewfinderContainer.children.length > 1) row.remove();\n  });\n  row.appendChild(removeBtn);\n\n  return row;\n}\n\nfunction setViewfinders(list) {\n  viewfinderContainer.innerHTML = '';\n  const filtered = filterNoneEntries(list);\n  if (filtered.length) {\n    filtered.forEach(item => {\n      const { type = '', resolution = '', connector = '', notes = '' } = item || {};\n      viewfinderContainer.appendChild(createViewfinderRow(type, resolution, connector, notes));\n    });\n  } else {\n    viewfinderContainer.appendChild(createViewfinderRow());\n  }\n}\n\nfunction getViewfinders() {\n  return Array.from(viewfinderContainer.querySelectorAll('.form-row'))\n    .map(row => {\n      const [typeSelect, resInput, connSelect, notesInput] = row.querySelectorAll('select, input');\n      return {\n        type: typeSelect.value,\n        resolution: resInput.value,\n        connector: connSelect.value,\n        notes: notesInput.value\n      };\n    })\n    .filter(vf => vf.type && vf.type !== 'None');\n}\n\nfunction clearViewfinders() {\n  setViewfinders([]);\n}\n\nfunction getAllMountTypes() {\n  const types = new Set();\n  Object.values(devices.cameras).forEach(cam => {\n    if (Array.isArray(cam.lensMount)) {\n      cam.lensMount.forEach(lm => {\n        if (lm && lm.type) types.add(lm.type);\n      });\n    }\n  });\n  return Array.from(types).sort(localeSort);\n}\n\nlet mountTypeOptions = getAllMountTypes();\n\nfunction updateMountTypeOptions() {\n  mountTypeOptions = getAllMountTypes();\n  document.querySelectorAll('.lens-mount-type-select').forEach(sel => {\n    const current = sel.value;\n    sel.innerHTML = '';\n    addEmptyOption(sel);\n    mountTypeOptions.forEach(optVal => {\n      const opt = document.createElement('option');\n      opt.value = optVal;\n      opt.textContent = optVal;\n      sel.appendChild(opt);\n    });\n    if (mountTypeOptions.includes(current)) sel.value = current;\n  });\n}\n\n// Build a lens mount row with type and mount selection fields.\nfunction createLensMountRow(type = '', mount = 'native') {\n  const row = document.createElement('div');\n  row.className = 'form-row';\n\n  const typeSelect = document.createElement('select');\n  typeSelect.className = 'lens-mount-type-select';\n  typeSelect.name = 'lensMountType';\n  addEmptyOption(typeSelect);\n  mountTypeOptions.forEach(optVal => {\n    const opt = document.createElement('option');\n    opt.value = optVal;\n    opt.textContent = optVal;\n    typeSelect.appendChild(opt);\n  });\n  if (type && !mountTypeOptions.includes(type)) {\n    const opt = document.createElement('option');\n    opt.value = type;\n    opt.textContent = type;\n    typeSelect.appendChild(opt);\n  }\n  typeSelect.value = type;\n  row.appendChild(createFieldWithLabel(typeSelect, 'Type'));\n\n  const mountSelect = document.createElement('select');\n  addEmptyOption(mountSelect);\n  mountSelect.name = 'lensMount';\n  ['native', 'adapted'].forEach(m => {\n    const opt = document.createElement('option');\n    opt.value = m;\n    opt.textContent = m;\n    mountSelect.appendChild(opt);\n  });\n  mountSelect.value = mount || '';\n  row.appendChild(createFieldWithLabel(mountSelect, 'Mount'));\n\n  const addBtn = document.createElement('button');\n  addBtn.type = 'button';\n  configureIconOnlyButton(addBtn, ICON_GLYPHS.add, {\n    contextPaths: ['lensMountHeading', ['cameraLensMountLabel']],\n    fallbackContext: 'Lens Mount',\n    actionKey: 'addEntry'\n  });\n  addBtn.addEventListener('click', () => {\n    row.after(createLensMountRow());\n  });\n  row.appendChild(addBtn);\n\n  const removeBtn = document.createElement('button');\n  removeBtn.type = 'button';\n  configureIconOnlyButton(removeBtn, ICON_GLYPHS.minus, {\n    contextPaths: ['lensMountHeading', ['cameraLensMountLabel']],\n    fallbackContext: 'Lens Mount',\n    actionKey: 'removeEntry'\n  });\n  removeBtn.addEventListener('click', () => {\n    if (lensMountContainer.children.length > 1) row.remove();\n  });\n  row.appendChild(removeBtn);\n\n  return row;\n}\n\nfunction setLensMounts(list) {\n  lensMountContainer.innerHTML = '';\n  const filtered = filterNoneEntries(list);\n  if (filtered.length) {\n    filtered.forEach(item => {\n      const { type = '', mount = 'native' } = item || {};\n      lensMountContainer.appendChild(createLensMountRow(type, mount));\n    });\n  } else {\n    lensMountContainer.appendChild(createLensMountRow());\n  }\n}\n\nfunction getLensMounts() {\n  return Array.from(lensMountContainer.querySelectorAll('.form-row'))\n    .map(row => {\n      const [typeSel, mountSel] = row.querySelectorAll('select');\n      return { type: typeSel.value, mount: mountSel.value };\n    })\n    .filter(lm => lm.type && lm.type !== 'None');\n}\n\nfunction clearLensMounts() {\n  setLensMounts([]);\n}\n\nfunction getAllPowerDistTypes() {\n  const types = new Set();\n  Object.values(devices.cameras).forEach(cam => {\n    const list = cam.power?.powerDistributionOutputs;\n    if (Array.isArray(list)) {\n      list.forEach(pd => { if (pd && pd.type) types.add(pd.type); });\n    }\n  });\n  return Array.from(types).sort(localeSort);\n}\n\nlet powerDistTypeOptions = getAllPowerDistTypes();\nfunction getAllPowerDistVoltages() {\n  const volts = new Set();\n  Object.values(devices.cameras).forEach(cam => {\n    const list = cam.power?.powerDistributionOutputs;\n    if (Array.isArray(list)) {\n      list.forEach(pd => { if (pd && pd.voltage) volts.add(pd.voltage); });\n    }\n  });\n  return Array.from(volts).filter(v => v).sort(localeSort);\n}\n\nfunction getAllPowerDistCurrents() {\n  const currents = new Set();\n  Object.values(devices.cameras).forEach(cam => {\n    const list = cam.power?.powerDistributionOutputs;\n    if (Array.isArray(list)) {\n      list.forEach(pd => { if (pd && pd.current) currents.add(pd.current); });\n    }\n  });\n  return Array.from(currents).filter(c => c).sort(localeSort);\n}\n\nlet powerDistVoltageOptions = getAllPowerDistVoltages();\nlet powerDistCurrentOptions = getAllPowerDistCurrents();\n\nfunction updatePowerDistVoltageOptions() {\n  powerDistVoltageOptions = getAllPowerDistVoltages();\n  document.querySelectorAll('.power-dist-voltage-select').forEach(sel => {\n    const cur = sel.value;\n    sel.innerHTML = '';\n    addEmptyOption(sel);\n    powerDistVoltageOptions.forEach(optVal => {\n      const opt = document.createElement('option');\n      opt.value = optVal;\n      opt.textContent = optVal;\n      sel.appendChild(opt);\n    });\n    if (powerDistVoltageOptions.includes(cur)) sel.value = cur;\n  });\n}\n\nfunction updatePowerDistCurrentOptions() {\n  powerDistCurrentOptions = getAllPowerDistCurrents();\n  document.querySelectorAll('.power-dist-current-select').forEach(sel => {\n    const cur = sel.value;\n    sel.innerHTML = '';\n    addEmptyOption(sel);\n    powerDistCurrentOptions.forEach(optVal => {\n      const opt = document.createElement('option');\n      opt.value = optVal;\n      opt.textContent = optVal;\n      sel.appendChild(opt);\n    });\n    if (powerDistCurrentOptions.includes(cur)) sel.value = cur;\n  });\n}\n\nfunction updatePowerDistTypeOptions() {\n  powerDistTypeOptions = getAllPowerDistTypes();\n  document.querySelectorAll('.power-dist-type-select').forEach(sel => {\n    const cur = sel.value;\n    sel.innerHTML = '';\n    addEmptyOption(sel);\n    powerDistTypeOptions.forEach(optVal => {\n      const opt = document.createElement('option');\n      opt.value = optVal;\n      opt.textContent = optVal;\n      sel.appendChild(opt);\n    });\n    if (powerDistTypeOptions.includes(cur)) sel.value = cur;\n  });\n}\n\n// Build a power distribution output row for the editor UI.\nfunction createPowerDistRow(type = '', voltage = '', current = '', wattage = '', notes = '') {\n  const row = document.createElement('div');\n  row.className = 'form-row';\n\n  const typeSelect = document.createElement('select');\n  typeSelect.className = 'power-dist-type-select';\n  typeSelect.name = 'powerDistType';\n  addEmptyOption(typeSelect);\n  powerDistTypeOptions.forEach(optVal => {\n    const opt = document.createElement('option');\n    opt.value = optVal;\n    opt.textContent = optVal;\n    typeSelect.appendChild(opt);\n  });\n  if (type && !powerDistTypeOptions.includes(type)) {\n    const opt = document.createElement('option');\n    opt.value = type;\n    opt.textContent = type;\n    typeSelect.appendChild(opt);\n  }\n  typeSelect.value = type;\n  row.appendChild(createFieldWithLabel(typeSelect, 'Type'));\n\n  const voltSelect = document.createElement('select');\n  voltSelect.className = 'power-dist-voltage-select';\n  addEmptyOption(voltSelect);\n  voltSelect.name = 'powerDistVoltage';\n  powerDistVoltageOptions.forEach(optVal => {\n    const opt = document.createElement('option');\n    opt.value = optVal;\n    opt.textContent = optVal;\n    voltSelect.appendChild(opt);\n  });\n  if (voltage && !powerDistVoltageOptions.includes(voltage)) {\n    const opt = document.createElement('option');\n    opt.value = voltage;\n    opt.textContent = voltage;\n    voltSelect.appendChild(opt);\n  }\n  voltSelect.value = voltage;\n  row.appendChild(createFieldWithLabel(voltSelect, 'Voltage'));\n\n  const currSelect = document.createElement('select');\n  currSelect.className = 'power-dist-current-select';\n  addEmptyOption(currSelect);\n  currSelect.name = 'powerDistCurrent';\n  powerDistCurrentOptions.forEach(optVal => {\n    const opt = document.createElement('option');\n    opt.value = optVal;\n    opt.textContent = optVal;\n    currSelect.appendChild(opt);\n  });\n  if (current && !powerDistCurrentOptions.includes(current)) {\n    const opt = document.createElement('option');\n    opt.value = current;\n    opt.textContent = current;\n    currSelect.appendChild(opt);\n  }\n  currSelect.value = current;\n  row.appendChild(createFieldWithLabel(currSelect, 'Current'));\n\n  const wattInput = document.createElement('input');\n  wattInput.type = 'number';\n  wattInput.step = '0.1';\n  wattInput.placeholder = 'W';\n  wattInput.value = wattage === null || wattage === undefined ? '' : wattage;\n  wattInput.name = 'powerDistWatt';\n  row.appendChild(createFieldWithLabel(wattInput, 'W')); \n\n  const notesInput = document.createElement('input');\n  notesInput.type = 'text';\n  notesInput.placeholder = 'Notes';\n  notesInput.value = notes;\n  notesInput.name = 'powerDistNotes';\n  row.appendChild(createFieldWithLabel(notesInput, 'Notes'));\n\n  const addBtn = document.createElement('button');\n  addBtn.type = 'button';\n  configureIconOnlyButton(addBtn, ICON_GLYPHS.add, {\n    contextPaths: ['powerDistributionHeading', ['cameraPowerDistLabel']],\n    fallbackContext: 'Power Distribution',\n    actionKey: 'addEntry'\n  });\n  addBtn.addEventListener('click', () => {\n    row.after(createPowerDistRow());\n  });\n  row.appendChild(addBtn);\n\n  const removeBtn = document.createElement('button');\n  removeBtn.type = 'button';\n  configureIconOnlyButton(removeBtn, ICON_GLYPHS.minus, {\n    contextPaths: ['powerDistributionHeading', ['cameraPowerDistLabel']],\n    fallbackContext: 'Power Distribution',\n    actionKey: 'removeEntry'\n  });\n  removeBtn.addEventListener('click', () => {\n    if (powerDistContainer.children.length > 1) row.remove();\n  });\n  row.appendChild(removeBtn);\n\n  return row;\n}\n\nfunction setPowerDistribution(list) {\n  powerDistContainer.innerHTML = '';\n  const filtered = filterNoneEntries(list);\n  if (filtered.length) {\n    filtered.forEach(item => {\n      const { type = '', voltage = '', current = '', wattage = '', notes = '' } = item || {};\n      powerDistContainer.appendChild(createPowerDistRow(type, voltage, current, wattage, notes));\n    });\n  } else {\n    powerDistContainer.appendChild(createPowerDistRow());\n  }\n}\n\nfunction getPowerDistribution() {\n  return Array.from(powerDistContainer.querySelectorAll('.form-row'))\n    .map(row => {\n      const [typeSel, voltSel, currSel, wattInput, notesInput] = row.querySelectorAll('select, input');\n      return {\n        type: typeSel.value,\n        voltage: voltSel.value,\n        current: currSel.value,\n        wattage: wattInput.value ? parseFloat(wattInput.value) : null,\n        notes: notesInput.value\n      };\n    })\n    .filter(pd => pd.type && pd.type !== 'None');\n}\n\nfunction clearPowerDistribution() {\n  setPowerDistribution([]);\n}\n\nfunction getAllTimecodeTypes() {\n  const types = new Set();\n  Object.values(devices.cameras).forEach(cam => {\n    const list = cam.timecode;\n    if (Array.isArray(list)) {\n      list.forEach(tc => { if (tc && tc.type) types.add(tc.type); });\n    }\n  });\n  return Array.from(types).sort(localeSort);\n}\n\nlet timecodeTypeOptions = getAllTimecodeTypes();\n\nfunction updateTimecodeTypeOptions() {\n  timecodeTypeOptions = getAllTimecodeTypes();\n  document.querySelectorAll('.timecode-type-select').forEach(sel => {\n    const cur = sel.value;\n    sel.innerHTML = '';\n    addEmptyOption(sel);\n    timecodeTypeOptions.forEach(optVal => {\n      const opt = document.createElement('option');\n      opt.value = optVal;\n      opt.textContent = optVal;\n      sel.appendChild(opt);\n    });\n    if (timecodeTypeOptions.includes(cur)) sel.value = cur;\n  });\n}\n\n// Build a timecode connector row used for editing camera properties.\nfunction createTimecodeRow(type = '', notes = '') {\n  const row = document.createElement('div');\n  row.className = 'form-row';\n\n  const typeSelect = document.createElement('select');\n  typeSelect.className = 'timecode-type-select';\n  typeSelect.name = 'timecodeType';\n  addEmptyOption(typeSelect);\n  timecodeTypeOptions.forEach(optVal => {\n    const opt = document.createElement('option');\n    opt.value = optVal;\n    opt.textContent = optVal;\n    typeSelect.appendChild(opt);\n  });\n  if (type && !timecodeTypeOptions.includes(type)) {\n    const opt = document.createElement('option');\n    opt.value = type;\n    opt.textContent = type;\n    typeSelect.appendChild(opt);\n  }\n  typeSelect.value = type;\n  row.appendChild(createFieldWithLabel(typeSelect, 'Type'));\n\n  const notesInput = document.createElement('input');\n  notesInput.type = 'text';\n  notesInput.placeholder = 'Notes';\n  notesInput.value = notes;\n  notesInput.name = 'timecodeNotes';\n  row.appendChild(createFieldWithLabel(notesInput, 'Notes'));\n\n  const addBtn = document.createElement('button');\n  addBtn.type = 'button';\n  configureIconOnlyButton(addBtn, ICON_GLYPHS.add, {\n    contextPaths: ['timecodeHeading', ['cameraTimecodeLabel']],\n    fallbackContext: 'Timecode',\n    actionKey: 'addEntry'\n  });\n  addBtn.addEventListener('click', () => {\n    row.after(createTimecodeRow());\n  });\n  row.appendChild(addBtn);\n\n  const removeBtn = document.createElement('button');\n  removeBtn.type = 'button';\n  configureIconOnlyButton(removeBtn, ICON_GLYPHS.minus, {\n    contextPaths: ['timecodeHeading', ['cameraTimecodeLabel']],\n    fallbackContext: 'Timecode',\n    actionKey: 'removeEntry'\n  });\n  removeBtn.addEventListener('click', () => {\n    if (timecodeContainer.children.length > 1) row.remove();\n  });\n  row.appendChild(removeBtn);\n\n  return row;\n}\n\nfunction setTimecodes(list) {\n  timecodeContainer.innerHTML = '';\n  const filtered = filterNoneEntries(list);\n  if (filtered.length) {\n    filtered.forEach(item => {\n      const { type = '', notes = '' } = item || {};\n      timecodeContainer.appendChild(createTimecodeRow(type, notes));\n    });\n  } else {\n    timecodeContainer.appendChild(createTimecodeRow());\n  }\n}\n\nfunction getTimecodes() {\n  return Array.from(timecodeContainer.querySelectorAll('.form-row'))\n    .map(row => {\n      const [typeSel, notesInput] = row.querySelectorAll('select, input');\n      return { type: typeSel.value, notes: notesInput.value };\n    })\n    .filter(tc => tc.type && tc.type !== 'None');\n}\n\n  function clearTimecodes() {\n    setTimecodes([]);\n  }\n\n  function getFavoriteValues(id) {\n    const favs = loadFavorites();\n    return Array.isArray(favs[id]) ? favs[id] : [];\n  }\n\n  function applyFavoritesToSelect(selectElem) {\n    if (!selectElem || !selectElem.id) return;\n    const favVals = getFavoriteValues(selectElem.id);\n    if (!favVals.length) return;\n    const opts = Array.from(selectElem.options);\n    const noneOpt = opts.find(o => o.value === 'None');\n    const others = opts.filter(o => o !== noneOpt);\n    const favOpts = [];\n    const restOpts = [];\n    others.forEach(o => (favVals.includes(o.value) ? favOpts.push(o) : restOpts.push(o)));\n    favOpts.sort((a, b) => localeSort(a.textContent, b.textContent));\n    restOpts.sort((a, b) => localeSort(a.textContent, b.textContent));\n    selectElem.innerHTML = '';\n    if (noneOpt) selectElem.appendChild(noneOpt);\n    favOpts.forEach(o => selectElem.appendChild(o));\n    restOpts.forEach(o => selectElem.appendChild(o));\n  }\n\n  function updateFavoriteButton(selectElem) {\n    if (!selectElem || !selectElem._favButton) return;\n    const favVals = getFavoriteValues(selectElem.id);\n    const val = selectElem.value;\n    const isFav = favVals.includes(val);\n    selectElem._favButton.innerHTML = iconMarkup(ICON_GLYPHS.star, 'favorite-icon');\n    selectElem._favButton.classList.toggle('favorited', isFav);\n    selectElem._favButton.disabled = val === 'None';\n    selectElem._favButton.setAttribute('aria-pressed', isFav ? 'true' : 'false');\n  }\n\n  function toggleFavorite(selectElem) {\n    if (!selectElem || !selectElem.id) return;\n    const val = selectElem.value;\n    if (val === 'None') return;\n    const favs = loadFavorites();\n    const list = Array.isArray(favs[selectElem.id]) ? favs[selectElem.id] : [];\n    const idx = list.indexOf(val);\n    if (idx === -1) list.push(val); else list.splice(idx, 1);\n    if (list.length) favs[selectElem.id] = list; else delete favs[selectElem.id];\n    saveFavorites(favs);\n    applyFavoritesToSelect(selectElem);\n    updateFavoriteButton(selectElem);\n    adjustGearListSelectWidth(selectElem);\n  }\n\n  function adjustGearListSelectWidth(selectElem) {\n    if (!selectElem || selectElem.multiple || selectElem.size > 1) return;\n    const container = selectElem.closest('#gearListOutput, #projectRequirementsOutput');\n    if (!container) return;\n    const styles = window.getComputedStyle(selectElem);\n    if (!styles || styles.display === 'none') {\n      selectElem.style.removeProperty('--gear-select-width');\n      return;\n    }\n    const selectedOption = selectElem.selectedOptions && selectElem.selectedOptions[0];\n    const optionText = selectedOption ? selectedOption.textContent.trim() : selectElem.value || '';\n    const fontSize = parseFloat(styles.fontSize) || 16;\n    const approxCharWidth = fontSize * 0.6;\n    const textWidth = (optionText ? optionText.length : 1) * approxCharWidth;\n    const paddingLeft = parseFloat(styles.paddingLeft) || 0;\n    const paddingRight = parseFloat(styles.paddingRight) || 0;\n    const borderLeft = parseFloat(styles.borderLeftWidth) || 0;\n    const borderRight = parseFloat(styles.borderRightWidth) || 0;\n    const arrowReserve = Math.max(fontSize, 16);\n    const minWidth = Math.max(fontSize * 4, 56);\n    const widthPx = Math.max(\n      Math.ceil(textWidth + paddingLeft + paddingRight + borderLeft + borderRight + arrowReserve),\n      minWidth\n    );\n    selectElem.style.setProperty('--gear-select-width', `${widthPx}px`);\n  }\n\n  function adjustGearListSelectWidths(container) {\n    if (!container) return;\n    container\n      .querySelectorAll('select')\n      .forEach(selectElem => adjustGearListSelectWidth(selectElem));\n  }\n\n  function ensureSelectWrapper(selectElem) {\n    if (!selectElem) return null;\n    let wrapper = selectElem.parentElement;\n    if (!wrapper || !wrapper.classList.contains('select-wrapper')) {\n      if (wrapper && wrapper.tagName === 'LABEL') {\n        const label = wrapper;\n        wrapper = document.createElement('div');\n        wrapper.className = 'select-wrapper';\n        label.parentElement.insertBefore(wrapper, label.nextSibling);\n        wrapper.appendChild(selectElem);\n      } else {\n        wrapper = document.createElement('div');\n        wrapper.className = 'select-wrapper';\n        selectElem.insertAdjacentElement('beforebegin', wrapper);\n        wrapper.appendChild(selectElem);\n      }\n    }\n    return wrapper;\n  }\n\n  function initFavoritableSelect(selectElem) {\n    if (!selectElem || !selectElem.id || selectElem.multiple || selectElem.hidden) return;\n    const wrapper = ensureSelectWrapper(selectElem);\n    const gearItem = selectElem.closest('.gear-item');\n\n    function cleanupFavoriteButton(btn) {\n      if (!btn) return;\n      if (btn._favListener) {\n        btn.removeEventListener('click', btn._favListener);\n        btn._favListener = null;\n      }\n      btn.remove();\n    }\n\n    let favoriteButton =\n      selectElem._favButton && selectElem._favButton.isConnected ? selectElem._favButton : null;\n\n    if (wrapper) {\n      const wrapperButtons = Array.from(wrapper.querySelectorAll('.favorite-toggle'));\n      if (favoriteButton && !wrapperButtons.includes(favoriteButton)) {\n        favoriteButton = null;\n      }\n      if (!favoriteButton && wrapperButtons.length > 0) {\n        [favoriteButton] = wrapperButtons;\n      }\n      wrapperButtons.forEach(btn => {\n        if (btn !== favoriteButton) cleanupFavoriteButton(btn);\n      });\n    }\n\n    if (gearItem) {\n      Array.from(gearItem.querySelectorAll('.favorite-toggle'))\n        .filter(\n          btn =>\n            btn !== favoriteButton && btn.getAttribute('data-fav-select-id') === selectElem.id\n        )\n        .forEach(cleanupFavoriteButton);\n    }\n\n    if (!favoriteButton) {\n      favoriteButton = document.createElement('button');\n      if (wrapper) {\n        wrapper.appendChild(favoriteButton);\n      } else {\n        selectElem.after(favoriteButton);\n      }\n    } else if (wrapper && favoriteButton.parentElement !== wrapper) {\n      wrapper.appendChild(favoriteButton);\n    }\n\n    if (favoriteButton._favListener) {\n      favoriteButton.removeEventListener('click', favoriteButton._favListener);\n    }\n    favoriteButton.type = 'button';\n    favoriteButton.className = 'favorite-toggle';\n    favoriteButton.innerHTML = iconMarkup(ICON_GLYPHS.star, 'favorite-icon');\n    favoriteButton.setAttribute('aria-pressed', 'false');\n    favoriteButton.setAttribute('data-fav-select-id', selectElem.id);\n    const clickHandler = () => toggleFavorite(selectElem);\n    favoriteButton.addEventListener('click', clickHandler);\n    favoriteButton._favListener = clickHandler;\n\n    if (!selectElem._favChangeListener) {\n      const changeListener = () => updateFavoriteButton(selectElem);\n      selectElem.addEventListener('change', changeListener);\n      selectElem._favChangeListener = changeListener;\n    }\n\n    selectElem._favButton = favoriteButton;\n    selectElem._favInit = true;\n\n    if (selectElem._favButton) {\n      selectElem._favButton.setAttribute('data-fav-select-id', selectElem.id);\n      selectElem._favButton.setAttribute('aria-label', texts[currentLang].favoriteToggleLabel);\n      selectElem._favButton.setAttribute('title', texts[currentLang].favoriteToggleLabel);\n      selectElem._favButton.setAttribute(\n        'data-help',\n        texts[currentLang].favoriteToggleHelp || texts[currentLang].favoriteToggleLabel\n      );\n    }\n\n    applyFavoritesToSelect(selectElem);\n    updateFavoriteButton(selectElem);\n    adjustGearListSelectWidth(selectElem);\n  }\n\n  // Populate dropdowns with device options\n  function populateSelect(selectElem, optionsObj = {}, includeNone = true) {\n    if (!selectElem) return;\n    // Ensure we always work with an object so Object.keys does not throw if\n    // `optionsObj` is passed as `null`.\n    const opts = optionsObj && typeof optionsObj === \"object\" ? optionsObj : {};\n    selectElem.innerHTML = \"\";\n    if (includeNone) {\n      const noneOpt = document.createElement(\"option\");\n      noneOpt.value = \"None\";\n      const noneMap = { de: \"Keine Auswahl\", es: \"Ninguno\", fr: \"Aucun\" };\n      noneOpt.textContent = noneMap[currentLang] || \"None\";\n      selectElem.appendChild(noneOpt);\n    }\n    Object.keys(opts)\n      .filter(name => name !== \"None\")\n      .sort(localeSort)\n      .forEach(name => {\n        const opt = document.createElement(\"option\");\n        opt.value = name;\n        opt.textContent = name;\n        selectElem.appendChild(opt);\n      });\n    initFavoritableSelect(selectElem);\n  }\n\nfunction populateMonitorSelect() {\n  const filtered = Object.fromEntries(\n    Object.entries(devices.monitors || {})\n      .filter(([, data]) => !(data.wirelessRX && !data.wirelessTx))\n  );\n  populateSelect(monitorSelect, filtered, true);\n}\n\nfunction filterSelect(selectElem, filterValue) {\n  const text = filterValue.toLowerCase();\n  Array.from(selectElem.options).forEach(opt => {\n    if (opt.value === \"None\" || text === \"\" || opt.textContent.toLowerCase().includes(text)) {\n      opt.hidden = false;\n      opt.disabled = false;\n    } else {\n      opt.hidden = true;\n      opt.disabled = true;\n    }\n  });\n}\n\nfunction filterDeviceList(listElem, filterValue) {\n  const text = filterValue.toLowerCase();\n  Array.from(listElem.querySelectorAll('li')).forEach(li => {\n    const nameSpan = li.querySelector('.device-summary span');\n    const name = nameSpan ? nameSpan.textContent.toLowerCase() : '';\n    if (text === '' || name.includes(text)) {\n      li.style.display = '';\n    } else {\n      li.style.display = 'none';\n    }\n  });\n}\n\n// Attach in-select search filtering for a dropdown\nfunction attachSelectSearch(selectElem) {\n  let searchStr = \"\";\n  let timer;\n\n  selectElem.addEventListener('keydown', (e) => {\n    if (e.key === 'Backspace') {\n      searchStr = searchStr.slice(0, -1);\n      filterSelect(selectElem, searchStr);\n      e.preventDefault();\n    } else if (e.key === 'Escape') {\n      searchStr = \"\";\n      filterSelect(selectElem, searchStr);\n    } else if (e.key.length === 1 && !e.ctrlKey && !e.metaKey && !e.altKey) {\n      searchStr += e.key.toLowerCase();\n      filterSelect(selectElem, searchStr);\n      e.preventDefault();\n    } else {\n      return;\n    }\n\n    clearTimeout(timer);\n    timer = setTimeout(() => {\n      searchStr = \"\";\n    }, 1000);\n    if (typeof timer.unref === 'function') {\n      timer.unref();\n    }\n  });\n\n  selectElem.addEventListener('blur', () => {\n    searchStr = \"\";\n    filterSelect(selectElem, \"\");\n  });\n}\n\nfunction bindFilterInput(inputElem, callback) {\n  if (!inputElem) {\n    return;\n  }\n  inputElem.addEventListener(\"input\", callback);\n  inputElem.addEventListener(\"keydown\", (e) => {\n    if (e.key === \"Escape\") {\n      inputElem.value = \"\";\n      callback();\n    }\n  });\n  addInputClearButton(inputElem, callback);\n}\n\nfunction addInputClearButton(inputElem, callback) {\n  const label = (texts[currentLang] && texts[currentLang].clearFilter) || \"Clear filter\";\n  const btn = document.createElement(\"button\");\n  btn.type = \"button\";\n  btn.className = \"clear-input-btn\";\n  btn.innerHTML = iconMarkup(ICON_GLYPHS.circleX, 'clear-icon');\n  btn.setAttribute(\"aria-label\", label);\n  btn.title = label;\n  btn.hidden = true;\n  btn.addEventListener(\"click\", () => {\n    inputElem.value = \"\";\n    callback();\n    inputElem.focus();\n  });\n  inputElem.insertAdjacentElement(\"afterend\", btn);\n  const toggle = () => {\n    btn.hidden = !inputElem.value;\n  };\n  inputElem.addEventListener(\"input\", toggle);\n  toggle();\n}\n\nfunction applyFilters() {\n  deviceManagerLists.forEach(({ list, filterInput }) => {\n    if (!list) return;\n    const value = filterInput ? filterInput.value : '';\n    filterDeviceList(list, value);\n  });\n}\n\n// Initialize device selection dropdowns\npopulateSelect(cameraSelect, devices.cameras, true);\npopulateMonitorSelect();\npopulateSelect(videoSelect, devices.video, true);\nif (cageSelect) populateSelect(cageSelect, devices.accessories?.cages || {}, true);\nmotorSelects.forEach(sel => populateSelect(sel, devices.fiz.motors, true));\ncontrollerSelects.forEach(sel => populateSelect(sel, devices.fiz.controllers, true));\npopulateSelect(distanceSelect, devices.fiz.distance, true);\npopulateSelect(batterySelect, devices.batteries, true);\npopulateSelect(hotswapSelect, devices.batteryHotswaps || {}, true);\nupdateBatteryPlateVisibility();\nupdateBatteryOptions();\n\n// Enable search inside dropdowns\n[cameraSelect, monitorSelect, videoSelect, cageSelect, distanceSelect, batterySelect, hotswapSelect, lensSelect]\n  .forEach(sel => attachSelectSearch(sel));\nmotorSelects.forEach(sel => attachSelectSearch(sel));\ncontrollerSelects.forEach(sel => attachSelectSearch(sel));\napplyFilters();\nsetVideoOutputs([]);\nsetMonitorVideoInputs([]);\nsetMonitorVideoOutputs([]);\nsetViewfinderVideoInputs([]);\nsetViewfinderVideoOutputs([]);\nsetFizConnectors([]);\nupdateFizConnectorOptions();\nupdateMotorConnectorOptions();\nupdateControllerConnectorOptions();\nupdateControllerPowerOptions();\nupdateControllerBatteryOptions();\nupdateControllerConnectivityOptions();\nupdateDistanceConnectionOptions();\nupdateDistanceMethodOptions();\nupdateDistanceDisplayOptions();\nsetViewfinders([]);\nsetBatteryPlates([]);\nsetRecordingMedia([]);\nupdateRecordingMediaOptions();\nupdatePlateTypeOptions();\nsetLensMounts([]);\nupdateMountTypeOptions();\nupdatePowerPortOptions();\nsetPowerDistribution([]);\nupdatePowerDistTypeOptions();\nupdatePowerDistVoltageOptions();\nupdatePowerDistCurrentOptions();\nsetTimecodes([]);\nupdateTimecodeTypeOptions();\nupdateDistanceConnectionOptions();\nupdateDistanceMethodOptions();\nupdateDistanceDisplayOptions();\n\n// Set default selections for dropdowns\n\n// Kamera: Wenn Option \u201ENone\u201C existiert, dann setze sie \u2013 sonst erste Option\nconst noneCameraOption = Array.from(cameraSelect.options).find(opt => opt.value === \"None\");\nif (noneCameraOption) {\n  cameraSelect.value = \"None\";\n} else {\n  cameraSelect.selectedIndex = 0;\n}\n\n// F\xFCr die anderen Dropdowns\n[monitorSelect, videoSelect, distanceSelect, batterySelect].forEach(sel => {\n  const noneOption = Array.from(sel.options).find(opt => opt.value === \"None\");\n  if (noneOption) {\n    sel.value = \"None\";\n  } else {\n    sel.selectedIndex = 0;\n  }\n});\n\n// FIZ Dropdowns\nmotorSelects.forEach(sel => { if (sel.options.length) sel.value = \"None\"; });\ncontrollerSelects.forEach(sel => { if (sel.options.length) sel.value = \"None\"; });\n\n// Calculation function to update results and warnings\nfunction renderTemperatureNote(baseHours) {\n  const container = document.getElementById(\"temperatureNote\");\n  if (!container) return;\n  const heading = texts[currentLang].temperatureNoteHeading;\n  let html = `<p>${heading}</p>`;\n  if (!baseHours || !isFinite(baseHours)) {\n    container.innerHTML = html;\n    return;\n  }\n  const temperatureHeader = getTemperatureColumnLabelForLang(currentLang, temperatureUnit);\n  html += `<table><tr><th>${temperatureHeader}</th><th>${texts[currentLang].runtimeLabel}</th><th>${texts[currentLang].batteryCountTempLabel}</th></tr>`;\n  TEMPERATURE_SCENARIOS.forEach(scenario => {\n    const runtime = baseHours * scenario.factor;\n    const runtimeCell = Number.isFinite(runtime) ? runtime.toFixed(2) : '0.00';\n    let batteries = '\u2013';\n    if (Number.isFinite(runtime) && runtime > 0) {\n      batteries = Math.ceil(10 / runtime + 1);\n    }\n    const temperatureCell = formatTemperatureForDisplay(scenario.celsius);\n    html += `<tr><td style=\"color:${scenario.color}\">${temperatureCell}</td><td>${runtimeCell}</td><td>${batteries}</td></tr>`;\n  });\n  html += \"</table>\";\n  container.innerHTML = html;\n}\n\nfunction ensureFeedbackTemperatureOptions(select) {\n  if (!select) return;\n  const expectedOptions = FEEDBACK_TEMPERATURE_MAX - FEEDBACK_TEMPERATURE_MIN + 2;\n  if (select.options.length === expectedOptions) {\n    return;\n  }\n  const previousValue = select.value;\n  select.innerHTML = '';\n  const emptyOpt = document.createElement('option');\n  emptyOpt.value = '';\n  emptyOpt.textContent = '';\n  select.appendChild(emptyOpt);\n  for (let temp = FEEDBACK_TEMPERATURE_MIN; temp <= FEEDBACK_TEMPERATURE_MAX; temp += 1) {\n    const opt = document.createElement('option');\n    opt.value = String(temp);\n    select.appendChild(opt);\n  }\n  if (previousValue) {\n    select.value = previousValue;\n  }\n}\n\nfunction updateFeedbackTemperatureOptions(lang = currentLang, unit = temperatureUnit) {\n  const tempSelect = document.getElementById('fbTemperature');\n  if (!tempSelect) return;\n  ensureFeedbackTemperatureOptions(tempSelect);\n  Array.from(tempSelect.options).forEach(option => {\n    if (!option) return;\n    if (option.value === '') {\n      option.textContent = '';\n      return;\n    }\n    const celsiusValue = Number(option.value);\n    if (!Number.isFinite(celsiusValue)) return;\n    option.textContent = formatTemperatureForDisplay(celsiusValue, {\n      lang,\n      unit,\n      includeSign: 'negative'\n    });\n  });\n}\n\nfunction updateFeedbackTemperatureLabel(lang = currentLang, unit = temperatureUnit) {\n  const labelTextElem = document.getElementById('fbTemperatureLabelText');\n  const labelElem = document.getElementById('fbTemperatureLabel');\n  const label = `${getTemperatureColumnLabelForLang(lang, unit)}:`;\n  if (labelTextElem) {\n    labelTextElem.textContent = label;\n  } else if (labelElem) {\n    labelElem.textContent = label;\n  }\n}\n\nfunction applyTemperatureUnitPreference(unit, options = {}) {\n  const normalized = normalizeTemperatureUnit(unit);\n  const { persist = true, reRender = true, forceUpdate = false } = options || {};\n  if (!forceUpdate && temperatureUnit === normalized) {\n    return;\n  }\n  temperatureUnit = normalized;\n  if (persist && typeof localStorage !== 'undefined') {\n    try {\n      localStorage.setItem(TEMPERATURE_UNIT_STORAGE_KEY, temperatureUnit);\n    } catch (error) {\n      console.warn('Could not save temperature unit preference', error);\n    }\n  }\n  if (typeof settingsTemperatureUnit !== 'undefined' && settingsTemperatureUnit) {\n    settingsTemperatureUnit.value = temperatureUnit;\n  }\n  if (reRender) {\n    updateFeedbackTemperatureLabel();\n    updateFeedbackTemperatureOptions();\n    renderTemperatureNote(lastRuntimeHours);\n  }\n}\n\n// Calculation function to update results and warnings\nfunction updateCalculations() {\n  // Gather selected values\n  const camera      = cameraSelect.value;\n  const monitor     = monitorSelect.value;\n  const video       = videoSelect.value;\n  const motors      = motorSelects.map(sel => sel.value);\n  const controllers = controllerSelects.map(sel => sel.value);\n  const distance    = distanceSelect.value;\n  let battery       = batterySelect.value;\n\n  // Calculate total power consumption (W)\n  let cameraW = 0;\n  if (devices.cameras[camera] !== undefined) {\n    const camData = devices.cameras[camera];\n    cameraW = typeof camData === 'object' ? camData.powerDrawWatts || 0 : camData;\n  }\n  let monitorW = 0;\n  if (devices.monitors[monitor] !== undefined) {\n    const mData = devices.monitors[monitor];\n    monitorW = typeof mData === 'object' ? mData.powerDrawWatts || 0 : mData;\n  }\n  let videoW = 0;\n  if (devices.video[video] !== undefined) {\n    const vData = devices.video[video];\n    videoW = typeof vData === 'object' ? vData.powerDrawWatts || 0 : vData;\n  }\n  let motorsW = 0;\n  motors.forEach(m => {\n    if (devices.fiz.motors[m] !== undefined) {\n      const d = devices.fiz.motors[m];\n      motorsW += typeof d === 'object' ? d.powerDrawWatts || 0 : d;\n    }\n  });\n  let controllersW = 0;\n  controllers.forEach(c => {\n    if (devices.fiz.controllers[c] !== undefined) {\n      const d = devices.fiz.controllers[c];\n      controllersW += typeof d === 'object' ? d.powerDrawWatts || 0 : d;\n    }\n  });\n  let distanceW = 0;\n  if (devices.fiz.distance[distance] !== undefined) {\n    const d = devices.fiz.distance[distance];\n    distanceW = typeof d === 'object' ? d.powerDrawWatts || 0 : d;\n  }\n\n  const totalWatt = cameraW + monitorW + videoW + motorsW + controllersW + distanceW;\n  totalPowerElem.textContent = totalWatt.toFixed(1);\n\n  const segments = [\n    { power: cameraW, className: \"camera\", label: texts[currentLang].cameraLabel },\n    { power: monitorW, className: \"monitor\", label: texts[currentLang].monitorLabel },\n    { power: videoW, className: \"video\", label: texts[currentLang].videoLabel },\n    { power: motorsW, className: \"motors\", label: texts[currentLang].fizMotorsLabel },\n    { power: controllersW, className: \"controllers\", label: texts[currentLang].fizControllersLabel },\n    { power: distanceW, className: \"distance\", label: texts[currentLang].distanceLabel }\n  ].filter(s => s.power > 0);\n\n  // Update breakdown by category\n  breakdownListElem.innerHTML = \"\";\n  if (cameraW > 0) {\n    const li = document.createElement(\"li\");\n    li.innerHTML = `<strong>${texts[currentLang].cameraLabel}</strong> ${cameraW.toFixed(1)} W`;\n    breakdownListElem.appendChild(li);\n  }\n  if (monitorW > 0) {\n    const li = document.createElement(\"li\");\n    li.innerHTML = `<strong>${texts[currentLang].monitorLabel}</strong> ${monitorW.toFixed(1)} W`;\n    breakdownListElem.appendChild(li);\n  }\n  if (videoW > 0) {\n    const li = document.createElement(\"li\");\n    li.innerHTML = `<strong>${texts[currentLang].videoLabel}</strong> ${videoW.toFixed(1)} W`;\n    breakdownListElem.appendChild(li);\n  }\n  if (motorsW > 0) {\n    const li = document.createElement(\"li\");\n    li.innerHTML = `<strong>${texts[currentLang].fizMotorsLabel}</strong> ${motorsW.toFixed(1)} W`;\n    breakdownListElem.appendChild(li);\n  }\n  if (controllersW > 0) {\n    const li = document.createElement(\"li\");\n    li.innerHTML = `<strong>${texts[currentLang].fizControllersLabel}</strong> ${controllersW.toFixed(1)} W`;\n    breakdownListElem.appendChild(li);\n  }\n  if (distanceW > 0) {\n    const li = document.createElement(\"li\");\n    li.innerHTML = `<strong>${texts[currentLang].distanceLabel}</strong> ${distanceW.toFixed(1)} W`;\n    breakdownListElem.appendChild(li);\n  }\n\n  // Calculate currents depending on battery type\n  const bMountCam = getSelectedPlate() === 'B-Mount';\n  let highV = bMountCam ? 33.6 : 14.4;\n  let lowV = bMountCam ? 21.6 : 12.0;\n  let totalCurrentHigh = 0;\n  let totalCurrentLow = 0;\n  if (totalWatt > 0) {\n    totalCurrentHigh = totalWatt / highV;\n    totalCurrentLow = totalWatt / lowV;\n  }\n  const currentHighLabel = document.getElementById(\"totalCurrent144Label\");\n  currentHighLabel.textContent = bMountCam\n    ? texts[currentLang].totalCurrent336Label\n    : texts[currentLang].totalCurrent144Label;\n  currentHighLabel.setAttribute(\n    \"data-help\",\n    bMountCam\n      ? texts[currentLang].totalCurrent336Help\n      : texts[currentLang].totalCurrent144Help\n  );\n  const currentLowLabel = document.getElementById(\"totalCurrent12Label\");\n  currentLowLabel.textContent = bMountCam\n    ? texts[currentLang].totalCurrent216Label\n    : texts[currentLang].totalCurrent12Label;\n  currentLowLabel.setAttribute(\n    \"data-help\",\n    bMountCam\n      ? texts[currentLang].totalCurrent216Help\n      : texts[currentLang].totalCurrent12Help\n  );\n  totalCurrent144Elem.textContent = totalCurrentHigh.toFixed(2);\n  totalCurrent12Elem.textContent = totalCurrentLow.toFixed(2);\n\n  // Update battery and hotswap options based on current draw\n  updateBatteryOptions();\n  battery = batterySelect.value;\n\n// Wenn kein Akku oder \"None\" ausgew\xE4hlt ist: Laufzeit = nicht berechenbar, keine Warnungen\nlet hours = null;\nif (!battery || battery === \"None\" || !devices.batteries[battery]) {\n  batteryLifeElem.textContent = \"\u2013\";\n  batteryCountElem.textContent = \"\u2013\";\n  setStatusMessage(pinWarnElem, '');\n  setStatusLevel(pinWarnElem, null);\n  setStatusMessage(dtapWarnElem, '');\n  setStatusLevel(dtapWarnElem, null);\n  if (hotswapWarnElem) {\n    setStatusMessage(hotswapWarnElem, '');\n    setStatusLevel(hotswapWarnElem, null);\n  }\n  lastRuntimeHours = null;\n  drawPowerDiagram(0, segments, 0);\n} else {\n    const battData = devices.batteries[battery];\n    const hsName = hotswapSelect.value;\n    const hsData = devices.batteryHotswaps && devices.batteryHotswaps[hsName];\n    const capacityWh = battData.capacity + (hsData?.capacity || 0);\n    let maxPinA = battData.pinA;\n    const maxDtapA = battData.dtapA;\n    if (hsData && typeof hsData.pinA === 'number') {\n      if (hsData.pinA < maxPinA) {\n        setStatusMessage(\n          hotswapWarnElem,\n          texts[currentLang].warnHotswapLower\n            .replace(\"{max}\", hsData.pinA)\n            .replace(\"{batt}\", battData.pinA)\n        );\n        setStatusLevel(hotswapWarnElem, 'warning');\n        maxPinA = hsData.pinA;\n      } else {\n        setStatusMessage(hotswapWarnElem, '');\n        setStatusLevel(hotswapWarnElem, null);\n      }\n    } else {\n      if (hotswapWarnElem) {\n        setStatusMessage(hotswapWarnElem, '');\n        setStatusLevel(hotswapWarnElem, null);\n      }\n    }\n    const availableWatt = maxPinA * lowV;\n    drawPowerDiagram(availableWatt, segments, maxPinA);\n    totalCurrent144Elem.textContent = totalCurrentHigh.toFixed(2);\n    totalCurrent12Elem.textContent = totalCurrentLow.toFixed(2);\n    if (totalWatt === 0) {\n      hours = Infinity;\n      batteryLifeElem.textContent = \"\u221E\";\n    } else {\n      hours = capacityWh / totalWatt;\n      batteryLifeElem.textContent = hours.toFixed(2);\n    }\n    lastRuntimeHours = hours;\n    // Round up total batteries (including one spare) to the next full number\n    const batteriesNeeded = Math.ceil(10 / hours + 1);\n    batteryCountElem.textContent = batteriesNeeded.toString();\n    // Warnings about current draw vs battery limits\n    setStatusMessage(pinWarnElem, '');\n    setStatusMessage(dtapWarnElem, '');\n    let pinSeverity = \"\";\n    let dtapSeverity = \"\";\n    if (totalCurrentLow > maxPinA) {\n      setStatusMessage(\n        pinWarnElem,\n        texts[currentLang].warnPinExceeded\n          .replace(\"{current}\", totalCurrentLow.toFixed(2))\n          .replace(\"{max}\", maxPinA)\n      );\n      pinSeverity = 'danger';\n    } else if (totalCurrentLow > maxPinA * 0.8) {\n      setStatusMessage(\n        pinWarnElem,\n        texts[currentLang].warnPinNear\n          .replace(\"{current}\", totalCurrentLow.toFixed(2))\n          .replace(\"{max}\", maxPinA)\n      );\n      pinSeverity = 'warning';\n    }\n    if (!bMountCam) {\n      if (totalCurrentLow > maxDtapA) {\n        setStatusMessage(\n          dtapWarnElem,\n          texts[currentLang].warnDTapExceeded\n            .replace(\"{current}\", totalCurrentLow.toFixed(2))\n            .replace(\"{max}\", maxDtapA)\n        );\n        dtapSeverity = 'danger';\n      } else if (totalCurrentLow > maxDtapA * 0.8) {\n        setStatusMessage(\n          dtapWarnElem,\n          texts[currentLang].warnDTapNear\n            .replace(\"{current}\", totalCurrentLow.toFixed(2))\n            .replace(\"{max}\", maxDtapA)\n        );\n        dtapSeverity = 'warning';\n      }\n    }\n    // Show max current capability and status (OK/Warning) for Pin and D-Tap\n    if (pinWarnElem.textContent === \"\") {\n      setStatusMessage(\n        pinWarnElem,\n        texts[currentLang].pinOk\n          .replace(\"{max}\", maxPinA)\n      );\n      setStatusLevel(pinWarnElem, 'success');\n    } else {\n      setStatusLevel(pinWarnElem, pinSeverity || 'warning');\n    }\n    if (!bMountCam) {\n      if (dtapWarnElem.textContent === \"\") {\n        setStatusMessage(\n          dtapWarnElem,\n          texts[currentLang].dtapOk\n            .replace(\"{max}\", maxDtapA)\n        );\n        setStatusLevel(dtapWarnElem, 'success');\n      } else {\n        setStatusLevel(dtapWarnElem, dtapSeverity || 'warning');\n      }\n    } else {\n      setStatusMessage(dtapWarnElem, '');\n      setStatusLevel(dtapWarnElem, null);\n    }\n  }\n\n  // Battery comparison table update\n  if (totalWatt > 0) {\n    // Build lists of batteries that can supply this current (via Pin or D-Tap)\n    const selectedBatteryName = batterySelect.value;\n    const camName = cameraSelect.value;\n    const plateFilter = getSelectedPlate();\n    const supportsB = supportsBMountCamera(camName);\n    const supportsGold = supportsGoldMountCamera(camName);\n    let selectedCandidate = null;\n    if (selectedBatteryName && selectedBatteryName !== \"None\" && devices.batteries[selectedBatteryName]) {\n      const selData = devices.batteries[selectedBatteryName];\n      if (\n        (!plateFilter || selData.mount_type === plateFilter) &&\n        (supportsB || selData.mount_type !== 'B-Mount') &&\n        (supportsGold || selData.mount_type !== 'Gold-Mount')\n      ) {\n        const pinOK_sel = totalCurrentLow <= selData.pinA;\n        const dtapOK_sel = !bMountCam && totalCurrentLow <= selData.dtapA;\n        if (pinOK_sel || dtapOK_sel) {\n          const selHours = selData.capacity / totalWatt;\n          let selMethod;\n          if (pinOK_sel && dtapOK_sel) selMethod = \"both pins and D-Tap\";\n          else if (pinOK_sel) selMethod = \"pins\";\n          else selMethod = \"dtap\";\n          selectedCandidate = { name: selectedBatteryName, hours: selHours, method: selMethod };\n        }\n      }\n    }\n\n    const pinsCandidates = [];\n    const dtapCandidates = [];\n    for (let battName in devices.batteries) {\n      if (battName === \"None\") continue;\n      if (selectedCandidate && battName === selectedCandidate.name) continue;\n\n      const battData = devices.batteries[battName];\n      if (plateFilter && battData.mount_type !== plateFilter) continue;\n      if (!plateFilter && !supportsB && battData.mount_type === 'B-Mount') continue;\n      if (!plateFilter && !supportsGold && battData.mount_type === 'Gold-Mount') continue;\n      const canPin = totalCurrentLow <= battData.pinA;\n      const canDTap = !bMountCam && totalCurrentLow <= battData.dtapA;\n\n      if (canPin) {\n        const hours = battData.capacity / totalWatt;\n        const method = (canDTap ? \"both pins and D-Tap\" : \"pins\");\n        pinsCandidates.push({ name: battName, hours: hours, method: method });\n      } else if (canDTap) {\n        const hours = battData.capacity / totalWatt;\n        dtapCandidates.push({ name: battName, hours: hours, method: \"dtap\" });\n      }\n    }\n\n    // Sort by runtime (hours) descending within each group\n    // Ensure stable ordering: sort by runtime descending, then by name\n    const sortByHoursThenName = (a, b) => {\n      const diff = b.hours - a.hours;\n      return diff !== 0 ? diff : collator.compare(a.name, b.name);\n    };\n    pinsCandidates.sort(sortByHoursThenName);\n    dtapCandidates.sort(sortByHoursThenName);\n\n    // Prepare table HTML\n    let tableHtml = `<tr><th>${texts[currentLang].batteryTableLabel}</th><th>${texts[currentLang].runtimeLabel}</th><th></th></tr>`;\n\n    if ((selectedCandidate ? 1 : 0) + pinsCandidates.length + dtapCandidates.length === 0) {\n      // No battery can supply via either output\n      tableHtml += `<tr><td colspan=\"3\">${texts[currentLang].noBatterySupports}</td></tr>`;\n    } else {\n      const allCandidatesForMax = (selectedCandidate ? [selectedCandidate] : []).concat(pinsCandidates, dtapCandidates);\n      const maxHours = Math.max(...allCandidatesForMax.map(c => c.hours)) || 1; // Ensure not dividing by zero\n\n      // Helper function to get the correct bar class\n      const getBarClass = (method) => {\n          return method === \"pins\" ? \"bar bar-pins-only\" : \"bar\";\n      };\n      // Helper to display method label\n      const getMethodLabel = (method) => {\n            const colorMap = {\n              pins: { var: '--warning-color', fallback: '#FF9800', text: texts[currentLang].methodPinsOnly },\n              'both pins and D-Tap': { var: '--success-color', fallback: '#4CAF50', text: texts[currentLang].methodPinsAndDTap },\n              infinite: { var: '--info-color', fallback: '#007bff', text: texts[currentLang].methodInfinite }\n            };\n            const entry = colorMap[method];\n            if (entry) {\n              const color = getCssVariableValue(entry.var, entry.fallback);\n              return `<span style=\"color:${color};\">${entry.text}</span>`;\n            }\n            return method;\n        };\n\n      // Add selected battery first, if it's a valid candidate\n      if (selectedCandidate) {\n        tableHtml += `<tr class=\"selectedBatteryRow\">\n                        <td>${escapeHtml(selectedCandidate.name)}</td>\n                        <td>${selectedCandidate.hours.toFixed(2)}h (${getMethodLabel(selectedCandidate.method)})</td>\n                        <td>\n                          <div class=\"barContainer\">\n                            <div class=\"${getBarClass(selectedCandidate.method)}\" style=\"width: ${(selectedCandidate.hours / maxHours) * 100}%;\"></div>\n                          </div>\n                        </td>\n                      </tr>`;\n      }\n      // Add other candidates\n      pinsCandidates.forEach(candidate => {\n        if (selectedCandidate && candidate.name === selectedCandidate.name) return; // Already added if selected\n        tableHtml += `<tr>\n                        <td>${escapeHtml(candidate.name)}</td>\n                        <td>${candidate.hours.toFixed(2)}h (${getMethodLabel(candidate.method)})</td>\n                        <td>\n                          <div class=\"barContainer\">\n                            <div class=\"${getBarClass(candidate.method)}\" style=\"width: ${(candidate.hours / maxHours) * 100}%;\"></div>\n                          </div>\n                        </td>\n                      </tr>`;\n      });\n       dtapCandidates.forEach(candidate => {\n        if (selectedCandidate && candidate.name === selectedCandidate.name) return; // Already added if selected\n        // Only add if not already in pinsCandidates (to avoid duplicates if a battery can do both but was only listed under dtapCandidates)\n        const alreadyInPins = pinsCandidates.some(p => p.name === candidate.name);\n        if (!alreadyInPins) {\n            tableHtml += `<tr>\n                            <td>${escapeHtml(candidate.name)}</td>\n                            <td>${candidate.hours.toFixed(2)}h (${getMethodLabel(candidate.method)})</td>\n                            <td>\n                              <div class=\"barContainer\">\n                                <div class=\"${getBarClass(candidate.method)}\" style=\"width: ${(candidate.hours / maxHours) * 100}%;\"></div>\n                              </div>\n                            </td>\n                          </tr>`;\n        }\n      });\n    }\n    batteryTableElem.innerHTML = tableHtml;\n    batteryComparisonSection.style.display = \"block\";\n  } else {\n    batteryComparisonSection.style.display = \"none\";\n  }\n  const feedback = renderFeedbackTable(getCurrentSetupKey());\n  if (feedback !== null) {\n    let combinedRuntime = feedback.runtime;\n    if (Number.isFinite(hours)) {\n      combinedRuntime =\n        (feedback.runtime * feedback.weight + hours) / (feedback.weight + 1);\n    }\n    batteryLifeElem.textContent = combinedRuntime.toFixed(2);\n    lastRuntimeHours = combinedRuntime;\n    if (batteryLifeLabelElem) {\n      let label = texts[currentLang].batteryLifeLabel;\n      const userNote = texts[currentLang].runtimeUserCountNote.replace('{count}', feedback.count);\n      const idx = label.indexOf(')');\n      if (idx !== -1) {\n        label = `${label.slice(0, idx)}, ${userNote}${label.slice(idx)}`;\n      }\n      batteryLifeLabelElem.textContent = label;\n      batteryLifeLabelElem.setAttribute(\n        \"data-help\",\n        texts[currentLang].batteryLifeHelp\n      );\n    }\n    if (runtimeAverageNoteElem) {\n      runtimeAverageNoteElem.textContent =\n        feedback.count > 4 ? texts[currentLang].runtimeAverageNote : '';\n    }\n    const batteriesNeeded = Math.ceil(10 / combinedRuntime + 1);\n    batteryCountElem.textContent = batteriesNeeded.toString();\n  } else {\n    if (batteryLifeLabelElem) {\n      batteryLifeLabelElem.textContent = texts[currentLang].batteryLifeLabel;\n      batteryLifeLabelElem.setAttribute(\n        \"data-help\",\n        texts[currentLang].batteryLifeHelp\n      );\n    }\n    if (runtimeAverageNoteElem) {\n      runtimeAverageNoteElem.textContent = '';\n    }\n  }\n  renderTemperatureNote(lastRuntimeHours);\n  checkFizCompatibility();\n  checkFizController();\n  checkArriCompatibility();\n  if (setupDiagramContainer) renderSetupDiagram();\n  refreshGearListIfVisible();\n}\n\nfunction getCurrentSetupKey() {\n  const camera = cameraSelect.value || '';\n  const monitor = monitorSelect.value || '';\n  const video = videoSelect.value || '';\n  const cage = cageSelect ? cageSelect.value : '';\n  const motors = motorSelects.map(sel => sel.value).filter(v => v && v !== 'None').sort().join(',');\n  const controllers = controllerSelects.map(sel => sel.value).filter(v => v && v !== 'None').sort().join(',');\n  const distance = distanceSelect.value || '';\n  const battery = batterySelect.value || '';\n  const hotswap = hotswapSelect.value || '';\n  const plate = getSelectedPlate() || '';\n  return [camera, monitor, video, cage, motors, controllers, distance, battery, hotswap, plate].join('|');\n}\n\nfunction deleteFeedbackEntry(key, index) {\n  const feedbackData = loadFeedbackSafe();\n  if (feedbackData[key]) {\n    feedbackData[key].splice(index, 1);\n    if (!feedbackData[key].length) {\n      delete feedbackData[key];\n    }\n    saveFeedbackSafe(feedbackData);\n    updateCalculations();\n  }\n}\n\nfunction renderFeedbackTable(currentKey) {\n  const container = document.getElementById('feedbackTableContainer');\n  const table = document.getElementById('userFeedbackTable');\n  const feedbackData = loadFeedbackSafe();\n  // Filter out any stored location information to keep the table column hidden\n  const entries = (feedbackData[currentKey] || []).map(entry => {\n    const rest = { ...entry };\n    delete rest.location;\n    return rest;\n  });\n\n  if (!entries.length) {\n    if (table) {\n      table.innerHTML = '';\n      table.classList.add('hidden');\n    }\n    if (container) container.classList.add('hidden');\n    return null;\n  }\n\n  const columns = [\n    { key: 'username', label: 'User' },\n    { key: 'date', label: 'Date' },\n    { key: 'cameraWifi', label: 'WIFI' },\n    { key: 'resolution', label: 'Res' },\n    { key: 'codec', label: 'Codec' },\n    { key: 'framerate', label: 'FPS' },\n    { key: 'firmware', label: 'Firmware' },\n    { key: 'batteryAge', label: 'Battery Age' },\n    { key: 'monitorBrightness', label: 'Monitor Brightness' },\n    { key: 'temperature', label: 'temp' },\n    { key: 'charging', label: 'Charging' },\n    { key: 'runtime', label: 'runtime' },\n    { key: 'batteriesPerDay', label: 'batteries a day' },\n    { key: 'weighting', label: 'weight' }\n  ];\n\n  // Helper functions for weighting factors\n  const parseResolution = str => {\n    if (!str) return null;\n    const s = String(str).toLowerCase();\n    const kMatch = s.match(/(\\d+(?:\\.\\d+)?)\\s*k/);\n    if (kMatch) return parseFloat(kMatch[1]) * 1000;\n    const pMatch = s.match(/(\\d{3,4})p/);\n    if (pMatch) return parseInt(pMatch[1], 10);\n    const xMatch = s.match(/x\\s*(\\d{3,4})/);\n    if (xMatch) return parseInt(xMatch[1], 10);\n    const numMatch = s.match(/(\\d{3,4})/);\n    return numMatch ? parseInt(numMatch[1], 10) : null;\n  };\n  const parseFramerate = str => {\n    if (!str) return null;\n    const m = String(str).match(/\\d+(?:\\.\\d+)?/);\n    return m ? parseFloat(m[0]) : null;\n  };\n  const tempFactor = temp => {\n    if (Number.isNaN(temp)) return 1;\n    if (temp >= 25) return 1;\n    if (temp >= 0) return 1 + (25 - temp) * 0.01;\n    if (temp >= -10) return 1.25 + (-temp) * 0.035;\n    if (temp >= -20) return 1.6 + (-10 - temp) * 0.04;\n    return 2;\n  };\n\n  const resolutionWeight = res => {\n    if (res >= 12000) return 3;\n    if (res >= 8000) return 2;\n    if (res >= 4000) return 1.5;\n    if (res >= 1080) return 1;\n    return res / 1080;\n  };\n\n  const codecWeight = codec => {\n    if (!codec) return 1;\n    const c = String(codec).toLowerCase();\n    if (\n      /(prores\\s*raw|braw|arriraw|r3d|redcode|cinema\\s*dng|cdng|canon\\s*raw|x-ocn|raw)/.test(c)\n    )\n      return 1;\n    if (/prores/.test(c)) return 1.1;\n    if (/dnx|avid/.test(c)) return 1.2;\n    if (/\\ball[\\s-]?i\\b|all\\s*intra|intra/.test(c)) return 1.3;\n    if (/h265|h\\.265|hevc|xavc\\s*hs|xhevc/.test(c)) return 1.7;\n    if (/h264|h\\.264|avc|xavc|avchd|mpeg-4/.test(c)) return 1.5;\n    return 1;\n  };\n\n  const camPower = devices?.cameras?.[cameraSelect?.value]?.powerDrawWatts || 0;\n  const monitorPower = devices?.monitors?.[monitorSelect?.value]?.powerDrawWatts || 0;\n  const videoPower = devices?.video?.[videoSelect?.value]?.powerDrawWatts || 0;\n  const motorPower = motorSelects.reduce(\n    (sum, sel) => sum + (devices?.fiz?.motors?.[sel.value]?.powerDrawWatts || 0),\n    0\n  );\n  const controllerPower = controllerSelects.reduce(\n    (sum, sel) => sum + (devices?.fiz?.controllers?.[sel.value]?.powerDrawWatts || 0),\n    0\n  );\n  const distancePower = devices?.fiz?.distance?.[distanceSelect?.value]?.powerDrawWatts || 0;\n  const otherPower = videoPower + motorPower + controllerPower + distancePower;\n  const totalPower = camPower + monitorPower + otherPower;\n  const specBrightness = devices?.monitors?.[monitorSelect?.value]?.brightnessNits;\n\n  let weightedSum = 0;\n  let weightTotal = 0;\n  let count = 0;\n  const breakdown = entries.map(e => {\n    const rt = parseFloat(e.runtime);\n    if (Number.isNaN(rt)) return null;\n\n    let camFactor = 1;\n    let monitorFactor = 1;\n\n    const res = parseResolution(e.resolution);\n    if (res) camFactor *= resolutionWeight(res);\n\n    const fps = parseFramerate(e.framerate);\n    if (fps) camFactor *= fps / 24;\n\n    const wifi = (e.cameraWifi || '').toLowerCase();\n    if (wifi.includes('on')) camFactor *= 1.1;\n\n    const codec = e.codec;\n    if (codec) camFactor *= codecWeight(codec);\n\n    const entryBrightness = parseFloat(e.monitorBrightness);\n    if (!Number.isNaN(entryBrightness) && specBrightness) {\n      const ratio = entryBrightness / specBrightness;\n      if (ratio < 1) monitorFactor *= ratio;\n    }\n\n    let weight = 1;\n    if (totalPower > 0) {\n      weight =\n        (camFactor * camPower + monitorFactor * monitorPower + otherPower) /\n        totalPower;\n    }\n\n    const temp = parseFloat(e.temperature);\n    const tempMul = tempFactor(temp);\n    const adjustedRuntime = rt * tempMul;\n\n    weightedSum += adjustedRuntime * weight;\n    weightTotal += weight;\n    count++;\n\n    return {\n      temperature: tempMul,\n      resolution: res ? resolutionWeight(res) : 1,\n      framerate: fps ? fps / 24 : 1,\n      wifi: wifi.includes('on') ? 1.1 : 1,\n      codec: codec ? codecWeight(codec) : 1,\n      monitor: monitorFactor,\n      weight\n    };\n  });\n\n  const maxWeight = Math.max(...breakdown.filter(Boolean).map(b => b.weight), 0);\n  let html = '<tr>' + columns.map(c => `<th>${escapeHtml(c.label)}</th>`).join('') + '<th></th></tr>';\n  const deleteFeedbackLabel =\n    texts[currentLang]?.deleteSetupBtn ||\n    texts.en?.deleteSetupBtn ||\n    'Delete';\n  entries.forEach((entry, index) => {\n    html += '<tr>';\n    columns.forEach(c => {\n      if (c.key === 'weighting') {\n        const b = breakdown[index];\n        if (b) {\n          const percent = maxWeight ? (b.weight / maxWeight) * 100 : 0;\n          const share = b.weight * 100;\n          const tooltip =\n            `Temp \xD7${b.temperature.toFixed(2)}\\n` +\n            `Res \xD7${b.resolution.toFixed(2)}\\n` +\n            `FPS \xD7${b.framerate.toFixed(2)}\\n` +\n            `Codec \xD7${b.codec.toFixed(2)}\\n` +\n            `Wi-Fi \xD7${b.wifi.toFixed(2)}\\n` +\n            `Monitor \xD7${b.monitor.toFixed(2)}\\n` +\n            `Share ${share.toFixed(1)}%`;\n          html +=\n            `<td><div class=\"weightingRow\"><div class=\"barContainer\"><div class=\"weightBar\" style=\"width:${percent}%\" title=\"${escapeHtml(tooltip)}\"></div></div><span class=\"weightingPercent\">${share.toFixed(1)}%</span></div></td>`;\n        } else {\n          html += '<td></td>';\n        }\n      } else if (c.key === 'date') {\n        html += `<td>${escapeHtml(formatDateString(entry[c.key]))}</td>`;\n      } else {\n        html += `<td>${escapeHtml(entry[c.key] || '')}</td>`;\n      }\n    });\n    html += `<td><button data-key=\"${encodeURIComponent(currentKey)}\" data-index=\"${index}\" class=\"deleteFeedbackBtn\">${iconMarkup(ICON_GLYPHS.trash, 'btn-icon')}${escapeHtml(deleteFeedbackLabel)}</button></td>`;\n    html += '</tr>';\n  });\n  table.innerHTML = html;\n  table.classList.remove('hidden');\n  if (container) container.classList.remove('hidden');\n  table.querySelectorAll('.deleteFeedbackBtn').forEach(btn => {\n    btn.setAttribute('aria-label', deleteFeedbackLabel);\n    btn.setAttribute('title', deleteFeedbackLabel);\n    btn.addEventListener('click', () => {\n      const key = decodeURIComponent(btn.dataset.key);\n      const idx = parseInt(btn.dataset.index, 10);\n      deleteFeedbackEntry(key, idx);\n    });\n  });\n\n  if (count >= 3 && weightTotal > 0) {\n    return { runtime: weightedSum / weightTotal, count, weight: weightTotal };\n  }\n  return null;\n}\n\n// Determine differences between the default device database and the current\n// in-memory `devices` object. Only changed, added or removed entries are\n// returned so they can be shared in a generated link.\nfunction getDeviceChanges() {\n  if (!window.defaultDevices) return {};\n  const diff = {};\n  const record = (cat, name, val, sub) => {\n    if (sub) {\n      diff.fiz = diff.fiz || {};\n      diff.fiz[sub] = diff.fiz[sub] || {};\n      diff.fiz[sub][name] = val;\n    } else {\n      diff[cat] = diff[cat] || {};\n      diff[cat][name] = val;\n    }\n  };\n  const compare = (cat, defCat, curCat, sub) => {\n    Object.keys(curCat).forEach(name => {\n      const cur = curCat[name];\n      const def = defCat[name];\n      if (!def || JSON.stringify(cur) !== JSON.stringify(def)) {\n        record(cat, name, cur, sub);\n      }\n    });\n    Object.keys(defCat).forEach(name => {\n      if (!curCat[name]) record(cat, name, null, sub);\n    });\n  };\n  compare('cameras', window.defaultDevices.cameras || {}, devices.cameras || {});\n  compare('viewfinders', window.defaultDevices.viewfinders || {}, devices.viewfinders || {});\n  compare('monitors', window.defaultDevices.monitors || {}, devices.monitors || {});\n  compare('video', window.defaultDevices.video || {}, devices.video || {});\n  compare('batteries', window.defaultDevices.batteries || {}, devices.batteries || {});\n  compare('batteryHotswaps', window.defaultDevices.batteryHotswaps || {}, devices.batteryHotswaps || {});\n  ['motors', 'controllers', 'distance'].forEach(sub => {\n    const defCat = window.defaultDevices.fiz ? (window.defaultDevices.fiz[sub] || {}) : {};\n    const curCat = devices.fiz ? (devices.fiz[sub] || {}) : {};\n    compare('fiz', defCat, curCat, sub);\n    if (diff.fiz && diff.fiz[sub] && !Object.keys(diff.fiz[sub]).length) {\n      delete diff.fiz[sub];\n    }\n  });\n  if (diff.fiz && !Object.keys(diff.fiz).length) delete diff.fiz;\n  Object.keys(diff).forEach(cat => {\n    if (cat !== 'fiz' && !Object.keys(diff[cat]).length) delete diff[cat];\n  });\n  return diff;\n}\n\n// Apply a set of device changes to the current in-memory database and update\n// all related UI elements and localStorage. `changes` mirrors the structure\n// returned by getDeviceChanges().\nfunction applyDeviceChanges(changes) {\n  if (!changes || typeof changes !== 'object') return;\n\n  const applyToCategory = (target, delta) => {\n    Object.keys(delta).forEach(name => {\n      const val = delta[name];\n      if (val === null) {\n        delete target[name];\n      } else {\n        target[name] = val;\n      }\n    });\n  };\n\n  Object.keys(changes).forEach(cat => {\n    if (cat === 'fiz') {\n      Object.keys(changes.fiz || {}).forEach(sub => {\n        devices.fiz[sub] = devices.fiz[sub] || {};\n        applyToCategory(devices.fiz[sub], changes.fiz[sub]);\n      });\n    } else {\n      devices[cat] = devices[cat] || {};\n      applyToCategory(devices[cat], changes[cat]);\n    }\n  });\n\n  unifyDevices(devices);\n  storeDevices(devices);\n  refreshDeviceLists();\n\n  // Re-populate dropdowns to include any newly added devices\n  populateSelect(cameraSelect, devices.cameras, true);\n  populateMonitorSelect();\n  populateSelect(videoSelect, devices.video, true);\n  motorSelects.forEach(sel => populateSelect(sel, devices.fiz.motors, true));\n  controllerSelects.forEach(sel => populateSelect(sel, devices.fiz.controllers, true));\n  populateSelect(distanceSelect, devices.fiz.distance, true);\n  populateSelect(batterySelect, devices.batteries, true);\n\n  updateFizConnectorOptions();\n  updateMotorConnectorOptions();\n  updateControllerConnectorOptions();\n  updateControllerPowerOptions();\n  updateControllerBatteryOptions();\n  updateControllerConnectivityOptions();\n  updateDistanceConnectionOptions();\n  updateDistanceMethodOptions();\n  updateDistanceDisplayOptions();\n}\n\nfunction renderSetupDiagram() {\n  if (!setupDiagramContainer) return;\n\n  const isTouchDevice = (navigator.maxTouchPoints || 0) > 0;\n\n  const camName = cameraSelect.value;\n  const cam = devices.cameras[camName];\n  const monitorName = monitorSelect.value;\n  const monitor = devices.monitors[monitorName];\n  const videoName = videoSelect.value;\n  const video = devices.video[videoName];\n  const batteryName = batterySelect.value;\n\n  const distanceName = distanceSelect.value;\n\n  let motors = motorSelects.map(sel => sel.value).filter(v => v && v !== 'None');\n  motors.sort((a, b) => motorPriority(a) - motorPriority(b));\n  const internalIdx = motors.findIndex(name => devices.fiz?.motors?.[name]?.internalController);\n  const hasInternalMotor = internalIdx !== -1;\n  if (hasInternalMotor && internalIdx > 0) {\n    const [m] = motors.splice(internalIdx, 1);\n    motors.unshift(m);\n  }\n  let controllers = controllerSelects.map(sel => sel.value).filter(v => v && v !== 'None');\n  controllers.sort((a, b) => controllerPriority(a) - controllerPriority(b));\n\n  const inlineControllers = controllers;\n\n  const nodes = [];\n  const pos = {};\n  const nodeMap = {};\n  const step = 300; // extra spacing for edge labels\n  const VIDEO_LABEL_SPACING = 10;\n  const EDGE_LABEL_GAP = 12;\n  const EDGE_LABEL_VERTICAL_GAP = 8;\n  const EDGE_ROUTE_LABEL_GAP = 10;\n  const baseY = 220;\n  let x = 80;\n\n  if (batteryName && batteryName !== 'None') {\n    let batteryLabel = batteryName;\n    const battMount = devices.batteries[batteryName]?.mount_type;\n    if (cam && battMount && cam.power?.batteryPlateSupport?.some(bp => bp.type === battMount && bp.mount === 'native')) {\n      batteryLabel += ` on native ${battMount} plate via Pins`;\n    }\n    pos.battery = { x, y: baseY, label: batteryLabel };\n    nodes.push('battery');\n    nodeMap.battery = { category: 'batteries', name: batteryName };\n    x += step;\n  }\n\n  if (camName && camName !== 'None') {\n    pos.camera = { x, y: baseY, label: camName };\n    nodes.push('camera');\n    nodeMap.camera = { category: 'cameras', name: camName };\n    x += step;\n  }\n\n  const controllerIds = controllers.map((_, idx) => `controller${idx}`);\n  const motorIds = motors.map((_, idx) => `motor${idx}`);\n\n  // Precompute maps for fast lookup instead of repeated indexOf calls\n  const controllerNameMap = new Map();\n  controllerIds.forEach((id, idx) => {\n    controllerNameMap.set(id, inlineControllers[idx] || controllers[idx]);\n  });\n  const motorNameMap = new Map();\n  motorIds.forEach((id, idx) => {\n    motorNameMap.set(id, motors[idx]);\n  });\n\n  const hasMainCtrl = controllers.some(n => controllerPriority(n) === 0);\n  let useMotorFirst = (!hasMainCtrl && hasInternalMotor) ||\n    (!controllerIds.length && motorIds.length && motorPriority(motors[0]) === 0);\n\n  const addNode = (id, category, label) => {\n    pos[id] = { x, y: baseY, label };\n    nodes.push(id);\n    nodeMap[id] = { category, name: label };\n    x += step;\n  };\n\n  if (useMotorFirst && motorIds.length) {\n    addNode(motorIds[0], 'fiz.motors', motors[0]);\n    controllerIds.forEach((id, idx) => {\n      addNode(id, 'fiz.controllers', inlineControllers[idx]);\n    });\n    motorIds.slice(1).forEach((id, idx) => {\n      addNode(id, 'fiz.motors', motors[idx + 1]);\n    });\n  } else {\n    controllerIds.forEach((id, idx) => {\n      addNode(id, 'fiz.controllers', inlineControllers[idx]);\n    });\n    motorIds.forEach((id, idx) => {\n      addNode(id, 'fiz.motors', motors[idx]);\n    });\n  }\n\n  if (monitorName && monitorName !== 'None') {\n    pos.monitor = { x: pos.camera ? pos.camera.x : 60, y: baseY - step, label: monitorName };\n    nodes.push('monitor');\n    nodeMap.monitor = { category: 'monitors', name: monitorName };\n  }\n  if (videoName && videoName !== 'None') {\n    pos.video = { x: pos.camera ? pos.camera.x : 60, y: baseY + step, label: videoName };\n    nodes.push('video');\n    nodeMap.video = { category: 'video', name: videoName };\n  }\n\n  let inlineDistance = false;\n  let dedicatedDistance = false;\n  if (distanceName && distanceName !== 'None') {\n    const attach = inlineControllers.length ? controllerIds[0] : motorIds[0];\n    if (attach) {\n      const arriDevices = [...inlineControllers, ...motors].some(n => isArri(n));\n      const hasDedicatedPort = inlineControllers.some(n => /RIA-1/i.test(n) || /UMC-4/i.test(n));\n      dedicatedDistance = hasDedicatedPort && arriDevices;\n      inlineDistance = arriDevices && !hasDedicatedPort && inlineControllers.length;\n      if (inlineDistance && motorIds.length) {\n        const nextId = motorIds[0];\n        pos.distance = { x: (pos[attach].x + pos[nextId].x) / 2, y: baseY - step, label: distanceName };\n      } else {\n        pos.distance = { x: pos[attach].x, y: baseY - step, label: distanceName };\n      }\n      nodes.push('distance');\n    nodeMap.distance = { category: 'fiz.distance', name: distanceName };\n    }\n  }\n\n  // Apply any manually moved node positions and cleanup\n  Object.keys(manualPositions).forEach(id => { if (!pos[id]) delete manualPositions[id]; });\n  Object.entries(pos).forEach(([id, p]) => {\n    if (manualPositions[id]) {\n      p.x = manualPositions[id].x;\n      p.y = manualPositions[id].y;\n    }\n  });\n\n  let firstFizId;\n  if (hasInternalMotor && motorIds.length && !hasMainCtrl) {\n    firstFizId = motorIds[0];\n  } else {\n    firstFizId = controllerIds.length ? controllerIds[0] : motorIds[0];\n  }\n\n  // Determine node heights and widths based on label length so text fits inside\n  const DEFAULT_NODE_H = 120;\n  const DEFAULT_NODE_W = 120;\n  const nodeHeights = {};\n  const nodeWidths = {};\n  const diagramLabelFontSize = 'var(--font-size-diagram-label, 11px)';\n  const diagramTextFontSize = 'var(--font-size-diagram-text, 13px)';\n  const DIAGRAM_LABEL_LINE_HEIGHT = 13;\n  const DIAGRAM_ICON_TEXT_GAP = 8;\n  const DEFAULT_DIAGRAM_ICON_SIZE = 24;\n\n  nodes.forEach(id => {\n    const label = pos[id].label || id;\n    const lines = wrapLabel(label);\n    // Extra space if an icon is shown\n    const hasIcon = diagramIcons[id] || id.startsWith('controller') || id.startsWith('motor');\n    nodeHeights[id] = Math.max(\n      DEFAULT_NODE_H,\n      lines.length * DIAGRAM_LABEL_LINE_HEIGHT + (hasIcon ? 30 : 20)\n    );\n    const longest = lines.reduce((m, l) => Math.max(m, l.length), 0);\n    nodeWidths[id] = Math.max(DEFAULT_NODE_W, longest * 9 + 20);\n  });\n  const NODE_W = Math.max(...Object.values(nodeWidths), DEFAULT_NODE_W);\n  const NODE_H = Math.max(...Object.values(nodeHeights), DEFAULT_NODE_H);\n  const getNodeHeight = id => nodeHeights[id] || NODE_H;\n\n  let viewWidth;\n\n  let chain = [];\n  const edges = [];\n  const usedConns = {};\n  const markUsed = (id, side) => { usedConns[`${id}|${side}`] = true; };\n  const isUsed = (id, side) => usedConns[`${id}|${side}`];\n  const pushEdge = (edge, type) => {\n    if (!edge.fromSide || !edge.toSide) {\n      const pair = closestConnectorPair(edge.from, edge.to, usedConns);\n      if (pair) {\n        if (!edge.fromSide) edge.fromSide = pair.fromSide;\n        if (!edge.toSide) edge.toSide = pair.toSide;\n      }\n    } else {\n      if (isUsed(edge.from, edge.fromSide) || isUsed(edge.to, edge.toSide)) return;\n    }\n    markUsed(edge.from, edge.fromSide);\n    markUsed(edge.to, edge.toSide);\n    edges.push({ ...edge, type });\n  };\n  const battMount = devices.batteries[batteryName]?.mount_type;\n  if (cam && batteryName && batteryName !== 'None') {\n    const plateType = getSelectedPlate();\n    const nativePlate = plateType && isSelectedPlateNative(camName);\n    const camPort = firstPowerInputType(cam);\n    const inLabel = camPort || plateType;\n    const label = nativePlate ? '' : formatConnLabel(battMount, inLabel);\n    pushEdge({ from: 'battery', to: 'camera', label, fromSide: 'right', toSide: 'left' }, 'power');\n  }\n  if (monitor && firstPowerInputType(monitor)) {\n    const mPort = firstPowerInputType(monitor);\n    if (batteryName && batteryName !== 'None') {\n      pushEdge({ from: 'battery', to: 'monitor', label: formatConnLabel(battMount, mPort), fromSide: 'top', toSide: 'left' }, 'power');\n    }\n  }\n  if (video && firstPowerInputType(video)) {\n    const pPort = firstPowerInputType(video);\n    if (batteryName && batteryName !== 'None') {\n      pushEdge({ from: 'battery', to: 'video', label: formatConnLabel(battMount, pPort), fromSide: 'bottom', toSide: 'left' }, 'power');\n    }\n  }\n  if (cam && cam.videoOutputs?.length) {\n    const camOut = cam.videoOutputs[0].type;\n    const monInObj = monitor && (monitor.video?.inputs?.[0] || monitor.videoInputs?.[0]);\n    const vidInObj = video && (video.videoInputs?.[0] || (video.video ? video.video.inputs[0] : null));\n    if (monitor && monInObj) {\n      const monIn = monInObj.portType || monInObj.type || monInObj;\n      pushEdge({ from: 'camera', to: 'monitor', label: connectionLabel(camOut, monIn), fromSide: 'top', toSide: 'bottom', labelSpacing: VIDEO_LABEL_SPACING }, 'video');\n    }\n    if (video && vidInObj) {\n      const vidIn = vidInObj.portType || vidInObj.type || vidInObj;\n      pushEdge({ from: 'camera', to: 'video', label: connectionLabel(camOut, vidIn), fromSide: 'bottom', toSide: 'top', labelSpacing: VIDEO_LABEL_SPACING }, 'video');\n    }\n  }\n  useMotorFirst = (!hasMainCtrl && hasInternalMotor) ||\n    (!controllerIds.length && motorIds.length && motorPriority(motors[0]) === 0);\n  const distanceSelected = distanceName && distanceName !== 'None';\n  const distanceInChain = distanceSelected && !dedicatedDistance;\n\n  let firstController = false;\n  let firstMotor = false;\n\n  if (useMotorFirst && motorIds.length) {\n    chain.push(motorIds[0]);\n    firstMotor = true;\n  } else if (controllerIds.length) {\n    chain.push(controllerIds[0]);\n    firstController = true;\n  } else if (motorIds.length) {\n    chain.push(motorIds[0]);\n    firstMotor = true;\n  }\n\n  if (distanceInChain) chain.push('distance');\n\n  if (controllerIds.length) chain = chain.concat(controllerIds.slice(firstController ? 1 : 0));\n  if (motorIds.length) chain = chain.concat(motorIds.slice(firstMotor ? 1 : 0));\n\n  if (cam && chain.length) {\n    let first = chain[0];\n    if (first === 'distance' && chain.length > 1 && (controllerIds.length || hasInternalMotor)) {\n      first = chain[1];\n    }\n    let firstName = null;\n    if (first.startsWith('controller')) {\n      firstName = controllerNameMap.get(first);\n    } else if (first.startsWith('motor')) {\n      firstName = motorNameMap.get(first);\n    }\n    const port = first === 'distance' ? 'LBUS' : controllerCamPort(firstName);\n    const camPort = cameraFizPort(camName, port, firstName);\n    pushEdge({ from: 'camera', to: first, label: formatConnLabel(camPort, port), noArrow: true }, 'fiz');\n  } else if (motorIds.length && cam) {\n    const camPort = cameraFizPort(camName, motorFizPort(motors[0]), motors[0]);\n    pushEdge({ from: 'camera', to: motorIds[0], label: formatConnLabel(camPort, motorFizPort(motors[0])), noArrow: true }, 'fiz');\n  }\n\n  for (let i = 0; i < chain.length - 1; i++) {\n    const a = chain[i];\n    const b = chain[i + 1];\n    let fromName = null, toName = null;\n    if (a.startsWith('controller')) fromName = controllerNameMap.get(a);\n    else if (a.startsWith('motor')) fromName = motorNameMap.get(a);\n    if (b.startsWith('controller')) toName = controllerNameMap.get(b);\n    else if (b.startsWith('motor')) toName = motorNameMap.get(b);\n    pushEdge({ from: a, to: b, label: formatConnLabel(fizPort(fromName), fizPort(toName)), noArrow: true }, 'fiz');\n  }\n\n\n\n  if (dedicatedDistance && controllerIds.length && distanceSelected) {\n    const ctrlName = inlineControllers[0] || controllers[0];\n    const distPort = controllerDistancePort(ctrlName);\n    const portLabel = formatConnLabel(fizPort(ctrlName), distPort);\n    pushEdge({ from: controllerIds[0], to: 'distance', label: portLabel, noArrow: true, toSide: 'bottom-right' }, 'fiz');\n  }\n\n\n  const fizList = [];\n  controllerIds.forEach((id, idx) => {\n    fizList.push({ id, name: inlineControllers[idx] || controllers[idx] });\n  });\n  motorIds.forEach((id, idx) => {\n    fizList.push({ id, name: motors[idx] });\n  });\n\n  const isMainCtrl = name => /RIA-1/i.test(name) || /UMC-4/i.test(name) || /cforce.*rf/i.test(name);\n  let powerTarget = null;\n  const main = fizList.find(d => isMainCtrl(d.name));\n  if (main) {\n    powerTarget = main;\n  } else {\n    powerTarget = fizList.find(d => fizNeedsPower(d.name));\n  }\n\n  if (powerTarget && fizNeedsPower(powerTarget.name)) {\n    const { id: fizId, name } = powerTarget;\n    const powerSrc = batteryName && batteryName !== 'None' ? 'battery' : null;\n    const label = formatConnLabel('D-Tap', fizPowerPort(name));\n    const skipBatt = isArri(camName) && isArriOrCmotion(name);\n    if (powerSrc && !skipBatt) {\n      pushEdge({\n        from: powerSrc,\n        to: fizId,\n        label,\n        fromSide: 'bottom-left',\n        toSide: 'bottom',\n        route: 'down-right-up'\n      }, 'power');\n    }\n  }\n  if (nodes.length === 0) {\n    setupDiagramContainer.innerHTML = `<p class=\"diagram-placeholder\">${texts[currentLang].setupDiagramPlaceholder}</p>`;\n    return;\n  }\n\n  const xs = Object.values(pos).map(p => p.x);\n  const minX = Math.min(...xs);\n  const maxX = Math.max(...xs);\n  const contentWidth = maxX - minX;\n  viewWidth = Math.max(500, contentWidth + NODE_W);\n  let shiftX = 0;\n  if (Object.keys(manualPositions).length === 0) {\n    shiftX = viewWidth / 2 - (minX + maxX) / 2;\n    Object.values(pos).forEach(p => { p.x += shiftX; });\n  }\n\n  const ys = Object.values(pos).map(p => p.y);\n  const minY = Math.min(...ys);\n  const maxY = Math.max(...ys);\n  const viewHeight = (maxY - minY) + NODE_H + 120;\n\n  function computePath(fromId, toId, labelSpacing = 0, opts = {}) {\n    const from = connectorPos(fromId, opts.fromSide);\n    const to = connectorPos(toId, opts.toSide);\n    let path, lx, ly, angle = 0;\n\n    if (opts.route === 'down-right-up') {\n      const bottomY = maxY + NODE_H;\n      path = `M ${from.x} ${from.y} V ${bottomY} H ${to.x} V ${to.y}`;\n      lx = (from.x + to.x) / 2;\n      ly = bottomY - EDGE_ROUTE_LABEL_GAP - labelSpacing;\n    } else {\n      path = `M ${from.x} ${from.y} L ${to.x} ${to.y}`;\n      const dx = to.x - from.x;\n      const dy = to.y - from.y;\n      angle = Math.atan2(dy, dx) * 180 / Math.PI;\n      const midX = (from.x + to.x) / 2;\n      const midY = (from.y + to.y) / 2;\n      const len = Math.hypot(dx, dy) || 1;\n      const baseGap = Math.abs(dx) < Math.abs(dy) ? EDGE_LABEL_VERTICAL_GAP : EDGE_LABEL_GAP;\n      const off = baseGap + labelSpacing;\n      const perpX = (dy / len) * off;\n      const perpY = (-dx / len) * off;\n      lx = midX + perpX;\n      ly = midY + perpY;\n    }\n\n    return { path, labelX: lx, labelY: ly, angle };\n  }\n\n  const EDGE_LABEL_WRAP = 18;\n\n  function wrapLabel(text, maxLen = 16) {\n    const words = text.split(' ');\n    const lines = [];\n    let line = '';\n    words.forEach(w => {\n      if ((line + ' ' + w).trim().length > maxLen && line) {\n        lines.push(line.trim());\n        line = w;\n      } else {\n        line += ` ${w}`;\n      }\n    });\n    if (line.trim()) lines.push(line.trim());\n    return lines;\n  }\n\n  let svg = `<svg viewBox=\"0 ${minY - NODE_H/2 - 20} ${viewWidth} ${viewHeight}\" xmlns=\"http://www.w3.org/2000/svg\">`;\n  svg += `<defs>\n    <linearGradient id=\"firstFizGrad\" x1=\"0%\" y1=\"0%\" x2=\"0%\" y2=\"100%\">\n      <stop offset=\"0%\" stop-color=\"#090\" />\n      <stop offset=\"100%\" stop-color=\"#d33\" />\n    </linearGradient>\n  </defs>`;\n  svg += `<g id=\"diagramRoot\">`;\n\n  edges.forEach(e => {\n    if (!pos[e.from] || !pos[e.to]) return;\n    const { path, labelX, labelY, angle } = computePath(e.from, e.to, e.labelSpacing || 0, e);\n    if (!path) return;\n    const cls = e.type ? `edge-path ${e.type}` : 'edge-path';\n    svg += `<path class=\"${cls}\" d=\"${path}\" />`;\n    if (e.label) {\n      const rot = ` transform=\"rotate(${angle} ${labelX} ${labelY})\"`;\n      const lines = wrapLabel(e.label, EDGE_LABEL_WRAP);\n      if (lines.length <= 1) {\n        svg += `<text class=\"edge-label\" x=\"${labelX}\" y=\"${labelY}\" text-anchor=\"middle\" dominant-baseline=\"middle\"${rot}>${escapeHtml(e.label)}</text>`;\n      } else {\n        const lineHeight = 12;\n        const startDy = -((lines.length - 1) * lineHeight) / 2;\n        svg += `<text class=\"edge-label\" x=\"${labelX}\" y=\"${labelY}\" text-anchor=\"middle\" dominant-baseline=\"middle\"${rot}>`;\n        lines.forEach((line, i) => {\n          const dy = i === 0 ? startDy : lineHeight;\n          svg += `<tspan x=\"${labelX}\" dy=\"${dy}\">${escapeHtml(line)}</tspan>`;\n        });\n        svg += `</text>`;\n      }\n    }\n  });\n\n\n  function connectorsFor(id) {\n    switch (id) {\n      case 'battery':\n        return [\n          { side: 'top', color: 'red' },\n          { side: 'right', color: 'red' },\n          { side: 'bottom', color: 'red' },\n          { side: 'bottom-left', color: 'red' }\n        ];\n      case 'monitor':\n        return [\n          { side: 'left', color: 'red' },\n          { side: 'bottom', color: 'blue' }\n        ];\n      case 'video':\n        return [\n          { side: 'left', color: 'red' },\n          { side: 'top', color: 'blue' }\n        ];\n      case 'camera':\n        return [\n          { side: 'left', color: 'red' },\n          { side: 'top', color: 'blue' },\n          { side: 'bottom', color: 'blue' },\n          { side: 'right', color: 'green' }\n        ];\n      case 'distance':\n        return [\n          { side: 'bottom', color: 'green' },\n          { side: 'bottom-right', color: 'green' }\n        ];\n      default:\n        if (id.startsWith('controller') || id.startsWith('motor')) {\n          if (firstFizId && id === firstFizId) {\n            return [\n              { side: 'top', color: 'green' },\n              { side: 'left', color: 'green' },\n              { side: 'right', color: 'green' },\n              { side: 'bottom', color: 'red' }\n            ];\n          }\n          return [\n            { side: 'left', color: 'green' },\n            { side: 'right', color: 'green' }\n          ];\n        }\n    }\n    return [];\n  }\n\n  function connectorPos(nodeId, side) {\n    const p = pos[nodeId];\n    if (!p) return { x: 0, y: 0 };\n    const h = getNodeHeight(nodeId);\n    switch (side) {\n      case 'top':\n        return { x: p.x, y: p.y - h / 2 };\n      case 'bottom':\n        return { x: p.x, y: p.y + h / 2 };\n      case 'bottom-left':\n        return { x: p.x - NODE_W / 2 + NODE_W / 3, y: p.y + h / 2 };\n      case 'bottom-right':\n        return { x: p.x + NODE_W / 2 - NODE_W / 3, y: p.y + h / 2 };\n      case 'left':\n        return { x: p.x - NODE_W / 2, y: p.y };\n      case 'right':\n        return { x: p.x + NODE_W / 2, y: p.y };\n      default:\n        return { x: p.x, y: p.y };\n    }\n  }\n\n  function closestConnectorPair(idA, idB, used = {}) {\n    const aConns = connectorsFor(idA);\n    const bConns = connectorsFor(idB);\n    let best = null;\n    let bestDist = Infinity;\n    aConns.forEach(ac => {\n      if (used[`${idA}|${ac.side}`]) return;\n      const ap = connectorPos(idA, ac.side);\n      bConns.forEach(bc => {\n        if (ac.color !== bc.color) return;\n        if (used[`${idB}|${bc.side}`]) return;\n        const bp = connectorPos(idB, bc.side);\n        const d = Math.hypot(ap.x - bp.x, ap.y - bp.y);\n        if (d < bestDist) {\n          bestDist = d;\n          best = { fromSide: ac.side, toSide: bc.side };\n        }\n      });\n    });\n    return best;\n  }\n\n  nodes.forEach(id => {\n    const p = pos[id];\n    if (!p) return;\n    const h = getNodeHeight(id);\n    const nodeCls = id === firstFizId ? 'diagram-node first-fiz' : 'diagram-node';\n    const rectCls = id === firstFizId ? 'node-box first-fiz' : 'node-box';\n    svg += `<g class=\"${nodeCls}\" data-node=\"${id}\">`;\n    svg += `<rect class=\"${rectCls}\" x=\"${p.x - NODE_W/2}\" y=\"${p.y - h/2}\" width=\"${NODE_W}\" height=\"${h}\" rx=\"4\" ry=\"4\" />`;\n    if (id === firstFizId) {\n      const xLeft = p.x - NODE_W / 2;\n      const yBottom = p.y + h / 2;\n      const r = 4;\n      const highlight = `M ${xLeft} ${p.y} L ${xLeft} ${yBottom - r} A ${r} ${r} 0 0 1 ${xLeft + r} ${yBottom} L ${p.x} ${yBottom}`;\n      svg += `<path class=\"first-fiz-highlight\" d=\"${highlight}\" />`;\n    }\n\n    const conns = connectorsFor(id);\n    conns.forEach(c => {\n      let cx = p.x, cy = p.y;\n      if (c.side === 'top') { cx = p.x; cy = p.y - h / 2; }\n      else if (c.side === 'bottom') { cx = p.x; cy = p.y + h / 2; }\n      else if (c.side === 'bottom-left') { cx = p.x - NODE_W / 2 + NODE_W / 3; cy = p.y + h / 2; }\n      else if (c.side === 'bottom-right') { cx = p.x + NODE_W / 2 - NODE_W / 3; cy = p.y + h / 2; }\n      else if (c.side === 'left') { cx = p.x - NODE_W / 2; cy = p.y; }\n      else if (c.side === 'right') { cx = p.x + NODE_W / 2; cy = p.y; }\n      svg += `<circle class=\"conn ${c.color}\" cx=\"${cx}\" cy=\"${cy}\" r=\"4\" />`;\n    });\n\n    let icon = diagramIcons[id];\n    if (!icon) {\n      if (id.startsWith('motor')) {\n        icon = diagramIcons.motors;\n      } else if (id.startsWith('controller')) {\n        const name = (nodeMap[id]?.name || '').toLowerCase();\n        if (/handle|grip/.test(name)) icon = diagramIcons.handle;\n        else icon = diagramIcons.controllers;\n      } else if (id === 'distance') {\n        icon = diagramIcons.distance;\n      }\n    }\n\n    const lines = wrapLabel(p.label || id);\n    const resolvedIcon = icon ? resolveIconGlyph(icon) : null;\n    const hasIconGlyph = Boolean(resolvedIcon && (resolvedIcon.markup || resolvedIcon.char));\n    const iconSize = hasIconGlyph && Number.isFinite(resolvedIcon.size)\n      ? resolvedIcon.size\n      : DEFAULT_DIAGRAM_ICON_SIZE;\n    const iconHeight = hasIconGlyph ? iconSize : 0;\n    const textLineCount = lines.length;\n    const textHeight = textLineCount ? textLineCount * DIAGRAM_LABEL_LINE_HEIGHT : 0;\n    const iconGap = hasIconGlyph && textLineCount ? DIAGRAM_ICON_TEXT_GAP : 0;\n    const contentHeight = iconHeight + iconGap + textHeight;\n    const contentTop = p.y - contentHeight / 2;\n    const centerX = formatSvgCoordinate(p.x);\n\n    if (hasIconGlyph) {\n      const iconCenterY = contentTop + iconHeight / 2;\n      if (resolvedIcon.markup) {\n        const positioned = positionSvgMarkup(\n          ensureSvgHasAriaHidden(resolvedIcon.markup),\n          p.x,\n          iconCenterY,\n          iconSize\n        );\n        if (positioned.markup) {\n          const wrapperClasses = ['node-icon-svg'];\n          if (resolvedIcon.className) wrapperClasses.push(resolvedIcon.className);\n          svg += `<g class=\"${wrapperClasses.join(' ')}\" transform=\"translate(${positioned.x}, ${positioned.y})\">${positioned.markup}</g>`;\n        }\n      } else if (resolvedIcon.char) {\n        const fontAttr = ` data-icon-font=\"${resolvedIcon.font}\"`;\n        svg += `<text class=\"node-icon\"${fontAttr} x=\"${centerX}\" y=\"${formatSvgCoordinate(iconCenterY)}\" text-anchor=\"middle\" dominant-baseline=\"middle\">${resolvedIcon.char}</text>`;\n      }\n    }\n\n    if (textLineCount) {\n      const textTop = contentTop + iconHeight + iconGap;\n      const textY = formatSvgCoordinate(textTop);\n      const fontSize = hasIconGlyph ? diagramLabelFontSize : diagramTextFontSize;\n      svg += `<text x=\"${centerX}\" y=\"${textY}\" text-anchor=\"middle\" dominant-baseline=\"hanging\" style=\"font-size: ${fontSize};\">`;\n      lines.forEach((line, i) => {\n        const dyAttr = i === 0 ? '' : ` dy=\"${DIAGRAM_LABEL_LINE_HEIGHT}\"`;\n        svg += `<tspan x=\"${centerX}\"${dyAttr}>${escapeHtml(line)}</tspan>`;\n      });\n      svg += `</text>`;\n    }\n    svg += `</g>`;\n  });\n\n  svg += '</g></svg>';\n  let popup = document.getElementById('diagramPopup');\n  if (!popup) {\n    popup = document.createElement('div');\n    popup.id = 'diagramPopup';\n    popup.className = 'diagram-popup';\n  }\n  setupDiagramContainer.innerHTML = '';\n  setupDiagramContainer.appendChild(popup);\n  setupDiagramContainer.insertAdjacentHTML('beforeend', svg);\n\n  const svgEl = setupDiagramContainer.querySelector('svg');\n  if (svgEl) {\n    svgEl.style.width = '100%';\n    if (!isTouchDevice) {\n      const bodyFontSize = parseFloat(getComputedStyle(document.body).fontSize) || 16;\n      let diagramFontSizePx = Number.NaN;\n      if (document.body) {\n        const measureEl = document.createElement('span');\n        measureEl.style.position = 'absolute';\n        measureEl.style.visibility = 'hidden';\n        measureEl.style.fontSize = 'var(--font-size-diagram-text)';\n        measureEl.textContent = 'M';\n        document.body.appendChild(measureEl);\n        diagramFontSizePx = parseFloat(getComputedStyle(measureEl).fontSize);\n        measureEl.remove();\n      }\n      const DEFAULT_MAX_NODE_FONT = 13; // fallback when diagram font size cannot be measured\n      const referenceFontSize = Number.isFinite(diagramFontSizePx) && diagramFontSizePx > 0\n        ? diagramFontSizePx\n        : DEFAULT_MAX_NODE_FONT;\n      const maxAutoScale = bodyFontSize / referenceFontSize;\n      svgEl.style.maxWidth = `${viewWidth * maxAutoScale}px`;\n    }\n  }\n\n  lastDiagramPositions = JSON.parse(JSON.stringify(pos));\n\n  attachDiagramPopups(nodeMap);\n\n  enableDiagramInteractions();\n\n}\n\nfunction attachDiagramPopups(map) {\n  if (!setupDiagramContainer) return;\n  const popup = document.getElementById('diagramPopup');\n  if (!popup) return;\n  popup.style.display = 'none';\n  const isTouchDevice = (navigator.maxTouchPoints || 0) > 0;\n\n  setupDiagramContainer.querySelectorAll('.diagram-node').forEach(node => {\n    const id = node.getAttribute('data-node');\n    const info = map[id];\n    if (!info) return;\n    let deviceData;\n    if (info.category === 'fiz.controllers') {\n      deviceData = devices.fiz?.controllers?.[info.name];\n    } else if (info.category === 'fiz.motors') {\n      deviceData = devices.fiz?.motors?.[info.name];\n    } else if (info.category === 'fiz.distance') {\n      deviceData = devices.fiz?.distance?.[info.name];\n    } else {\n      deviceData = devices[info.category]?.[info.name];\n    }\n    const connectors = deviceData ? generateConnectorSummary(deviceData) : '';\n    const infoHtml =\n      (deviceData && deviceData.latencyMs ?\n        `<div class=\"info-box video-conn\"><strong>Latency:</strong> ${escapeHtml(String(deviceData.latencyMs))}</div>` : '') +\n      (deviceData && deviceData.frequency ?\n        `<div class=\"info-box video-conn\"><strong>Frequency:</strong> ${escapeHtml(String(deviceData.frequency))}</div>` : '');\n    const html = `<strong>${escapeHtml(info.name)}</strong>` +\n      connectors + infoHtml;\n\n    const show = e => {\n      e.stopPropagation();\n      const pointer = e.touches && e.touches[0] ? e.touches[0] : e;\n      popup.innerHTML = html;\n      popup.style.display = 'block';\n\n      const rect = setupDiagramContainer.getBoundingClientRect();\n      const relX = pointer.clientX - rect.left;\n      const relY = pointer.clientY - rect.top;\n      const offset = 10;\n      const popupWidth = popup.offsetWidth;\n\n      // Open the popup to the left if it would otherwise overflow the container\n      let left = relX + offset;\n      if (relX + popupWidth + offset > rect.width) {\n        left = Math.max(0, relX - popupWidth - offset);\n      }\n\n      popup.style.left = `${left}px`;\n      popup.style.top = `${relY + offset}px`;\n    };\n    const hide = () => { popup.style.display = 'none'; };\n    if (isTouchDevice) {\n      node.addEventListener('touchstart', show);\n      node.addEventListener('click', show);\n    } else {\n      node.addEventListener('mousemove', show);\n      node.addEventListener('mouseout', hide);\n      node.addEventListener('click', show);\n    }\n  });\n\n  if (!setupDiagramContainer.dataset.popupOutsideListeners) {\n    const hideOnOutside = e => {\n      if (!e.target.closest('.diagram-node')) popup.style.display = 'none';\n    };\n    if (isTouchDevice) {\n      setupDiagramContainer.addEventListener('touchstart', hideOnOutside);\n    } else {\n      setupDiagramContainer.addEventListener('click', hideOnOutside);\n    }\n    setupDiagramContainer.dataset.popupOutsideListeners = 'true';\n  }\n}\n\nfunction enableDiagramInteractions() {\n  if (!setupDiagramContainer) return;\n  const svg = setupDiagramContainer.querySelector('svg');\n  if (!svg) return;\n\n  if (cleanupDiagramInteractions) cleanupDiagramInteractions();\n\n  const root = svg.querySelector('#diagramRoot') || svg;\n  const isTouchDevice = (navigator.maxTouchPoints || 0) > 0;\n  const MAX_SCALE = isTouchDevice ? Infinity : 3;\n  const INITIAL_SCALE = 0.9;\n  let pan = { x: 0, y: 0 };\n  let scale = INITIAL_SCALE;\n  let panning = false;\n  let panStart = { x: 0, y: 0 };\n  const getPos = e => {\n    if (e.touches && e.touches[0]) return { x: e.touches[0].clientX, y: e.touches[0].clientY };\n    if (e.changedTouches && e.changedTouches[0]) return { x: e.changedTouches[0].clientX, y: e.changedTouches[0].clientY };\n    return { x: e.clientX, y: e.clientY };\n  };\n  const apply = () => {\n    if (scale > MAX_SCALE) scale = MAX_SCALE;\n    root.setAttribute('transform', `translate(${pan.x},${pan.y}) scale(${scale})`);\n  };\n  if (zoomInBtn) {\n    zoomInBtn.onclick = () => {\n      scale *= 1.1;\n      apply();\n    };\n  }\n  if (zoomOutBtn) {\n    zoomOutBtn.onclick = () => {\n      scale *= 0.9;\n      apply();\n    };\n  }\n  if (resetViewBtn) {\n    resetViewBtn.onclick = () => {\n      pan = { x: 0, y: 0 };\n      scale = INITIAL_SCALE;\n      apply();\n      manualPositions = {};\n      renderSetupDiagram();\n    };\n  }\n  const onSvgMouseDown = e => {\n    if (e.target.closest('.diagram-node')) return;\n    const pos = getPos(e);\n    panning = true;\n    panStart = { x: pos.x - pan.x, y: pos.y - pan.y };\n    if (e.touches) e.preventDefault();\n  };\n  const onPanMove = e => {\n    if (!panning) return;\n    const pos = getPos(e);\n    pan.x = pos.x - panStart.x;\n    pan.y = pos.y - panStart.y;\n    apply();\n    if (e.touches) e.preventDefault();\n  };\n  const stopPanning = () => { panning = false; };\n\n  let dragId = null;\n  let dragStart = null;\n  let dragNode = null;\n  const onDragStart = e => {\n    const node = e.target.closest('.diagram-node');\n    if (!node) return;\n    dragId = node.getAttribute('data-node');\n    dragNode = node;\n    const pos = getPos(e);\n    dragStart = { x: pos.x, y: pos.y };\n    if (e.touches) e.preventDefault();\n    e.stopPropagation();\n  };\n  const onDragMove = e => {\n    if (!dragId) return;\n    const start = lastDiagramPositions[dragId];\n    if (!start) return;\n    const pos = getPos(e);\n    const dx = (pos.x - dragStart.x) / scale;\n    const dy = (pos.y - dragStart.y) / scale;\n    let newX = start.x + dx;\n    let newY = start.y + dy;\n    if (gridSnap) {\n      const g = 20 / scale;\n      newX = Math.round(newX / g) * g;\n      newY = Math.round(newY / g) * g;\n    }\n    const tx = newX - start.x;\n    const ty = newY - start.y;\n    if (dragNode) dragNode.setAttribute('transform', `translate(${tx},${ty})`);\n    if (e.touches) e.preventDefault();\n  };\n  const onDragEnd = e => {\n    if (!dragId) return;\n    const start = lastDiagramPositions[dragId];\n    if (start) {\n      const pos = getPos(e);\n      const dx = (pos.x - dragStart.x) / scale;\n      const dy = (pos.y - dragStart.y) / scale;\n      let newX = start.x + dx;\n      let newY = start.y + dy;\n      if (gridSnap) {\n        const g = 20 / scale;\n        newX = Math.round(newX / g) * g;\n        newY = Math.round(newY / g) * g;\n      }\n      manualPositions[dragId] = { x: newX, y: newY };\n    }\n    dragId = null;\n    dragNode = null;\n    renderSetupDiagram();\n    if (e.touches) e.preventDefault();\n  };\n\n  svg.addEventListener('mousedown', onSvgMouseDown);\n  svg.addEventListener('touchstart', onSvgMouseDown, { passive: false });\n  window.addEventListener('mousemove', onPanMove);\n  window.addEventListener('touchmove', onPanMove, { passive: false });\n  window.addEventListener('mouseup', stopPanning);\n  window.addEventListener('touchend', stopPanning);\n  svg.addEventListener('mousedown', onDragStart);\n  svg.addEventListener('touchstart', onDragStart, { passive: false });\n  window.addEventListener('mousemove', onDragMove);\n  window.addEventListener('touchmove', onDragMove, { passive: false });\n  window.addEventListener('mouseup', onDragEnd);\n  window.addEventListener('touchend', onDragEnd);\n\n  cleanupDiagramInteractions = () => {\n    svg.removeEventListener('mousedown', onSvgMouseDown);\n    svg.removeEventListener('touchstart', onSvgMouseDown);\n    window.removeEventListener('mousemove', onPanMove);\n    window.removeEventListener('touchmove', onPanMove);\n    window.removeEventListener('mouseup', stopPanning);\n    window.removeEventListener('touchend', stopPanning);\n    svg.removeEventListener('mousedown', onDragStart);\n    svg.removeEventListener('touchstart', onDragStart);\n    window.removeEventListener('mousemove', onDragMove);\n    window.removeEventListener('touchmove', onDragMove);\n    window.removeEventListener('mouseup', onDragEnd);\n    window.removeEventListener('touchend', onDragEnd);\n  };\n\n  apply();\n}\n\nfunction updateDiagramLegend() {\n  if (!diagramLegend) return;\n  const legendItems = [\n    { cls: 'power', text: texts[currentLang].diagramLegendPower },\n    { cls: 'video', text: texts[currentLang].diagramLegendVideo },\n    { cls: 'fiz', text: texts[currentLang].diagramLegendFIZ }\n  ];\n  diagramLegend.innerHTML = legendItems\n    .map(({ cls, text }) => `<span><span class=\"swatch ${cls}\"></span>${text}</span>`)\n    .join('');\n}\n\n// Convert a camelCase or underscore key to a human friendly label\nfunction humanizeKey(key) {\n  const map = {\n    powerDrawWatts: 'Power (W)',\n    capacity: 'Capacity (Wh)',\n    pinA: 'Pin A',\n    dtapA: 'D-Tap A',\n    mount_type: 'Mount',\n    screenSizeInches: 'Screen Size (in)',\n    brightnessNits: 'Brightness (nits)',\n    torqueNm: 'Torque (Nm)',\n    internalController: 'Internal Controller',\n    powerSource: 'Power Source',\n    batteryType: 'Battery Type',\n    connectivity: 'Connectivity'\n  };\n  if (map[key]) return map[key];\n  return key\n    .replace(/_/g, ' ')\n    .replace(/([A-Z])/g, ' $1')\n    .replace(/^./, (c) => c.toUpperCase());\n}\n\nfunction formatValue(value) {\n  if (Array.isArray(value)) {\n    return value.map((v) => formatValue(v)).join('; ');\n  }\n  if (value && typeof value === 'object') {\n    const parts = [];\n    for (const k in value) {\n      if (value[k] === '' || value[k] === null || value[k] === undefined) continue;\n      parts.push(`${humanizeKey(k)}: ${formatValue(value[k])}`);\n    }\n    return `{ ${parts.join(', ')} }`;\n  }\n  if (typeof value === 'boolean') return value ? 'Yes' : 'No';\n  return String(value);\n}\n\nfunction createDeviceDetailsList(deviceData) {\n  const list = document.createElement('ul');\n  list.className = 'device-detail-list';\n\n  const appendItem = (key, value, parent) => {\n    if (value === '' || value === null || value === undefined) return;\n    const li = document.createElement('li');\n    const label = document.createElement('strong');\n    label.textContent = humanizeKey(key) + ':';\n    li.appendChild(label);\n\n    if (Array.isArray(value)) {\n      if (value.length && typeof value[0] === 'object') {\n        const subList = document.createElement('ul');\n        subList.className = 'device-detail-list';\n        value.forEach((v) => {\n          const subLi = document.createElement('li');\n          subLi.appendChild(createDeviceDetailsList(v));\n          subList.appendChild(subLi);\n        });\n        li.appendChild(subList);\n      } else {\n        li.appendChild(document.createTextNode(value.map((v) => formatValue(v)).join(', ')));\n      }\n    } else if (value && typeof value === 'object') {\n      li.appendChild(createDeviceDetailsList(value));\n    } else {\n      li.appendChild(document.createTextNode(formatValue(value)));\n    }\n\n    parent.appendChild(li);\n  };\n\n  if (typeof deviceData !== 'object') {\n    appendItem('powerDrawWatts', deviceData, list);\n  } else {\n    Object.keys(deviceData).forEach((k) => appendItem(k, deviceData[k], list));\n  }\n\n  return list;\n}\nfunction formatDateString(val) {\n  if (!val) return '';\n  const d = new Date(val);\n  if (Number.isNaN(d.getTime())) return String(val);\n  return d.toISOString().split('T')[0];\n}\n\n// Helper to render existing devices in the manager section\nfunction renderDeviceList(categoryKey, ulElement) {\n  ulElement.innerHTML = \"\";\n  let categoryDevices = devices[categoryKey];\n  // Handle nested FIZ categories\n  if (categoryKey.includes('.')) {\n    const [mainCat, subCat] = categoryKey.split('.');\n    categoryDevices = devices[mainCat] && devices[mainCat][subCat];\n  }\n  if (!categoryDevices) return;\n\n  const buildItem = (name, deviceData, subcategory) => {\n    if (name === \"None\") return;\n    const li = document.createElement(\"li\");\n    const header = document.createElement(\"div\");\n    header.className = \"device-summary\";\n\n    const nameSpan = document.createElement(\"span\");\n    nameSpan.textContent = name;\n    let summary = generateConnectorSummary(deviceData);\n    summary = summary ? summary.replace(/<[^>]+>/g, '').replace(/\\s+/g, ' ').trim() : '';\n    if (deviceData.notes) {\n      summary = summary ? `${summary}; Notes: ${deviceData.notes}` : deviceData.notes;\n    }\n    if (summary) {\n      nameSpan.setAttribute('title', summary);\n      nameSpan.setAttribute('data-help', summary);\n    }\n    header.appendChild(nameSpan);\n\n    const toggleBtn = document.createElement(\"button\");\n    toggleBtn.className = \"detail-toggle\";\n    toggleBtn.type = \"button\";\n    toggleBtn.setAttribute(\"aria-expanded\", \"false\");\n    toggleBtn.textContent = texts[currentLang].showDetails;\n    toggleBtn.setAttribute('data-help', texts[currentLang].showDetails);\n    header.appendChild(toggleBtn);\n\n    const editBtn = document.createElement(\"button\");\n    editBtn.className = \"edit-btn\";\n    editBtn.dataset.name = name;\n    editBtn.dataset.category = categoryKey;\n    if (subcategory) editBtn.dataset.subcategory = subcategory;\n    editBtn.textContent = texts[currentLang].editBtn;\n    editBtn.setAttribute('data-help', texts[currentLang].editBtnHelp || texts[currentLang].editBtn);\n    header.appendChild(editBtn);\n\n    const deleteBtn = document.createElement(\"button\");\n    deleteBtn.className = \"delete-btn\";\n    deleteBtn.dataset.name = name;\n    deleteBtn.dataset.category = categoryKey;\n    if (subcategory) deleteBtn.dataset.subcategory = subcategory;\n    deleteBtn.textContent = texts[currentLang].deleteDeviceBtn;\n    deleteBtn.setAttribute('data-help', texts[currentLang].deleteDeviceBtnHelp || texts[currentLang].deleteDeviceBtn);\n    header.appendChild(deleteBtn);\n\n    li.appendChild(header);\n\n    const detailsDiv = document.createElement(\"div\");\n    detailsDiv.className = \"device-details\";\n    detailsDiv.style.display = \"none\";\n    detailsDiv.appendChild(createDeviceDetailsList(deviceData));\n    li.appendChild(detailsDiv);\n\n    ulElement.appendChild(li);\n  };\n\n  if (categoryKey === \"accessories.cables\") {\n    for (const [subcat, devs] of Object.entries(categoryDevices)) {\n      for (const name in devs) {\n        buildItem(name, devs[name], subcat);\n      }\n    }\n  } else {\n    for (let name in categoryDevices) {\n      buildItem(name, categoryDevices[name]);\n    }\n  }\n}\n\nfunction refreshDeviceLists() {\n  syncDeviceManagerCategories();\n  deviceManagerLists.forEach(({ list, filterInput }, categoryKey) => {\n    if (!list) return;\n    renderDeviceList(categoryKey, list);\n    const filterValue = filterInput ? filterInput.value : '';\n    filterDeviceList(list, filterValue);\n  });\n}\n\n// Initial render of device lists\nrefreshDeviceLists();\n\n\n// --- EVENT LISTENERS ---\n\n// Language selection\nlanguageSelect.addEventListener(\"change\", (event) => {\n  setLanguage(event.target.value);\n});\n\nif (skipLink) {\n  skipLink.addEventListener(\"click\", () => {\n    const main = document.getElementById(\"mainContent\");\n    if (main) main.focus();\n  });\n}\n\n// Filtering inputs\n\n\n\n\n// Setup management\nsaveSetupBtn.addEventListener(\"click\", () => {\n  const typedName = setupNameInput.value.trim();\n  if (!typedName) {\n    alert(texts[currentLang].alertSetupName);\n    return;\n  }\n  const currentSetup = { ...getCurrentSetupState() };\n  const langTexts = texts[currentLang] || {};\n  const fallbackTexts = texts.en || {};\n  if (!hasAnyDeviceSelection(currentSetup)) {\n    const message =\n      langTexts.alertSetupNeedsDevice ||\n      fallbackTexts.alertSetupNeedsDevice ||\n      'Please select at least one device before saving a project.';\n    alert(message);\n    return;\n  }\n  const gearListHtml = getCurrentGearListHtml();\n  if (gearListHtml) {\n    currentSetup.gearList = gearListHtml;\n  }\n\n  const selectedName = setupSelect ? setupSelect.value : '';\n  const renamingExisting = Boolean(selectedName && typedName && selectedName !== typedName);\n  let setups = getSetups();\n  let finalName = typedName;\n  let storedProjectSnapshot = null;\n\n  if (renamingExisting) {\n    if (typeof loadProject === 'function') {\n      try {\n        storedProjectSnapshot = loadProject(selectedName);\n      } catch (error) {\n        console.warn('Failed to load project data while renaming setup', error);\n      }\n    }\n\n    if (typeof renameSetup === 'function') {\n      try {\n        const renamed = renameSetup(selectedName, typedName);\n        if (typeof renamed === 'string' && renamed) {\n          finalName = renamed;\n        }\n      } catch (error) {\n        console.warn('Failed to rename setup in storage', error);\n      }\n      setups = getSetups();\n    } else if (Object.prototype.hasOwnProperty.call(setups, selectedName)) {\n      setups[typedName] = setups[selectedName];\n      delete setups[selectedName];\n      finalName = typedName;\n    }\n  }\n\n  setups[finalName] = currentSetup;\n  storeSetups(setups);\n\n  if (renamingExisting && storedProjectSnapshot && typeof saveProject === 'function') {\n    try {\n      saveProject(finalName, storedProjectSnapshot);\n    } catch (error) {\n      console.warn('Failed to preserve project data during setup rename', error);\n    }\n  }\n\n  populateSetupSelect();\n  setupNameInput.value = finalName;\n  setupSelect.value = finalName; // Select the saved setup (new or renamed)\n  lastSetupName = finalName;\n  saveCurrentSession(); // Persist selection so refreshes restore this setup\n  storeLoadedSetupState(getCurrentSetupState());\n  checkSetupChanged();\n  // Ensure the current gear list stays persisted with the project so setups\n  // remain in sync with the automatically saved table.\n  saveCurrentGearList();\n\n  if (renamingExisting && selectedName && selectedName !== finalName) {\n    if (typeof deleteProject === 'function') {\n      try {\n        deleteProject(selectedName);\n      } catch (error) {\n        console.warn('Failed to remove old project entry during setup rename', error);\n      }\n    } else if (typeof saveProject === 'function') {\n      try {\n        saveProject(selectedName, { projectInfo: null, gearList: '' });\n      } catch (error) {\n        console.warn('Failed to clear legacy project entry during setup rename', error);\n      }\n    }\n  }\n\n  if (saveSetupBtn) {\n    saveSetupBtn.disabled = !setupNameInput.value.trim();\n  }\n\n  alert(texts[currentLang].alertSetupSaved.replace(\"{name}\", finalName));\n});\n\ndeleteSetupBtn.addEventListener(\"click\", () => {\n  const setupName = setupSelect.value;\n  if (!setupName) {\n    alert(texts[currentLang].alertNoSetupSelected);\n    return;\n  }\n  if (\n    confirm(texts[currentLang].confirmDeleteSetup.replace(\"{name}\", setupName)) &&\n    confirm(texts[currentLang].confirmDeleteSetupAgain)\n  ) {\n    const backupName = ensureAutoBackupBeforeDeletion('delete setup');\n    if (!backupName) {\n      return;\n    }\n    let setups = getSetups();\n    delete setups[setupName];\n    storeSetups(setups);\n    if (typeof deleteProject === 'function') {\n      deleteProject(setupName);\n    }\n    populateSetupSelect();\n    setupNameInput.value = \"\"; // Clear setup name input\n\n    let selectionResetHandled = false;\n    if (setupSelect) {\n      lastSetupName = '';\n      setupSelect.value = \"\";\n      setupSelect.dispatchEvent(new Event('change'));\n      selectionResetHandled = true;\n    }\n\n    if (!selectionResetHandled) {\n      if (gearListOutput) {\n        gearListOutput.innerHTML = '';\n        gearListOutput.classList.add('hidden');\n      }\n      if (projectRequirementsOutput) {\n        projectRequirementsOutput.innerHTML = '';\n        projectRequirementsOutput.classList.add('hidden');\n      }\n      currentProjectInfo = null;\n      if (projectForm) populateProjectForm({});\n      storeLoadedSetupState(null);\n      updateBatteryPlateVisibility();\n      updateBatteryOptions();\n      clearProjectAutoGearRules();\n      renderAutoGearRulesList();\n      updateAutoGearCatalogOptions();\n      // Reset dropdowns to \"None\" or first option after deleting current setup\n      [cameraSelect, monitorSelect, videoSelect, cageSelect, distanceSelect, batterySelect, hotswapSelect].forEach(sel => {\n        const noneOption = Array.from(sel.options).find(opt => opt.value === \"None\");\n        if (noneOption) {\n          sel.value = \"None\";\n        } else {\n          sel.selectedIndex = 0;\n        }\n      });\n      const sbSel = getSliderBowlSelect();\n      if (sbSel) sbSel.value = '';\n      motorSelects.forEach(sel => { if (sel.options.length) sel.value = \"None\"; });\n      controllerSelects.forEach(sel => { if (sel.options.length) sel.value = \"None\"; });\n      updateCalculations(); // Recalculate after deleting setup\n    }\n    alert(texts[currentLang].alertSetupDeleted.replace(\"{name}\", setupName));\n  }\n});\n\nsetupSelect.addEventListener(\"change\", (event) => {\n  const setupName = event.target.value;\n  const typedName =\n    setupNameInput && typeof setupNameInput.value === 'string'\n      ? setupNameInput.value.trim()\n      : '';\n  const previousKey =\n    (lastSetupName && typeof lastSetupName === 'string' ? lastSetupName : '')\n    || typedName\n    || '';\n\n  if (typeof saveProject === 'function') {\n    const info = projectForm ? collectProjectFormData() : {};\n    if (info) {\n      info.sliderBowl = getSliderBowlValue();\n      info.easyrig = getEasyrigValue();\n    }\n    const previousProjectInfo = deriveProjectInfo(info);\n    currentProjectInfo = previousProjectInfo;\n    const previousPayload = {\n      projectInfo: previousProjectInfo,\n      gearList: getCurrentGearListHtml()\n    };\n    const previousRules = getProjectScopedAutoGearRules();\n    if (previousRules && previousRules.length) {\n      previousPayload.autoGearRules = previousRules;\n    }\n    saveProject(previousKey, previousPayload);\n  }\n\n  displayGearAndRequirements('');\n  currentProjectInfo = null;\n  if (setupName === \"\") { // \"-- New Setup --\" selected\n    setupNameInput.value = \"\";\n    [cameraSelect, monitorSelect, videoSelect, cageSelect, distanceSelect, batterySelect, hotswapSelect].forEach(sel => {\n      const noneOption = Array.from(sel.options).find(opt => opt.value === \"None\");\n      if (noneOption) {\n        sel.value = \"None\";\n      } else {\n        sel.selectedIndex = 0;\n      }\n    });\n    const sbSel = getSliderBowlSelect();\n    if (sbSel) sbSel.value = '';\n    motorSelects.forEach(sel => { if (sel.options.length) sel.value = \"None\"; });\n    controllerSelects.forEach(sel => { if (sel.options.length) sel.value = \"None\"; });\n    updateBatteryPlateVisibility();\n    updateBatteryOptions();\n    storeLoadedSetupState(null);\n    if (gearListOutput) {\n      gearListOutput.innerHTML = '';\n      gearListOutput.classList.add('hidden');\n    }\n    if (projectRequirementsOutput) {\n      projectRequirementsOutput.innerHTML = '';\n      projectRequirementsOutput.classList.add('hidden');\n    }\n    currentProjectInfo = null;\n    if (projectForm) populateProjectForm({});\n    clearProjectAutoGearRules();\n  } else {\n    const setups = getSetups();\n    const setup = setups[setupName];\n    if (setup) {\n      setupNameInput.value = setupName;\n      cameraSelect.value = setup.camera;\n      updateBatteryPlateVisibility();\n      batteryPlateSelect.value = setup.batteryPlate || batteryPlateSelect.value;\n      monitorSelect.value = setup.monitor;\n      videoSelect.value = setup.video;\n      if (cageSelect) cageSelect.value = setup.cage || cageSelect.value;\n      (setup.motors || []).forEach((val, i) => { if (motorSelects[i]) motorSelects[i].value = val; });\n      (setup.controllers || []).forEach((val, i) => { if (controllerSelects[i]) controllerSelects[i].value = val; });\n      distanceSelect.value = setup.distance;\n      batterySelect.value = setup.battery;\n      hotswapSelect.value = setup.batteryHotswap || hotswapSelect.value;\n      setSliderBowlValue(setup.sliderBowl || '');\n      setEasyrigValue(setup.easyrig || '');\n      updateBatteryOptions();\n      const storedProject = typeof loadProject === 'function' ? loadProject(setupName) : null;\n      const html = setup.gearList || storedProject?.gearList || '';\n      currentProjectInfo = setup.projectInfo || storedProject?.projectInfo || null;\n      const projectRulesSource = Array.isArray(setup.autoGearRules) && setup.autoGearRules.length\n        ? setup.autoGearRules\n        : (Array.isArray(storedProject?.autoGearRules) && storedProject.autoGearRules.length\n          ? storedProject.autoGearRules\n          : null);\n      if (projectRulesSource) {\n        useProjectAutoGearRules(projectRulesSource);\n      } else {\n        clearProjectAutoGearRules();\n      }\n      if (gearListOutput) {\n        displayGearAndRequirements(html);\n        populateProjectForm(currentProjectInfo || {});\n        if (html) {\n          ensureGearListActions();\n          bindGearListCageListener();\n          bindGearListEasyrigListener();\n          bindGearListSliderBowlListener();\n          bindGearListEyeLeatherListener();\n          bindGearListProGaffTapeListener();\n          bindGearListDirectorMonitorListener();\n        }\n        if (typeof saveProject === 'function') {\n          const payload = {\n            projectInfo: currentProjectInfo,\n            gearList: html\n          };\n          const activeRules = getProjectScopedAutoGearRules();\n          if (activeRules && activeRules.length) {\n            payload.autoGearRules = activeRules;\n          }\n          saveProject(setupName, payload);\n        }\n      }\n    } else {\n      currentProjectInfo = null;\n      if (projectForm) populateProjectForm({});\n      displayGearAndRequirements('');\n      clearProjectAutoGearRules();\n    }\n    storeLoadedSetupState(getCurrentSetupState());\n  }\n  renderAutoGearRulesList();\n  updateAutoGearCatalogOptions();\n  if (saveSetupBtn) {\n    saveSetupBtn.disabled = !setupNameInput.value.trim();\n  }\n  updateCalculations();\n  checkSetupChanged();\n  lastSetupName = setupName;\n});\n\n\nfunction populateSetupSelect() {\n  const setups = getSetups();\n  setupSelect.innerHTML = `<option value=\"\">${texts[currentLang].newSetupOption}</option>`;\n  const names = Object.keys(setups)\n    .filter(name => showAutoBackups || !name.startsWith('auto-backup-'))\n    .sort((a, b) => {\n      const autoA = a.startsWith('auto-backup-');\n      const autoB = b.startsWith('auto-backup-');\n      if (autoA !== autoB) return autoA ? 1 : -1; // Auto backups last\n      return localeSort(a, b);\n    });\n  for (const name of names) {\n    const opt = document.createElement(\"option\");\n    opt.value = name;\n    opt.textContent = name;\n    setupSelect.appendChild(opt);\n  }\n}\npopulateSetupSelect(); // Initial populate of setups\ncheckSetupChanged();\n\n// Auto-save backups every 10 minutes. Saved backups appear in the setup\n// selector but do not change the currently selected setup. Intervals are\n// unref'ed when possible so Node environments can exit cleanly.\nfunction autoBackup(options = {}) {\n  if (!setupSelect) return null;\n  const config = typeof options === 'object' && options !== null ? options : {};\n  const suppressSuccess = Boolean(config.suppressSuccess);\n  const suppressError = Boolean(config.suppressError);\n  const successMessage = typeof config.successMessage === 'string' && config.successMessage\n    ? config.successMessage\n    : 'Auto backup saved';\n  const errorMessage = typeof config.errorMessage === 'string' && config.errorMessage\n    ? config.errorMessage\n    : 'Auto backup failed';\n\n  try {\n    const pad = (n) => String(n).padStart(2, '0');\n    const now = new Date();\n    const baseName = `auto-backup-${now.getFullYear()}-${pad(now.getMonth() + 1)}-${pad(now.getDate())}-${pad(now.getHours())}-${pad(now.getMinutes())}`;\n    const activeNameRaw = setupSelect.value\n      || (setupNameInput && typeof setupNameInput.value === 'string'\n        ? setupNameInput.value.trim()\n        : '');\n    const normalizedName = activeNameRaw\n      ? activeNameRaw.replace(/\\s+/g, ' ').trim()\n      : '';\n    const backupName = normalizedName ? `${baseName}-${normalizedName}` : baseName;\n    const currentSetup = { ...getCurrentSetupState() };\n    const gearListHtml = getCurrentGearListHtml();\n    if (gearListHtml) {\n      currentSetup.gearList = gearListHtml;\n    }\n    const setups = getSetups();\n    setups[backupName] = currentSetup;\n    storeSetups(setups);\n    if (typeof saveProject === 'function') {\n      const payload = {\n        gearList: gearListHtml || '',\n        projectInfo: currentSetup.projectInfo || null,\n      };\n      const activeRules = getProjectScopedAutoGearRules();\n      if (activeRules && activeRules.length) {\n        payload.autoGearRules = activeRules;\n      }\n      if (payload.gearList || payload.projectInfo || payload.autoGearRules) {\n        saveProject(backupName, payload);\n      }\n    }\n    const prevValue = setupSelect.value;\n    const prevName = setupNameInput ? setupNameInput.value : '';\n    populateSetupSelect();\n    setupSelect.value = prevValue;\n    if (setupNameInput) setupNameInput.value = prevName;\n    if (!suppressSuccess) {\n      showNotification('success', successMessage);\n    }\n    return backupName;\n  } catch (e) {\n    console.warn('Auto backup failed', e);\n    if (!suppressError) {\n      showNotification('error', errorMessage);\n    }\n    return null;\n  }\n}\n\nfunction ensureAutoBackupBeforeDeletion(context, options = {}) {\n  const config = typeof options === 'object' && options !== null ? options : {};\n  const langTexts = texts[currentLang] || {};\n  const fallbackTexts = texts.en || {};\n  const successMessage = config.successMessage\n    || langTexts.preDeleteBackupSuccess\n    || fallbackTexts.preDeleteBackupSuccess\n    || 'Automatic backup saved. Restore it anytime from Saved Projects.';\n  const failureMessage = config.failureMessage\n    || langTexts.preDeleteBackupFailed\n    || fallbackTexts.preDeleteBackupFailed\n    || 'Automatic backup failed. The action was cancelled.';\n  const autoBackupOptions = {\n    suppressSuccess: true,\n    suppressError: true,\n    ...(config.autoBackupOptions || {}),\n  };\n\n  let backupName = null;\n  if (typeof autoBackup === 'function') {\n    try {\n      backupName = autoBackup(autoBackupOptions);\n    } catch (error) {\n      console.error(`Automatic backup before ${context || 'deletion'} failed`, error);\n      backupName = null;\n    }\n  }\n\n  if (!backupName) {\n    showNotification('error', failureMessage);\n    return null;\n  }\n\n  if (config.notifySuccess !== false) {\n    showNotification('success', successMessage);\n  }\n\n  return backupName;\n}\nconst autoBackupInterval = setInterval(autoBackup, 10 * 60 * 1000);\nif (typeof autoBackupInterval.unref === 'function') {\n  autoBackupInterval.unref();\n}\n\nconst autoGearBackupInterval = setInterval(() => {\n  if (!autoGearRulesDirtySinceBackup) return;\n  createAutoGearBackup();\n}, AUTO_GEAR_BACKUP_INTERVAL_MS);\nif (typeof autoGearBackupInterval.unref === 'function') {\n  autoGearBackupInterval.unref();\n}\n\nconst hourlyBackupInterval = setInterval(() => {\n  const fileName = createSettingsBackup(false);\n  showNotification(\n    fileName ? 'success' : 'error',\n    fileName ? `Full app backup downloaded (${fileName})` : 'Full app backup failed',\n  );\n}, 60 * 60 * 1000);\nif (typeof hourlyBackupInterval.unref === 'function') {\n  hourlyBackupInterval.unref();\n}\n\nfunction showDeviceManagerSection() {\n  if (!deviceManagerSection || !toggleDeviceBtn) return;\n  if (!deviceManagerSection.classList.contains('hidden')) return;\n  deviceManagerSection.classList.remove('hidden');\n  setButtonLabelWithIcon(toggleDeviceBtn, texts[currentLang].hideDeviceManager, ICON_GLYPHS.minus);\n  toggleDeviceBtn.setAttribute('title', texts[currentLang].hideDeviceManager);\n  toggleDeviceBtn.setAttribute('data-help', texts[currentLang].hideDeviceManagerHelp);\n  toggleDeviceBtn.setAttribute('aria-expanded', 'true');\n  refreshDeviceLists();\n  updateCalculations();\n}\n\nfunction hideDeviceManagerSection() {\n  if (!deviceManagerSection || !toggleDeviceBtn) return;\n  if (deviceManagerSection.classList.contains('hidden')) return;\n  deviceManagerSection.classList.add('hidden');\n  setButtonLabelWithIcon(toggleDeviceBtn, texts[currentLang].toggleDeviceManager, ICON_GLYPHS.gears);\n  toggleDeviceBtn.setAttribute('title', texts[currentLang].toggleDeviceManager);\n  toggleDeviceBtn.setAttribute('data-help', texts[currentLang].toggleDeviceManagerHelp);\n  toggleDeviceBtn.setAttribute('aria-expanded', 'false');\n}\n\n// Toggle device manager visibility\nif (toggleDeviceBtn) {\n  toggleDeviceBtn.addEventListener('click', () => {\n    if (deviceManagerSection.classList.contains('hidden')) {\n      showDeviceManagerSection();\n    } else {\n      hideDeviceManagerSection();\n    }\n  });\n}\n\n\nfunction toggleDeviceDetails(button) {\n  const details = button.closest('li').querySelector('.device-details');\n  const expanded = button.getAttribute('aria-expanded') === 'true';\n  if (expanded) {\n    details.style.display = 'none';\n    button.textContent = texts[currentLang].showDetails;\n    button.setAttribute('aria-expanded', 'false');\n    button.setAttribute('data-help', texts[currentLang].showDetails);\n  } else {\n    details.style.display = 'block';\n    button.textContent = texts[currentLang].hideDetails;\n    button.setAttribute('aria-expanded', 'true');\n    button.setAttribute('data-help', texts[currentLang].hideDetails);\n  }\n}\n\nfunction inferDeviceCategory(key, data) {\n  if (key === \"batteries\" || key.endsWith('.batteries') || data.capacity !== undefined) return \"batteries\";\n  if (key === \"cameras\" || data.recordingMedia || data.lensMount || data.power?.batteryPlateSupport) return \"cameras\";\n  if (key === \"monitors\" || (data.screenSizeInches !== undefined && !key.includes(\"viewfinder\"))) return \"monitors\";\n  if (key === \"viewfinders\" || key.includes(\"viewfinder\")) return \"viewfinders\";\n  if (key === \"video\" || key === \"wirelessReceivers\" || key === \"iosVideo\" || data.videoInputs || data.videoOutputs || data.frequency !== undefined) return \"video\";\n  if (key === \"fiz.motors\" || data.torqueNm !== undefined || data.gearTypes) return \"fiz.motors\";\n  if (key === \"fiz.controllers\" || data.powerSource || data.batteryType || data.connectivity) return \"fiz.controllers\";\n  if (key === \"fiz.distance\" || data.measurementMethod || data.connectionCompatibility || data.measurementRange || data.accuracy) return \"fiz.distance\";\n  return \"generic\";\n}\n\nfunction populateDeviceForm(categoryKey, deviceData, subcategory) {\n  placeWattField(categoryKey, deviceData);\n  const type = inferDeviceCategory(categoryKey, deviceData);\n  if (wattFieldDiv) wattFieldDiv.style.display = \"block\";\n  hideFormSection(batteryFieldsDiv);\n  hideFormSection(cameraFieldsDiv);\n  hideFormSection(monitorFieldsDiv);\n  hideFormSection(viewfinderFieldsDiv);\n  hideFormSection(videoFieldsDiv);\n  hideFormSection(motorFieldsDiv);\n  hideFormSection(controllerFieldsDiv);\n  hideFormSection(distanceFieldsDiv);\n  clearDynamicFields();\n\n  if (type === \"batteries\") {\n    if (wattFieldDiv) wattFieldDiv.style.display = \"none\";\n    showFormSection(batteryFieldsDiv);\n    newCapacityInput.value = deviceData.capacity || '';\n    newPinAInput.value = deviceData.pinA || '';\n    if (dtapRow) dtapRow.style.display = categoryKey === \"batteryHotswaps\" ? \"none\" : \"\";\n    newDtapAInput.value = categoryKey === \"batteryHotswaps\" ? '' : (deviceData.dtapA || '');\n    buildDynamicFields(categoryKey, deviceData, categoryExcludedAttrs[categoryKey] || []);\n  } else if (type === \"cameras\") {\n    if (wattFieldDiv) wattFieldDiv.style.display = \"none\";\n    showFormSection(cameraFieldsDiv);\n    const tmp = firstPowerInputType(deviceData);\n    cameraWattInput.value = deviceData.powerDrawWatts || '';\n    cameraVoltageInput.value = deviceData.power?.input?.voltageRange || '';\n    cameraPortTypeInput.value = tmp || \"\";\n    setBatteryPlates(deviceData.power?.batteryPlateSupport || []);\n    setRecordingMedia(deviceData.recordingMedia || []);\n    setLensMounts(deviceData.lensMount || []);\n    setPowerDistribution(deviceData.power?.powerDistributionOutputs || []);\n    setVideoOutputs(deviceData.videoOutputs || []);\n    setFizConnectors(deviceData.fizConnectors || []);\n    setViewfinders(deviceData.viewfinder || []);\n    setTimecodes(deviceData.timecode || []);\n    buildDynamicFields(categoryKey, deviceData, categoryExcludedAttrs[categoryKey] || []);\n  } else if (type === \"monitors\") {\n    showFormSection(monitorFieldsDiv);\n    monitorScreenSizeInput.value = deviceData.screenSizeInches || '';\n    monitorBrightnessInput.value = deviceData.brightnessNits || '';\n    monitorWattInput.value = deviceData.powerDrawWatts || '';\n    monitorVoltageInput.value = deviceData.power?.input?.voltageRange || '';\n    const mpt = firstPowerInputType(deviceData);\n    monitorPortTypeInput.value = mpt || \"\";\n    setMonitorVideoInputs(deviceData.videoInputs || deviceData.video?.inputs || []);\n    setMonitorVideoOutputs(deviceData.videoOutputs || deviceData.video?.outputs || []);\n    monitorWirelessTxInput.checked = !!deviceData.wirelessTx;\n    monitorLatencyInput.value = deviceData.latencyMs || '';\n    monitorAudioOutputInput.value =\n      deviceData.audioOutput?.portType ||\n      deviceData.audioOutput?.type ||\n      deviceData.audioOutput || '';\n    buildDynamicFields(categoryKey, deviceData, categoryExcludedAttrs[categoryKey] || []);\n  } else if (type === \"viewfinders\") {\n    showFormSection(viewfinderFieldsDiv);\n    viewfinderScreenSizeInput.value = deviceData.screenSizeInches || '';\n    viewfinderBrightnessInput.value = deviceData.brightnessNits || '';\n    viewfinderWattInput.value = deviceData.powerDrawWatts || '';\n    viewfinderVoltageInput.value = deviceData.power?.input?.voltageRange || '';\n    const vfpt = firstPowerInputType(deviceData);\n    viewfinderPortTypeInput.value = vfpt || \"\";\n    setViewfinderVideoInputs(deviceData.videoInputs || deviceData.video?.inputs || []);\n    setViewfinderVideoOutputs(deviceData.videoOutputs || deviceData.video?.outputs || []);\n    viewfinderWirelessTxInput.checked = !!deviceData.wirelessTx;\n    viewfinderLatencyInput.value = deviceData.latencyMs || '';\n    buildDynamicFields(categoryKey, deviceData, categoryExcludedAttrs[categoryKey] || []);\n  } else if (type === \"video\") {\n    showFormSection(videoFieldsDiv);\n    newWattInput.value = deviceData.powerDrawWatts || '';\n    videoPowerInput.value = firstPowerInputType(deviceData);\n    setVideoInputs(deviceData.videoInputs || deviceData.video?.inputs || []);\n    setVideoOutputsIO(deviceData.videoOutputs || deviceData.video?.outputs || []);\n    videoFrequencyInput.value = deviceData.frequency || '';\n    videoLatencyInput.value = deviceData.latencyMs || '';\n    motorConnectorInput.value = '';\n    buildDynamicFields(categoryKey, deviceData, categoryExcludedAttrs[categoryKey] || []);\n  } else if (type === \"fiz.motors\") {\n    showFormSection(motorFieldsDiv);\n    newWattInput.value = deviceData.powerDrawWatts || '';\n    motorConnectorInput.value = deviceData.fizConnector || '';\n    motorInternalInput.checked = !!deviceData.internalController;\n    motorTorqueInput.value = deviceData.torqueNm || '';\n    motorGearInput.value = Array.isArray(deviceData.gearTypes) ? deviceData.gearTypes.join(', ') : '';\n    motorNotesInput.value = deviceData.notes || '';\n    buildDynamicFields(categoryKey, deviceData, categoryExcludedAttrs[categoryKey] || []);\n  } else if (type === \"fiz.controllers\") {\n    showFormSection(controllerFieldsDiv);\n    newWattInput.value = deviceData.powerDrawWatts || '';\n    const cc = Array.isArray(deviceData.fizConnectors)\n      ? deviceData.fizConnectors.map(fc => fc.type).join(', ')\n      : (deviceData.fizConnector || '');\n    controllerConnectorInput.value = cc;\n    controllerPowerInput.value = deviceData.powerSource || '';\n    controllerBatteryInput.value = deviceData.batteryType || '';\n    controllerConnectivityInput.value = deviceData.connectivity || '';\n    controllerNotesInput.value = deviceData.notes || '';\n    buildDynamicFields(categoryKey, deviceData, categoryExcludedAttrs[categoryKey] || []);\n  } else if (type === \"fiz.distance\") {\n    showFormSection(distanceFieldsDiv);\n    newWattInput.value = deviceData.powerDrawWatts || '';\n    distanceConnectionInput.value = deviceData.connectionCompatibility || '';\n    distanceMethodInput.value = deviceData.measurementMethod || '';\n    distanceRangeInput.value = deviceData.measurementRange || '';\n    distanceAccuracyInput.value = deviceData.accuracy || '';\n    distanceOutputInput.value = deviceData.outputDisplay || '';\n    distanceNotesInput.value = deviceData.notes || '';\n    buildDynamicFields(categoryKey, deviceData, categoryExcludedAttrs[categoryKey] || []);\n  } else if (type === \"accessories.cables\") {\n    wattFieldDiv.style.display = \"none\";\n    subcategoryFieldDiv.hidden = false;\n    const subcats = Object.keys(devices.accessories?.cables || {});\n    newSubcategorySelect.innerHTML = '';\n    for (const sc of subcats) {\n      const opt = document.createElement('option');\n      opt.value = sc;\n      opt.textContent = sc.charAt(0).toUpperCase() + sc.slice(1);\n      newSubcategorySelect.appendChild(opt);\n    }\n    newSubcategorySelect.value = subcategory || '';\n    // Allow selecting a different subcategory while editing so devices can\n    // be reorganised without re-creating them from scratch.\n    newSubcategorySelect.disabled = false;\n    buildDynamicFields(`accessories.cables.${subcategory}`, deviceData, categoryExcludedAttrs[`accessories.cables.${subcategory}`] || []);\n  } else {\n    const watt = typeof deviceData === 'object' ? deviceData.powerDrawWatts : deviceData;\n    newWattInput.value = watt || '';\n    buildDynamicFields(categoryKey, deviceData, categoryExcludedAttrs[categoryKey] || []);\n  }\n}\n\n// Handle \"Edit\" and \"Delete\" buttons in device lists (event delegation)\ndeviceManagerSection.addEventListener(\"click\", (event) => {\n  if (event.target.classList.contains(\"detail-toggle\")) {\n    toggleDeviceDetails(event.target);\n  } else if (event.target.classList.contains(\"edit-btn\")) {\n    const name = event.target.dataset.name;\n    const categoryKey = event.target.dataset.category;\n    const subcategory = event.target.dataset.subcategory;\n\n    // Ensure category exists in selector\n    if (!Array.from(newCategorySelect.options).some(opt => opt.value === categoryKey)) {\n      const opt = document.createElement(\"option\");\n      opt.value = categoryKey;\n      opt.textContent = categoryNames[currentLang]?.[categoryKey] || categoryKey;\n      newCategorySelect.appendChild(opt);\n    }\n\n    addDeviceBtn.dataset.mode = \"edit\";\n    addDeviceBtn.dataset.originalName = name;\n    addDeviceBtn.dataset.originalCategory = categoryKey;\n    if (categoryKey === \"accessories.cables\" && subcategory) {\n      addDeviceBtn.dataset.originalSubcategory = subcategory;\n    } else {\n      delete addDeviceBtn.dataset.originalSubcategory;\n    }\n\n    // Set form for editing\n    newCategorySelect.value = categoryKey;\n    newNameInput.value = name;\n    // Trigger change handler so fields are cleared and rebuilt for the category\n    newCategorySelect.dispatchEvent(new Event('change'));\n\n    let deviceData;\n    if (categoryKey === \"accessories.cables\") {\n      deviceData = devices.accessories.cables[subcategory][name];\n    } else if (categoryKey.includes('.')) {\n      const [mainCat, subCat] = categoryKey.split('.');\n      deviceData = devices[mainCat][subCat][name];\n    } else {\n      deviceData = devices[categoryKey][name];\n    }\n\n    populateDeviceForm(categoryKey, deviceData, subcategory);\n    // Change button to \"Update\"\n    setButtonLabelWithIcon(addDeviceBtn, texts[currentLang].updateDeviceBtn, ICON_GLYPHS.save);\n    addDeviceBtn.setAttribute('data-help', texts[currentLang].updateDeviceBtnHelp);\n    addDeviceBtn.dataset.mode = \"edit\";\n    setButtonLabelWithIcon(cancelEditBtn, texts[currentLang].cancelEditBtn, ICON_GLYPHS.circleX);\n    cancelEditBtn.setAttribute('data-help', texts[currentLang].cancelEditBtnHelp);\n    showFormSection(cancelEditBtn);\n    document.getElementById(\"addDeviceHeading\").scrollIntoView({ behavior: \"smooth\", block: \"start\" });\n  } else if (event.target.classList.contains(\"delete-btn\")) {\n    const name = event.target.dataset.name;\n    const categoryKey = event.target.dataset.category;\n    const subcategory = event.target.dataset.subcategory;\n    if (confirm(texts[currentLang].confirmDeleteDevice.replace(\"{name}\", name))) {\n      if (categoryKey === \"accessories.cables\") {\n        delete devices.accessories.cables[subcategory][name];\n      } else if (categoryKey.includes('.')) {\n        const [mainCat, subCat] = categoryKey.split('.');\n        delete devices[mainCat][subCat][name];\n      } else {\n        delete devices[categoryKey][name];\n      }\n      storeDevices(devices);\n      viewfinderTypeOptions = getAllViewfinderTypes();\n      viewfinderConnectorOptions = getAllViewfinderConnectors();\n      refreshDeviceLists();\n      // Re-populate all dropdowns and update calculations\n      populateSelect(cameraSelect, devices.cameras, true);\n      populateMonitorSelect();\n      populateSelect(videoSelect, devices.video, true);\n      motorSelects.forEach(sel => populateSelect(sel, devices.fiz.motors, true));\n      controllerSelects.forEach(sel => populateSelect(sel, devices.fiz.controllers, true));\n      populateSelect(distanceSelect, devices.fiz.distance, true);\n      populateSelect(batterySelect, devices.batteries, true);\n        updateFizConnectorOptions();\n        updateMotorConnectorOptions();\n        updateControllerConnectorOptions();\n        updateControllerPowerOptions();\n        updateControllerBatteryOptions();\n        updateControllerConnectivityOptions();\n        updatePowerDistTypeOptions();\n        updatePowerDistVoltageOptions();\n        updatePowerDistCurrentOptions();\n        updateTimecodeTypeOptions();\n        updateDistanceConnectionOptions();\n        updateDistanceMethodOptions();\n        updateDistanceDisplayOptions();\n      applyFilters();\n      updateCalculations();\n    }\n  }\n});\n\ndeviceManagerSection.addEventListener('keydown', (event) => {\n  if (event.target.classList.contains('detail-toggle') && (event.key === 'Enter' || event.key === ' ')) {\n    event.preventDefault();\n    toggleDeviceDetails(event.target);\n  }\n});\n\n// Category selection in add device form\nnewCategorySelect.addEventListener(\"change\", () => {\n  const wasEditing = addDeviceBtn?.dataset.mode === \"edit\";\n  const previousName = newNameInput ? newNameInput.value : \"\";\n  const val = newCategorySelect.value;\n  placeWattField(val);\n  clearDynamicFields();\n  subcategoryFieldDiv.hidden = true;\n  newSubcategorySelect.innerHTML = \"\";\n  newSubcategorySelect.disabled = false;\n  if (dtapRow) dtapRow.style.display = \"\";\n  if (wattFieldDiv) wattFieldDiv.style.display = \"block\";\n  hideFormSection(batteryFieldsDiv);\n  hideFormSection(cameraFieldsDiv);\n  hideFormSection(monitorFieldsDiv);\n  hideFormSection(viewfinderFieldsDiv);\n  hideFormSection(videoFieldsDiv);\n  hideFormSection(motorFieldsDiv);\n  hideFormSection(controllerFieldsDiv);\n  hideFormSection(distanceFieldsDiv);\n  if (val === \"batteries\" || val === \"accessories.batteries\" || val === \"batteryHotswaps\") {\n    if (wattFieldDiv) wattFieldDiv.style.display = \"none\";\n    showFormSection(batteryFieldsDiv);\n    if (dtapRow) dtapRow.style.display = val === \"batteryHotswaps\" ? \"none\" : \"\";\n  } else if (val === \"cameras\") {\n    if (wattFieldDiv) wattFieldDiv.style.display = \"none\";\n    showFormSection(cameraFieldsDiv);\n  } else if (val === \"monitors\" || val === \"directorMonitors\") {\n    if (wattFieldDiv) wattFieldDiv.style.display = \"none\";\n    showFormSection(monitorFieldsDiv);\n  } else if (val === \"viewfinders\") {\n    if (wattFieldDiv) wattFieldDiv.style.display = \"none\";\n    showFormSection(viewfinderFieldsDiv);\n  } else if (val === \"video\" || val === \"wirelessReceivers\" || val === \"iosVideo\") {\n    showFormSection(videoFieldsDiv);\n  } else if (val === \"fiz.motors\") {\n    showFormSection(motorFieldsDiv);\n  } else if (val === \"fiz.controllers\") {\n    showFormSection(controllerFieldsDiv);\n  } else if (val === \"fiz.distance\") {\n    showFormSection(distanceFieldsDiv);\n  } else if (val === \"accessories.cables\") {\n    if (wattFieldDiv) wattFieldDiv.style.display = \"none\";\n    subcategoryFieldDiv.hidden = false;\n    const subcats = Object.keys(devices.accessories?.cables || {});\n    for (const sc of subcats) {\n      const opt = document.createElement('option');\n      opt.value = sc;\n      opt.textContent = sc.charAt(0).toUpperCase() + sc.slice(1);\n      newSubcategorySelect.appendChild(opt);\n    }\n    if (newSubcategorySelect.value) {\n      buildDynamicFields(`accessories.cables.${newSubcategorySelect.value}`, {}, categoryExcludedAttrs[`accessories.cables.${newSubcategorySelect.value}`] || []);\n    }\n  } else {\n    buildDynamicFields(val, {}, categoryExcludedAttrs[val] || []);\n  }\n  newWattInput.value = \"\";\n  newCapacityInput.value = \"\";\n  newPinAInput.value = \"\";\n  newDtapAInput.value = \"\";\n  cameraWattInput.value = \"\";\n  cameraVoltageInput.value = \"\";\n  cameraPortTypeInput.value = \"\";\n  monitorScreenSizeInput.value = \"\";\n  monitorBrightnessInput.value = \"\";\n  monitorWattInput.value = \"\";\n  monitorVoltageInput.value = \"\";\n  monitorPortTypeInput.value = \"\";\n  monitorWirelessTxInput.checked = false;\n  monitorLatencyInput.value = \"\";\n  monitorAudioOutputInput.value = \"\";\n  clearMonitorVideoInputs();\n  clearMonitorVideoOutputs();\n  viewfinderScreenSizeInput.value = \"\";\n  viewfinderBrightnessInput.value = \"\";\n  viewfinderWattInput.value = \"\";\n  viewfinderVoltageInput.value = \"\";\n  viewfinderPortTypeInput.value = \"\";\n  viewfinderWirelessTxInput.checked = false;\n  viewfinderLatencyInput.value = \"\";\n  clearViewfinderVideoInputs();\n  clearViewfinderVideoOutputs();\n  clearBatteryPlates();\n  clearRecordingMedia();\n  clearLensMounts();\n  clearPowerDistribution();\n  clearVideoOutputs();\n  clearFizConnectors();\n  clearViewfinders();\n  clearTimecodes();\n  videoPowerInput.value = \"\";\n  clearVideoInputs();\n  clearVideoOutputsIO();\n  videoFrequencyInput.value = \"\";\n  videoLatencyInput.value = \"\";\n  motorConnectorInput.value = \"\";\n  motorInternalInput.checked = false;\n  motorTorqueInput.value = \"\";\n  motorGearInput.value = \"\";\n  motorNotesInput.value = \"\";\n  controllerConnectorInput.value = \"\";\n  controllerPowerInput.value = \"\";\n  controllerBatteryInput.value = \"\";\n  controllerConnectivityInput.value = \"\";\n  controllerNotesInput.value = \"\";\n  distanceConnectionInput.value = \"\";\n  distanceMethodInput.value = \"\";\n  distanceRangeInput.value = \"\";\n  distanceAccuracyInput.value = \"\";\n  distanceOutputInput.value = \"\";\n  distanceNotesInput.value = \"\";\n  if (val !== 'accessories.cables') {\n    buildDynamicFields(val, {}, categoryExcludedAttrs[val] || []);\n  }\n  if (newNameInput) {\n    if (wasEditing) {\n      newNameInput.value = previousName;\n    } else {\n      newNameInput.value = \"\";\n    }\n  }\n  const cancelLabel = texts[currentLang].cancelEditBtn;\n  if (wasEditing) {\n    setButtonLabelWithIcon(addDeviceBtn, texts[currentLang].updateDeviceBtn, ICON_GLYPHS.save);\n    addDeviceBtn.setAttribute('data-help', texts[currentLang].updateDeviceBtnHelp);\n    setButtonLabelWithIcon(cancelEditBtn, cancelLabel, ICON_GLYPHS.circleX);\n    cancelEditBtn.setAttribute('data-help', texts[currentLang].cancelEditBtnHelp);\n    showFormSection(cancelEditBtn);\n  } else {\n    setButtonLabelWithIcon(addDeviceBtn, texts[currentLang].addDeviceBtn, ICON_GLYPHS.add);\n    addDeviceBtn.setAttribute('data-help', texts[currentLang].addDeviceBtnHelp);\n    addDeviceBtn.dataset.mode = \"add\";\n    delete addDeviceBtn.dataset.originalName;\n    delete addDeviceBtn.dataset.originalSubcategory;\n    delete addDeviceBtn.dataset.originalCategory;\n    setButtonLabelWithIcon(cancelEditBtn, cancelLabel, ICON_GLYPHS.circleX);\n    cancelEditBtn.setAttribute('data-help', texts[currentLang].cancelEditBtnHelp);\n    hideFormSection(cancelEditBtn);\n  }\n});\n\nnewSubcategorySelect.addEventListener('change', () => {\n  if (newCategorySelect.value === 'accessories.cables') {\n    buildDynamicFields(`accessories.cables.${newSubcategorySelect.value}`, {}, categoryExcludedAttrs[`accessories.cables.${newSubcategorySelect.value}`] || []);\n  }\n});\n\nfunction resetDeviceForm() {\n  if (addDeviceBtn) {\n    addDeviceBtn.dataset.mode = \"add\";\n    delete addDeviceBtn.dataset.originalName;\n    delete addDeviceBtn.dataset.originalSubcategory;\n    delete addDeviceBtn.dataset.originalCategory;\n  }\n  if (cancelEditBtn) {\n    hideFormSection(cancelEditBtn);\n    setButtonLabelWithIcon(cancelEditBtn, texts[currentLang].cancelEditBtn, ICON_GLYPHS.circleX);\n    cancelEditBtn.setAttribute('data-help', texts[currentLang].cancelEditBtnHelp);\n  }\n  // Trigger change handler to reset fields and button text, guarding against\n  // missing DOM elements in test environments.\n  if (newCategorySelect.isConnected) {\n    try {\n      newCategorySelect.dispatchEvent(new Event('change'));\n    } catch (err) {\n      console.warn('resetDeviceForm dispatch failed', err);\n    }\n  }\n}\n\n\n// Add/Update device logic\naddDeviceBtn.addEventListener(\"click\", () => {\n  const name = newNameInput.value.trim();\n  const category = newCategorySelect.value;\n  const isEditing = addDeviceBtn.dataset.mode === \"edit\";\n  const originalName = addDeviceBtn.dataset.originalName;\n  const originalCategory = addDeviceBtn.dataset.originalCategory;\n  const subcategory = category === \"accessories.cables\" ? newSubcategorySelect.value : null;\n  const originalSubcategory = addDeviceBtn.dataset.originalSubcategory;\n\n  if (!name) {\n    alert(texts[currentLang].alertDeviceName);\n    return;\n  }\n\n  if (category === \"accessories.cables\" && !subcategory) {\n    alert(texts[currentLang].alertDeviceFields);\n    return;\n  }\n\n  const targetCategory = getCategoryContainer(category, subcategory, { create: true });\n  if (!targetCategory) {\n    alert(texts[currentLang].alertDeviceFields);\n    return;\n  }\n\n  const storedOriginalCategory = originalCategory || category;\n  const storedOriginalSubcategory = originalSubcategory || null;\n  const originalCollection = isEditing\n    ? getCategoryContainer(\n        storedOriginalCategory,\n        storedOriginalCategory === \"accessories.cables\" ? storedOriginalSubcategory : null,\n        { create: false }\n      )\n    : null;\n  const originalDeviceData = isEditing && originalCollection ? originalCollection[originalName] : undefined;\n  const editingSameCategory = isEditing && storedOriginalCategory === category;\n  const editingSamePath = editingSameCategory && (\n    category !== \"accessories.cables\" || storedOriginalSubcategory === subcategory\n  );\n\n  // Check for duplicate name if adding, or if name changed during edit\n  if ((!isEditing && targetCategory[name] !== undefined) ||\n      (isEditing && (name !== originalName || (category === \"accessories.cables\" && subcategory !== originalSubcategory)) && targetCategory[name] !== undefined)) {\n    alert(texts[currentLang].alertDeviceExists);\n    return;\n  }\n\n  if (category === \"batteries\" || category === \"accessories.batteries\" || category === \"batteryHotswaps\") {\n    const capacity = parseFloat(newCapacityInput.value);\n    const pinA = parseFloat(newPinAInput.value);\n    const dtapA = category === \"batteryHotswaps\" ? undefined : parseFloat(newDtapAInput.value);\n    if (\n      isNaN(capacity) ||\n      isNaN(pinA) ||\n      capacity <= 0 ||\n      pinA <= 0 ||\n      (category !== \"batteryHotswaps\" && (isNaN(dtapA) || dtapA < 0))\n    ) {\n      alert(texts[currentLang].alertDeviceFields);\n      return;\n    }\n    const existing = editingSamePath && originalDeviceData ? { ...originalDeviceData } : {};\n    if (category === \"batteryHotswaps\") {\n      targetCategory[name] = { ...existing, capacity: capacity, pinA: pinA };\n    } else {\n      targetCategory[name] = { ...existing, capacity: capacity, pinA: pinA, dtapA: dtapA };\n    }\n    Object.assign(targetCategory[name], collectDynamicFieldValues(category, categoryExcludedAttrs[category] || []));\n  } else if (category === \"accessories.cables\") {\n    const existing = isEditing && originalDeviceData ? { ...originalDeviceData } : {};\n    const attrs = collectDynamicFieldValues(`accessories.cables.${subcategory}`, categoryExcludedAttrs[`accessories.cables.${subcategory}`] || []);\n    targetCategory[name] = { ...existing, ...attrs };\n  } else if (category === \"cameras\") {\n    const watt = parseFloat(cameraWattInput.value);\n    if (isNaN(watt) || watt <= 0) {\n      alert(texts[currentLang].alertDeviceWatt);\n      return;\n    }\n    let powerDist, videoOut, fizCon, viewfinder, timecode, plateSupport;\n    try {\n      powerDist = getPowerDistribution();\n      videoOut = getVideoOutputs();\n      fizCon = getFizConnectors();\n      viewfinder = getViewfinders();\n      timecode = getTimecodes();\n      plateSupport = getBatteryPlates();\n    } catch (e) {\n      console.error(\"Invalid camera JSON input:\", e);\n      alert(texts[currentLang].alertInvalidCameraJSON);\n      return;\n    }\n    targetCategory[name] = {\n      powerDrawWatts: watt,\n      power: {\n        input: {\n          voltageRange: cameraVoltageInput.value,\n          type: cameraPortTypeInput.value\n        },\n        batteryPlateSupport: plateSupport,\n        powerDistributionOutputs: powerDist\n      },\n      videoOutputs: videoOut,\n      fizConnectors: fizCon,\n      recordingMedia: getRecordingMedia(),\n      viewfinder: viewfinder,\n      lensMount: getLensMounts(),\n      timecode: timecode\n    };\n    Object.assign(targetCategory[name], collectDynamicFieldValues(category, categoryExcludedAttrs[category] || []));\n  } else if (category === \"monitors\" || category === \"directorMonitors\") {\n    const watt = parseFloat(monitorWattInput.value);\n    if (isNaN(watt) || watt <= 0) {\n      alert(texts[currentLang].alertDeviceWatt);\n      return;\n    }\n    const screenSize = parseFloat(monitorScreenSizeInput.value);\n    const brightness = parseFloat(monitorBrightnessInput.value);\n    targetCategory[name] = {\n      screenSizeInches: isNaN(screenSize) ? undefined : screenSize,\n      brightnessNits: isNaN(brightness) ? undefined : brightness,\n      powerDrawWatts: watt,\n      power: {\n        input: {\n          voltageRange: monitorVoltageInput.value,\n          type: monitorPortTypeInput.value\n        },\n        output: null\n      },\n      video: {\n        inputs: getMonitorVideoInputs(),\n        outputs: getMonitorVideoOutputs()\n      },\n      wirelessTx: monitorWirelessTxInput.checked,\n      latencyMs: monitorWirelessTxInput.checked ? monitorLatencyInput.value : undefined,\n      audioOutput: monitorAudioOutputInput.value ? { portType: monitorAudioOutputInput.value } : undefined\n    };\n    Object.assign(targetCategory[name], collectDynamicFieldValues(category, categoryExcludedAttrs[category] || []));\n  } else if (category === \"viewfinders\") {\n    const watt = parseFloat(viewfinderWattInput.value);\n    if (isNaN(watt) || watt <= 0) {\n      alert(texts[currentLang].alertDeviceWatt);\n      return;\n    }\n    const screenSize = parseFloat(viewfinderScreenSizeInput.value);\n    const brightness = parseFloat(viewfinderBrightnessInput.value);\n    targetCategory[name] = {\n      screenSizeInches: isNaN(screenSize) ? undefined : screenSize,\n      brightnessNits: isNaN(brightness) ? undefined : brightness,\n      powerDrawWatts: watt,\n      power: {\n        input: {\n          voltageRange: viewfinderVoltageInput.value,\n          type: viewfinderPortTypeInput.value\n        },\n        output: null\n      },\n      video: {\n        inputs: getViewfinderVideoInputs(),\n        outputs: getViewfinderVideoOutputs()\n      },\n      wirelessTx: viewfinderWirelessTxInput.checked,\n      latencyMs: viewfinderWirelessTxInput.checked ? viewfinderLatencyInput.value : undefined\n    };\n    Object.assign(targetCategory[name], collectDynamicFieldValues(category, categoryExcludedAttrs[category] || []));\n  } else if (category === \"video\" || category === \"wirelessReceivers\" || category === \"iosVideo\") {\n    const watt = parseFloat(newWattInput.value);\n    if (isNaN(watt) || watt <= 0) {\n      alert(texts[currentLang].alertDeviceWatt);\n      return;\n    }\n    targetCategory[name] = {\n      powerDrawWatts: watt,\n      power: { input: { type: videoPowerInput.value } },\n      videoInputs: getVideoInputs(),\n      videoOutputs: getVideoOutputsIO(),\n      frequency: videoFrequencyInput.value,\n      latencyMs: videoLatencyInput.value\n    };\n    Object.assign(targetCategory[name], collectDynamicFieldValues(category, categoryExcludedAttrs[category] || []));\n  } else if (category === \"fiz.motors\") {\n    const watt = parseFloat(newWattInput.value);\n    if (isNaN(watt) || watt <= 0) {\n      alert(texts[currentLang].alertDeviceWatt);\n      return;\n    }\n    targetCategory[name] = {\n      powerDrawWatts: watt,\n      fizConnector: motorConnectorInput.value,\n      internalController: motorInternalInput.checked,\n      torqueNm: motorTorqueInput.value ? parseFloat(motorTorqueInput.value) : null,\n      gearTypes: motorGearInput.value ? motorGearInput.value.split(',').map(s => s.trim()).filter(Boolean) : [],\n      notes: motorNotesInput.value\n    };\n    Object.assign(targetCategory[name], collectDynamicFieldValues(category, categoryExcludedAttrs[category] || []));\n  } else if (category === \"fiz.controllers\") {\n    const watt = parseFloat(newWattInput.value);\n    if (isNaN(watt) || watt <= 0) {\n      alert(texts[currentLang].alertDeviceWatt);\n      return;\n    }\n    targetCategory[name] = {\n      powerDrawWatts: watt,\n      fizConnector: controllerConnectorInput.value,\n      powerSource: controllerPowerInput.value,\n      batteryType: controllerBatteryInput.value,\n      connectivity: controllerConnectivityInput.value,\n      notes: controllerNotesInput.value\n    };\n    Object.assign(targetCategory[name], collectDynamicFieldValues(category, categoryExcludedAttrs[category] || []));\n  } else if (category === \"fiz.distance\") {\n    const watt = parseFloat(newWattInput.value);\n    if (isNaN(watt) || watt <= 0) {\n      alert(texts[currentLang].alertDeviceWatt);\n      return;\n    }\n    targetCategory[name] = {\n      powerDrawWatts: watt,\n      connectionCompatibility: distanceConnectionInput.value,\n      measurementMethod: distanceMethodInput.value,\n      measurementRange: distanceRangeInput.value,\n      accuracy: distanceAccuracyInput.value,\n      outputDisplay: distanceOutputInput.value,\n      notes: distanceNotesInput.value\n    };\n    Object.assign(targetCategory[name], collectDynamicFieldValues(category, categoryExcludedAttrs[category] || []));\n  } else {\n    const watt = parseFloat(newWattInput.value);\n    if (isNaN(watt) || watt <= 0) {\n      alert(texts[currentLang].alertDeviceWatt);\n      return;\n    }\n    const existing = editingSamePath && originalDeviceData ? { ...originalDeviceData } : {};\n    const attrs = collectDynamicFieldValues(category, categoryExcludedAttrs[category] || []);\n    targetCategory[name] = { ...existing, ...attrs, powerDrawWatts: watt };\n  }\n\n  if (isEditing) {\n    removeOriginalDeviceEntry(\n      storedOriginalCategory,\n      storedOriginalSubcategory,\n      originalName,\n      category,\n      subcategory,\n      name\n    );\n    addDeviceBtn.dataset.originalCategory = category;\n    if (category === \"accessories.cables\" && subcategory) {\n      addDeviceBtn.dataset.originalSubcategory = subcategory;\n    } else {\n      delete addDeviceBtn.dataset.originalSubcategory;\n    }\n    addDeviceBtn.dataset.originalName = name;\n  }\n\n  // After adding/updating, reset form and refresh lists\n  resetDeviceForm();\n\n  storeDevices(devices);\n  viewfinderTypeOptions = getAllViewfinderTypes();\n  viewfinderConnectorOptions = getAllViewfinderConnectors();\n  updatePlateTypeOptions();\n  updatePowerPortOptions();\n  updatePowerDistTypeOptions();\n  updatePowerDistVoltageOptions();\n  updatePowerDistCurrentOptions();\n  updateRecordingMediaOptions();\n  updateTimecodeTypeOptions();\n  refreshDeviceLists();\n  // Re-populate all dropdowns to include the new/updated device\n  populateSelect(cameraSelect, devices.cameras, true);\n  populateMonitorSelect();\n  populateSelect(videoSelect, devices.video, true);\n  motorSelects.forEach(sel => populateSelect(sel, devices.fiz.motors, true));\n  controllerSelects.forEach(sel => populateSelect(sel, devices.fiz.controllers, true));\n  populateSelect(distanceSelect, devices.fiz.distance, true);\n  populateSelect(batterySelect, devices.batteries, true);\n  updateFizConnectorOptions();\n  applyFilters();\n  updateCalculations(); // Update calculations after device data changes\n\n  let categoryKey = category.replace(\".\", \"_\");\n  let categoryDisplay = texts[currentLang][\"category_\" + categoryKey] || category;\n  if (isEditing) {\n      alert(texts[currentLang].alertDeviceUpdated.replace(\"{name}\", name).replace(\"{category}\", categoryDisplay));\n  } else {\n      alert(texts[currentLang].alertDeviceAdded.replace(\"{name}\", name).replace(\"{category}\", categoryDisplay));\n  }\n});\n\n// Cancel editing and revert form to add mode\ncancelEditBtn.addEventListener(\"click\", () => {\n  resetDeviceForm();\n});\n\n// Export device data\nexportBtn.addEventListener(\"click\", () => {\n  const dataStr = JSON.stringify(devices, null, 2);\n  exportOutput.style.display = \"block\";\n  exportOutput.value = dataStr;\n  const blob = new Blob([dataStr], { type: \"application/json\" });\n  const url = URL.createObjectURL(blob);\n  const a = document.createElement(\"a\");\n  a.href = url;\n  a.download = \"device_data_export.json\";\n  document.body.appendChild(a);\n  a.click();\n  document.body.removeChild(a);\n  URL.revokeObjectURL(url);\n});\n\nconst exportAndRevertBtn = document.getElementById('exportAndRevertBtn'); \n\nif (exportAndRevertBtn) {\n  exportAndRevertBtn.addEventListener('click', () => {\n    // Step 1: Export the current database\n    if (confirm(texts[currentLang].confirmExportAndRevert)) { // Confirmation for both actions\n      // Reusing the export logic from the existing 'Export Database' button\n      const dataStr = JSON.stringify(devices, null, 2);\n      // For simplicity, let's just trigger a download directly.\n      const blob = new Blob([dataStr], { type: \"application/json\" });\n      const url = URL.createObjectURL(blob);\n      const a = document.createElement(\"a\");\n      a.href = url;\n      a.download = \"device_data_backup_before_revert.json\"; // Suggests it's a backup\n      document.body.appendChild(a);\n      a.click();\n      document.body.removeChild(a);\n      URL.revokeObjectURL(url);\n\n      // Give a small delay to ensure download prompt appears before next step\n      const revertTimer = setTimeout(() => {\n        // Step 2: Remove saved database and reload page so device files are re-read\n        localStorage.removeItem('cameraPowerPlanner_devices');\n        alert(texts[currentLang].alertExportAndRevertSuccess);\n        location.reload();\n      }, 500); // 500ms delay\n      if (typeof revertTimer.unref === 'function') {\n        revertTimer.unref();\n      }\n    }\n  });\n}\n\n// Import device data\nimportDataBtn.addEventListener(\"click\", () => {\n  importFileInput.click(); // Trigger the file input click\n});\n\nimportFileInput.addEventListener(\"change\", (event) => {\n  const file = event.target.files[0];\n  if (!file) {\n    return;\n  }\n\n  const reader = new FileReader();\n  reader.onload = (e) => {\n    try {\n      const importedData = JSON.parse(e.target.result);\n      const result = parseDeviceDatabaseImport(importedData);\n\n      if (!result.devices) {\n        const summary = formatDeviceImportErrors(result.errors);\n        console.error('Device import validation failed:', result.errors);\n        alert(summary ? `${texts[currentLang].alertImportError}\\n${summary}` : texts[currentLang].alertImportError);\n        return;\n      }\n\n      devices = result.devices; // Overwrite current devices with imported data\n      unifyDevices(devices);\n      storeDevices(devices);\n      viewfinderTypeOptions = getAllViewfinderTypes();\n      viewfinderConnectorOptions = getAllViewfinderConnectors();\n      refreshDeviceLists(); // Update device manager lists\n      // Re-populate all dropdowns and update calculations\n      populateSelect(cameraSelect, devices.cameras, true);\n      populateMonitorSelect();\n      populateSelect(videoSelect, devices.video, true);\n      motorSelects.forEach(sel => populateSelect(sel, devices.fiz.motors, true));\n      controllerSelects.forEach(sel => populateSelect(sel, devices.fiz.controllers, true));\n      populateSelect(distanceSelect, devices.fiz.distance, true);\n      populateSelect(batterySelect, devices.batteries, true);\n      updateFizConnectorOptions();\n      updateMotorConnectorOptions();\n      updateControllerConnectorOptions();\n      updateControllerPowerOptions();\n      updateControllerBatteryOptions();\n      updateControllerConnectivityOptions();\n      updateDistanceConnectionOptions();\n      updateDistanceMethodOptions();\n      updateDistanceDisplayOptions();\n      applyFilters();\n      updateCalculations();\n\n      const deviceCount = countDeviceDatabaseEntries(devices);\n      alert(texts[currentLang].alertImportSuccess.replace(\"{num_devices}\", deviceCount));\n      exportOutput.style.display = \"block\"; // Show the textarea\n      exportOutput.value = JSON.stringify(devices, null, 2); // Display the newly imported data\n    } catch (error) {\n      console.error(\"Error parsing or importing data:\", error);\n      const errorMessage = error && error.message ? error.message : String(error);\n      const summary = formatDeviceImportErrors([errorMessage]);\n      alert(summary ? `${texts[currentLang].alertImportError}\\n${summary}` : texts[currentLang].alertImportError);\n    }\n  };\n  reader.readAsText(file);\n  event.target.value = ''; // Clear the file input for re-selection of the same file\n});\n\n\n\n// --- NEW SETUP MANAGEMENT FUNCTIONS ---\n\n// Generate a printable overview of the current selected setup in a new tab\ngenerateOverviewBtn.addEventListener('click', () => {\n    if (!setupSelect.value) { // Ensure a setup is selected\n        alert(texts[currentLang].alertSelectSetupForOverview);\n        return;\n    }\n    generatePrintableOverview();\n});\n\nfunction batteryPinsSufficient() {\n    const batt = batterySelect && batterySelect.value;\n    if (!batt || batt === 'None' || !devices.batteries[batt]) return true;\n    const battData = devices.batteries[batt];\n    const totalCurrentLow = parseFloat(totalCurrent12Elem.textContent);\n    if (!isFinite(totalCurrentLow)) return true;\n    return totalCurrentLow <= battData.pinA;\n}\n\nfunction alertPinExceeded() {\n    const batt = batterySelect && batterySelect.value;\n    if (!batt || batt === 'None' || !devices.batteries[batt]) return;\n    const battData = devices.batteries[batt];\n    const totalCurrentLow = parseFloat(totalCurrent12Elem.textContent);\n    alert(\n        texts[currentLang].warnPinExceeded\n            .replace('{current}', totalCurrentLow.toFixed(2))\n            .replace('{max}', battData.pinA)\n    );\n}\n\n// Generate a printable gear list for the current setup\ngenerateGearListBtn.addEventListener('click', () => {\n    if (!setupSelect.value) {\n        alert(texts[currentLang].alertSelectSetupForOverview);\n        return;\n    }\n    if (!batteryPinsSufficient()) {\n        alertPinExceeded();\n        return;\n    }\n    populateRecordingResolutionDropdown(currentProjectInfo && currentProjectInfo.recordingResolution);\n    populateSensorModeDropdown(currentProjectInfo && currentProjectInfo.sensorMode);\n    populateCodecDropdown(currentProjectInfo && currentProjectInfo.codec);\n    openDialog(projectDialog);\n});\n\nif (deleteGearListProjectBtn) {\n    deleteGearListProjectBtn.addEventListener('click', () => {\n        deleteCurrentGearList();\n    });\n}\n\nif (projectCancelBtn) {\n    projectCancelBtn.addEventListener('click', () => {\n        closeDialog(projectDialog);\n    });\n}\n\nif (projectDialogCloseBtn) {\n    projectDialogCloseBtn.addEventListener('click', () => {\n        if (projectCancelBtn) {\n            projectCancelBtn.click();\n        } else {\n            closeDialog(projectDialog);\n        }\n    });\n}\n\nif (projectForm) {\n    projectForm.addEventListener('submit', e => {\n        e.preventDefault();\n        if (!batteryPinsSufficient()) {\n            alertPinExceeded();\n            return;\n        }\n        const info = collectProjectFormData();\n        currentProjectInfo = info;\n        ensureZoomRemoteSetup(info);\n        const html = generateGearListHtml(info);\n        displayGearAndRequirements(html);\n        ensureGearListActions();\n        bindGearListCageListener();\n        bindGearListEasyrigListener();\n        bindGearListSliderBowlListener();\n        bindGearListEyeLeatherListener();\n        bindGearListProGaffTapeListener();\n        bindGearListDirectorMonitorListener();\n        // Persist the generated gear list and current project name so that\n        // a page reload can restore the visible gear list without requiring\n        // any additional user action.\n        saveCurrentSession();\n        scheduleProjectAutoSave(true);\n        closeDialog(projectDialog);\n    });\n}\n\nfunction downloadSharedProject(shareFileName, includeAutoGear) {\n  if (!shareFileName) return;\n  const setupName = getCurrentProjectName();\n  const currentSetup = {\n    setupName,\n    camera: cameraSelect.value,\n    monitor: monitorSelect.value,\n    video: videoSelect.value,\n    cage: cageSelect.value,\n    motors: motorSelects.map(sel => sel.value),\n    controllers: controllerSelects.map(sel => sel.value),\n    distance: distanceSelect.value,\n    batteryPlate: batteryPlateSelect.value,\n    battery: batterySelect.value,\n    batteryHotswap: hotswapSelect.value\n  };\n  if (currentProjectInfo) {\n    currentSetup.projectInfo = currentProjectInfo;\n  } else {\n    const project = typeof loadProject === 'function' ? loadProject(setupName) : null;\n    if (project && project.projectInfo) {\n      currentSetup.projectInfo = project.projectInfo;\n    }\n  }\n  const gearSelectors = getGearListSelectors();\n  if (Object.keys(gearSelectors).length) {\n    currentSetup.gearSelectors = gearSelectors;\n  }\n  const combinedHtml = getCurrentGearListHtml();\n  if (combinedHtml) {\n    const { projectHtml, gearHtml } = splitGearListHtml(combinedHtml);\n    if (projectHtml) currentSetup.projectHtml = projectHtml;\n    if (gearHtml) {\n      currentSetup.gearList = projectHtml\n        ? gearHtml.replace(/<h2[^>]*>.*?<\\/h2>/, '')\n        : gearHtml;\n    }\n  }\n  const deviceChanges = getDeviceChanges();\n  if (Object.keys(deviceChanges).length) {\n    currentSetup.changedDevices = deviceChanges;\n  }\n  const key = getCurrentSetupKey();\n  const feedback = loadFeedbackSafe()[key] || [];\n  if (feedback.length) {\n    currentSetup.feedback = feedback;\n  }\n  const rulesForShare = getAutoGearRules();\n  const hasAutoGearRules = Array.isArray(rulesForShare) && rulesForShare.length > 0;\n  if (includeAutoGear && hasAutoGearRules) {\n    currentSetup.autoGearRules = rulesForShare;\n  }\n  const notifyShareFailure = error => {\n    if (error) {\n      console.warn('Project export failed', error);\n    } else {\n      console.warn('Project export failed');\n    }\n    const failureMessage = getLocalizedText('shareExportFailed') || 'Project export failed.';\n    if (shareLinkMessage) {\n      shareLinkMessage.textContent = failureMessage;\n      setStatusLevel(shareLinkMessage, 'danger');\n      shareLinkMessage.classList.remove('hidden');\n      if (typeof setTimeout === 'function') {\n        setTimeout(() => shareLinkMessage.classList.add('hidden'), 6000);\n      }\n    } else if (typeof alert === 'function') {\n      alert(failureMessage);\n    }\n  };\n\n  let json;\n  try {\n    json = JSON.stringify(currentSetup, null, 2);\n  } catch (serializationError) {\n    console.error('Failed to serialize shared project', serializationError);\n    notifyShareFailure(serializationError);\n    return;\n  }\n\n  const downloaded = downloadBackupPayload(json, shareFileName);\n\n  if (shareIncludeAutoGearCheckbox) {\n    shareIncludeAutoGearCheckbox.checked = includeAutoGear && hasAutoGearRules;\n  }\n\n  if (!downloaded) {\n    notifyShareFailure();\n    return;\n  }\n\n  if (shareLinkMessage) {\n    shareLinkMessage.textContent = texts[currentLang].shareLinkCopied;\n    setStatusLevel(shareLinkMessage, 'success');\n    shareLinkMessage.classList.remove('hidden');\n    if (typeof setTimeout === 'function') {\n      setTimeout(() => shareLinkMessage.classList.add('hidden'), 4000);\n    }\n  }\n}\n\nshareSetupBtn.addEventListener('click', () => {\n  saveCurrentGearList();\n  const setupName = getCurrentProjectName();\n  const defaultName = getDefaultShareFilename(setupName);\n  const defaultFilename = ensureJsonExtension(defaultName);\n\n  if (!shareDialog || !shareForm || !shareFilenameInput) {\n    const shareFileName = promptForSharedFilename(setupName);\n    if (!shareFileName) {\n      return;\n    }\n    const rulesForShare = getAutoGearRules();\n    const hasAutoGearRules = Array.isArray(rulesForShare) && rulesForShare.length > 0;\n    const includeAutoGear = hasAutoGearRules\n      ? confirmAutoGearSelection(\n          shareIncludeAutoGearCheckbox ? shareIncludeAutoGearCheckbox.checked : false\n        )\n      : false;\n    if (shareIncludeAutoGearCheckbox) {\n      shareIncludeAutoGearCheckbox.checked = includeAutoGear && hasAutoGearRules;\n    }\n    downloadSharedProject(shareFileName, includeAutoGear);\n    return;\n  }\n\n  shareFilenameInput.value = defaultFilename;\n  shareFilenameInput.setCustomValidity('');\n\n  if (shareFilenameMessage) {\n    const template = getLocalizedText('shareFilenamePrompt') || '';\n    shareFilenameMessage.textContent = template.includes('{defaultName}')\n      ? template.replace('{defaultName}', defaultName)\n      : template;\n  }\n\n  const rulesForShare = getAutoGearRules();\n  const hasAutoGearRules = Array.isArray(rulesForShare) && rulesForShare.length > 0;\n  if (shareIncludeAutoGearCheckbox) {\n    shareIncludeAutoGearCheckbox.disabled = !hasAutoGearRules;\n    shareIncludeAutoGearCheckbox.setAttribute('aria-disabled', hasAutoGearRules ? 'false' : 'true');\n    if (!hasAutoGearRules) {\n      shareIncludeAutoGearCheckbox.checked = false;\n    }\n  }\n  if (shareIncludeAutoGearLabelElem) {\n    shareIncludeAutoGearLabelElem.classList.toggle('disabled', !hasAutoGearRules);\n    shareIncludeAutoGearLabelElem.setAttribute('aria-disabled', !hasAutoGearRules ? 'true' : 'false');\n  }\n\n  openDialog(shareDialog);\n  if (typeof requestAnimationFrame === 'function') {\n    requestAnimationFrame(() => {\n      if (shareFilenameInput) {\n        shareFilenameInput.focus();\n        shareFilenameInput.select();\n      }\n    });\n  } else if (shareFilenameInput) {\n    setTimeout(() => {\n      shareFilenameInput.focus();\n      shareFilenameInput.select();\n    }, 0);\n  }\n});\n\nif (shareForm) {\n  shareForm.addEventListener('submit', event => {\n    event.preventDefault();\n    if (!shareFilenameInput) return;\n    const sanitized = sanitizeShareFilename(shareFilenameInput.value);\n    if (!sanitized) {\n      const invalidMessage =\n        getLocalizedText('shareFilenameInvalid')\n        || 'Please enter a valid file name to continue.';\n      shareFilenameInput.setCustomValidity(invalidMessage);\n      shareFilenameInput.reportValidity();\n      return;\n    }\n    shareFilenameInput.setCustomValidity('');\n    const shareFileName = ensureJsonExtension(sanitized);\n    const includeAutoGear = !!(\n      shareIncludeAutoGearCheckbox\n      && !shareIncludeAutoGearCheckbox.disabled\n      && shareIncludeAutoGearCheckbox.checked\n    );\n    closeDialog(shareDialog);\n    downloadSharedProject(shareFileName, includeAutoGear);\n  });\n}\n\nif (shareCancelBtn) {\n  shareCancelBtn.addEventListener('click', () => {\n    if (shareFilenameInput) {\n      shareFilenameInput.setCustomValidity('');\n    }\n    closeDialog(shareDialog);\n  });\n}\n\nif (shareDialog) {\n  shareDialog.addEventListener('cancel', event => {\n    event.preventDefault();\n    if (shareFilenameInput) {\n      shareFilenameInput.setCustomValidity('');\n    }\n    closeDialog(shareDialog);\n  });\n}\n\nif (sharedLinkInput) {\n  sharedLinkInput.addEventListener('change', () => {\n    if (pendingSharedLinkListener) return;\n    const file = sharedLinkInput.files && sharedLinkInput.files[0];\n    if (file) {\n      readSharedProjectFile(file);\n    }\n  });\n}\n\nif (applySharedLinkBtn && sharedLinkInput) {\n  applySharedLinkBtn.addEventListener('click', () => {\n    if (pendingSharedLinkListener) {\n      sharedLinkInput.removeEventListener('change', pendingSharedLinkListener);\n      pendingSharedLinkListener = null;\n    }\n    const handleSelection = () => {\n      sharedLinkInput.removeEventListener('change', handleSelection);\n      pendingSharedLinkListener = null;\n      const file = sharedLinkInput.files && sharedLinkInput.files[0];\n      if (file) {\n        readSharedProjectFile(file);\n      }\n    };\n    pendingSharedLinkListener = handleSelection;\n    sharedLinkInput.addEventListener('change', handleSelection);\n    sharedLinkInput.value = '';\n    sharedLinkInput.click();\n    if (sharedLinkInput.files && sharedLinkInput.files.length) {\n      handleSelection();\n    }\n  });\n}\n\nif (sharedImportModeSelect) {\n  sharedImportModeSelect.addEventListener('change', () => {\n    if (sharedImportPromptActive) return;\n    if (lastSharedSetupData === null) return;\n    reapplySharedImportSelection();\n  });\n}\n\nif (sharedImportForm) {\n  sharedImportForm.addEventListener('submit', event => {\n    event.preventDefault();\n    finalizeSharedImportPrompt();\n    applyStoredSharedImport();\n  });\n}\n\nif (sharedImportCancelBtn) {\n  sharedImportCancelBtn.addEventListener('click', () => {\n    finalizeSharedImportPrompt();\n    clearStoredSharedImportData();\n  });\n}\n\nif (sharedImportDialog) {\n  sharedImportDialog.addEventListener('cancel', event => {\n    event.preventDefault();\n    finalizeSharedImportPrompt();\n    clearStoredSharedImportData();\n  });\n}\n\n// Open feedback dialog and handle submission\nif (runtimeFeedbackBtn && feedbackDialog && feedbackForm) {\n  runtimeFeedbackBtn.addEventListener('click', () => {\n    const today = new Date().toISOString().split('T')[0];\n    const motVals = motorSelects.map(sel => sel.value).filter(v => v && v !== 'None');\n    const ctrlVals = controllerSelects.map(sel => sel.value).filter(v => v && v !== 'None');\n    document.getElementById('fbDate').value = today;\n    document.getElementById('fbCamera').value = cameraSelect.value || '';\n    document.getElementById('fbBatteryPlate').value = getSelectedPlate() || '';\n    document.getElementById('fbBattery').value = batterySelect.value || '';\n    document.getElementById('fbWirelessVideo').value = videoSelect.value || '';\n    document.getElementById('fbMonitor').value = monitorSelect.value || '';\n    const cam = devices?.cameras?.[cameraSelect.value];\n    document.getElementById('fbResolution').value = cam?.resolutions?.[0] || '';\n    document.getElementById('fbCodec').value = cam?.recordingCodecs?.[0] || '';\n    document.getElementById('fbControllers').value = ctrlVals.join(', ');\n    document.getElementById('fbMotors').value = motVals.join(', ');\n    const fbDistance = document.getElementById('fbDistance');\n    if (fbDistance && distanceSelect) {\n      fbDistance.innerHTML = distanceSelect.innerHTML;\n      fbDistance.value = distanceSelect.value || '';\n    }\n    openDialog(feedbackDialog);\n  });\n\n  feedbackCancelBtn.addEventListener('click', () => {\n    closeDialog(feedbackDialog);\n  });\n\n  if (feedbackUseLocationBtn) {\n    feedbackUseLocationBtn.addEventListener('click', () => {\n      const locationInput = document.getElementById('fbLocation');\n      if (!navigator.geolocation) {\n        alert('Geolocation is not supported by your browser');\n        return;\n      }\n      feedbackUseLocationBtn.disabled = true;\n      navigator.geolocation.getCurrentPosition(\n        pos => {\n          const { latitude, longitude } = pos.coords;\n          locationInput.value = `${latitude.toFixed(5)}, ${longitude.toFixed(5)}`;\n          feedbackUseLocationBtn.disabled = false;\n        },\n        () => {\n          feedbackUseLocationBtn.disabled = false;\n          alert('Unable to retrieve your location');\n        }\n      );\n    });\n  }\n\n  feedbackForm.addEventListener('submit', e => {\n    e.preventDefault();\n    const entry = {\n      username: document.getElementById('fbUsername').value.trim(),\n      date: document.getElementById('fbDate').value,\n      location: document.getElementById('fbLocation').value.trim(),\n      camera: document.getElementById('fbCamera').value.trim(),\n      batteryPlate: document.getElementById('fbBatteryPlate').value.trim(),\n      lensMount: document.getElementById('fbLensMount').value.trim(),\n      resolution: document.getElementById('fbResolution').value.trim(),\n      codec: document.getElementById('fbCodec').value.trim(),\n      framerate: document.getElementById('fbFramerate').value.trim(),\n      cameraWifi: document.getElementById('fbWifi').value,\n      firmware: document.getElementById('fbFirmware').value.trim(),\n      battery: document.getElementById('fbBattery').value.trim(),\n      batteryAge: document.getElementById('fbBatteryAge').value.trim(),\n      wirelessVideo: document.getElementById('fbWirelessVideo').value.trim(),\n      monitor: document.getElementById('fbMonitor').value.trim(),\n      monitorBrightness: document.getElementById('fbMonitorBrightness').value.trim(),\n      lens: document.getElementById('fbLens').value.trim(),\n      lensData: document.getElementById('fbLensData').value.trim(),\n      controllers: document.getElementById('fbControllers').value.trim(),\n      motors: document.getElementById('fbMotors').value.trim(),\n      distance: document.getElementById('fbDistance').value.trim(),\n      temperature: document.getElementById('fbTemperature').value.trim(),\n      charging: document.getElementById('fbCharging').value.trim(),\n      runtime: document.getElementById('fbRuntime').value.trim(),\n      batteriesPerDay: document.getElementById('fbBatteriesPerDay').value.trim()\n    };\n    const key = getCurrentSetupKey();\n    const feedback = loadFeedbackSafe();\n    if (!feedback[key]) feedback[key] = [];\n    feedback[key].push(entry);\n    saveFeedbackSafe(feedback);\n    const lines = [];\n    Object.entries(entry).forEach(([k, v]) => {\n      lines.push(`${k}: ${v}`);\n    });\n    const subject = encodeURIComponent('Cine Power Planner Runtime Feedback');\n    const body = encodeURIComponent(lines.join('\\n'));\n    window.location.href = `mailto:info@lucazanner.de?subject=${subject}&body=${body}`;\n    closeDialog(feedbackDialog);\n    updateCalculations();\n  });\n}\n\n\nfunction summarizeByType(list) {\n    if (!Array.isArray(list)) return {};\n    return list.reduce((counts, it) => {\n        if (it?.type) {\n            counts[it.type] = (counts[it.type] || 0) + 1;\n        }\n        return counts;\n    }, {});\n}\n\nfunction connectorBlocks(items, icon, cls = 'neutral-conn', label = '', dir = '') {\n  if (!Array.isArray(items) || items.length === 0) return '';\n  const counts = summarizeByType(items);\n  const entries = Object.entries(counts).map(([type, count]) => {\n    return `${escapeHtml(type)}${count > 1 ? ` \xD7${count}` : ''}`;\n  });\n  if (!entries.length) return '';\n  const prefix = label ? `${label}${dir ? ` ${dir}` : ''}: ` : '';\n  const iconHtml = iconMarkup(icon, 'connector-icon');\n  return `<span class=\"connector-block ${cls}\">${iconHtml}${prefix}${entries.join(', ')}</span>`;\n}\n\nfunction generateConnectorSummary(device) {\n  if (!device || typeof device !== 'object') return '';\n\n  let portHtml = '';\n  const connectors = [\n    { items: device.power?.powerDistributionOutputs, icon: diagramConnectorIcons.powerOut, cls: 'power-conn', label: 'Power', dir: 'Out' },\n    { items: powerInputTypes(device).map(t => ({ type: t })), icon: diagramConnectorIcons.powerIn, cls: 'power-conn', label: 'Power', dir: 'In' },\n    { items: device.fizConnectors, icon: diagramConnectorIcons.fiz, cls: 'fiz-conn', label: 'FIZ Port' },\n    { items: device.video?.inputs || device.videoInputs, icon: diagramConnectorIcons.video, cls: 'video-conn', label: 'Video', dir: 'In' },\n    { items: device.video?.outputs || device.videoOutputs, icon: diagramConnectorIcons.video, cls: 'video-conn', label: 'Video', dir: 'Out' },\n    { items: device.timecode, icon: diagramConnectorIcons.timecode, cls: 'neutral-conn', label: 'Timecode' },\n    { items: device.audioInput?.portType ? [{ type: device.audioInput.portType }] : undefined, icon: diagramConnectorIcons.audioIn, cls: 'neutral-conn', label: 'Audio', dir: 'In' },\n    { items: device.audioOutput?.portType ? [{ type: device.audioOutput.portType }] : undefined, icon: diagramConnectorIcons.audioOut, cls: 'neutral-conn', label: 'Audio', dir: 'Out' },\n    { items: device.audioIo?.portType ? [{ type: device.audioIo.portType }] : undefined, icon: diagramConnectorIcons.audioIo, cls: 'neutral-conn', label: 'Audio', dir: 'I/O' },\n  ];\n\n  for (const { items, icon, cls, label, dir } of connectors) {\n    portHtml += connectorBlocks(items, icon, cls, label, dir);\n  }\n\n  let specHtml = '';\n  if (typeof device.powerDrawWatts === 'number') {\n    specHtml += `<span class=\"info-box power-conn\">${iconMarkup(diagramConnectorIcons.powerSpec)}Power: ${device.powerDrawWatts} W</span>`;\n  }\n  if (device.power?.input?.voltageRange) {\n    specHtml += `<span class=\"info-box power-conn\">${iconMarkup(ICON_GLYPHS.batteryBolt)}Voltage: ${escapeHtml(String(device.power.input.voltageRange))}V</span>`;\n  }\n  if (typeof device.weight_g === 'number') {\n    const weightLabel = `${device.weight_g} g`;\n    specHtml += `<span class=\"info-box neutral-conn\">${iconMarkup(ICON_GLYPHS.gears)}Weight: ${escapeHtml(weightLabel)}</span>`;\n  }\n  if (typeof device.capacity === 'number') {\n        specHtml += `<span class=\"info-box power-conn\">${iconMarkup(ICON_GLYPHS.batteryFull)}Capacity: ${device.capacity} Wh</span>`;\n    }\n    if (typeof device.pinA === 'number') {\n        specHtml += `<span class=\"info-box power-conn\">Pins: ${device.pinA}A</span>`;\n    }\n    if (typeof device.dtapA === 'number') {\n        specHtml += `<span class=\"info-box power-conn\">D-Tap: ${device.dtapA}A</span>`;\n    }\n    if (device.mount_type) {\n        specHtml += `<span class=\"info-box power-conn\">Mount: ${escapeHtml(String(device.mount_type))}</span>`;\n    }\n  if (typeof device.screenSizeInches === 'number') {\n    specHtml += `<span class=\"info-box video-conn\">${iconMarkup(DIAGRAM_MONITOR_ICON)}Screen: ${device.screenSizeInches}\"</span>`;\n  }\n    if (typeof device.brightnessNits === 'number') {\n        specHtml += `<span class=\"info-box video-conn\">${iconMarkup(ICON_GLYPHS.brightness)}Brightness: ${device.brightnessNits} nits</span>`;\n    }\n  if (typeof device.wirelessTx === 'boolean') {\n    specHtml += `<span class=\"info-box video-conn\">${iconMarkup(ICON_GLYPHS.wifi)}Wireless: ${device.wirelessTx}</span>`;\n  }\n  if (device.internalController) {\n    specHtml += `<span class=\"info-box fiz-conn\">${iconMarkup(diagramConnectorIcons.controller)}Controller: Internal</span>`;\n  }\n  if (typeof device.torqueNm === 'number') {\n    specHtml += `<span class=\"info-box fiz-conn\">${iconMarkup(diagramConnectorIcons.torque)}Torque: ${device.torqueNm} Nm</span>`;\n  }\n  if (device.powerSource) {\n    specHtml += `<span class=\"info-box power-conn\">${iconMarkup(diagramConnectorIcons.powerSource)}Power Source: ${escapeHtml(String(device.powerSource))}</span>`;\n  }\n\n  const uniqueList = list => {\n    if (!Array.isArray(list)) return [];\n    const seen = new Set();\n    const values = [];\n    list.forEach(entry => {\n      const str = entry != null ? String(entry).trim() : '';\n      if (!str || seen.has(str)) return;\n      seen.add(str);\n      values.push(escapeHtml(str));\n    });\n    return values;\n  };\n\n  const appendListBox = (html, values, label, cls, icon) => {\n    const formatted = uniqueList(values);\n    if (!formatted.length) return html;\n    const iconHtml = iconMarkup(icon);\n    const labelHtml = `<span class=\"info-box-label\">${label}:</span>`;\n    const valuesHtml = `<span class=\"info-box-values\">${formatted.join(', ')}</span>`;\n    return `${html}<span class=\"info-box ${cls} info-box-list\">${iconHtml}${labelHtml}${valuesHtml}</span>`;\n  };\n\n  let recordingHtml = '';\n  if (Array.isArray(device.sensorModes)) {\n    recordingHtml = appendListBox(recordingHtml, device.sensorModes, 'Sensor Modes', 'video-conn', ICON_GLYPHS.sensor);\n  }\n  if (Array.isArray(device.resolutions)) {\n    recordingHtml = appendListBox(recordingHtml, device.resolutions, 'Resolutions', 'video-conn', ICON_GLYPHS.screen);\n  }\n  if (Array.isArray(device.recordingCodecs)) {\n    recordingHtml = appendListBox(recordingHtml, device.recordingCodecs, 'Codecs', 'video-conn', ICON_GLYPHS.camera);\n  }\n  if (Array.isArray(device.recordingMedia)) {\n    const mediaTypes = device.recordingMedia\n      .map(item => (item && item.type ? item.type : ''));\n    recordingHtml = appendListBox(recordingHtml, mediaTypes, 'Media', 'video-conn', ICON_GLYPHS.save);\n  }\n\n    let extraHtml = '';\n    if (Array.isArray(device.power?.batteryPlateSupport) && device.power.batteryPlateSupport.length) {\n        const types = device.power.batteryPlateSupport.map(p => {\n            const mount = p.mount ? ` (${escapeHtml(p.mount)})` : '';\n            return `${escapeHtml(p.type)}${mount}`;\n        });\n        extraHtml += `<span class=\"info-box power-conn\">Battery Plate: ${types.join(', ')}</span>`;\n    }\n    if (Array.isArray(device.viewfinder) && device.viewfinder.length) {\n        const types = device.viewfinder.map(v => escapeHtml(v.type));\n        extraHtml += `<span class=\"info-box video-conn\">Viewfinder: ${types.join(', ')}</span>`;\n    }\n    if (Array.isArray(device.gearTypes) && device.gearTypes.length) {\n        const types = device.gearTypes.map(g => escapeHtml(g));\n        extraHtml += `<span class=\"info-box fiz-conn\">Gear: ${types.join(', ')}</span>`;\n    }\n    if (device.connectivity) {\n        extraHtml += `<span class=\"info-box video-conn\">Connectivity: ${escapeHtml(String(device.connectivity))}</span>`;\n    }\n    if (device.notes) {\n        extraHtml += `<span class=\"info-box neutral-conn\">Notes: ${escapeHtml(String(device.notes))}</span>`;\n    }\n\n    let lensHtml = '';\n    if (Array.isArray(device.lensMount)) {\n        const boxes = device.lensMount.map(lm => {\n            const mount = lm.mount ? ` (${escapeHtml(lm.mount)})` : '';\n            return `<span class=\"info-box neutral-conn\">${escapeHtml(lm.type)}${mount}</span>`;\n        }).join('');\n        if (boxes) lensHtml = `<div class=\"lens-mount-box\">${boxes}</div>`;\n    }\n\n    let html = '';\n    const section = (label, content) => {\n        if (!content) return '';\n        return `<div class=\"info-label\">${label}</div>${content}`;\n    };\n\n    html += section('Ports', portHtml);\n    html += section('Specs', specHtml);\n    html += section('Recording', recordingHtml);\n    html += section('Extras', extraHtml);\n    if (lensHtml) html += `<div class=\"info-label\">Lens Mount</div>${lensHtml}`;\n\n    return html ? `<div class=\"connector-summary\">${html}</div>` : '';\n}\n\n\nfunction suggestChargerCounts(total) {\n    let quad = Math.floor(total / 4);\n    const remainder = total % 4;\n    let dual = 0;\n    let single = 0;\n    if (remainder === 0) {\n        // nothing\n    } else if (remainder === 3) {\n        quad += 1;\n    } else if (remainder > 0) {\n        dual += 1;\n    }\n    return { quad, dual, single };\n}\n\nfunction addArriKNumber(name) {\n    if (!name) return name;\n    const d = typeof devices !== 'undefined' ? devices : {};\n    const collections = [\n        d.viewfinders,\n        d.directorMonitors,\n        d.iosVideo,\n        d.videoAssist,\n        d.media,\n        d.lenses\n    ];\n    for (const col of collections) {\n        if (col && col[name]) {\n            const item = col[name];\n            if (item.brand && item.brand.toUpperCase().includes('ARRI') && item.kNumber && !name.includes(item.kNumber)) {\n                return name.replace(/^ARRI\\s*/i, `ARRI ${item.kNumber} `);\n            }\n            return name;\n        }\n    }\n    if (d.accessories) {\n        const findItem = obj => {\n            if (!obj) return null;\n            if (obj[name]) return obj[name];\n            for (const val of Object.values(obj)) {\n                if (val && typeof val === 'object') {\n                    const found = findItem(val);\n                    if (found) return found;\n                }\n            }\n            return null;\n        };\n        for (const col of Object.values(d.accessories)) {\n            const item = findItem(col);\n            if (item) {\n                if (item.brand && item.brand.toUpperCase().includes('ARRI') && item.kNumber && !name.includes(item.kNumber)) {\n                    return /^ARRI\\s*/i.test(name) ? name.replace(/^ARRI\\s*/i, `ARRI ${item.kNumber} `) : `ARRI ${item.kNumber} ${name}`;\n                }\n                return name;\n            }\n        }\n    }\n    return name;\n}\n\nconst sanitizeFizContext = context => (context || '')\n    .replace(/[()]/g, '')\n    .replace(/\\s{2,}/g, ' ')\n    .trim();\n\nconst formatFizCable = (name, context) => {\n    const cleaned = sanitizeFizContext(context);\n    return cleaned ? `${name} (${cleaned})` : name;\n};\n\nfunction suggestArriFizCables() {\n    const CABLE_LBUS_05 = 'LBUS to LBUS 0,5m';\n    const CABLE_UDM_SERIAL_4P = 'Cable UDM \u2013 SERIAL (4p) 0,5m';\n    const CABLE_UDM_SERIAL_7P = 'Cable UDM \u2013 SERIAL (7p) 1,5m';\n    const cables = [];\n    const lbusLengths = [];\n    const camSpare = [];\n    const camera = cameraSelect?.value || '';\n    const motors = motorSelects.map(sel => sel.value).filter(v => v && v !== 'None');\n    const controllers = controllerSelects.map(sel => sel.value).filter(v => v && v !== 'None');\n    const distance = distanceSelect?.value || '';\n    const motor = motors[0] || '';\n    const hasMasterGrip = controllers.includes('Arri Master Grip (single unit)');\n    const hasRIA = controllers.includes('Arri RIA-1');\n    let hasUDM = distance.includes('UDM');\n    let hasLCube = distance.includes('LCube');\n    if (hasLCube && (hasRIA || camera === 'Arri Alexa 35')) hasLCube = false;\n    const isCforceMiniRF = /cforce mini rf/i.test(motor);\n    const isCforceMini = /cforce mini/i.test(motor) && !isCforceMiniRF;\n    const motorContext = motor ? `for ${motor}` : 'for FIZ motor';\n    const masterGripContext = 'for Arri Master Grip (single unit)';\n    const distanceContext = distance ? `for ${distance}` : 'for distance sensor';\n    const controllersToCheck = [];\n    if (hasRIA) controllersToCheck.push('Arri RIA-1');\n    if (isCforceMiniRF) controllersToCheck.push('Arri cforce mini RF');\n    const primaryController = controllersToCheck[0] || controllers[0] || '';\n    const pushLbus = (len, contextOverride) => {\n        const formatted = String(len).replace('.', ',');\n        const ctx = contextOverride || motorContext;\n        cables.push(formatFizCable(`LBUS to LBUS ${formatted}m`, ctx));\n        lbusLengths.push(Number(len));\n    };\n    if ((camera === 'Arri Alexa Mini' || camera === 'Arri Alexa Mini LF') && isCforceMini) {\n        pushLbus(0.3);\n        if (hasLCube) pushLbus(0.4, distanceContext);\n        if (hasMasterGrip) pushLbus(0.5, masterGripContext);\n    } else if (camera === 'Arri Alexa 35' && isCforceMini) {\n        pushLbus(0.3);\n        if (hasMasterGrip) pushLbus(0.5, masterGripContext);\n    } else if (isCforceMiniRF) {\n        if (hasLCube) {\n            pushLbus(0.4, distanceContext);\n            if (hasMasterGrip) pushLbus(0.5, masterGripContext);\n        } else if (hasMasterGrip) {\n            pushLbus(0.5, masterGripContext);\n        }\n    } else if (hasRIA && isCforceMini) {\n        pushLbus(0.4);\n        if (hasMasterGrip) pushLbus(0.5, masterGripContext);\n    }\n    if (controllersToCheck.length) {\n        const cablesData = devices.accessories?.cables || {};\n        let chosen = null;\n        for (const [name, data] of Object.entries(cablesData)) {\n            const connectors = [];\n            if (Array.isArray(data.connectors)) connectors.push(...data.connectors);\n            if (data.from) connectors.push(data.from);\n            if (data.to) connectors.push(data.to);\n            if (!connectors.some(c => /CAM \\(7-pin/i.test(c))) continue;\n            const ctrlOk = (data.compatibleControllers || []).some(cc =>\n                controllersToCheck.some(ct => cc.toLowerCase().includes(ct.toLowerCase())));\n            if (!ctrlOk) continue;\n            const camOk = !data.compatibleCameras ||\n                data.compatibleCameras.some(c => c.toLowerCase() === camera.toLowerCase());\n            if (!camOk) continue;\n            if (!chosen || (data.lengthM ?? Infinity) < (cablesData[chosen].lengthM ?? Infinity)) {\n                chosen = name;\n            }\n        }\n        if (chosen) {\n            const camContext = camera ? `for ${camera}` : 'for camera control';\n            cables.push(formatFizCable(chosen, camContext));\n            camSpare.push(chosen);\n        } else if (hasRIA && cablesData['Cable CAM (7-pin) \u2013 D-Tap 0,5m']) {\n            const fallback = 'Cable CAM (7-pin) \u2013 D-Tap 0,5m';\n            const fallbackContext = primaryController ? `for ${primaryController} power` : 'for controller power';\n            cables.push(formatFizCable(fallback, fallbackContext));\n            camSpare.push(fallback);\n        }\n    }\n    if (hasUDM) {\n        if (hasLCube) {\n            cables.push(formatFizCable(CABLE_UDM_SERIAL_7P, distanceContext));\n        } else {\n            cables.push(formatFizCable(CABLE_UDM_SERIAL_4P, distanceContext));\n            cables.push(formatFizCable(CABLE_UDM_SERIAL_4P, 'spare'));\n        }\n    }\n    if (lbusLengths.length) {\n        const shortest = Math.min(...lbusLengths);\n        const formattedShortest = String(shortest).replace('.', ',');\n        cables.push(formatFizCable(`LBUS to LBUS ${formattedShortest}m`, 'spare'));\n        cables.push(formatFizCable(CABLE_LBUS_05, 'spare'));\n    }\n    camSpare.forEach(n => cables.push(formatFizCable(n, 'spare')));\n    return cables;\n}\n\nfunction collectAccessories({ hasMotor = false, videoDistPrefs = [] } = {}) {\n    const cameraSupport = [];\n    const misc = [];\n    const monitoringSupport = [\n        'BNC Cable 0.5 m',\n        'BNC Cable 1 m',\n        'BNC Cable 5 m',\n        'BNC Cable 10 m',\n        'BNC Drum 25 m'\n    ];\n    const rigging = [];\n    const chargers = [];\n    const fizCables = [];\n    const acc = devices.accessories || {};\n    const excludedCables = new Set(['D-Tap to LEMO 2-pin', 'HDMI Cable']);\n\n    if (batterySelect.value) {\n        const mount = devices.batteries[batterySelect.value]?.mount_type;\n        if (acc.powerPlates) {\n            for (const [name, plate] of Object.entries(acc.powerPlates)) {\n                if ((!plate.mount || plate.mount === mount) && (!plate.compatible || plate.compatible.includes(cameraSelect.value))) {\n                    cameraSupport.push(name);\n                }\n            }\n        }\n        if (acc.chargers) {\n            let camCount = parseInt(batteryCountElem?.textContent || '', 10);\n            if (!Number.isFinite(camCount)) camCount = batterySelect.value ? 1 : 0;\n            let monCount = 0;\n            if (Array.isArray(videoDistPrefs)) {\n                const handheldCount = videoDistPrefs.filter(v => /Monitor(?: \\d+\")? handheld$/.test(v)).length;\n                monCount += handheldCount * 3;\n                const largeCount = videoDistPrefs.filter(v => {\n                    const m = v.match(/Monitor (\\d+(?:\\.\\d+)?)/);\n                    return m && parseFloat(m[1]) > 10 && !/handheld$/.test(v);\n                }).length;\n                monCount += largeCount * 2;\n            }\n            if (hasMotor) monCount += 3;\n            const total = camCount + monCount;\n            if (total > 0) {\n                const counts = suggestChargerCounts(total);\n                const findName = slots => {\n                    for (const [name, charger] of Object.entries(acc.chargers)) {\n                        if (charger.mount === mount && charger.slots === slots) return name;\n                    }\n                    return null;\n                };\n                const pushCharger = (slots, count) => {\n                    const n = findName(slots);\n                    if (!n) return;\n                    for (let i = 0; i < count; i++) chargers.push(n);\n                };\n                pushCharger(4, counts.quad);\n                pushCharger(2, counts.dual);\n                pushCharger(1, counts.single);\n            }\n        }\n    }\n\n    if (cameraSelect.value && acc.cages) {\n        if (!cageSelect.value || cageSelect.value === 'None') {\n            for (const [name, cage] of Object.entries(acc.cages)) {\n                if (!cage.compatible || cage.compatible.includes(cameraSelect.value)) cameraSupport.push(name);\n            }\n        }\n    }\n\n    const powerCableDb = acc.cables?.power || {};\n    const gatherPower = (data, target = misc, includeExcluded = false) => {\n        const input = data?.power?.input?.type;\n        const types = Array.isArray(input) ? input : input ? [input] : [];\n        types.forEach(t => {\n            for (const [name, cable] of Object.entries(powerCableDb)) {\n                const isExcluded = excludedCables.has(name);\n                if (cable.to === t && (!isExcluded || includeExcluded)) target.push(name);\n            }\n        });\n    };\n    gatherPower(devices.cameras[cameraSelect.value]);\n    gatherPower(devices.video[videoSelect.value]);\n    const onboardMonitor = devices.monitors[monitorSelect.value];\n    if (onboardMonitor) {\n        const monitorLabel = 'Onboard monitor';\n        const powerType = onboardMonitor?.power?.input?.type;\n        const hasLemo2 = Array.isArray(powerType)\n            ? powerType.includes('LEMO 2-pin')\n            : powerType === 'LEMO 2-pin';\n        if (hasLemo2) {\n            monitoringSupport.push(\n                `D-Tap to Lemo-2-pin Cable 0,5m (${monitorLabel})`,\n                `D-Tap to Lemo-2-pin Cable 0,5m (${monitorLabel})`\n            );\n        }\n        const cameraData = devices.cameras[cameraSelect.value];\n        const camVideo = (cameraData?.videoOutputs || []).map(v => v.type?.toUpperCase());\n        const monVideo = (onboardMonitor.videoInputs || []).map(v => v.type?.toUpperCase());\n        const hasSDI = camVideo.some(t => t && t.includes('SDI')) && monVideo.some(t => t && t.includes('SDI'));\n        const hasHDMI = camVideo.includes('HDMI') && monVideo.includes('HDMI');\n        if (hasSDI) {\n            monitoringSupport.push(\n                `Ultraslim BNC Cable 0.5 m (${monitorLabel})`,\n                `Ultraslim BNC Cable 0.5 m (${monitorLabel})`\n            );\n        } else if (hasHDMI) {\n            monitoringSupport.push(\n                `Ultraslim HDMI 0.5 m (${monitorLabel})`,\n                `Ultraslim HDMI 0.5 m (${monitorLabel})`\n            );\n        }\n        rigging.push(`ULCS Arm mit 3/8\" und 1/4\" double (${monitorLabel})`);\n    }\n    if (videoSelect.value) {\n        const rxName = videoSelect.value.replace(/ TX\\b/, ' RX');\n        if (devices.wirelessReceivers && devices.wirelessReceivers[rxName]) {\n            gatherPower(devices.wirelessReceivers[rxName]);\n        }\n    }\n    motorSelects.forEach(sel => gatherPower(devices.fiz.motors[sel.value]));\n    controllerSelects.forEach(sel => gatherPower(devices.fiz.controllers[sel.value]));\n    gatherPower(devices.fiz.distance[distanceSelect.value]);\n\n    const fizCableDb = acc.cables?.fiz || {};\n    const getFizConnectors = data => {\n        const list = [];\n        if (!data) return list;\n        if (Array.isArray(data.fizConnectors)) {\n            data.fizConnectors.forEach(fc => {\n                const type = fc && typeof fc === 'object' ? fc.type : fc;\n                if (type) list.push(type);\n            });\n        }\n        if (data.fizConnector) list.push(data.fizConnector);\n        return [...new Set(list.filter(Boolean))];\n    };\n    const pushFizCable = (name, context) => {\n        fizCables.push(formatFizCable(name, context));\n    };\n    const pairContextCounts = {};\n    const buildPairContext = (motorName, controllerName) => {\n        const parts = [sanitizeFizContext(motorName), sanitizeFizContext(controllerName)].filter(Boolean);\n        if (!parts.length) return '';\n        const base = parts.join(' \u2194 ');\n        const key = base.toLowerCase();\n        const next = (pairContextCounts[key] || 0) + 1;\n        pairContextCounts[key] = next;\n        return next > 1 ? `${base} #${next}` : base;\n    };\n    const matchesCable = (cable, from, to) => {\n        if (!cable) return false;\n        const fromToMatch = (a, b) => (cable.from === a && cable.to === b) || (cable.from === b && cable.to === a);\n        if (cable.from && cable.to) {\n            if (fromToMatch(from, to)) return true;\n        }\n        if (Array.isArray(cable.connectors)) {\n            const connectors = cable.connectors;\n            if (connectors.includes(from) && connectors.includes(to)) return true;\n        }\n        return false;\n    };\n    const motorEntries = motorSelects\n        .map(sel => sel.value)\n        .filter(v => v && v !== 'None')\n        .map(name => ({ name, data: devices.fiz.motors[name] }))\n        .filter(entry => entry.data);\n    const controllerEntries = controllerSelects\n        .map(sel => sel.value)\n        .filter(v => v && v !== 'None')\n        .map(name => ({ name, data: devices.fiz.controllers[name] }))\n        .filter(entry => entry.data);\n    motorEntries.forEach(motorEntry => {\n        const motorConns = getFizConnectors(motorEntry.data);\n        controllerEntries.forEach(controllerEntry => {\n            const controllerConns = getFizConnectors(controllerEntry.data);\n            motorConns.forEach(mConn => {\n                controllerConns.forEach(cConn => {\n                    if (mConn !== cConn) return;\n                    for (const [name, cable] of Object.entries(fizCableDb)) {\n                        if (matchesCable(cable, mConn, cConn)) {\n                            const context = buildPairContext(motorEntry.name, controllerEntry.name);\n                            pushFizCable(name, context);\n                        }\n                    }\n                });\n            });\n        });\n    });\n\n    suggestArriFizCables().forEach(name => fizCables.push(name));\n\n    const miscUnique = [...new Set(misc)];\n    const monitoringSupportList = monitoringSupport.slice();\n    const riggingUnique = [...new Set(rigging)];\n    for (let i = 0; i < 4; i++) monitoringSupportList.push('BNC Connector');\n    return {\n        cameraSupport: [...new Set(cameraSupport)],\n        chargers,\n        fizCables,\n        misc: miscUnique,\n        monitoringSupport: monitoringSupportList,\n        rigging: riggingUnique\n    };\n}\n\nfunction collectProjectFormData() {\n    if (!projectForm) return {};\n\n    const formData = new FormData(projectForm);\n    const getValue = (name) => {\n        const raw = formData.get(name);\n        return typeof raw === 'string' ? raw.trim() : '';\n    };\n    const getMultiValue = (name) => {\n        const values = formData.getAll(name);\n        if (!values || values.length === 0) return '';\n        return values.map(value => (typeof value === 'string' ? value : String(value))).join(', ');\n    };\n\n    const viewfinderSettings = getMultiValue('viewfinderSettings');\n    const frameGuides = getMultiValue('frameGuides');\n    const aspectMaskOpacity = getMultiValue('aspectMaskOpacity');\n    const filterStr = collectFilterSelections();\n    const filterTypes = filterStr ? filterStr.split(',').map(s => s.split(':')[0]) : [];\n    const matteboxVal = filterTypes.some(t => t === 'ND Grad HE' || t === 'ND Grad SE')\n        ? 'Swing Away'\n        : getValue('mattebox');\n\n    const people = Array.from(crewContainer?.querySelectorAll('.person-row') || [])\n        .map(row => ({\n            role: row.querySelector('select')?.value,\n            name: row.querySelector('.person-name')?.value.trim(),\n            phone: row.querySelector('.person-phone')?.value.trim(),\n            email: row.querySelector('.person-email')?.value?.trim()\n        }))\n        .filter(person => person.role && person.name);\n\n    const collectRanges = (container, startSel, endSel) => Array.from(container?.querySelectorAll('.period-row') || [])\n        .map(row => {\n            const start = row.querySelector(startSel)?.value;\n            const end = row.querySelector(endSel)?.value;\n            return [start, end].filter(Boolean).join(' to ');\n        })\n        .filter(Boolean);\n\n    const prepDays = collectRanges(prepContainer, '.prep-start', '.prep-end');\n    const shootingDays = collectRanges(shootContainer, '.shoot-start', '.shoot-end');\n\n    const gearValues = gearListOutput ? (() => {\n        const ids = [\n            'gearListDirectorMonitor',\n            'gearListDopMonitor',\n            'gearListGafferMonitor',\n            'gearListDirectorMonitor15',\n            'gearListComboMonitor15',\n            'gearListDopMonitor15',\n            'gearListFocusMonitor',\n            'gearListProGaffColor1',\n            'gearListProGaffWidth1',\n            'gearListProGaffColor2',\n            'gearListProGaffWidth2',\n            'gearListEyeLeatherColor'\n        ];\n        const map = new Map();\n        ids.forEach(id => {\n            const el = gearListOutput.querySelector(`#${id}`);\n            if (!el) return;\n            const value = el.value;\n            map.set(id, typeof value === 'string' ? value : (value == null ? '' : String(value)));\n        });\n        return map;\n    })() : null;\n\n    const getGearValue = (id) => (gearValues && gearValues.has(id) ? gearValues.get(id) : '');\n\n    const proGaffColor1 = getGearValue('gearListProGaffColor1');\n    const proGaffWidth1 = getGearValue('gearListProGaffWidth1');\n    const proGaffColor2 = getGearValue('gearListProGaffColor2');\n    const proGaffWidth2 = getGearValue('gearListProGaffWidth2');\n\n    const info = {\n        productionCompany: getValue('productionCompany'),\n        rentalHouse: getValue('rentalHouse'),\n        ...(people.length ? { people } : {}),\n        prepDays,\n        shootingDays,\n        deliveryResolution: getValue('deliveryResolution'),\n        recordingResolution: getValue('recordingResolution'),\n        aspectRatio: getMultiValue('aspectRatio'),\n        codec: getValue('codec'),\n        baseFrameRate: getValue('baseFrameRate'),\n        sensorMode: getValue('sensorMode'),\n        lenses: getMultiValue('lenses'),\n        requiredScenarios: getMultiValue('requiredScenarios'),\n        cameraHandle: getMultiValue('cameraHandle'),\n        viewfinderExtension: getValue('viewfinderExtension'),\n        viewfinderEyeLeatherColor: getGearValue('gearListEyeLeatherColor') || getValue('viewfinderEyeLeatherColor'),\n        mattebox: matteboxVal,\n        gimbal: getMultiValue('gimbal'),\n        viewfinderSettings,\n        frameGuides,\n        aspectMaskOpacity,\n        videoDistribution: getMultiValue('videoDistribution'),\n        monitoringConfiguration: getValue('monitoringConfiguration'),\n        monitorUserButtons: getMultiValue('monitorUserButtons'),\n        cameraUserButtons: getMultiValue('cameraUserButtons'),\n        viewfinderUserButtons: getMultiValue('viewfinderUserButtons'),\n        tripodHeadBrand: getValue('tripodHeadBrand'),\n        tripodBowl: getValue('tripodBowl'),\n        tripodTypes: getMultiValue('tripodTypes'),\n        tripodSpreader: getValue('tripodSpreader'),\n        sliderBowl: getSliderBowlValue(),\n        easyrig: getEasyrigValue(),\n        filter: filterStr\n    };\n\n    const assignGearField = (prop, id) => {\n        const value = getGearValue(id);\n        if (value) {\n            info[prop] = value;\n        }\n    };\n\n    assignGearField('directorMonitor', 'gearListDirectorMonitor');\n    assignGearField('dopMonitor', 'gearListDopMonitor');\n    assignGearField('gafferMonitor', 'gearListGafferMonitor');\n    assignGearField('directorMonitor15', 'gearListDirectorMonitor15');\n    assignGearField('comboMonitor15', 'gearListComboMonitor15');\n    assignGearField('dopMonitor15', 'gearListDopMonitor15');\n\n    info.focusMonitor = getGearValue('gearListFocusMonitor') || '';\n\n    if (proGaffColor1 || proGaffWidth1) {\n        info.proGaffColor1 = proGaffColor1 || '';\n        info.proGaffWidth1 = proGaffWidth1 || '';\n    }\n\n    if (proGaffColor2 || proGaffWidth2) {\n        info.proGaffColor2 = proGaffColor2 || '';\n        info.proGaffWidth2 = proGaffWidth2 || '';\n    }\n\n    const currentProjectName = getCurrentProjectName();\n    if (currentProjectName) {\n        info.projectName = currentProjectName;\n    }\n\n    return info;\n}\n\nfunction populateProjectForm(info = {}) {\n    if (!projectForm) return;\n    projectForm.reset();\n    const setVal = (name, value) => {\n        if (value === undefined) return;\n        const field = projectForm.querySelector(`[name=\"${name}\"]`);\n        if (field) field.value = value;\n    };\n    const setMulti = (name, values) => {\n        const field = projectForm.querySelector(`[name=\"${name}\"]`);\n        if (!field || values === undefined) return;\n        const arr = Array.isArray(values) ? values : (values ? values.split(',').map(v => v.trim()) : []);\n        Array.from(field.options).forEach(opt => {\n            opt.selected = arr.includes(opt.value);\n        });\n    };\n\n    populateRecordingResolutionDropdown(info.recordingResolution);\n    populateSensorModeDropdown(info.sensorMode);\n    populateCodecDropdown(info.codec);\n\n    setVal('productionCompany', info.productionCompany);\n    setVal('rentalHouse', info.rentalHouse);\n    if (crewContainer) {\n        crewContainer.innerHTML = '';\n        (info.people || []).forEach(p => createCrewRow(p));\n    }\n    if (prepContainer) {\n        prepContainer.innerHTML = '';\n        const prepArr = Array.isArray(info.prepDays)\n            ? info.prepDays\n            : (info.prepDays ? String(info.prepDays).split('\\n') : ['']);\n        if (!prepArr.length) prepArr.push('');\n        prepArr.forEach(r => {\n            const [start, end] = r.split(' to ');\n            createPrepRow({ start, end });\n        });\n    }\n    if (shootContainer) {\n        shootContainer.innerHTML = '';\n        const shootArr = Array.isArray(info.shootingDays)\n            ? info.shootingDays\n            : (info.shootingDays ? String(info.shootingDays).split('\\n') : ['']);\n        if (!shootArr.length) shootArr.push('');\n        shootArr.forEach(r => {\n            const [start, end] = r.split(' to ');\n            createShootRow({ start, end });\n        });\n    }\n    setVal('deliveryResolution', info.deliveryResolution);\n    setMulti('aspectRatio', info.aspectRatio);\n    setVal('baseFrameRate', info.baseFrameRate);\n    setVal('sensorMode', info.sensorMode);\n    setMulti('lenses', info.lenses);\n    setMulti('requiredScenarios', info.requiredScenarios);\n    setMulti('cameraHandle', info.cameraHandle);\n    setVal('viewfinderExtension', info.viewfinderExtension);\n    setVal('viewfinderEyeLeatherColor', info.viewfinderEyeLeatherColor);\n    setVal('mattebox', info.mattebox);\n    setMulti('gimbal', info.gimbal);\n    setMulti('viewfinderSettings', info.viewfinderSettings);\n    setMulti('frameGuides', info.frameGuides);\n    setMulti('aspectMaskOpacity', info.aspectMaskOpacity);\n    setMulti('videoDistribution', info.videoDistribution);\n    setVal('monitoringConfiguration', info.monitoringConfiguration);\n    setMulti('monitorUserButtons', info.monitorUserButtons);\n    setMulti('cameraUserButtons', info.cameraUserButtons);\n    setMulti('viewfinderUserButtons', info.viewfinderUserButtons);\n    setVal('tripodHeadBrand', info.tripodHeadBrand);\n    setVal('tripodBowl', info.tripodBowl);\n    setMulti('tripodTypes', info.tripodTypes);\n    setVal('tripodSpreader', info.tripodSpreader);\n    setSliderBowlValue(info.sliderBowl || '');\n    setEasyrigValue(info.easyrig || '');\n    const filterTokens = parseFilterTokens(info.filter);\n    setMulti('filter', filterTokens.map(t => t.type));\n    renderFilterDetails();\n    filterTokens.forEach(({ type, size, values }) => {\n        const sizeSel = document.getElementById(`filter-size-${filterId(type)}`);\n        if (sizeSel) sizeSel.value = size;\n        const valSel = document.getElementById(`filter-values-${filterId(type)}`);\n        if (valSel) {\n            const arr = Array.isArray(values) ? values : [];\n            Array.from(valSel.options).forEach(opt => {\n                opt.selected = arr.includes(opt.value);\n            });\n        }\n    });\n}\n\nfunction ensureZoomRemoteSetup(info) {\n    if (!info || !info.tripodPreferences || !info.tripodPreferences.includes('Zoom Remote handle')) return;\n    let motors = motorSelects.map(sel => sel.value).filter(v => v && v !== 'None');\n    if (!motors.length) return;\n    if (motors.length < 2 && motorSelects[1]) {\n        let second = motors[0];\n        if (/cforce.*rf/i.test(second) && devices.fiz.motors['Arri Cforce Mini']) {\n            second = 'Arri Cforce Mini';\n        }\n        motorSelects[1].value = second;\n        motors = motorSelects.map(sel => sel.value).filter(v => v && v !== 'None');\n    }\n    const allowed = new Set([\n        'Arri Master Grip (single unit)',\n        'Arri ZMU-4 (body only, wired)',\n        'Tilta Nucleus-M Hand Grip (single)',\n        'Tilta Nucleus-M II Handle (single)'\n    ]);\n    const controllers = controllerSelects.map(sel => sel.value).filter(v => v && v !== 'None');\n    if (!controllers.some(c => allowed.has(c))) {\n        const brand = detectBrand(motors[0]);\n        let ctrl = null;\n        if (brand === 'arri') {\n            ctrl = 'Arri Master Grip (single unit)';\n        } else if (brand === 'tilta') {\n            ctrl = 'Tilta Nucleus-M Hand Grip (single)';\n        }\n        if (ctrl && controllerSelects[0]) {\n            controllerSelects[0].value = ctrl;\n        }\n    }\n    if (typeof updateCalculations === 'function') updateCalculations();\n    if (typeof saveCurrentSession === 'function') saveCurrentSession();\n}\n\nfunction stripAutoGearContext(name) {\n    return (name || '').replace(/\\s*\\([^)]*\\)\\s*$/, '').trim();\n}\n\nfunction normalizeAutoGearName(name) {\n    return stripAutoGearContext(name).toLowerCase();\n}\n\nfunction matchesAutoGearItem(target, actual) {\n    if (!target || !actual) return false;\n    const normTarget = normalizeAutoGearName(target);\n    const normActual = normalizeAutoGearName(actual);\n    if (normTarget === normActual) return true;\n    return normTarget === normalizeAutoGearName(actual.replace(/^\\d+x\\s+/, ''));\n}\n\nfunction getSpanCount(span) {\n    if (!span) return 1;\n    const text = span.textContent || '';\n    const match = text.trim().match(/^(\\d+)x\\s+/);\n    return match ? parseInt(match[1], 10) : 1;\n}\n\nfunction updateSpanCountInPlace(span, newCount) {\n    if (!span) return;\n    const walker = document.createTreeWalker(span, NodeFilter.SHOW_TEXT, null, false);\n    let textNode = null;\n    while (walker.nextNode()) {\n        const node = walker.currentNode;\n        if (/\\d+x\\s+/i.test(node.textContent)) {\n            textNode = node;\n            break;\n        }\n    }\n    if (!textNode) {\n        span.insertBefore(document.createTextNode(`${newCount}x `), span.firstChild);\n        return;\n    }\n    const value = textNode.textContent || '';\n    const match = value.match(/^(\\s*)(\\d+)x\\s+(.*)$/);\n    if (match) {\n        textNode.textContent = `${match[1]}${newCount}x ${match[3]}`;\n    } else {\n        textNode.textContent = value.replace(/^(\\d+)x\\s+/, `${newCount}x `);\n    }\n}\n\nfunction cleanupAutoGearCell(cell) {\n    if (!cell) return;\n    const nodes = Array.from(cell.childNodes);\n    let previousWasBreak = true;\n    nodes.forEach(node => {\n        if (node.nodeType === Node.TEXT_NODE && !node.textContent.trim()) {\n            cell.removeChild(node);\n            return;\n        }\n        if (node.nodeName === 'BR') {\n            if (previousWasBreak || !node.nextSibling) {\n                cell.removeChild(node);\n                return;\n            }\n            previousWasBreak = true;\n        } else {\n            previousWasBreak = false;\n        }\n    });\n    while (cell.firstChild && cell.firstChild.nodeName === 'BR') {\n        cell.removeChild(cell.firstChild);\n    }\n    while (cell.lastChild && cell.lastChild.nodeName === 'BR') {\n        cell.removeChild(cell.lastChild);\n    }\n    const textContent = cell.textContent ? cell.textContent.trim() : '';\n    if (!textContent && !cell.querySelector('.gear-item')) {\n        const row = cell.closest('tr');\n        const section = row ? row.closest('tbody') : null;\n        if (section && section.classList.contains('auto-gear-category')) {\n            section.remove();\n        }\n    }\n}\n\nfunction analyzeAutoGearSegment(nodes) {\n    if (!nodes || !nodes.length) return null;\n    const span = nodes.find(node => node.nodeType === 1 && node.classList && node.classList.contains('gear-item'));\n    if (span) {\n        const name = span.getAttribute('data-gear-name') || (span.textContent || '').replace(/^(\\d+)x\\s+/, '').trim();\n        const count = getSpanCount(span);\n        return { span, name, count };\n    }\n    const wrapper = document.createElement('div');\n    nodes.forEach(node => wrapper.appendChild(node.cloneNode(true)));\n    let text = wrapper.innerHTML\n        .replace(/<select[\\s\\S]*?<\\/select>/gi, '')\n        .replace(/<[^>]+>/g, '')\n        .trim();\n    if (!text) return null;\n    const match = text.match(/^(\\d+)x\\s+/);\n    let count = 1;\n    if (match) {\n        count = parseInt(match[1], 10);\n        text = text.slice(match[0].length).trim();\n    }\n    return { span: null, name: text, count, wrapper };\n}\n\nfunction updateRawSegmentCount(nodes, info, newCount) {\n    if (!nodes.length) return;\n    let updated = false;\n    for (const node of nodes) {\n        if (node.nodeType === Node.TEXT_NODE) {\n            const value = node.textContent || '';\n            if (/\\d+x\\s+/i.test(value)) {\n                node.textContent = value.replace(/^(\\s*)(\\d+)x\\s+/, (match, spaces) => `${spaces}${newCount}x `);\n                updated = true;\n                break;\n            }\n            if (value.trim()) {\n                node.textContent = `${newCount}x ${value.trim().replace(/^(\\d+)x\\s+/, '')}`;\n                updated = true;\n                break;\n            }\n        } else if (node.nodeType === 1) {\n            const child = node.firstChild;\n            if (child && child.nodeType === Node.TEXT_NODE && /\\d+x\\s+/i.test(child.textContent || '')) {\n                child.textContent = (child.textContent || '').replace(/^(\\s*)(\\d+)x\\s+/, (match, spaces) => `${spaces}${newCount}x `);\n                updated = true;\n                break;\n            }\n        }\n    }\n    if (!updated) {\n        const first = nodes[0];\n        const parent = first.parentNode;\n        if (parent) {\n            parent.insertBefore(document.createTextNode(`${newCount}x ${info.name}`), first);\n        }\n    }\n}\n\nfunction removeAutoGearItem(cell, item, remainingOverride) {\n    if (!cell) return normalizeAutoGearQuantity(item.quantity);\n    let remaining = typeof remainingOverride === 'number'\n        ? remainingOverride\n        : normalizeAutoGearQuantity(item.quantity);\n    if (remaining <= 0) return remaining;\n    const nodes = Array.from(cell.childNodes);\n    if (!nodes.length) return remaining;\n    const segments = [];\n    let current = [];\n    nodes.forEach(node => {\n        if (node.nodeName === 'BR') {\n            segments.push({ nodes: current, separator: node });\n            current = [];\n        } else {\n            current.push(node);\n        }\n    });\n    segments.push({ nodes: current, separator: null });\n    let modified = false;\n    segments.forEach(segment => {\n        if (!segment.nodes.length || remaining <= 0) return;\n        const info = analyzeAutoGearSegment(segment.nodes);\n        if (!info || !info.name || !matchesAutoGearItem(item.name, info.name)) return;\n        if (info.span) {\n            const currentCount = info.count;\n            if (currentCount > remaining) {\n                updateSpanCountInPlace(info.span, currentCount - remaining);\n                remaining = 0;\n            } else {\n                remaining -= currentCount;\n                segment.nodes.forEach(node => node.remove());\n            }\n            modified = true;\n        } else {\n            if (info.count > remaining && info.count > 1) {\n                updateRawSegmentCount(segment.nodes, info, info.count - remaining);\n                remaining = 0;\n                modified = true;\n            } else {\n                remaining -= info.count;\n                segment.nodes.forEach(node => node.remove());\n                modified = true;\n            }\n        }\n    });\n    if (modified) {\n        cleanupAutoGearCell(cell);\n    }\n    return remaining;\n}\n\nfunction getAutoGearRuleDisplayLabel(rule) {\n  if (!rule || typeof rule !== 'object') return '';\n  const label = typeof rule.label === 'string' ? rule.label.trim() : '';\n  if (label) return label;\n  const scenarioList = Array.isArray(rule.scenarios) ? rule.scenarios.filter(Boolean) : [];\n  if (scenarioList.length) return scenarioList.join(' + ');\n  const cameraList = Array.isArray(rule.camera) ? rule.camera.filter(Boolean) : [];\n  if (cameraList.length) return cameraList.join(' + ');\n  const monitorList = Array.isArray(rule.monitor) ? rule.monitor.filter(Boolean) : [];\n  if (monitorList.length) return monitorList.join(' + ');\n  const wirelessList = Array.isArray(rule.wireless) ? rule.wireless.filter(Boolean) : [];\n  if (wirelessList.length) return wirelessList.join(' + ');\n  const motorsList = Array.isArray(rule.motors) ? rule.motors.filter(Boolean) : [];\n  if (motorsList.length) return motorsList.join(' + ');\n  const controllersList = Array.isArray(rule.controllers) ? rule.controllers.filter(Boolean) : [];\n  if (controllersList.length) return controllersList.join(' + ');\n  const distanceList = Array.isArray(rule.distance) ? rule.distance.filter(Boolean) : [];\n  if (distanceList.length) return distanceList.join(' + ');\n  const matteboxList = Array.isArray(rule.mattebox) ? rule.mattebox.filter(Boolean) : [];\n  if (matteboxList.length) return matteboxList.join(' + ');\n  const cameraHandleList = Array.isArray(rule.cameraHandle) ? rule.cameraHandle.filter(Boolean) : [];\n  if (cameraHandleList.length) return cameraHandleList.join(' + ');\n  const viewfinderList = Array.isArray(rule.viewfinderExtension)\n    ? rule.viewfinderExtension.filter(Boolean).map(getViewfinderFallbackLabel)\n    : [];\n  if (viewfinderList.length) return viewfinderList.join(' + ');\n  const videoDistributionList = Array.isArray(rule.videoDistribution)\n    ? rule.videoDistribution.filter(Boolean).map(getVideoDistributionFallbackLabel)\n    : [];\n  if (videoDistributionList.length) return videoDistributionList.join(' + ');\n  return '';\n}\n\nfunction formatAutoGearRuleTooltip(rule) {\n    const langTexts = texts[currentLang] || texts.en || {};\n    const unnamedTemplate = langTexts.autoGearRuleTooltipUnnamed\n        || texts.en?.autoGearRuleTooltipUnnamed\n        || 'Added by automatic gear rule';\n    if (!rule || typeof rule !== 'object') return unnamedTemplate;\n    const label = getAutoGearRuleDisplayLabel(rule);\n    if (label) {\n        const namedTemplate = langTexts.autoGearRuleTooltipNamed\n            || texts.en?.autoGearRuleTooltipNamed\n            || `${unnamedTemplate}: %s`;\n        return namedTemplate.replace('%s', label);\n    }\n    return unnamedTemplate;\n}\n\nfunction addAutoGearItem(cell, item, rule) {\n    if (!cell) return;\n    const normalizedItem = normalizeAutoGearItem(item);\n    if (!normalizedItem) return;\n    const quantity = normalizeAutoGearQuantity(normalizedItem.quantity);\n    if (quantity <= 0) return;\n    const name = normalizedItem.name ? normalizedItem.name.trim() : '';\n    if (!name) return;\n    const spans = Array.from(cell.querySelectorAll('.gear-item'));\n    for (const span of spans) {\n        const spanName = span.getAttribute('data-gear-name') || (span.textContent || '').replace(/^(\\d+)x\\s+/, '').trim();\n        if (matchesAutoGearItem(name, spanName)) {\n            const newCount = getSpanCount(span) + quantity;\n            updateSpanCountInPlace(span, newCount);\n            return;\n        }\n    }\n    if (cell.childNodes.length) {\n        cell.appendChild(document.createElement('br'));\n    }\n    const span = document.createElement('span');\n    span.className = 'gear-item auto-gear-item';\n    span.setAttribute('data-gear-name', name);\n    if (rule && typeof rule === 'object') {\n        if (rule.id) {\n            span.dataset.autoGearRuleId = rule.id;\n        }\n        const ruleLabel = getAutoGearRuleDisplayLabel(rule);\n        if (ruleLabel) {\n            span.dataset.autoGearRuleLabel = ruleLabel;\n        }\n        const tooltip = formatAutoGearRuleTooltip(rule);\n        if (tooltip) {\n            span.title = tooltip;\n        }\n    }\n    const displayName = typeof addArriKNumber === 'function' ? addArriKNumber(name) : name;\n    span.textContent = `${quantity}x ${displayName}`;\n    if (normalizedItem.screenSize) {\n        span.appendChild(document.createTextNode(` - ${normalizedItem.screenSize}`));\n    }\n    const selectorType = normalizedItem.selectorType || 'none';\n    const selectorDefault = normalizedItem.selectorDefault || '';\n    if (selectorType && selectorType !== 'none') {\n        const selectorLabel = getAutoGearSelectorLabel(selectorType);\n        if (normalizedItem.selectorEnabled) {\n            const options = getAutoGearSelectorOptions(selectorType);\n            const shouldRenderSelector = options.length || selectorDefault;\n            if (shouldRenderSelector) {\n                const sanitizedRuleId = rule && rule.id ? rule.id.replace(/[^a-zA-Z0-9_-]/g, '') : 'rule';\n                const selectId = `autoGearSelector_${sanitizedRuleId}_${normalizedItem.id}`;\n                const select = document.createElement('select');\n                select.id = selectId;\n                select.className = 'auto-gear-selector';\n                select.dataset.autoGearSelectorType = selectorType;\n                select.setAttribute('aria-label', selectorLabel);\n                let normalizedDefaultValue = '';\n                options.forEach(optionName => {\n                    const option = document.createElement('option');\n                    option.value = optionName;\n                    option.textContent = typeof addArriKNumber === 'function' ? addArriKNumber(optionName) : optionName;\n                    if (!normalizedDefaultValue && selectorDefault && optionName.toLowerCase() === selectorDefault.toLowerCase()) {\n                        normalizedDefaultValue = option.value;\n                    }\n                    select.appendChild(option);\n                });\n                if (selectorDefault && !normalizedDefaultValue) {\n                    const fallbackOption = document.createElement('option');\n                    fallbackOption.value = selectorDefault;\n                    fallbackOption.textContent = typeof addArriKNumber === 'function'\n                        ? addArriKNumber(selectorDefault)\n                        : selectorDefault;\n                    select.insertBefore(fallbackOption, select.firstChild);\n                    normalizedDefaultValue = selectorDefault;\n                }\n                if (normalizedDefaultValue) {\n                    select.value = normalizedDefaultValue;\n                } else if (select.options.length) {\n                    select.selectedIndex = 0;\n                }\n                const optionCount = select.options.length;\n                const minVisibleRows = 6;\n                const maxVisibleRows = 12;\n                let visibleRows = optionCount >= minVisibleRows\n                    ? Math.min(maxVisibleRows, optionCount)\n                    : (optionCount || minVisibleRows);\n                if (!Number.isFinite(visibleRows) || visibleRows <= 0) {\n                    visibleRows = minVisibleRows;\n                }\n                select.size = visibleRows;\n                const hintText = getAutoGearSelectorScrollHint();\n                let selectorWrapper = select;\n                if (hintText) {\n                    const wrapper = document.createElement('span');\n                    wrapper.className = 'auto-gear-selector-container';\n                    wrapper.appendChild(select);\n                    const hint = document.createElement('span');\n                    hint.id = `${selectId}_hint`;\n                    hint.className = 'auto-gear-selector-hint';\n                    hint.textContent = hintText;\n                    wrapper.appendChild(hint);\n                    select.setAttribute('aria-describedby', hint.id);\n                    selectorWrapper = wrapper;\n                }\n                span.appendChild(document.createTextNode(' - '));\n                span.appendChild(selectorWrapper);\n            } else if (selectorDefault) {\n                const formattedDefault = typeof addArriKNumber === 'function' ? addArriKNumber(selectorDefault) : selectorDefault;\n                span.appendChild(document.createTextNode(` - ${selectorLabel}: ${formattedDefault}`));\n            } else if (selectorLabel) {\n                span.appendChild(document.createTextNode(` - ${selectorLabel}`));\n            }\n        } else if (selectorDefault) {\n            const formattedDefault = typeof addArriKNumber === 'function' ? addArriKNumber(selectorDefault) : selectorDefault;\n            span.appendChild(document.createTextNode(` - ${selectorLabel}: ${formattedDefault}`));\n        } else if (selectorLabel) {\n            span.appendChild(document.createTextNode(` - ${selectorLabel}`));\n        }\n    }\n    if (normalizedItem.notes) {\n        const delimiter = normalizedItem.notes.trim().toLowerCase().startsWith('incl') ? ' ' : ' \u2013 ';\n        span.appendChild(document.createTextNode(`${delimiter}${normalizedItem.notes}`));\n    }\n    cell.appendChild(span);\n}\n\nfunction ensureAutoGearCategory(table, category) {\n    const rawCategory = category && category.trim() ? category.trim() : '';\n    const label = rawCategory || AUTO_GEAR_CUSTOM_CATEGORY;\n    const existing = Array.from(table.querySelectorAll('tbody.category-group')).find(body => {\n        if (body.dataset && Object.prototype.hasOwnProperty.call(body.dataset, 'autoCategory')) {\n            return body.dataset.autoCategory === rawCategory;\n        }\n        const headerCell = body.querySelector('.category-row td');\n        return headerCell && headerCell.textContent.trim() === label;\n    });\n    if (existing) {\n        const cell = existing.querySelector('tr:not(.category-row) td');\n        return cell || null;\n    }\n    const body = document.createElement('tbody');\n    body.className = 'category-group auto-gear-category';\n    body.dataset.autoCategory = rawCategory;\n    const headerRow = document.createElement('tr');\n    headerRow.className = 'category-row';\n    const headerCell = document.createElement('td');\n    const labelText = rawCategory\n        ? rawCategory\n        : (texts[currentLang]?.autoGearCustomCategory || texts.en?.autoGearCustomCategory || 'Custom Additions');\n    headerCell.textContent = labelText;\n    headerRow.appendChild(headerCell);\n    body.appendChild(headerRow);\n    const itemsRow = document.createElement('tr');\n    const itemsCell = document.createElement('td');\n    itemsRow.appendChild(itemsCell);\n    body.appendChild(itemsRow);\n    table.appendChild(body);\n    return itemsCell;\n}\n\nfunction findAutoGearCategoryCell(table, category) {\n    if (!table) return null;\n    const rawCategory = category && category.trim() ? category.trim() : '';\n    const label = rawCategory || AUTO_GEAR_CUSTOM_CATEGORY;\n    const bodies = Array.from(table.querySelectorAll('tbody.category-group'));\n    for (const body of bodies) {\n        if (body.dataset && Object.prototype.hasOwnProperty.call(body.dataset, 'autoCategory')) {\n            if (body.dataset.autoCategory === rawCategory) {\n                const cell = body.querySelector('tr:not(.category-row) td');\n                if (cell) return cell;\n            }\n            continue;\n        }\n        const headerCell = body.querySelector('.category-row td');\n        if (!headerCell) continue;\n        const headerLabel = headerCell.textContent.trim();\n        if (rawCategory) {\n            if (headerLabel === rawCategory) {\n                const cell = body.querySelector('tr:not(.category-row) td');\n                if (cell) return cell;\n            }\n        } else if (body.classList.contains('auto-gear-category') || headerLabel === label) {\n            const cell = body.querySelector('tr:not(.category-row) td');\n            if (cell) return cell;\n        }\n    }\n    return null;\n}\n\nfunction applyAutoGearRulesToTableHtml(tableHtml, info) {\n    if (!tableHtml || !autoGearRules.length || typeof document === 'undefined') return tableHtml;\n  const scenarios = info && info.requiredScenarios\n      ? info.requiredScenarios.split(',').map(s => s.trim()).filter(Boolean)\n      : [];\n  const selectedMattebox = info && typeof info.mattebox === 'string'\n      ? info.mattebox.trim()\n      : '';\n  const normalizedMattebox = normalizeAutoGearTriggerValue(selectedMattebox);\n  const cameraHandles = info && typeof info.cameraHandle === 'string'\n      ? info.cameraHandle.split(',').map(s => s.trim()).filter(Boolean)\n      : [];\n  const normalizedCameraHandles = cameraHandles\n      .map(normalizeAutoGearTriggerValue)\n      .filter(Boolean);\n  const cameraHandleSet = new Set(normalizedCameraHandles);\n  const rawViewfinderExtension = info && typeof info.viewfinderExtension === 'string'\n      ? info.viewfinderExtension.trim()\n      : '';\n  const hasViewfinderSelection = Boolean(rawViewfinderExtension);\n  const normalizedViewfinderExtension = hasViewfinderSelection\n      ? normalizeAutoGearTriggerValue(rawViewfinderExtension)\n      : '__none__';\n  let videoDistribution = [];\n  if (info && Array.isArray(info.videoDistribution)) {\n    videoDistribution = info.videoDistribution;\n  } else if (info && typeof info.videoDistribution === 'string') {\n    videoDistribution = info.videoDistribution\n      .split(',')\n      .map(s => s.trim())\n      .filter(Boolean);\n  }\n  const normalizedVideoDistributionRaw = videoDistribution\n    .map(normalizeVideoDistributionOptionValue)\n    .map(value => (value === '__none__' ? '__none__' : normalizeAutoGearTriggerValue(value)))\n    .filter(value => value || value === '__none__');\n  const hasRealVideoDistributionSelection = normalizedVideoDistributionRaw.some(value => value !== '__none__');\n  const normalizedVideoDistribution = hasRealVideoDistributionSelection\n    ? normalizedVideoDistributionRaw.filter(value => value !== '__none__')\n    : ['__none__'];\n  const videoDistributionSet = new Set(normalizedVideoDistribution);\n  const rawCameraSelection = info && typeof info.cameraSelection === 'string'\n      ? info.cameraSelection.trim()\n      : '';\n  const normalizedCameraSelection = normalizeAutoGearTriggerValue(rawCameraSelection);\n  const rawMonitorSelection = info && typeof info.monitorSelection === 'string'\n      ? info.monitorSelection.trim()\n      : '';\n  const normalizedMonitorSelection = normalizeAutoGearTriggerValue(rawMonitorSelection);\n  const rawWirelessSelection = info && typeof info.wirelessSelection === 'string'\n      ? info.wirelessSelection.trim()\n      : '';\n  const normalizedWirelessSelection = normalizeAutoGearTriggerValue(rawWirelessSelection);\n  const rawMotorSelections = [];\n  if (info) {\n    if (Array.isArray(info.motorSelections)) {\n      rawMotorSelections.push(...info.motorSelections);\n    }\n    if (Array.isArray(info.motors)) {\n      rawMotorSelections.push(...info.motors);\n    }\n  }\n  const normalizedMotorSet = new Set(\n    rawMotorSelections\n      .filter(value => typeof value === 'string')\n      .map(value => normalizeAutoGearTriggerValue(value))\n      .filter(Boolean)\n  );\n  const rawControllerSelections = [];\n  if (info) {\n    if (Array.isArray(info.controllerSelections)) {\n      rawControllerSelections.push(...info.controllerSelections);\n    }\n    if (Array.isArray(info.controllers)) {\n      rawControllerSelections.push(...info.controllers);\n    }\n  }\n  const normalizedControllerSet = new Set(\n    rawControllerSelections\n      .filter(value => typeof value === 'string')\n      .map(value => normalizeAutoGearTriggerValue(value))\n      .filter(Boolean)\n  );\n  const rawDistanceSelection = info && typeof info.distanceSelection === 'string'\n      ? info.distanceSelection.trim()\n      : '';\n  const normalizedDistanceSelection = normalizeAutoGearTriggerValue(rawDistanceSelection);\n  if (!scenarios.length) {\n    const hasRuleWithoutScenario = autoGearRules.some(rule => {\n      const scenarioList = Array.isArray(rule.scenarios)\n          ? rule.scenarios.filter(Boolean)\n          : [];\n            return scenarioList.length === 0;\n        });\n        if (!hasRuleWithoutScenario) return tableHtml;\n    }\n    const touchesMatteboxCategory = (rule) => {\n        if (!rule || typeof rule !== 'object') return false;\n        const lists = [];\n        if (Array.isArray(rule.add)) lists.push(rule.add);\n        if (Array.isArray(rule.remove)) lists.push(rule.remove);\n        return lists.some(entries => entries.some(entry => {\n            if (!entry || typeof entry !== 'object') return false;\n            const category = typeof entry.category === 'string' ? entry.category.trim().toLowerCase() : '';\n            return category === 'matte box + filter';\n        }));\n    };\n\n    let triggered = autoGearRules.filter(rule => {\n        const scenarioList = Array.isArray(rule.scenarios) ? rule.scenarios.filter(Boolean) : [];\n        if (scenarioList.length && !scenarioList.every(s => scenarios.includes(s))) {\n            return false;\n        }\n        const matteboxList = Array.isArray(rule.mattebox) ? rule.mattebox.filter(Boolean) : [];\n        if (matteboxList.length) {\n          const normalizedTargets = matteboxList\n            .map(normalizeAutoGearTriggerValue)\n            .filter(Boolean);\n          if (!normalizedTargets.length) return false;\n          if (!normalizedMattebox) return false;\n          if (!normalizedTargets.includes(normalizedMattebox)) return false;\n        }\n        const cameraList = Array.isArray(rule.camera) ? rule.camera.filter(Boolean) : [];\n        if (cameraList.length) {\n          const normalizedTargets = cameraList\n            .map(normalizeAutoGearTriggerValue)\n            .filter(Boolean);\n          if (!normalizedTargets.length) return false;\n          if (!normalizedCameraSelection) return false;\n          if (!normalizedTargets.includes(normalizedCameraSelection)) return false;\n        }\n        const monitorList = Array.isArray(rule.monitor) ? rule.monitor.filter(Boolean) : [];\n        if (monitorList.length) {\n          const normalizedTargets = monitorList\n            .map(normalizeAutoGearTriggerValue)\n            .filter(Boolean);\n          if (!normalizedTargets.length) return false;\n          if (!normalizedMonitorSelection) return false;\n          if (!normalizedTargets.includes(normalizedMonitorSelection)) return false;\n        }\n        const wirelessList = Array.isArray(rule.wireless) ? rule.wireless.filter(Boolean) : [];\n        if (wirelessList.length) {\n          const normalizedTargets = wirelessList\n            .map(normalizeAutoGearTriggerValue)\n            .filter(Boolean);\n          if (!normalizedTargets.length) return false;\n          if (!normalizedWirelessSelection) return false;\n          if (!normalizedTargets.includes(normalizedWirelessSelection)) return false;\n        }\n        const motorsList = Array.isArray(rule.motors) ? rule.motors.filter(Boolean) : [];\n        if (motorsList.length) {\n          const normalizedTargets = motorsList\n            .map(normalizeAutoGearTriggerValue)\n            .filter(Boolean);\n          if (!normalizedTargets.length) return false;\n          if (!normalizedTargets.every(target => normalizedMotorSet.has(target))) return false;\n        }\n        const controllersList = Array.isArray(rule.controllers) ? rule.controllers.filter(Boolean) : [];\n        if (controllersList.length) {\n          const normalizedTargets = controllersList\n            .map(normalizeAutoGearTriggerValue)\n            .filter(Boolean);\n          if (!normalizedTargets.length) return false;\n          if (!normalizedTargets.every(target => normalizedControllerSet.has(target))) return false;\n        }\n        const distanceList = Array.isArray(rule.distance) ? rule.distance.filter(Boolean) : [];\n        if (distanceList.length) {\n          const normalizedTargets = distanceList\n            .map(normalizeAutoGearTriggerValue)\n            .filter(Boolean);\n          if (!normalizedTargets.length) return false;\n          if (!normalizedDistanceSelection) return false;\n          if (!normalizedTargets.includes(normalizedDistanceSelection)) return false;\n        }\n        const cameraHandleList = Array.isArray(rule.cameraHandle) ? rule.cameraHandle.filter(Boolean) : [];\n        if (cameraHandleList.length) {\n          const normalizedTargets = cameraHandleList\n            .map(normalizeAutoGearTriggerValue)\n            .filter(Boolean);\n            if (!normalizedTargets.length) return false;\n            if (!normalizedTargets.every(target => cameraHandleSet.has(target))) return false;\n        }\n        const viewfinderList = Array.isArray(rule.viewfinderExtension) ? rule.viewfinderExtension.filter(Boolean) : [];\n        if (viewfinderList.length) {\n            const normalizedTargets = viewfinderList\n                .map(value => (value === '__none__' ? '__none__' : normalizeAutoGearTriggerValue(value)))\n                .filter(value => value || value === '__none__');\n            if (!normalizedTargets.length) return false;\n            if (!normalizedTargets.includes(normalizedViewfinderExtension)) return false;\n        }\n        const videoDistList = Array.isArray(rule.videoDistribution) ? rule.videoDistribution.filter(Boolean) : [];\n        if (videoDistList.length) {\n            const normalizedTargets = videoDistList\n                .map(normalizeAutoGearTriggerValue)\n                .filter(Boolean);\n            if (!normalizedTargets.length) return false;\n            if (!normalizedTargets.every(target => videoDistributionSet.has(target))) return false;\n        }\n        return true;\n    });\n    if (!triggered.length) return tableHtml;\n\n    if (normalizedMattebox) {\n        triggered = triggered.filter(rule => {\n            if (!touchesMatteboxCategory(rule)) return true;\n            const matteboxList = Array.isArray(rule.mattebox) ? rule.mattebox.filter(Boolean) : [];\n            if (!matteboxList.length) return false;\n            const normalizedTargets = matteboxList\n                .map(normalizeAutoGearTriggerValue)\n                .filter(Boolean);\n            if (!normalizedTargets.length) return false;\n            return normalizedTargets.includes(normalizedMattebox);\n        });\n        if (!triggered.length) return tableHtml;\n    }\n    const container = document.createElement('div');\n    container.innerHTML = tableHtml;\n    const table = container.querySelector('.gear-table');\n    if (!table) return tableHtml;\n    triggered.forEach(rule => {\n        rule.remove.forEach(item => {\n            let remaining = normalizeAutoGearQuantity(item.quantity);\n            if (remaining <= 0) return;\n            const primaryCell = findAutoGearCategoryCell(table, item.category);\n            if (primaryCell) {\n                remaining = removeAutoGearItem(primaryCell, item, remaining);\n            }\n            if (remaining > 0) {\n                const gearCells = Array.from(table.querySelectorAll('tbody.category-group tr:not(.category-row) td'));\n                for (const cell of gearCells) {\n                    if (cell === primaryCell) continue;\n                    remaining = removeAutoGearItem(cell, item, remaining);\n                    if (remaining <= 0) break;\n                }\n            }\n        });\n        rule.add.forEach(item => {\n            const cell = ensureAutoGearCategory(table, item.category);\n            if (cell) addAutoGearItem(cell, item, rule);\n        });\n    });\n    return container.innerHTML;\n}\n\nfunction formatPhoneHref(phone) {\n  if (typeof phone !== 'string') return '';\n  const trimmed = phone.trim();\n  if (!trimmed) return '';\n  const sanitized = trimmed.replace(/[^0-9+*#;,]/g, '');\n  return sanitized ? sanitized : '';\n}\n\nfunction formatEmailHref(email) {\n  if (typeof email !== 'string') return '';\n  const trimmed = email.trim();\n  if (!trimmed || !trimmed.includes('@')) return '';\n  const normalized = trimmed.replace(/\\s+/g, '');\n  if (!normalized || !normalized.includes('@')) return '';\n  const encoded = encodeURIComponent(normalized);\n  return encoded ? encoded.replace(/%40/g, '@') : '';\n}\n\nfunction formatRequirementValue(rawValue) {\n  if (rawValue && typeof rawValue === 'object') {\n    if (typeof rawValue.__html === 'string' && rawValue.__html) {\n      return rawValue.__html;\n    }\n    if (Array.isArray(rawValue) && rawValue.length) {\n      const html = rawValue\n        .map(item => (typeof item === 'string' ? escapeHtml(item) : escapeHtml(String(item || ''))))\n        .join('<br>');\n      if (html) return html;\n    }\n    if (typeof rawValue.text === 'string' && rawValue.text) {\n      return escapeHtml(rawValue.text).replace(/\\n/g, '<br>');\n    }\n  }\n  const value = typeof rawValue === 'string'\n    ? rawValue\n    : rawValue == null\n      ? ''\n      : String(rawValue);\n  return escapeHtml(value).replace(/\\n/g, '<br>');\n}\n\nfunction generateGearListHtml(info = {}) {\n    const getText = sel => sel && sel.options && sel.selectedIndex >= 0\n        ? sel.options[sel.selectedIndex].text.trim()\n        : '';\n    const selectedNames = {\n        camera: cameraSelect && cameraSelect.value && cameraSelect.value !== 'None' ? getText(cameraSelect) : '',\n        monitor: monitorSelect && monitorSelect.value && monitorSelect.value !== 'None' ? getText(monitorSelect) : '',\n        video: videoSelect && videoSelect.value && videoSelect.value !== 'None' ? getText(videoSelect) : '',\n        motors: motorSelects\n            .map(sel => sel && sel.value && sel.value !== 'None' ? getText(sel) : '')\n            .filter(Boolean),\n        controllers: controllerSelects\n            .map(sel => sel && sel.value && sel.value !== 'None' ? getText(sel) : '')\n            .filter(Boolean),\n        distance: distanceSelect && distanceSelect.value && distanceSelect.value !== 'None' ? getText(distanceSelect) : '',\n        cage: cageSelect && cageSelect.value && cageSelect.value !== 'None' ? getText(cageSelect) : '',\n        battery: batterySelect && batterySelect.value && batterySelect.value !== 'None' ? getText(batterySelect) : ''\n    };\n    const hasMotor = selectedNames.motors.length > 0;\n    const videoDistPrefs = info.videoDistribution\n        ? info.videoDistribution.split(',').map(s => s.trim()).filter(Boolean)\n        : [];\n    const handheldPrefs = videoDistPrefs\n        .map(p => {\n            const m = p.match(/^(Director|Gaffer|DoP) Monitor (?:(\\d+)\" )?handheld$/);\n            return m ? { role: m[1], size: m[2] ? parseFloat(m[2]) : undefined } : null;\n        })\n        .filter(Boolean);\n    const largeMonitorPrefs = videoDistPrefs\n        .map(p => {\n            const m = p.match(/^(Director|Combo|DoP) Monitor 15-21\"$/);\n            return m ? { role: m[1] } : null;\n        })\n        .filter(Boolean);\n    if ([\"Arri Alexa Mini\", \"Arri Amira\"].includes(selectedNames.camera)) {\n        selectedNames.viewfinder = \"ARRI K2.75004.0 MVF-1 Viewfinder\";\n    } else {\n        selectedNames.viewfinder = \"\";\n    }\n    const { cameraSupport: cameraSupportAcc, chargers: chargersAcc, fizCables: fizCableAcc, misc: miscAcc, monitoringSupport: monitoringSupportAcc, rigging: riggingAcc } = collectAccessories({ hasMotor, videoDistPrefs });\n    for (let i = 0; i < 2; i++) riggingAcc.push('ULCS Bracket with 1/4\" to 1/4\"');\n    for (let i = 0; i < 2; i++) riggingAcc.push('ULCS Bracket with 3/8\" to 1/4\"');\n    for (let i = 0; i < 2; i++) riggingAcc.push('Noga Arm');\n    for (let i = 0; i < 2; i++) riggingAcc.push('Mini Magic Arm');\n    for (let i = 0; i < 4; i++) riggingAcc.push('Cine Quick Release');\n    riggingAcc.push('SmallRig - Super lightweight 15mm RailBlock');\n    for (let i = 0; i < 3; i++) riggingAcc.push('Spigot with male 3/8\" and 1/4\"');\n    for (let i = 0; i < 2; i++) riggingAcc.push('Clapper Stick');\n    for (let i = 0; i < 2; i++) riggingAcc.push('D-Tap Splitter');\n    const cagesDb = devices.accessories?.cages || {};\n    const compatibleCages = [];\n    if (cameraSelect && cameraSelect.value && cameraSelect.value !== 'None') {\n        for (const [name, cage] of Object.entries(cagesDb)) {\n            if (!cage.compatible || cage.compatible.includes(cameraSelect.value)) {\n                compatibleCages.push(name);\n            }\n        }\n    }\n    const supportAccNoCages = cameraSupportAcc.filter(item => !compatibleCages.includes(item));\n    const scenarios = info.requiredScenarios\n        ? info.requiredScenarios.split(',').map(s => s.trim()).filter(Boolean)\n        : [];\n    const hasSeededScenarioRules = hasSeededAutoGearDefaults();\n    const allowLegacyScenarioGear = autoGearRules.length === 0 && !hasSeededScenarioRules;\n    const isScenarioActive = scenario => allowLegacyScenarioGear && scenarios.includes(scenario);\n    const isAnyScenarioActive = list => allowLegacyScenarioGear && list.some(value => scenarios.includes(value));\n    const hasGimbal = isScenarioActive('Gimbal');\n    if (isAnyScenarioActive(['Trinity', 'Steadicam'])) {\n        for (let i = 0; i < 2; i++) {\n            riggingAcc.push('D-Tap Splitter');\n            riggingAcc.push('D-Tap Extension 50 cm (Steadicam/Trinity)');\n        }\n        for (let i = 0; i < 2; i++) {\n            riggingAcc.push('D-Tap Extension 50 cm (Spare)');\n        }\n    }\n    const handleSelections = info.cameraHandle\n        ? info.cameraHandle.split(',').map(r => r.trim()).filter(Boolean)\n        : [];\n    const viewfinderExtSelections = info.viewfinderExtension\n        ? info.viewfinderExtension.split(',').map(r => r.trim()).filter(Boolean)\n        : [];\n    const monitoringSettings = [\n        ...(info.viewfinderSettings ? info.viewfinderSettings.split(',').map(s => s.trim()) : []),\n        ...(info.frameGuides ? info.frameGuides.split(',').map(s => s.trim()) : []),\n        ...(info.aspectMaskOpacity ? info.aspectMaskOpacity.split(',').map(s => s.trim()) : []),\n        ...(info.monitoringSettings ? info.monitoringSettings.split(',').map(s => s.trim()) : []),\n    ].filter(Boolean);\n    const selectedLensNames = info.lenses\n        ? info.lenses.split(',').map(s => s.trim()).filter(Boolean)\n        : [];\n    const maxLensFront = selectedLensNames.reduce((max, name) => {\n        const lens = devices.lenses && devices.lenses[name];\n        return Math.max(max, lens && lens.frontDiameterMm || 0);\n    }, 0);\n    const parsedFilters = parseFilterTokens(info.filter);\n    const filterTypes = parsedFilters.map(f => f.type);\n    const needsSwingAway = filterTypes.some(t => t === 'ND Grad HE' || t === 'ND Grad SE');\n    const filterEntries = buildFilterGearEntries(parsedFilters);\n    let filterSelections = collectFilterAccessories(parsedFilters);\n    if (filterEntries.length && filterSelections.length) {\n        const filterNames = new Set(\n            filterEntries.map(entry => normalizeGearNameForComparison(entry.gearName))\n        );\n        filterSelections = filterSelections.filter(item =>\n            !filterNames.has(normalizeGearNameForComparison(item))\n        );\n    }\n    const filterSelectHtml = buildFilterSelectHtml(parsedFilters, filterEntries);\n    if (info.mattebox && !needsSwingAway) {\n        const matteboxSelection = info.mattebox.toLowerCase();\n        if (matteboxSelection.includes('clamp')) {\n            const lensNames = info.lenses\n                ? info.lenses.split(',').map(s => s.trim()).filter(Boolean)\n                : [];\n            const diameters = [...new Set(lensNames\n                .map(n => devices.lenses && devices.lenses[n] && devices.lenses[n].frontDiameterMm)\n                .filter(Boolean))];\n            diameters.forEach(d => filterSelections.push(`ARRI LMB 4x5 Clamp Adapter ${d}mm`));\n        }\n    }\n    viewfinderExtSelections.forEach(vf => supportAccNoCages.push(vf));\n    if (isAnyScenarioActive(['Rain Machine', 'Extreme rain'])) {\n        filterSelections.push('Schulz Sprayoff Micro');\n        filterSelections.push('Fischer RS to D-Tap cable 0,5m');\n        filterSelections.push('Fischer RS to D-Tap cable 0,5m');\n        filterSelections.push('Spare Disc (Schulz Sprayoff Micro)');\n    }\n    let gimbalSelectionsFinal = [];\n    let selectedGimbal = '';\n    if (hasGimbal) {\n        const gimbalSelections = info.gimbal\n            ? info.gimbal.split(',').map(s => s.trim()).filter(Boolean)\n            : [];\n        const bigLens = maxLensFront > 95;\n        if (gimbalSelections.length) {\n            gimbalSelectionsFinal = gimbalSelections.map(g => (/Ronin RS4 Pro/i.test(g) && bigLens ? 'DJI Ronin 2' : g));\n            if (gimbalSelectionsFinal.length === 1) selectedGimbal = gimbalSelectionsFinal[0];\n        } else {\n            const cam = devices && devices.cameras && devices.cameras[selectedNames.camera];\n            const weight = cam && cam.weight_g;\n            const isSmall = weight != null ? weight < 2000 : /(FX3|FX6|R5)/i.test(selectedNames.camera);\n            selectedGimbal = bigLens ? 'DJI Ronin 2' : (isSmall ? 'DJI Ronin RS4 Pro Combo' : 'DJI Ronin 2');\n            gimbalSelectionsFinal = [selectedGimbal];\n        }\n        if (/Ronin RS4 Pro/i.test(selectedGimbal) && maxLensFront <= 95) {\n            filterSelections.push('Tilta Mirage VND Kit');\n            filterSelections.push('Tilta 95 mm Polarizer Filter f\xFCr Tilta Mirage');\n            filterSelections.push('Vaxis 95 mm IRND Filter 0.3 + 0.6 + 0.9 + 1.2 Filter');\n            filterSelections.push('Vaxis 95mm Black Mist 1/4 + 1/8 Filter');\n        } else {\n            filterSelections.push('Arri KK.0038066 Flexible Sunshade Side Flag Holders Set');\n        }\n    }\n    const receiverLabels = [];\n    handheldPrefs.forEach(p => receiverLabels.push(`${p.role} handheld`));\n    largeMonitorPrefs.forEach(p => receiverLabels.push(`${p.role} 15-21\"`));\n    if (hasMotor) receiverLabels.push('Focus');\n    const receiverCount = receiverLabels.length;\n    if (selectedNames.video) {\n        monitoringSupportAcc.push('Antenna 5,8GHz 5dBi Long (spare)');\n        const rxName = selectedNames.video.replace(/ TX\\b/, ' RX');\n        if (devices && devices.wirelessReceivers && devices.wirelessReceivers[rxName]) {\n            const receivers = receiverCount || 1;\n            for (let i = 0; i < receivers; i++) {\n                monitoringSupportAcc.push('Antenna 5,8GHz 5dBi Long (spare)');\n            }\n        }\n    }\n    const addMonitorCables = label => {\n        monitoringSupportAcc.push(\n            `D-Tap to Lemo-2-pin Cable 0,3m (${label})`,\n            `D-Tap to Lemo-2-pin Cable 0,3m (${label})`,\n            `Ultraslim BNC Cable 0.3 m (${label})`,\n            `Ultraslim BNC Cable 0.3 m (${label})`\n        );\n    };\n    handheldPrefs.forEach(p => addMonitorCables(`${p.role} handheld`));\n    const addLargeMonitorCables = label => {\n        monitoringSupportAcc.push(\n            `D-Tap to Lemo-2-pin Cable 0,5m (${label})`,\n            `D-Tap to Lemo-2-pin Cable 0,5m (${label})`,\n            `Ultraslim BNC Cable 0.5 m (${label})`,\n            `Ultraslim BNC Cable 0.5 m (${label})`\n        );\n    };\n    largeMonitorPrefs.forEach(p => addLargeMonitorCables(`${p.role} 15-21\"`));\n    if (hasMotor) {\n        monitoringSupportAcc.push(\n            'D-Tap to Mini XLR 3-pin Cable 0,3m (Focus)',\n            'D-Tap to Mini XLR 3-pin Cable 0,3m (Focus)',\n            'Ultraslim BNC Cable 0.3 m (Focus)',\n            'Ultraslim BNC Cable 0.3 m (Focus)'\n        );\n    }\n    const handleName = 'SHAPE Telescopic Handle ARRI Rosette Kit 12\"';\n    const addHandle = () => {\n        if (!supportAccNoCages.includes(handleName)) {\n            supportAccNoCages.push(handleName);\n        }\n    };\n    if (isScenarioActive('Handheld') && isScenarioActive('Easyrig')) {\n        addHandle();\n    }\n    if (handleSelections.includes('Hand Grips')) {\n        addHandle();\n    }\n    if (handleSelections.includes('Handle Extension')) {\n        supportAccNoCages.push('ARRI K2.0019797 HEX-3');\n    }\n    if (handleSelections.includes('L-Handle')) {\n        supportAccNoCages.push('ARRI KK.0037820 Handle Extension Set');\n    }\n    const projectInfo = { ...info };\n    const crewRoleLabels = texts[currentLang]?.crewRoles || texts.en?.crewRoles || {};\n    if (Array.isArray(info.people)) {\n        const crewEntriesHtml = [];\n        const crewEntriesText = [];\n        info.people\n            .filter(p => p.role && p.name)\n            .forEach(p => {\n                const roleLabel = crewRoleLabels[p.role] || p.role || '';\n                const safeRole = escapeHtml(roleLabel);\n                const nameValue = typeof p.name === 'string' ? p.name.trim() : (p.name ? String(p.name).trim() : '');\n                if (!nameValue) {\n                    return;\n                }\n                const safeName = escapeHtml(nameValue);\n                const detailLinks = [];\n                const detailText = [];\n                const phoneValue = typeof p.phone === 'string' ? p.phone.trim() : (p.phone ? String(p.phone).trim() : '');\n                if (phoneValue) {\n                    const phoneHref = formatPhoneHref(phoneValue);\n                    const safePhone = escapeHtml(phoneValue);\n                    detailText.push(phoneValue);\n                    if (phoneHref) {\n                        detailLinks.push(`<a href=\"tel:${phoneHref}\" class=\"req-contact-link\">${safePhone}</a>`);\n                    } else {\n                        detailLinks.push(safePhone);\n                    }\n                }\n                const emailValue = typeof p.email === 'string' ? p.email.trim() : (p.email ? String(p.email).trim() : '');\n                if (emailValue) {\n                    const emailHref = formatEmailHref(emailValue);\n                    const safeEmail = escapeHtml(emailValue);\n                    detailText.push(emailValue);\n                    if (emailHref) {\n                        detailLinks.push(`<a href=\"mailto:${emailHref}\" class=\"req-contact-link\">${safeEmail}</a>`);\n                    } else {\n                        detailLinks.push(safeEmail);\n                    }\n                }\n                const linkDetails = detailLinks.length ? ` (${detailLinks.join(', ')})` : '';\n                const plainDetails = detailText.length ? ` (${detailText.join(', ')})` : '';\n                crewEntriesHtml.push(`<span class=\"crew-entry\">${safeRole}: ${safeName}${linkDetails}</span>`);\n                crewEntriesText.push(`${roleLabel}: ${nameValue}${plainDetails}`);\n            });\n        if (crewEntriesHtml.length) {\n            projectInfo.crew = {\n                __html: crewEntriesHtml.join('<br>'),\n                text: crewEntriesText.join('\\n')\n            };\n        }\n    }\n    delete projectInfo.people;\n    if (Array.isArray(info.prepDays)) {\n        projectInfo.prepDays = info.prepDays.join('\\n');\n    }\n    if (Array.isArray(info.shootingDays)) {\n        projectInfo.shootingDays = info.shootingDays.join('\\n');\n    }\n    if (monitoringSettings.length) {\n        projectInfo.monitoringSupport = monitoringSettings.join(', ');\n    }\n    delete projectInfo.monitoringSettings;\n    delete projectInfo.viewfinderSettings;\n    delete projectInfo.frameGuides;\n    delete projectInfo.aspectMaskOpacity;\n    const projectTitleSource = getCurrentProjectName() || info.projectName || '';\n    const projectTitle = escapeHtml(projectTitleSource);\n    const projectLabels = texts[currentLang]?.projectFields || texts.en?.projectFields || {};\n    const projectFormTexts = texts[currentLang]?.projectForm || texts.en?.projectForm || {};\n    const excludedFields = new Set([\n        'cameraHandle',\n        'viewfinderExtension',\n        'mattebox',\n        'videoDistribution',\n        'monitoringConfiguration',\n        'focusMonitor',\n        'tripodHeadBrand',\n        'tripodBowl',\n        'tripodTypes',\n        'tripodSpreader',\n        'sliderBowl',\n        'easyrig',\n        'lenses',\n        'viewfinderSettings',\n        'frameGuides',\n        'aspectMaskOpacity',\n        'filter',\n        'viewfinderEyeLeatherColor',\n        'directorMonitor',\n        'dopMonitor',\n        'gafferMonitor',\n        'directorMonitor15',\n        'comboMonitor15',\n        'dopMonitor15',\n        'proGaffColor1',\n        'proGaffWidth1',\n        'proGaffColor2',\n        'proGaffWidth2'\n    ]);\n    const infoEntries = Object.entries(projectInfo)\n        .filter(([k, v]) => v && k !== 'projectName' && !excludedFields.has(k));\n    const boxesHtml = infoEntries.length ? '<div class=\"requirements-grid\">' +\n        infoEntries.map(([k, v]) => {\n            const value = formatRequirementValue(v);\n            const label = projectLabels[k] || k;\n            const iconHtml = iconMarkup(projectFieldIcons[k], {\n                className: 'req-icon',\n                size: 'var(--req-icon-size)'\n            });\n            return `<div class=\"requirement-box\" data-field=\"${k}\">${iconHtml}<span class=\"req-label\">${escapeHtml(label)}</span><span class=\"req-value\">${value}</span></div>`;\n        }).join('') + '</div>' : '';\n    const requirementsHeading = projectFormTexts.heading || 'Project Requirements';\n    const infoHtml = infoEntries.length ? `<h3>${escapeHtml(requirementsHeading)}</h3>${boxesHtml}` : '';\n    const formatItems = arr => {\n        const counts = {};\n        arr.filter(Boolean).map(addArriKNumber).forEach(item => {\n            const match = item.trim().match(/^(.*?)(?: \\(([^()]+)\\))?$/);\n            const base = match ? match[1].trim() : item.trim();\n            const ctx = match && match[2] ? match[2].trim() : '';\n            if (!counts[base]) {\n                counts[base] = { total: 0, ctxCounts: {} };\n            }\n            counts[base].total++;\n            counts[base].ctxCounts[ctx] = (counts[base].ctxCounts[ctx] || 0) + 1;\n        });\n        return Object.entries(counts)\n            .sort(([a], [b]) => a.localeCompare(b, undefined, { sensitivity: 'base' }))\n            .map(([base, { total, ctxCounts }]) => {\n                const ctxKeys = Object.keys(ctxCounts);\n                const hasContext = ctxKeys.some(c => c);\n                let ctxParts = [];\n                if (hasContext) {\n                    if (base === 'sand bag') {\n                        const realEntries = Object.entries(ctxCounts)\n                            .filter(([c]) => c && c.toLowerCase() !== 'spare')\n                            .sort(([a], [b]) => a.localeCompare(b, undefined, { sensitivity: 'base' }));\n                        const usedCount = realEntries.reduce((sum, [, count]) => sum + count, 0);\n                        const spareCount = total - usedCount;\n                        ctxParts = realEntries.map(([c, count]) => `${count}x ${c}`);\n                        if (spareCount > 0) ctxParts.push(`${spareCount}x Spare`);\n                    } else if (base.startsWith('Bebob ')) {\n                        const realEntries = Object.entries(ctxCounts)\n                            .filter(([c]) => c && c.toLowerCase() !== 'spare')\n                            .sort(([a], [b]) => a.localeCompare(b, undefined, { sensitivity: 'base' }));\n                        const usedCount = realEntries.reduce((sum, [, count]) => sum + count, 0);\n                        const spareCount = total - usedCount;\n                        ctxParts = realEntries.map(([c, count]) => `${count}x ${c}`);\n                        if (spareCount > 0) ctxParts.push(`${spareCount}x Spare`);\n                    } else {\n                        const realEntries = Object.entries(ctxCounts)\n                            .filter(([c]) => c && c.toLowerCase() !== 'spare')\n                            .sort(([a], [b]) => a.localeCompare(b, undefined, { sensitivity: 'base' }));\n                        ctxParts = realEntries.map(([c, count]) => `${count}x ${c}`);\n                        const spareCount = Object.entries(ctxCounts)\n                            .filter(([c]) => c && c.toLowerCase() === 'spare')\n                            .reduce((sum, [, count]) => sum + count, 0);\n                        if (spareCount > 0) {\n                            ctxParts.push(`${spareCount}x Spare`);\n                        } else if (base === 'D-Tap Extension 50 cm') {\n                            const usedCount = realEntries.reduce((sum, [, count]) => sum + count, 0);\n                            const remaining = total - usedCount;\n                            if (remaining > 0) ctxParts.push(`${remaining}x Spare`);\n                        }\n                    }\n                }\n                const ctxStr = ctxParts.length ? ` (${ctxParts.join(', ')})` : '';\n                const translatedBase = gearItemTranslations[currentLang]?.[base] || base;\n                const displayName = `${translatedBase}${ctxStr}`;\n                const dataName = `${base}${ctxStr}`;\n                return `<span class=\"gear-item\" data-gear-name=\"${escapeHtml(dataName)}\">${total}x ${escapeHtml(displayName)}</span>`;\n            })\n            .join('<br>');\n    };\n    const ensureItems = (arr, categoryPath) => {\n        if (typeof registerDevice !== 'function') return;\n        const entries = {};\n        arr.filter(Boolean).forEach(item => {\n            const match = item.trim().match(/^(.*?)(?: \\(([^()]+)\\))?$/);\n            const base = match ? match[1].trim() : item.trim();\n            entries[base] = entries[base] || {};\n        });\n        if (Object.keys(entries).length) {\n            registerDevice(categoryPath, entries);\n        }\n    };\n    const categoryGroups = [];\n    const addRow = (cat, items) => {\n        categoryGroups.push(\n            `<tbody class=\"category-group\"><tr class=\"category-row\"><td>${cat}</td></tr><tr><td>${items}</td></tr></tbody>`\n        );\n    };\n    addRow('Camera', formatItems([selectedNames.camera]));\n    const cameraSupportText = formatItems(supportAccNoCages);\n    let cageSelectHtml = '';\n    if (compatibleCages.length) {\n        const options = compatibleCages.map(c => `<option value=\"${escapeHtml(c)}\"${c === selectedNames.cage ? ' selected' : ''}>${escapeHtml(addArriKNumber(c))}</option>`).join('');\n        cageSelectHtml = `<span class=\"cage-select-wrapper\"><span>1x</span><select id=\"gearListCage\">${options}</select></span>`;\n    }\n    addRow('Camera Support', [cameraSupportText, cageSelectHtml].filter(Boolean).join('<br>'));\n    let mediaItems = '';\n    const cam = devices && devices.cameras && selectedNames.camera ? devices.cameras[selectedNames.camera] : null;\n    if (cam && Array.isArray(cam.recordingMedia) && cam.recordingMedia.length) {\n        const sizeMap = {\n            'CFexpress Type A': '320GB',\n            'CFast 2.0': '512GB',\n            'CFexpress Type B': '512GB',\n            'Codex Compact Drive': '1TB',\n            'AXS Memory A-Series slot': '1TB',\n            'SD': '128GB',\n            'SD Card': '128GB',\n            'SDXC': '128GB',\n            'XQD Card': '120GB',\n            'RED MINI-MAG': '512GB',\n            'REDMAG 1.8\" SSD': '512GB',\n            'Blackmagic Media Module': '8TB',\n            'DJI PROSSD': '1TB',\n            'USB-C 3.1 Gen 1 expansion port for external media': '1TB',\n            'USB-C 3.1 Gen 2 expansion port for external media': '1TB',\n            'USB-C to external SSD/HDD': '1TB'\n        };\n        mediaItems = cam.recordingMedia\n            .slice(0, 1)\n            .map(m => {\n                const type = m && m.type ? m.type : '';\n                if (!type) return '';\n                let size = '';\n                if (m.notes) {\n                    const match = m.notes.match(/(\\d+(?:\\.\\d+)?\\s*(?:TB|GB))/i);\n                    if (match) size = match[1].toUpperCase();\n                }\n                if (!size) size = sizeMap[type] || '512GB';\n                return `4x ${escapeHtml(size)} ${escapeHtml(type)}<br>2x ${escapeHtml(type)} reader with USB-C`;\n            })\n            .filter(Boolean)\n            .join('<br>');\n    }\n    addRow('Media', mediaItems);\n    const lensDisplayNames = selectedLensNames.map(name => {\n        const lens = devices.lenses && devices.lenses[name];\n        const base = addArriKNumber(name);\n        if (!lens) return base;\n        const attrs = [];\n        if (lens.weight_g) attrs.push(`${lens.weight_g}g`);\n        if (lens.clampOn) {\n            if (lens.frontDiameterMm) attrs.push(`${lens.frontDiameterMm}mm clamp-on`);\n            else attrs.push('clamp-on');\n        } else if (lens.clampOn === false) {\n            attrs.push('no clamp-on');\n        }\n        const minFocus = lens.minFocusMeters ?? lens.minFocus ?? (lens.minFocusCm ? lens.minFocusCm / 100 : null);\n        if (minFocus) attrs.push(`${minFocus}m min focus`);\n        return attrs.length ? `${base} (${attrs.join(', ')})` : base;\n    });\n    addRow('Lens', formatItems(lensDisplayNames));\n    const parseRodTypes = raw => {\n        if (!raw && raw !== 0) return [];\n        const values = Array.isArray(raw) ? raw : [raw];\n        const rodSet = new Set();\n        values.forEach(value => {\n            const text = (value ?? '').toString().toLowerCase();\n            if (!text) return;\n            if (/\\b15\\s*mm\\b/.test(text)) rodSet.add('15mm');\n            if (/\\b19\\s*mm\\b/.test(text)) rodSet.add('19mm');\n        });\n        const order = ['15mm', '19mm'];\n        return order.filter(type => rodSet.has(type));\n    };\n    const lensSupportItems = [];\n    const requiredRodTypes = new Set();\n    const addedRodPairs = new Set();\n    selectedLensNames.forEach(name => {\n        const lens = devices.lenses && devices.lenses[name];\n        if (!lens) return;\n        const normalizedRodTypes = parseRodTypes(lens.rodStandard);\n        const rodType = normalizedRodTypes[0] || (lens.rodStandard ? lens.rodStandard : '15mm');\n        const baseRodType = normalizedRodTypes[0] || (rodType === '19mm' ? '19mm' : '15mm');\n        const rodLength = lens.rodLengthCm || (baseRodType === '19mm' ? 45 : 30);\n        const rodKey = `${baseRodType}-${rodLength}`;\n        if (!addedRodPairs.has(rodKey)) {\n            lensSupportItems.push(`${baseRodType} rods ${rodLength}cm`);\n            addedRodPairs.add(rodKey);\n        }\n        const typesForRequirement = normalizedRodTypes.length ? normalizedRodTypes : [baseRodType];\n        typesForRequirement.forEach(rt => requiredRodTypes.add(rt));\n        if (lens.needsLensSupport) {\n            lensSupportItems.push(`${baseRodType} lens support`);\n        }\n    });\n    const cageRod = devices.accessories?.cages?.[selectedNames.cage]?.rodStandard;\n    const cageRodTypes = parseRodTypes(cageRod);\n    const hasCageRodInfo = Array.isArray(cageRod) ? cageRod.length > 0 : Boolean(cageRod);\n    requiredRodTypes.forEach(rt => {\n        if (hasCageRodInfo && !cageRodTypes.includes(rt)) {\n            lensSupportItems.push(`${glyphText(ICON_GLYPHS.warning)}\\u00A0cage incompatible with ${rt} rods`);\n        }\n    });\n    addRow('Lens Support', formatItems(lensSupportItems));\n    addRow('Matte box + filter', [filterSelectHtml, formatItems(filterSelections)].filter(Boolean).join('<br>'));\n    const motorItems = [];\n    const clmSpareAdded = { clm3: false, clm4: false, clm5: false };\n    selectedNames.motors.forEach(name => {\n        const lower = name.toLowerCase();\n        if (/cforce\\s*mini\\s*rf|cforce\\s*rf/.test(lower)) {\n            motorItems.push('ARRI KK.0040345 CFORCE MINI RF Basic Set 2');\n        } else if (/cforce\\s*mini/.test(lower) && !/rf/.test(lower)) {\n            motorItems.push('ARRI KK.0040344 Cforce Mini Basic Set 2');\n        } else if (/cforce\\s*plus/.test(lower)) {\n            motorItems.push('Arri KK.0008824 cforce plus Basic Set');\n            motorItems.push('ARRI K2.0009335 Cforce Plus Gear M0.8/32p, 60t');\n        } else if (/clm-3/.test(lower)) {\n            motorItems.push('Arri KK.0005854 Controlled Lens Motor CLM-3 Basic Set');\n            if (!clmSpareAdded.clm3) {\n                motorItems.push('Arri K2.65145.0, Cable CLM-3 (7p) - CLM/FIZ (12p) (0,8m/2.6ft) (spare)');\n                clmSpareAdded.clm3 = true;\n            }\n        } else if (/clm-4/.test(lower)) {\n            motorItems.push('ARRI Controlled Lens Motor CLM-4, Basic Kit (KK.0005855)');\n            if (!clmSpareAdded.clm4) {\n                motorItems.push('Arri K2.72099.0 CLM-4 Motor Cable (spare)');\n                clmSpareAdded.clm4 = true;\n            }\n        } else if (/clm-5/.test(lower)) {\n            motorItems.push('Arri K2.0006361 Controlled Lens Motor CLM-5 Basic Set');\n            if (!clmSpareAdded.clm5) {\n                motorItems.push('Arri K2.0006361 Controlled Lens Motor CLM-5 Basic Set (spare)');\n                clmSpareAdded.clm5 = true;\n            }\n        } else {\n            motorItems.push(name);\n        }\n    });\n    const distanceItems = [];\n    const distanceName = selectedNames.distance;\n    if (distanceName) {\n        const lowerName = distanceName.toLowerCase();\n        if (lowerName === 'udm-1 + lcube') {\n            distanceItems.push('Arri KK.0005853 Ultrasonic Distance Measure UDM-1 Basic Set');\n            const hasRiaController = selectedNames.controllers\n                .some(ctrl => /ria-1/i.test(ctrl));\n            const isAlexa35 = /alexa 35/i.test(selectedNames.camera || '');\n            if (!hasRiaController && !isAlexa35) {\n                distanceItems.push('Arri KK.0009001 LCUBE CUB-1 Basic Set');\n            }\n        } else {\n            distanceItems.push(distanceName);\n        }\n    }\n    addRow('LDS (FIZ)', formatItems([\n        ...motorItems,\n        ...selectedNames.controllers,\n        ...distanceItems,\n        ...fizCableAcc\n    ]));\n    let batteryItems = '';\n    if (selectedNames.battery) {\n        let count = batteryCountElem ? parseInt(batteryCountElem.textContent, 10) : NaN;\n        if (!count || isNaN(count)) count = 1;\n        const safeBatt = escapeHtml(addArriKNumber(selectedNames.battery));\n        batteryItems = `${count}x ${safeBatt}`;\n        const swapName = hotswapSelect && hotswapSelect.value && hotswapSelect.value !== 'None' ? getText(hotswapSelect) : '';\n        if (swapName) {\n            batteryItems += `<br>1x ${escapeHtml(swapName)}`;\n        }\n    }\n    addRow('Camera Batteries', batteryItems);\n    let monitoringItems = '';\n    const monitorSizes = [];\n    if (selectedNames.viewfinder) {\n        monitoringItems += `1x <strong>Viewfinder</strong> - ${escapeHtml(addArriKNumber(selectedNames.viewfinder))}`;\n    }\n    if (selectedNames.monitor) {\n        const size = devices?.monitors?.[selectedNames.monitor]?.screenSizeInches;\n        if (size) monitorSizes.push(size);\n        const sizeHtml = size ? `${size}&quot; - ` : '';\n        monitoringItems += (monitoringItems ? '<br>' : '') + `1x <strong>Onboard Monitor</strong> - ${sizeHtml}${escapeHtml(addArriKNumber(selectedNames.monitor))} - incl. Sunhood`;\n    }\n    handheldPrefs.forEach(({ role, size }) => {\n        const monitorsDb = devices && devices.monitors ? devices.monitors : {};\n        const names = Object.keys(monitorsDb)\n            .filter(n => (!monitorsDb[n].wirelessTx || monitorsDb[n].wirelessRX))\n            .sort(localeSort);\n        const infoKey = role === 'DoP' ? 'dopMonitor' : `${role.toLowerCase()}Monitor`;\n        let defaultName = info[infoKey] && names.includes(info[infoKey])\n            ? info[infoKey]\n            : names.includes('SmallHD Ultra 7') ? 'SmallHD Ultra 7' : names[0];\n        if (!info[infoKey] && size) {\n            const sized = names.find(n => monitorsDb[n].screenSizeInches === size);\n            if (size === 7 && names.includes('SmallHD Ultra 7')) {\n                defaultName = 'SmallHD Ultra 7';\n            } else if (sized) {\n                defaultName = sized;\n            }\n        }\n        const opts = names\n            .map(n => `<option value=\"${escapeHtml(n)}\"${n === defaultName ? ' selected' : ''}>${escapeHtml(addArriKNumber(n))}</option>`)\n            .join('');\n        const idSuffix = role === 'DoP' ? 'Dop' : role;\n        const labelRole = role.replace(/s$/, '');\n        const selectedSize = devices && devices.monitors && devices.monitors[defaultName]\n            ? devices.monitors[defaultName].screenSizeInches\n            : '';\n        monitoringItems += (monitoringItems ? '<br>' : '') + `1x <strong>${labelRole} Handheld Monitor</strong> - <span id=\"monitorSize${idSuffix}\">${selectedSize}&quot;</span> - <select id=\"gearList${idSuffix}Monitor\">${opts}</select> incl. Directors cage, shoulder strap, sunhood, rigging for teradeks`;\n        monitorSizes.push(selectedSize);\n    });\n    largeMonitorPrefs.forEach(({ role }) => {\n        const dirDb = devices && devices.directorMonitors ? devices.directorMonitors : {};\n        const names = Object.keys(dirDb).filter(n => n !== 'None').sort(localeSort);\n        const infoKey = role === 'DoP' ? 'dopMonitor15' : role === 'Combo' ? 'comboMonitor15' : 'directorMonitor15';\n        let defaultName = info[infoKey] && names.includes(info[infoKey])\n            ? info[infoKey]\n            : 'SmallHD Cine 24\" 4K High-Bright Monitor';\n        const opts = names\n            .map(n => `<option value=\"${escapeHtml(n)}\"${n === defaultName ? ' selected' : ''}>${escapeHtml(addArriKNumber(n))}</option>`)\n            .join('');\n        const idSuffix = role === 'DoP' ? 'Dop' : role;\n        const size = dirDb[defaultName]?.screenSizeInches || '';\n        monitoringItems += (monitoringItems ? '<br>' : '') +\n            `1x <strong>${role} Monitor</strong> - <span id=\"monitorSize${idSuffix}15\">${size}&quot;</span> - <select id=\"gearList${idSuffix}Monitor15\">${opts}</select> incl. sunhood, V-Mount, AC Adapter and Wooden Camera Ultra QR Monitor Mount (Baby Pin, C-Stand)`;\n        if (size) monitorSizes.push(size);\n    });\n    if (hasMotor) {\n        const monitorsDb = devices && devices.monitors ? devices.monitors : {};\n        const names = Object.keys(monitorsDb)\n            .filter(n => (!monitorsDb[n].wirelessTx || monitorsDb[n].wirelessRX))\n            .sort(localeSort);\n        const defaultName = info.focusMonitor && names.includes(info.focusMonitor)\n            ? info.focusMonitor\n            : names.includes('TV Logic F7HS') ? 'TV Logic F7HS' : names[0];\n        const opts = names\n            .map(n => `<option value=\"${escapeHtml(n)}\"${n === defaultName ? ' selected' : ''}>${escapeHtml(addArriKNumber(n))}</option>`)\n            .join('');\n        const selectedSize = monitorsDb[defaultName]?.screenSizeInches || '';\n        monitoringItems += (monitoringItems ? '<br>' : '') +\n            `1x <strong>Focus Monitor</strong> - <span id=\"monitorSizeFocus\">${selectedSize}&quot;</span> - <select id=\"gearListFocusMonitor\">${opts}</select> incl Directors cage, shoulder strap, sunhood, rigging for teradeks`;\n        if (selectedSize) monitorSizes.push(selectedSize);\n    }\n    const monitoringGear = [];\n    const wirelessSize = monitorSizes.includes(5) ? 5 : 7;\n    if (selectedNames.video) {\n        monitoringGear.push(`Wireless Transmitter - ${wirelessSize}&quot; - ${addArriKNumber(selectedNames.video)}`);\n        const rxName = selectedNames.video.replace(/ TX\\b/, ' RX');\n        if (devices && devices.wirelessReceivers && devices.wirelessReceivers[rxName]) {\n            receiverLabels.forEach(label => {\n                monitoringGear.push(`Wireless Receiver - ${wirelessSize}&quot; - ${addArriKNumber(rxName)} (${label})`);\n            });\n        }\n    }\n    if (monitoringGear.length) {\n        const gearHtml = formatItems(monitoringGear)\n            .replace(/>(\\d+x )Wireless Transmitter/g, '>$1<strong>Wireless Transmitter</strong>')\n            .replace(/>(\\d+x )Wireless Receiver/g, '>$1<strong>Wireless Receiver</strong>')\n            .replace(/&amp;quot;/g, '&quot;');\n        monitoringItems += (monitoringItems ? '<br>' : '') + gearHtml;\n    }\n    let monitoringBatteryItems = [];\n    const bebob98 = Object.keys(devices.batteries || {}).find(n => /V98micro/i.test(n)) || 'Bebob V98micro';\n    handheldPrefs.forEach(p => {\n        for (let i = 0; i < 3; i++) monitoringBatteryItems.push(`${bebob98} (${p.role} handheld)`);\n    });\n    if (hasMotor) {\n        const bebob150 = Object.keys(devices.batteries || {}).find(n => /V150micro/i.test(n)) || 'Bebob V150micro';\n        for (let i = 0; i < 3; i++) monitoringBatteryItems.push(`${bebob150} (Focus)`);\n    }\n    const bebob290 = Object.keys(devices.batteries || {}).find(n => /V290RM-Cine/i.test(n)) || 'Bebob V290RM-Cine';\n    largeMonitorPrefs.forEach(p => {\n        monitoringBatteryItems.push(`${bebob290} (${p.role} 15-21\")`, `${bebob290} (${p.role} 15-21\")`);\n    });\n    addRow('Monitoring Batteries', formatItems(monitoringBatteryItems));\n    addRow('Chargers', formatItems(chargersAcc));\n    addRow('Monitoring', monitoringItems);\n    ensureItems(monitoringSupportAcc, 'accessories.monitoringSupport');\n    const monitoringSupportHardware = formatItems(monitoringSupportAcc);\n    const monitoringSupportItems = monitoringSupportHardware;\n    addRow('Monitoring support', monitoringSupportItems);\n    const cartsTransportationItems = [\n        'Magliner Senior - with quick release mount + tripod holder + utility tray + O\u2018Connor-Aufh\xE4ngung',\n        ...Array(10).fill('Securing Straps (25mm wide)'),\n        'Loading Ramp (pair, 420kg)',\n        ...Array(20).fill('Ring Fitting for Airline Rails')\n    ];\n    ensureItems(cartsTransportationItems, 'accessories.carts');\n    const gripItems = [];\n    let needsStandardTripod = false;\n    let sliderSelectHtml = '';\n    let easyrigSelectHtml = '';\n    handheldPrefs.forEach(p => {\n        gripItems.push(`Avenger C-Stand Sliding Leg 20\" (${p.role} handheld)`);\n        gripItems.push(`Steelfingers Wheel C-Stand 3er Set (${p.role} handheld)`);\n        gripItems.push(`Lite-Tite Swivel Aluminium Umbrella Adapter (${p.role} handheld)`);\n        riggingAcc.push(`Spigot with male 3/8\" and 1/4\" (${p.role} handheld)`);\n    });\n    largeMonitorPrefs.forEach(p => {\n        gripItems.push(`Matthews Monitor Stand II (249562) (${p.role} 15-21\")`);\n        gripItems.push(`Avenger C590 Conka Bonka Stativ-Verl\xE4ngerungen Set (${p.role} 15-21\")`);\n        gripItems.push(`Impact Baby to Junior Receiver Adapter (${p.role} 15-21\")`);\n        gripItems.push(`Matthews BIG F'ING Monitor Wheel Set (3 pieces) (${p.role} 15-21\")`);\n        riggingAcc.push(`ULCS Bracket with 1/4\" to 1/4\" (${p.role} 15-21\")`);\n        gripItems.push(`Manfrotto 635 Quick-Action Super Clamp (${p.role} 15-21\")`);\n        riggingAcc.push(`Spigot with male 3/8\" and 1/4\" (${p.role} 15-21\")`);\n        riggingAcc.push(`Cine Quick Release (${p.role} 15-21\")`);\n        riggingAcc.push(`D-Tap Splitter (${p.role} 15-21\")`);\n        riggingAcc.push(`D-Tap Splitter (${p.role} 15-21\")`);\n    });\n    if (hasMotor) {\n        gripItems.push('Avenger C-Stand Sliding Leg 20\" (Focus)');\n        gripItems.push('Steelfingers Wheel C-Stand 3er Set (Focus)');\n        gripItems.push('Lite-Tite Swivel Aluminium Umbrella Adapter (Focus)');\n    }\n    if (isScenarioActive('Easyrig')) {\n        const stabiliser = devices && devices.accessories && devices.accessories.cameraStabiliser && devices.accessories.cameraStabiliser['Easyrig 5 Vario'];\n        const opts = stabiliser && Array.isArray(stabiliser.options) ? stabiliser.options : [];\n        const options = ['no further stabilisation', ...opts];\n        const optsHtml = options.map(o => `<option value=\"${escapeHtml(o)}\">${escapeHtml(addArriKNumber(o))}</option>`).join('');\n        easyrigSelectHtml = `1x Easyrig 5 Vario <select id=\"gearListEasyrig\">${optsHtml}</select>`;\n    }\n    if (hasGimbal) {\n        gripItems.push(...gimbalSelectionsFinal);\n    }\n    const frictionArmCount = hasGimbal ? 2 : 1;\n    gripItems.push(...Array(frictionArmCount).fill('Manfrotto 244N Friktion Arm'));\n    if (hasGimbal) {\n        gripItems.push('Avenger D200B Grip Head');\n        gripItems.push('Spigot with male 3/8\" and 1/4\"');\n    }\n    if (isScenarioActive('Cine Saddle')) gripItems.push('Cinekinetic Cinesaddle');\n    if (isScenarioActive('Steadybag')) gripItems.push('Steadybag');\n    if (isScenarioActive('Jib')) {\n        gripItems.push('Pro Sup EJIb-Arm');\n        gripItems.push('Jib counter weights');\n        needsStandardTripod = true;\n    }\n    if (isScenarioActive('Slider')) {\n        const options = ['', '75er bowl', '100er bowl', '150er bowl', 'Mitchell Mount'].map(o => `<option value=\"${escapeHtml(o)}\"${o === info.sliderBowl ? ' selected' : ''}>${escapeHtml(addArriKNumber(o))}</option>`).join('');\n        sliderSelectHtml = `1x Prosup Tango Roller <select id=\"gearListSliderBowl\">${options}</select>`;\n        gripItems.push('Avenger Combo Stand 10 A1010CS 64-100 cm black');\n        gripItems.push('Avenger Combo Stand 10 A1010CS 64-100 cm black');\n        gripItems.push('Avenger Combo Stand 20 A1020B 110-198 cm black');\n        gripItems.push('Avenger Combo Stand 20 A1020B 110-198 cm black');\n        gripItems.push('Apple Box Set / B\xFChnenkisten Set');\n        gripItems.push('Apple Box Set / B\xFChnenkisten Set');\n        gripItems.push('Paganini set');\n        gripItems.push('Sand bag (Slider)');\n        gripItems.push('Sand bag (Slider)');\n        gripItems.push('Cable mat');\n        gripItems.push('Cable mat');\n        gripItems.push('Cable mat');\n    }\n    if (isScenarioActive('Slider') && isScenarioActive('Undersling mode')) {\n        gripItems.push('Tango Beam');\n    }\n    if (isScenarioActive('Outdoor')) {\n        riggingAcc.push('Spigot with male 3/8\" and 1/4\" (Focus Umbrella)');\n    }\n    if (isAnyScenarioActive(['Extreme heat', 'Extreme rain', 'Rain Machine'])) {\n        gripItems.push('Large Umbrella');\n        gripItems.push('Avenger A5036CS Roller 36 Low Base with Umbrella Mounting');\n    }\n    const tripodTypes = info.tripodTypes ? info.tripodTypes.split(',').map(s => s.trim()).filter(Boolean) : [];\n    const bowlType = info.tripodBowl;\n    const spreader = info.tripodSpreader;\n    const headBrand = info.tripodHeadBrand;\n    const headMap = {\n        'OConnor': {\n            '100mm bowl': \"O'Connor Ultimate 1040 Fluid-Head\",\n            '150mm bowl': \"O'Connor Ultimate 2560 Fluid-Head\",\n            'Mitchell Mount': \"O'Connor Ultimate 2560 Fluid-Head\"\n        },\n        'Sachtler': {\n            '75mm bowl': 'Sachtler aktiv8T S2068T',\n            '100mm bowl': 'Sachtler aktiv18T S2088T',\n            '150mm bowl': 'Sachtler Cine 30 3007'\n        }\n    };\n    const headName = headMap[headBrand] && headMap[headBrand][bowlType];\n    if (headName) {\n        gripItems.push(`${headName} ${bowlType}`);\n    }\n    tripodTypes.forEach(t => {\n        const base = bowlType ? `${bowlType} ${t}` : t;\n        if (t === 'Hi-Head') {\n            gripItems.push(base);\n        } else if (spreader) {\n            gripItems.push(`${base} + ${spreader}`);\n        } else {\n            gripItems.push(base);\n        }\n        if (t === 'Frog Tripod') {\n            gripItems.push('Sand bag (Frog Tripod)');\n        }\n        if (t === 'Hi-Head') {\n            gripItems.push('Sand bag (Hi-Head)');\n        }\n    });\n    if (needsStandardTripod && !gripItems.some(item => /Standard Tripod/.test(item))) {\n        gripItems.push('Standard Tripod');\n    }\n    const standCount = gripItems.filter(item => /\\bstand\\b/i.test(item) && !/wheel/i.test(item)).length;\n    if (standCount) {\n        gripItems.push(...Array(standCount * 3).fill('Tennis ball'));\n    }\n    const maglinerCount = cartsTransportationItems.filter(item => /Magliner/i.test(item)).length;\n    if (maglinerCount) {\n        gripItems.push(...Array(maglinerCount * 2).fill('Wooden wedge'));\n    }\n    ensureItems(riggingAcc, 'accessories.rigging');\n    ensureItems(gripItems, 'accessories.grip');\n    const riggingItems = formatItems(riggingAcc);\n    addRow('Rigging', riggingItems);\n    const powerItems = [\n        'Power Cable Drum 25-50 m',\n        ...Array(2).fill('Power Cable 10 m'),\n        ...Array(2).fill('Power Cable 5 m'),\n        ...Array(3).fill('Power Strip'),\n        ...Array(3).fill('PRCD-S (Portable Residual Current Device-Safety)'),\n        ...Array(3).fill('Power Three Way Splitter')\n    ];\n    if (isScenarioActive('Studio')) {\n        powerItems.push('Camera Power Supply');\n    }\n    ensureItems(powerItems, 'accessories.power');\n    addRow('Power', formatItems(powerItems));\n    addRow('Grip', [sliderSelectHtml, formatItems(gripItems), easyrigSelectHtml].filter(Boolean).join('<br>'));\n    addRow('Carts and Transportation', formatItems(cartsTransportationItems));\n    const miscExcluded = new Set([\n        'D-Tap to LEMO 2-pin',\n        'HDMI Cable',\n        'BNC SDI Cable',\n        'Ultraslim BNC Cable 0.5 m'\n    ]);\n    const miscItems = [...miscAcc].filter(item => !miscExcluded.has(item));\n    const consumables = [];\n    const hasViewfinder = Array.isArray(cam?.viewfinder) && cam.viewfinder.length > 0;\n    let eyeLeatherColor = info.viewfinderEyeLeatherColor || 'red';\n    const gaffTapeSelections = [\n        { id: 1, color: info.proGaffColor1 || 'red', width: info.proGaffWidth1 || '24mm' },\n        { id: 2, color: info.proGaffColor2 || 'blue', width: info.proGaffWidth2 || '24mm' }\n    ];\n    const baseConsumables = [\n        { name: 'Kimtech Wipes', count: 1 },\n        { name: 'Sprigs Red 1/4\"', count: 1, noScale: true },\n        { name: 'Clapper Stick', count: 2, klappen: true }\n    ];\n    let eyeLeatherCount = hasViewfinder ? 2 : 0;\n    let shootDays = 0;\n    let isWinterShoot = false;\n    const shootRanges = Array.isArray(info.shootingDays)\n        ? info.shootingDays\n        : (info.shootingDays ? [info.shootingDays] : []);\n    const winterMonths = new Set([9, 10, 11, 0, 1, 2, 3, 4]);\n    shootRanges.forEach(r => {\n        const parts = r.split(' to ');\n        if (parts.length === 2) {\n            const start = new Date(parts[0]);\n            const end = new Date(parts[1]);\n            if (!isNaN(start) && !isNaN(end)) {\n                shootDays += Math.floor((end - start) / (1000 * 60 * 60 * 24)) + 1;\n                if (!isWinterShoot) {\n                    const m = new Date(start);\n                    m.setHours(0, 0, 0, 0);\n                    while (m <= end) {\n                        if (winterMonths.has(m.getMonth())) {\n                            isWinterShoot = true;\n                            break;\n                        }\n                        m.setMonth(m.getMonth() + 1);\n                    }\n                }\n            }\n        }\n    });\n    let multiplier = 1;\n    if (shootDays > 21) {\n        multiplier = 4;\n    } else if (shootDays > 14) {\n        multiplier = 3;\n    } else if (shootDays > 7) {\n        multiplier = 2;\n    }\n    const klappenMultiplier = multiplier % 2 === 0 ? multiplier : Math.max(1, multiplier - 1);\n    for (const item of baseConsumables) {\n        let count = item.count;\n        if (item.noScale) {\n            // no scaling\n        } else if (item.klappen) {\n            count *= klappenMultiplier;\n        } else {\n            count *= multiplier;\n        }\n        for (let i = 0; i < count; i++) consumables.push(item.name);\n    }\n    if (eyeLeatherCount) eyeLeatherCount *= multiplier;\n    const needsRainProtection = isAnyScenarioActive(['Outdoor', 'Extreme rain', 'Rain Machine']);\n    if (needsRainProtection && selectedNames.camera) {\n        miscItems.push(`Rain Cover ${addArriKNumber(selectedNames.camera)}`);\n    }\n    const needsUmbrellas = needsRainProtection || isScenarioActive('Extreme heat');\n    if (needsUmbrellas) {\n        if (!miscItems.includes('Umbrella for Focus Monitor')) miscItems.push('Umbrella for Focus Monitor');\n        if (!miscItems.includes('Umbrella Magliner incl Mounting to Magliner')) miscItems.push('Umbrella Magliner incl Mounting to Magliner');\n    }\n    if (needsRainProtection) {\n        const monitorSizes = [];\n        if (monitorSelect && monitorSelect.value) {\n            const m = devices.monitors[monitorSelect.value];\n            if (m && m.screenSizeInches) monitorSizes.push(m.screenSizeInches);\n        }\n        const monitorsAbove10 = monitorSizes.filter(s => s > 10).length;\n        const monitorsUnder10 = monitorSizes.filter(s => s <= 10).length;\n        for (let i = 0; i < monitorsAbove10 + 2; i++) consumables.push('CapIt Large');\n        for (let i = 0; i < monitorsUnder10 + 3; i++) consumables.push('CapIt Medium');\n        for (let i = 0; i < 3; i++) consumables.push('CapIt Small');\n        for (let i = 0; i < 10; i++) consumables.push('Duschhaube');\n        consumables.push('Magliner Rain Cover Transparent');\n    }\n    const needsHairDryer =\n        (isWinterShoot && isScenarioActive('Outdoor')) ||\n        isScenarioActive('Extreme cold (snow)');\n    const needsHandAndFeetWarmers = isScenarioActive('Extreme cold (snow)');\n    if (needsHairDryer) {\n        miscItems.push('Hair Dryer');\n        if ([\"Sony Venice 2\", \"Sony Venice\"].includes(selectedNames.camera)) {\n            miscItems.push('Denz C0100072 Shut-Eye Heater f\xFCr Sony');\n        } else if ([\"Arri Alexa Mini\", \"Arri Amira\"].includes(selectedNames.camera)) {\n            miscItems.push('Arri K2.0003898 Heated Eyecup HE-7 for the MVF-1');\n        }\n    }\n    if (needsHandAndFeetWarmers) {\n        const warmersCount = Math.max(shootDays, 1) * 2;\n        for (let i = 0; i < warmersCount; i++) miscItems.push('Hand Warmers');\n        for (let i = 0; i < warmersCount; i++) miscItems.push('Feet Warmers');\n    }\n    const gaffColors = [\n        ['red', 'Red'],\n        ['blue', 'Blue'],\n        ['green', 'Green'],\n        ['yellow', 'Yellow'],\n        ['black', 'Black'],\n        ['pink', 'Pink'],\n        ['orange', 'Orange'],\n        ['violette', 'Violette'],\n        ['white', 'White']\n    ];\n    const gaffWidths = ['6mm', '12mm', '19mm', '24mm', '48mm'];\n    const proGaffCount = multiplier;\n    const proGaffHtml = gaffTapeSelections.map(({ id, color, width }) => {\n        const colorOpts = gaffColors\n            .map(([val, label]) => `<option value=\"${val}\"${val === color ? ' selected' : ''}>${label}</option>`)\n            .join('');\n        const widthOpts = gaffWidths\n            .map(val => `<option value=\"${val}\"${val === width ? ' selected' : ''}>${val}</option>`)\n            .join('');\n        return `<span class=\"gear-item\" data-gear-name=\"Pro Gaff Tape\">${proGaffCount}x Pro Gaff Tape <select id=\"gearListProGaffColor${id}\">${colorOpts}</select> <select id=\"gearListProGaffWidth${id}\">${widthOpts}</select></span>`;\n    }).join('<br>');\n    let eyeLeatherHtml = '';\n    if (eyeLeatherCount) {\n        const colors = [\n            ['red', 'Red'],\n            ['blue', 'Blue'],\n            ['natural', 'Natural'],\n            ['green', 'Green'],\n            ['purple', 'Purple'],\n            ['orange', 'Orange'],\n            ['gray', 'Gray'],\n            ['yellow', 'Yellow'],\n            ['jaguar', 'Jaguar'],\n            ['killer bee', 'Killer Bee'],\n            ['green rabbit', 'Green Rabbit'],\n            ['black', 'Black']\n        ];\n        const options = colors.map(([val, label]) => `<option value=\"${val}\"${val === eyeLeatherColor ? ' selected' : ''}>${label}</option>`).join('');\n        eyeLeatherHtml = `<span class=\"gear-item\" data-gear-name=\"Bluestar eye leather made of microfiber oval, large\">${eyeLeatherCount}x Bluestar eye leather made of microfiber oval, large <select id=\"gearListEyeLeatherColor\">${options}</select></span>`;\n    }\n    addRow('Miscellaneous', formatItems(miscItems));\n    addRow('Consumables', [eyeLeatherHtml, proGaffHtml, formatItems(consumables)].filter(Boolean).join('<br>'));\n    let body = `<h2>${projectTitle}</h2>`;\n    if (infoHtml) body += infoHtml;\n    const tableHtml = '<table class=\"gear-table\">' + categoryGroups.join('') + '</table>';\n    const infoForRules = {\n        ...info,\n        cameraSelection: selectedNames.camera,\n        monitorSelection: selectedNames.monitor,\n        wirelessSelection: selectedNames.video,\n        motorSelections: selectedNames.motors.slice(),\n        controllerSelections: selectedNames.controllers.slice(),\n        distanceSelection: selectedNames.distance,\n    };\n    const adjustedTable = applyAutoGearRulesToTableHtml(tableHtml, infoForRules);\n    body += '<h3>Gear List</h3>' + adjustedTable;\n    return body;\n}\n\n\nfunction getCurrentGearListHtml() {\n    if (!gearListOutput && !projectRequirementsOutput) return '';\n\n    let projHtml = '';\n    if (projectRequirementsOutput) {\n        const projClone = projectRequirementsOutput.cloneNode(true);\n        const editBtn = projClone.querySelector('#editProjectBtn');\n        if (editBtn) editBtn.remove();\n        const t = projClone.querySelector('h2');\n        if (t) t.remove();\n        projHtml = projClone.innerHTML.trim();\n    }\n\n    let gearHtml = '';\n    if (gearListOutput) {\n        const clone = gearListOutput.cloneNode(true);\n        const actions = clone.querySelector('#gearListActions');\n        if (actions) actions.remove();\n        const editBtn = clone.querySelector('#editProjectBtn');\n        if (editBtn) editBtn.remove();\n        ['Director', 'Dop', 'Gaffer', 'Focus'].forEach(role => {\n            const sel = clone.querySelector(`#gearList${role}Monitor`);\n            if (sel) {\n                const originalSel = gearListOutput.querySelector(`#gearList${role}Monitor`);\n                const val = originalSel ? originalSel.value : sel.value;\n                Array.from(sel.options).forEach(opt => {\n                    if (opt.value === val) {\n                        opt.setAttribute('selected', '');\n                    } else {\n                        opt.removeAttribute('selected');\n                    }\n                });\n            }\n        });\n        ['Director', 'Combo', 'Dop'].forEach(role => {\n            const sel = clone.querySelector(`#gearList${role}Monitor15`);\n            if (sel) {\n                const originalSel = gearListOutput.querySelector(`#gearList${role}Monitor15`);\n                const val = originalSel ? originalSel.value : sel.value;\n                Array.from(sel.options).forEach(opt => {\n                    if (opt.value === val) {\n                        opt.setAttribute('selected', '');\n                    } else {\n                        opt.removeAttribute('selected');\n                    }\n                });\n            }\n        });\n        const cageSel = clone.querySelector('#gearListCage');\n        if (cageSel) {\n            const originalSel = gearListOutput.querySelector('#gearListCage');\n            const val = originalSel ? originalSel.value : cageSel.value;\n            Array.from(cageSel.options).forEach(opt => {\n                if (opt.value === val) {\n                    opt.setAttribute('selected', '');\n                } else {\n                    opt.removeAttribute('selected');\n                }\n            });\n        }\n        const easyrigSel = clone.querySelector('#gearListEasyrig');\n        if (easyrigSel) {\n            const originalSel = gearListOutput.querySelector('#gearListEasyrig');\n            const val = originalSel ? originalSel.value : easyrigSel.value;\n            Array.from(easyrigSel.options).forEach(opt => {\n                if (opt.value === val) {\n                    opt.setAttribute('selected', '');\n                } else {\n                    opt.removeAttribute('selected');\n                }\n            });\n        }\n        const sliderSel = clone.querySelector('#gearListSliderBowl');\n        if (sliderSel) {\n            const originalSel = gearListOutput.querySelector('#gearListSliderBowl');\n            const val = originalSel ? originalSel.value : sliderSel.value;\n            Array.from(sliderSel.options).forEach(opt => {\n                if (opt.value === val) {\n                    opt.setAttribute('selected', '');\n                } else {\n                    opt.removeAttribute('selected');\n                }\n            });\n        }\n        const eyeSel = clone.querySelector('#gearListEyeLeatherColor');\n        if (eyeSel) {\n            const originalSel = gearListOutput.querySelector('#gearListEyeLeatherColor');\n            const val = originalSel ? originalSel.value : eyeSel.value;\n            Array.from(eyeSel.options).forEach(opt => {\n                if (opt.value === val) {\n                    opt.setAttribute('selected', '');\n                } else {\n                    opt.removeAttribute('selected');\n                }\n            });\n        }\n        [1, 2].forEach(i => {\n            const colorSel = clone.querySelector(`#gearListProGaffColor${i}`);\n            if (colorSel) {\n                const originalSel = gearListOutput.querySelector(`#gearListProGaffColor${i}`);\n                const val = originalSel ? originalSel.value : colorSel.value;\n                Array.from(colorSel.options).forEach(opt => {\n                    if (opt.value === val) {\n                        opt.setAttribute('selected', '');\n                    } else {\n                        opt.removeAttribute('selected');\n                    }\n                });\n            }\n            const widthSel = clone.querySelector(`#gearListProGaffWidth${i}`);\n            if (widthSel) {\n                const originalSel = gearListOutput.querySelector(`#gearListProGaffWidth${i}`);\n                const val = originalSel ? originalSel.value : widthSel.value;\n                Array.from(widthSel.options).forEach(opt => {\n                    if (opt.value === val) {\n                        opt.setAttribute('selected', '');\n                    } else {\n                        opt.removeAttribute('selected');\n                    }\n                });\n            }\n        });\n        clone.querySelectorAll('input[type=\"checkbox\"]').forEach(cb => {\n            if (cb.checked) {\n                cb.setAttribute('checked', '');\n            } else {\n                cb.removeAttribute('checked');\n            }\n        });\n        const table = clone.querySelector('.gear-table');\n        gearHtml = table ? '<h3>Gear List</h3>' + table.outerHTML : '';\n    }\n\n    if (!projHtml && !gearHtml) return '';\n\n    const projectName = getCurrentProjectName();\n    const titleHtml = projectName ? `<h2>${projectName}</h2>` : '';\n    return `${titleHtml}${projHtml}${gearHtml}`.trim();\n}\n\nfunction getGearListSelectors() {\n    if (!gearListOutput) return {};\n    const selectors = {};\n    gearListOutput.querySelectorAll('select[id]').forEach(sel => {\n        selectors[sel.id] = sel.multiple\n            ? Array.from(sel.selectedOptions).map(o => o.value)\n            : sel.value;\n    });\n    return selectors;\n}\n\nfunction applyGearListSelectors(selectors) {\n    if (!gearListOutput || !selectors) return;\n    Object.entries(selectors).forEach(([id, value]) => {\n        const sel = gearListOutput.querySelector(`#${id}`);\n        if (sel) {\n            if (sel.multiple) {\n                const vals = Array.isArray(value) ? value : [value];\n                Array.from(sel.options).forEach(opt => {\n                    opt.selected = vals.includes(opt.value);\n                });\n                sel.dispatchEvent(new Event('change'));\n            } else {\n                sel.value = value;\n                sel.dispatchEvent(new Event('change'));\n            }\n        }\n    });\n}\n\nfunction saveCurrentGearList() {\n    if (factoryResetInProgress) return;\n    const html = getCurrentGearListHtml();\n    const info = projectForm ? collectProjectFormData() : {};\n    info.sliderBowl = getSliderBowlValue();\n    info.easyrig = getEasyrigValue();\n    currentProjectInfo = deriveProjectInfo(info);\n    const projectStorageKey = getCurrentProjectStorageKey({ allowTyped: true });\n    const storageKey = getCurrentProjectStorageKey();\n    const projectRules = getProjectScopedAutoGearRules();\n    if (typeof saveProject === 'function' && typeof projectStorageKey === 'string') {\n        const payload = {\n            projectInfo: currentProjectInfo,\n            gearList: html\n        };\n        if (projectRules && projectRules.length) {\n            payload.autoGearRules = projectRules;\n        }\n        saveProject(projectStorageKey, payload);\n    }\n\n    if (!storageKey) return;\n\n    const setups = getSetups();\n    const existing = setups[storageKey];\n    if (!existing && !html && !currentProjectInfo && !(projectRules && projectRules.length)) {\n        return;\n    }\n\n    const setup = existing || {};\n    let changed = false;\n\n    if (html) {\n        if (setup.gearList !== html) {\n            setup.gearList = html;\n            changed = true;\n        }\n    } else if (Object.prototype.hasOwnProperty.call(setup, 'gearList')) {\n        delete setup.gearList;\n        changed = true;\n    }\n\n    if (currentProjectInfo) {\n        if (setup.projectInfo !== currentProjectInfo) {\n            setup.projectInfo = currentProjectInfo;\n            changed = true;\n        }\n    } else if (Object.prototype.hasOwnProperty.call(setup, 'projectInfo')) {\n        delete setup.projectInfo;\n        changed = true;\n    }\n\n    const existingRules = setup.autoGearRules;\n    const existingRulesSig = existingRules && existingRules.length ? stableStringify(existingRules) : '';\n    const newRulesSig = projectRules && projectRules.length ? stableStringify(projectRules) : '';\n    if (newRulesSig) {\n        if (existingRulesSig !== newRulesSig) {\n            setup.autoGearRules = projectRules;\n            changed = true;\n        }\n    } else if (Object.prototype.hasOwnProperty.call(setup, 'autoGearRules')) {\n        delete setup.autoGearRules;\n        changed = true;\n    }\n\n    if (!existing) {\n        setups[storageKey] = setup;\n        storeSetups(setups);\n    } else if (changed) {\n        setups[storageKey] = setup;\n        storeSetups(setups);\n    }\n}\n\nfunction deleteCurrentGearList() {\n    if (!confirm(texts[currentLang].confirmDeleteGearList)) return false;\n    if (!confirm(texts[currentLang].confirmDeleteGearListAgain)) return false;\n    const backupName = ensureAutoBackupBeforeDeletion('delete gear list');\n    if (!backupName) return false;\n    const storageKey = getCurrentProjectStorageKey();\n    if (typeof deleteProject === 'function') {\n        deleteProject(storageKey);\n    } else if (typeof saveProject === 'function') {\n        saveProject(storageKey, { projectInfo: null, gearList: '' });\n    }\n    const setups = getSetups();\n    if (setups && typeof setups === 'object') {\n        const existingSetup = setups[storageKey];\n        if (existingSetup && typeof existingSetup === 'object') {\n            let changed = false;\n            if (Object.prototype.hasOwnProperty.call(existingSetup, 'gearList')) {\n                delete existingSetup.gearList;\n                changed = true;\n            }\n            if (Object.prototype.hasOwnProperty.call(existingSetup, 'projectInfo')) {\n                delete existingSetup.projectInfo;\n                changed = true;\n            }\n            if (Object.prototype.hasOwnProperty.call(existingSetup, 'autoGearRules')) {\n                delete existingSetup.autoGearRules;\n                changed = true;\n            }\n            if (changed) {\n                storeSetups(setups);\n            }\n        }\n    }\n    if (gearListOutput) {\n        gearListOutput.innerHTML = '';\n        gearListOutput.classList.add('hidden');\n    }\n    if (projectRequirementsOutput) {\n        projectRequirementsOutput.innerHTML = '';\n        projectRequirementsOutput.classList.add('hidden');\n    }\n    currentProjectInfo = null;\n    if (projectForm) populateProjectForm({});\n    storeSession({\n        setupName: setupNameInput ? setupNameInput.value : '',\n        setupSelect: setupSelect ? setupSelect.value : '',\n        camera: cameraSelect ? cameraSelect.value : '',\n        monitor: monitorSelect ? monitorSelect.value : '',\n        video: videoSelect ? videoSelect.value : '',\n        cage: cageSelect ? cageSelect.value : '',\n        motors: motorSelects.map(sel => sel ? sel.value : ''),\n        controllers: controllerSelects.map(sel => sel ? sel.value : ''),\n        distance: distanceSelect ? distanceSelect.value : '',\n        batteryPlate: batteryPlateSelect ? batteryPlateSelect.value : '',\n        battery: batterySelect ? batterySelect.value : '',\n        batteryHotswap: hotswapSelect ? hotswapSelect.value : '',\n        sliderBowl: getSliderBowlValue(),\n        easyrig: getEasyrigValue(),\n        projectInfo: null\n    });\n    if (typeof autoSaveCurrentSetup === 'function') {\n        autoSaveCurrentSetup();\n        if (storageKey) {\n            const setupsAfterSave = getSetups();\n            const savedSetup = setupsAfterSave && setupsAfterSave[storageKey];\n            if (savedSetup && typeof savedSetup === 'object') {\n                let resaved = false;\n                if (Object.prototype.hasOwnProperty.call(savedSetup, 'gearList')) {\n                    delete savedSetup.gearList;\n                    resaved = true;\n                }\n                if (Object.prototype.hasOwnProperty.call(savedSetup, 'projectInfo')) {\n                    delete savedSetup.projectInfo;\n                    resaved = true;\n                }\n                if (resaved) {\n                    storeSetups(setupsAfterSave);\n                }\n            }\n        }\n    }\n    currentProjectInfo = null;\n    updateGearListButtonVisibility();\n    if (typeof document !== 'undefined' && typeof document.dispatchEvent === 'function') {\n        const eventDetail = { projectName: storageKey, backupName, source: 'deleteCurrentGearList' };\n        try {\n            document.dispatchEvent(new CustomEvent('gearlist:deleted', { detail: eventDetail }));\n        } catch (error) {\n            if (typeof document.createEvent === 'function') {\n                const fallbackEvent = document.createEvent('CustomEvent');\n                fallbackEvent.initCustomEvent('gearlist:deleted', false, false, eventDetail);\n                document.dispatchEvent(fallbackEvent);\n            } else {\n                console.warn('Unable to dispatch gearlist:deleted event', error);\n            }\n        }\n    }\n    return true;\n}\n\nfunction ensureGearListActions() {\n    if (!gearListOutput) return;\n    let actions = document.getElementById('gearListActions');\n    if (!actions) {\n        actions = document.createElement('div');\n        actions.id = 'gearListActions';\n        gearListOutput.appendChild(actions);\n    }\n    const existingDeleteBtn = actions.querySelector('#deleteGearListBtn');\n    if (existingDeleteBtn) {\n        existingDeleteBtn.removeEventListener('click', deleteCurrentGearList);\n        existingDeleteBtn.remove();\n    }\n    let autoSaveNote = document.getElementById('gearListAutosaveNote');\n    if (!autoSaveNote) {\n        autoSaveNote = document.createElement('p');\n        autoSaveNote.id = 'gearListAutosaveNote';\n        autoSaveNote.className = 'gear-list-autosave-note';\n        actions.appendChild(autoSaveNote);\n    } else if (!actions.contains(autoSaveNote)) {\n        actions.appendChild(autoSaveNote);\n    }\n    const noteText = texts[currentLang].gearListAutosaveNote\n        || 'Gear lists save automatically with the project.';\n    autoSaveNote.textContent = noteText;\n    autoSaveNote.setAttribute('title', noteText);\n    autoSaveNote.setAttribute('data-help', noteText);\n\n    if (!gearListOutput._filterListenerBound) {\n        gearListOutput.addEventListener('change', e => {\n            const target = e.target;\n            if (target && target.matches('select')) {\n                adjustGearListSelectWidth(target);\n            }\n            let shouldSync = false;\n            if (target.matches('.filter-values-container input[type=\"checkbox\"]')) {\n                const container = target.closest('.filter-values-container');\n                const storageId = container && container.getAttribute('data-storage-values');\n                const sel = container && container.querySelector('select');\n                if (target.checked) {\n                    target.setAttribute('checked', '');\n                } else {\n                    target.removeAttribute('checked');\n                }\n                if (storageId) {\n                    syncGearListFilterValue(storageId, target.value, target.checked);\n                } else if (sel) {\n                    const opt = Array.from(sel.options).find(opt => opt.value === target.value);\n                    if (opt) opt.selected = target.checked;\n                    sel.dispatchEvent(new Event('change'));\n                }\n                shouldSync = true;\n            } else if (target.matches('select[data-storage-id]')) {\n                const storageId = target.getAttribute('data-storage-id');\n                if (storageId) {\n                    syncGearListFilterSize(storageId, target.value);\n                }\n                shouldSync = true;\n            } else if (target.id && target.id.startsWith('filter-size-')) {\n                shouldSync = true;\n            } else if (target.id && target.id.startsWith('filter-values-')) {\n                shouldSync = true;\n            } else if (target.matches('input, select, textarea') && !target.closest('#gearListActions')) {\n                shouldSync = true;\n            }\n\n            if (shouldSync) {\n                saveCurrentGearList();\n                saveCurrentSession();\n                checkSetupChanged();\n            }\n        });\n        gearListOutput._filterListenerBound = true;\n    }\n\n    if (!gearListOutput._inputListenerBound) {\n        gearListOutput.addEventListener('input', e => {\n            const target = e.target;\n            if (!target) return;\n            if (target.closest('#gearListActions')) return;\n            if (target.matches('input, textarea')) {\n                saveCurrentGearList();\n                saveCurrentSession();\n                checkSetupChanged();\n            }\n        });\n        gearListOutput._inputListenerBound = true;\n    }\n}\n\nif (typeof document !== 'undefined' && typeof document.addEventListener === 'function') {\n    const handlerKey = '__cameraPowerPlannerGearDeleteHandler';\n    if (!document[handlerKey]) {\n        const handleGearDeleteRequest = () => {\n            try {\n                deleteCurrentGearList();\n            } catch (error) {\n                console.warn('Failed to handle gear list deletion request', error);\n            }\n        };\n        document.addEventListener('gearlist:delete-requested', handleGearDeleteRequest);\n        Object.defineProperty(document, handlerKey, {\n            value: handleGearDeleteRequest,\n            configurable: true,\n            writable: false,\n            enumerable: false,\n        });\n    }\n}\n\nfunction bindGearListCageListener() {\n    if (!gearListOutput) return;\n    const sel = gearListOutput.querySelector('#gearListCage');\n    if (sel) {\n        sel.addEventListener('change', e => {\n            if (cageSelect) {\n                cageSelect.value = e.target.value;\n                cageSelect.dispatchEvent(new Event('change'));\n            }\n            saveCurrentGearList();\n        });\n    }\n}\n\nfunction bindGearListEasyrigListener() {\n    if (!gearListOutput) return;\n    const sel = gearListOutput.querySelector('#gearListEasyrig');\n    if (sel) {\n        sel.addEventListener('change', () => {\n            saveCurrentGearList();\n            saveCurrentSession();\n            checkSetupChanged();\n        });\n    }\n}\n\nfunction bindGearListSliderBowlListener() {\n    if (!gearListOutput) return;\n    const sel = gearListOutput.querySelector('#gearListSliderBowl');\n    if (sel) {\n        sel.addEventListener('change', () => {\n            saveCurrentGearList();\n            saveCurrentSession();\n            checkSetupChanged();\n        });\n    }\n}\n\nfunction bindGearListEyeLeatherListener() {\n    if (!gearListOutput) return;\n    const sel = gearListOutput.querySelector('#gearListEyeLeatherColor');\n    if (sel) {\n        sel.addEventListener('change', () => {\n            saveCurrentGearList();\n        });\n    }\n}\n\nfunction bindGearListProGaffTapeListener() {\n    if (!gearListOutput) return;\n    [1, 2].forEach(i => {\n        const colorSel = gearListOutput.querySelector(`#gearListProGaffColor${i}`);\n        const widthSel = gearListOutput.querySelector(`#gearListProGaffWidth${i}`);\n        [colorSel, widthSel].forEach(sel => {\n            if (sel) {\n                sel.addEventListener('change', () => {\n                    saveCurrentGearList();\n                });\n            }\n        });\n    });\n}\n\nfunction bindGearListDirectorMonitorListener() {\n    if (!gearListOutput) return;\n    ['Director', 'Dop', 'Gaffer', 'Focus'].forEach(role => {\n        const sel = gearListOutput.querySelector(`#gearList${role}Monitor`);\n        if (sel) {\n            sel.addEventListener('change', () => {\n                const monitorInfo = devices && devices.monitors && devices.monitors[sel.value];\n                const span = gearListOutput.querySelector(`#monitorSize${role}`);\n                if (span && monitorInfo && monitorInfo.screenSizeInches) {\n                    span.textContent = `${monitorInfo.screenSizeInches}\"`;\n                }\n                saveCurrentGearList();\n                saveCurrentSession();\n                checkSetupChanged();\n            });\n        }\n    });\n    ['Director', 'Combo', 'Dop'].forEach(role => {\n        const sel = gearListOutput.querySelector(`#gearList${role}Monitor15`);\n        if (sel) {\n            sel.addEventListener('change', () => {\n                const monitorInfo = devices && devices.directorMonitors && devices.directorMonitors[sel.value];\n                const span = gearListOutput.querySelector(`#monitorSize${role}15`);\n                if (span && monitorInfo && monitorInfo.screenSizeInches) {\n                    span.textContent = `${monitorInfo.screenSizeInches}\"`;\n                }\n                saveCurrentGearList();\n                saveCurrentSession();\n                checkSetupChanged();\n            });\n        }\n    });\n}\n\n\nfunction refreshGearListIfVisible() {\n    if (!gearListOutput || gearListOutput.classList.contains('hidden')) return;\n    if (restoringSession) return;\n    if (skipNextGearListRefresh) {\n        skipNextGearListRefresh = false;\n        return;\n    }\n\n    if (projectForm) {\n        populateRecordingResolutionDropdown(currentProjectInfo && currentProjectInfo.recordingResolution);\n        populateSensorModeDropdown(currentProjectInfo && currentProjectInfo.sensorMode);\n        populateCodecDropdown(currentProjectInfo && currentProjectInfo.codec);\n        const info = collectProjectFormData();\n        info.sliderBowl = getSliderBowlValue();\n        info.easyrig = getEasyrigValue();\n        currentProjectInfo = deriveProjectInfo(info);\n    } else {\n        const info = { sliderBowl: getSliderBowlValue(), easyrig: getEasyrigValue() };\n        currentProjectInfo = deriveProjectInfo(info);\n    }\n\n    const html = generateGearListHtml(currentProjectInfo || {});\n    if (currentProjectInfo) {\n        displayGearAndRequirements(html);\n    } else {\n        const { gearHtml } = splitGearListHtml(html);\n        gearListOutput.innerHTML = gearHtml;\n    }\n    ensureGearListActions();\n    bindGearListCageListener();\n    bindGearListEasyrigListener();\n    bindGearListSliderBowlListener();\n    bindGearListEyeLeatherListener();\n    bindGearListProGaffTapeListener();\n    bindGearListDirectorMonitorListener();\n    // Ensure both the gear list HTML and the associated session state are\n    // saved whenever the visible list is refreshed so reloads keep it visible.\n    saveCurrentSession();\n}\n\n\n// --- SESSION STATE HANDLING ---\nfunction saveCurrentSession(options = {}) {\n  if (restoringSession || factoryResetInProgress) return;\n  const info = projectForm ? collectProjectFormData() : {};\n  info.sliderBowl = getSliderBowlValue();\n  info.easyrig = getEasyrigValue();\n  currentProjectInfo = deriveProjectInfo(info);\n  const state = {\n    setupName: setupNameInput ? setupNameInput.value : '',\n    setupSelect: setupSelect ? setupSelect.value : '',\n    camera: cameraSelect ? cameraSelect.value : '',\n    monitor: monitorSelect ? monitorSelect.value : '',\n    video: videoSelect ? videoSelect.value : '',\n    cage: cageSelect ? cageSelect.value : '',\n    motors: motorSelects.map(sel => sel ? sel.value : ''),\n    controllers: controllerSelects.map(sel => sel ? sel.value : ''),\n    distance: distanceSelect ? distanceSelect.value : '',\n    batteryPlate: batteryPlateSelect ? batteryPlateSelect.value : '',\n    battery: batterySelect ? batterySelect.value : '',\n    batteryHotswap: hotswapSelect ? hotswapSelect.value : '',\n    sliderBowl: info.sliderBowl,\n    easyrig: info.easyrig,\n    projectInfo: currentProjectInfo\n  };\n  storeSession(state);\n  // Persist the current gear list and project requirements alongside the\n  // session so they survive reloads without requiring a manual save action.\n  if (!options.skipGearList) {\n    saveCurrentGearList();\n  }\n}\n\nfunction autoSaveCurrentSetup() {\n  if (factoryResetInProgress) return;\n  if (!setupNameInput) return;\n  const name = setupNameInput.value.trim();\n  if (!name) {\n    saveCurrentSession({ skipGearList: true });\n    checkSetupChanged();\n    return;\n  }\n  const selectedName = setupSelect ? setupSelect.value : '';\n  if (setupSelect && (!selectedName || name !== selectedName)) {\n    saveCurrentSession({ skipGearList: true });\n    checkSetupChanged();\n    return;\n  }\n  const currentSetup = { ...getCurrentSetupState() };\n  const gearListHtml = getCurrentGearListHtml();\n  if (gearListHtml) {\n    currentSetup.gearList = gearListHtml;\n  }\n  const setups = getSetups();\n  setups[name] = currentSetup;\n  storeSetups(setups);\n  populateSetupSelect();\n  if (setupSelect) setupSelect.value = name;\n  saveCurrentSession();\n  storeLoadedSetupState(getCurrentSetupState());\n  checkSetupChanged();\n}\n\nlet projectAutoSaveTimer = null;\nlet factoryResetInProgress = false;\n\nfunction runProjectAutoSave() {\n  if (factoryResetInProgress) {\n    projectAutoSaveTimer = null;\n    return;\n  }\n  if (restoringSession) return;\n  projectAutoSaveTimer = null;\n  const hasSetupName = Boolean(setupNameInput && setupNameInput.value.trim());\n  if (!hasSetupName) {\n    saveCurrentSession();\n  }\n  autoSaveCurrentSetup();\n  saveCurrentGearList();\n}\n\nfunction scheduleProjectAutoSave(immediate = false) {\n  if (factoryResetInProgress) {\n    if (projectAutoSaveTimer) {\n      clearTimeout(projectAutoSaveTimer);\n      projectAutoSaveTimer = null;\n    }\n    return;\n  }\n  if (restoringSession) {\n    if (projectAutoSaveTimer) {\n      clearTimeout(projectAutoSaveTimer);\n      projectAutoSaveTimer = null;\n    }\n    return;\n  }\n  if (immediate) {\n    if (projectAutoSaveTimer) {\n      clearTimeout(projectAutoSaveTimer);\n      projectAutoSaveTimer = null;\n    }\n    runProjectAutoSave();\n    return;\n  }\n  if (projectAutoSaveTimer) {\n    clearTimeout(projectAutoSaveTimer);\n  }\n  projectAutoSaveTimer = setTimeout(runProjectAutoSave, 300);\n  if (\n    projectAutoSaveTimer &&\n    typeof projectAutoSaveTimer === 'object' &&\n    typeof projectAutoSaveTimer.unref === 'function'\n  ) {\n    projectAutoSaveTimer.unref();\n  }\n}\n\nif (projectForm) {\n  projectForm.querySelectorAll('select[multiple]').forEach(sel => {\n    sel.addEventListener('mousedown', e => {\n      if (e.target.tagName !== 'OPTION') return;\n      e.preventDefault();\n      const option = e.target;\n      const scrollTop = sel.scrollTop;\n      option.selected = !option.selected;\n      sel.dispatchEvent(new Event('change'));\n      sel.focus();\n      sel.scrollTop = scrollTop;\n    });\n    sel.addEventListener('dblclick', e => {\n      e.preventDefault();\n    });\n  });\n\n  projectForm.querySelectorAll('select').forEach(sel => {\n    if (sel.id === 'requiredScenarios') return;\n    sel.addEventListener('change', () => updateSelectIconBoxes(sel));\n    updateSelectIconBoxes(sel);\n  });\n\n  const queueProjectAutoSave = () => scheduleProjectAutoSave();\n  const flushProjectAutoSave = () => scheduleProjectAutoSave(true);\n  projectForm.addEventListener('input', queueProjectAutoSave);\n  projectForm.addEventListener('change', flushProjectAutoSave);\n\n  projectForm.querySelectorAll('input, textarea, select').forEach(el => {\n    el.addEventListener('change', saveCurrentSession);\n  });\n}\n\nfunction setSelectValue(select, value) {\n  if (!select) return;\n  if (value === undefined) return;\n  const normalized = value === null ? '' : value;\n  select.value = normalized;\n  if (select.value !== normalized) {\n    const options = Array.from(select.options || []);\n    const noneOption = options.find(opt => opt.value === 'None');\n    if (normalized === '' && !options.length) {\n      select.value = '';\n    } else if (normalized === '') {\n      if (noneOption) {\n        select.value = 'None';\n      } else {\n        select.selectedIndex = -1;\n      }\n    } else if (noneOption) {\n      select.value = 'None';\n    } else {\n      select.selectedIndex = -1;\n    }\n  }\n  updateFavoriteButton(select);\n  adjustGearListSelectWidth(select);\n}\n\nfunction resetSelectsToNone(selects) {\n  selects.forEach(select => {\n    if (!select) return;\n    const options = Array.from(select.options || []);\n    const noneOption = options.find(opt => opt.value === 'None');\n    if (noneOption) {\n      select.value = 'None';\n    } else if (!options.length) {\n      select.value = '';\n    } else {\n      select.selectedIndex = -1;\n    }\n  });\n}\n\nfunction restoreSessionState() {\n  restoringSession = true;\n  const state = loadSession();\n  storeLoadedSetupState(state || null);\n  resetSelectsToNone(motorSelects);\n  resetSelectsToNone(controllerSelects);\n  if (state) {\n    if (setupNameInput) {\n      setupNameInput.value = state.setupName || '';\n      setupNameInput.dispatchEvent(new Event('input'));\n    }\n    setSelectValue(cameraSelect, state.camera);\n    updateBatteryPlateVisibility();\n    setSelectValue(batteryPlateSelect, state.batteryPlate);\n    updateBatteryOptions();\n    setSelectValue(monitorSelect, state.monitor);\n    setSelectValue(videoSelect, state.video);\n    setSelectValue(cageSelect, state.cage);\n    setSelectValue(distanceSelect, state.distance);\n    if (Array.isArray(state.motors)) {\n      state.motors.forEach((val, i) => { if (motorSelects[i]) setSelectValue(motorSelects[i], val); });\n    }\n    if (Array.isArray(state.controllers)) {\n      state.controllers.forEach((val, i) => { if (controllerSelects[i]) setSelectValue(controllerSelects[i], val); });\n    }\n    setSelectValue(batterySelect, state.battery);\n    setSelectValue(hotswapSelect, state.batteryHotswap);\n    setSelectValue(setupSelect, state.setupSelect);\n    currentProjectInfo = state.projectInfo || null;\n    if (projectForm) populateProjectForm(currentProjectInfo || {});\n  } else {\n    if (gearListOutput) {\n      gearListOutput.innerHTML = '';\n      gearListOutput.classList.add('hidden');\n    }\n    if (projectRequirementsOutput) {\n      projectRequirementsOutput.innerHTML = '';\n      projectRequirementsOutput.classList.add('hidden');\n    }\n  }\n  if (gearListOutput || projectRequirementsOutput) {\n    const typedName = getCurrentProjectName();\n    const storageKey = getCurrentProjectStorageKey();\n    const fetchStoredProject = name =>\n      typeof loadProject === 'function' && typeof name === 'string'\n        ? loadProject(name)\n        : null;\n    const hasProjectPayload = project =>\n      project && (project.gearList || project.projectInfo);\n    const candidateNames = [];\n    if (typedName) {\n      candidateNames.push(typedName);\n    }\n    if (storageKey || storageKey === '') {\n      if (!candidateNames.includes(storageKey)) {\n        candidateNames.push(storageKey);\n      }\n    }\n    let storedProject = null;\n    for (const name of candidateNames) {\n      storedProject = fetchStoredProject(name);\n      if (hasProjectPayload(storedProject)) {\n        break;\n      }\n    }\n    if (!hasProjectPayload(storedProject) && state) {\n      const fallbackName = typeof state.setupSelect === 'string' ? state.setupSelect.trim() : '';\n      if (fallbackName && !candidateNames.includes(fallbackName)) {\n        const fallbackProject = fetchStoredProject(fallbackName);\n        if (hasProjectPayload(fallbackProject)) {\n          storedProject = fallbackProject;\n        }\n      }\n    }\n    if (hasProjectPayload(storedProject)) {\n      const mergedInfo = {\n        ...(storedProject.projectInfo || {}),\n        ...(currentProjectInfo || {})\n      };\n      currentProjectInfo = mergedInfo;\n      if (projectForm) populateProjectForm(currentProjectInfo);\n      displayGearAndRequirements(storedProject.gearList);\n      if (gearListOutput && storedProject.gearList) {\n        gearListOutput.classList.remove('hidden');\n        skipNextGearListRefresh = true;\n      }\n      if (gearListOutput) {\n        ensureGearListActions();\n        bindGearListCageListener();\n        bindGearListEasyrigListener();\n        bindGearListSliderBowlListener();\n        bindGearListEyeLeatherListener();\n        bindGearListProGaffTapeListener();\n        bindGearListDirectorMonitorListener();\n        if (state) {\n          setSliderBowlValue(state.sliderBowl);\n          setEasyrigValue(state.easyrig);\n        }\n        // Ensure the generator button reflects the restored gear list state\n        updateGearListButtonVisibility();\n      }\n    }\n  }\n  lastSetupName = setupSelect ? setupSelect.value : '';\n  restoringSession = false;\n  saveCurrentSession();\n}\n\nfunction applySharedSetup(shared, options = {}) {\n  try {\n    const decoded = decodeSharedSetup(\n      typeof shared === 'string' ? JSON.parse(shared) : shared\n    );\n    deactivateSharedImportProjectPreset();\n    const sharedRulesFromData = Array.isArray(decoded.autoGearRules) ? decoded.autoGearRules : null;\n    const providedRules = Array.isArray(options.sharedAutoGearRules) && options.sharedAutoGearRules.length\n      ? options.sharedAutoGearRules\n      : sharedRulesFromData;\n    const hasProvidedRules = Array.isArray(providedRules) && providedRules.length > 0;\n    const providedMode = options.autoGearMode;\n    let modes = Array.isArray(providedMode)\n      ? providedMode.slice()\n      : (typeof providedMode === 'string' ? [providedMode] : []);\n    modes = modes.filter((value, index, arr) => (\n      (value === 'none' || value === 'project' || value === 'global')\n      && arr.indexOf(value) === index\n    ));\n    if (!modes.length) {\n      modes = hasProvidedRules ? ['project'] : ['none'];\n    }\n    if (modes.length > 1 && modes.includes('none')) {\n      modes = modes.filter(value => value !== 'none');\n    }\n    if (!modes.length) {\n      modes = hasProvidedRules ? ['project'] : ['none'];\n    }\n    const applyGlobal = modes.includes('global');\n    const applyProject = modes.includes('project');\n    const applyNoneOnly = modes.length === 1 && modes[0] === 'none';\n    let autoGearUpdated = false;\n    if (applyGlobal) {\n      if (hasProvidedRules) {\n        const merged = mergeAutoGearRules(getBaseAutoGearRules(), providedRules);\n        const preset = ensureSharedAutoGearPreset(merged, decoded);\n        if (preset) {\n          setActiveAutoGearPresetId(preset.id, { persist: true, skipRender: true });\n        }\n        setAutoGearRules(merged);\n        autoGearUpdated = true;\n      } else if (usingProjectAutoGearRules()) {\n        clearProjectAutoGearRules();\n        autoGearUpdated = true;\n      }\n    }\n    if (applyProject) {\n      if (hasProvidedRules) {\n        const preset = ensureSharedAutoGearPreset(providedRules, decoded);\n        if (preset) {\n          activateSharedImportProjectPreset(preset.id);\n        }\n        useProjectAutoGearRules(providedRules);\n      } else {\n        clearProjectAutoGearRules();\n        deactivateSharedImportProjectPreset();\n      }\n      autoGearUpdated = true;\n    } else if (!applyGlobal && (applyNoneOnly || !hasProvidedRules)) {\n      if (usingProjectAutoGearRules()) {\n        clearProjectAutoGearRules();\n        deactivateSharedImportProjectPreset();\n        autoGearUpdated = true;\n      }\n    }\n    if (autoGearUpdated) {\n      renderAutoGearRulesList();\n      updateAutoGearCatalogOptions();\n    }\n    if (decoded.changedDevices) {\n      applyDeviceChanges(decoded.changedDevices);\n    }\n    if (setupNameInput && decoded.setupName) {\n      setupNameInput.value = decoded.setupName;\n      setupNameInput.dispatchEvent(new Event('input'));\n    }\n    resetSelectsToNone(motorSelects);\n    resetSelectsToNone(controllerSelects);\n    setSelectValue(cameraSelect, decoded.camera);\n    updateBatteryPlateVisibility();\n    setSelectValue(batteryPlateSelect, decoded.batteryPlate);\n    updateBatteryOptions();\n    setSelectValue(monitorSelect, decoded.monitor);\n    setSelectValue(videoSelect, decoded.video);\n    setSelectValue(cageSelect, decoded.cage);\n    setSelectValue(distanceSelect, decoded.distance);\n    if (Array.isArray(decoded.motors)) {\n      decoded.motors.forEach((val, i) => { if (motorSelects[i]) setSelectValue(motorSelects[i], val); });\n    }\n    if (Array.isArray(decoded.controllers)) {\n      decoded.controllers.forEach((val, i) => { if (controllerSelects[i]) setSelectValue(controllerSelects[i], val); });\n    }\n    setSelectValue(batterySelect, decoded.battery);\n    setSelectValue(hotswapSelect, decoded.batteryHotswap);\n    saveCurrentSession();\n    if (Array.isArray(decoded.feedback) && decoded.feedback.length) {\n      const key = getCurrentSetupKey();\n      const fb = loadFeedbackSafe();\n      fb[key] = (fb[key] || []).concat(decoded.feedback);\n      saveFeedbackSafe(fb);\n    }\n    currentProjectInfo = decoded.projectInfo || null;\n    if (projectForm) populateProjectForm(currentProjectInfo || {});\n    let gearDisplayed = false;\n    const combinedHtml = (decoded.projectHtml || '') + (decoded.gearList || '');\n    if (combinedHtml) {\n      displayGearAndRequirements(combinedHtml);\n      ensureGearListActions();\n      bindGearListCageListener();\n      bindGearListEasyrigListener();\n      bindGearListSliderBowlListener();\n      bindGearListProGaffTapeListener();\n      bindGearListDirectorMonitorListener();\n      gearDisplayed = true;\n    } else if (decoded.projectInfo || decoded.gearSelectors) {\n      const html = generateGearListHtml(decoded.projectInfo || {});\n      displayGearAndRequirements(html);\n      ensureGearListActions();\n      bindGearListCageListener();\n      bindGearListEasyrigListener();\n      bindGearListSliderBowlListener();\n      bindGearListProGaffTapeListener();\n      bindGearListDirectorMonitorListener();\n      gearDisplayed = true;\n    }\n    if (decoded.gearSelectors && gearDisplayed) {\n      applyGearListSelectors(decoded.gearSelectors);\n    }\n    if (decoded.projectInfo || decoded.gearSelectors || decoded.gearList) {\n      const payload = {\n        gearList: getCurrentGearListHtml(),\n        projectInfo: decoded.projectInfo || null\n      };\n      const activeRules = getProjectScopedAutoGearRules();\n      if (activeRules && activeRules.length) {\n        payload.autoGearRules = activeRules;\n      }\n      let storageKey = getCurrentProjectStorageKey({ allowTyped: true });\n      const typedName = setupNameInput && typeof setupNameInput.value === 'string'\n        ? setupNameInput.value.trim()\n        : '';\n      const selectedName = setupSelect && typeof setupSelect.value === 'string'\n        ? setupSelect.value.trim()\n        : '';\n      if (typedName && typedName !== selectedName) {\n        storageKey = typedName;\n      }\n      saveProject(storageKey, payload);\n    }\n  } catch (e) {\n    console.error('Failed to apply shared setup', e);\n    alert(texts[currentLang].invalidSharedLink);\n  }\n}\n\nlet manualQueryParamWarningShown = false;\n\nfunction getQueryParam(search, key) {\n  if (!key) {\n    return null;\n  }\n\n  if (typeof URLSearchParams === 'function') {\n    try {\n      return new URLSearchParams(search).get(key);\n    } catch (error) {\n      if (!manualQueryParamWarningShown && typeof console !== 'undefined' && typeof console.warn === 'function') {\n        console.warn('Falling back to manual query parameter parsing.', error);\n      }\n      manualQueryParamWarningShown = true;\n    }\n  }\n\n  if (typeof search !== 'string' || search.length === 0) {\n    return null;\n  }\n\n  const query = search.charAt(0) === '?' ? search.slice(1) : search;\n  if (!query) {\n    return null;\n  }\n\n  const pairs = query.split('&');\n  for (let i = 0; i < pairs.length; i += 1) {\n    if (!pairs[i]) {\n      continue;\n    }\n\n    const [rawName, rawValue = ''] = pairs[i].split('=');\n    if (!rawName) {\n      continue;\n    }\n\n    let decodedName;\n    try {\n      decodedName = decodeURIComponent(rawName.replace(/\\+/g, ' '));\n    } catch (error) {\n      if (!manualQueryParamWarningShown && typeof console !== 'undefined' && typeof console.warn === 'function') {\n        console.warn('Unable to decode query parameter name', rawName, error);\n      }\n      manualQueryParamWarningShown = true;\n      continue;\n    }\n\n    if (decodedName !== key) {\n      continue;\n    }\n\n    try {\n      return decodeURIComponent(rawValue.replace(/\\+/g, ' '));\n    } catch (error) {\n      if (!manualQueryParamWarningShown && typeof console !== 'undefined' && typeof console.warn === 'function') {\n        console.warn('Unable to decode query parameter value', rawValue, error);\n      }\n      manualQueryParamWarningShown = true;\n      return rawValue;\n    }\n  }\n\n  return null;\n}\n\nfunction applySharedSetupFromUrl() {\n  const hasSearch =\n    typeof window !== 'undefined'\n    && window.location\n    && typeof window.location.search === 'string';\n  const search = hasSearch ? window.location.search : '';\n  const shared = getQueryParam(search, 'shared');\n  if (!shared) return;\n  try {\n    const data = JSON.parse(LZString.decompressFromEncodedURIComponent(shared));\n    applySharedSetup(data);\n    if (typeof updateCalculations === 'function') {\n      updateCalculations();\n    }\n    if (window.history && window.history.replaceState) {\n      history.replaceState(null, '', window.location.pathname);\n    }\n  } catch (e) {\n    console.error('Failed to apply shared setup from URL', e);\n  }\n}\n\n// --- EVENT LISTENERS F\xDCR NEUBERECHNUNG ---\n\n// Sicherstellen, dass \xC4nderungen an den Selects auch neu berechnen\n[cameraSelect, monitorSelect, videoSelect, cageSelect, distanceSelect, batterySelect, hotswapSelect, batteryPlateSelect]\n  .forEach(sel => { if (sel) sel.addEventListener(\"change\", updateCalculations); });\nif (cameraSelect) {\n  cameraSelect.addEventListener('change', () => {\n    updateBatteryPlateVisibility();\n    updateBatteryOptions();\n    populateRecordingResolutionDropdown(currentProjectInfo && currentProjectInfo.recordingResolution);\n    populateSensorModeDropdown(currentProjectInfo && currentProjectInfo.sensorMode);\n  });\n}\nif (monitoringConfigurationSelect) {\n  monitoringConfigurationSelect.addEventListener('change', () => {\n    monitoringConfigurationUserChanged = true;\n    updateViewfinderSettingsVisibility();\n  });\n}\nif (monitorSelect) {\n  monitorSelect.addEventListener('change', updateMonitoringConfigurationOptions);\n}\nif (batteryPlateSelect) batteryPlateSelect.addEventListener('change', updateBatteryOptions);\nif (batterySelect) batterySelect.addEventListener('change', updateBatteryOptions);\nif (hotswapSelect) hotswapSelect.addEventListener('change', updateCalculations);\n\nmotorSelects.forEach(sel => { if (sel) sel.addEventListener(\"change\", updateCalculations); });\ncontrollerSelects.forEach(sel => { if (sel) sel.addEventListener(\"change\", updateCalculations); });\n\n[cameraSelect, monitorSelect, videoSelect, cageSelect, distanceSelect, batterySelect, hotswapSelect, batteryPlateSelect, setupSelect]\n  .forEach(sel => { if (sel) sel.addEventListener(\"change\", saveCurrentSession); });\nmotorSelects.forEach(sel => { if (sel) sel.addEventListener(\"change\", saveCurrentSession); });\ncontrollerSelects.forEach(sel => { if (sel) sel.addEventListener(\"change\", saveCurrentSession); });\nif (setupNameInput) {\n  const handleSetupNameInput = () => {\n    const typedName = setupNameInput.value ? setupNameInput.value.trim() : '';\n    const selectedName = setupSelect ? setupSelect.value : '';\n    const renameInProgress = Boolean(selectedName && typedName && typedName !== selectedName);\n    saveCurrentSession({ skipGearList: renameInProgress });\n  };\n  setupNameInput.addEventListener(\"input\", handleSetupNameInput);\n}\n\n[cameraSelect, monitorSelect, videoSelect, cageSelect, distanceSelect, batterySelect, hotswapSelect, batteryPlateSelect]\n  .forEach(sel => { if (sel) sel.addEventListener(\"change\", saveCurrentGearList); });\nmotorSelects.forEach(sel => { if (sel) sel.addEventListener(\"change\", saveCurrentGearList); });\ncontrollerSelects.forEach(sel => { if (sel) sel.addEventListener(\"change\", saveCurrentGearList); });\n\n[cameraSelect, monitorSelect, videoSelect, cageSelect, distanceSelect, batterySelect, hotswapSelect, batteryPlateSelect]\n  .forEach(sel => { if (sel) sel.addEventListener(\"change\", checkSetupChanged); });\nmotorSelects.forEach(sel => { if (sel) sel.addEventListener(\"change\", checkSetupChanged); });\ncontrollerSelects.forEach(sel => { if (sel) sel.addEventListener(\"change\", checkSetupChanged); });\nif (setupNameInput) setupNameInput.addEventListener(\"input\", checkSetupChanged);\n\n[cameraSelect, monitorSelect, videoSelect, cageSelect, distanceSelect, batterySelect, hotswapSelect, batteryPlateSelect]\n  .forEach(sel => { if (sel) sel.addEventListener(\"change\", autoSaveCurrentSetup); });\nmotorSelects.forEach(sel => { if (sel) sel.addEventListener(\"change\", autoSaveCurrentSetup); });\ncontrollerSelects.forEach(sel => { if (sel) sel.addEventListener(\"change\", autoSaveCurrentSetup); });\nif (setupNameInput) setupNameInput.addEventListener(\"change\", autoSaveCurrentSetup);\n\nconst flushProjectAutoSaveOnExit = () => {\n  if (factoryResetInProgress) return;\n  scheduleProjectAutoSave(true);\n};\nif (typeof document !== 'undefined') {\n  document.addEventListener('visibilitychange', () => {\n    if (document.visibilityState === 'hidden') {\n      flushProjectAutoSaveOnExit();\n    }\n  });\n}\nif (typeof window !== 'undefined') {\n  ['pagehide', 'beforeunload'].forEach((eventName) => {\n    window.addEventListener(eventName, flushProjectAutoSaveOnExit);\n  });\n}\n\n// Enable Save button only when a setup name is entered and allow Enter to save\nif (setupNameInput && saveSetupBtn) {\n  const toggleSaveSetupBtn = () => {\n    saveSetupBtn.disabled = !setupNameInput.value.trim();\n  };\n  toggleSaveSetupBtn();\n  setupNameInput.addEventListener(\"input\", toggleSaveSetupBtn);\n  setupNameInput.addEventListener(\"keydown\", (e) => {\n    if (e.key === \"Enter\" && !saveSetupBtn.disabled) {\n      saveSetupBtn.click();\n    }\n  });\n}\n\n// Dark mode handling\nfunction updateThemeColor(isDark) {\n  const meta = document.querySelector('meta[name=\"theme-color\"]');\n  if (meta) {\n    meta.setAttribute('content', isDark ? '#1c1c1e' : '#ffffff');\n  }\n}\n\nfunction setToggleIcon(button, glyph) {\n  if (!button) return;\n  let iconSpan = button.querySelector('.icon-glyph');\n  if (!iconSpan) {\n    iconSpan = document.createElement('span');\n    iconSpan.className = 'icon-glyph';\n    iconSpan.setAttribute('aria-hidden', 'true');\n    button.textContent = '';\n    button.appendChild(iconSpan);\n  }\n\n  const glyphConfig =\n    glyph && typeof glyph === 'object' && (glyph.markup || glyph.className)\n      ? glyph\n      : { value: glyph };\n\n  const classNames = ['icon-glyph'];\n  if (glyphConfig.className) {\n    classNames.push(glyphConfig.className);\n  }\n  iconSpan.className = classNames.join(' ');\n\n  if (glyphConfig.markup) {\n    iconSpan.innerHTML = ensureSvgHasAriaHidden(glyphConfig.markup);\n    iconSpan.removeAttribute('data-icon-font');\n  } else {\n    applyIconGlyph(iconSpan, glyphConfig.value);\n  }\n}\n\nfunction applyDarkMode(enabled) {\n  if (enabled) {\n    document.body.classList.add(\"dark-mode\");\n    document.documentElement.classList.add(\"dark-mode\");\n    document.body.classList.remove(\"light-mode\");\n    document.documentElement.classList.remove(\"light-mode\");\n    if (darkModeToggle) {\n      setToggleIcon(darkModeToggle, ICON_GLYPHS.sun);\n      darkModeToggle.setAttribute(\"aria-pressed\", \"true\");\n    }\n  } else {\n    document.body.classList.remove(\"dark-mode\");\n    document.documentElement.classList.remove(\"dark-mode\");\n    document.body.classList.add(\"light-mode\");\n    document.documentElement.classList.add(\"light-mode\");\n    if (darkModeToggle) {\n      setToggleIcon(darkModeToggle, ICON_GLYPHS.moon);\n      darkModeToggle.setAttribute(\"aria-pressed\", \"false\");\n    }\n  }\n  const highContrast = isHighContrastActive();\n  const accentSource = highContrast ? HIGH_CONTRAST_ACCENT_COLOR : accentColor;\n  refreshDarkModeAccentBoost({ color: accentSource, highContrast });\n  updateThemeColor(enabled);\n  if (settingsDarkMode) {\n    settingsDarkMode.checked = enabled;\n  }\n}\n\nlet darkModeEnabled = false;\ntry {\n  const stored = localStorage.getItem(\"darkMode\");\n  if (stored !== null) {\n    darkModeEnabled = stored === \"true\";\n  } else if (typeof window.matchMedia === \"function\") {\n    darkModeEnabled = window.matchMedia(\"(prefers-color-scheme: dark)\").matches;\n  }\n} catch (e) {\n  console.warn(\"Could not load dark mode preference\", e);\n}\napplyDarkMode(darkModeEnabled);\n\nif (darkModeToggle) {\n  darkModeToggle.addEventListener(\"click\", () => {\n    darkModeEnabled = !document.body.classList.contains(\"dark-mode\");\n    applyDarkMode(darkModeEnabled);\n    try {\n      localStorage.setItem(\"darkMode\", darkModeEnabled);\n    } catch (e) {\n      console.warn(\"Could not save dark mode preference\", e);\n    }\n  });\n}\n\nfunction applyHighContrast(enabled) {\n  if (enabled) {\n    if (document.body) {\n      document.body.classList.add(\"high-contrast\");\n    }\n    document.documentElement.classList.add(\"high-contrast\");\n    applyAccentColor(accentColor);\n  } else {\n    if (document.body) {\n      document.body.classList.remove(\"high-contrast\");\n    }\n    document.documentElement.classList.remove(\"high-contrast\");\n    if (document.body && document.body.classList.contains('pink-mode') && !hasCustomAccentSelection()) {\n      clearAccentColorOverrides();\n    } else {\n      applyAccentColor(accentColor);\n    }\n  }\n}\n\nlet highContrastEnabled = false;\ntry {\n  highContrastEnabled = localStorage.getItem(\"highContrast\") === \"true\";\n} catch (e) {\n  console.warn(\"Could not load high contrast preference\", e);\n}\napplyHighContrast(highContrastEnabled);\n\n// Pink mode handling\n\nfunction stopPinkModeIconRotation() {\n  if (pinkModeIconRotationTimer) {\n    clearInterval(pinkModeIconRotationTimer);\n    pinkModeIconRotationTimer = null;\n  }\n}\n\nfunction triggerPinkModeIconAnimation() {\n  const targets = [];\n  if (pinkModeToggle) {\n    const toggleIcon = pinkModeToggle.querySelector('.pink-mode-icon');\n    if (toggleIcon) {\n      targets.push(toggleIcon);\n    }\n  }\n  if (pinkModeHelpIcon) {\n    targets.push(pinkModeHelpIcon);\n  }\n  if (!targets.length) {\n    return;\n  }\n  targets.forEach(target => {\n    target.classList.remove(PINK_MODE_ICON_ANIMATION_CLASS);\n    // Force a reflow so the animation restarts even when toggled quickly\n    target.getBoundingClientRect();\n    target.classList.add(PINK_MODE_ICON_ANIMATION_CLASS);\n    if (PINK_MODE_ICON_ANIMATION_RESET_DELAY > 0) {\n      setTimeout(() => {\n        target.classList.remove(PINK_MODE_ICON_ANIMATION_CLASS);\n      }, PINK_MODE_ICON_ANIMATION_RESET_DELAY);\n    }\n  });\n}\n\nfunction applyPinkModeIcon(iconConfig, { animate = false } = {}) {\n  if (!iconConfig) return;\n  if (pinkModeToggle) {\n    setToggleIcon(pinkModeToggle, iconConfig);\n  }\n  if (pinkModeHelpIcon) {\n    pinkModeHelpIcon.className = 'help-icon icon-glyph icon-svg pink-mode-icon';\n    pinkModeHelpIcon.innerHTML = iconConfig.markup || '';\n  }\n  if (animate) {\n    triggerPinkModeIconAnimation();\n  }\n}\n\nfunction startPinkModeIconRotation() {\n  const sequence = Array.isArray(pinkModeIcons.onSequence)\n    ? pinkModeIcons.onSequence\n    : [];\n  if (!sequence.length) {\n    applyPinkModeIcon(pinkModeIcons.off, { animate: false });\n    return;\n  }\n  stopPinkModeIconRotation();\n  if (!pinkModeToggle && !pinkModeHelpIcon) {\n    return;\n  }\n  pinkModeIconIndex = 0;\n  applyPinkModeIcon(sequence[pinkModeIconIndex], { animate: true });\n  pinkModeIconRotationTimer = setInterval(() => {\n    pinkModeIconIndex = (pinkModeIconIndex + 1) % sequence.length;\n    applyPinkModeIcon(sequence[pinkModeIconIndex], { animate: true });\n  }, PINK_MODE_ICON_INTERVAL_MS);\n}\n\nfunction applyPinkMode(enabled) {\n  const preserveAccent = shouldPreserveAccentInPinkMode();\n  if (enabled) {\n    document.body.classList.add(\"pink-mode\");\n    if (accentColorInput) {\n      accentColorInput.disabled = true;\n    }\n    if (preserveAccent) {\n      applyAccentColor(accentColor);\n    } else {\n      clearAccentColorOverrides();\n    }\n    if (pinkModeToggle) {\n      pinkModeToggle.setAttribute(\"aria-pressed\", \"true\");\n    }\n    startPinkModeIconRotation();\n    startPinkModeAnimatedIcons();\n  } else {\n    stopPinkModeAnimatedIcons();\n    document.body.classList.remove(\"pink-mode\");\n    if (accentColorInput) {\n      accentColorInput.disabled = false;\n    }\n    applyAccentColor(accentColor);\n    stopPinkModeIconRotation();\n    applyPinkModeIcon(pinkModeIcons.off, { animate: false });\n    if (pinkModeToggle) {\n      pinkModeToggle.setAttribute(\"aria-pressed\", \"false\");\n    }\n  }\n  if (settingsPinkMode) {\n    settingsPinkMode.checked = enabled;\n  }\n}\n\nfunction isPinkModeActive() {\n  return !!(document.body && document.body.classList.contains('pink-mode'));\n}\n\nlet pinkModeEnabled = false;\n\nlet settingsInitialPinkMode = isPinkModeActive();\n\nfunction persistPinkModePreference(enabled) {\n  pinkModeEnabled = !!enabled;\n  applyPinkMode(pinkModeEnabled);\n  try {\n    localStorage.setItem('pinkMode', pinkModeEnabled);\n  } catch (e) {\n    console.warn('Could not save pink mode preference', e);\n  }\n}\n\nfunction rememberSettingsPinkModeBaseline() {\n  settingsInitialPinkMode = isPinkModeActive();\n}\n\nfunction revertSettingsPinkModeIfNeeded() {\n  if (isPinkModeActive() !== settingsInitialPinkMode) {\n    persistPinkModePreference(settingsInitialPinkMode);\n  }\n}\n\ntry {\n  pinkModeEnabled = localStorage.getItem('pinkMode') === 'true';\n} catch (e) {\n  console.warn('Could not load pink mode preference', e);\n}\napplyPinkMode(pinkModeEnabled);\nrememberSettingsPinkModeBaseline();\n\nif (pinkModeToggle) {\n  pinkModeToggle.addEventListener(\"click\", () => {\n    persistPinkModePreference(!document.body.classList.contains('pink-mode'));\n  });\n}\n\nif (settingsPinkMode) {\n  settingsPinkMode.addEventListener('change', () => {\n    persistPinkModePreference(settingsPinkMode.checked);\n  });\n}\n\nif (settingsButton && settingsDialog) {\n  settingsButton.addEventListener('click', () => {\n    prevAccentColor = accentColor;\n    rememberSettingsPinkModeBaseline();\n    if (settingsLanguage) settingsLanguage.value = currentLang;\n    if (settingsDarkMode) settingsDarkMode.checked = document.body.classList.contains('dark-mode');\n    if (settingsPinkMode) settingsPinkMode.checked = document.body.classList.contains('pink-mode');\n    if (settingsHighContrast) settingsHighContrast.checked = document.body.classList.contains('high-contrast');\n    if (settingsShowAutoBackups) settingsShowAutoBackups.checked = showAutoBackups;\n    if (accentColorInput) {\n      const stored = localStorage.getItem('accentColor');\n      accentColorInput.value = stored || accentColor;\n    }\n    if (settingsTemperatureUnit) settingsTemperatureUnit.value = temperatureUnit;\n    if (settingsFontSize) settingsFontSize.value = fontSize;\n    if (settingsFontFamily) settingsFontFamily.value = fontFamily;\n    if (settingsLogo) settingsLogo.value = '';\n    if (settingsLogoPreview) loadStoredLogoPreview();\n    updateStorageSummary();\n    if (autoGearEditor) {\n      closeAutoGearEditor();\n      refreshAutoGearScenarioOptions();\n      refreshAutoGearMatteboxOptions();\n      refreshAutoGearCameraHandleOptions();\n      refreshAutoGearViewfinderExtensionOptions();\n      refreshAutoGearVideoDistributionOptions();\n      refreshAutoGearCameraOptions();\n      refreshAutoGearMonitorOptions();\n      refreshAutoGearWirelessOptions();\n      refreshAutoGearMotorsOptions();\n      refreshAutoGearControllersOptions();\n      refreshAutoGearDistanceOptions();\n      populateAutoGearCategorySelect(autoGearAddCategorySelect, '');\n      populateAutoGearCategorySelect(autoGearRemoveCategorySelect, '');\n      renderAutoGearRulesList();\n      renderAutoGearDraftLists();\n      updateAutoGearCatalogOptions();\n    }\n    if (activeSettingsTabId) {\n      activateSettingsTab(activeSettingsTabId);\n    }\n    settingsDialog.removeAttribute('hidden');\n    openDialog(settingsDialog);\n    scheduleSettingsTabsOverflowUpdate();\n    // Focus the first control except the language selector to avoid opening it automatically\n    const activePanel = settingsDialog.querySelector('.settings-panel:not([hidden])');\n    const first = activePanel?.querySelector('input:not([type=\"hidden\"]), select:not(#settingsLanguage), textarea');\n    if (first) {\n      try {\n        first.focus({ preventScroll: true });\n      } catch {\n        first.focus();\n      }\n    }\n  });\n\n  if (settingsCancel) {\n    settingsCancel.addEventListener('click', () => {\n      revertSettingsPinkModeIfNeeded();\n      rememberSettingsPinkModeBaseline();\n      revertAccentColor();\n      if (settingsLogo) settingsLogo.value = '';\n      if (settingsLogoPreview) loadStoredLogoPreview();\n      closeAutoGearEditor();\n      closeDialog(settingsDialog);\n      settingsDialog.setAttribute('hidden', '');\n    });\n  }\n\n  if (settingsSave) {\n    settingsSave.addEventListener('click', () => {\n      if (settingsLanguage) {\n        setLanguage(settingsLanguage.value);\n      }\n      if (settingsDarkMode) {\n        const enabled = settingsDarkMode.checked;\n        applyDarkMode(enabled);\n        try {\n          localStorage.setItem('darkMode', enabled);\n        } catch (e) {\n          console.warn('Could not save dark mode preference', e);\n        }\n      }\n      if (settingsPinkMode) {\n        persistPinkModePreference(settingsPinkMode.checked);\n      }\n      if (settingsHighContrast) {\n        const enabled = settingsHighContrast.checked;\n        applyHighContrast(enabled);\n        try {\n          localStorage.setItem('highContrast', enabled);\n        } catch (e) {\n          console.warn('Could not save high contrast preference', e);\n        }\n      }\n      if (settingsShowAutoBackups) {\n        const enabled = settingsShowAutoBackups.checked;\n        const changed = enabled !== showAutoBackups;\n        showAutoBackups = enabled;\n        try {\n          localStorage.setItem('showAutoBackups', enabled);\n        } catch (e) {\n          console.warn('Could not save auto backup visibility preference', e);\n        }\n        if (changed) {\n          const prevValue = setupSelect ? setupSelect.value : '';\n          const prevName = setupNameInput ? setupNameInput.value : '';\n          populateSetupSelect();\n          if (setupSelect) {\n            if (showAutoBackups || !prevValue.startsWith('auto-backup-')) {\n              setupSelect.value = prevValue;\n            } else {\n              setupSelect.value = '';\n            }\n          }\n          if (setupNameInput) {\n            setupNameInput.value = prevName;\n          }\n        }\n      }\n      if (accentColorInput) {\n        const color = accentColorInput.value;\n        applyAccentColor(color);\n        try {\n          localStorage.setItem('accentColor', color);\n        } catch (e) {\n          console.warn('Could not save accent color', e);\n        }\n        accentColor = color;\n        prevAccentColor = color;\n      }\n      if (settingsTemperatureUnit) {\n        applyTemperatureUnitPreference(settingsTemperatureUnit.value);\n      }\n      if (settingsFontSize) {\n        const size = settingsFontSize.value;\n        applyFontSize(size);\n        try {\n          localStorage.setItem('fontSize', size);\n        } catch (e) {\n          console.warn('Could not save font size', e);\n        }\n        fontSize = size;\n      }\n      if (settingsFontFamily) {\n        const family = settingsFontFamily.value;\n        applyFontFamily(family);\n        try {\n          localStorage.setItem('fontFamily', family);\n        } catch (e) {\n          console.warn('Could not save font family', e);\n        }\n        fontFamily = family;\n      }\n      if (settingsLogo && settingsLogo.files && settingsLogo.files[0]) {\n        const file = settingsLogo.files[0];\n        if (file.type === 'image/svg+xml' || file.name.toLowerCase().endsWith('.svg')) {\n          const reader = new FileReader();\n          reader.onload = () => {\n            try {\n              localStorage.setItem('customLogo', reader.result);\n            } catch (e) {\n              console.warn('Could not save custom logo', e);\n            }\n            renderSettingsLogoPreview(reader.result);\n          };\n          reader.readAsDataURL(file);\n        } else {\n          showNotification('error', texts[currentLang].logoFormatError || 'Unsupported logo format');\n          if (settingsLogo) settingsLogo.value = '';\n          loadStoredLogoPreview();\n        }\n      }\n      closeAutoGearEditor();\n      rememberSettingsPinkModeBaseline();\n      closeDialog(settingsDialog);\n      settingsDialog.setAttribute('hidden', '');\n    });\n  }\n\n  settingsDialog.addEventListener('click', e => {\n    if (e.target === settingsDialog) {\n      revertSettingsPinkModeIfNeeded();\n      rememberSettingsPinkModeBaseline();\n      revertAccentColor();\n      if (settingsLogo) settingsLogo.value = '';\n      if (settingsLogoPreview) loadStoredLogoPreview();\n      closeAutoGearEditor();\n      closeDialog(settingsDialog);\n      settingsDialog.setAttribute('hidden', '');\n    }\n  });\n\n  settingsDialog.addEventListener('cancel', e => {\n    e.preventDefault();\n    revertSettingsPinkModeIfNeeded();\n    rememberSettingsPinkModeBaseline();\n    revertAccentColor();\n    if (settingsLogo) settingsLogo.value = '';\n    if (settingsLogoPreview) loadStoredLogoPreview();\n    closeAutoGearEditor();\n    closeDialog(settingsDialog);\n    settingsDialog.setAttribute('hidden', '');\n  });\n\nif (autoGearAddRuleBtn) {\n  autoGearAddRuleBtn.addEventListener('click', () => {\n    openAutoGearEditor();\n  });\n}\nif (autoGearResetFactoryButton) {\n  autoGearResetFactoryButton.addEventListener('click', resetAutoGearRulesToFactoryAdditions);\n}\nif (autoGearExportButton) {\n  autoGearExportButton.addEventListener('click', exportAutoGearRules);\n}\nif (autoGearImportButton && autoGearImportInput) {\n  autoGearImportButton.addEventListener('click', () => {\n    autoGearImportInput.click();\n  });\n  autoGearImportInput.addEventListener('change', handleAutoGearImportSelection);\n}\nif (autoGearPresetSelect) {\n  autoGearPresetSelect.addEventListener('change', handleAutoGearPresetSelection);\n}\nif (autoGearSavePresetButton) {\n  autoGearSavePresetButton.addEventListener('click', handleAutoGearSavePreset);\n}\nif (autoGearDeletePresetButton) {\n  autoGearDeletePresetButton.addEventListener('click', handleAutoGearDeletePreset);\n}\nif (autoGearAddItemButton) {\n  autoGearAddItemButton.addEventListener('click', () => addAutoGearDraftItem('add'));\n}\n  if (autoGearRemoveItemButton) {\n    autoGearRemoveItemButton.addEventListener('click', () => addAutoGearDraftItem('remove'));\n  }\n  if (autoGearSaveRuleButton) {\n    autoGearSaveRuleButton.addEventListener('click', saveAutoGearRuleFromEditor);\n  }\n  if (autoGearCancelEditButton) {\n    autoGearCancelEditButton.addEventListener('click', () => {\n      closeAutoGearEditor();\n      renderAutoGearDraftLists();\n    });\n  }\n  if (autoGearRulesList) {\n    autoGearRulesList.addEventListener('click', event => {\n      const target = event.target;\n      if (!target) return;\n      if (target.classList.contains('auto-gear-edit')) {\n        openAutoGearEditor(target.dataset.ruleId || '');\n      } else if (target.classList.contains('auto-gear-delete')) {\n        deleteAutoGearRule(target.dataset.ruleId || '');\n      }\n    });\n  }\n  if (autoGearBackupSelect) {\n    autoGearBackupSelect.addEventListener('change', () => {\n      updateAutoGearBackupRestoreButtonState();\n    });\n  }\n  if (autoGearShowBackupsCheckbox) {\n    autoGearShowBackupsCheckbox.addEventListener('change', handleAutoGearShowBackupsToggle);\n  }\n  if (autoGearBackupRestoreButton) {\n    autoGearBackupRestoreButton.addEventListener('click', () => {\n      if (!autoGearBackupSelect) return;\n      const backupId = autoGearBackupSelect.value;\n      if (backupId) {\n        restoreAutoGearBackup(backupId);\n      }\n    });\n  }\n  if (autoGearAddCategorySelect) {\n    autoGearAddCategorySelect.addEventListener('change', syncAutoGearMonitorFieldVisibility);\n  }\n  if (autoGearRemoveCategorySelect) {\n    autoGearRemoveCategorySelect.addEventListener('change', syncAutoGearMonitorFieldVisibility);\n  }\n  const bindAutoGearSelectorCatalogSync = (typeSelect, defaultInput) => {\n    if (!typeSelect) return;\n    const refreshCatalog = () => {\n      updateAutoGearMonitorCatalogOptions(typeSelect.value);\n    };\n    typeSelect.addEventListener('change', refreshCatalog);\n    if (defaultInput) {\n      defaultInput.addEventListener('focus', refreshCatalog);\n    }\n  };\n  bindAutoGearSelectorCatalogSync(autoGearAddSelectorTypeSelect, autoGearAddSelectorDefaultInput);\n  bindAutoGearSelectorCatalogSync(autoGearRemoveSelectorTypeSelect, autoGearRemoveSelectorDefaultInput);\n  if (autoGearEditor) {\n    autoGearEditor.addEventListener('click', event => {\n      const target = event.target;\n      if (!target || !target.classList.contains('auto-gear-remove-entry')) return;\n      const listType = target.dataset.listType;\n      const itemId = target.dataset.itemId;\n      if (!autoGearEditorDraft || !itemId) return;\n      const list = listType === 'remove' ? autoGearEditorDraft.remove : autoGearEditorDraft.add;\n      const index = list.findIndex(item => item.id === itemId);\n      if (index >= 0) {\n        list.splice(index, 1);\n        renderAutoGearDraftLists();\n      }\n    });\n  }\n}\n\nsyncAutoGearMonitorFieldVisibility();\n\nconst createAccentTint = (alpha = 0.16) => {\n  const accentFallback = typeof accentColor === 'string'\n    ? accentColor\n    : DEFAULT_ACCENT_COLOR;\n  const accentSource = getCssVariableValue('--accent-color', accentFallback);\n  const rgb = parseColorToRgb(accentSource);\n  if (!rgb) return null;\n  return `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${alpha})`;\n};\n\nfunction showNotification(type, message) {\n  if (typeof document === 'undefined') return;\n  const id = 'backupNotificationContainer';\n  let container = document.getElementById(id);\n  if (!container) {\n    container = document.createElement('div');\n    container.id = id;\n    container.style.position = 'fixed';\n    container.style.top = '1rem';\n    container.style.right = '1rem';\n    container.style.zIndex = '10000';\n    document.body.appendChild(container);\n  }\n  const note = document.createElement('div');\n  note.textContent = message;\n  note.style.padding = '0.75rem 1.25rem';\n  note.style.marginTop = '0.5rem';\n  note.style.borderRadius = '0.75rem';\n  note.style.border = 'none';\n  note.style.boxShadow = '0 0.75rem 2.5rem rgba(0, 0, 0, 0.14)';\n  let background;\n  let textColor;\n  if (type === 'error' || type === 'warning') {\n    const backgroundVar = type === 'error' ? '--status-error-bg' : '--status-warning-bg';\n    const fallbackBackground = type === 'error' ? '#fdd' : '#ffd';\n    background = getCssVariableValue(backgroundVar, fallbackBackground);\n    const textColorVar = type === 'error' ? '--status-error-text-color' : '--status-warning-text-color';\n    textColor = getCssVariableValue(textColorVar, '#000');\n  } else {\n    background = createAccentTint() || getCssVariableValue('--status-success-bg', '#dfd');\n    textColor = getCssVariableValue('--status-success-text-color', '#000');\n  }\n  note.style.background = background;\n  note.style.color = textColor;\n  container.appendChild(note);\n  setTimeout(() => {\n    note.remove();\n    if (!container.children.length) {\n      container.remove();\n    }\n  }, 4000);\n}\n\nfunction formatFullBackupFilename(date) {\n  const safeDate = date instanceof Date && !Number.isNaN(date.valueOf())\n    ? date\n    : new Date();\n  const pad = n => String(n).padStart(2, '0');\n  const year = safeDate.getFullYear();\n  const month = pad(safeDate.getMonth() + 1);\n  const day = pad(safeDate.getDate());\n  const hours = pad(safeDate.getHours());\n  const minutes = pad(safeDate.getMinutes());\n  const seconds = pad(safeDate.getSeconds());\n  const offsetMinutes = safeDate.getTimezoneOffset();\n  let offsetSuffix = 'Z';\n  if (offsetMinutes !== 0) {\n    const sign = offsetMinutes > 0 ? '-' : '+';\n    const abs = Math.abs(offsetMinutes);\n    const offsetHours = pad(Math.floor(abs / 60));\n    const offsetMins = pad(abs % 60);\n    offsetSuffix = `${sign}${offsetHours}:${offsetMins}`;\n  }\n  const iso = `${year}-${month}-${day}T${hours}:${minutes}:${seconds}${offsetSuffix}`;\n  const safeIso = iso.replace(/[:]/g, '-');\n  return {\n    iso,\n    fileName: `${safeIso} full app backup.json`,\n  };\n}\n\nfunction resolveSafeLocalStorage() {\n  if (typeof getSafeLocalStorage === 'function') {\n    try {\n      const storage = getSafeLocalStorage();\n      if (storage) {\n        return storage;\n      }\n    } catch (error) {\n      console.warn('Unable to obtain safe local storage reference', error);\n    }\n  }\n  if (typeof SAFE_LOCAL_STORAGE !== 'undefined') {\n    return SAFE_LOCAL_STORAGE;\n  }\n  if (typeof localStorage !== 'undefined') {\n    return localStorage;\n  }\n  return null;\n}\n\nfunction captureStorageSnapshot(storage) {\n  const snapshot = Object.create(null);\n  if (!storage) return snapshot;\n  try {\n    if (typeof storage.key === 'function' && typeof storage.length === 'number') {\n      const length = storage.length;\n      for (let i = 0; i < length; i++) {\n        const key = storage.key(i);\n        if (typeof key !== 'string') continue;\n        snapshot[key] = storage.getItem(key);\n      }\n    } else if (typeof storage.keys === 'function') {\n      const keys = storage.keys();\n      keys.forEach((key) => {\n        if (typeof key !== 'string') return;\n        snapshot[key] = storage.getItem(key);\n      });\n    } else if (typeof storage.forEach === 'function') {\n      storage.forEach((value, key) => {\n        if (typeof key !== 'string') return;\n        snapshot[key] = value;\n      });\n    }\n  } catch (error) {\n    console.warn('Failed to snapshot storage', error);\n  }\n  return snapshot;\n}\n\nfunction sanitizeBackupPayload(raw) {\n  if (raw === null || raw === undefined) {\n    return '';\n  }\n\n  let text;\n  if (typeof raw === 'string') {\n    text = raw;\n  } else {\n    try {\n      text = String(raw);\n    } catch (error) {\n      console.warn('Failed to stringify backup payload', error);\n      text = '';\n    }\n  }\n\n  if (typeof text !== 'string') {\n    return '';\n  }\n\n  if (text.startsWith('\\uFEFF')) {\n    return text.replace(/^\\uFEFF/, '');\n  }\n\n  return text;\n}\n\nconst BACKUP_STORAGE_KEY_PREFIXES = ['cameraPowerPlanner_'];\nconst BACKUP_STORAGE_KNOWN_KEYS = new Set([\n  'darkMode',\n  'pinkMode',\n  'highContrast',\n  'showAutoBackups',\n  'accentColor',\n  'fontSize',\n  'fontFamily',\n  'customLogo',\n  'language',\n  IOS_PWA_HELP_STORAGE_KEY,\n]);\nconst BACKUP_METADATA_BASE_KEYS = new Set([\n  'settings',\n  'storage',\n  'localStorage',\n  'values',\n  'entries',\n  'sessionStorage',\n  'sessionState',\n  'sessionEntries',\n  'payload',\n  'plannerData',\n  'allData',\n  'generatedAt',\n  'version',\n  'appVersion',\n  'applicationVersion',\n]);\nconst BACKUP_DATA_KEYS = [\n  'devices',\n  'setups',\n  'session',\n  'feedback',\n  'project',\n  'projects',\n  'gearList',\n  'favorites',\n  'autoGearRules',\n  'autoGearSeeded',\n  'autoGearBackups',\n  'autoGearPresets',\n  'autoGearActivePresetId',\n  'autoGearAutoPresetId',\n  'autoGearShowBackups',\n  'customLogo',\n  'customFonts',\n  'preferences',\n];\n\nfunction isPlainObject(value) {\n  return value !== null && typeof value === 'object' && !Array.isArray(value);\n}\n\nfunction normalizeStoredValue(value) {\n  if (typeof value === 'string') return value;\n  if (value === undefined || value === null) return '';\n  if (typeof value === 'object') {\n    try {\n      return JSON.stringify(value);\n    } catch (error) {\n      console.warn('Failed to serialize stored value for backup compatibility', error);\n      return '';\n    }\n  }\n  try {\n    return String(value);\n  } catch (error) {\n    console.warn('Failed to normalize stored value for backup compatibility', error);\n    return '';\n  }\n}\n\nfunction convertEntriesToSnapshot(section) {\n  if (!section) return null;\n  const snapshot = Object.create(null);\n  const assignEntry = (key, value) => {\n    if (typeof key !== 'string' || !key) return;\n    snapshot[key] = normalizeStoredValue(value);\n  };\n\n  if (Array.isArray(section)) {\n    section.forEach(entry => {\n      if (!entry) return;\n      if (Array.isArray(entry)) {\n        assignEntry(entry[0], entry[1]);\n        return;\n      }\n      if (typeof entry === 'object') {\n        if (typeof entry.key === 'string') {\n          assignEntry(entry.key, entry.value ?? entry.val ?? entry.data ?? entry.content ?? entry.string);\n          return;\n        }\n        if (typeof entry.name === 'string') {\n          assignEntry(entry.name, entry.value ?? entry.val ?? entry.data ?? entry.content ?? entry.string);\n          return;\n        }\n        if (Array.isArray(entry.entry)) {\n          assignEntry(entry.entry[0], entry.entry[1]);\n        }\n      }\n    });\n  } else if (isPlainObject(section)) {\n    Object.entries(section).forEach(([key, value]) => {\n      assignEntry(key, value);\n    });\n  } else {\n    return null;\n  }\n\n  return Object.keys(snapshot).length ? snapshot : null;\n}\n\nfunction extractFirstMatchingSnapshot(source, keys) {\n  if (!isPlainObject(source)) return { snapshot: null, keyUsed: null };\n  for (const key of keys) {\n    if (!Object.prototype.hasOwnProperty.call(source, key)) continue;\n    const snapshot = convertEntriesToSnapshot(source[key]);\n    if (snapshot) {\n      return { snapshot, keyUsed: key };\n    }\n  }\n  return { snapshot: null, keyUsed: null };\n}\n\nfunction looksLikeStoredSettingKey(key) {\n  if (BACKUP_STORAGE_KNOWN_KEYS.has(key)) {\n    return true;\n  }\n  return BACKUP_STORAGE_KEY_PREFIXES.some(prefix => key.startsWith(prefix));\n}\n\nfunction buildLegacyStorageFromRoot(source, metadataKeys) {\n  if (!isPlainObject(source)) return null;\n  const snapshot = Object.create(null);\n  Object.entries(source).forEach(([key, value]) => {\n    if (metadataKeys.has(key)) return;\n    if (!looksLikeStoredSettingKey(key)) return;\n    snapshot[key] = normalizeStoredValue(value);\n  });\n  return Object.keys(snapshot).length ? snapshot : null;\n}\n\nfunction extractBackupSections(raw) {\n  const parsed = isPlainObject(raw) ? raw : {};\n  const versionValue =\n    typeof parsed.version === 'string'\n      ? parsed.version\n      : typeof parsed.appVersion === 'string'\n        ? parsed.appVersion\n        : typeof parsed.applicationVersion === 'string'\n          ? parsed.applicationVersion\n          : undefined;\n\n  const settingsResult = extractFirstMatchingSnapshot(parsed, [\n    'settings',\n    'localStorage',\n    'storage',\n    'storedSettings',\n    'values',\n    'entries',\n  ]);\n  const sessionResult = extractFirstMatchingSnapshot(parsed, [\n    'sessionStorage',\n    'session',\n    'sessions',\n    'sessionState',\n    'sessionEntries',\n  ]);\n\n  const metadataKeys = new Set(BACKUP_METADATA_BASE_KEYS);\n  if (settingsResult.keyUsed) metadataKeys.add(settingsResult.keyUsed);\n  if (sessionResult.keyUsed) metadataKeys.add(sessionResult.keyUsed);\n\n  const settingsSnapshot = settingsResult.snapshot || buildLegacyStorageFromRoot(parsed, metadataKeys);\n  const sessionSnapshot = sessionResult.snapshot;\n\n  let dataSection = null;\n  for (const key of ['data', 'payload', 'plannerData', 'allData']) {\n    if (isPlainObject(parsed[key])) {\n      dataSection = parsed[key];\n      break;\n    }\n  }\n  if (!dataSection) {\n    const fallback = {};\n    BACKUP_DATA_KEYS.forEach(key => {\n      if (metadataKeys.has(key)) return;\n      if (Object.prototype.hasOwnProperty.call(parsed, key)) {\n        fallback[key] = parsed[key];\n      }\n    });\n    if (Object.keys(fallback).length) {\n      dataSection = fallback;\n    }\n  }\n\n  return {\n    fileVersion: versionValue,\n    settings: settingsSnapshot,\n    sessionStorage: sessionSnapshot,\n    data: isPlainObject(dataSection) ? dataSection : null,\n  };\n}\n\nfunction triggerBackupDownload(url, fileName) {\n  if (typeof document === 'undefined') {\n    return false;\n  }\n\n  let anchor;\n  try {\n    anchor = document.createElement('a');\n  } catch (error) {\n    console.warn('Failed to create backup download link', error);\n    return false;\n  }\n\n  if (!anchor || typeof anchor.click !== 'function' || !('download' in anchor)) {\n    return false;\n  }\n\n  anchor.href = url;\n  anchor.download = fileName;\n  anchor.rel = 'noopener';\n\n  if (anchor.style) {\n    try {\n      if (typeof anchor.style.setProperty === 'function') {\n        anchor.style.setProperty('display', 'none');\n      } else {\n        anchor.style.display = 'none';\n      }\n    } catch (styleError) {\n      void styleError;\n    }\n  }\n\n  const parent = document.body || document.documentElement || document.head;\n  let appended = false;\n  if (parent && typeof parent.appendChild === 'function') {\n    try {\n      parent.appendChild(anchor);\n      appended = true;\n    } catch (appendError) {\n      void appendError;\n    }\n  }\n\n  try {\n    anchor.click();\n  } catch (clickError) {\n    console.warn('Failed to trigger backup download link', clickError);\n    if (appended && anchor.parentNode && typeof anchor.parentNode.removeChild === 'function') {\n      try {\n        anchor.parentNode.removeChild(anchor);\n      } catch (removeError) {\n        void removeError;\n      }\n    }\n    return false;\n  }\n\n  if (appended && anchor.parentNode && typeof anchor.parentNode.removeChild === 'function') {\n    try {\n      anchor.parentNode.removeChild(anchor);\n    } catch (removeError2) {\n      void removeError2;\n    }\n  }\n\n  return true;\n}\n\nfunction encodeBackupDataUrl(payload) {\n  try {\n    return `data:application/json;charset=utf-8,${encodeURIComponent(payload)}`;\n  } catch (error) {\n    console.warn('Failed to encode backup data URL', error);\n    return null;\n  }\n}\n\nfunction downloadBackupPayload(payload, fileName) {\n  if (typeof payload !== 'string') {\n    return false;\n  }\n\n  let blob = null;\n  if (typeof Blob !== 'undefined') {\n    try {\n      blob = new Blob([payload], { type: 'application/json' });\n    } catch (blobError) {\n      console.warn('Failed to create backup blob', blobError);\n      blob = null;\n    }\n  }\n\n  if (blob) {\n    if (typeof navigator !== 'undefined' && typeof navigator.msSaveOrOpenBlob === 'function') {\n      try {\n        navigator.msSaveOrOpenBlob(blob, fileName);\n        return true;\n      } catch (msError) {\n        console.warn('Saving backup via msSaveOrOpenBlob failed', msError);\n      }\n    }\n\n    if (typeof URL !== 'undefined' && URL && typeof URL.createObjectURL === 'function') {\n      let objectUrl = null;\n      try {\n        objectUrl = URL.createObjectURL(blob);\n      } catch (urlError) {\n        console.warn('Failed to create backup object URL', urlError);\n        objectUrl = null;\n      }\n\n      if (objectUrl) {\n        const triggered = triggerBackupDownload(objectUrl, fileName);\n        try {\n          if (typeof URL.revokeObjectURL === 'function') {\n            URL.revokeObjectURL(objectUrl);\n          }\n        } catch (revokeError) {\n          console.warn('Failed to revoke backup object URL', revokeError);\n        }\n\n        if (triggered) {\n          return true;\n        }\n      }\n    }\n  }\n\n  const dataUrl = encodeBackupDataUrl(payload);\n  if (dataUrl) {\n    return triggerBackupDownload(dataUrl, fileName);\n  }\n\n  return false;\n}\n\nfunction createSettingsBackup(notify = true, timestamp = new Date()) {\n  try {\n    const isEvent = notify && typeof notify === 'object' && typeof notify.type === 'string';\n    const shouldNotify = isEvent ? true : Boolean(notify);\n    const { iso, fileName } = formatFullBackupFilename(timestamp);\n    const safeStorage = resolveSafeLocalStorage();\n    const settings = captureStorageSnapshot(safeStorage);\n    const sessionEntries = captureStorageSnapshot(typeof sessionStorage !== 'undefined' ? sessionStorage : null);\n    const backup = {\n      version: APP_VERSION,\n      generatedAt: iso,\n      settings,\n      sessionStorage: Object.keys(sessionEntries).length ? sessionEntries : undefined,\n      data: typeof exportAllData === 'function' ? exportAllData() : {},\n    };\n    const payload = JSON.stringify(backup);\n    const downloaded = downloadBackupPayload(payload, fileName);\n    if (!downloaded) {\n      throw new Error('No supported download method available');\n    }\n    if (shouldNotify) {\n      showNotification('success', 'Full app backup downloaded');\n    }\n    return fileName;\n  } catch (e) {\n    console.warn('Backup failed', e);\n    if (notify) {\n      showNotification('error', 'Backup failed');\n    }\n    return null;\n  }\n}\n\nif (backupSettings) {\n  backupSettings.addEventListener('click', createSettingsBackup);\n}\n\nif (restoreSettings && restoreSettingsInput) {\n  restoreSettings.addEventListener('click', () => restoreSettingsInput.click());\n  restoreSettingsInput.addEventListener('change', () => {\n    const file = restoreSettingsInput.files[0];\n    if (!file) return;\n\n    const langTexts = texts[currentLang] || {};\n    const fallbackTexts = texts.en || {};\n    const restoreFailureMessage =\n      langTexts.restoreFailed\n      || fallbackTexts.restoreFailed\n      || 'Restore failed. Check the backup file and try again.';\n\n    let backupFileName = null;\n    try {\n      backupFileName = createSettingsBackup(false, new Date());\n    } catch (error) {\n      console.error('Backup before restore failed', error);\n    }\n\n    if (!backupFileName) {\n      const failureMessage = langTexts.restoreBackupFailed\n        || fallbackTexts.restoreBackupFailed\n        || 'Backup failed. Restore cancelled.';\n      showNotification('error', failureMessage);\n      alert(failureMessage);\n      restoreSettingsInput.value = '';\n      return;\n    }\n\n    showNotification('success', 'Full app backup downloaded');\n\n    const finalizeRestore = () => {\n      try {\n        restoreSettingsInput.value = '';\n      } catch (resetError) {\n        void resetError;\n      }\n    };\n\n    const handleRestoreError = (error) => {\n      console.warn('Restore failed', error);\n      showNotification('error', restoreFailureMessage);\n      alert(restoreFailureMessage);\n      finalizeRestore();\n    };\n\n    const processBackupPayload = (rawPayload) => {\n      try {\n        const sanitizedPayload = sanitizeBackupPayload(rawPayload);\n        if (!sanitizedPayload || !sanitizedPayload.trim()) {\n          throw new Error('Backup payload empty');\n        }\n        const parsed = JSON.parse(sanitizedPayload);\n        const {\n          settings: restoredSettings,\n          sessionStorage: restoredSession,\n          data,\n          fileVersion,\n        } = extractBackupSections(parsed);\n\n        const hasSettings = restoredSettings && Object.keys(restoredSettings).length > 0;\n        const hasSessionEntries = restoredSession && Object.keys(restoredSession).length > 0;\n        const hasDataEntries = data && Object.keys(data).length > 0;\n        if (!hasSettings && !hasSessionEntries && !hasDataEntries) {\n          throw new Error('Backup missing recognized sections');\n        }\n        if (fileVersion !== APP_VERSION) {\n          alert(`${texts[currentLang].restoreVersionWarning} (${fileVersion || 'unknown'} \u2192 ${APP_VERSION})`);\n        }\n        if (restoredSettings && typeof restoredSettings === 'object') {\n          const safeStorage = resolveSafeLocalStorage();\n          if (safeStorage && typeof safeStorage.setItem === 'function') {\n            Object.entries(restoredSettings).forEach(([k, v]) => {\n              if (typeof k !== 'string') return;\n              try {\n                if (v === null || v === undefined) {\n                  if (typeof safeStorage.removeItem === 'function') {\n                    safeStorage.removeItem(k);\n                  }\n                } else {\n                  safeStorage.setItem(k, String(v));\n                }\n              } catch (storageError) {\n                console.warn('Failed to restore storage entry', k, storageError);\n              }\n            });\n          }\n        }\n        if (restoredSession && typeof sessionStorage !== 'undefined') {\n          Object.entries(restoredSession).forEach(([key, value]) => {\n            try {\n              sessionStorage.setItem(key, value);\n            } catch (sessionError) {\n              console.warn('Failed to restore sessionStorage entry', key, sessionError);\n            }\n          });\n        }\n        loadStoredLogoPreview();\n        if (data && typeof importAllData === 'function') {\n          importAllData(data);\n        }\n        syncAutoGearRulesFromStorage(data?.autoGearRules);\n        const safeStorage = resolveSafeLocalStorage();\n        const safeGetItem = (key) => {\n          if (!safeStorage || typeof safeStorage.getItem !== 'function') return null;\n          try {\n            return safeStorage.getItem(key);\n          } catch (error) {\n            console.warn('Failed to read restored storage key', key, error);\n            return null;\n          }\n        };\n        const restoredTemperatureUnit = safeGetItem(TEMPERATURE_UNIT_STORAGE_KEY);\n        if (restoredTemperatureUnit) {\n          applyTemperatureUnitPreference(restoredTemperatureUnit, {\n            persist: false,\n          });\n        }\n        applyDarkMode(safeGetItem('darkMode') === 'true');\n        applyPinkMode(safeGetItem('pinkMode') === 'true');\n        applyHighContrast(safeGetItem('highContrast') === 'true');\n        showAutoBackups = safeGetItem('showAutoBackups') === 'true';\n        const prevValue = setupSelect ? setupSelect.value : '';\n        const prevName = setupNameInput ? setupNameInput.value : '';\n        populateSetupSelect();\n        if (setupSelect) {\n          if (showAutoBackups || !prevValue.startsWith('auto-backup-')) {\n            setupSelect.value = prevValue;\n          } else {\n            setupSelect.value = '';\n          }\n        }\n        if (setupNameInput) {\n          setupNameInput.value = prevName;\n        }\n        if (settingsShowAutoBackups) {\n          settingsShowAutoBackups.checked = showAutoBackups;\n        }\n        const color = safeGetItem('accentColor');\n        if (color) {\n          document.documentElement.style.setProperty('--accent-color', color);\n          document.documentElement.style.setProperty('--link-color', color);\n          accentColor = color;\n          prevAccentColor = color;\n        }\n        const lang = safeGetItem('language');\n        if (lang) setLanguage(lang);\n        alert(texts[currentLang].restoreSuccess);\n        finalizeRestore();\n      } catch (err) {\n        handleRestoreError(err);\n      }\n    };\n\n    const attemptTextFallback = (reason) => {\n      if (!file || typeof file.text !== 'function') {\n        return false;\n      }\n      if (reason) {\n        console.warn('FileReader unavailable for restore, using file.text()', reason);\n      } else {\n        console.warn('FileReader unavailable for restore, using file.text()');\n      }\n      Promise.resolve()\n        .then(() => file.text())\n        .then(processBackupPayload)\n        .catch(handleRestoreError);\n      return true;\n    };\n\n    let reader = null;\n    if (typeof FileReader === 'function') {\n      try {\n        reader = new FileReader();\n      } catch (readerError) {\n        console.warn('Failed to create FileReader for restore', readerError);\n        reader = null;\n      }\n    }\n\n    if (reader && typeof reader.readAsText === 'function') {\n      reader.onload = event => {\n        const result = event && event.target ? event.target.result : '';\n        processBackupPayload(result);\n      };\n      reader.onerror = () => {\n        const error = reader.error || new Error('Failed to read backup file');\n        console.warn('FileReader failed while reading restore file', error);\n        if (!attemptTextFallback(error)) {\n          handleRestoreError(error);\n        }\n      };\n      try {\n        reader.readAsText(file);\n        return;\n      } catch (readError) {\n        console.warn('Failed to read restore file', readError);\n        if (!attemptTextFallback(readError)) {\n          handleRestoreError(readError);\n        }\n        return;\n      }\n    }\n\n    if (!attemptTextFallback()) {\n      handleRestoreError(new Error('No supported file reader available'));\n    }\n  });\n}\n\nfunction resetPlannerStateAfterFactoryReset() {\n  try {\n    if (typeof storeLoadedSetupState === 'function') {\n      storeLoadedSetupState(null);\n    }\n  } catch (error) {\n    console.warn('Failed to reset loaded setup state during factory reset', error);\n  }\n\n  try {\n    currentProjectInfo = null;\n  } catch (error) {\n    console.warn('Failed to clear in-memory project info during factory reset', error);\n  }\n\n  try {\n    if (typeof populateProjectForm === 'function') {\n      populateProjectForm({});\n    } else if (projectForm && typeof projectForm.reset === 'function') {\n      projectForm.reset();\n    }\n  } catch (error) {\n    console.warn('Failed to reset project form during factory reset', error);\n  }\n\n  try {\n    displayGearAndRequirements('');\n  } catch (error) {\n    console.warn('Failed to reset gear displays during factory reset', error);\n    if (gearListOutput) {\n      gearListOutput.innerHTML = '';\n      gearListOutput.classList.add('hidden');\n    }\n    if (projectRequirementsOutput) {\n      projectRequirementsOutput.innerHTML = '';\n      projectRequirementsOutput.classList.add('hidden');\n    }\n  }\n\n  const primarySelects = [\n    cameraSelect,\n    monitorSelect,\n    videoSelect,\n    cageSelect,\n    distanceSelect,\n    batterySelect,\n    hotswapSelect,\n    batteryPlateSelect,\n  ];\n  primarySelects.forEach(select => {\n    if (!select) return;\n    try {\n      const options = Array.from(select.options || []);\n      const noneOption = options.find(opt => opt.value === 'None');\n      if (noneOption) {\n        select.value = 'None';\n      } else if (options.length) {\n        select.selectedIndex = 0;\n      } else {\n        select.value = '';\n      }\n    } catch (selectError) {\n      console.warn('Failed to reset selector during factory reset', selectError);\n    }\n  });\n\n  try {\n    resetSelectsToNone(motorSelects);\n  } catch (error) {\n    console.warn('Failed to reset motor selections during factory reset', error);\n  }\n\n  try {\n    resetSelectsToNone(controllerSelects);\n  } catch (error) {\n    console.warn('Failed to reset controller selections during factory reset', error);\n  }\n\n  try {\n    const sliderSelect = getSliderBowlSelect();\n    if (sliderSelect) sliderSelect.value = '';\n  } catch (error) {\n    console.warn('Failed to reset slider bowl selection during factory reset', error);\n  }\n\n  try {\n    const easyrigSelect = getEasyrigSelect();\n    if (easyrigSelect) easyrigSelect.value = '';\n  } catch (error) {\n    console.warn('Failed to reset Easyrig selection during factory reset', error);\n  }\n\n  try {\n    if (setupNameInput) {\n      setupNameInput.value = '';\n    }\n  } catch (error) {\n    console.warn('Failed to clear setup name during factory reset', error);\n  }\n\n  try {\n    if (setupSelect) {\n      populateSetupSelect();\n      setupSelect.value = '';\n    }\n  } catch (error) {\n    console.warn('Failed to reset setup selector options during factory reset', error);\n  }\n\n  try {\n    syncAutoGearRulesFromStorage();\n  } catch (error) {\n    console.warn('Failed to sync automatic gear rules during factory reset', error);\n    try {\n      clearProjectAutoGearRules();\n    } catch (fallbackError) {\n      console.warn('Failed to clear project automatic gear rules during factory reset', fallbackError);\n    }\n  }\n\n  try {\n    renderAutoGearRulesList();\n  } catch (error) {\n    console.warn('Failed to render automatic gear rules during factory reset', error);\n  }\n\n  try {\n    resetSharedImportStateForFactoryReset();\n  } catch (error) {\n    console.warn('Failed to reset shared import state during factory reset', error);\n  }\n\n  try {\n    updateAutoGearCatalogOptions();\n  } catch (error) {\n    console.warn('Failed to refresh automatic gear catalog during factory reset', error);\n  }\n\n  try {\n    updateBatteryPlateVisibility();\n  } catch (error) {\n    console.warn('Failed to reset battery plate visibility during factory reset', error);\n  }\n\n  try {\n    updateBatteryOptions();\n  } catch (error) {\n    console.warn('Failed to reset battery options during factory reset', error);\n  }\n\n  try {\n    if (typeof loadStoredLogoPreview === 'function') {\n      loadStoredLogoPreview();\n    }\n  } catch (error) {\n    console.warn('Failed to reset custom logo preview during factory reset', error);\n  }\n\n  try {\n    resetCustomFontsForFactoryReset();\n  } catch (error) {\n    console.warn('Failed to reset custom fonts during factory reset', error);\n  }\n\n  try {\n    updateStorageSummary();\n  } catch (error) {\n    console.warn('Failed to update storage summary during factory reset', error);\n  }\n\n  try {\n    ensureGearListActions();\n  } catch (error) {\n    console.warn('Failed to ensure gear list actions during factory reset', error);\n  }\n\n  try {\n    checkSetupChanged();\n  } catch (error) {\n    console.warn('Failed to refresh setup state during factory reset', error);\n  }\n\n  try {\n    updateCalculations();\n  } catch (error) {\n    console.warn('Failed to update calculations during factory reset', error);\n  }\n}\n\nif (factoryResetButton) {\n  factoryResetButton.addEventListener('click', () => {\n    const langTexts = texts[currentLang] || texts.en || {};\n    const confirmReset = langTexts.confirmFactoryReset\n      || 'Create a backup and wipe all planner data?';\n    if (!confirm(confirmReset)) return;\n    const confirmResetAgain = langTexts.confirmFactoryResetAgain\n      || 'This will permanently delete all saved planner data. Continue?';\n    if (!confirm(confirmResetAgain)) return;\n\n    if (typeof createSettingsBackup !== 'function') {\n      const errorMsg = langTexts.factoryResetError\n        || 'Factory reset failed. Please try again.';\n      showNotification('error', errorMsg);\n      return;\n    }\n\n    let backupFileName = null;\n    try {\n      backupFileName = createSettingsBackup(false, new Date());\n    } catch (error) {\n      console.error('Backup before factory reset failed', error);\n    }\n\n    if (!backupFileName) {\n      const backupFailedMsg = langTexts.factoryResetBackupFailed\n        || 'Backup failed. Data was not deleted.';\n      showNotification('error', backupFailedMsg);\n      return;\n    }\n\n    if (typeof clearAllData !== 'function') {\n      const errorMsg = langTexts.factoryResetError\n        || 'Factory reset failed. Please try again.';\n      showNotification('error', errorMsg);\n      return;\n    }\n\n    try {\n      factoryResetInProgress = true;\n      if (typeof globalThis !== 'undefined') {\n        try {\n          globalThis.__cameraPowerPlannerFactoryResetting = true;\n        } catch (flagError) {\n          console.warn('Unable to flag factory reset on global scope', flagError);\n        }\n      }\n      if (projectAutoSaveTimer) {\n        clearTimeout(projectAutoSaveTimer);\n        projectAutoSaveTimer = null;\n      }\n      try {\n        stopPinkModeIconRotation();\n        stopPinkModeAnimatedIcons();\n      } catch (animationError) {\n        console.warn('Failed to stop pink mode animations during factory reset', animationError);\n      }\n      clearAllData();\n      try {\n        resetPlannerStateAfterFactoryReset();\n      } catch (resetError) {\n        console.warn('Failed to reset planner state after factory reset', resetError);\n      }\n      try {\n        darkModeEnabled = false;\n        applyDarkMode(false);\n      } catch (darkError) {\n        console.warn('Failed to reset dark mode during factory reset', darkError);\n      }\n      try {\n        highContrastEnabled = false;\n        applyHighContrast(false);\n        if (settingsHighContrast) {\n          settingsHighContrast.checked = false;\n        }\n      } catch (contrastError) {\n        console.warn('Failed to reset high contrast during factory reset', contrastError);\n      }\n      try {\n        pinkModeEnabled = false;\n        applyPinkMode(false);\n        rememberSettingsPinkModeBaseline();\n      } catch (pinkError) {\n        console.warn('Failed to reset pink mode during factory reset', pinkError);\n      }\n      showAutoBackups = false;\n      if (settingsShowAutoBackups) {\n        settingsShowAutoBackups.checked = false;\n      }\n      try {\n        accentColor = DEFAULT_ACCENT_COLOR;\n        prevAccentColor = DEFAULT_ACCENT_COLOR;\n        clearAccentColorOverrides();\n        applyAccentColor(accentColor);\n        if (accentColorInput) {\n          accentColorInput.value = DEFAULT_ACCENT_COLOR;\n        }\n      } catch (accentError) {\n        console.warn('Failed to reset accent color during factory reset', accentError);\n      }\n      try {\n        fontSize = '16';\n        applyFontSize(fontSize);\n        if (settingsFontSize) {\n          settingsFontSize.value = fontSize;\n        }\n      } catch (fontSizeError) {\n        console.warn('Failed to reset font size during factory reset', fontSizeError);\n      }\n      try {\n        fontFamily = \"'Ubuntu', sans-serif\";\n        applyFontFamily(fontFamily);\n        if (settingsFontFamily) {\n          settingsFontFamily.value = fontFamily;\n        }\n      } catch (fontFamilyError) {\n        console.warn('Failed to reset font family during factory reset', fontFamilyError);\n      }\n      if (settingsDialog) {\n        settingsDialog.setAttribute('hidden', '');\n      }\n      const successMsg = langTexts.factoryResetSuccess\n        || 'Backup downloaded. All planner data cleared. Reloading\u2026';\n      showNotification('success', successMsg);\n      setTimeout(() => {\n        if (typeof window !== 'undefined' && window.location && window.location.reload) {\n          window.location.reload();\n        }\n      }, 600);\n    } catch (error) {\n      console.error('Factory reset failed', error);\n      factoryResetInProgress = false;\n      if (typeof globalThis !== 'undefined') {\n        try {\n          delete globalThis.__cameraPowerPlannerFactoryResetting;\n        } catch (cleanupError) {\n          console.warn('Unable to clear factory reset flag from global scope', cleanupError);\n        }\n      }\n      const errorMsg = langTexts.factoryResetError\n        || 'Factory reset failed. Please try again.';\n      showNotification('error', errorMsg);\n    }\n  });\n}\n\nasync function clearCachesAndReload() {\n  try {\n    if (typeof navigator !== 'undefined' && navigator.serviceWorker) {\n      const registrations = [];\n      const { serviceWorker } = navigator;\n      try {\n        if (typeof serviceWorker.getRegistrations === 'function') {\n          const regs = await serviceWorker.getRegistrations();\n          if (Array.isArray(regs)) {\n            regs.forEach(reg => registrations.push(reg));\n          }\n        } else if (typeof serviceWorker.getRegistration === 'function') {\n          const reg = await serviceWorker.getRegistration();\n          if (reg) {\n            registrations.push(reg);\n          }\n        } else if (serviceWorker.ready && typeof serviceWorker.ready.then === 'function') {\n          try {\n            const readyReg = await serviceWorker.ready;\n            if (readyReg) {\n              registrations.push(readyReg);\n            }\n          } catch (readyError) {\n            console.warn('Failed to await active service worker', readyError);\n          }\n        }\n      } catch (queryError) {\n        console.warn('Failed to query service worker registrations', queryError);\n      }\n\n      if (registrations.length) {\n        await Promise.all(registrations.map(reg => {\n          if (!reg || typeof reg.unregister !== 'function') {\n            return Promise.resolve();\n          }\n          return reg.unregister().catch(unregisterError => {\n            console.warn('Service worker unregister failed', unregisterError);\n          });\n        }));\n      }\n    }\n\n    if (typeof caches !== 'undefined' && caches && typeof caches.keys === 'function') {\n      const keys = await caches.keys();\n      await Promise.all(keys.map(key => {\n        if (!key || typeof caches.delete !== 'function') {\n          return Promise.resolve(false);\n        }\n        return caches.delete(key).catch(cacheError => {\n          console.warn('Failed to delete cache', key, cacheError);\n          return false;\n        });\n      }));\n    }\n  } catch (error) {\n    console.warn('Cache clear failed', error);\n  } finally {\n    try {\n      if (typeof window !== 'undefined' && window.location) {\n        const { location } = window;\n        const hasReplace = location && typeof location.replace === 'function';\n        const hasReload = location && typeof location.reload === 'function';\n        let navigationTriggered = false;\n        if (hasReplace) {\n          const paramName = 'forceReload';\n          const timestamp = Date.now().toString(36);\n          let href = location.href || '';\n          let hash = '';\n          const hashIndex = href.indexOf('#');\n          if (hashIndex !== -1) {\n            hash = href.slice(hashIndex);\n            href = href.slice(0, hashIndex);\n          }\n          const pattern = new RegExp('([?&])' + paramName + '=[^&]*');\n          const replacement = '$1' + paramName + '=' + timestamp;\n          if (pattern.test(href)) {\n            href = href.replace(pattern, replacement);\n          } else if (href.indexOf('?') !== -1) {\n            href += '&' + paramName + '=' + timestamp;\n          } else if (href) {\n            href += '?' + paramName + '=' + timestamp;\n          }\n          location.replace(href + hash);\n          navigationTriggered = true;\n        }\n        if (!navigationTriggered && hasReload) {\n          location.reload();\n        }\n      }\n    } catch (reloadError) {\n      console.warn('Forced reload failed', reloadError);\n      if (typeof window !== 'undefined' && window.location && typeof window.location.reload === 'function') {\n        window.location.reload();\n      }\n    }\n  }\n}\n\nif (reloadButton) {\n  reloadButton.addEventListener(\"click\", clearCachesAndReload);\n}\n\nfunction exportDiagramSvg() {\n  if (!setupDiagramContainer) return '';\n  const svgEl = setupDiagramContainer.querySelector('svg');\n  if (!svgEl) return '';\n\n  const clone = svgEl.cloneNode(true);\n  const labels = svgEl.querySelectorAll('.edge-label');\n  const cloneLabels = clone.querySelectorAll('.edge-label');\n  labels.forEach((lbl, idx) => {\n    if (cloneLabels[idx]) {\n      // innerHTML isn't consistently supported for SVG <text> elements in all browsers,\n      // which could result in empty connection labels in the exported SVG. Using\n      // textContent ensures the label text is preserved across environments.\n      cloneLabels[idx].textContent = lbl.textContent;\n    }\n  });\n  const style = document.createElementNS('http://www.w3.org/2000/svg', 'style');\n  // Always export using the bright theme regardless of the current mode\n  style.textContent = getDiagramCss(false);\n  clone.insertBefore(style, clone.firstChild);\n  const serializer = new XMLSerializer();\n  return serializer.serializeToString(clone);\n}\n\nfunction copyTextToClipboardBestEffort(text) {\n  if (typeof text !== 'string' || !text) {\n    return;\n  }\n\n  if (\n    typeof navigator !== 'undefined' &&\n    navigator &&\n    navigator.clipboard &&\n    typeof navigator.clipboard.writeText === 'function'\n  ) {\n    navigator.clipboard.writeText(text).catch(() => {});\n    return;\n  }\n\n  if (\n    typeof document === 'undefined' ||\n    !document ||\n    !document.body ||\n    typeof document.createElement !== 'function'\n  ) {\n    return;\n  }\n\n  let textarea = null;\n  const previousActiveElement = document.activeElement;\n\n  try {\n    textarea = document.createElement('textarea');\n    textarea.value = text;\n    textarea.setAttribute('readonly', '');\n    textarea.style.position = 'fixed';\n    textarea.style.top = '-9999px';\n    textarea.style.opacity = '0';\n    document.body.appendChild(textarea);\n\n    try {\n      textarea.focus();\n    } catch {\n      // Ignore focus errors on platforms that disallow programmatic focus.\n    }\n\n    try {\n      textarea.select();\n      if (typeof textarea.setSelectionRange === 'function') {\n        textarea.setSelectionRange(0, textarea.value.length);\n      }\n    } catch {\n      // Ignore selection errors; execCommand may still succeed.\n    }\n\n    if (typeof document.execCommand === 'function') {\n      try {\n        document.execCommand('copy');\n      } catch {\n        // Ignore execCommand failures to avoid breaking the export flow.\n      }\n    }\n  } catch {\n    // Ignore clipboard fallback errors.\n  } finally {\n    if (textarea && textarea.parentNode) {\n      textarea.parentNode.removeChild(textarea);\n    }\n\n    if (\n      previousActiveElement &&\n      typeof previousActiveElement.focus === 'function'\n    ) {\n      try {\n        previousActiveElement.focus();\n      } catch {\n        // Ignore focus restoration errors.\n      }\n    }\n  }\n}\n\nif (downloadDiagramBtn) {\n  downloadDiagramBtn.addEventListener('click', (e) => {\n    const source = exportDiagramSvg();\n    if (!source) return;\n\n    copyTextToClipboardBestEffort(source);\n    const pad = n => String(n).padStart(2, '0');\n    const now = new Date();\n    const datePart = `${now.getFullYear()}-${pad(now.getMonth() + 1)}-${pad(now.getDate())}_${pad(now.getHours())}-${pad(now.getMinutes())}`;\n    const namePart = (getCurrentProjectName() || 'setup')\n        .replace(/\\s+/g, '-').replace(/[^a-z0-9-_]/gi, '');\n    const baseName = `${datePart}_${namePart}_diagram`;\n\n    const saveSvg = () => {\n      const blob = new Blob([source], { type: 'image/svg+xml;charset=utf-8' });\n      const url = URL.createObjectURL(blob);\n      const a = document.createElement('a');\n      a.href = url;\n      a.download = `${baseName}.svg`;\n      a.click();\n      URL.revokeObjectURL(url);\n    };\n\n    if (e.shiftKey) {\n      const img = new Image();\n      img.onload = () => {\n        const canvas = document.createElement('canvas');\n        canvas.width = img.width;\n        canvas.height = img.height;\n        const ctx = canvas.getContext('2d');\n        ctx.drawImage(img, 0, 0);\n        canvas.toBlob(blob => {\n          const url = URL.createObjectURL(blob);\n          const a = document.createElement('a');\n          a.href = url;\n          a.download = `${baseName}.jpg`;\n          a.click();\n          URL.revokeObjectURL(url);\n        }, 'image/jpeg', 0.95);\n      };\n      img.src = 'data:image/svg+xml;charset=utf-8,' + encodeURIComponent(source);\n    } else {\n      saveSvg();\n    }\n  });\n}\n\nif (gridSnapToggleBtn) {\n  gridSnapToggleBtn.addEventListener('click', () => {\n    gridSnap = !gridSnap;\n    gridSnapToggleBtn.classList.toggle('active', gridSnap);\n    gridSnapToggleBtn.setAttribute('aria-pressed', gridSnap ? 'true' : 'false');\n    if (setupDiagramContainer) {\n      setupDiagramContainer.classList.toggle('grid-snap', gridSnap);\n    }\n  });\n}\n\nif (helpButton && helpDialog) {\n  // --- Help dialog and hover help -----------------------------------------\n  // Provides a modal help dialog with live filtering and a \"hover for help\"\n  // mode that exposes descriptions for interface controls. The following\n  // functions manage searching, opening/closing the dialog and tooltip-based\n  // hover help.\n  const helpContent = helpDialog.querySelector('.help-content');\n  const helpQuickLinkItems = new Map();\n  const helpSectionHighlightTimers = new Map();\n  const appTargetHighlightTimers = new Map();\n  const featureSearchHighlightTimers = new Map();\n\n  const highlightAppTarget = element => {\n    if (!element) return;\n    const target = element;\n    const existing = appTargetHighlightTimers.get(target);\n    if (existing) {\n      clearTimeout(existing);\n    }\n    target.classList.add('help-target-focus');\n    const timeout = setTimeout(() => {\n      target.classList.remove('help-target-focus');\n      appTargetHighlightTimers.delete(target);\n    }, 2000);\n    appTargetHighlightTimers.set(target, timeout);\n  };\n\n  const highlightFeatureSearchTargets = targets => {\n    if (!Array.isArray(targets) || targets.length === 0) return;\n    const seen = new Set();\n    targets.forEach(target => {\n      if (!target || typeof target.classList?.add !== 'function') return;\n      if (seen.has(target)) return;\n      seen.add(target);\n      const existing = featureSearchHighlightTimers.get(target);\n      if (existing) {\n        clearTimeout(existing);\n      }\n      target.classList.add('feature-search-focus');\n      const timeout = setTimeout(() => {\n        target.classList.remove('feature-search-focus');\n        featureSearchHighlightTimers.delete(target);\n      }, 2500);\n      featureSearchHighlightTimers.set(target, timeout);\n    });\n  };\n\n  const findAssociatedLabelElements = element => {\n    if (!element) return [];\n    const labels = new Set();\n    const doc = element.ownerDocument || (typeof document !== 'undefined' ? document : null);\n    if (element.labels && typeof element.labels === 'object') {\n      Array.from(element.labels).forEach(label => {\n        if (label) labels.add(label);\n      });\n    }\n    if (typeof element.closest === 'function') {\n      const wrappingLabel = element.closest('label');\n      if (wrappingLabel) labels.add(wrappingLabel);\n    }\n    if (doc && typeof element.getAttribute === 'function') {\n      const collectIdRefs = attrValue => {\n        if (!attrValue) return;\n        attrValue\n          .split(/\\s+/)\n          .filter(Boolean)\n          .forEach(id => {\n            const ref = doc.getElementById(id);\n            if (ref) labels.add(ref);\n          });\n      };\n      collectIdRefs(element.getAttribute('aria-labelledby'));\n      collectIdRefs(element.getAttribute('aria-describedby'));\n    }\n    return Array.from(labels);\n  };\n\n  const focusFeatureElement = element => {\n    if (!element) return;\n\n    const settingsSection = element.closest('#settingsDialog');\n    const settingsPanel = element.closest('.settings-panel');\n    if (settingsPanel) {\n      const labelledBy = settingsPanel.getAttribute('aria-labelledby') || '';\n      const tabIds = labelledBy\n        .split(/\\s+/)\n        .map(id => id.trim())\n        .filter(Boolean);\n      const matchingTabId = tabIds.find(id => document.getElementById(id));\n      if (matchingTabId) {\n        activateSettingsTab(matchingTabId);\n      }\n    }\n    if (settingsSection && !isDialogOpen(settingsDialog)) {\n      settingsButton?.click?.();\n    }\n\n    const dialog = element.closest('dialog');\n    if (dialog && !isDialogOpen(dialog)) {\n      if (dialog.id === 'projectDialog') {\n        generateGearListBtn?.click?.();\n      } else if (dialog.id === 'feedbackDialog') {\n        runtimeFeedbackBtn?.click?.();\n      } else if (dialog.id === 'overviewDialog') {\n        generateOverviewBtn?.click?.();\n      } else {\n        openDialog(dialog);\n      }\n    }\n\n    const deviceManager = element.closest('#device-manager');\n    if (deviceManager) {\n      showDeviceManagerSection();\n    }\n\n    if (typeof element.scrollIntoView === 'function') {\n      element.scrollIntoView({ behavior: 'smooth', block: 'center' });\n    }\n\n    const hadTabIndex = element.hasAttribute('tabindex');\n    let addedTabIndex = false;\n    if (!hadTabIndex) {\n      const tabIndex = element.tabIndex;\n      if (typeof tabIndex === 'number' && tabIndex < 0) {\n        element.setAttribute('tabindex', '-1');\n        addedTabIndex = true;\n      }\n    }\n\n    if (typeof element.focus === 'function') {\n      try {\n        element.focus({ preventScroll: true });\n      } catch {\n        element.focus();\n      }\n    }\n\n    if (addedTabIndex) {\n      element.addEventListener(\n        'blur',\n        () => element.removeAttribute('tabindex'),\n        { once: true }\n      );\n    }\n  };\n\n  const focusHelpSectionHeading = section => {\n    if (!section) return;\n    const heading =\n      section.querySelector('h3, summary, h4, h5, h6') ||\n      section.querySelector('button, a');\n    if (!heading) return;\n    const hadTabIndex = heading.hasAttribute('tabindex');\n    if (!hadTabIndex) heading.setAttribute('tabindex', '-1');\n    try {\n      heading.focus({ preventScroll: true });\n    } catch {\n      heading.focus();\n    }\n    if (!hadTabIndex) {\n      heading.addEventListener(\n        'blur',\n        () => heading.removeAttribute('tabindex'),\n        { once: true }\n      );\n    }\n  };\n\n  const highlightHelpSection = section => {\n    if (!section) return;\n    const existingTimer = helpSectionHighlightTimers.get(section);\n    if (existingTimer) {\n      clearTimeout(existingTimer);\n    }\n    section.classList.add('help-section-focus');\n    const timer = setTimeout(() => {\n      section.classList.remove('help-section-focus');\n      helpSectionHighlightTimers.delete(section);\n    }, 1500);\n    helpSectionHighlightTimers.set(section, timer);\n  };\n\n  const syncHelpQuickLinksVisibility = () => {\n    if (!helpQuickLinksNav || !helpQuickLinksList || !helpQuickLinkItems.size) {\n      if (helpQuickLinksNav) helpQuickLinksNav.setAttribute('hidden', '');\n      return;\n    }\n    let hasVisible = false;\n    helpQuickLinkItems.forEach(({ section, listItem, button }) => {\n      if (section && !section.hasAttribute('hidden')) {\n        listItem.removeAttribute('hidden');\n        hasVisible = true;\n      } else {\n        listItem.setAttribute('hidden', '');\n        if (button) button.classList.remove('active');\n      }\n    });\n    if (hasVisible) {\n      helpQuickLinksNav.removeAttribute('hidden');\n    } else {\n      helpQuickLinksNav.setAttribute('hidden', '');\n    }\n  };\n\n  const applyQuickLinkLanguage = lang => {\n    if (!helpQuickLinksNav) return;\n    const langTexts = (texts && texts[lang]) || {};\n    const fallbackTexts = (texts && texts.en) || {};\n    const headingText =\n      langTexts.helpQuickLinksHeading || fallbackTexts.helpQuickLinksHeading;\n    if (helpQuickLinksHeading && headingText) {\n      helpQuickLinksHeading.textContent = headingText;\n    }\n    const ariaLabel =\n      langTexts.helpQuickLinksAriaLabel ||\n      headingText ||\n      fallbackTexts.helpQuickLinksAriaLabel ||\n      'Help topics quick navigation';\n    helpQuickLinksNav.setAttribute('aria-label', ariaLabel);\n    const helpDescription =\n      langTexts.helpQuickLinksHelp || fallbackTexts.helpQuickLinksHelp;\n    if (helpDescription) {\n      helpQuickLinksNav.setAttribute('data-help', helpDescription);\n    } else {\n      helpQuickLinksNav.removeAttribute('data-help');\n    }\n    const template =\n      langTexts.helpQuickLinkButtonHelp || fallbackTexts.helpQuickLinkButtonHelp;\n    helpQuickLinkItems.forEach(({ button, label }) => {\n      if (!button) return;\n      if (template) {\n        const helpText = template.replace('%s', label);\n        button.setAttribute('data-help', helpText);\n        button.setAttribute('aria-label', helpText);\n      } else {\n        button.removeAttribute('data-help');\n        button.setAttribute('aria-label', label);\n      }\n    });\n  };\n\n  updateHelpQuickLinksForLanguage = applyQuickLinkLanguage;\n\n  const buildHelpQuickLinks = () => {\n    if (!helpQuickLinksNav || !helpQuickLinksList || !helpSectionsContainer) {\n      helpQuickLinkItems.clear();\n      if (helpQuickLinksNav) helpQuickLinksNav.setAttribute('hidden', '');\n      return;\n    }\n    helpQuickLinkItems.clear();\n    helpQuickLinksList.textContent = '';\n    const fragment = document.createDocumentFragment();\n    const sections = Array.from(\n      helpSectionsContainer.querySelectorAll('section[data-help-section]')\n    );\n    sections.forEach(section => {\n      const id = section.id;\n      if (!id) return;\n      const heading = section.querySelector('h3');\n      if (!heading) return;\n      const headingIcon = heading.querySelector('.help-icon.icon-glyph');\n      let label = heading.textContent || '';\n      if (headingIcon) {\n        const iconText = headingIcon.textContent || '';\n        if (iconText) {\n          const iconIndex = label.indexOf(iconText);\n          if (iconIndex > -1) {\n            label =\n              label.slice(0, iconIndex) +\n              label.slice(iconIndex + iconText.length);\n          }\n        }\n      }\n      label = label.trim();\n      if (!label) return;\n      const li = document.createElement('li');\n      const button = document.createElement('button');\n      button.type = 'button';\n      button.className = 'help-quick-link';\n      button.dataset.targetId = id;\n      button.setAttribute('aria-label', label);\n\n      if (headingIcon) {\n        const icon = headingIcon.cloneNode(true);\n        icon.classList.remove('help-icon');\n        icon.classList.add('help-quick-link-icon');\n        button.appendChild(icon);\n      }\n\n      const labelSpan = document.createElement('span');\n      labelSpan.className = 'help-quick-link-label';\n      labelSpan.textContent = label;\n      button.appendChild(labelSpan);\n      button.addEventListener('click', () => {\n        if (section.hasAttribute('hidden')) return;\n        if (helpQuickLinksList) {\n          helpQuickLinksList\n            .querySelectorAll('.help-quick-link.active')\n            .forEach(btn => btn.classList.remove('active'));\n        }\n        button.classList.add('active');\n        if (typeof section.scrollIntoView === 'function') {\n          section.scrollIntoView({ behavior: 'smooth', block: 'start' });\n        }\n        highlightHelpSection(section);\n        focusHelpSectionHeading(section);\n        const quickLinkHeading =\n          section.querySelector('h3, summary, h4, h5, h6, [role=\"heading\"]') ||\n          section.querySelector('button, a');\n        if (quickLinkHeading) {\n          highlightFeatureSearchTargets([quickLinkHeading]);\n        } else {\n          highlightFeatureSearchTargets([section]);\n        }\n      });\n      li.appendChild(button);\n      fragment.appendChild(li);\n      helpQuickLinkItems.set(id, { section, button, listItem: li, label });\n    });\n    if (!fragment.childNodes.length) {\n      helpQuickLinksNav.setAttribute('hidden', '');\n      return;\n    }\n    helpQuickLinksList.appendChild(fragment);\n    applyQuickLinkLanguage(currentLang);\n    syncHelpQuickLinksVisibility();\n  };\n\n  buildHelpQuickLinks();\n\n  if (helpDialog) {\n    helpDialog.addEventListener('click', e => {\n      const link = e.target.closest('a[data-help-target]');\n      if (!link) return;\n      const rawSelector = link.dataset.helpTarget || link.getAttribute('href') || '';\n      const selector = rawSelector.trim();\n      if (!selector) return;\n      let focusEl;\n      try {\n        focusEl = document.querySelector(selector);\n      } catch {\n        focusEl = null;\n      }\n      if (!focusEl) return;\n      e.preventDefault();\n      const highlightSelector = link.dataset.helpHighlight || '';\n      let highlightEl = focusEl;\n      if (highlightSelector) {\n        try {\n          const candidate = document.querySelector(highlightSelector);\n          if (candidate) {\n            highlightEl = candidate;\n          }\n        } catch {\n          // ignore selector errors and fall back to the focus element\n        }\n      }\n      const targetInsideHelp = helpDialog.contains(focusEl);\n      const runFocus = () => {\n        focusFeatureElement(focusEl);\n        if (highlightEl) {\n          highlightAppTarget(highlightEl);\n        }\n        const extraTargets = findAssociatedLabelElements(highlightEl || focusEl);\n        if (extraTargets.length) {\n          highlightFeatureSearchTargets(extraTargets);\n        }\n      };\n      if (targetInsideHelp) {\n        runFocus();\n        return;\n      }\n      closeHelp(null);\n      requestAnimationFrame(() => {\n        requestAnimationFrame(runFocus);\n      });\n    });\n  }\n\n  // Search and filtering for the help dialog. Every keystroke scans both\n  // high-level sections and individual FAQ items, restoring their original\n  // markup, highlighting matches and hiding entries that do not include the\n  // query. A message is shown if nothing matches and the clear button is\n  // toggled based on the presence of a query.\n  const HELP_SEARCH_ACCENT_VARIANTS = new Map([\n    ['a', '\xE0\xE1\xE2\xE3\xE4\xE5\u0101\u0103\u0105\u01CE\u0201\u0203\u0227\u1EAD\u1EAF\u1EB1\u1EB5\u1EB3\u1EA5\u1EA7\u1EAB\u1EA9\u1EA3\u1EA1\xE6'],\n    ['b', '\u1E03\u0253'],\n    ['c', '\xE7\u0107\u0109\u010B\u010D\u0188'],\n    ['d', '\u010F\u0111\u1E0D\u1E11\u1E13'],\n    ['e', '\xE8\xE9\xEA\xEB\u0113\u0115\u0117\u0119\u011B\u0205\u0207\u1EB9\u1EBB\u1EBD\u1EBF\u1EC1\u1EC3\u1EC5\u1EC7'],\n    ['f', '\u0192\u1E1F'],\n    ['g', '\u011F\u0123\u011D\u0121\u01F5\u1E21'],\n    ['h', '\u0125\u0127\u1E23\u1E25\u1E27\u1E96'],\n    ['i', '\xEC\xED\xEE\xEF\u0129\u012B\u012D\u012F\u0131\u1EC9\u1ECB'],\n    ['j', '\u0135\u01F0'],\n    ['k', '\u0137\u0199\u1E31\u1E33\u1E35'],\n    ['l', '\u013A\u013C\u013E\u0142\u1E37\u1E3D'],\n    ['m', '\u1E3F\u1E41\u1E43'],\n    ['n', '\xF1\u0144\u0146\u0148\u01F9\u1E45\u1E47\u1E4B'],\n    ['o', '\xF2\xF3\xF4\xF5\xF6\u014D\u014F\u0151\xF8\u01D2\u020D\u020F\u01A1\u1ED9\u1EDB\u1EDD\u1EE1\u1EDF\u1EE3\u1ECD\u1ECF\u0153'],\n    ['p', '\u1E55\u1E57'],\n    ['q', '\u02A0'],\n    ['r', '\u0155\u0157\u0159\u0211\u0213\u1E5B\u1E59'],\n    ['s', '\u015B\u015D\u015F\u0161\u0219\u1E61\u1E63'],\n    ['t', '\u0163\u0165\u021B\u1E6B\u1E6D\u1E6F'],\n    ['u', '\xF9\xFA\xFB\xFC\u0169\u016B\u016D\u016F\u0171\u0173\u01D4\u0215\u0217\u01B0\u1EF1\u1EE9\u1EEB\u1EEF\u1EED\u1EE5\u1EE7'],\n    ['v', '\u1E7D\u1E7F'],\n    ['w', '\u0175\u1E81\u1E83\u1E85\u1E87\u1E89'],\n    ['x', '\u1E8B\u1E8D'],\n    ['y', '\xFD\xFF\u0177\u1EF3\u1EF7\u1EF9\u1EF5'],\n    ['z', '\u017A\u017C\u017E\u1E91\u1E93\u1E95']\n  ]);\n\n  const normaliseHelpSearchText = str => {\n    if (!str) return '';\n    let normalized = String(str).toLowerCase();\n    if (typeof normalized.normalize === 'function') {\n      normalized = normalized.normalize('NFD');\n    }\n    normalized = normalized\n      .replace(/[\\u0300-\\u036f]/g, '')\n      .replace(/\xDF/g, 'ss')\n      .replace(/\xE6/g, 'ae')\n      .replace(/\u0153/g, 'oe')\n      .replace(/\xF8/g, 'o')\n      .replace(/&/g, 'and')\n      .replace(/\\+/g, 'plus')\n      .replace(/[\xB0\xBA\u02DA]/g, 'deg')\n      .replace(/\\bdegrees?\\b/g, 'deg')\n      .replace(/[\xD7\u2715\u2716\u2717\u2718]/g, 'x');\n    normalized = normalizeSpellingVariants(normalized);\n    normalized = normaliseMarkVariants(normalized);\n    return normalized.replace(/[^a-z0-9]+/g, '');\n  };\n\n  const buildHelpHighlightPattern = normalized => {\n    if (!normalized) return null;\n    const escapeRegExp = str => str.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n    const parts = [];\n    const addLetterPattern = char => {\n      const variants = HELP_SEARCH_ACCENT_VARIANTS.get(char) || '';\n      const chars = new Set();\n      const all = `${char}${variants}`;\n      for (const ch of all) {\n        chars.add(ch);\n        const upper = ch.toUpperCase();\n        if (upper) chars.add(upper);\n      }\n      const escaped = Array.from(chars)\n        .map(escapeRegExp)\n        .join('');\n      return `[${escaped}]`;\n    };\n    const letters = Array.from(normalized);\n    letters.forEach((char, index) => {\n      if (index > 0) parts.push('\\\\s*');\n      if (/[a-z]/.test(char)) {\n        parts.push(addLetterPattern(char));\n      } else if (/[0-9]/.test(char)) {\n        parts.push(char);\n      } else {\n        parts.push(escapeRegExp(char));\n      }\n    });\n    return `(${parts.join('')})`;\n  };\n\n  updateHelpResultsSummaryText = ({\n    totalCount,\n    visibleCount,\n    hasQuery,\n    queryText\n  } = {}) => {\n    if (!helpResultsSummary) return;\n    if (typeof totalCount === 'number' && Number.isFinite(totalCount)) {\n      helpResultsSummary.dataset.totalCount = String(totalCount);\n    }\n    if (typeof visibleCount === 'number' && Number.isFinite(visibleCount)) {\n      helpResultsSummary.dataset.visibleCount = String(visibleCount);\n    }\n    if (typeof hasQuery === 'boolean') {\n      helpResultsSummary.dataset.hasQuery = hasQuery ? 'true' : 'false';\n    }\n    if (typeof queryText === 'string') {\n      helpResultsSummary.dataset.query = queryText;\n    }\n    const storedTotal = Number(helpResultsSummary.dataset.totalCount || 0);\n    if (!storedTotal) {\n      helpResultsSummary.textContent = '';\n      helpResultsSummary.setAttribute('hidden', '');\n      return;\n    }\n    const storedVisible = Number(\n      helpResultsSummary.dataset.visibleCount || 0\n    );\n    const storedHasQuery = helpResultsSummary.dataset.hasQuery === 'true';\n    const storedQuery = helpResultsSummary.dataset.query || '';\n    const langTexts = (texts && texts[currentLang]) || {};\n    const fallbackTexts = (texts && texts.en) || {};\n    let summaryText = '';\n    if (storedHasQuery) {\n      const template =\n        langTexts.helpResultsSummaryFiltered ||\n        fallbackTexts.helpResultsSummaryFiltered;\n      if (template) {\n        summaryText = template\n          .replace('%1$s', storedVisible)\n          .replace('%2$s', storedTotal)\n          .replace('%3$s', storedQuery);\n      } else if (storedQuery) {\n        summaryText = `Showing ${storedVisible} of ${storedTotal} help topics for \u201C${storedQuery}\u201D.`;\n      } else {\n        summaryText = `Showing ${storedVisible} of ${storedTotal} help topics.`;\n      }\n    } else {\n      const template =\n        langTexts.helpResultsSummaryAll ||\n        fallbackTexts.helpResultsSummaryAll;\n      if (template) {\n        summaryText = template.replace('%s', storedTotal);\n      } else {\n        summaryText = `All ${storedTotal} help topics are shown.`;\n      }\n    }\n    helpResultsSummary.textContent = summaryText;\n    helpResultsSummary.removeAttribute('hidden');\n  };\n\n  const filterHelp = () => {\n    // Bail out early if the search input is missing\n    if (!helpSearch) {\n      if (helpResultsSummary) helpResultsSummary.setAttribute('hidden', '');\n      return;\n    }\n    const rawQuery = helpSearch.value.trim();\n    const normalizedQuery = normaliseHelpSearchText(rawQuery);\n    const hasQuery = normalizedQuery.length > 0;\n    // Treat sections and FAQ items uniformly so the same logic can filter both\n    const sections = Array.from(\n      helpDialog.querySelectorAll('[data-help-section]')\n    );\n    const items = Array.from(helpDialog.querySelectorAll('.faq-item'));\n    const elements = sections.concat(items);\n    const totalCount = elements.length;\n    let visibleCount = 0;\n    const highlightPattern = hasQuery\n      ? buildHelpHighlightPattern(normalizedQuery)\n      : null;\n    const highlightMatches = (root, pattern) => {\n      if (\n        !pattern ||\n        typeof document.createTreeWalker !== 'function' ||\n        typeof NodeFilter === 'undefined'\n      ) {\n        return;\n      }\n      const walker = document.createTreeWalker(\n        root,\n        NodeFilter.SHOW_TEXT,\n        null\n      );\n      const textNodes = [];\n      while (walker.nextNode()) {\n        textNodes.push(walker.currentNode);\n      }\n      textNodes.forEach(node => {\n        const text = node.textContent;\n        if (!text) return;\n        const regex = new RegExp(pattern, 'giu');\n        const firstMatch = regex.exec(text);\n        if (!firstMatch) return;\n        const frag = document.createDocumentFragment();\n        let lastIndex = 0;\n        let match = firstMatch;\n        do {\n          const start = match.index;\n          const end = start + match[0].length;\n          if (start > lastIndex) {\n            frag.appendChild(\n              document.createTextNode(text.slice(lastIndex, start))\n            );\n          }\n          const mark = document.createElement('mark');\n          mark.textContent = text.slice(start, end);\n          frag.appendChild(mark);\n          lastIndex = end;\n          if (regex.lastIndex === start) {\n            regex.lastIndex++;\n          }\n        } while ((match = regex.exec(text)) !== null);\n        if (lastIndex < text.length) {\n          frag.appendChild(document.createTextNode(text.slice(lastIndex)));\n        }\n        if (node.parentNode) {\n          node.parentNode.replaceChild(frag, node);\n        }\n      });\n    };\n    elements.forEach(el => {\n      const isFaqItem = el.classList.contains('faq-item');\n      // Save original HTML once so that repeated filtering doesn't permanently\n      // insert <mark> tags; restore it before applying a new highlight. While\n      // doing so, capture the default open state for FAQ <details> elements so\n      // the search can temporarily expand matches and restore the original\n      // collapsed/expanded configuration when cleared.\n      if (!el.dataset.origHtml) {\n        el.dataset.origHtml = el.innerHTML;\n        if (isFaqItem) {\n          el.dataset.defaultOpen = el.hasAttribute('open') ? 'true' : 'false';\n        }\n      } else {\n        el.innerHTML = el.dataset.origHtml;\n      }\n      const text = normaliseHelpSearchText(el.textContent || '');\n      const keywordText = normaliseHelpSearchText(\n        el.dataset.helpKeywords || ''\n      );\n      const matches =\n        !hasQuery ||\n        text.includes(normalizedQuery) ||\n        keywordText.includes(normalizedQuery);\n      if (matches) {\n        if (hasQuery && highlightPattern) {\n          // Highlight the matching text while preserving the rest of the content\n          highlightMatches(el, highlightPattern);\n        }\n        el.removeAttribute('hidden');\n        if (isFaqItem) {\n          if (hasQuery) {\n            el.setAttribute('open', '');\n          } else if (el.dataset.defaultOpen === 'true') {\n            el.setAttribute('open', '');\n          } else {\n            el.removeAttribute('open');\n          }\n        }\n        visibleCount += 1;\n      } else {\n        // Hide entries that do not match and collapse FAQ answers while they\n        // are filtered out so reopening the dialog starts from a clean state.\n        el.setAttribute('hidden', '');\n        if (isFaqItem) {\n          el.removeAttribute('open');\n        }\n      }\n    });\n    if (typeof updateHelpResultsSummaryText === 'function') {\n      updateHelpResultsSummaryText({\n        totalCount,\n        visibleCount,\n        hasQuery,\n        queryText: rawQuery || normalizedQuery\n      });\n    }\n    if (helpNoResults) {\n      // Show or hide the \"no results\" indicator\n      if (visibleCount > 0) {\n        helpNoResults.setAttribute('hidden', '');\n      } else {\n        helpNoResults.removeAttribute('hidden');\n      }\n    }\n    if (helpSearchClear) {\n      // Only show the clear button when there is text in the search box\n      if (hasQuery) {\n        helpSearchClear.removeAttribute('hidden');\n      } else {\n        helpSearchClear.setAttribute('hidden', '');\n      }\n    }\n    syncHelpQuickLinksVisibility();\n  };\n\n  // Display the help dialog. The search box is reset so stale filter state\n  // doesn't persist between openings, and focus is moved to the search field\n  // for immediate typing.\n  const openHelp = () => {\n    closeSideMenu();\n    helpDialog.removeAttribute('hidden');\n    openDialog(helpDialog);\n    if (helpSearch) {\n      helpSearch.value = '';\n      filterHelp(); // ensure all sections are visible again\n      if (helpQuickLinksList) {\n        helpQuickLinksList\n          .querySelectorAll('.help-quick-link.active')\n          .forEach(btn => btn.classList.remove('active'));\n      }\n      if (helpContent) {\n        helpContent.scrollTop = 0;\n      }\n      helpSearch.focus();\n    } else {\n      try {\n        helpDialog.focus({ preventScroll: true });\n      } catch {\n        helpDialog.focus();\n      }\n    }\n  };\n\n  // Hide the dialog and return focus to the button that opened it\n  const closeHelp = (returnFocusEl = helpButton) => {\n    closeDialog(helpDialog);\n    helpDialog.setAttribute('hidden', '');\n    if (returnFocusEl && typeof returnFocusEl.focus === 'function') {\n      try {\n        returnFocusEl.focus({ preventScroll: true });\n      } catch {\n        returnFocusEl.focus();\n      }\n    }\n  };\n\n  // Convenience helper for toggling the dialog open or closed\n  const toggleHelp = () => {\n    if (!isDialogOpen(helpDialog)) {\n      openHelp();\n    } else {\n      closeHelp();\n    }\n  };\n\n  // Hover help mode displays a tooltip describing whichever element the user\n  // points at or focuses. It is triggered from a button inside the dialog and\n  // uses the same data-help/aria-* attributes that power the dialog content.\n  let hoverHelpActive = false;\n  let hoverHelpTooltip;\n  let hoverHelpCurrentTarget = null;\n\n  const HOVER_HELP_TARGET_SELECTOR =\n    '[data-help], [aria-label], [title], [aria-labelledby], [alt], [aria-describedby]';\n\n  const findHoverHelpTarget = start => {\n    if (!start) return null;\n    const el = start.closest(HOVER_HELP_TARGET_SELECTOR);\n    if (!el || el.tagName === 'SECTION') {\n      return null;\n    }\n    return el;\n  };\n\n  const collectHoverHelpText = el => {\n    if (!el) return [];\n    const parts = [];\n    const addText = value => {\n      if (typeof value !== 'string') return;\n      const trimmed = value.trim();\n      if (!trimmed) return;\n      if (!parts.includes(trimmed)) parts.push(trimmed);\n    };\n\n    const addTextFromElement = (element, { includeTextContent = false } = {}) => {\n      if (!element) return;\n      addText(element.getAttribute('data-help'));\n      addText(element.getAttribute('aria-label'));\n      addText(element.getAttribute('aria-description'));\n      addText(element.getAttribute('title'));\n      if (includeTextContent) {\n        addText(element.textContent);\n      }\n    };\n\n    addTextFromElement(el);\n\n    const applyFromIds = ids => {\n      if (!ids) return;\n      ids\n        .split(/\\s+/)\n        .filter(Boolean)\n        .forEach(id => {\n          const ref = document.getElementById(id);\n          if (!ref) return;\n          addTextFromElement(ref, { includeTextContent: true });\n        });\n    };\n\n    applyFromIds(el.getAttribute('aria-labelledby'));\n    addText(el.getAttribute('alt'));\n    applyFromIds(el.getAttribute('aria-describedby'));\n\n    findAssociatedLabelElements(el).forEach(labelEl => {\n      addTextFromElement(labelEl, { includeTextContent: true });\n    });\n\n    if (!parts.length) {\n      addText(el.textContent);\n    }\n\n    return parts;\n  };\n\n  const positionHoverHelpTooltip = target => {\n    if (!hoverHelpTooltip || !target) return;\n    const rect = target.getBoundingClientRect();\n    const docEl = document.documentElement;\n    const viewportWidth = Math.max(docEl?.clientWidth || 0, window.innerWidth || 0);\n    const viewportHeight = Math.max(docEl?.clientHeight || 0, window.innerHeight || 0);\n    const scrollX = window.scrollX || window.pageXOffset || 0;\n    const scrollY = window.scrollY || window.pageYOffset || 0;\n    const horizontalOffset = 12;\n    const verticalOffset = 10;\n    const viewportPadding = 8;\n\n    const safeLeft = Number.isFinite(rect.left) ? rect.left : 0;\n    const safeRight = Number.isFinite(rect.right) ? rect.right : safeLeft + (rect.width || 0);\n    const safeTop = Number.isFinite(rect.top) ? rect.top : 0;\n    const safeBottom = Number.isFinite(rect.bottom) ? rect.bottom : safeTop;\n\n    const tooltipRect = hoverHelpTooltip.getBoundingClientRect();\n    const tooltipWidth = tooltipRect.width || hoverHelpTooltip.offsetWidth || 0;\n    const tooltipHeight = tooltipRect.height || hoverHelpTooltip.offsetHeight || 0;\n\n    let top = safeBottom + scrollY + verticalOffset;\n    let left = safeLeft + scrollX;\n\n    if (tooltipWidth) {\n      const viewportRightLimit = scrollX + viewportWidth - viewportPadding;\n      const defaultRight = left + tooltipWidth;\n      if (defaultRight > viewportRightLimit) {\n        left = safeRight + scrollX - tooltipWidth - horizontalOffset;\n      }\n\n      const minLeft = scrollX + viewportPadding;\n      const maxLeft =\n        scrollX + Math.max(viewportWidth - tooltipWidth - viewportPadding, viewportPadding);\n      if (left < minLeft) {\n        left = minLeft;\n      } else if (left > maxLeft) {\n        left = maxLeft;\n      }\n    }\n\n    if (tooltipHeight) {\n      const minTop = scrollY + viewportPadding;\n      const maxTop = scrollY + Math.max(viewportHeight - tooltipHeight - viewportPadding, viewportPadding);\n      if (top > maxTop) {\n        const aboveTop = safeTop + scrollY - tooltipHeight - verticalOffset;\n        if (aboveTop >= minTop) {\n          top = aboveTop;\n        } else {\n          top = Math.min(Math.max(top, minTop), maxTop);\n        }\n      } else if (top < minTop) {\n        top = minTop;\n      }\n    }\n\n    hoverHelpTooltip.style.top = `${top}px`;\n    hoverHelpTooltip.style.left = `${left}px`;\n  };\n\n  const hideHoverHelpTooltip = () => {\n    if (!hoverHelpTooltip) return;\n    hoverHelpTooltip.setAttribute('hidden', '');\n    hoverHelpTooltip.style.removeProperty('visibility');\n  };\n\n  const updateHoverHelpTooltip = target => {\n    hoverHelpCurrentTarget = target || null;\n    if (!hoverHelpActive || !hoverHelpTooltip || !target) {\n      hideHoverHelpTooltip();\n      return;\n    }\n    const textParts = collectHoverHelpText(target);\n    if (!textParts.length) {\n      hideHoverHelpTooltip();\n      return;\n    }\n    hoverHelpTooltip.textContent = textParts.join(' ');\n    const wasHidden = hoverHelpTooltip.hasAttribute('hidden');\n    if (wasHidden) {\n      hoverHelpTooltip.style.visibility = 'hidden';\n      hoverHelpTooltip.removeAttribute('hidden');\n    }\n    positionHoverHelpTooltip(target);\n    if (wasHidden) {\n      hoverHelpTooltip.style.removeProperty('visibility');\n    }\n    hoverHelpTooltip.removeAttribute('hidden');\n  };\n\n  const canInteractDuringHoverHelp = target => {\n    if (!hoverHelpActive || !target) return false;\n    return !!target.closest('[data-allow-hover-help], #settingsButton, #settingsDialog');\n  };\n\n  // Exit hover-help mode and clean up tooltip/cursor state\n  const stopHoverHelp = () => {\n    hoverHelpActive = false;\n    hoverHelpCurrentTarget = null;\n    if (hoverHelpTooltip) {\n      hoverHelpTooltip.remove();\n      hoverHelpTooltip = null;\n    }\n    document.body.style.cursor = '';\n    document.body.classList.remove('hover-help-active');\n  };\n\n  // Start hover-help mode: close the dialog, create the tooltip element and\n  // switch the cursor to the standard help cursor.\n  const startHoverHelp = () => {\n    hoverHelpActive = true;\n    closeHelp();\n    document.body.style.cursor = 'help';\n    document.body.classList.add('hover-help-active');\n    hoverHelpTooltip = document.createElement('div');\n    hoverHelpTooltip.id = 'hoverHelpTooltip';\n    hoverHelpTooltip.setAttribute('role', 'tooltip');\n    hoverHelpTooltip.setAttribute('hidden', '');\n    document.body.appendChild(hoverHelpTooltip);\n  };\n\n  const refreshTooltipPosition = () => {\n    if (hoverHelpActive && hoverHelpTooltip && hoverHelpCurrentTarget) {\n      positionHoverHelpTooltip(hoverHelpCurrentTarget);\n    }\n  };\n\n  document.addEventListener('mouseover', e => {\n    if (!hoverHelpActive || !hoverHelpTooltip) return;\n    const target = findHoverHelpTarget(e.target);\n    updateHoverHelpTooltip(target);\n  });\n\n  document.addEventListener('focusin', e => {\n    if (!hoverHelpActive || !hoverHelpTooltip) return;\n    const target = findHoverHelpTarget(e.target);\n    updateHoverHelpTooltip(target);\n  });\n\n  document.addEventListener('focusout', e => {\n    if (!hoverHelpActive || !hoverHelpTooltip) return;\n    if (!e.relatedTarget || !findHoverHelpTarget(e.relatedTarget)) {\n      hoverHelpCurrentTarget = null;\n      hideHoverHelpTooltip();\n    }\n  });\n\n  window.addEventListener('scroll', refreshTooltipPosition, true);\n  window.addEventListener('resize', refreshTooltipPosition);\n\n  // Prevent interacting with controls like dropdowns while hover help is active\n  document.addEventListener(\n    'mousedown',\n    e => {\n      if (hoverHelpActive && !canInteractDuringHoverHelp(e.target)) {\n        e.preventDefault();\n      }\n    },\n    true\n  );\n\n  document.addEventListener('click', e => {\n    // Any click while in hover-help mode exits the mode and removes the tooltip\n    if (!hoverHelpActive) return;\n    if (canInteractDuringHoverHelp(e.target)) {\n      return;\n    }\n    e.preventDefault();\n    stopHoverHelp();\n  });\n\n  if (hoverHelpButton) {\n    // Dedicated button inside the dialog to enable hover-help mode\n    hoverHelpButton.addEventListener('click', e => {\n      e.stopPropagation();\n      startHoverHelp(); // activate tooltip mode\n    });\n  }\n\n  const focusFeatureSearchInput = () => {\n    if (!featureSearch) return;\n    const sideMenu = document.getElementById('sideMenu');\n    if (sideMenu?.contains(featureSearch)) {\n      openSideMenu();\n    }\n    if (typeof featureSearch.scrollIntoView === 'function') {\n      featureSearch.scrollIntoView({ behavior: 'smooth', block: 'center' });\n    }\n    try {\n      featureSearch.focus({ preventScroll: true });\n    } catch {\n      featureSearch.focus();\n    }\n    if (typeof featureSearch.select === 'function') {\n      featureSearch.select();\n    }\n    featureSearch.showPicker?.();\n  };\n\n  runFeatureSearch = query => {\n    const rawQuery = typeof query === 'string' ? query : featureSearch?.value || '';\n    const originalNormalized = normalizeSearchValue(rawQuery);\n    const value = rawQuery.trim();\n    if (!value) return;\n    const lower = value.toLowerCase();\n    const isHelp = lower.endsWith(' (help)');\n    const clean = isHelp ? value.slice(0, -7).trim() : value;\n    const cleanKey = searchKey(clean);\n    const cleanTokens = searchTokens(clean);\n\n    const helpMatch = findBestSearchMatch(helpMap, cleanKey, cleanTokens);\n    const deviceMatch = findBestSearchMatch(deviceMap, cleanKey, cleanTokens);\n    const featureMatch = findBestSearchMatch(featureMap, cleanKey, cleanTokens);\n    const helpScore = helpMatch?.score || 0;\n    const deviceScore = deviceMatch?.score || 0;\n    const featureScore = featureMatch?.score || 0;\n    const deviceStrong = deviceMatch ? STRONG_SEARCH_MATCH_TYPES.has(deviceMatch.matchType) : false;\n    const featureStrong = featureMatch ? STRONG_SEARCH_MATCH_TYPES.has(featureMatch.matchType) : false;\n    const bestNonHelpScore = Math.max(deviceScore, featureScore);\n    const hasStrongNonHelp = deviceStrong || featureStrong;\n    const preferHelp =\n      !!helpMatch &&\n      (isHelp || (!hasStrongNonHelp && helpScore > bestNonHelpScore));\n\n    if (!isHelp && !preferHelp) {\n      const shouldUseDevice =\n        !!deviceMatch &&\n        (!featureMatch ||\n          (deviceStrong && !featureStrong) ||\n          (deviceStrong === featureStrong &&\n            (deviceScore > featureScore ||\n              (deviceScore === featureScore && featureMatch?.matchType !== 'exactKey'))));\n      if (shouldUseDevice) {\n        const device = deviceMatch.value;\n        if (device && device.select) {\n          device.select.value = device.value;\n          device.select.dispatchEvent(new Event('change', { bubbles: true }));\n          if (device.label) {\n            updateFeatureSearchValue(device.label, originalNormalized);\n          }\n          focusFeatureElement(device.select);\n          const highlightTargets = [\n            device.select,\n            ...findAssociatedLabelElements(device.select)\n          ];\n          highlightFeatureSearchTargets(highlightTargets);\n          return;\n        }\n      }\n      if (featureMatch) {\n        const feature = featureMatch.value;\n        const featureEl = feature?.element || feature;\n        if (featureEl) {\n          const label = feature?.label || featureEl.textContent?.trim();\n          if (label) {\n            updateFeatureSearchValue(label, originalNormalized);\n          }\n          focusFeatureElement(featureEl);\n          const highlightTargets = [\n            featureEl,\n            ...findAssociatedLabelElements(featureEl)\n          ];\n          highlightFeatureSearchTargets(highlightTargets);\n          return;\n        }\n      }\n    }\n    if (helpMatch) {\n      const helpEntry = helpMatch.value || {};\n      const section = helpEntry.section;\n      openHelp();\n      if (helpSearch) {\n        helpSearch.value = clean;\n        filterHelp();\n      }\n      if (section) {\n        if (section.hasAttribute('hidden')) {\n          section.removeAttribute('hidden');\n          if (helpNoResults) {\n            helpNoResults.setAttribute('hidden', '');\n          }\n          syncHelpQuickLinksVisibility();\n        }\n        if (typeof section.scrollIntoView === 'function') {\n          section.scrollIntoView({ behavior: 'smooth', block: 'start' });\n        }\n        highlightHelpSection(section);\n        const sectionHeading =\n          section.querySelector('h3, summary, h4, h5, h6, [role=\"heading\"]') ||\n          section.querySelector('button, a');\n        if (sectionHeading) {\n          highlightFeatureSearchTargets([sectionHeading]);\n        } else {\n          highlightFeatureSearchTargets([section]);\n        }\n        const quickLink = section.id ? helpQuickLinkItems.get(section.id) : null;\n        if (helpQuickLinksList) {\n          helpQuickLinksList\n            .querySelectorAll('.help-quick-link.active')\n            .forEach(btn => btn.classList.remove('active'));\n        }\n        if (quickLink && quickLink.button) {\n          quickLink.button.classList.add('active');\n        }\n      }\n      return;\n    }\n    openHelp();\n    if (helpSearch) {\n      helpSearch.value = clean;\n      filterHelp();\n      highlightFeatureSearchTargets([helpSearch]);\n    }\n  };\n\n  if (featureSearch) {\n    const handle = () => runFeatureSearch(featureSearch.value);\n    featureSearch.addEventListener('change', handle);\n    featureSearch.addEventListener('input', () => {\n      updateFeatureSearchSuggestions(featureSearch.value);\n      featureSearch.showPicker?.();\n    });\n    featureSearch.addEventListener('keydown', e => {\n      if (e.key === 'Enter') {\n        handle();\n      } else if (e.key === 'Escape' && featureSearch.value) {\n        featureSearch.value = '';\n        restoreFeatureSearchDefaults();\n        featureSearch.showPicker?.();\n        e.preventDefault();\n      }\n    });\n  }\n\n  // Wire up button clicks and search field interactions\n  helpButton.addEventListener('click', toggleHelp);\n  if (closeHelpBtn) closeHelpBtn.addEventListener('click', closeHelp);\n  if (helpSearch) helpSearch.addEventListener('input', filterHelp);\n  if (helpSearchClear) helpSearchClear.addEventListener('click', () => {\n    if (helpSearch) {\n      helpSearch.value = '';\n      filterHelp();\n      helpSearch.focus();\n    }\n  });\n\n  document.addEventListener('keydown', e => {\n    const tag = document.activeElement.tagName;\n    const isTextField = tag === 'INPUT' || tag === 'TEXTAREA';\n    // Keyboard shortcuts controlling the help dialog and hover-help mode\n    if (hoverHelpActive && e.key === 'Escape') {\n      // Escape exits hover-help mode\n      stopHoverHelp();\n    } else if (e.key === 'Escape' && isDialogOpen(helpDialog)) {\n      // Escape closes the help dialog\n      e.preventDefault();\n      closeHelp();\n    } else if (\n      e.key === 'Escape' && settingsDialog && isDialogOpen(settingsDialog)\n    ) {\n      e.preventDefault();\n      revertSettingsPinkModeIfNeeded();\n      rememberSettingsPinkModeBaseline();\n      revertAccentColor();\n      closeDialog(settingsDialog);\n      settingsDialog.setAttribute('hidden', '');\n    } else if (\n      e.key === 'F1' ||\n      ((e.key === '/' || e.key === '?') && (e.ctrlKey || e.metaKey))\n    ) {\n      // F1 or Ctrl+/ toggles the dialog even while typing\n      e.preventDefault();\n      toggleHelp();\n    } else if (\n      e.key === '/' &&\n      !isTextField &&\n      (!helpDialog || !isDialogOpen(helpDialog))\n    ) {\n      e.preventDefault();\n      focusFeatureSearchInput();\n    } else if (\n      (e.key === '?' && !isTextField) ||\n      (e.key.toLowerCase() === 'h' && !isTextField)\n    ) {\n      // Plain ? or H opens the dialog when not typing in a field\n      e.preventDefault();\n      toggleHelp();\n    } else if (\n      isDialogOpen(helpDialog) &&\n      ((e.key === '/' && !isTextField) || (e.key.toLowerCase() === 'f' && (e.ctrlKey || e.metaKey)))\n    ) {\n      // When the dialog is open, / or Ctrl+F moves focus to the search box\n      e.preventDefault();\n      if (helpSearch) helpSearch.focus();\n    } else if (e.key === ',' && (e.ctrlKey || e.metaKey)) {\n      e.preventDefault();\n      if (settingsButton) settingsButton.click();\n    } else if (e.key.toLowerCase() === 'k' && (e.ctrlKey || e.metaKey)) {\n      e.preventDefault();\n      focusFeatureSearchInput();\n    } else if (e.key.toLowerCase() === 'd' && !isTextField) {\n      darkModeEnabled = !document.body.classList.contains('dark-mode');\n      applyDarkMode(darkModeEnabled);\n      try {\n        localStorage.setItem('darkMode', darkModeEnabled);\n      } catch (err) {\n        console.warn('Could not save dark mode preference', err);\n      }\n    } else if (e.key.toLowerCase() === 's' && (e.ctrlKey || e.metaKey)) {\n      e.preventDefault();\n      if (saveSetupBtn && !saveSetupBtn.disabled) {\n        saveSetupBtn.click();\n      }\n    } else if (e.key.toLowerCase() === 'p' && !isTextField) {\n      persistPinkModePreference(!document.body.classList.contains('pink-mode'));\n    }\n  });\n\n  helpDialog.addEventListener('click', e => {\n    // Clicking the semi-transparent backdrop (not the dialog content) closes it\n    if (e.target === helpDialog) closeHelp();\n  });\n\n  helpDialog.addEventListener('cancel', e => {\n    e.preventDefault();\n    closeHelp();\n  });\n}\n\n// Initial calculation and language set after DOM is ready\n// Initialize immediately if DOM is already loaded (e.g. when scripts are\n// injected after `DOMContentLoaded` fired). Otherwise wait for the event.\n\n\nconst scenarioIcons = {\n  Indoor: iconGlyph('\\uF194', ICON_FONT_KEYS.ESSENTIAL),\n  Outdoor: iconGlyph('\\uF278', ICON_FONT_KEYS.ESSENTIAL),\n  Studio: iconGlyph('\\uF128', ICON_FONT_KEYS.FILM),\n  Tripod: iconGlyph('\\uF12C', ICON_FONT_KEYS.FILM),\n  Handheld: iconGlyph('\\uE93B', ICON_FONT_KEYS.UICONS),\n  Easyrig: iconGlyph('\\uE15B', ICON_FONT_KEYS.UICONS),\n  'Cine Saddle': iconGlyph('\\uF01B', ICON_FONT_KEYS.UICONS),\n  Steadybag: iconGlyph('\\uE925', ICON_FONT_KEYS.UICONS),\n  Dolly: iconGlyph('\\uF109', ICON_FONT_KEYS.FILM),\n  Slider: iconGlyph('\\uE112', ICON_FONT_KEYS.UICONS),\n  Steadicam: iconGlyph('\\uEFBD', ICON_FONT_KEYS.UICONS),\n  Gimbal: iconGlyph('\\uEA9C', ICON_FONT_KEYS.UICONS),\n  Trinity: iconGlyph('\\uEA4E', ICON_FONT_KEYS.UICONS),\n  Rollcage: iconGlyph('\\uF04C', ICON_FONT_KEYS.UICONS),\n  'Car Mount': iconGlyph('\\uE35B', ICON_FONT_KEYS.UICONS),\n  Jib: iconGlyph('\\uE553', ICON_FONT_KEYS.UICONS),\n  'Undersling mode': iconGlyph('\\uE0D8', ICON_FONT_KEYS.UICONS),\n  Crane: iconGlyph('\\uE554', ICON_FONT_KEYS.UICONS),\n  'Remote Head': ICON_GLYPHS.controller,\n  'Extreme cold (snow)': iconGlyph('\\uF0FB', ICON_FONT_KEYS.UICONS),\n  'Extreme rain': iconGlyph('\\uE4A6', ICON_FONT_KEYS.UICONS),\n  'Extreme heat': iconGlyph('\\uE80F', ICON_FONT_KEYS.UICONS),\n  'Rain Machine': iconGlyph('\\uF153', ICON_FONT_KEYS.UICONS),\n  'Slow Motion': iconGlyph('\\uF373', ICON_FONT_KEYS.UICONS),\n  'Battery Belt': ICON_GLYPHS.batteryBolt\n};\n\nfunction updateRequiredScenariosSummary() {\n  if (!requiredScenariosSelect || !requiredScenariosSummary) return;\n  requiredScenariosSummary.innerHTML = '';\n  let selected = Array.from(requiredScenariosSelect.selectedOptions).map(o => o.value);\n  const hasDolly = selected.includes('Dolly');\n  if (remoteHeadOption) {\n    if (!hasDolly) {\n      remoteHeadOption.hidden = true;\n      remoteHeadOption.selected = false;\n      selected = selected.filter(v => v !== 'Remote Head');\n    } else {\n      remoteHeadOption.hidden = false;\n    }\n  }\n  if (\n    hasDolly &&\n    monitorSelect &&\n    (!monitorSelect.value || monitorSelect.value === 'None')\n  ) {\n    const defaultMonitor = 'SmallHD Ultra 7';\n    if (devices?.monitors?.[defaultMonitor]) {\n      if (!Array.from(monitorSelect.options).some(o => o.value === defaultMonitor)) {\n        const opt = document.createElement('option');\n        opt.value = defaultMonitor;\n        opt.textContent = defaultMonitor;\n        monitorSelect.appendChild(opt);\n      }\n      monitorSelect.value = defaultMonitor;\n      monitorSelect.dispatchEvent(new Event('change'));\n    }\n  }\n  if (videoDistributionSelect) {\n    const ensureOption = val => {\n      let opt = Array.from(videoDistributionSelect.options).find(o => o.value === val);\n      if (!opt) {\n        opt = document.createElement('option');\n        opt.value = val;\n        opt.textContent = val;\n        videoDistributionSelect.appendChild(opt);\n      }\n    };\n    ensureOption('DoP Monitor 7\" handheld');\n    ensureOption('DoP Monitor 15-21\"');\n  }\n  selected.forEach(val => {\n    const box = document.createElement('span');\n    box.className = 'scenario-box';\n    const iconSpan = document.createElement('span');\n    iconSpan.className = 'scenario-icon icon-glyph';\n    applyIconGlyph(iconSpan, scenarioIcons[val] || ICON_GLYPHS.pin);\n    box.appendChild(iconSpan);\n    box.appendChild(document.createTextNode(val));\n    requiredScenariosSummary.appendChild(box);\n  });\n  if (tripodPreferencesRow) {\n    if (selected.includes('Tripod')) {\n      tripodPreferencesRow.classList.remove('hidden');\n      if (tripodPreferencesHeading) tripodPreferencesHeading.classList.remove('hidden');\n      if (tripodPreferencesSection) tripodPreferencesSection.classList.remove('hidden');\n    } else {\n      tripodPreferencesRow.classList.add('hidden');\n      if (tripodPreferencesHeading) tripodPreferencesHeading.classList.add('hidden');\n      if (tripodPreferencesSection) tripodPreferencesSection.classList.add('hidden');\n      if (tripodHeadBrandSelect) tripodHeadBrandSelect.value = '';\n      if (tripodBowlSelect) tripodBowlSelect.value = '';\n      if (tripodTypesSelect) Array.from(tripodTypesSelect.options).forEach(o => { o.selected = false; });\n      if (tripodSpreaderSelect) tripodSpreaderSelect.value = '';\n      updateTripodOptions();\n    }\n  }\n}\n\nfunction initApp() {\n  if (sharedLinkRow) {\n    sharedLinkRow.classList.remove('hidden');\n  }\n  populateEnvironmentDropdowns();\n  populateLensDropdown();\n  populateFilterDropdown();\n  if (filterSelectElem) {\n    filterSelectElem.addEventListener('change', renderFilterDetails);\n    filterSelectElem.addEventListener('change', () => {\n      saveCurrentSession();\n      saveCurrentGearList();\n      checkSetupChanged();\n    });\n    renderFilterDetails();\n  }\n  populateUserButtonDropdowns();\n  document.querySelectorAll('#projectForm select')\n    .forEach(sel => {\n      attachSelectSearch(sel);\n      initFavoritableSelect(sel);\n    });\n  setupInstallBanner();\n  setLanguage(currentLang);\n  maybeShowIosPwaHelp();\n  resetDeviceForm();\n  ensureDefaultProjectInfoSnapshot();\n  restoreSessionState();\n  applySharedSetupFromUrl();\n  if (requiredScenariosSelect) {\n    requiredScenariosSelect.addEventListener('change', updateRequiredScenariosSummary);\n    updateRequiredScenariosSummary();\n  }\n  if (tripodHeadBrandSelect) {\n    tripodHeadBrandSelect.addEventListener('change', updateTripodOptions);\n  }\n  if (tripodBowlSelect) {\n    tripodBowlSelect.addEventListener('change', updateTripodOptions);\n  }\n  updateTripodOptions();\n  updateViewfinderExtensionVisibility();\n  updateCalculations();\n  applyFilters();\n}\n\nfunction populateEnvironmentDropdowns() {\n  const tempSelect = document.getElementById('fbTemperature');\n  if (tempSelect) {\n    ensureFeedbackTemperatureOptions(tempSelect);\n    updateFeedbackTemperatureOptions();\n  }\n\n}\n\nfunction populateLensDropdown() {\n  if (!lensSelect) return;\n\n  lensSelect.innerHTML = '';\n  const lensData = devices && devices.lenses;\n\n  if (!lensData || Object.keys(lensData).length === 0) {\n    return;\n  }\n\n  if (!lensSelect.multiple) {\n    const emptyOpt = document.createElement('option');\n    emptyOpt.value = '';\n    lensSelect.appendChild(emptyOpt);\n  }\n  Object.keys(lensData).sort(localeSort).forEach(name => {\n    const opt = document.createElement('option');\n    opt.value = name;\n    const lens = lensData[name] || {};\n    const attrs = [];\n    if (lens.weight_g) attrs.push(`${lens.weight_g}g`);\n    if (lens.clampOn) {\n      if (lens.frontDiameterMm) attrs.push(`${lens.frontDiameterMm}mm clamp-on`);\n      else attrs.push('clamp-on');\n    } else if (lens.clampOn === false) {\n      attrs.push('no clamp-on');\n    }\n    const minFocus = lens.minFocusMeters ?? lens.minFocus ?? (lens.minFocusCm ? lens.minFocusCm / 100 : null);\n    if (minFocus) attrs.push(`${minFocus}m min focus`);\n    opt.textContent = attrs.length ? `${name} (${attrs.join(', ')})` : name;\n    lensSelect.appendChild(opt);\n  });\n}\n\nfunction populateCameraPropertyDropdown(selectId, property, selected = '') {\n  const dropdown = document.getElementById(selectId);\n  if (!dropdown) return;\n\n  dropdown.innerHTML = '';\n  const emptyOpt = document.createElement('option');\n  emptyOpt.value = '';\n  dropdown.appendChild(emptyOpt);\n\n  const camKey = cameraSelect && cameraSelect.value;\n  const values =\n    camKey && devices && devices.cameras && devices.cameras[camKey]\n      ? devices.cameras[camKey][property]\n      : null;\n  if (Array.isArray(values)) {\n    values.forEach(v => {\n      const opt = document.createElement('option');\n      opt.value = v;\n      opt.textContent = v;\n      if (v === selected) opt.selected = true;\n      dropdown.appendChild(opt);\n    });\n  }\n}\n\nfunction populateRecordingResolutionDropdown(selected = '') {\n  populateCameraPropertyDropdown('recordingResolution', 'resolutions', selected);\n}\n\nfunction populateSensorModeDropdown(selected = '') {\n  populateCameraPropertyDropdown('sensorMode', 'sensorModes', selected);\n}\n\nfunction populateCodecDropdown(selected = '') {\n  populateCameraPropertyDropdown('codec', 'recordingCodecs', selected);\n}\n\nfunction populateFilterDropdown() {\n  if (filterSelectElem && devices && Array.isArray(devices.filterOptions)) {\n    if (!filterSelectElem.multiple) {\n      const emptyOpt = document.createElement('option');\n      emptyOpt.value = '';\n      filterSelectElem.appendChild(emptyOpt);\n    }\n    devices.filterOptions.forEach(f => {\n      const opt = document.createElement('option');\n      opt.value = f;\n      opt.textContent = f;\n      filterSelectElem.appendChild(opt);\n    });\n  }\n}\n\nconst filterId = t => t.replace(/[^a-z0-9]/gi, '_');\n\nfunction getFilterValueConfig(type) {\n  switch (type) {\n    case 'IRND':\n      return { opts: ['0.3','0.6','0.9','1.2','1.5','1.8','2.1','2.5'], defaults: ['0.3','1.2'] };\n    case 'Diopter':\n      return { opts: ['+1/4','+1/2','+1','+2','+3','+4'], defaults: ['+1/2','+1','+2','+4'] };\n    case 'ND Grad HE':\n      return {\n        opts: ['0.3 HE Vertical','0.6 HE Vertical','0.9 HE Vertical','1.2 HE Vertical','0.3 HE Horizontal','0.6 HE Horizontal','0.9 HE Horizontal','1.2 HE Horizontal'],\n        defaults: ['0.3 HE Horizontal','0.6 HE Horizontal','0.9 HE Horizontal']\n      };\n    case 'ND Grad SE':\n      return {\n        opts: ['0.3 SE Vertical','0.6 SE Vertical','0.9 SE Vertical','1.2 SE Vertical','0.3 SE Horizontal','0.6 SE Horizontal','0.9 SE Horizontal','1.2 SE Horizontal'],\n        defaults: ['0.3 SE Horizontal','0.6 SE Horizontal','0.9 SE Horizontal']\n      };\n    default:\n      return { opts: ['1','1/2','1/4','1/8','1/16'], defaults: ['1/2','1/4','1/8'] };\n  }\n}\n\nfunction createFilterSizeSelect(type, selected = DEFAULT_FILTER_SIZE, options = {}) {\n  const { includeId = true, idPrefix = 'filter-size-' } = options;\n  const sel = document.createElement('select');\n  if (includeId) {\n    sel.id = `${idPrefix}${filterId(type)}`;\n  }\n  let sizes = [DEFAULT_FILTER_SIZE, '4x4', '6x6', '95mm'];\n  if (type === 'Rota-Pol') sizes = [DEFAULT_FILTER_SIZE, '6x6', '95mm'];\n  sizes.forEach(s => {\n    const o = document.createElement('option');\n    o.value = s;\n    o.textContent = s;\n    if (s === selected) o.selected = true;\n    sel.appendChild(o);\n  });\n  return sel;\n}\n\n/* exported createFilterValueSelect */\nfunction createFilterValueSelect(type, selected) {\n  const sel = document.createElement('select');\n  sel.id = `filter-values-${filterId(type)}`;\n  // Allow selecting multiple strengths for a given filter\n  // Use both the property and attribute to ensure HTML serialization\n  sel.multiple = true;\n  sel.setAttribute('multiple', '');\n  const { opts, defaults = [] } = getFilterValueConfig(type);\n  const selectedVals = Array.isArray(selected)\n    ? selected.slice()\n    : defaults.slice();\n  const syncOption = (option, isSelected) => {\n    option.selected = isSelected;\n    if (isSelected) {\n      option.setAttribute('selected', '');\n    } else {\n      option.removeAttribute('selected');\n    }\n  };\n  const syncCheckbox = (checkbox, isChecked) => {\n    checkbox.checked = isChecked;\n    if (isChecked) {\n      checkbox.setAttribute('checked', '');\n    } else {\n      checkbox.removeAttribute('checked');\n    }\n  };\n  opts.forEach(o => {\n    const opt = document.createElement('option');\n    opt.value = o;\n    opt.textContent = o;\n    syncOption(opt, selectedVals.includes(o));\n    sel.appendChild(opt);\n  });\n  // Hidden select holds the values; checkboxes provide the UI\n  sel.size = opts.length;\n  sel.style.display = 'none';\n  const container = document.createElement('span');\n  container.className = 'filter-values-container';\n  opts.forEach(o => {\n    const lbl = document.createElement('label');\n    lbl.className = 'filter-value-option';\n    const cb = document.createElement('input');\n    cb.type = 'checkbox';\n    cb.value = o;\n    syncCheckbox(cb, selectedVals.includes(o));\n    cb.addEventListener('change', () => {\n      const opt = Array.from(sel.options).find(opt => opt.value === o);\n      if (opt) syncOption(opt, cb.checked);\n      syncCheckbox(cb, cb.checked);\n      sel.dispatchEvent(new Event('change'));\n    });\n    lbl.appendChild(cb);\n    lbl.appendChild(document.createTextNode(o));\n    container.appendChild(lbl);\n  });\n  sel.addEventListener('change', () => {\n    Array.from(container.querySelectorAll('input[type=\"checkbox\"]')).forEach(cb => {\n      const opt = Array.from(sel.options).find(opt => opt.value === cb.value);\n      if (opt) syncOption(opt, opt.selected);\n      syncCheckbox(cb, !!opt && opt.selected);\n    });\n  });\n  container.appendChild(sel);\n  return { container, select: sel };\n}\n\nfunction resolveFilterDisplayInfo(type, size = DEFAULT_FILTER_SIZE) {\n  switch (type) {\n    case 'Diopter':\n      return { label: 'Schneider CF DIOPTER FULL GEN2', gearName: 'Schneider CF DIOPTER FULL GEN2' };\n    case 'Clear':\n      return { label: 'Clear Filter', gearName: 'Clear Filter' };\n    case 'IRND':\n      return { label: 'IRND Filter', gearName: 'IRND Filter' };\n    case 'Pol':\n      return { label: 'Pol Filter', gearName: 'Pol Filter' };\n    case 'Rota-Pol': {\n      if (size === '6x6') {\n        return {\n          label: 'ARRI Rota Pola Filter Frame (6x6)',\n          gearName: 'ARRI Rota Pola Filter Frame (6x6)'\n        };\n      }\n      if (size === '95mm') {\n        return {\n          label: 'Tilta 95mm Polarizer Filter for Tilta Mirage',\n          gearName: 'Tilta 95mm Polarizer Filter for Tilta Mirage'\n        };\n      }\n      return {\n        label: 'ARRI Rota Pola Filter Frame',\n        gearName: 'ARRI Rota Pola Filter Frame'\n      };\n    }\n    case 'ND Grad HE':\n      return { label: 'ND Grad HE Filter', gearName: 'ND Grad HE Filter' };\n    case 'ND Grad SE':\n      return { label: 'ND Grad SE Filter', gearName: 'ND Grad SE Filter' };\n    default:\n      return { label: `${type} Filter Set`, gearName: `${type} Filter Set` };\n  }\n}\n\nfunction buildFilterGearEntries(filters = []) {\n  const entries = [];\n  filters.forEach(({ type, size = DEFAULT_FILTER_SIZE, values }) => {\n    if (!type) return;\n    const sizeValue = size || DEFAULT_FILTER_SIZE;\n    const idBase = `filter-${filterId(type)}`;\n    switch (type) {\n      case 'Diopter': {\n        entries.push({\n          id: `${idBase}-frame`,\n          gearName: 'ARRI Diopter Frame 138mm',\n          label: 'ARRI Diopter Frame 138mm',\n          type: '',\n          size: '',\n          values: []\n        });\n        const diopterValues = values == null\n          ? (getFilterValueConfig(type).defaults || []).slice()\n          : (Array.isArray(values) ? values.slice() : []);\n        entries.push({\n          id: `${idBase}-set`,\n          gearName: 'Schneider CF DIOPTER FULL GEN2',\n          label: 'Schneider CF DIOPTER FULL GEN2',\n          type,\n          size: '',\n          values: diopterValues\n        });\n        break;\n      }\n      case 'Clear': {\n        const { label, gearName } = resolveFilterDisplayInfo(type, sizeValue);\n        entries.push({\n          id: idBase,\n          gearName,\n          label,\n          type,\n          size: sizeValue,\n          values: []\n        });\n        break;\n      }\n      case 'Pol': {\n        const { label, gearName } = resolveFilterDisplayInfo(type, sizeValue);\n        entries.push({\n          id: idBase,\n          gearName,\n          label,\n          type,\n          size: sizeValue,\n          values: []\n        });\n        break;\n      }\n      case 'Rota-Pol': {\n        const { label, gearName } = resolveFilterDisplayInfo(type, sizeValue);\n        const displaySize = label.includes(sizeValue) ? '' : sizeValue;\n        entries.push({\n          id: idBase,\n          gearName,\n          label,\n          type,\n          size: displaySize,\n          values: []\n        });\n        break;\n      }\n      case 'ND Grad HE':\n      case 'ND Grad SE': {\n        const { label, gearName } = resolveFilterDisplayInfo(type, sizeValue);\n        const gradValues = values == null\n          ? (getFilterValueConfig(type).defaults || []).slice()\n          : (Array.isArray(values) ? values.slice() : []);\n        entries.push({\n          id: idBase,\n          gearName,\n          label,\n          type,\n          size: sizeValue,\n          values: gradValues\n        });\n        break;\n      }\n      default: {\n        const { label, gearName } = resolveFilterDisplayInfo(type, sizeValue);\n        const filterValues = values == null\n          ? (getFilterValueConfig(type).defaults || []).slice()\n          : (Array.isArray(values) ? values.slice() : []);\n        entries.push({\n          id: idBase,\n          gearName,\n          label,\n          type,\n          size: sizeValue,\n          values: filterValues\n        });\n      }\n    }\n  });\n  return entries;\n}\n\nfunction formatFilterEntryText(entry) {\n  const details = [];\n  if (entry.size) details.push(entry.size);\n  if (entry.values && entry.values.length) details.push(entry.values.join(', '));\n  const suffix = details.length ? ` (${details.join(' \u2022 ')})` : '';\n  return `1x ${entry.label}${suffix}`;\n}\n\nfunction updateGearListFilterEntries(entries = []) {\n  if (!gearListOutput) return;\n  const entryMap = new Map(entries.map(entry => [entry.id, entry]));\n  gearListOutput.querySelectorAll('[data-filter-entry]').forEach(span => {\n    const entryId = span.getAttribute('data-filter-entry');\n    if (!entryId) return;\n    const entry = entryMap.get(entryId);\n    if (!entry) return;\n    span.textContent = formatFilterEntryText(entry);\n    span.setAttribute('data-gear-name', entry.gearName);\n    span.setAttribute('data-filter-label', entry.label);\n    if (entry.type) {\n      span.setAttribute('data-filter-type', entry.type);\n    } else {\n      span.removeAttribute('data-filter-type');\n    }\n  });\n}\n\nfunction getGearListFilterDetailsContainer() {\n  return gearListOutput ? gearListOutput.querySelector('#gearListFilterDetails') : null;\n}\n\nfunction filterTypeNeedsValueSelect(type) {\n  return type === 'Diopter'\n    || type === 'IRND'\n    || type === 'ND Grad HE'\n    || type === 'ND Grad SE'\n    || (type !== 'Clear' && type !== 'Pol' && type !== 'Rota-Pol');\n}\n\nfunction createFilterStorageValueSelect(type, selected) {\n  const select = document.createElement('select');\n  select.id = `filter-values-${filterId(type)}`;\n  select.multiple = true;\n  select.setAttribute('multiple', '');\n  select.hidden = true;\n  select.setAttribute('aria-hidden', 'true');\n  const { opts, defaults = [] } = getFilterValueConfig(type);\n  const chosen = Array.isArray(selected) ? selected.slice() : defaults.slice();\n  opts.forEach(value => {\n    const opt = document.createElement('option');\n    opt.value = value;\n    opt.textContent = value;\n    if (chosen.includes(value)) {\n      opt.selected = true;\n      opt.setAttribute('selected', '');\n    }\n    select.appendChild(opt);\n  });\n  return select;\n}\n\nfunction renderFilterDetailsStorage(details) {\n  if (!filterDetailsStorage) return;\n  filterDetailsStorage.innerHTML = '';\n  if (!details.length) {\n    filterDetailsStorage.hidden = true;\n    return;\n  }\n  filterDetailsStorage.hidden = true;\n  details.forEach(detail => {\n    const { type, size, values, needsSize, needsValues } = detail;\n    if (needsSize) {\n      const sizeSelect = createFilterSizeSelect(type, size);\n      sizeSelect.hidden = true;\n      sizeSelect.setAttribute('aria-hidden', 'true');\n      sizeSelect.addEventListener('change', handleFilterDetailChange);\n      filterDetailsStorage.appendChild(sizeSelect);\n    }\n    if (needsValues) {\n      const valuesSelect = createFilterStorageValueSelect(type, values);\n      valuesSelect.addEventListener('change', handleFilterDetailChange);\n      filterDetailsStorage.appendChild(valuesSelect);\n    }\n  });\n}\n\nfunction renderGearListFilterDetails(details) {\n  const container = getGearListFilterDetailsContainer();\n  if (!container) return;\n  container.innerHTML = '';\n  if (!details.length) {\n    container.classList.add('hidden');\n    return;\n  }\n  container.classList.remove('hidden');\n  details.forEach(detail => {\n    const { type, label, size, values, needsSize, needsValues } = detail;\n    const row = document.createElement('div');\n    row.className = 'filter-detail';\n    const heading = document.createElement('div');\n    heading.className = 'filter-detail-label';\n    const displaySize = size && label && label.includes(size) ? '' : size;\n    const displayValues = Array.isArray(values) ? values : undefined;\n    if (label) {\n      heading.textContent = formatFilterEntryText({\n        label,\n        size: displaySize,\n        values: displayValues\n      });\n    } else {\n      heading.textContent = '';\n    }\n    row.appendChild(heading);\n    const controls = document.createElement('div');\n    controls.className = 'filter-detail-controls';\n    if (needsSize) {\n      const sizeLabel = document.createElement('label');\n      sizeLabel.className = 'filter-detail-size';\n      const sizeText = document.createElement('span');\n      sizeText.className = 'filter-detail-sublabel';\n      sizeText.textContent = 'Size';\n      const sizeWrapper = document.createElement('span');\n      sizeWrapper.className = 'select-wrapper';\n      const sizeSelect = createFilterSizeSelect(type, size, { includeId: false });\n      sizeSelect.setAttribute('data-storage-id', `filter-size-${filterId(type)}`);\n      sizeSelect.addEventListener('change', () => {\n        const storageId = sizeSelect.getAttribute('data-storage-id');\n        if (!storageId) return;\n        syncGearListFilterSize(storageId, sizeSelect.value);\n      });\n      sizeWrapper.appendChild(sizeSelect);\n      sizeLabel.append(sizeText, sizeWrapper);\n      controls.appendChild(sizeLabel);\n    }\n    if (needsValues) {\n      const valuesWrap = document.createElement('div');\n      valuesWrap.className = 'filter-detail-values';\n      const valueLabel = document.createElement('span');\n      valueLabel.className = 'filter-detail-sublabel';\n      valueLabel.textContent = 'Strengths';\n      const optionsWrap = document.createElement('span');\n      optionsWrap.className = 'filter-values-container';\n      optionsWrap.setAttribute('data-storage-values', `filter-values-${filterId(type)}`);\n      const storageValuesId = optionsWrap.getAttribute('data-storage-values');\n      const { opts, defaults = [] } = getFilterValueConfig(type);\n      const currentValues = values == null ? defaults : (Array.isArray(values) ? values : []);\n      opts.forEach(value => {\n        const lbl = document.createElement('label');\n        lbl.className = 'filter-value-option';\n        const cb = document.createElement('input');\n        cb.type = 'checkbox';\n        cb.value = value;\n        if (currentValues.includes(value)) {\n          cb.checked = true;\n          cb.setAttribute('checked', '');\n        }\n        cb.addEventListener('change', () => {\n          if (!storageValuesId) return;\n          syncGearListFilterValue(storageValuesId, value, cb.checked);\n        });\n        lbl.append(cb, document.createTextNode(value));\n        optionsWrap.appendChild(lbl);\n      });\n      valuesWrap.append(valueLabel, optionsWrap);\n      controls.appendChild(valuesWrap);\n    }\n    row.appendChild(controls);\n    container.appendChild(row);\n  });\n  adjustGearListSelectWidths(container);\n}\n\nfunction syncGearListFilterSize(storageId, value) {\n  const storageSelect = document.getElementById(storageId);\n  if (!storageSelect) return;\n  if (storageSelect.value !== value) {\n    storageSelect.value = value;\n  }\n  storageSelect.dispatchEvent(new Event('change'));\n}\n\nfunction syncGearListFilterValue(storageId, value, isSelected) {\n  const storageSelect = document.getElementById(storageId);\n  if (!storageSelect) return;\n  let changed = false;\n  Array.from(storageSelect.options).forEach(opt => {\n    if (opt.value !== value) return;\n    if (opt.selected !== isSelected) {\n      opt.selected = isSelected;\n      changed = true;\n      if (isSelected) {\n        opt.setAttribute('selected', '');\n      } else {\n        opt.removeAttribute('selected');\n      }\n    }\n  });\n  if (changed) {\n    storageSelect.dispatchEvent(new Event('change'));\n  }\n}\n\nfunction renderFilterDetails() {\n  if (!filterSelectElem) return;\n  const selected = Array.from(filterSelectElem.selectedOptions).map(o => o.value).filter(Boolean);\n  const existingSelections = collectFilterSelections();\n  const existingTokens = existingSelections\n    ? parseFilterTokens(existingSelections)\n    : (currentProjectInfo && currentProjectInfo.filter ? parseFilterTokens(currentProjectInfo.filter) : []);\n  const existingMap = new Map(existingTokens.map(token => [token.type, token]));\n  const details = selected.map(type => {\n    const prev = existingMap.get(type) || {};\n    const size = prev.size || DEFAULT_FILTER_SIZE;\n    const needsSize = type !== 'Diopter';\n    const needsValues = filterTypeNeedsValueSelect(type);\n    const { label } = resolveFilterDisplayInfo(type, size);\n    return {\n      type,\n      label,\n      size,\n      values: Array.isArray(prev.values) ? prev.values.slice() : [],\n      needsSize,\n      needsValues\n    };\n  });\n  renderFilterDetailsStorage(details);\n  renderGearListFilterDetails(details);\n  if (matteboxSelect) {\n    const needsSwing = selected.some(t => t === 'ND Grad HE' || t === 'ND Grad SE');\n    if (needsSwing) matteboxSelect.value = 'Swing Away';\n  }\n}\n\nfunction handleFilterDetailChange() {\n  if (!filterSelectElem) return;\n  const filterStr = collectFilterSelections();\n  const entries = buildFilterGearEntries(parseFilterTokens(filterStr));\n  updateGearListFilterEntries(entries);\n  if (gearListOutput) adjustGearListSelectWidths(gearListOutput);\n  saveCurrentSession();\n  saveCurrentGearList();\n  checkSetupChanged();\n  renderFilterDetails();\n}\n\nfunction collectFilterSelections() {\n  if (!filterSelectElem) return '';\n  const selected = Array.from(filterSelectElem.selectedOptions).map(o => o.value);\n  const existing = currentProjectInfo && currentProjectInfo.filter\n    ? parseFilterTokens(currentProjectInfo.filter)\n    : [];\n  const existingMap = Object.fromEntries(existing.map(t => [t.type, t]));\n  const tokens = selected.map(type => {\n    const sizeSel = document.getElementById(`filter-size-${filterId(type)}`);\n    const valSel = document.getElementById(`filter-values-${filterId(type)}`);\n    const prev = existingMap[type] || {};\n    const size = sizeSel ? sizeSel.value : (prev.size || DEFAULT_FILTER_SIZE);\n    let vals;\n    const needsValues = filterTypeNeedsValueSelect(type);\n    if (valSel) {\n      vals = Array.from(valSel.selectedOptions).map(o => o.value);\n    } else if (Array.isArray(prev.values) && prev.values.length) {\n      vals = prev.values.slice();\n    } else {\n      vals = [];\n    }\n    let valueSegment = '';\n    if (needsValues) {\n      valueSegment = vals.length ? `:${vals.join('|')}` : ':!';\n    }\n    return `${type}:${size}${valueSegment}`;\n  });\n  return tokens.join(',');\n}\n\nfunction parseFilterTokens(str) {\n  if (!str) return [];\n  return str.split(',').map(s => {\n    const parts = s.split(':').map(p => p.trim());\n    const type = parts[0];\n    const size = parts[1] || DEFAULT_FILTER_SIZE;\n    const vals = parts.length > 2 ? parts[2] : undefined;\n    let values;\n    if (vals === undefined) {\n      values = undefined;\n    } else if (vals === '' || vals === '!') {\n      values = [];\n    } else {\n      values = vals.split('|').map(v => v.trim()).filter(Boolean);\n    }\n    return { type, size, values };\n  }).filter(t => t.type);\n}\n\nfunction applyFilterSelectionsToGearList(info = currentProjectInfo) {\n  if (!gearListOutput) return;\n  const tokens = info && info.filter ? parseFilterTokens(info.filter) : [];\n  const entries = buildFilterGearEntries(tokens);\n  updateGearListFilterEntries(entries);\n  adjustGearListSelectWidths(gearListOutput);\n}\n\nfunction normalizeGearNameForComparison(name) {\n  if (!name) return '';\n  let normalized = String(name);\n  if (typeof normalized.normalize === 'function') {\n    normalized = normalized.normalize('NFD');\n  } else if (typeof String.prototype.normalize === 'function') {\n    normalized = String.prototype.normalize.call(normalized, 'NFD');\n  }\n  normalized = normalized.replace(/[\\u0300-\\u036f]/g, '');\n  normalized = normalized.replace(/\\bfuer\\b/gi, 'for');\n  normalized = normalized.replace(/\\bfur\\b/gi, 'for');\n  normalized = normalized.toLowerCase();\n  return normalized.replace(/[^a-z0-9]+/g, '');\n}\n\nfunction buildFilterSelectHtml(filters = [], precomputedEntries) {\n  const entries = Array.isArray(precomputedEntries)\n    ? precomputedEntries\n    : buildFilterGearEntries(filters);\n  const summaryHtml = entries.map(entry => {\n    const attrs = [\n      'class=\"gear-item\"',\n      `data-gear-name=\"${escapeHtml(entry.gearName)}\"`,\n      `data-filter-entry=\"${escapeHtml(entry.id)}\"`,\n      `data-filter-label=\"${escapeHtml(entry.label)}\"`\n    ];\n    if (entry.type) attrs.push(`data-filter-type=\"${escapeHtml(entry.type)}\"`);\n    const text = formatFilterEntryText(entry);\n    return `<span ${attrs.join(' ')}>${escapeHtml(text)}</span>`;\n  }).join('<br>');\n  const detailsContainer = entries.length\n    ? '<div id=\"gearListFilterDetails\" class=\"hidden\" aria-live=\"polite\"></div>'\n    : '';\n  const summaryContainer = summaryHtml\n    ? `<div class=\"gear-list-filter-summary\">${summaryHtml}</div>`\n    : '';\n  return [detailsContainer, summaryContainer].filter(Boolean).join('');\n}\n\nfunction collectFilterAccessories(filters = []) {\n  const items = [];\n  filters.forEach(({ type }) => {\n    switch (type) {\n      case 'ND Grad HE':\n      case 'ND Grad SE':\n        break;\n      default:\n        break;\n    }\n  });\n  return items;\n}\n\nfunction populateUserButtonDropdowns() {\n  const functions = [\n    'Toggle LUT',\n    'False Color',\n    'Peaking',\n    'Anamorphic Desqueeze',\n    'Surround View',\n    '1:1 Zoom',\n    'Playback',\n    'Record',\n    'Zoom',\n    'Frame Lines',\n    'Frame Grab'\n  ];\n  ['monitorUserButtons', 'cameraUserButtons', 'viewfinderUserButtons'].forEach(id => {\n    const sel = document.getElementById(id);\n    if (!sel) return;\n    functions.forEach(fn => {\n      const opt = document.createElement('option');\n      opt.value = fn;\n      opt.textContent = fn;\n      sel.appendChild(opt);\n    });\n    sel.size = functions.length;\n  });\n}\n\nif (document.readyState === \"loading\") {\n  document.addEventListener(\"DOMContentLoaded\", initApp);\n} else {\n  initApp();\n}\n\n// Export functions for testing in Node environment\nif (typeof module !== \"undefined\" && module.exports) {\n  module.exports = {\n    APP_VERSION,\n    closeSideMenu,\n    openSideMenu,\n    setupSideMenu,\n    setupResponsiveControls,\n    setLanguage,\n    updateCalculations,\n    setBatteryPlates,\n    getBatteryPlates,\n    setRecordingMedia,\n    getRecordingMedia,\n    applyDarkMode,\n    applyPinkMode,\n    applyHighContrast,\n    generatePrintableOverview,\n    generateGearListHtml,\n    ensureZoomRemoteSetup,\n    encodeSharedSetup,\n    decodeSharedSetup,\n    applySharedSetupFromUrl,\n    applySharedSetup,\n    updateBatteryPlateVisibility,\n    updateBatteryOptions,\n    renderSetupDiagram,\n    enableDiagramInteractions,\n    updateDiagramLegend,\n    cameraFizPort,\n    controllerCamPort,\n    controllerDistancePort,\n    detectBrand,\n    connectionLabel,\n    generateConnectorSummary,\n    exportDiagramSvg,\n    fixPowerInput,\n    ensureList,\n    normalizeVideoType,\n    normalizeFizConnectorType,\n    normalizeViewfinderType,\n    normalizePowerPortType,\n    getCurrentSetupKey,\n    renderFeedbackTable,\n    saveCurrentGearList,\n    getGearListSelectors,\n    applyGearListSelectors,\n    setSelectValue,\n    autoSaveCurrentSetup,\n    saveCurrentSession,\n    restoreSessionState,\n    displayGearAndRequirements,\n    deleteCurrentGearList,\n    ensureGearListActions,\n    bindGearListEasyrigListener,\n    populateSelect,\n    populateLensDropdown,\n    populateCameraPropertyDropdown,\n    populateRecordingResolutionDropdown,\n    populateSensorModeDropdown,\n    populateCodecDropdown,\n    updateRequiredScenariosSummary,\n    updateMonitoringConfigurationOptions,\n    updateViewfinderExtensionVisibility,\n    scenarioIcons,\n    collectProjectFormData,\n    populateProjectForm,\n    renderFilterDetails,\n    collectFilterSelections,\n    parseFilterTokens,\n    applyFilterSelectionsToGearList,\n    setCurrentProjectInfo,\n    getCurrentProjectInfo,\n    crewRoles,\n    formatFullBackupFilename,\n    computeGearListCount,\n    autoBackup,\n    createSettingsBackup,\n    captureStorageSnapshot,\n    sanitizeBackupPayload,\n    extractBackupSections,\n    searchKey,\n    searchTokens,\n    findBestSearchMatch,\n    runFeatureSearch,\n    __featureSearchInternals: {\n      featureMap,\n      deviceMap,\n      helpMap,\n      featureSearchEntries,\n      featureSearchDefaultOptions,\n      featureSearchInput: featureSearch,\n      featureListElement: featureList,\n      restoreFeatureSearchDefaults,\n      updateFeatureSearchSuggestions,\n    },\n    __customFontInternals: {\n      addFromData: (name, dataUrl, options) => addCustomFontFromData(name, dataUrl, options),\n      getEntries: () => Array.from(customFontEntries.values()),\n    },\n    __sharedImportInternals: {\n      getLastSharedSetupData: () => lastSharedSetupData,\n      setLastSharedSetupDataForTest: (value) => {\n        lastSharedSetupData = value;\n      },\n      getLastSharedAutoGearRules: () => lastSharedAutoGearRules,\n      setLastSharedAutoGearRulesForTest: (value) => {\n        lastSharedAutoGearRules = value;\n      },\n      isProjectPresetActive: () => sharedImportProjectPresetActive,\n      setProjectPresetActiveForTest: (value) => {\n        sharedImportProjectPresetActive = !!value;\n      },\n      getPreviousPresetId: () => sharedImportPreviousPresetId,\n      setPreviousPresetIdForTest: (value) => {\n        sharedImportPreviousPresetId = typeof value === 'string' ? value : '';\n      },\n      isPromptActive: () => sharedImportPromptActive,\n      setPromptActiveForTest: (value) => {\n        sharedImportPromptActive = !!value;\n      },\n      getPendingSharedLinkListener: () => pendingSharedLinkListener,\n      setPendingSharedLinkListenerForTest: (listener) => {\n        pendingSharedLinkListener = typeof listener === 'function' ? listener : null;\n      },\n    },\n    collectAutoGearCatalogNames,\n    buildDefaultVideoDistributionAutoGearRules,\n    applyAutoGearRulesToTableHtml,\n    exportAutoGearRules,\n    importAutoGearRulesFromData,\n    createAutoGearBackup,\n    restoreAutoGearBackup,\n    getAutoGearRules,\n    syncAutoGearRulesFromStorage,\n    parseDeviceDatabaseImport,\n    countDeviceDatabaseEntries,\n    sanitizeShareFilename,\n    ensureJsonExtension,\n    getDefaultShareFilename,\n    promptForSharedFilename,\n    downloadSharedProject,\n    confirmAutoGearSelection,\n    configureSharedImportOptions,\n    resolveSharedImportMode,\n    resetPlannerStateAfterFactoryReset,\n    __autoGearInternals: {\n      buildDefaultVideoDistributionAutoGearRules,\n      buildVideoDistributionAutoRules,\n      buildAutoGearRulesFromBaseInfo,\n      seedAutoGearRulesFromCurrentProject,\n      clearAutoGearDefaultsSeeded,\n    },\n  };\n}\n";
function __cineEnsureGlobalBindings() {
  var globalScope = typeof globalThis !== 'undefined' ? globalThis : typeof global !== 'undefined' ? global : this;
  var win = globalScope.window || globalScope;
  if (!globalScope.window) globalScope.window = win;
  if (!globalScope.self) globalScope.self = win;
  if (win && !win.self) win.self = win;
  var doc = globalScope.document || win && win.document || undefined;
  if (doc && !win.document) win.document = doc;
  if (!globalScope.document && doc) globalScope.document = doc;
  var nav = globalScope.navigator || win && win.navigator || undefined;
  if (nav && !win.navigator) win.navigator = nav;
  if (!globalScope.navigator && nav) globalScope.navigator = nav;
  var ls = globalScope.localStorage || win && win.localStorage || undefined;
  if (ls && !win.localStorage) win.localStorage = ls;
  if (!globalScope.localStorage && ls) globalScope.localStorage = ls;
  var ss = globalScope.sessionStorage || win && win.sessionStorage || undefined;
  if (ss && !win.sessionStorage) win.sessionStorage = ss;
  if (!globalScope.sessionStorage && ss) globalScope.sessionStorage = ss;
  var loc = globalScope.location || win && win.location || undefined;
  if (loc && !win.location) win.location = loc;
  if (!globalScope.location && loc) globalScope.location = loc;
  var cachesRef = globalScope.caches || win && win.caches || undefined;
  if (cachesRef && !win.caches) win.caches = cachesRef;
  if (!globalScope.caches && cachesRef) globalScope.caches = cachesRef;
  return {
    globalScope: globalScope,
    window: win
  };
}
function __cineEnsureMonolithLoaded() {
  var versionDefined = false;
  try {
    versionDefined = typeof APP_VERSION !== 'undefined';
  } catch (_unused) {
    versionDefined = false;
  }
  if (versionDefined) {
    return;
  }
  var _cineEnsureGlobalBin = __cineEnsureGlobalBindings(),
    globalScope = _cineEnsureGlobalBin.globalScope;
  var exportsTarget = typeof module !== "undefined" && module.exports ? module.exports : {};
  var moduleObj = typeof module !== "undefined" ? module : {
    exports: exportsTarget
  };
  var requireFn = typeof require === "function" ? require : function unavailable(name) {
    throw new Error("Cannot require module \"".concat(name, "\" in this environment."));
  };
  var factory = new Function('exports', 'require', 'module', '__filename', '__dirname', MONOLITH_SOURCE);
  factory(exportsTarget, requireFn, moduleObj, typeof __filename !== 'undefined' ? __filename : '', typeof __dirname !== 'undefined' ? __dirname : '');
  if (typeof module === "undefined") {
    globalScope.cinePowerPlanner = moduleObj.exports;
  }
}
__cineEnsureMonolithLoaded();