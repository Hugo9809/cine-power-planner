{"version":3,"mappings":"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,CAClB,uBACA,mBACA,2BACA,yBACA,+BAEF,6BAA8B,CAC5B,mCACA,6BACA,sCACA,yCACA,2CAEF,WAAY,CACV,cACA,cACA,eACA,iBACA,oBAEF,qBAAsB,CACpB,0BACA,wBACA,0BACA,iCACA,gCAEF,sBAAuB,CACrB,2BACA,6BACA,4BACA,sCACA,uBAEF,OAAQ,CAAC,SAAU,YAAa,WAAY,UAAW,WAAW,EAClE,kBAAmB,CACjB,qBACA,gBACA,mBACA,wBACA,qBAEF,aAAc,CACZ,gBACA,mBACA,iBACA,uBACA,mBAEF,oBAAqB,CACnB,uBACA,sBACA,mBACA,qBACA,mBAEF,0BAA2B,CACzB,+BACA,4BACA,6BACA,6BACA,uBAEF,SAAU,CAAC,WAAY,YAAa,YAAa,YAAa,WAAW,EACzE,OAAQ,CACN,SACA,sBACA,uBACA,uBACA,yBAEF,kBAAmB,CACjB,qBACA,kBACA,qBACA,wBACA,uBAEF,kBAAmB,CACjB,qBACA,qBACA,wBACA,4BACA,yBAEF,wBAAyB,CACvB,2BACA,2BACA,8BACA,kCACA,+BAEF,aAAc,CACZ,gBACA,eACA,iBACA,kBACA,iBAEF,mBAAoB,CAClB,+BACA,0BACA,oCACA,2CACA,yBAEF,kBAAmB,CACjB,sBACA,iBACA,+BACA,kCACA,gBAEF,sBAAuB,CACrB,0BACA,iBACA,+BACA,+BACA,gBAEF,gBAAiB,CACf,oBACA,YACA,oBACA,qBACA,qBAEF,WAAY,CACV,cACA,aACA,cACA,eACA,gBAEF,YAAa,CACX,eACA,cACA,mBACA,mBACA,qBAEF,eAAgB,CACd,kBACA,kBACA,mBACA,qBACA,oBAEF,WAAY,CACV,cACA,gBACA,cACA,kBACA,eAEF,QAAS,CACP,wBACA,yBACA,+BACA,2BACA,6BAEJ,EAEIC,GAAiC,CACnC,2BACA,0BACA,2BACA,wBACA,0BACA,8BACA,0BACF,EAEA,SAASC,GAA2BznB,EAAO,CACzC,OAAI,OAAOA,GAAU,SACZ,GAEFA,EAAM,OAAO,QAAQ,WAAY,EAAE,EAAE,MAC9C,CAEA,SAAS0nB,GAA8BC,EAA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","names":["baseDetectGlobalScope","FALLBACK_SCOPE","DETECT_CACHE","safeAssign","target","key","value","detectGlobalScope","detected","collectCandidateScopes","primary","extras","detect","seen","append","scope","detectFn","index","tryRequire","modulePath","resolveFromScopes","propertyName","options","settings","predicate","scoped","candidates","getCachedGlobalValue","factory","api","GLOBAL_SCOPE","globalScope","VALID_ICON_FONTS","keys","fonts","font","toCodePointChar","radix","codePoint","normalizeGlyphChar","char","trimmed","unicodeMatch","decoded","unicodeBraceMatch","hexEntityMatch","decimalEntityMatch","iconGlyph","defaultFont","requestedFont","normalizedFont","glyph","resolveIconGlyph","size","fontKey","className","ensureSvgHasAriaHidden","markup","applyIconGlyph","element","resolved","cls","iconMarkup","parts","finalClass","svg","fontAttr","formatSvgCoordinate","rounded","positionSvgMarkup","centerX","centerY","half","x","y","width","height","match","attrs","attrText","additions","STAR_ICON_SVG","ICON_GLYPHS","isObjectLike","freezeArray","array","cloneArray","clone","createPrimaryCache","getPrimaryCacheEntry","cache","entry","pushUnique","BASE_SCOPES","scopes","EMPTY_EXTRAS","SUPPORTS_WEAKMAP","sanitizeExtras","sanitized","computeCandidateScopes","extrasList","getExtrasCache","detectEntry","extrasEntry","getDetectEntry","collectInternal","cacheEntry","primaryEntry","computed","computedFallback","createCollector","getBaseScopes","DEFAULT_PENDING_QUEUE_KEY","fallbackDetectGlobalScope","installSafeConsoleGuards","targetScope","consoleRef","methods","originals","method","candidate","guarded","createScopeCollector","DEFAULT_EXTRAS_KEY","HELPER_COLLECTOR_CACHE","BASE_SCOPE_EXTRAS_CACHE","resolveExtrasForBaseScope","baseScope","resolveHelperCollector","extrasKey","collector","fallbackCollectCandidateScopes","resolvedBaseScope","pushScope","fallbackTryRequire","fallbackDefineHiddenProperty","name","fallbackEnsureQueue","queueKey","queue","BUILTIN_IMMUTABILITY","registryKey","isEthereumProviderCandidate","PRIMARY_SCOPE","inspectionError","ctorName","isNodeProcessReference","functionName","source","shouldBypassDeepFreeze","tag","fallbackResolveSeenTracker","tracked","fallbackFreezeDeep","tracker","descriptor","child","fallbackSafeWarn","message","detail","fallbackResolveModuleRegistry","fallbackQueueModuleRegistration","payload","createFallbackKernel","primaryScope","resolveArchitectureKernel","LOCAL_SCOPE","RESOLVED_KERNEL","ACTIVE_KERNEL","PENDING_QUEUE_KEY","collected","baseTryRequire","result","baseResolveModuleRegistry","required","cachedModuleRegistry","hasResolvedRegistry","getModuleRegistry","ensureQueue","queueModuleRegistration","baseRegisterOrQueueModule","registry","onError","error","baseFreezeDeep","baseSafeWarn","exposeGlobal","baseApi","moduleRegistry","ensureConsoleMethodsWritable","QUEUE_FLUSH_TIMER_KEY","moduleMap","metadataMap","registryReference","resolveImmutability","createFallbackImmutability","shouldBypass","freeze","FALLBACK_IMMUTABILITY","activeImmutability","getImmutability","freezeDeep","provider","normalizeName","normalizeConnections","entries","normalized","raw","register","moduleApi","normalizedName","existing","get","has","list","describe","meta","normalizeNameCollection","normalizeCategoryCollection","describeAll","normalizedNames","normalizedCategories","namesFilter","categoryFilter","snapshot","sourceNames","left","right","assertRegistered","names","missing","present","resetForTests","getTimerDescriptor","assignHidden","cancelPendingFlush","clearTimer","schedulePendingFlush","scheduleFromScope","clearFromScope","timerId","flushPendingRegistrations","pending","collectQueueScopes","preferredScope","readQueueFromScope","ensureQueueOnScope","resolveQueueDescriptor","queueRegistrationPayload","record","queueScope","createBlueprint","normalizedCategory","normalizedDescription","freezeByDefault","normalizedConnections","staticApi","metadata","cachedApi","instantiated","instantiateError","buildRegistrationOptions","overrides","base","instantiate","context","produced","invocationContext","frozenContext","registerBlueprint","resolvedRegistry","registrationOptions","deferOnError","targetRegistry","blueprint","VIDEO_OUTPUT_TYPES","NORMALIZED_FLAG_KEY","memoizeNormalization","fn","str","VIDEO_TYPE_PATTERNS","normalizeVideoType","_","needles","n","FIZ_CONNECTOR_MAP","createMapNormalizer","map","normalizeFizConnectorType","VIEWFINDER_TYPE_MAP","normalizeViewfinderType","POWER_PORT_TYPE_MAP","mapPowerPortOne","normalizePowerPortType","type","toArray","val","piece","ensureList","defaults","item","fixPowerInput","dev","input","normalizeEntry","it","pType","tType","rest","typeField","applyFixPowerInput","collection","hasNormalizedDevicesMarker","bundle","markDevicesNormalized","unifyDevices","devicesData","cam","m","mount","notes","vo","count","norm","parsedCount","num","fc","vf","lm","idx","arr","o","lens","normalizeMountEntry","status","existingMountOptions","normalizedOptions","pushNormalizedEntry","mountType","dedupedOptions","opt","mountState","safeMountOptions","mountOptions","primaryType","fizGroups","c","p","normalizeDevicesForPersistence","loggingResolveStructuredClone","loggingJsonDeepClone","LOGGING_DEEP_CLONE","structuredCloneImpl","fallbackLoadModuleEnvironment","fallbackLoadEnvironmentBridge","fallbackResolveModuleGlobals","MODULE_ENV","ENV_BRIDGE","MODULE_GLOBALS","structuredCloneCandidates","addCandidate","cachedStructuredCloneCandidate","tryStructuredCloneValue","cloned","resolveModuleRegistry","bridged","cineModules","MODULE_REGISTRY","shared","provided","registerOrQueueModule","registered","ctor","visited","define_process_env_default","freezeError","safeWarn","CONSOLE_METHODS","CONSOLE_PROXY_FLAG","ORIGINAL_CONSOLE_FUNCTIONS","store","consoleProxyInstalled","consoleProxyInstallationAttempted","consoleProxyInstallationFailed","lastConsoleCaptureState","consoleProxyWarningIssued","consoleProxyGuardDepth","informModuleGlobals","LOG_LEVEL_MAP","LOG_LEVELS","LEVEL_COUNTER_KEYS","createLevelCounters","counters","resetLevelCounters","resolveLevelKey","level","getCounterValue","applyLevelCounterDelta","delta","next","applyLevelCounterDeltaForEntries","summariseEntriesByLevel","summary","accumulateLevelSummary","increment","current","cloneLevelSummary","freezeLevelSummary","HISTORY_MIN_LIMIT","HISTORY_ABSOLUTE_MIN_LIMIT","HISTORY_MAX_LIMIT","HISTORY_STORAGE_KEY","CONFIG_STORAGE_KEY","ERROR_EVENT_FLAG","DEFAULT_CONFIG_VALUES","DEFAULT_CONFIG","SERVICE_WORKER_LOG_CHANNEL","SERVICE_WORKER_LOG_ENTRY_TYPE","SERVICE_WORKER_LOG_STATE_REQUEST","SERVICE_WORKER_LOG_STATE_RESPONSE","SERVICE_WORKER_LOG_REQUEST_TIMEOUT","SERVICE_WORKER_LOG_POLL_INTERVAL","SERVICE_WORKER_LOG_HISTORY_LIMIT","cloneDefaultConfig","activeConfig","logHistory","logSubscribers","configSubscribers","attachedErrorTargets","runtimeEntryCount","emittedLevelCounters","retainedLevelCounters","droppedLevelCounters","totalEntriesDropped","lastHistoryDrop","serviceWorkerBridgeState","normalizeLevel","fallbackLevel","fallback","getLevelPriority","booleanFromValue","clampHistoryLimit","effectiveMinimum","absolute","parsed","coerceMessage","sanitizeForLog","depth","nextDepth","valueType","errorOutput","collectedErrors","truncatedErrors","appendErrorDetail","rawErrors","iterator","symbolIterator","maxPreview","length","preview","previewLength","mapCtor","mapValue","mapKey","setCtor","items","urlParamsCtor","params","truncated","pair","len","output","maxKeys","symbols","symbolLength","symbolKey","symbolName","structuredCloneResult","normaliseStackTrace","stackValue","maxLength","charTruncated","limitedStack","rawLines","frameLimit","frames","frameTruncated","line","normaliseOriginSnapshot","origin","stackSummary","frame","getSessionStorage","storage","clearStoredHistory","persistConfigSafe","persistHistorySafe","getEffectiveHistoryLimit","recordHistoryDrop","removedEntries","limit","removedSummary","oldestEntry","newestEntry","dropTimestamp","dropIsoTimestamp","enforceHistoryLimit","overflow","shouldRecord","shouldOutputToConsole","getLevelState","normalizedLevel","consoleEnabled","historyEnabled","isLevelEnabled","state","checkConsole","checkHistory","createEntryId","timestamp","pushEntryToHistory","appendEntry","notifyLogSubscribers","listeners","listener","getHistorySnapshot","effectiveLimit","start","slice","notifyConfigSubscribers","arrayFromArrayLike","safeArrayPush","getConsoleLevelForMethod","getStoredConsoleFunction","stored","invokeConsoleMethod","args","receiver","finalArgs","recordConsoleMessage","rawArgs","messageParts","sanitizedArguments","detailPayload","errorEntries","sanitizedArray","rawValue","sanitizedValue","isErrorInstance","hasSanitizedErrorShape","valueClone","coercedMessage","rawType","contextMeta","metaKeys","errorIndices","errorEntry","primaryError","forceStackCapture","contextOptions","logInternal","installConsoleProxies","installedAny","proxy","argsArray","firstArg","recordError","removeConsoleProxies","restoredAny","original","syncConsoleCaptureState","buildConsoleCaptureDetail","isConsoleCaptureActive","overrideKeys","enableConsoleCapture","setConfig","disableConsoleCapture","shouldCaptureOrigin","override","captureLogOrigin","stackSource","detailStack","stackMessage","captureError","isoTimestamp","captureContext","namespace","sanitizedDetail","internalOptions","methodName","prefixParts","consoleArgs","debug","info","warn","getConfigSnapshot","getHistory","cloneLastDropSnapshot","getStats","clearHistory","subscribe","subscribeConfig","mergeMeta","baseMeta","merged","baseKeys","createLogger","normalizedNamespace","logWithNamespace","mergedMeta","optionOverrides","markEventHandled","event","flag","handleGlobalError","handleUnhandledRejection","markTargetAttached","attachGlobalErrorListeners","applyConfig","changed","captureChanged","limitChanged","consoleCaptureChanged","nextPersistSession","nextLevel","nextHistoryLevel","nextLimit","nextConsole","nextCapture","nextConsoleCapture","nextStackTraces","previousCapture","previousConsoleCapture","resolveConfigPresetFromScopes","scopeIndex","keyIndex","applyConfigFromStorage","applyConfigFromQuery","search","updates","hasUpdates","assignUpdate","part","eqIndex","normaliseStoredEntry","normalizedMessage","normalizedId","getGlobalNavigator","getNavigatorServiceWorker","nav","markServiceWorkerEntrySeen","id","mergeServiceWorkerEntryMeta","snapshotMeta","channel","importServiceWorkerLogEntries","rawEntry","entryId","finalizeServiceWorkerLogRequest","requestId","scheduleServiceWorkerLogPoll","requestServiceWorkerLogSnapshot","ensureServiceWorkerBroadcastChannel","handleServiceWorkerLogMessage","data","reason","serviceWorker","closeMessageChannel","readyPromise","registration","worker","controller","targetWorker","settled","finalize","finalizeWithPoll","handleResponse","handleChannelError","postWithoutChannel","setupServiceWorkerLogBridge","loadPersistedHistory","initialiseConfig","preset","loggingAPI","baseConsole","consoleDescriptor","requestedMethods","unique","i","methodNames","property","resolveModuleBase","MODULE_BASE","push","resolveLoggingFromScope","logging","resolveLogging","cloneMeta","resolveConsoleMethod","fallbackWarningIssued","createConsoleFallbackLogger","consoleMethod","resolveLogger","logger","resolverApi","queueError","CONTACTS_STORAGE_KEY","resolveLocalStorage","generateContactId","sanitizeContactValue","primitive","stringified","normalizeContactEntry","role","phone","email","website","avatar","createdAt","updatedAt","sortContacts","a","b","nameA","nameB","loadStoredContacts","storageKey","saveContactsToStorage","contacts","exposedViaModuleBase","StorageInterface","IndexedDBAdapter","e","compressed","decompressed","LZString","set","del","clear","UserContext","uuid","deviceId","userContext","SYNC_METADATA_VERSION","SyncStatus","LockStatus","nowISO","generateDocId","prefix","random","createSyncMetadata","identity","now","updateSyncMetadata","existingMeta","markAsSynced","serverTimestamp","markAsConflict","errorMessage","wrapWithMetadata","unwrapMetadata","wrapped","hasMetadata","LOCK_CHANNEL_NAME","HEARTBEAT_INTERVAL_MS","LOCK_TIMEOUT_MS","LOCK_STORAGE_PREFIX","LockEvent","ProjectLockService","err","projectId","existingLock","lock","callback","intervalId","oldLock","projectLockService","PROJECT_KEY_PREFIX","StorageRepository","newDriver","scopedKey","deletionPromises","k","allKeys","projectKey","projectData","lockInfo","__vitePreload","dataVault","DataVault$1","projects","projectIndexKeys","prefixedKeys","rawKey","migrated","prefixedKey","migrationError","storageRepo","LocalStorageAdapter","MIGRATION_FLAG_KEY","StorageMigrationService","keysToMigrate","importError","itemError","setSafely","adapter","UserContext$1","migrationService","OWN_GEAR_KEY","GearRepository","query","q","gearRepo","DataVault","filename","safeFilename","writable","files","handle","text","file","projectMemoryCache","isProjectCacheHydrated","hydrateProjectCache","projectKeys","monolithKey","monolithValue","shardKeys","rawIndex","PROJECT_INDEX_KEY","normalizedIndex","normalizeProjectIndexForCache","projectIndexCache","AUTO_GEAR_MONITOR_DEFAULTS_STORAGE_KEY","autoGearMonitorDefaultsCache","AUTO_GEAR_ACTIVE_PRESET_STORAGE_KEY","autoGearActivePresetIdCache","AUTO_GEAR_AUTO_PRESET_STORAGE_KEY","autoGearAutoPresetIdCache","AUTO_GEAR_BACKUPS_STORAGE_KEY","autoGearBackupsCache","AUTO_GEAR_BACKUP_RETENTION_STORAGE_KEY","autoGearBackupRetentionCache","AUTO_GEAR_BACKUP_VISIBILITY_STORAGE_KEY","autoGearBackupVisibilityCache","CUSTOM_FONT_STORAGE_KEY_DEFAULT","customFontsCache","CUSTOM_LOGO_STORAGE_KEY","customLogoCache","CAMERA_COLOR_STORAGE_KEY","cameraColorsCache","PRINT_PREFERENCES_STORAGE_KEY","printPreferencesCache","contactsCache","OWN_GEAR_STORAGE_KEY","ownGearCache","USER_PROFILE_STORAGE_KEY","userProfileCache","FAVORITES_STORAGE_KEY","favoritesCache","TEMPERATURE_UNIT_STORAGE_KEY_NAME","temperatureUnitCache","FOCUS_SCALE_STORAGE_KEY_NAME","focusScaleCache","getMountVoltageStorageKeyName","mountVoltagesCache","FULL_BACKUP_HISTORY_STORAGE_KEY","fullBackupHistoryCache","monoErr","shardPromises","shardErr","FORCE_STORAGE_REINITIALIZE","FACTORY_RESET_LOCK_KEY","LIFECYCLE_CHANNEL_NAME","lifecycleChannel","isJestWorker","lockError","lockValue","invalidateProjectReadCache","scopeList","justReset","s","shouldHydrateProjectCache","isNative","prefixMigrationOutcome","migrateProjectKeyPrefixOnStartup","updateProjectIndex","getSafeLocalStorage","indexRefreshError","closeStorageLifecycle","storageManualDeepClone","references","referenceStore","clonedDate","timeValue","storageJsonDeepClone","storageResolveStructuredClone","storageCreateResilientDeepClone","STORAGE_DEEP_CLONE","knownSessionStorages","registerKnownSessionStorage","resolveSessionStorageFromScope","resolveLocalStorageFromScope","collectLocalStorageCandidates","isFactoryResetActive","readFlag","fallbackScopes","DEVICE_STORAGE_KEY","DEVICE_STORAGE_KEY_VARIANTS","SETUP_STORAGE_KEY","SESSION_STATE_KEY","FEEDBACK_STORAGE_KEY","PROJECT_STORAGE_KEY","PROJECT_STORAGE_REV_KEY","DOCUMENTATION_TRACKER_STORAGE_KEY","DEVICE_SCHEMA_CACHE_KEY","LEGACY_SCHEMA_CACHE_KEY","MOUNT_VOLTAGE_STORAGE_KEY_FALLBACK","MOUNT_VOLTAGE_STORAGE_KEY_SYMBOL","PROJECT_STORAGE_READ_CACHE","STORAGE_CACHE_SYMBOL","PROJECT_SHARD_PREFIX","STORAGE_STATE_CACHE_WEAKMAP","CONTACTS_MODULE_API","CONTACTS_MODULE_RESOLUTION_ATTEMPTED","COMPRESSION_STRATEGY_CACHE","COMPRESSION_STRATEGY_CACHE_KEYS","COMPRESSION_STRATEGY_CACHE_LIMIT","COMPRESSION_CANDIDATE_CACHE_MISS","STORAGE_COMPRESSION_CANDIDATE_CACHE","createCompressionCandidateCache","MIGRATION_BACKUP_COMPRESSION_CANDIDATE_CACHE","AUTO_BACKUP_COMPRESSION_CACHE","AUTO_BACKUP_COMPRESSION_CACHE_KEYS","AUTO_BACKUP_COMPRESSION_CACHE_LIMIT","cloneAutoBackupCompressionValue","readAutoBackupCompressionCache","signature","cached","writeAutoBackupCompressionCache","compression","isCompressedAutoBackupSnapshotPayload","existingIndex","oldest","resetAutoBackupCompressionCache","COMPRESSION_WARNING_LIMIT","COMPRESSION_WARNING_BATCH_SIZE","COMPRESSION_LOG_SUMMARY_WINDOW_MS","compressionWarningRegistry","storageLoggingResolverCache","storageLoggerCache","storageLoggerResolutionAttempted","consoleHelpersImport","consoleHelpersImport.ensureConsoleMethodsWritable","ACTIVE_PROJECT_COMPRESSION_HOLD_KEY","ACTIVE_PROJECT_COMPRESSION_HOLD_ENABLED","collectStorageLoggingScopes","enqueue","resolveStorageLoggingResolver","loggingResolverImport","resolver","resolveStorageLogger","sanitizeStorageError","getActiveStorageType","safeLocalStorageInfo","logStorageEvent","consoleCallback","handled","resolvedMeta","metaIndex","metaKey","getCompressionLogTimestamp","logCompressionSavingsEvent","kind","identifier","savings","percent","entryKey","keyLabel","consoleLogger","shouldSummarize","getCompressionLogSnapshot","getCompressionStrategyCacheKey","variants","segments","variant","compressName","decompressName","readCompressionStrategyCache","cacheKey","lzReference","pruneCompressionStrategyCache","oldestKey","writeCompressionStrategyCache","strategies","computeStorageCompressionWrapperBaseLength","skeleton","STORAGE_COMPRESSION_FLAG_KEY","STORAGE_COMPRESSION_VERSION","STORAGE_COMPRESSION_ALGORITHM","STORAGE_COMPRESSION_NAMESPACE","serialized","emptyLiteralLength","numericLimit","cloneCompressionCandidate","touchCompressionCandidateCacheKey","readCompressionCandidateCacheEntry","writeCompressionCandidateCacheEntry","getStorageStateCacheMap","createIfMissing","assigned","getCachedStorageEntry","clearCachedStorageEntry","cloneValueForCache","cloneCachedEntryValue","cloneLookupMap","copy","cloneProjectLookupSnapshotForReturn","lookup","captureProjectLookupSnapshotForCache","freezeProjectSnapshotProjects","isPlainObject","frozen","setProjectReadCacheSnapshot","getProjectReadCacheClone","safeStorage","currentRaw","forMutation","normalizeProjectStorageRevisionValue","getProjectStorageRevisionKeyName","loadProjectStorageRevision","storageOverride","loadJSONFromStorage","bumpProjectStorageRevision","saveJSONToStorage","cacheStorageValue","normalizedValue","cachedValue","tryGetCachedStorageValue","primaryRaw","rawStored","readGlobalStringValue","directValue","symbolValue","exposeGlobalStringValue","symbolAssigned","resolveMountVoltageStorageKeyName","exposed","MOUNT_VOLTAGE_STORAGE_KEY_NAME","refreshMountVoltageStorageKeyName","RAW_STORAGE_BACKUP_KEYS","getStorageKeyVariants","getMountVoltageStorageBackupKeyName","ensureCustomFontStorageKeyName","existingName","getCustomFontStorageKeyName","TEMPERATURE_UNIT_STORAGE_KEY_DEFAULT","FOCUS_SCALE_STORAGE_KEY_DEFAULT","resolveTemperatureUnitStorageKey","assignError","defineError","AUTO_GEAR_RULES_STORAGE_KEY","AUTO_GEAR_SEEDED_STORAGE_KEY","AUTO_GEAR_PRESETS_STORAGE_KEY","STORAGE_AUTO_BACKUP_NAME_PREFIX","STORAGE_AUTO_BACKUP_DELETION_PREFIX","STORAGE_AUTO_BACKUP_RENAMED_FLAG","AUTO_BACKUP_METADATA_PROPERTY","AUTO_BACKUP_SNAPSHOT_PROPERTY","AUTO_BACKUP_SNAPSHOT_VERSION","AUTO_BACKUP_PAYLOAD_COMPRESSION_FLAG","AUTO_BACKUP_CYCLE_PLACEHOLDER","projectActivityTimestamps","forcedCompressedProjectKeys","AUTO_BACKUP_PAYLOAD_COMPRESSION_MIN_LENGTH","isAutoBackupStorageKey","MAX_AUTO_BACKUPS","MAX_DELETION_BACKUPS","AUTO_GEAR_BACKUP_RETENTION_DEFAULT_VALUE","AUTO_GEAR_BACKUP_RETENTION_MIN","AUTO_GEAR_BACKUP_RETENTION_MAX","ensureGlobalAutoGearBackupDefaults","cloneAutoBackupMetadata","cloneAutoBackupValue","defineAutoBackupMetadata","clonedMetadata","getAutoBackupMetadata","copyAutoBackupMetadata","opts","cloneState","handleCircularClone","compute","cloneAutoBackupValueWithLegacyNormalization","normalizeLegacyLongGopStructure","prepareAutoBackupSnapshotPayloadForStorage","contextName","shouldReport","computedSignature","createStableValueSignature","signatureError","existingSignature","reusedPayload","reusedCompression","decodedExisting","decodeCompressedJsonStorageValue","resolvedSignature","createCompressedJsonStorageCandidate","compressedPayload","compressionInfo","label","restoreAutoBackupSnapshotPayload","rawPayload","details","deriveAutoBackupCreatedAt","fallbackDate","parseAutoBackupKey","sourceDate","detectCyclicAutoBackupReference","path","maxSteps","steps","currentName","currentMetadata","baseName","baseEntry","promoteAutoBackupMetadataToFull","expandAutoBackupEntries","container","isAutoBackupKey","filter","shouldIncludeEntry","include","resolve","stack","restored","restoreCompressedProjectEntry","clonedValue","fallbackPayload","payloadKeys","payloadSignature","payloadInfo","cycleSignatureError","cyclePayloadError","snapshotType","baseValue","payloadError","changedKeys","removedKeys","expanded","payloadSignatureError","computeAutoBackupDiff","currentValue","currentKeys","hasCurrent","hasBase","currentEntry","currentSignature","baseSignature","serializeAutoBackupEntries","entryNames","latestAutoBackupNames","groups","parsedKey","groupKey","disableCompressionForName","prepared","normalizedBase","diff","SETUP_STORAGE_KEY_VARIANTS","getDeviceStorageKeyVariants","isDeviceStorageKeyVariant","shouldAllowCriticalSweepPrimaryInspection","inspectSetupStorageForQuotaRecovery","skipKeysSet","skipSet","STORAGE_BACKUP_SUFFIX","MAX_SAVE_ATTEMPTS","MAX_QUOTA_RECOVERY_STEPS","STORAGE_MIGRATION_BACKUP_SUFFIX","CRITICAL_BACKUP_KEY_PROVIDERS","readAllProjectsFromStorage","createCriticalStorageEntry","backupKey","resolvedBackupKey","gatherCriticalStorageEntries","pushEntry","expectedBaseBackupKey","variantKey","variantEntry","storageId","providerError","providerDetail","lastCriticalStorageGuardResult","registerCriticalStorageGuardResult","ensureCriticalStorageBackups","guardError","guardDetail","targetStorage","primaryValue","readError","primaryReadDetail","backupValue","backupReadError","backupReadDetail","stringPrimaryValue","tryStoreBackup","mirrorDetail","shouldAttemptCompression","candidateValue","writeResult","isQuotaExceededError","compressedCandidate","skipKeys","shouldInspectPrimaryDuringSweep","sweepResult","attemptStorageCompressionSweep","alertStorageError","ensuredDetail","mirroredDetails","errorDetail","getLastCriticalStorageGuardResult","MAX_MIGRATION_BACKUP_CLEANUP_STEPS","MIGRATION_BACKUP_COMPRESSION_ALGORITHM","MIGRATION_BACKUP_COMPRESSION_ENCODING","MIGRATION_BACKUP_COMPRESSION_VARIANTS","LEGACY_STORAGE_COMPRESSION_ALGORITHM","STORAGE_COMPRESSION_VARIANTS","STORAGE_COMPRESSION_ALGORITHM_LITERAL","STORAGE_COMPRESSION_NAMESPACE_LITERAL","STORAGE_COMPRESSION_WRAPPER_BASE_LENGTH","storageCompressionPatchedStorages","STORAGE_COMPRESSION_SWEEP_LIMIT","STORAGE_COMPRESSION_SWEEP_MIN_SAVINGS","STORAGE_RAW_GET_ITEM_PROPERTY","STORAGE_PROACTIVE_COMPRESSION_MIN_LENGTH","STORAGE_PROACTIVE_COMPRESSION_MIN_SAVINGS","STORAGE_PROACTIVE_COMPRESSION_MIN_RATIO","getAvailableLZStringCompressionStrategies","cachedStrategies","available","compressFn","decompressFn","variantLiteral","variantLiteralLength","tryDecompressWithStrategies","preferredVariant","contextLabel","attempts","preferred","j","lastError","strategy","canUseMigrationBackupCompression","tryCreateCompressedMigrationBackupCandidate","serializedPayload","bestCandidate","compressionError","serializedCompressedPayload","serializationError","parseMigrationBackupMetadata","MIGRATION_BACKUP_LEGACY_CREATED_AT_KEYS","canUseJsonValueCompression","baseWrapperLength","best","bestSerialized","bestCompressedLiteral","bestVariantLiteral","originalLengthDigits","compressedLiteral","compressedLiteralError","candidateSerialized","candidateLength","compressedLengthDigits","legacyWrapper","finalVariantLiteral","serializedWrapper","parseError","markProjectActivity","recordTime","normalizeProjectStorageKey","markProjectCollectionActivity","removeProjectActivity","normalizeForcedProjectCompressionKey","isForcedProjectCompressionLocked","ensureProjectEntryUncompressed","ensureProjectEntriesUncompressed","registerActiveSetupStorageSkipKeys","keysToSkip","registerProtectedCompressionSkipKeys","keysToProtect","variantIndex","maybeDecompressStoredString","isSessionStorageInstance","minSavings","minSavingsThreshold","total","upperLimit","compressedCount","freedCharacters","decodeStoredValue","patchIndividualStorageGetItem","originalGetItem","rawGetItem","patchedGetItem","suppressDefineWarning","suppressAssignWarning","patchStorageGetItemForCompression","prototype","patchError","getRawStorageGetter","direct","readRawStorageValue","rawGetterOverride","getter","collectMigrationBackupEntriesForCleanup","excludeKey","snapshotStorageEntries","pruneMigrationBackupEntriesForCleanup","attemptMigrationBackupQuotaRecovery","tryWrite","removedBackups","attemptWrite","clearUiCacheStorageEntries","cleared","clearError","retryAfterClear","attempt","removed","retry","ensurePreWriteMigrationBackup","parsedValue","normalizedRawValue","createStorageMigrationBackup","MIGRATION_BACKUP_LEGACY_DATA_KEYS","trySerializeMigrationBackupValue","normalizeLegacyMigrationBackupCreatedAt","fallbackIso","numeric","iso","time","normalizeLegacyMigrationBackupValue","listChanged","normalizedList","hasData","itemCreatedAt","normalizedDate","dateChanged","usedKey","rawCreatedAt","createdAtSourceKey","createdAtChanged","upgradeLegacyMigrationBackupEntry","originalValue","hasExistingBackup","fallbackCreatedAt","existingRaw","existingData","jsonError","newEntry","MAX_BACKUP_HISTORY","tryStoreList","candidateList","recovery","appendError","tryStoreSerialized","logCompression","storedLength","rawSavings","standardCandidate","standardResult","handleFailure","runRecoveryWith","fallbackError","errorToReport","compressedResult","PRIMARY_STORAGE_KEYS","SIMPLE_STORAGE_KEYS","STORAGE_ALERT_FLAG_NAME","SESSION_FALLBACK_ALERT_FLAG_NAME","storageErrorAlertShown","sessionFallbackAlertShown","DEVICE_COLLECTION_KEYS","FIZ_COLLECTION_KEYS","ACCESSORY_COLLECTION_KEYS","getStorageManager","STORAGE_TEST_KEY","QUOTA_ERROR_NAMES","QUOTA_ERROR_CODES","QUOTA_ERROR_NUMBERS","hasStoredEntries","lengthError","candidateKey","iterationError","verifyStorage","cleanupError","createMemoryStorage","memoryStore","initializeSafeLocalStorage","localCandidates","lastFailedUpgradeCandidate","alertSessionFallback","migrateSnapshotToStorage","migratedKeys","failedKeys","existingRead","writeError","clearMigratedKeys","keysToRemove","rollbackMigratedKeys","suppressAlerts","captureKey","updateGlobalSafeLocalStorageReference","downgradeSafeLocalStorageToMemory","failingStorage","activeStorage","snapshotError","fallbackStorage","fallbackType","sessionScopes","verified","sessionError","copyError","fallbackDescription","attemptLocalStorageUpgrade","currentStorage","selectedCandidate","verifiedStorage","verificationError","resultStorage","persistentStorageRequestPromise","requestPersistentStorage","storageManager","trackedPromise","alreadyGranted","supportsPersistedCheck","persistedError","granted","verifyError","isMapLike","convertMapLikeKey","json","convertMapLikeToObject","mapLike","assignEntry","iterated","step","LEGACY_LONG_GOP_TOKEN_REGEX","inferLegacyLongGopCompressionVariant","lower","normalizeLegacyLongGopString","normalizeLegacyLongGopKey","normalizedArray","normalizedItem","normalizedObject","normalizedKey","normalizeLegacyLongGopBackups","backups","normalizedEntry","parseWithPrefix","yearPart","monthPart","dayPart","hourPart","minutePart","year","month","day","hour","minute","includeSeconds","seconds","labelStartIndex","secondsCandidate","collectAutoBackupEntries","markAutoBackupValueAsRenamed","isAutoBackupValueRenamed","isRenamedAutoBackupEntry","getAutoBackupLabelKey","getAutoBackupEntrySignature","preparedValue","cloneForSignature","signatureState","seenSet","handleCircularSignature","signatureParseError","removeSingleDuplicateAutoBackupEntry","seenSignaturesByLabel","labelKey","labelSignatures","removeDuplicateAutoBackupEntries","removedKey","pruneAutoBackupEntries","duplicateBuckets","bucketKey","removable","indexes","enforceAutoBackupLimits","autoBackups","deletionBackups","removeOldestAutoBackupEntry","force","removeFromEntries","respectRename","hasValue","duplicateAutoBackupKey","duplicateDeletionBackupKey","oldestDeletionBackupKey","oldestAutoBackupKey","describeAutoGearBackupEntry","trimmedNote","trimmedTimestamp","removeOldestAutoGearBackupEntry","removeAt","cleanupAutoGearBackupMigrationCopies","migrationBackupKey","pruned","clearCachedPlannerDataForAutoGearBackups","shouldDisplayStorageAlert","msg","texts","currentLang","lang","getWindowStorage","collectUniqueStorages","storages","migrateKeyBetweenStorages","legacyKey","modernKey","keepLegacy","legacyValue","destination","removeError","migrateKeyInStorages","preferredTarget","migrateLegacyStorageKeys","localStorages","sessionStorages","legacyPrefix","legacy","modern","includeSession","updateFontKey","migratedLocal","applyLegacyStorageMigrations","safeLocal","defaultValue","disableBackup","validate","restoreIfMissing","alertOnFailure","fallbackKey","useBackup","skipBackupRecovery","allowBackupRecovery","allowMigrationBackupRecovery","migrationBackupCandidates","pushCandidate","rawGetter","rawStoredValue","shouldAlert","parseRawValue","normalizedRaw","cachedPrimary","normalizedForCache","rawForCache","missingPrimary","attemptMigrationBackupRecovery","migrationRaw","migrationRawStored","migrationReadError","rawSource","extracted","extractSnapshotStoredValue","serializedCandidate","restoredRawValue","shouldEscalate","payloadToStore","recompressed","restoreError","shouldAttemptBackup","backupRaw","backupRawStored","backup","recompressSource","normalizedBackup","fallbackRawForCache","shouldAttemptMigrationBackup","migrationRecovery","cleanupKey","cleanupErr","onQuotaExceeded","enableCompressionSweep","disableCompression","forceCompressionOnQuota","sessionScopedStorage","compressionBlocked","allowQuotaCompression","loadRawValue","targetKey","standardSerializedCache","standardSerializationComputed","compressionCandidate","useCompressedSerialization","compressionAttempted","compressionLogged","resetSerializationState","computeStandardSerialized","computeCompressedSerialized","baseline","getSerializedForAttempt","standard","tryEnableCompression","forcing","logCompressionIfNeeded","originalLength","wrappedLength","maybeEnableProactiveCompression","rawExisting","preservedBackupValue","hasPreservedBackup","removedBackupDuringRetry","quotaRecoverySteps","quotaRecoveryFailed","compressionSweepAttempted","registerQuotaRecoveryStep","attemptStorageCleanup","freed","cleaned","attemptHandleQuota","handlerError","skipKeysCleanup","cleanupResult","normalizedSerialized","normalizedString","skipPrimaryWrite","existingBackupValue","existingBackupRaw","observedPrimaryRawValue","observedBackupRawValue","existingValue","existingRawValue","inspectError","backupCandidates","standardSerialized","preferredBackupCandidate","backupMatchesPreferred","backupRawForCache","backupResult","backupError","backupRemovedForRetry","lastCandidate","tryStoreCandidate","normalizedForBackup","deleteFromStorage","disableMigrationCleanup","UI_CACHE_STORAGE_KEYS","UI_CACHE_STORAGE_ACCESS_WARNINGS","collectUiCacheStorages","seenScopes","readProperty","inspectScope","nested","loadFlagFromStorage","saveFlagToStorage","loadWithMigration","primaryLoadMsg","fallbackLoadMsg","saveMsg","deleteMsg","loadOptions","fallbackOptions","generateUniqueName","usedNames","trimmedBase","suffix","ensureImportedProjectBaseName","rawName","importedMatch","resolveImportedProjectNamingContext","parsedSuffix","suffixStart","generateImportedProjectName","normalizedCandidate","ensureUpdatedProjectBaseName","generateUpdatedProjectName","collectStringValues","arraysEqual","normalizeDiagramPositions","positions","diagramPositionsEqual","keysA","keysB","valueA","valueB","normalizeSessionStatePayload","normalizeStringField","mergeArrayField","legacyKeys","values","hadLegacyData","hasTargetKey","normalizedPositions","normalizedState","loadSessionState","saveSessionState","saveOptions","loadAutoGearBackups","normalizeDeviceDataPayload","rawData","ensureObject","mergeTrailingSpaceKeys","trimmedKey","deviceName","deviceData","uniqueName","loadDeviceData","parsedData","saveDeviceData","normalizedDeviceData","dataToPersist","normalizeSetups","obj","used","loadSetups","setups","saveSetups","normalizedSetups","serializedSetups","updateSetups","saveSetup","setup","loadSetup","deleteSetup","renameSetup","oldName","newName","movedValue","wasAutoBackup","targetIsAutoBackup","REQUIREMENT_FIELDS_KEEP_NEWLINES","LEGACY_PROJECT_FIELD_LABELS","PRODUCTION_COMPANY_FIELD_ORDER","normalizeProjectFieldLabel","getProductionCompanyLabelSets","projectLabels","labelSets","textsObj","fallbackProjectLabels","addLabel","legacyLabels","expandCombinedProductionCompanyInfo","rawText","normalizedText","segment","firstLine","metadataLines","collectedFromMetadata","fields","field","streetParts","secondary","streetTwo","joinCollected","combined","activeField","normalizedLine","matchedField","streetLines","LEGACY_PROJECT_LABEL_FIELD_MAP","normalize","labels","HTML_ENTITY_MAP","decodeHtmlEntities","entity","code","mapped","stripHtmlTags","previous","normalizeRequirementValueFromHtml","rawHtml","fieldName","normalizedBreaks","extractRequirementValueMetadata","spanRegex","lines","content","fieldsAttrMatch","singleFieldMatch","rawFields","mapLegacyRequirementLabel","labelText","extractProjectInfoFromHtml","html","gridOpenMatch","gridStartIndex","headingMatch","projectName","gridHtml","boxRegex","globalLang","boxHtml","fieldMatch","labelMatch","valueMatch","rawField","valueToStore","expandedField","expandedValue","cloneProjectData","cloneProjectInfo","projectInfo","sanitizeImportedCrewEntries","sanitizeImportedValue","note","sanitizeImportedProjectInfo","fallbackLensNames","fallbackLensNameSet","addFallbackLensName","registerFallbackLensNames","converted","deriveLensSelectionsFromNameMap","selection","normalizeProjectLensNameCandidate","extractLensNamesFromSource","crew","normalizeProjectLensNamesField","normalizeProjectLensSelectionsFromSources","derived","cloneAutoGearRules","rules","cloneDiagramPositionsForStorage","PROJECT_FILTER_DEFAULT_SIZE","normalizeImportedFilterValues","tryParseJSONLike","normalizeImportedFilterEntry","typePart","sizePart","rawValues","typeCandidate","sizeCandidate","valuesCandidate","hasExplicitValues","typeKeys","sizeKeys","valueKeys","serializeNormalizedFilterEntry","token","normalizeImportedFilterValue","singleEntry","normalizeImportedProjectFilters","normalizedFilter","cloneProjectGearSelectors","selectors","cloneSelectorValue","nestedValue","clonedNestedValue","normalizeProjectPowerSelection","normalizeString","cloneProjectPowerSelection","LEGACY_LENS_SELECTION_META_KEYS","isLikelyLensNameKey","deriveLensNameKeysFromObject","nameCandidates","keyDerivedNames","nestedName","nestedEntries","keyNames","isNormalized","normalizeProjectLensSelectionEntry","mountValue","mountCandidates","trimmedMount","directNameCandidates","mountFields","sources","fallbackNames","sourceList","seenNames","addSelection","entryChanged","processSourceValue","mappedSelections","fallbackName","normalizeProject","projectContainer","projectInfoSource","normalizedProjectInfo","parsedInfo","nestedProjectInfo","parsedProjectInfo","normalizedAutoGearRules","assignAutoGearRules","convertedRules","parsedRules","gearListSource","convertedGearList","normalizedGearList","normalizedGearSelectors","gearSelectorsSource","parsedSelectors","powerSelectionSource","normalizedPowerSelection","parsedGear","diagramSource","normalizedDiagramPositions","nestedDiagramSource","htmlSources","nestedSelectorsSource","nestedPowerSelection","recovered","recoveredClone","normalizedClone","lensSelectionSources","lensSelectionResult","derivedGenerationFlag","normalizedInfo","normalizedRules","normalizedSelectors","normalizedDiagram","normalizedPower","parsedProject","LEGACY_PROJECT_ROOT_KEYS","NORMALIZED_PROJECT_KEYS","isNormalizedProjectEntry","gearList","powerSelection","setActiveProjectCompressionHold","clearActiveProjectCompressionHold","resolveProjectKey","rawMap","normalizedMap","exact","firstExisting","buildProjectLookupFromProjects","rawKeyLookup","normalizedKeyLookup","forceRefresh","skipMigrations","skipAutoBackupExpansion","projectsSnapshot","lookupSnapshot","storageRaw","combinedRawEntries","rawVal","parsedVal","inputForExpansion","expandOptions","expandedParsed","usedProjectNames","normalizedProjectNames","markProjectNameUsed","registerLookupKey","storedKey","effectiveKey","createLookupSnapshot","suggestedName","updatedName","originalEntry","needsUpgrade","requiresContentUpdate","normalizedSignature","originalSignature","finalKey","innerName","pruneOrphanProjectShards","keysToDelete","cleanupMonolithicProjectStorage","persistProjectShard","project","skipCompression","shardKey","victimKey","persistAllProjects","indexError","entryModified","existingModified","buildProjectIndexForRepo","prefixed","storedIndex","indexKeys","migrationResult","prefixedIndex","readProjectIndex","isIndexedDB","loadProject","resolvedKey","mutableProjects","loadProjectMetadata","cachedIndex","loaded","sanitizeProjectNameForBackup","collapsed","formatAutoBackupTimestamp","date","pad","generateDeletionBackupMetadata","sanitizedName","cloneProjectEntryForBackup","maybeCreateProjectDeletionBackup","backupName","createProjectDeletionBackup","backupOutcome","generateOverwriteBackupMetadata","maybeCreateProjectOverwriteBackup","backupSource","saveProject","skipOverwriteBackup","requestedKey","preferredKey","initialSnapshot","initialProjects","initialResolvedKey","initialExistingEntry","initialExistingSignature","latestSnapshot","renamedFromKey","existingKey","hasExistingEntry","existingEntry","nextSignature","shouldDelete","manualRenamedFrom","resolvedOld","shardSuccess","deleteProject","storagesToPrune","backupSuffix","uiCacheError","currentSafeStorage","potentialShardKey","renameProject","targetName","createProjectImporter","defaultName","normalizedProject","firstChar","lastChar","expectedClosing","importProjectCollection","ensureImporter","fallbackLabel","proj","importProject","collectLegacyProjectCollections","collections","addCollection","plannerData","loadFavorites","saveFavorites","favs","resolveContactsModuleApi","contactsModuleImport","moduleBase","fallbackSanitizeContactValue","fallbackGenerateContactId","generated","fallbackNormalizeContactEntry","sanitize","avatarSource","fallbackSortContacts","createdA","createdB","normalizeContactsList","sorted","normalizer","loadContacts","saveContacts","loadOwnGear","saveOwnGear","normalizeUserProfileField","normalizeUserProfile","loadUserProfile","saveUserProfile","profile","loadFeedback","saveFeedback","feedback","normalizeFullBackupHistoryEntry","loadFullBackupHistory","saveFullBackupHistory","safeEntries","recordFullBackupHistoryEntry","history","normalizeImportedFullBackupHistory","results","nestedValues","DOCUMENTATION_TRACKER_SCHEMA_VERSION","generateDocumentationTrackerId","normalizeDocumentationTrackerStatusEntry","completed","timestampCandidate","normalizeDocumentationTrackerStatusMap","keyString","normalizeDocumentationTrackerStatuses","normalizeDocumentationTrackerRelease","targetDate","archived","normalizedStatus","statuses","normalizeDocumentationTrackerState","rawState","loadDocumentationTracker","saveDocumentationTracker","loadAutoGearRules","saveAutoGearRules","defaultsApplied","withDefaults","rule","skipNormalization","safeRules","normalizedCached","saveAutoGearBackups","normalizedBackups","safeBackups","attemptedMigrationCleanup","attemptedCacheCleanup","isIndexedDBActive","removal","loadAutoGearSeedFlag","saveAutoGearSeedFlag","loadAutoGearPresets","presets","presetArray","saveAutoGearPresets","readActiveAutoGearPresetIds","ids","pushId","loadAutoGearActivePresetId","loadAutoGearAutoPresetId","disableCompressionOverride","safePresets","normalizedPresets","activePresetIds","loadAutoGearMonitorDefaults","monitorDefaults","normalizedDefaults","saveAutoGearMonitorDefaults","safeDefaults","removeAutoGearPresetFromStorage","presetId","rawPresets","parsedPresets","normalizedRawPresets","filteredPresets","saveAutoGearActivePresetId","legacyStorage","saveAutoGearAutoPresetId","previousPresetId","existingId","loadAutoGearBackupVisibility","saveAutoGearBackupVisibility","getAutoGearBackupRetentionUpperBound","clampAutoGearBackupRetention","getAutoGearBackupRetentionDefault","upperBound","normalizeAutoGearBackupRetentionValue","maybeJson","candidateKeys","loadAutoGearBackupRetention","retention","saveAutoGearBackupRetention","clearAllData","clearStorageFully","storageName","clearVaultFn","vaultDbNames","db","dbName","request","vaultError","cacheKeys","cacheError","readLocalStorageValue","decodedBackup","legacyError","parseStoredBoolean","interpretPrintPreferencesValue","hasSectionsContainer","sectionsSource","sections","sectionKeys","sectionKey","sectionValue","layout","trimmedLayout","collectPreferenceSnapshot","preferences","darkMode","pinkMode","highContrast","reduceMotion","relaxedSpacing","showAutoBackups","accentColor","fontSize","fontFamily","language","mountVoltageKey","mountVoltages","voltageParseError","iosPwaHelpShown","temperatureUnit","focusScale","cameraColorsRaw","parsedCameraColors","trimmedCameraColors","cameraColorParseError","printPreferencesRaw","interpretedPrintPreferences","normalizeCustomFontEntries","readStoredCustomFonts","backupVaultRecordCache","normalizeBackupVaultMetadata","normalizeBackupVaultRecord","fileName","createdAtMs","normalizedCreatedAtMs","parsedTime","normalizeBackupVaultRecordList","records","parsedResult","scoreBackupVaultRecord","score","mergeBackupVaultRecords","existingList","incomingList","mergeList","readBackupVaultFallbackRecords","resolveBackupVaultApi","refreshBackupVaultRecordCache","loader","response","resolveAutoGearPersistence","getAutoGearSnapshotFromCache","persistence","readValue","readerName","prepareBackupForExport","exportAllData","autoGearSnapshot","rawProjects","documentationTracker","customLogo","customFonts","schemaCache","fallbackVaultRecords","combinedVaultRecords","safeSetLocalStorage","keysWithMemoryCache","clearCacheForKey","writeLegacyStorage","storedValue","legacyWriteError","normalizeImportedBoolean","normalizeImportedArray","fallbackKeys","filterFn","normalizeImportedContacts","normalizeImportedAutoGearRules","normalizeImportedAutoGearBackups","normalizeImportedAutoGearBackupRetention","normalizeImportedAutoGearPresets","normalizeImportedAutoGearMonitorDefaults","legacyNormalized","normalizeImportedPresetId","normalizeImportedBackupVaultRecords","importBackupVaultRecords","existingFallback","mergedFallback","storageError","queueRecord","existingIds","getSnapshotKeyVariants","readSnapshotEntry","compressionToken","encodingToken","isModernCompression","isLegacyLongGopCompression","parseSnapshotJSONValue","parseSnapshotStringValue","convertStorageSnapshotToData","hasAssignments","hasSnapshotKeys","preferenceKeys","mountVoltageKeyName","simpleSnapshotKeys","booleanPreferenceKeys","markSnapshotEntry","assignJSONValue","schemaEntry","cacheValue","customFontsEntry","fontsValue","customLogoEntry","logoValue","seedEntry","activePresetEntry","autoPresetEntry","backupsVisibilityEntry","snapshotPrintValue","interpretedPreferences","stringValue","temperatureUnitEntry","storedUnit","normalizedUnit","focusScaleEntry","storedScale","normalizedScale","cameraColorsEntry","storedCameraColors","mountVoltageEntry","storedVoltages","importAllData","allData","skipSnapshotConversion","hasOwn","cameraColorKeyName","autoGearPersistence","persistAutoGearValue","fallbackFn","prefs","unit","scale","focusScaleError","rawPrintPreferences","normalizedPrintPreferences","serializedPrintPreferences","printPreferenceSerializationError","printPreferencePersistError","printPreferenceApplyError","printPreferenceStringPersistError","rawVoltages","voltStoreError","parsedVoltages","voltParseError","rawCameraColors","applyImportedCameraColors","palette","applied","cameraColorApplyError","serializedPalette","cameraColorSerializeError","cameraColorPersistError","cameraColorStoreError","logo","schemaError","trackerState","trackerFromLogs","trackerFromLegacy","visibility","backupRecords","importProjectEntry","ensureProjectImporter","projectImported","getTrackedImporter","importer","importTrackedCollection","getProjectMemoryCache","STORAGE_API","TEST_ONLY_AUTO_BACKUP_COMPRESSION_CACHE","definitionError","cineStorage","resolveModuleLinker","linker","MODULE_LINKER","linked","linkedRegistry","linkedKey","sharedKey","bridgedKey","cloneOptions","fallbackRegisterOrQueue","fallbackExposeGlobal","providerModules","addProviderModule","reference","bindingState","bindingNames","identifyProvider","providerEntry","ref","ensureBindingEntry","bindingKey","implementationName","resolveBinding","refresh","requireBinding","snapshotBinding","createWrapper","alias","inspectBinding","inspectAllBindings","listBindings","persistenceAPI","existingPersistence","createFallbackIconFontKeys","hasWidth","hasHeight","ICON_FONT_KEYS","fallbackFont","AUTO_GEAR_STORAGE_KEYS","DEFAULT_CACHE_STATE","cloneCacheValue","buildCacheEntry","createCacheState","resolvePersistenceScope","module","AutoGearService","hydrate","binding","persistenceScope","visible","autoGearService","ProjectService","newProject","sourceId","cleanSourceId","sourceProject","existingNames","counter","newData","projectService"],"ignoreList":[],"sources":["../../src/scripts/modules/helpers/scope-utils.js","../../src/scripts/modules/icons.js","../../src/scripts/modules/helpers/scope-collector.js","../../src/scripts/modules/base.js","../../src/scripts/modules/registry.js","../../src/scripts/modules/device-normalization.js","../../src/scripts/modules/logging.js","../../src/scripts/modules/console-helpers.js","../../src/scripts/console-helpers.js","../../src/scripts/modules/logging-resolver.js","../../src/scripts/modules/features/contacts.js","../../src/scripts/modules/storage/StorageInterface.js","../../src/scripts/modules/storage/drivers/IndexedDBAdapter.js","../../src/scripts/modules/core/UserContext.js","../../src/scripts/modules/storage/SyncMetadata.js","../../src/scripts/modules/storage/ProjectLockService.js","../../src/scripts/modules/storage/StorageRepository.js","../../src/scripts/modules/storage/drivers/LocalStorageAdapter.js","../../src/scripts/modules/storage/StorageMigrationService.js","../../src/scripts/modules/gear/GearRepository.js","../../src/scripts/modules/storage/DataVault.js","../../src/scripts/storage.js","../../src/scripts/modules/persistence.js","../../src/scripts/modules/helpers/icons.js","../../src/scripts/modules/persistence/AutoGearService.js","../../src/scripts/modules/persistence/ProjectService.js"],"sourcesContent":["/**\n * Cine Power Planner Scope Utilities\n *\n * Pure ESM module for cross-environment global scope detection.\n * Provides utilities to locate and interact with the global scope across\n * browsers, workers, Node environments, and legacy contexts.\n *\n * @module helpers/scope-utils\n * @see {@link ../runtime-environment.js} for the aggregate API\n * @see {@link ../../docs/dev/architecture/runtime-environment.md} for architecture docs\n *\n * Extracted from app-core-environment.js during Vite migration (Step 24).\n */\n\n/**\n * Locate the best-available global scope in a resilient, legacy-safe way.\n * Falls back to an empty object to avoid throwing in sandboxed/offline contexts.\n * Exists to provide a stable entry point for global access across browsers,\n * workers, Node-like runtimes, and legacy environments.\n *\n * @returns {object} The detected global scope or a safe empty object fallback.\n */\nfunction baseDetectGlobalScope() {\n  if (typeof globalThis !== 'undefined') {\n    return globalThis;\n  }\n  if (typeof window !== 'undefined') {\n    return window;\n  }\n  if (typeof self !== 'undefined') {\n    return self;\n  }\n  if (typeof global !== 'undefined') {\n    return global;\n  }\n  return {};\n}\n\nconst FALLBACK_SCOPE = baseDetectGlobalScope();\nconst DETECT_CACHE = { value: null, time: 0 };\n\n/**\n * Safely define a non-enumerable property on a target without throwing.\n * Uses defineProperty when possible, then falls back to assignment.\n * Exists to cache helper results on globals even in restricted environments.\n *\n * @param {object|Function|null|undefined} target - The object or function to receive the property.\n * @param {string} key - The property name to define.\n * @param {*} value - The value to assign.\n * @returns {boolean} True when the property was set, otherwise false.\n */\nfunction safeAssign(target, key, value) {\n  if (!target || (typeof target !== 'object' && typeof target !== 'function')) {\n    return false;\n  }\n\n  try {\n    Object.defineProperty(target, key, {\n      configurable: true,\n      enumerable: false,\n      writable: true,\n      value,\n    });\n    return true;\n  } catch (defineError) {\n    void defineError;\n  }\n\n  try {\n    target[key] = value;\n    return true;\n  } catch (assignmentError) {\n    void assignmentError;\n  }\n\n  return false;\n}\n\n/**\n * Detect and cache the global scope with non-throwing access.\n * Uses a cached value when available, with a fallback object as a safety net.\n * Exists to provide consistent global access in offline/legacy deployments.\n *\n * @returns {object} The detected global scope or a safe fallback.\n */\nexport function detectGlobalScope() {\n  if (DETECT_CACHE.value && typeof DETECT_CACHE.value === 'object') {\n    return DETECT_CACHE.value;\n  }\n\n  try {\n    const detected = baseDetectGlobalScope();\n    if (detected && (typeof detected === 'object' || typeof detected === 'function')) {\n      DETECT_CACHE.value = detected;\n      DETECT_CACHE.time = Date.now();\n      return detected;\n    }\n  } catch (detectionError) {\n    void detectionError;\n  }\n\n  return FALLBACK_SCOPE;\n}\n\n/**\n * Collect unique candidate scopes for resilient global lookups.\n * Includes optional primary/extras, detected globals, and known fallbacks.\n * Never throws; failures in detection are ignored.\n * Exists to unify multi-environment access (browser, worker, Node) without\n * breaking offline or legacy contexts.\n *\n * @param {object|Function|null|undefined} primary - Preferred scope to try first.\n * @param {Array<object|Function>|null|undefined} extras - Additional scopes to add.\n * @param {Function|null|undefined} detect - Optional detector (defaults to detectGlobalScope).\n * @returns {Array<object|Function>} A de-duplicated list of candidate scopes.\n */\nexport function collectCandidateScopes(primary, extras, detect) {\n  const seen = [];\n  const append = (scope) => {\n    if (!scope || (typeof scope !== 'object' && typeof scope !== 'function')) {\n      return;\n    }\n    if (seen.indexOf(scope) === -1) {\n      seen.push(scope);\n    }\n  };\n\n  append(primary);\n\n  const detectFn = typeof detect === 'function' ? detect : detectGlobalScope;\n\n  try {\n    append(detectFn());\n  } catch (detectError) {\n    void detectError;\n  }\n\n  if (Array.isArray(extras)) {\n    for (let index = 0; index < extras.length; index += 1) {\n      append(extras[index]);\n    }\n  }\n\n  if (typeof globalThis !== 'undefined') append(globalThis);\n  if (typeof window !== 'undefined') append(window);\n  if (typeof self !== 'undefined') append(self);\n  if (typeof global !== 'undefined') append(global);\n\n  append(FALLBACK_SCOPE);\n\n  return seen.slice();\n}\n\n/**\n * Attempt a CommonJS require without throwing.\n * Returns null when require is unavailable or the module cannot be loaded.\n * Exists to support legacy/offline environments where dynamic imports differ.\n *\n * @param {string} modulePath - The module identifier to require.\n * @returns {*} The required module value or null on failure.\n */\nexport function tryRequire(modulePath) {\n  if (typeof require !== 'function') {\n    return null;\n  }\n\n  try {\n    return require(modulePath);\n  } catch (error) {\n    void error;\n    return null;\n  }\n}\n\n/**\n * Resolve a property-owning scope from a list of candidate globals.\n * Uses optional predicate and safe property checks to avoid throwing.\n * Exists to safely discover globals across multiple runtime contexts.\n *\n * @param {string} propertyName - The global property to look for.\n * @param {object} [options] - Configuration for scope collection and filtering.\n * @param {Function} [options.predicate] - Optional predicate(scope, propertyName) for early match.\n * @param {Array<object|Function>} [options.scopes] - Pre-seeded scopes to inspect first.\n * @param {object|Function} [options.primaryScope] - Primary scope candidate.\n * @param {Array<object|Function>} [options.additionalScopes] - Additional scope candidates.\n * @param {Function} [options.detect] - Custom global detector function.\n * @returns {object|Function|null} The first matching scope or null when not found.\n */\nexport function resolveFromScopes(propertyName, options) {\n  const settings = options || {};\n  const predicate = typeof settings.predicate === 'function' ? settings.predicate : null;\n  const scoped = Array.isArray(settings.scopes) ? settings.scopes.slice() : [];\n  const candidates = collectCandidateScopes(\n    settings.primaryScope,\n    settings.additionalScopes,\n    settings.detect\n  );\n\n  for (let index = 0; index < candidates.length; index += 1) {\n    if (scoped.indexOf(candidates[index]) === -1) {\n      scoped.push(candidates[index]);\n    }\n  }\n\n  for (let index = 0; index < scoped.length; index += 1) {\n    const scope = scoped[index];\n    if (!scope || (typeof scope !== 'object' && typeof scope !== 'function')) {\n      continue;\n    }\n\n    if (predicate) {\n      try {\n        if (predicate(scope, propertyName)) {\n          return scope;\n        }\n      } catch (predicateError) {\n        void predicateError;\n      }\n    }\n\n    try {\n      if (propertyName in scope) {\n        return scope;\n      }\n    } catch (accessError) {\n      void accessError;\n    }\n  }\n\n  return null;\n}\n\n/**\n * Read or initialize a cached value on the global scope.\n * Uses a safe, non-throwing define/assign with fallback to direct value.\n * When key is falsy, returns the factory result without caching.\n * Exists to persist shared utilities across loads in offline/legacy runtimes.\n *\n * @param {string} key - Global cache key to read/write.\n * @param {Function|*} factory - Value or factory to produce the value.\n * @returns {*} The cached or newly-created value.\n */\nexport function getCachedGlobalValue(key, factory) {\n  if (!key) {\n    return typeof factory === 'function' ? factory() : factory;\n  }\n\n  const scope = detectGlobalScope();\n  if (scope && typeof scope === 'object') {\n    if (Object.prototype.hasOwnProperty.call(scope, key)) {\n      return scope[key];\n    }\n\n    const value = typeof factory === 'function' ? factory() : factory;\n    if (safeAssign(scope, key, value)) {\n      try {\n        return scope[key];\n      } catch (error) {\n        void error;\n      }\n    }\n    return value;\n  }\n\n  return typeof factory === 'function' ? factory() : factory;\n}\n\nconst api = {\n  baseDetectGlobalScope, // Exported as member of API object but generic\n  detectGlobalScope,\n  collectCandidateScopes,\n  tryRequire,\n  defineHiddenProperty: safeAssign,\n  resolveFromScopes,\n  getCachedGlobalValue,\n};\n\n// Global Assignment\nconst GLOBAL_SCOPE = detectGlobalScope();\n\nif (GLOBAL_SCOPE && !GLOBAL_SCOPE.cineScopeUtils) {\n  safeAssign(GLOBAL_SCOPE, 'cineScopeUtils', api);\n}\n\nexport {\n  baseDetectGlobalScope,\n  safeAssign,\n  safeAssign as defineHiddenProperty,\n  api as cineScopeUtils\n};\n","/* global ICON_FONT_KEYS */\n// Removed IIFE wrapper for ES Module conversion\n// (function createCineIconsModule() {\n\nconst globalScope =\n    (typeof globalThis !== 'undefined' && globalThis) ||\n    (typeof window !== 'undefined' && window) ||\n    (typeof self !== 'undefined' && self) ||\n    (typeof global !== 'undefined' && global) ||\n    {};\n\nconst VALID_ICON_FONTS = (function createValidIconFontSet() {\n    // Ensure ICON_FONT_KEYS is available\n    const keys = globalScope.ICON_FONT_KEYS || (typeof ICON_FONT_KEYS !== 'undefined' ? ICON_FONT_KEYS : null);\n\n    if (typeof keys !== 'object' || !keys) {\n        return new Set();\n    }\n    const fonts = Object.values(keys).filter(\n        font => typeof font === 'string' && font,\n    );\n    return new Set(fonts);\n})();\n\nfunction toCodePointChar(value, radix) {\n    const codePoint = parseInt(value, radix);\n    if (!Number.isFinite(codePoint) || codePoint < 0) {\n        return '';\n    }\n    if (typeof String.fromCodePoint === 'function') {\n        try {\n            return String.fromCodePoint(codePoint);\n        } catch (rangeError) {\n            void rangeError;\n        }\n    }\n    if (codePoint <= 0xffff) {\n        return String.fromCharCode(codePoint);\n    }\n    return '';\n}\n\nfunction normalizeGlyphChar(char) {\n    if (typeof char !== 'string') {\n        return '';\n    }\n    const trimmed = char.trim();\n    if (!trimmed) {\n        return '';\n    }\n    const unicodeMatch = trimmed.match(/^(?:\\\\)+u([0-9A-Fa-f]{4})$/);\n    if (unicodeMatch) {\n        const decoded = toCodePointChar(unicodeMatch[1], 16);\n        if (decoded) {\n            return decoded;\n        }\n    }\n    const unicodeBraceMatch = trimmed.match(/^(?:\\\\)+u\\{([0-9A-Fa-f]+)\\}$/);\n    if (unicodeBraceMatch) {\n        const decoded = toCodePointChar(unicodeBraceMatch[1], 16);\n        if (decoded) {\n            return decoded;\n        }\n    }\n    const hexEntityMatch = trimmed.match(/^&#x([0-9A-Fa-f]+);$/i);\n    if (hexEntityMatch) {\n        const decoded = toCodePointChar(hexEntityMatch[1], 16);\n        if (decoded) {\n            return decoded;\n        }\n    }\n    const decimalEntityMatch = trimmed.match(/^&#(\\d+);$/);\n    if (decimalEntityMatch) {\n        const decoded = toCodePointChar(decimalEntityMatch[1], 10);\n        if (decoded) {\n            return decoded;\n        }\n    }\n    return trimmed;\n}\n\nfunction iconGlyph(char, font) {\n    // Resolve font keys dynamically to handle load order\n    const keys = globalScope.ICON_FONT_KEYS || (typeof ICON_FONT_KEYS !== 'undefined' ? ICON_FONT_KEYS : { UICONS: 'uicons' });\n    const defaultFont = keys.UICONS || 'uicons';\n    const requestedFont = font || defaultFont;\n\n    const normalizedFont = VALID_ICON_FONTS.has(requestedFont) ? requestedFont : defaultFont;\n    const normalizedChar = normalizeGlyphChar(char);\n    const glyph = {\n        char: normalizedChar,\n        font: normalizedFont,\n    };\n    return typeof Object.freeze === 'function' ? Object.freeze(glyph) : glyph;\n}\n\nfunction resolveIconGlyph(glyph) {\n    const keys = globalScope.ICON_FONT_KEYS || (typeof ICON_FONT_KEYS !== 'undefined' ? ICON_FONT_KEYS : { UICONS: 'uicons' });\n    const defaultFont = keys.UICONS || 'uicons';\n\n    if (!glyph) {\n        return {\n            char: '',\n            font: defaultFont,\n            className: '',\n            size: undefined,\n        };\n    }\n    if (glyph.markup) {\n        const size = Number.isFinite(glyph.size) ? glyph.size : undefined;\n        return {\n            markup: glyph.markup,\n            className: glyph.className || '',\n            font: defaultFont,\n            size,\n        };\n    }\n    if (typeof glyph === 'string') {\n        return {\n            char: normalizeGlyphChar(glyph),\n            font: defaultFont,\n            className: '',\n            size: undefined,\n        };\n    }\n    if (typeof glyph === 'object') {\n        const char = typeof glyph.char === 'string' ? normalizeGlyphChar(glyph.char) : '';\n        const fontKey = glyph.font && VALID_ICON_FONTS.has(glyph.font) ? glyph.font : defaultFont;\n        const className = typeof glyph.className === 'string' ? glyph.className : '';\n        const size = Number.isFinite(glyph.size) ? glyph.size : undefined;\n        if (glyph.markup) {\n            return {\n                markup: glyph.markup,\n                className,\n                font: fontKey,\n                size,\n            };\n        }\n        return {\n            char,\n            font: fontKey,\n            className,\n            size,\n        };\n    }\n    return {\n        char: '',\n        font: defaultFont,\n        className: '',\n        size: undefined,\n    };\n}\n\nfunction ensureSvgHasAriaHidden(markup) {\n    if (typeof markup !== 'string') return '';\n    if (markup.indexOf('aria-hidden=\"true\"') !== -1) return markup;\n    return markup.replace('<svg', '<svg aria-hidden=\"true\"');\n}\n\nfunction applyIconGlyph(element, glyph) {\n    if (!element) return;\n    const resolved = resolveIconGlyph(glyph);\n    if (resolved.markup) {\n        element.innerHTML = ensureSvgHasAriaHidden(resolved.markup);\n        element.setAttribute('aria-hidden', 'true');\n        if (resolved.className) {\n            resolved.className\n                .split(/\\s+/)\n                .filter(Boolean)\n                .forEach(cls => element.classList.add(cls));\n        }\n        element.removeAttribute('data-icon-font');\n        return;\n    }\n    const char = resolved.char || '';\n    element.textContent = char;\n    if (char) {\n        element.setAttribute('data-icon-font', resolved.font);\n    } else {\n        element.removeAttribute('data-icon-font');\n    }\n}\n\nfunction iconMarkup(glyph, className) {\n    const resolved = resolveIconGlyph(glyph);\n    const parts = [];\n    if (resolved.className) parts.push(resolved.className);\n    if (className) parts.push(className);\n    const finalClass = parts.join(' ');\n\n    if (resolved.markup) {\n        let svg = ensureSvgHasAriaHidden(resolved.markup);\n        if (finalClass) {\n            if (svg.indexOf('class=\"') !== -1) {\n                svg = svg.replace('class=\"', `class=\"${finalClass} `);\n            } else {\n                svg = svg.replace('<svg', `<svg class=\"${finalClass}\"`);\n            }\n        }\n        return svg;\n    }\n\n    const fontAttr = resolved.char ? `data-icon-font=\"${resolved.font}\"` : '';\n    return `<span class=\"icon-glyph ${finalClass}\" aria-hidden=\"true\" ${fontAttr}>${resolved.char}</span>`;\n}\n\nfunction formatSvgCoordinate(value) {\n    if (!Number.isFinite(value)) return '0';\n    const rounded = Math.round(value * 100) / 100;\n    if (Number.isInteger(rounded)) return String(rounded);\n    return rounded.toFixed(2).replace(/0+$/, '').replace(/\\.$/, '');\n}\n\nfunction positionSvgMarkup(markup, centerX, centerY, size = 24) {\n    if (typeof markup !== 'string') {\n        return { markup: '', x: '0', y: '0' };\n    }\n    const trimmed = markup.trim();\n    if (!trimmed) {\n        return { markup: '', x: '0', y: '0' };\n    }\n    const half = size / 2;\n    const x = formatSvgCoordinate(centerX);\n    const y = formatSvgCoordinate(centerY);\n    const width = formatSvgCoordinate(size);\n    const height = formatSvgCoordinate(size);\n    const cleaned = trimmed.replace(/<svg\\b([^>]*)>/i, (match, attrs = '') => {\n        let attrText = attrs\n            .replace(/\\s+x\\s*=\\s*\"[^\"]*\"/gi, '')\n            .replace(/\\s+y\\s*=\\s*\"[^\"]*\"/gi, '')\n            .trim();\n        const additions = [];\n        if (!/(?:^|\\s)width\\s*=/i.test(attrText)) additions.push(`width=\"${width}\"`);\n        if (!/(?:^|\\s)height\\s*=/i.test(attrText)) additions.push(`height=\"${height}\"`);\n        additions.push(`x=\"-${formatSvgCoordinate(half)}\"`);\n        additions.push(`y=\"-${formatSvgCoordinate(half)}\"`);\n        attrText = [attrText].concat(additions).filter(Boolean).join(' ').trim();\n        return attrText ? `<svg ${attrText}>` : '<svg>';\n    });\n    return { markup: cleaned, x, y };\n}\n\nconst STAR_ICON_SVG = `\n<svg viewBox=\"0 0 24 24\" xmlns=\"http://www.w3.org/2000/svg\">\n  <path\n    d=\"M12 17.25 6.545 20.2 7.9 13.975 3 9.45l6.272-.7L12 3l2.728 5.75L21 9.45l-4.9 4.525 1.355 6.225Z\"\n    fill=\"currentColor\"\n    stroke=\"currentColor\"\n    stroke-width=\"0\"\n  />\n</svg>\n`.trim();\n\n// We need to access ICON_FONT_KEYS from the global scope or where it's defined\nconst keys = globalScope.ICON_FONT_KEYS || (typeof ICON_FONT_KEYS !== 'undefined' ? ICON_FONT_KEYS : {\n    UICONS: 'uicons',\n    ESSENTIAL: 'essential',\n    GADGET: 'gadget',\n    FILM: 'film',\n    TEXT: 'text'\n});\n\nconst ICON_GLYPHS = Object.freeze({\n    batteryBolt: iconGlyph('\\uE1A6', keys.UICONS),\n    batteryFull: iconGlyph('\\uE1A9', keys.UICONS),\n    bolt: iconGlyph('\\uF1F8', keys.ESSENTIAL),\n    plug: iconGlyph('\\uEE75', keys.UICONS),\n    sliders: iconGlyph('\\uF143', keys.ESSENTIAL),\n    screen: iconGlyph('\\uF11D', keys.GADGET),\n    brightness: iconGlyph('\\uE2B3', keys.UICONS),\n    wifi: iconGlyph('\\uF4AC', keys.UICONS),\n    gears: iconGlyph('\\uE8AF', keys.UICONS),\n    controller: iconGlyph('\\uF117', keys.GADGET),\n    distance: iconGlyph('\\uEFB9', keys.UICONS),\n    sensor: iconGlyph('\\uEC2B', keys.UICONS),\n    viewfinder: iconGlyph('\\uF114', keys.FILM),\n    camera: iconGlyph('\\uE333', keys.UICONS),\n    trash: iconGlyph('\\uF254', keys.ESSENTIAL),\n    reload: iconGlyph('\\uF202', keys.ESSENTIAL),\n    load: iconGlyph('\\uE0E0', keys.UICONS),\n    installApp: iconGlyph('\\uE9D4', keys.UICONS),\n    add: Object.freeze({ char: '+', font: keys.TEXT, className: 'icon-text' }),\n    minus: Object.freeze({ char: '', font: keys.TEXT, className: 'icon-text' }),\n    arrowLeft: Object.freeze({ char: '', font: keys.TEXT, className: 'icon-text' }),\n    check: iconGlyph('\\uE3D8', keys.UICONS),\n    fileExport: iconGlyph('\\uE7AB', keys.UICONS),\n    fileImport: iconGlyph('\\uE7C7', keys.UICONS),\n    save: iconGlyph('\\uF207', keys.ESSENTIAL),\n    share: iconGlyph('\\uF219', keys.ESSENTIAL),\n    paperPlane: iconGlyph('\\uED67', keys.UICONS),\n    magnet: iconGlyph('\\uF1B5', keys.ESSENTIAL),\n    codec: iconGlyph('\\uE4CD', keys.UICONS),\n    timecode: iconGlyph('\\uF10E', keys.FILM),\n    audioIn: iconGlyph('\\uF1C3', keys.ESSENTIAL),\n    audioOut: iconGlyph('\\uF22F', keys.ESSENTIAL),\n    note: iconGlyph('\\uF13E', keys.ESSENTIAL),\n    overview: iconGlyph('\\uF1F5', keys.UICONS),\n    gearList: iconGlyph('\\uE467', keys.UICONS),\n    contacts: iconGlyph('\\uF404', keys.UICONS),\n    feedback: iconGlyph('\\uE791', keys.UICONS),\n    resetView: iconGlyph('\\uEB6D', keys.UICONS),\n    pin: iconGlyph('\\uF1EF', keys.ESSENTIAL),\n    sun: iconGlyph('\\uF1FE', keys.UICONS),\n    moon: iconGlyph('\\uEC7E', keys.UICONS),\n    circleX: iconGlyph('\\uF131', keys.ESSENTIAL),\n    settingsGeneral: iconGlyph('\\uE5A3', keys.UICONS),\n    settingsAutoGear: iconGlyph('\\uE8AF', keys.UICONS),\n    settingsAccessibility: iconGlyph('\\uF392', keys.UICONS),\n    settingsBackup: iconGlyph('\\uE5BD', keys.UICONS),\n    settingsData: iconGlyph('\\uE5C7', keys.UICONS),\n    settingsAbout: iconGlyph('\\uEA4F', keys.UICONS),\n    star: Object.freeze({ markup: STAR_ICON_SVG, className: 'icon-svg favorite-star-icon' }),\n    warning: iconGlyph('\\uF26F', keys.ESSENTIAL),\n});\n\n// Expose to global scope for legacy compatibility\nglobalScope.cineIcons = {\n    VALID_ICON_FONTS,\n    toCodePointChar,\n    normalizeGlyphChar,\n    iconGlyph,\n    resolveIconGlyph,\n    applyIconGlyph,\n    iconMarkup,\n    formatSvgCoordinate,\n    positionSvgMarkup,\n    STAR_ICON_SVG,\n    ICON_GLYPHS,\n};\n\n// Expose individual functions for backward compatibility if needed, \n// or just use cineIcons namespace. \n// Based on app-core-new-1.js usage, these seem to be expected in the scope.\nglobalScope.iconGlyph = iconGlyph;\nglobalScope.resolveIconGlyph = resolveIconGlyph;\nglobalScope.applyIconGlyph = applyIconGlyph;\nglobalScope.iconMarkup = iconMarkup;\nglobalScope.formatSvgCoordinate = formatSvgCoordinate;\nglobalScope.positionSvgMarkup = positionSvgMarkup;\nglobalScope.STAR_ICON_SVG = STAR_ICON_SVG;\nglobalScope.ICON_GLYPHS = ICON_GLYPHS;\n\n// Export as ES Module\nexport const cineIcons = globalScope.cineIcons;\nexport {\n    VALID_ICON_FONTS,\n    toCodePointChar,\n    normalizeGlyphChar,\n    iconGlyph,\n    resolveIconGlyph,\n    applyIconGlyph,\n    iconMarkup,\n    formatSvgCoordinate,\n    positionSvgMarkup,\n    STAR_ICON_SVG,\n    ICON_GLYPHS,\n};\n","function detectGlobalScope() {\n  if (typeof globalThis !== 'undefined') {\n    return globalThis;\n  }\n  if (typeof window !== 'undefined') {\n    return window;\n  }\n  if (typeof self !== 'undefined') {\n    return self;\n  }\n  if (typeof global !== 'undefined') {\n    return global;\n  }\n  return {};\n}\n\nfunction isObjectLike(value) {\n  return !!value && (typeof value === 'object' || typeof value === 'function');\n}\n\nfunction freezeArray(array) {\n  if (typeof Object.freeze === 'function') {\n    try {\n      return Object.freeze(array);\n    } catch (error) {\n      void error;\n    }\n  }\n  return array;\n}\n\nfunction cloneArray(array) {\n  if (!array) {\n    return [];\n  }\n  try {\n    return Array.prototype.slice.call(array);\n  } catch (error) {\n    void error;\n  }\n  const clone = [];\n  for (let index = 0; index < array.length; index += 1) {\n    clone[index] = array[index];\n  }\n  return clone;\n}\n\nfunction createPrimaryCache() {\n  return {\n    objects: typeof WeakMap === 'function' ? new WeakMap() : null,\n    primitives: Object.create(null),\n    empty: null,\n  };\n}\n\nfunction getPrimaryCacheEntry(cache, primary) {\n  if (!cache) {\n    return null;\n  }\n\n  if (isObjectLike(primary)) {\n    if (!cache.objects) {\n      return null;\n    }\n    let entry = cache.objects.get(primary);\n    if (!entry) {\n      entry = { cached: false, value: null };\n      cache.objects.set(primary, entry);\n    }\n    return entry;\n  }\n\n  const key = typeof primary + ':' + String(primary);\n  let entry = cache.primitives[key];\n  if (!entry) {\n    entry = { cached: false, value: null };\n    cache.primitives[key] = entry;\n  }\n  return entry;\n}\n\nfunction pushUnique(target, value) {\n  if (!isObjectLike(value)) {\n    return;\n  }\n  if (target.indexOf(value) === -1) {\n    target.push(value);\n  }\n}\n\nconst BASE_SCOPES = (function buildBaseScopes() {\n  const scopes = [];\n  pushUnique(scopes, typeof globalThis !== 'undefined' ? globalThis : null);\n  pushUnique(scopes, typeof window !== 'undefined' ? window : null);\n  pushUnique(scopes, typeof self !== 'undefined' ? self : null);\n  pushUnique(scopes, typeof global !== 'undefined' ? global : null);\n  return freezeArray(scopes);\n})();\n\nconst EMPTY_EXTRAS = freezeArray([]);\nconst SUPPORTS_WEAKMAP = typeof WeakMap === 'function';\nconst DETECT_CACHE = SUPPORTS_WEAKMAP ? new WeakMap() : null;\n\nfunction sanitizeExtras(extras) {\n  if (!Array.isArray(extras) || extras.length === 0) {\n    return EMPTY_EXTRAS;\n  }\n\n  const sanitized = [];\n  for (let index = 0; index < extras.length; index += 1) {\n    pushUnique(sanitized, extras[index]);\n  }\n\n  if (sanitized.length === 0) {\n    return EMPTY_EXTRAS;\n  }\n\n  return freezeArray(sanitized);\n}\n\nfunction computeCandidateScopes(primary, detectFn, extrasList) {\n  const scopes = [];\n  pushUnique(scopes, primary);\n\n  let detected = null;\n  if (typeof detectFn === 'function') {\n    try {\n      detected = detectFn();\n    } catch (error) {\n      void error;\n      detected = null;\n    }\n  }\n  pushUnique(scopes, detected);\n\n  for (let index = 0; index < BASE_SCOPES.length; index += 1) {\n    pushUnique(scopes, BASE_SCOPES[index]);\n  }\n\n  if (Array.isArray(extrasList)) {\n    for (let index = 0; index < extrasList.length; index += 1) {\n      pushUnique(scopes, extrasList[index]);\n    }\n  }\n\n  return freezeArray(scopes);\n}\n\nfunction getExtrasCache(detectEntry, extrasList) {\n  if (!detectEntry) {\n    return null;\n  }\n\n  if (extrasList === EMPTY_EXTRAS) {\n    if (!detectEntry.empty) {\n      detectEntry.empty = createPrimaryCache();\n    }\n    return detectEntry.empty;\n  }\n\n  if (!detectEntry.extras) {\n    if (!SUPPORTS_WEAKMAP) {\n      return null;\n    }\n    detectEntry.extras = new WeakMap();\n  }\n\n  let extrasEntry = detectEntry.extras.get(extrasList);\n  if (!extrasEntry) {\n    extrasEntry = createPrimaryCache();\n    detectEntry.extras.set(extrasList, extrasEntry);\n  }\n  return extrasEntry;\n}\n\nfunction getDetectEntry(detectFn) {\n  if (!DETECT_CACHE) {\n    return null;\n  }\n\n  let entry = DETECT_CACHE.get(detectFn);\n  if (!entry) {\n    entry = { empty: null, extras: null };\n    DETECT_CACHE.set(detectFn, entry);\n  }\n  return entry;\n}\n\nfunction collectInternal(primary, detectFn, extrasList, cacheEntry) {\n  if (cacheEntry) {\n    const primaryEntry = getPrimaryCacheEntry(cacheEntry, primary);\n    if (primaryEntry) {\n      if (primaryEntry.cached) {\n        return cloneArray(primaryEntry.value);\n      }\n      const computed = computeCandidateScopes(primary, detectFn, extrasList);\n      primaryEntry.value = computed;\n      primaryEntry.cached = true;\n      return cloneArray(computed);\n    }\n  }\n\n  const computedFallback = computeCandidateScopes(primary, detectFn, extrasList);\n  return cloneArray(computedFallback);\n}\n\nexport function createCollector(options) {\n  const detectFn = options && typeof options.detectGlobalScope === 'function'\n    ? options.detectGlobalScope\n    : detectGlobalScope;\n  const extrasList = sanitizeExtras(options && options.additionalScopes);\n  const detectEntry = getDetectEntry(detectFn);\n  const cacheEntry = getExtrasCache(detectEntry, extrasList);\n\n  return function collectWithPreset(primary) {\n    return collectInternal(primary, detectFn, extrasList, cacheEntry);\n  };\n}\n\nexport function collectCandidateScopes(primary, options) {\n  const collector = createCollector(options || {});\n  return collector(primary);\n}\n\nexport function getBaseScopes() {\n  return cloneArray(BASE_SCOPES);\n}\n\n// Global Assignment for Legacy Compatibility\nconst GLOBAL_SCOPE = detectGlobalScope();\n\nif (GLOBAL_SCOPE && !GLOBAL_SCOPE.__cineScopeCollector) {\n  GLOBAL_SCOPE.__cineScopeCollector = {\n    collectCandidateScopes,\n    createCollector,\n    getBaseScopes,\n  };\n}\n","import { createCollector } from './helpers/scope-collector.js';\n\nconst DEFAULT_PENDING_QUEUE_KEY = '__cinePendingModuleRegistrations__';\n\nfunction fallbackDetectGlobalScope() {\n  if (typeof globalThis !== 'undefined') {\n    return globalThis;\n  }\n  if (typeof window !== 'undefined') {\n    return window;\n  }\n  if (typeof self !== 'undefined') {\n    return self;\n  }\n  if (typeof global !== 'undefined') {\n    return global;\n  }\n  return {};\n}\n\nfunction installSafeConsoleGuards(scope) {\n  const targetScope = scope || fallbackDetectGlobalScope();\n  if (!targetScope || (typeof targetScope !== 'object' && typeof targetScope !== 'function')) {\n    return;\n  }\n\n  let consoleRef = null;\n  try {\n    consoleRef = targetScope.console || null;\n  } catch (error) {\n    consoleRef = null;\n    void error;\n  }\n\n  if (!consoleRef || (typeof consoleRef !== 'object' && typeof consoleRef !== 'function')) {\n    return;\n  }\n\n  const methods = ['log', 'warn', 'error', 'info', 'debug'];\n  let originals = null;\n\n  try {\n    originals = consoleRef.__cineSafeConsoleOriginals || null;\n  } catch (error) {\n    originals = null;\n    void error;\n  }\n\n  if (!originals || typeof originals !== 'object') {\n    originals = {};\n    try {\n      Object.defineProperty(consoleRef, '__cineSafeConsoleOriginals', {\n        configurable: true,\n        enumerable: false,\n        writable: true,\n        value: originals,\n      });\n    } catch (defineError) {\n      try {\n        consoleRef.__cineSafeConsoleOriginals = originals;\n      } catch (assignError) {\n        void assignError;\n      }\n      void defineError;\n    }\n  }\n\n  for (let index = 0; index < methods.length; index += 1) {\n    const method = methods[index];\n    let candidate = null;\n    try {\n      candidate = consoleRef[method];\n    } catch (error) {\n      candidate = null;\n      void error;\n    }\n\n    if (typeof candidate !== 'function') {\n      continue;\n    }\n\n    if (candidate && candidate.__cineSafeConsoleGuard) {\n      continue;\n    }\n\n    if (!Object.prototype.hasOwnProperty.call(originals, method)) {\n      originals[method] = candidate;\n    }\n\n    const guarded = function cineSafeConsoleGuard() {\n      try {\n        return candidate.apply(consoleRef, arguments);\n      } catch (error) {\n        void error;\n      }\n      return undefined;\n    };\n\n    try {\n      Object.defineProperty(guarded, '__cineSafeConsoleGuard', {\n        configurable: true,\n        enumerable: false,\n        writable: false,\n        value: true,\n      });\n    } catch (defineError) {\n      guarded.__cineSafeConsoleGuard = true;\n      void defineError;\n    }\n\n    try {\n      consoleRef[method] = guarded;\n    } catch (error) {\n      void error;\n    }\n  }\n}\n\nconst createScopeCollector = createCollector;\n\nconst DEFAULT_EXTRAS_KEY = { key: 'defaultExtras' };\nconst HELPER_COLLECTOR_CACHE = [];\nconst BASE_SCOPE_EXTRAS_CACHE = typeof WeakMap === 'function' ? new WeakMap() : [];\n\nfunction resolveExtrasForBaseScope(baseScope) {\n  if (!baseScope || (typeof baseScope !== 'object' && typeof baseScope !== 'function')) {\n    return undefined;\n  }\n\n  if (BASE_SCOPE_EXTRAS_CACHE && typeof BASE_SCOPE_EXTRAS_CACHE.get === 'function') {\n    let extras = BASE_SCOPE_EXTRAS_CACHE.get(baseScope);\n    if (!extras) {\n      extras = [baseScope];\n      BASE_SCOPE_EXTRAS_CACHE.set(baseScope, extras);\n    }\n    return extras;\n  }\n\n  for (let index = 0; index < BASE_SCOPE_EXTRAS_CACHE.length; index += 1) {\n    const entry = BASE_SCOPE_EXTRAS_CACHE[index];\n    if (entry.scope === baseScope) {\n      return entry.extras;\n    }\n  }\n\n  const extras = [baseScope];\n  BASE_SCOPE_EXTRAS_CACHE.push({ scope: baseScope, extras });\n  return extras;\n}\n\nfunction resolveHelperCollector(detectFn, extras) {\n  if (!createScopeCollector) {\n    return null;\n  }\n\n  const extrasKey = Array.isArray(extras) ? extras : DEFAULT_EXTRAS_KEY;\n\n  for (let index = 0; index < HELPER_COLLECTOR_CACHE.length; index += 1) {\n    const entry = HELPER_COLLECTOR_CACHE[index];\n    if (entry.detect === detectFn && entry.extras === extrasKey) {\n      return entry.collector;\n    }\n  }\n\n  const collector = createScopeCollector({\n    detectGlobalScope: detectFn,\n    additionalScopes: Array.isArray(extras) ? extras : undefined,\n  });\n\n  if (collector) {\n    HELPER_COLLECTOR_CACHE.push({ detect: detectFn, extras: extrasKey, collector });\n    return collector;\n  }\n\n  return null;\n}\n\nfunction fallbackCollectCandidateScopes(primary, baseScope) {\n  const resolvedBaseScope = baseScope || fallbackDetectGlobalScope();\n  const extras = resolveExtrasForBaseScope(resolvedBaseScope);\n  const collector = resolveHelperCollector(fallbackDetectGlobalScope, extras);\n  if (collector) {\n    return collector(primary || resolvedBaseScope);\n  }\n\n  const scopes = [];\n\n  function pushScope(scope) {\n    if (!scope || (typeof scope !== 'object' && typeof scope !== 'function')) {\n      return;\n    }\n    if (scopes.indexOf(scope) === -1) {\n      scopes.push(scope);\n    }\n  }\n\n  pushScope(primary || resolvedBaseScope);\n  if (typeof globalThis !== 'undefined') pushScope(globalThis);\n  if (typeof window !== 'undefined') pushScope(window);\n  if (typeof self !== 'undefined') pushScope(self);\n  if (typeof global !== 'undefined') pushScope(global);\n\n  return scopes;\n}\n\nfunction fallbackTryRequire(modulePath) {\n  // In ESM build, require is not available dynamically in the same way.\n  // We return null to fallback to global resolution.\n  return null;\n}\n\nfunction fallbackDefineHiddenProperty(target, name, value) {\n  if (!target || (typeof target !== 'object' && typeof target !== 'function')) {\n    return false;\n  }\n\n  try {\n    Object.defineProperty(target, name, {\n      configurable: true,\n      enumerable: false,\n      writable: true,\n      value,\n    });\n    return true;\n  } catch (error) {\n    void error;\n  }\n\n  try {\n    target[name] = value;\n    return true;\n  } catch (assignmentError) {\n    void assignmentError;\n  }\n\n  return false;\n}\n\nfunction fallbackEnsureQueue(scope, key, baseScope) {\n  const targetScope = scope || baseScope;\n  const queueKey = typeof key === 'string' && key ? key : DEFAULT_PENDING_QUEUE_KEY;\n\n  if (!targetScope || typeof targetScope !== 'object') {\n    return null;\n  }\n\n  let queue = targetScope[queueKey];\n  if (Array.isArray(queue)) {\n    return queue;\n  }\n\n  if (!fallbackDefineHiddenProperty(targetScope, queueKey, [])) {\n    return null;\n  }\n\n  queue = targetScope[queueKey];\n  if (!Array.isArray(queue)) {\n    return null;\n  }\n\n  return queue;\n}\n\nconst BUILTIN_IMMUTABILITY = (function resolveBuiltinImmutability() {\n  const registryKey = '__cineBuiltinImmutabilityGuards__';\n  const scopes = fallbackCollectCandidateScopes(null, fallbackDetectGlobalScope());\n\n  // Require removed for ESM conversion\n\n  for (let index = 0; index < scopes.length; index += 1) {\n    const scope = scopes[index];\n    if (!scope || (typeof scope !== 'object' && typeof scope !== 'function')) {\n      continue;\n    }\n\n    try {\n      const candidate = scope[registryKey];\n      if (candidate && typeof candidate === 'object') {\n        return candidate;\n      }\n    } catch (error) {\n      void error;\n    }\n  }\n\n  return null;\n})();\n\nfunction isEthereumProviderCandidate(value) {\n  if (!value || typeof value === 'function' || (typeof value !== 'object' && typeof value !== 'function')) {\n    return false;\n  }\n\n  if (PRIMARY_SCOPE && typeof PRIMARY_SCOPE === 'object') {\n    try {\n      if (value === PRIMARY_SCOPE.ethereum) {\n        return true;\n      }\n    } catch (error) {\n      void error;\n      return true;\n    }\n  }\n\n  try {\n    if (value.isMetaMask === true) {\n      return true;\n    }\n  } catch (inspectionError) {\n    if (inspectionError && typeof inspectionError.message === 'string' && /metamask/i.test(inspectionError.message)) {\n      return true;\n    }\n  }\n\n  try {\n    if (typeof value.request === 'function' && typeof value.on === 'function') {\n      if (typeof value.removeListener === 'function' || typeof value.removeEventListener === 'function') {\n        return true;\n      }\n\n      const ctorName = value.constructor && value.constructor.name;\n      if (ctorName && /Ethereum|MetaMask|Provider/i.test(ctorName)) {\n        return true;\n      }\n    }\n  } catch (accessError) {\n    void accessError;\n    return true;\n  }\n\n  return false;\n}\n\nfunction isNodeProcessReference(value) {\n  if (!value) {\n    return false;\n  }\n\n  if (typeof process === 'undefined' || !process) {\n    return false;\n  }\n\n  if (value === process) {\n    return true;\n  }\n\n  if (typeof value === 'object') {\n    try {\n      if (value.constructor && value.constructor.name === 'process') {\n        return true;\n      }\n    } catch (processInspectionError) {\n      void processInspectionError;\n    }\n\n    if (\n      typeof value.pid === 'number' &&\n      typeof value.nextTick === 'function' &&\n      typeof value.emit === 'function' &&\n      typeof value.binding === 'function'\n    ) {\n      return true;\n    }\n  }\n\n  if (typeof value === 'function') {\n    if (\n      value === process.binding ||\n      value === process._linkedBinding ||\n      value === process.dlopen\n    ) {\n      return true;\n    }\n\n    try {\n      const functionName = value.name || '';\n      if (functionName && (functionName === 'binding' || functionName === 'dlopen')) {\n        const source = Function.prototype.toString.call(value);\n        if (source && source.indexOf('[native code]') !== -1) {\n          return true;\n        }\n      }\n    } catch (functionInspectionError) {\n      void functionInspectionError;\n    }\n  }\n\n  return false;\n}\n\nfunction shouldBypassDeepFreeze(value) {\n  if (!value || typeof value === 'function' || (typeof value !== 'object' && typeof value !== 'function')) {\n    return false;\n  }\n\n  if (isNodeProcessReference(value)) {\n    return true;\n  }\n\n  if (\n    typeof value === 'object' &&\n    value &&\n    typeof value.id === 'string' &&\n    typeof value.filename === 'string' &&\n    (typeof value.loaded === 'boolean' || Array.isArray(value.children))\n  ) {\n    return true;\n  }\n\n  if (\n    typeof process !== 'undefined' &&\n    process &&\n    process.release &&\n    process.release.name === 'node'\n  ) {\n    return true;\n  }\n\n  try {\n    if (\n      BUILTIN_IMMUTABILITY &&\n      typeof BUILTIN_IMMUTABILITY.isImmutableBuiltin === 'function' &&\n      BUILTIN_IMMUTABILITY.isImmutableBuiltin(value)\n    ) {\n      return true;\n    }\n\n    if (typeof value.pipe === 'function' && typeof value.unpipe === 'function') {\n      return true;\n    }\n\n    if (typeof value.on === 'function' && typeof value.emit === 'function') {\n      if (typeof value.write === 'function' || typeof value.read === 'function') {\n        return true;\n      }\n\n      const ctorName = value.constructor && value.constructor.name;\n      if (ctorName && /Stream|Emitter|Port/i.test(ctorName)) {\n        return true;\n      }\n    }\n\n    if (typeof Symbol !== 'undefined' && value[Symbol.toStringTag]) {\n      const tag = value[Symbol.toStringTag];\n      if (typeof tag === 'string' && /Stream|Port/i.test(tag)) {\n        return true;\n      }\n    }\n  } catch (inspectionError) {\n    void inspectionError;\n  }\n\n  return false;\n}\n\nfunction fallbackResolveSeenTracker(seen) {\n  if (seen && typeof seen.has === 'function' && typeof seen.add === 'function') {\n    return seen;\n  }\n\n  if (Array.isArray(seen)) {\n    return {\n      has(value) {\n        return seen.indexOf(value) !== -1;\n      },\n      add(value) {\n        if (seen.indexOf(value) === -1) {\n          seen.push(value);\n        }\n      },\n    };\n  }\n\n  if (typeof WeakSet === 'function') {\n    try {\n      return new WeakSet();\n    } catch (trackerError) {\n      void trackerError;\n    }\n  }\n\n  const tracked = [];\n  return {\n    has(value) {\n      return tracked.indexOf(value) !== -1;\n    },\n    add(value) {\n      if (tracked.indexOf(value) === -1) {\n        tracked.push(value);\n      }\n    },\n  };\n}\n\nfunction fallbackFreezeDeep(value, seen) {\n  if (!value || typeof value === 'function' || (typeof value !== 'object' && typeof value !== 'function')) {\n    return value;\n  }\n\n  if (shouldBypassDeepFreeze(value) || isEthereumProviderCandidate(value)) {\n    return value;\n  }\n\n  if (typeof value === 'function') {\n    try {\n      return Object.freeze(value);\n    } catch (freezeError) {\n      void freezeError;\n      return value;\n    }\n  }\n\n  const tracker = fallbackResolveSeenTracker(seen);\n\n  if (tracker.has(value)) {\n    return value;\n  }\n\n  tracker.add(value);\n\n  let keys;\n  try {\n    keys = Object.getOwnPropertyNames(value);\n  } catch (error) {\n    void error;\n    return value;\n  }\n  for (let index = 0; index < keys.length; index += 1) {\n    const key = keys[index];\n\n    let descriptor;\n    try {\n      descriptor = Object.getOwnPropertyDescriptor(value, key);\n    } catch (descriptorError) {\n      void descriptorError;\n      descriptor = null;\n    }\n\n    if (\n      descriptor &&\n      (typeof descriptor.get === 'function' || typeof descriptor.set === 'function')\n    ) {\n      continue;\n    }\n\n    let child;\n    try {\n      child = value[key];\n    } catch (accessError) {\n      void accessError;\n      child = undefined;\n    }\n    if (!child || typeof child === 'function' || (typeof child !== 'object' && typeof child !== 'function')) {\n      continue;\n    }\n\n    if (shouldBypassDeepFreeze(child) || isEthereumProviderCandidate(child)) {\n      continue;\n    }\n\n    fallbackFreezeDeep(child, tracker);\n  }\n\n  try {\n    return Object.freeze(value);\n  } catch (freezeError) {\n    void freezeError;\n    return value;\n  }\n}\n\nfunction fallbackSafeWarn(message, detail) {\n  if (typeof console === 'undefined' || typeof console.warn !== 'function') {\n    return;\n  }\n\n  try {\n    if (typeof detail === 'undefined') {\n      console.warn(message);\n    } else {\n      console.warn(message, detail);\n    }\n  } catch (error) {\n    void error;\n  }\n}\n\nfunction fallbackResolveModuleRegistry(scope, baseScope) {\n  const targetScope = scope || baseScope;\n\n  const required = fallbackTryRequire('./registry.js');\n  if (required && typeof required === 'object') {\n    return required;\n  }\n\n  const scopes = fallbackCollectCandidateScopes(targetScope, baseScope);\n  for (let index = 0; index < scopes.length; index += 1) {\n    const candidate = scopes[index];\n    if (candidate && typeof candidate.cineModules === 'object') {\n      return candidate.cineModules;\n    }\n  }\n\n  return null;\n}\n\nfunction fallbackQueueModuleRegistration(scope, name, api, options, baseScope) {\n  const targetScope = scope || baseScope;\n  const queue = fallbackEnsureQueue(targetScope, DEFAULT_PENDING_QUEUE_KEY, baseScope);\n  if (!queue) {\n    return false;\n  }\n\n  const payload = Object.freeze({\n    name,\n    api,\n    options: Object.freeze({ ...(options || {}) }),\n  });\n\n  try {\n    queue.push(payload);\n    return true;\n  } catch (error) {\n    void error;\n  }\n\n  try {\n    queue[queue.length] = payload;\n    return true;\n  } catch (assignmentError) {\n    void assignmentError;\n  }\n\n  return false;\n}\n\nfunction createFallbackKernel(primaryScope) {\n  const baseScope = primaryScope || fallbackDetectGlobalScope();\n\n  return {\n    detectGlobalScope: fallbackDetectGlobalScope,\n    getGlobalScope() {\n      return baseScope;\n    },\n    collectCandidateScopes(primary) {\n      return fallbackCollectCandidateScopes(primary || baseScope, baseScope);\n    },\n    tryRequire: fallbackTryRequire,\n    defineHiddenProperty: fallbackDefineHiddenProperty,\n    ensureQueue(scope, key) {\n      return fallbackEnsureQueue(scope || baseScope, key, baseScope);\n    },\n    freezeDeep: fallbackFreezeDeep,\n    safeWarn: fallbackSafeWarn,\n    resolveModuleRegistry(scope) {\n      return fallbackResolveModuleRegistry(scope || baseScope, baseScope);\n    },\n    queueModuleRegistration(scope, name, api, options) {\n      return fallbackQueueModuleRegistration(scope || baseScope, name, api, options, baseScope);\n    },\n    getPendingQueueKey() {\n      return DEFAULT_PENDING_QUEUE_KEY;\n    },\n  };\n}\n\nfunction resolveArchitectureKernel(scope) {\n  const targetScope = scope || fallbackDetectGlobalScope();\n\n  // Require removed for ESM conversion\n\n  if (targetScope && typeof targetScope.cineModuleArchitectureKernel === 'object') {\n    return targetScope.cineModuleArchitectureKernel;\n  }\n\n  return null;\n}\n\nconst LOCAL_SCOPE = fallbackDetectGlobalScope();\ninstallSafeConsoleGuards(LOCAL_SCOPE);\nconst RESOLVED_KERNEL = resolveArchitectureKernel(LOCAL_SCOPE);\nconst ACTIVE_KERNEL = RESOLVED_KERNEL || createFallbackKernel(LOCAL_SCOPE);\n\nfunction detectGlobalScope() {\n  if (ACTIVE_KERNEL && typeof ACTIVE_KERNEL.detectGlobalScope === 'function') {\n    try {\n      const detected = ACTIVE_KERNEL.detectGlobalScope();\n      if (detected) {\n        return detected;\n      }\n    } catch (error) {\n      void error;\n    }\n  }\n  return fallbackDetectGlobalScope();\n}\n\nconst PRIMARY_SCOPE =\n  ACTIVE_KERNEL && typeof ACTIVE_KERNEL.getGlobalScope === 'function'\n    ? (function resolvePrimaryScope() {\n      try {\n        const scoped = ACTIVE_KERNEL.getGlobalScope();\n        if (scoped) {\n          return scoped;\n        }\n      } catch (error) {\n        void error;\n      }\n      return detectGlobalScope();\n    })()\n    : detectGlobalScope();\n\nconst PENDING_QUEUE_KEY =\n  ACTIVE_KERNEL && typeof ACTIVE_KERNEL.getPendingQueueKey === 'function'\n    ? ACTIVE_KERNEL.getPendingQueueKey()\n    : DEFAULT_PENDING_QUEUE_KEY;\n\nfunction collectCandidateScopes(primary) {\n  if (ACTIVE_KERNEL && typeof ACTIVE_KERNEL.collectCandidateScopes === 'function') {\n    try {\n      const collected = ACTIVE_KERNEL.collectCandidateScopes(primary || PRIMARY_SCOPE);\n      if (Array.isArray(collected) && collected.length > 0) {\n        return collected;\n      }\n    } catch (error) {\n      void error;\n    }\n  }\n  return fallbackCollectCandidateScopes(primary || PRIMARY_SCOPE, PRIMARY_SCOPE);\n}\n\nfunction baseTryRequire(modulePath) {\n  if (ACTIVE_KERNEL && typeof ACTIVE_KERNEL.tryRequire === 'function') {\n    try {\n      const result = ACTIVE_KERNEL.tryRequire(modulePath);\n      if (typeof result !== 'undefined') {\n        return result;\n      }\n    } catch (error) {\n      void error;\n    }\n  }\n\n  return fallbackTryRequire(modulePath);\n}\n\nfunction baseResolveModuleRegistry(scope) {\n  const targetScope = scope || PRIMARY_SCOPE;\n\n  if (ACTIVE_KERNEL && typeof ACTIVE_KERNEL.resolveModuleRegistry === 'function') {\n    try {\n      const resolved = ACTIVE_KERNEL.resolveModuleRegistry(targetScope);\n      if (resolved && typeof resolved === 'object') {\n        return resolved;\n      }\n    } catch (error) {\n      void error;\n    }\n  }\n\n  const required = baseTryRequire('./registry.js');\n  if (required && typeof required === 'object') {\n    return required;\n  }\n\n  const scopes = collectCandidateScopes(targetScope);\n  for (let index = 0; index < scopes.length; index += 1) {\n    const candidate = scopes[index];\n    if (candidate && typeof candidate.cineModules === 'object') {\n      return candidate.cineModules;\n    }\n  }\n\n  return null;\n}\n\nlet cachedModuleRegistry = null;\nlet hasResolvedRegistry = false;\n\nfunction getModuleRegistry(scope) {\n  if (!hasResolvedRegistry || (scope && scope !== PRIMARY_SCOPE)) {\n    const resolved = baseResolveModuleRegistry(scope);\n    if (scope && scope !== PRIMARY_SCOPE) {\n      return resolved;\n    }\n    cachedModuleRegistry = resolved;\n    hasResolvedRegistry = true;\n  }\n\n  return cachedModuleRegistry;\n}\n\nfunction ensureQueue(scope) {\n  const targetScope = scope || PRIMARY_SCOPE;\n\n  if (ACTIVE_KERNEL && typeof ACTIVE_KERNEL.ensureQueue === 'function') {\n    try {\n      const queue = ACTIVE_KERNEL.ensureQueue(targetScope, PENDING_QUEUE_KEY);\n      if (Array.isArray(queue)) {\n        return queue;\n      }\n    } catch (error) {\n      void error;\n    }\n  }\n\n  return fallbackEnsureQueue(targetScope, PENDING_QUEUE_KEY, PRIMARY_SCOPE);\n}\n\nfunction queueModuleRegistration(scope, name, api, options) {\n  const targetScope = scope || PRIMARY_SCOPE;\n\n  if (ACTIVE_KERNEL && typeof ACTIVE_KERNEL.queueModuleRegistration === 'function') {\n    try {\n      if (ACTIVE_KERNEL.queueModuleRegistration(targetScope, name, api, options)) {\n        return true;\n      }\n    } catch (error) {\n      void error;\n    }\n  }\n\n  const queue = ensureQueue(targetScope);\n  if (!queue) {\n    return false;\n  }\n\n  const payload = Object.freeze({\n    name,\n    api,\n    options: Object.freeze({ ...(options || {}) }),\n  });\n\n  try {\n    queue.push(payload);\n  } catch (error) {\n    void error;\n    queue[queue.length] = payload;\n  }\n\n  return true;\n}\n\nfunction baseRegisterOrQueueModule(scope, registry, name, api, options, onError) {\n  if (registry && typeof registry.register === 'function') {\n    try {\n      registry.register(name, api, options);\n      return true;\n    } catch (error) {\n      if (typeof onError === 'function') {\n        onError(error);\n      } else {\n        void error;\n      }\n    }\n  }\n\n  queueModuleRegistration(scope, name, api, options);\n  return false;\n}\n\nfunction baseFreezeDeep(value) {\n  if (!value || typeof value === 'function' || (typeof value !== 'object' && typeof value !== 'function')) {\n    return value;\n  }\n\n  if (shouldBypassDeepFreeze(value) || isEthereumProviderCandidate(value)) {\n    return value;\n  }\n\n  if (ACTIVE_KERNEL && typeof ACTIVE_KERNEL.freezeDeep === 'function') {\n    try {\n      return ACTIVE_KERNEL.freezeDeep(value);\n    } catch (error) {\n      void error;\n    }\n  }\n\n  return fallbackFreezeDeep(value);\n}\n\nfunction baseSafeWarn(message, detail) {\n  if (ACTIVE_KERNEL && typeof ACTIVE_KERNEL.safeWarn === 'function') {\n    try {\n      ACTIVE_KERNEL.safeWarn(message, detail);\n      return;\n    } catch (error) {\n      void error;\n    }\n  }\n\n  fallbackSafeWarn(message, detail);\n}\n\nfunction exposeGlobal(name, value, scope, options = {}) {\n  const targetScope = scope || PRIMARY_SCOPE;\n  if (!targetScope || typeof targetScope !== 'object') {\n    return false;\n  }\n\n  const descriptor = {\n    configurable: options.configurable !== false,\n    enumerable: !!options.enumerable,\n    value,\n    writable: options.writable === true,\n  };\n\n  try {\n    Object.defineProperty(targetScope, name, descriptor);\n    return true;\n  } catch (error) {\n    void error;\n    try {\n      targetScope[name] = value;\n      return true;\n    } catch (assignmentError) {\n      void assignmentError;\n      return false;\n    }\n  }\n}\n\nconst baseApi = baseFreezeDeep({\n  getGlobalScope() {\n    return PRIMARY_SCOPE;\n  },\n  collectCandidateScopes,\n  tryRequire: baseTryRequire,\n  resolveModuleRegistry: baseResolveModuleRegistry,\n  getModuleRegistry,\n  queueModuleRegistration(name, api, options, scope) {\n    return queueModuleRegistration(scope || PRIMARY_SCOPE, name, api, options);\n  },\n  registerOrQueueModule(name, api, options, onError, scope, registry) {\n    const targetScope = scope || PRIMARY_SCOPE;\n    const moduleRegistry = registry || getModuleRegistry(targetScope);\n    return baseRegisterOrQueueModule(targetScope, moduleRegistry, name, api, options, onError);\n  },\n  freezeDeep: baseFreezeDeep,\n  safeWarn: baseSafeWarn,\n  exposeGlobal,\n  PENDING_QUEUE_KEY,\n});\n\nconst registry = getModuleRegistry();\nbaseRegisterOrQueueModule(\n  PRIMARY_SCOPE,\n  registry,\n  'cineModuleBase',\n  baseApi,\n  {\n    category: 'infrastructure',\n    description: 'Shared helpers for module registration, freezing and safe global exposure.',\n    replace: true,\n    connections: ['cineModuleArchitectureKernel', 'cineModuleArchitectureHelpers'],\n  },\n  (error) => {\n    baseSafeWarn('Unable to register cineModuleBase.', error);\n  },\n);\n\nexposeGlobal('cineModuleBase', baseApi, PRIMARY_SCOPE, { configurable: true, enumerable: false, writable: false });\n\nexport default baseApi;\nexport { baseApi as cineModuleBase };\n","/**\n * The registry is the shared phone book for every module that bootstraps the\n * planner. Comments throughout the file explain why we cache the lookups and\n * which safeguards keep user data utilities from being redefined by accident.\n */\nconst GLOBAL_SCOPE =\n  typeof globalThis !== 'undefined'\n    ? globalThis\n    : typeof window !== 'undefined'\n      ? window\n      : typeof self !== 'undefined'\n        ? self\n        : typeof global !== 'undefined'\n          ? global\n          : {};\n\nlet ensureConsoleMethodsWritable = null;\n\nif (\n  !ensureConsoleMethodsWritable\n  && GLOBAL_SCOPE\n  && typeof GLOBAL_SCOPE.__cineEnsureConsoleMethodsWritable === 'function'\n) {\n  ensureConsoleMethodsWritable = GLOBAL_SCOPE.__cineEnsureConsoleMethodsWritable;\n}\n\nif (typeof ensureConsoleMethodsWritable === 'function') {\n  ensureConsoleMethodsWritable(['warn', 'info']);\n}\n\nconst PENDING_QUEUE_KEY = '__cinePendingModuleRegistrations__';\nconst QUEUE_FLUSH_TIMER_KEY = '__cinePendingModuleRegistrationsTimer__';\n\nlet moduleMap = Object.create(null);\nlet metadataMap = Object.create(null);\nlet registryReference = null;\n\n/**\n * Discover the immutability helpers that freeze exported APIs. We perform the\n * same guarded probing used across the codebase so the registry works in\n * browsers, workers and tests without assuming a specific runtime.\n */\nfunction resolveImmutability(scope) {\n  const targetScope = scope || GLOBAL_SCOPE;\n\n  const scopes = [targetScope];\n  if (typeof globalThis !== 'undefined' && scopes.indexOf(globalThis) === -1) scopes.push(globalThis);\n  if (typeof window !== 'undefined' && scopes.indexOf(window) === -1) scopes.push(window);\n  if (typeof self !== 'undefined' && scopes.indexOf(self) === -1) scopes.push(self);\n  if (typeof global !== 'undefined' && scopes.indexOf(global) === -1) scopes.push(global);\n\n  for (let index = 0; index < scopes.length; index += 1) {\n    const candidate = scopes[index];\n    if (candidate && typeof candidate.cineModuleImmutability === 'object') {\n      return candidate.cineModuleImmutability;\n    }\n  }\n\n  return null;\n}\n\nconst BUILTIN_IMMUTABILITY = (function resolveBuiltinImmutability() {\n  // Built-in guards are cached on the global scope because they are reused by\n  // multiple modules. Documenting this avoids confusion when debugging deep\n  // freeze issues across different bundles.\n  const registryKey = '__cineBuiltinImmutabilityGuards__';\n  const scopes = [GLOBAL_SCOPE];\n  if (typeof globalThis !== 'undefined' && globalThis !== GLOBAL_SCOPE) scopes.push(globalThis);\n  if (typeof window !== 'undefined') scopes.push(window);\n  if (typeof self !== 'undefined') scopes.push(self);\n  if (typeof global !== 'undefined') scopes.push(global);\n\n  for (let index = 0; index < scopes.length; index += 1) {\n    const scope = scopes[index];\n    if (!scope || (typeof scope !== 'object' && typeof scope !== 'function')) {\n      continue;\n    }\n\n    try {\n      const candidate = scope[registryKey];\n      if (candidate && typeof candidate === 'object') {\n        return candidate;\n      }\n    } catch (error) {\n      void error;\n    }\n  }\n\n  return null;\n})();\n\nfunction createFallbackImmutability() {\n  // The fallback freeze logic imitates the helper shipped with the modern\n  // runtime. extensive inline comments make it clear why certain objects such\n  // as streams are excluded from freezing: mutating them is necessary for\n  // Node-based tooling and does not impact project persistence.\n  function shouldBypass(value) {\n    if (!value || typeof value === 'function' || (typeof value !== 'object' && typeof value !== 'function')) {\n      return false;\n    }\n\n    try {\n      if (\n        BUILTIN_IMMUTABILITY &&\n        typeof BUILTIN_IMMUTABILITY.isImmutableBuiltin === 'function' &&\n        BUILTIN_IMMUTABILITY.isImmutableBuiltin(value)\n      ) {\n        return true;\n      }\n\n      if (typeof value.pipe === 'function' && typeof value.unpipe === 'function') {\n        return true;\n      }\n\n      if (typeof value.on === 'function' && typeof value.emit === 'function') {\n        if (typeof value.write === 'function' || typeof value.read === 'function') {\n          return true;\n        }\n\n        const ctorName = value.constructor && value.constructor.name;\n        if (ctorName && /Stream|Emitter|Port/i.test(ctorName)) {\n          return true;\n        }\n      }\n\n      if (typeof Symbol !== 'undefined' && value[Symbol.toStringTag]) {\n        const tag = value[Symbol.toStringTag];\n        if (typeof tag === 'string' && /Stream|Port/i.test(tag)) {\n          return true;\n        }\n      }\n    } catch (inspectionError) {\n      void inspectionError;\n    }\n\n    return false;\n  }\n\n  function freeze(value, seen = new WeakSet()) {\n    if (!value || typeof value === 'function' || (typeof value !== 'object' && typeof value !== 'function')) {\n      return value;\n    }\n\n    if (shouldBypass(value)) {\n      return value;\n    }\n\n    if (seen.has(value)) {\n      return value;\n    }\n\n    seen.add(value);\n\n    const keys = Object.getOwnPropertyNames(value);\n    for (let index = 0; index < keys.length; index += 1) {\n      const key = keys[index];\n      let child;\n      try {\n        child = value[key];\n      } catch (accessError) {\n        void accessError;\n        child = undefined;\n      }\n      if (!child || typeof child === 'function' || (typeof child !== 'object' && typeof child !== 'function')) {\n        continue;\n      }\n      freeze(child, seen);\n    }\n\n    try {\n      return Object.freeze(value);\n    } catch (freezeError) {\n      void freezeError;\n      return value;\n    }\n  }\n\n  return {\n    shouldBypassDeepFreeze: shouldBypass,\n    freezeDeep: freeze,\n  };\n}\n\nconst FALLBACK_IMMUTABILITY = createFallbackImmutability();\nlet activeImmutability = resolveImmutability(GLOBAL_SCOPE) || FALLBACK_IMMUTABILITY;\n\nfunction getImmutability() {\n  if (activeImmutability !== FALLBACK_IMMUTABILITY) {\n    return activeImmutability;\n  }\n\n  const resolved = resolveImmutability(GLOBAL_SCOPE);\n  if (resolved && resolved !== activeImmutability) {\n    activeImmutability = resolved;\n  }\n\n  return activeImmutability;\n}\n\nfunction freezeDeep(value, seen) {\n  const provider = getImmutability();\n\n  try {\n    return provider.freezeDeep(value, seen);\n  } catch (error) {\n    void error;\n  }\n\n  return FALLBACK_IMMUTABILITY.freezeDeep(value, seen);\n}\n\nfunction normalizeName(name) {\n  if (typeof name === 'string') {\n    const trimmed = name.trim();\n    if (trimmed) {\n      return trimmed;\n    }\n  }\n  throw new TypeError('cineModules.register expected a non-empty string name.');\n}\n\nfunction normalizeConnections(value) {\n  if (value == null) {\n    return [];\n  }\n\n  const entries = Array.isArray(value)\n    ? value\n    : typeof value === 'string'\n      ? [value]\n      : typeof value[Symbol.iterator] === 'function'\n        ? Array.from(value)\n        : [value];\n\n  const seen = new Set();\n  const normalized = [];\n\n  for (let index = 0; index < entries.length; index += 1) {\n    const entry = entries[index];\n    let raw = null;\n\n    if (typeof entry === 'string') {\n      raw = entry;\n    } else if (entry && typeof entry.name === 'string') {\n      raw = entry.name;\n    }\n\n    if (!raw) {\n      continue;\n    }\n\n    const trimmed = raw.trim();\n    if (!trimmed || seen.has(trimmed)) {\n      continue;\n    }\n\n    seen.add(trimmed);\n    normalized.push(trimmed);\n  }\n\n  return normalized;\n}\n\n\n/**\n * Register a Module\n *\n * Publishes a module API to the central registry, making it available to `get()` callers.\n *\n * Mechanisms:\n * 1. NORMALIZATION: \"My Module \" becomes \"My Module\".\n * 2. IMMUTABILITY: By default, the API object is Deep Frozen to prevent other modules from accidentally mutating it.\n * 3. CONFLICT CHECK: Throws if a module with the same name exists (unless `replace: true` is specified), ensuring consistency.\n * 4. METADATA: Stores descriptive metadata (category, description, connections) separately from the runtime logic.\n *\n * @param {string} name - Unique identifier for the module.\n * @param {object} moduleApi - The public interface of the module.\n * @param {object} [options] - Configuration (freeze, replace, description, etc).\n * @returns {object} - The (potentially frozen) module API.\n */\nfunction register(name, moduleApi, options = {}) {\n  const normalizedName = normalizeName(name);\n\n  if (!moduleApi || (typeof moduleApi !== 'object' && typeof moduleApi !== 'function')) {\n    throw new TypeError(`cineModules.register(\"${normalizedName}\") expected an object or function.`);\n  }\n\n  const freeze = options.freeze !== false;\n  const descriptor = freeze && !Object.isFrozen(moduleApi)\n    ? freezeDeep(moduleApi)\n    : moduleApi;\n\n  if (Object.prototype.hasOwnProperty.call(moduleMap, normalizedName)) {\n    const existing = moduleMap[normalizedName];\n    if (existing === descriptor) {\n      return existing;\n    }\n\n    if (!options.replace) {\n      throw new Error(`cineModules: Module \"${normalizedName}\" is already registered. Use { replace: true } to overwrite.`);\n    }\n  }\n\n  moduleMap[normalizedName] = descriptor;\n  metadataMap[normalizedName] = {\n    description: typeof options.description === 'string' ? options.description.trim() : '',\n    category: typeof options.category === 'string' ? options.category.trim() : '',\n    registeredAt: Date.now(),\n    frozen: freeze,\n    connections: freezeDeep(normalizeConnections(\n      options.connections || options.links || options.dependencies || null,\n    )),\n  };\n\n  return descriptor;\n}\n\n/**\n * Retrieve a Registered Module\n *\n * This is the primary lookup method for inter-module dependencies.\n * - It normalizes names to prevent case/whitespace confusing bugs.\n * - It is O(1) via a hash map lookup (`moduleMap`).\n * - Ideally, consumers should cache the result if used in a hot loop, though the lookup itself is fast.\n *\n * @param {string} name - The name of the module to retrieve.\n * @returns {object|null} - The module API object if found, or null.\n */\nfunction get(name) {\n  const normalizedName = normalizeName(name);\n  return Object.prototype.hasOwnProperty.call(moduleMap, normalizedName)\n    ? moduleMap[normalizedName]\n    : null;\n}\n\nfunction has(name) {\n  const normalizedName = normalizeName(name);\n  return Object.prototype.hasOwnProperty.call(moduleMap, normalizedName);\n}\n\nfunction list() {\n  return Object.freeze(Object.keys(moduleMap).sort());\n}\n\nfunction describe(name) {\n  const normalizedName = normalizeName(name);\n  const meta = metadataMap[normalizedName];\n  if (!meta) {\n    return null;\n  }\n  return Object.freeze({\n    name: normalizedName,\n    description: meta.description,\n    category: meta.category,\n    registeredAt: meta.registeredAt,\n    frozen: meta.frozen,\n    connections: meta.connections || freezeDeep([]),\n  });\n}\n\nfunction normalizeNameCollection(value) {\n  if (value == null) {\n    return null;\n  }\n\n  const entries = Array.isArray(value)\n    ? value\n    : typeof value === 'string'\n      ? [value]\n      : typeof value[Symbol.iterator] === 'function'\n        ? Array.from(value)\n        : [value];\n\n  const normalized = [];\n  const seen = new Set();\n\n  for (let index = 0; index < entries.length; index += 1) {\n    const entry = entries[index];\n\n    try {\n      const normalizedName = normalizeName(entry);\n      if (!seen.has(normalizedName)) {\n        seen.add(normalizedName);\n        normalized.push(normalizedName);\n      }\n    } catch (error) {\n      void error;\n    }\n  }\n\n  return normalized.length > 0 ? normalized : null;\n}\n\nfunction normalizeCategoryCollection(value) {\n  if (value == null) {\n    return null;\n  }\n\n  const entries = Array.isArray(value)\n    ? value\n    : typeof value === 'string'\n      ? [value]\n      : typeof value[Symbol.iterator] === 'function'\n        ? Array.from(value)\n        : [value];\n\n  const normalized = [];\n  const seen = new Set();\n\n  for (let index = 0; index < entries.length; index += 1) {\n    const entry = entries[index];\n    if (typeof entry !== 'string') {\n      continue;\n    }\n\n    const trimmed = entry.trim();\n    if (!trimmed || seen.has(trimmed)) {\n      continue;\n    }\n\n    seen.add(trimmed);\n    normalized.push(trimmed);\n  }\n\n  return normalized.length > 0 ? normalized : null;\n}\n\nfunction describeAll(options = {}) {\n  const normalizedNames = normalizeNameCollection(options && options.names);\n  const normalizedCategories = normalizeCategoryCollection(\n    options && (options.categories || options.category || null),\n  );\n\n  const namesFilter = normalizedNames ? new Set(normalizedNames) : null;\n  const categoryFilter = normalizedCategories ? new Set(normalizedCategories) : null;\n\n  const snapshot = [];\n\n  const sourceNames = namesFilter ? normalizedNames : Object.keys(metadataMap);\n\n  for (let index = 0; index < sourceNames.length; index += 1) {\n    const name = sourceNames[index];\n    const meta = metadataMap[name];\n    if (!meta) {\n      continue;\n    }\n\n    if (categoryFilter && !categoryFilter.has(meta.category)) {\n      continue;\n    }\n\n    snapshot.push({\n      name,\n      description: meta.description,\n      category: meta.category,\n      registeredAt: meta.registeredAt,\n      frozen: meta.frozen,\n      connections: meta.connections || freezeDeep([]),\n    });\n  }\n\n  if (!namesFilter) {\n    const shouldSort = !options || options.sort !== false;\n    if (shouldSort) {\n      snapshot.sort((left, right) => left.name.localeCompare(right.name));\n    }\n  }\n\n  return freezeDeep(snapshot);\n}\n\nfunction assertRegistered(names) {\n  const entries = Array.isArray(names) ? names.slice() : [names];\n  const detail = {};\n  const missing = [];\n\n  for (let index = 0; index < entries.length; index += 1) {\n    const name = normalizeName(entries[index]);\n    const present = has(name);\n    detail[name] = present;\n    if (!present) {\n      missing.push(name);\n    }\n  }\n\n  return Object.freeze({\n    ok: missing.length === 0,\n    missing: Object.freeze(missing),\n    detail: Object.freeze(detail),\n  });\n}\n\nfunction resetForTests(options = {}) {\n  const isTestEnvironment =\n    typeof process !== 'undefined' &&\n    process &&\n    process.env &&\n    process.env.NODE_ENV === 'test';\n\n  if (!isTestEnvironment) {\n    throw new Error('cineModules.__internalResetForTests() is restricted to test environments.');\n  }\n\n  if (!options || options.force !== true) {\n    throw new Error('cineModules.__internalResetForTests() requires { force: true }.');\n  }\n\n  moduleMap = Object.create(null);\n  metadataMap = Object.create(null);\n\n  // Cancel any pending flushes and plain the queue\n  const scopes = [GLOBAL_SCOPE];\n  if (typeof globalThis !== 'undefined' && globalThis !== GLOBAL_SCOPE) scopes.push(globalThis);\n  if (typeof window !== 'undefined' && scopes.indexOf(window) === -1) scopes.push(window);\n  if (typeof self !== 'undefined' && scopes.indexOf(self) === -1) scopes.push(self);\n  if (typeof global !== 'undefined' && scopes.indexOf(global) === -1) scopes.push(global);\n\n  for (const scope of scopes) {\n    if (scope) {\n      cancelPendingFlush(scope);\n      if (Array.isArray(scope[PENDING_QUEUE_KEY])) {\n        scope[PENDING_QUEUE_KEY].length = 0;\n      }\n    }\n  }\n\n  return true;\n}\n\nfunction getTimerDescriptor(scope) {\n  if (!scope || typeof scope !== 'object') {\n    return null;\n  }\n\n  const descriptor = scope[QUEUE_FLUSH_TIMER_KEY];\n  return descriptor && typeof descriptor === 'object' ? descriptor : null;\n}\n\nfunction assignHidden(scope, key, value) {\n  if (!scope || (typeof scope !== 'object' && typeof scope !== 'function')) {\n    return false;\n  }\n\n  try {\n    Object.defineProperty(scope, key, {\n      configurable: true,\n      enumerable: false,\n      writable: true,\n      value,\n    });\n    return true;\n  } catch (error) {\n    void error;\n  }\n\n  try {\n    scope[key] = value;\n    return true;\n  } catch (assignmentError) {\n    void assignmentError;\n  }\n\n  return false;\n}\n\nfunction cancelPendingFlush(scope) {\n  const descriptor = getTimerDescriptor(scope);\n  if (!descriptor) {\n    return;\n  }\n\n  const clearTimer = descriptor && typeof descriptor.clear === 'function' ? descriptor.clear : null;\n  if (clearTimer && Object.prototype.hasOwnProperty.call(descriptor, 'id')) {\n    try {\n      clearTimer(descriptor.id);\n    } catch (error) {\n      void error;\n    }\n  }\n\n  assignHidden(scope, QUEUE_FLUSH_TIMER_KEY, null);\n}\n\nfunction schedulePendingFlush(scope) {\n  if (!scope || typeof scope !== 'object') {\n    return;\n  }\n\n  const queue = scope[PENDING_QUEUE_KEY];\n  if (!Array.isArray(queue) || queue.length === 0) {\n    cancelPendingFlush(scope);\n    return;\n  }\n\n  if (getTimerDescriptor(scope)) {\n    return;\n  }\n\n  const scheduleFromScope =\n    (typeof scope.setTimeout === 'function' && scope.setTimeout.bind(scope)) ||\n    (typeof GLOBAL_SCOPE.setTimeout === 'function' && GLOBAL_SCOPE.setTimeout.bind(GLOBAL_SCOPE)) ||\n    (typeof setTimeout === 'function' ? setTimeout : null);\n\n  if (typeof scheduleFromScope !== 'function') {\n    return;\n  }\n\n  const clearFromScope =\n    (typeof scope.clearTimeout === 'function' && scope.clearTimeout.bind(scope)) ||\n    (typeof GLOBAL_SCOPE.clearTimeout === 'function' && GLOBAL_SCOPE.clearTimeout.bind(GLOBAL_SCOPE)) ||\n    (typeof clearTimeout === 'function' ? clearTimeout : null);\n\n  const timerId = scheduleFromScope(function retryFlush() {\n    cancelPendingFlush(scope);\n    flushPendingRegistrations(scope);\n  }, 0);\n\n  assignHidden(scope, QUEUE_FLUSH_TIMER_KEY, {\n    id: timerId,\n    clear: typeof clearFromScope === 'function' ? clearFromScope : null,\n  });\n}\n\nfunction flushPendingRegistrations(scope) {\n  if (!scope || typeof scope !== 'object') {\n    return;\n  }\n\n  const queue = scope[PENDING_QUEUE_KEY];\n  if (!Array.isArray(queue) || queue.length === 0) {\n    cancelPendingFlush(scope);\n    return;\n  }\n\n  const pending = queue.slice();\n  queue.length = 0;\n\n  let requiresReschedule = false;\n\n  for (let index = 0; index < pending.length; index += 1) {\n    const entry = pending[index];\n    if (!entry || typeof entry !== 'object') {\n      continue;\n    }\n\n    const name = entry.name;\n    const api = entry.api;\n    const options = entry.options || {};\n\n    try {\n      registry.register(name, api, options);\n    } catch (error) {\n      // If the module fails to register, we log a warning and discard the pending entry.\n      // Retrying blindly causes infinite loops if the error is permanent (e.g. invalid name, conflict, etc).\n      if (typeof console !== 'undefined' && typeof console.warn === 'function') {\n        console.warn(`cineModules: discard pending registration for \"${name}\" due to error:`, error);\n      }\n      continue;\n    }\n  }\n\n  if (requiresReschedule || queue.length > 0) {\n    schedulePendingFlush(scope);\n  } else {\n    cancelPendingFlush(scope);\n  }\n}\n\nfunction collectQueueScopes(preferredScope) {\n  const scopes = [];\n\n  function pushScope(candidate) {\n    if (!candidate || (typeof candidate !== 'object' && typeof candidate !== 'function')) {\n      return;\n    }\n    if (scopes.indexOf(candidate) === -1) {\n      scopes.push(candidate);\n    }\n  }\n\n  pushScope(preferredScope);\n  pushScope(GLOBAL_SCOPE);\n  if (typeof globalThis !== 'undefined') pushScope(globalThis);\n  if (typeof window !== 'undefined') pushScope(window);\n  if (typeof self !== 'undefined') pushScope(self);\n  if (typeof global !== 'undefined') pushScope(global);\n\n  return scopes;\n}\n\nfunction readQueueFromScope(scope) {\n  if (!scope || (typeof scope !== 'object' && typeof scope !== 'function')) {\n    return null;\n  }\n\n  try {\n    const queue = scope[PENDING_QUEUE_KEY];\n    return Array.isArray(queue) ? queue : null;\n  } catch (error) {\n    void error;\n    return null;\n  }\n}\n\nfunction ensureQueueOnScope(scope) {\n  if (!scope || (typeof scope !== 'object' && typeof scope !== 'function')) {\n    return null;\n  }\n\n  let queue = readQueueFromScope(scope);\n  if (queue) {\n    return queue;\n  }\n\n  if (assignHidden(scope, PENDING_QUEUE_KEY, [])) {\n    queue = readQueueFromScope(scope);\n    if (queue) {\n      return queue;\n    }\n  }\n\n  try {\n    scope[PENDING_QUEUE_KEY] = [];\n    queue = readQueueFromScope(scope);\n    if (queue) {\n      return queue;\n    }\n  } catch (error) {\n    void error;\n  }\n\n  return null;\n}\n\nfunction resolveQueueDescriptor(preferredScope) {\n  const scopes = collectQueueScopes(preferredScope);\n\n  for (let index = 0; index < scopes.length; index += 1) {\n    const candidate = scopes[index];\n    const queue = ensureQueueOnScope(candidate);\n    if (queue) {\n      return { queue, scope: candidate };\n    }\n  }\n\n  return null;\n}\n\nfunction queueRegistrationPayload(scope, payload) {\n  const descriptor = resolveQueueDescriptor(scope || GLOBAL_SCOPE);\n  if (!descriptor || !descriptor.queue) {\n    return false;\n  }\n\n  const record = freezeDeep({\n    name: payload && payload.name ? normalizeName(payload.name) : null,\n    api: payload ? payload.api : null,\n    options: Object.freeze({ ...(payload && payload.options ? payload.options : {}) }),\n  });\n\n  const { queue, scope: queueScope } = descriptor;\n\n  try {\n    queue.push(record);\n  } catch (error) {\n    void error;\n    queue[queue.length] = record;\n  }\n\n  try {\n    schedulePendingFlush(queueScope);\n  } catch (error) {\n    void error;\n  }\n\n  return true;\n}\n\nfunction createBlueprint(options = {}) {\n  const normalizedName = normalizeName(options.name);\n  const normalizedCategory = typeof options.category === 'string' ? options.category.trim() : '';\n  if (!normalizedCategory) {\n    throw new TypeError(`cineModules.createBlueprint(\"${normalizedName}\") expected a non-empty category string.`);\n  }\n\n  const normalizedDescription = typeof options.description === 'string' ? options.description.trim() : '';\n  if (!normalizedDescription) {\n    throw new TypeError(`cineModules.createBlueprint(\"${normalizedName}\") expected a non-empty description.`);\n  }\n\n  const freezeByDefault = options.freeze !== false;\n  const normalizedConnections = freezeDeep(normalizeConnections(options.connections));\n\n  const factory = typeof options.factory === 'function' ? options.factory : null;\n  const staticApi = factory ? null : options.api;\n\n  if (!factory && (!staticApi || (typeof staticApi !== 'object' && typeof staticApi !== 'function'))) {\n    throw new TypeError(\n      `cineModules.createBlueprint(\"${normalizedName}\") expected an object API or factory function.`,\n    );\n  }\n\n  const metadata = Object.freeze({\n    name: normalizedName,\n    category: normalizedCategory,\n    description: normalizedDescription,\n    connections: normalizedConnections,\n    freeze: freezeByDefault,\n  });\n\n  let cachedApi = null;\n  let instantiated = false;\n  let instantiateError = null;\n\n  function buildRegistrationOptions(overrides) {\n    const base = {\n      category: metadata.category,\n      description: metadata.description,\n      connections: metadata.connections,\n      freeze: metadata.freeze,\n    };\n\n    if (!overrides || typeof overrides !== 'object') {\n      return Object.freeze({ ...base });\n    }\n\n    const normalized = { ...base };\n\n    if (Object.prototype.hasOwnProperty.call(overrides, 'category')) {\n      const candidate = typeof overrides.category === 'string' ? overrides.category.trim() : '';\n      if (candidate) {\n        normalized.category = candidate;\n      }\n    }\n\n    if (Object.prototype.hasOwnProperty.call(overrides, 'description')) {\n      const candidate = typeof overrides.description === 'string' ? overrides.description.trim() : '';\n      if (candidate) {\n        normalized.description = candidate;\n      }\n    }\n\n    if (Object.prototype.hasOwnProperty.call(overrides, 'connections')) {\n      normalized.connections = freezeDeep(normalizeConnections(overrides.connections));\n    }\n\n    if (Object.prototype.hasOwnProperty.call(overrides, 'freeze')) {\n      normalized.freeze = overrides.freeze !== false;\n    }\n\n    return Object.freeze(normalized);\n  }\n\n  function instantiate(context) {\n    if (instantiated) {\n      if (instantiateError) {\n        throw instantiateError;\n      }\n      return cachedApi;\n    }\n\n    instantiated = true;\n\n    let produced = staticApi;\n    if (factory) {\n      const invocationContext = context && typeof context === 'object' ? { ...context } : {};\n      const frozenContext = Object.freeze({\n        registry: registryReference || null,\n        metadata,\n        context: invocationContext,\n        freezeDeep,\n        normalizeConnections,\n      });\n\n      try {\n        produced = factory(frozenContext);\n      } catch (error) {\n        instantiateError = error instanceof Error ? error : new Error(String(error));\n        throw instantiateError;\n      }\n    }\n\n    if (!produced || (typeof produced !== 'object' && typeof produced !== 'function')) {\n      const error = new TypeError(\n        `cineModules.createBlueprint(\"${normalizedName}\") factory expected an object or function return value.`,\n      );\n      instantiateError = error;\n      throw error;\n    }\n\n    cachedApi = freezeByDefault && !Object.isFrozen(produced) ? freezeDeep(produced) : produced;\n    return cachedApi;\n  }\n\n  function registerBlueprint(options = {}) {\n    const resolvedRegistry =\n      options && typeof options.registry === 'object' && options.registry\n        ? options.registry\n        : registryReference;\n\n    const registrationOptions = buildRegistrationOptions(options && options.options);\n    const scope = options && options.scope ? options.scope : GLOBAL_SCOPE;\n    const deferOnError = options && Object.prototype.hasOwnProperty.call(options, 'defer') ? options.defer !== false : true;\n    const onError = options && typeof options.onError === 'function' ? options.onError : null;\n\n    const api = instantiate(options && options.context);\n\n    const targetRegistry =\n      resolvedRegistry && typeof resolvedRegistry.register === 'function' ? resolvedRegistry : registryReference;\n\n    if (!targetRegistry || typeof targetRegistry.register !== 'function') {\n      throw new TypeError('cineModules.createBlueprint register() requires a registry with a register() function.');\n    }\n\n    try {\n      return targetRegistry.register(metadata.name, api, registrationOptions);\n    } catch (error) {\n      if (deferOnError) {\n        queueRegistrationPayload(scope, {\n          name: metadata.name,\n          api,\n          options: registrationOptions,\n        });\n      }\n\n      if (onError) {\n        try {\n          onError(error);\n        } catch (handlerError) {\n          void handlerError;\n        }\n      }\n\n      throw error;\n    }\n  }\n\n  const blueprint = {\n    name: metadata.name,\n    category: metadata.category,\n    description: metadata.description,\n    connections: metadata.connections,\n    freeze: metadata.freeze,\n    instantiate,\n    register: registerBlueprint,\n    getMetadata() {\n      return metadata;\n    },\n    createRegistrationOptions: buildRegistrationOptions,\n    toJSON() {\n      return metadata;\n    },\n  };\n\n  return Object.freeze(blueprint);\n}\n\nconst registry = {};\nregistry.register = register;\nregistry.get = get;\nregistry.has = has;\nregistry.list = list;\nregistry.describe = describe;\nregistry.describeAll = describeAll;\nregistry.assertRegistered = assertRegistered;\nregistry.createBlueprint = createBlueprint;\nregistry.__internalResetForTests = resetForTests;\n\nregistryReference = registry;\n\nconst scopes = [GLOBAL_SCOPE];\nif (typeof globalThis !== 'undefined' && globalThis !== GLOBAL_SCOPE) scopes.push(globalThis);\nif (typeof window !== 'undefined' && scopes.indexOf(window) === -1) scopes.push(window);\nif (typeof self !== 'undefined' && scopes.indexOf(self) === -1) scopes.push(self);\nif (typeof global !== 'undefined' && scopes.indexOf(global) === -1) scopes.push(global);\n\nfor (let index = 0; index < scopes.length; index += 1) {\n  const scope = scopes[index];\n  if (!scope || typeof scope !== 'object') {\n    continue;\n  }\n\n  const existing = scope.cineModules;\n  if (existing !== registry) {\n    try {\n      Object.defineProperty(scope, 'cineModules', {\n        configurable: true,\n        enumerable: false,\n        value: registry,\n        writable: true,\n      });\n    } catch (error) {\n      void error;\n      try {\n        scope.cineModules = registry;\n      } catch (assignmentError) {\n        void assignmentError;\n      }\n    }\n  }\n\n  flushPendingRegistrations(scope);\n}\n\nexport default registry;\nexport const cineModules = registry;\n","const globalScope =\n    (typeof globalThis !== 'undefined' && globalThis) ||\n    (typeof window !== 'undefined' && window) ||\n    (typeof self !== 'undefined' && self) ||\n    (typeof global !== 'undefined' && global) ||\n    {};\n\n// Use a Set for O(1) lookups when validating video output types\nconst VIDEO_OUTPUT_TYPES = new Set([\n    '3G-SDI',\n    '6G-SDI',\n    '12G-SDI',\n    'Mini BNC',\n    'HDMI',\n    'Mini HDMI',\n    'Micro HDMI',\n    'DisplayPort'\n]);\n\nconst NORMALIZED_FLAG_KEY = '__normalized';\n\n/**\n * Memoize a normalisation function for repeated lookups.\n *\n * The provided function receives both the original trimmed string and a\n * lowercase key. Results are cached to avoid recomputing normalisations for\n * the same input.\n *\n * @param {(value: string, key: string) => string} fn - Function that performs\n *   normalisation.\n * @returns {(value: string) => string} Wrapped function with memoisation and\n *   empty-string fallback for falsy inputs.\n */\nfunction memoizeNormalization(fn) {\n    const cache = new Map();\n    return value => {\n        if (!value) return '';\n        const str = String(value)\n            .replace(/[]/g, '')\n            .trim();\n        const key = str.toLowerCase();\n        if (!cache.has(key)) cache.set(key, fn(str, key));\n        return cache.get(key);\n    };\n}\n\nconst VIDEO_TYPE_PATTERNS = [\n    { needles: ['12g'], value: '12G-SDI' },\n    { needles: ['6g'], value: '6G-SDI' },\n    { needles: ['3g'], value: '3G-SDI' },\n    // Accept both \"HD-SDI\" and \"HD SDI\" spellings\n    { needles: ['hd', 'sdi'], value: '3G-SDI' },\n    { needles: ['mini', 'bnc'], value: 'Mini BNC' },\n    { needles: ['micro', 'hdmi'], value: 'Micro HDMI' },\n    { needles: ['mini', 'hdmi'], value: 'Mini HDMI' },\n    { needles: ['hdmi'], value: 'HDMI' },\n    { needles: ['displayport'], value: 'DisplayPort' },\n    { needles: ['display', 'port'], value: 'DisplayPort' },\n    { needles: ['dp'], value: 'DisplayPort' }\n];\n\nconst normalizeVideoType = memoizeNormalization((_, key) => {\n    const match = VIDEO_TYPE_PATTERNS.find(({ needles }) =>\n        needles.every(n => key.includes(n))\n    );\n    return match ? match.value : '';\n});\n\nconst FIZ_CONNECTOR_MAP = {\n    'lemo 4-pin (lbus)': 'LBUS (LEMO 4-pin)',\n    'lbus (lemo 4-pin)': 'LBUS (LEMO 4-pin)',\n    'lbus (4-pin lemo)': 'LBUS (LEMO 4-pin)',\n    'lbus (4-pin lemo for motors)': 'LBUS (LEMO 4-pin)',\n    '4-pin lemo (lbus)': 'LBUS (LEMO 4-pin)',\n    'lemo 4-pin': 'LEMO 4-pin',\n    '4-pin lemo': 'LEMO 4-pin',\n    'lemo 7-pin': 'LEMO 7-pin',\n    'lemo 7-pin 1b': 'LEMO 7-pin',\n    '7-pin lemo': 'LEMO 7-pin',\n    '7-pin lemo (lcs)': 'LEMO 7-pin (LCS)',\n    '7-pin lemo (cam)': 'LEMO 7-pin (CAM)',\n    'ext (lemo 7-pin)': 'EXT LEMO 7-pin',\n    'hirose 12pin': 'Hirose 12-pin',\n    '12-pin hirose': 'Hirose 12-pin',\n    '12pin broadcast connector': 'Hirose 12-pin',\n    'lens 12 pin': 'Hirose 12-pin',\n    'lens terminal 12-pin': 'Hirose 12-pin',\n    'lens terminal 12-pin jack': 'Hirose 12-pin',\n    'lens terminal': 'Hirose 12-pin',\n    'usb type-c': 'USB-C',\n    'usb-c': 'USB-C',\n    'usb-c (usb 3.2 / 3.1 gen 1)': 'USB-C',\n    'usb-c / gigabit ethernet (via adapter)': 'USB-C',\n    'active ef mount': 'Active EF mount',\n    'lanc (2.5mm stereo mini jack)': 'LANC',\n    '2.5 mm sub-mini (lanc)': 'LANC',\n    'remote a (2.5mm)': 'REMOTE A connector',\n    'remote control terminal': 'REMOTE A connector',\n    'remote 8 pin': 'REMOTE B connector'\n};\n\nfunction createMapNormalizer(map) {\n    return memoizeNormalization((str, key) => map[key] || str);\n}\n\nconst normalizeFizConnectorType = createMapNormalizer(FIZ_CONNECTOR_MAP);\n\nconst VIEWFINDER_TYPE_MAP = {\n    'dsmc3 red touch 7\" lcd (optional)': 'RED Touch 7\" LCD (Optional)',\n    'red touch 7.0\" lcd (optional)': 'RED Touch 7\" LCD (Optional)',\n    'lcd touch panel': 'LCD touchscreen',\n    'lcd touchscreen': 'LCD touchscreen',\n    'native lcd capacitive touchscreen': 'LCD touchscreen',\n    'integrated touchscreen lcd': 'LCD touchscreen',\n    'free-angle lcd': 'Vari-angle LCD',\n    'lcd monitor (native)': 'Integrated LCD monitor',\n    'native lcd viewfinder': 'Integrated LCD monitor',\n    'lcd monitor lm-v2 (supplied)': 'LCD Monitor LM-V2',\n    'integrated main monitor': 'Integrated LCD monitor',\n    'optional evf-v70 viewfinder': 'EVF-V70 (Optional)',\n    'optional evf-v50': 'EVF-V50 (Optional)',\n    'optional oled viewfinder': 'OLED EVF (Optional)',\n    'blackmagic pocket cinema camera pro evf (optional)': 'Blackmagic Pro EVF (Optional)',\n    'external backlit lcd status display': 'LCD status display',\n    'built-in fold-out lcd': 'Fold-out LCD',\n    'oled lvf (live view finder)': 'OLED EVF',\n    'lcd capacitive touchscreen': 'LCD touchscreen',\n    'lemo 26 pin': 'LEMO 26-pin port'\n};\n\nconst normalizeViewfinderType = createMapNormalizer(VIEWFINDER_TYPE_MAP);\n\nconst POWER_PORT_TYPE_MAP = {\n    'lemo 8-pin (dc in / bat)': 'Bat LEMO 8-pin',\n    'lemo 8-pin (bat)': 'Bat LEMO 8-pin',\n    'bat (lemo 8-pin)': 'Bat LEMO 8-pin',\n    'lemo 8-pin': 'Bat LEMO 8-pin',\n    '2-pin dc-input': '2-pin DC-IN',\n    'dc-': 'DC IN',\n    'dc': 'DC IN',\n    '2-pin xlr': 'XLR 2-pin',\n    '2-pin locking connector': 'LEMO 2-pin',\n    '2-pin locking connector / 2-pin lemo': 'LEMO 2-pin',\n    '4-pin xlr / dc in 12v': 'XLR 4-pin',\n    '4-pin xlr / v-lock': 'XLR 4-pin',\n    'xlr 4-pin jack': 'XLR 4-pin',\n    'xlr 4-pin (main input)': 'XLR 4-pin',\n    'xlr-type 4 pin (male) / square-shaped 5 pin connector (battery)': 'XLR 4-pin / Square 5-pin',\n    '12-pin molex connector (at battery plate rear) / 4-pin xlr (external power)': 'Molex 12-pin / XLR 4-pin',\n    'battery slot': 'Battery Slot',\n    'usb-c': 'USB-C',\n    'usb type-c': 'USB-C',\n    'usb-c pd': 'USB-C PD',\n    'usb-c (power delivery)': 'USB-C PD',\n    'usb-c pd,dc coupler': 'USB-C PD / DC Coupler',\n    'dc coupler': 'DC Coupler',\n    'dc coupler (dr-e6c)': 'DC Coupler',\n    'dc input': 'DC IN',\n    'dc barrel': 'DC Barrel',\n    'dc (barrel)': 'DC Barrel',\n    'locking dc barrel': 'DC Barrel',\n    'dc 24v terminal': 'DC Barrel',\n    'weipu sf610/s2 (12vdc) input': 'Weipu SF610/S2',\n    '6-pin 1b dc-in / tb50 battery mount': '6-pin 1B DC-IN',\n    '6-pin 1b dc-,tb50': '6-pin 1B DC-IN'\n};\n\nconst mapPowerPortOne = createMapNormalizer(POWER_PORT_TYPE_MAP);\n\nfunction normalizePowerPortType(type) {\n    if (!type) return [];\n    const toArray = val => {\n        const normalized = mapPowerPortOne(val);\n        if (!normalized) return [];\n        return normalized\n            .split(/[/,]/)\n            .map(piece => mapPowerPortOne(piece.trim()))\n            .map(piece => (piece && piece.trim()) || '')\n            .filter(Boolean);\n    };\n    return Array.isArray(type) ? type.flatMap(toArray) : toArray(type);\n}\n\nfunction ensureList(list, defaults) {\n    if (!Array.isArray(list)) return [];\n    return list.map(item =>\n        typeof item === 'string'\n            ? { ...defaults, type: item }\n            : { ...defaults, ...(item || {}) }\n    );\n}\n\nfunction fixPowerInput(dev) {\n    if (!dev) return;\n    if (dev.powerInput && !dev.power?.input) {\n        dev.power = { ...(dev.power || {}), input: { type: normalizePowerPortType(dev.powerInput) } };\n        delete dev.powerInput;\n    }\n    const input = dev.power?.input;\n    if (!input) return;\n    const normalizeEntry = it => {\n        if (typeof it === 'string') {\n            return { type: normalizePowerPortType(it) };\n        }\n        if (it) {\n            const { portType: pType, type: tType, ...rest } = it;\n            const typeField = (!tType && pType) ? pType : tType;\n            return { ...rest, type: typeField ? normalizePowerPortType(typeField) : [] };\n        }\n        return { type: [] };\n    };\n    dev.power.input = Array.isArray(input) ? input.map(normalizeEntry) : normalizeEntry(input);\n}\n\nfunction applyFixPowerInput(collection) {\n    if (!collection || typeof collection !== 'object') return;\n    Object.values(collection).forEach(fixPowerInput);\n}\n\n\nfunction hasNormalizedDevicesMarker(bundle) {\n    return Boolean(\n        bundle &&\n        Object.prototype.hasOwnProperty.call(bundle, NORMALIZED_FLAG_KEY) &&\n        bundle[NORMALIZED_FLAG_KEY]\n    );\n}\n\nfunction markDevicesNormalized(bundle) {\n    if (!bundle || typeof bundle !== 'object') {\n        return bundle;\n    }\n    try {\n        Object.defineProperty(bundle, NORMALIZED_FLAG_KEY, {\n            configurable: true,\n            enumerable: false,\n            value: true,\n            writable: true\n        });\n    } catch (defineNormalizedError) {\n        void defineNormalizedError;\n        bundle[NORMALIZED_FLAG_KEY] = true;\n    }\n    return bundle;\n}\n\n\n// Normalize various camera properties so downstream logic works with\n// consistent structures and value formats.\nfunction unifyDevices(devicesData, options) {\n    if (!devicesData || typeof devicesData !== 'object') return devicesData;\n    const force = Boolean(options && options.force);\n    if (!force && hasNormalizedDevicesMarker(devicesData)) {\n        return devicesData;\n    }\n    Object.values(devicesData.cameras || {}).forEach(cam => {\n        if (cam.power?.input && cam.power.input.powerDrawWatts !== undefined) {\n            delete cam.power.input.powerDrawWatts;\n        }\n        fixPowerInput(cam);\n        if (Array.isArray(cam.power?.batteryPlateSupport)) {\n            cam.power.batteryPlateSupport = cam.power.batteryPlateSupport.map(it => {\n                if (typeof it === 'string') {\n                    const m = it.match(/([^()]+)(?:\\(([^)]+)\\))?(?:\\s*-\\s*(.*))?/);\n                    const type = m ? m[1].trim() : it;\n                    let mount = m && m[2] ? m[2].trim().toLowerCase() : '';\n                    if (!mount) {\n                        mount = /adapted|via adapter/i.test(it) ? 'adapted' : 'native';\n                    } else if (/via adapter/i.test(mount)) {\n                        mount = 'adapted';\n                    }\n                    const notes = m && m[3] ? m[3].trim() : (/via adapter/i.test(it) ? 'via adapter' : '');\n                    return { type, mount, notes };\n                }\n                return {\n                    type: it.type || '',\n                    mount: (it.mount ? it.mount : (it.native ? 'native' : (it.adapted ? 'adapted' : 'native'))).toLowerCase(),\n                    notes: it.notes || ''\n                };\n            });\n        }\n        if (cam.power) {\n            cam.power.powerDistributionOutputs = ensureList(cam.power.powerDistributionOutputs, {\n                type: '',\n                voltage: '',\n                current: '',\n                wattage: null,\n                notes: ''\n            });\n        }\n        cam.videoOutputs = ensureList(cam.videoOutputs, { type: '', notes: '' }).flatMap(vo => {\n            const { count, ...rest } = vo || {};\n            const norm = normalizeVideoType(rest.type);\n            if (!VIDEO_OUTPUT_TYPES.has(norm)) return [];\n            const parsedCount = parseInt(count, 10);\n            const num = Number.isFinite(parsedCount) && parsedCount > 0 ? parsedCount : 1;\n            const base = { ...rest, type: norm, notes: rest.notes || '' };\n            return Array.from({ length: num }, () => ({ ...base }));\n        });\n        cam.fizConnectors = ensureList(cam.fizConnectors, { type: '', notes: '' }).map(fc => {\n            const { type, ...rest } = fc || {};\n            return { ...rest, type: normalizeFizConnectorType(type) };\n        });\n        cam.viewfinder = ensureList(cam.viewfinder, { type: '', resolution: '', connector: '', notes: '' }).map(vf => {\n            const { type, ...rest } = vf || {};\n            return {\n                ...rest,\n                type: normalizeViewfinderType(type)\n            };\n        });\n        cam.recordingMedia = ensureList(cam.recordingMedia, { type: '', notes: '' }).map(m => {\n            let { type = '', notes = '' } = m || {};\n            const match = type.match(/^(.*?)(?:\\((.*)\\))?$/);\n            if (match) {\n                type = match[1].trim();\n                notes = notes || (match[2] ? match[2].trim() : '');\n            }\n            if (/^SD UHS-II$/i.test(type)) {\n                type = 'SD Card';\n                notes = notes ? `${notes}; UHS-II` : 'UHS-II';\n            } else if (/^SD \\(UHS-II\\/UHS-I\\)$/i.test(type)) {\n                type = 'SD Card';\n                notes = 'UHS-II/UHS-I';\n            } else if (type === 'CFast 2.0 card slots') {\n                type = 'CFast 2.0';\n                notes = notes || 'Dual Slots';\n            } else if (type === 'CFexpress Type B (Dual Slots)') {\n                type = 'CFexpress Type B';\n                notes = notes || 'Dual Slots';\n            } else if (type === 'CFexpress Type B (via adapter)') {\n                type = 'CFexpress Type B';\n                notes = notes || 'via adapter';\n            } else if (/^SD UHS-II \\(Dual Slots\\)$/i.test(type)) {\n                type = 'SD Card';\n                notes = notes ? `${notes}; UHS-II (Dual Slots)` : 'UHS-II (Dual Slots)';\n            } else if (type === 'SD Card (Dual Slots)') {\n                type = 'SD Card';\n                notes = notes || 'Dual Slots';\n            } else if (type === 'SD card slot (for proxy/backup)') {\n                type = 'SD Card';\n                notes = notes || 'for proxy/backup';\n            }\n            return { type, notes };\n        });\n        cam.timecode = ensureList(cam.timecode, { type: '', notes: '' });\n        cam.lensMount = ensureList(cam.lensMount, { type: '', mount: 'native', notes: '' })\n            .map(lm => ({\n                type: lm.type,\n                mount: (lm.mount ? lm.mount.toLowerCase() : 'native'),\n                notes: lm.notes || ''\n            }))\n            .filter((lm, idx, arr) =>\n                idx === arr.findIndex(o => o.type === lm.type && o.mount === lm.mount && o.notes === lm.notes)\n            );\n    });\n\n    Object.values(devicesData.lenses || {}).forEach(lens => {\n        if (!lens || typeof lens !== 'object') return;\n        const normalizeMountEntry = (entry) => {\n            if (!entry) return null;\n            if (typeof entry === 'string') {\n                const trimmed = entry.trim();\n                if (!trimmed) return null;\n                return { type: trimmed, mount: 'native' };\n            }\n            const type = typeof entry.type === 'string' ? entry.type.trim() : '';\n            if (!type) return null;\n            const status = typeof entry.mount === 'string' ? entry.mount.trim().toLowerCase() : '';\n            return { type, mount: status === 'adapted' ? 'adapted' : 'native' };\n        };\n\n        const existingMountOptions = lens.mountOptions;\n        const normalizedOptions = [];\n\n        const pushNormalizedEntry = (entry) => {\n            const normalized = normalizeMountEntry(entry);\n            if (normalized) {\n                normalizedOptions.push(normalized);\n            }\n        };\n\n        if (Array.isArray(existingMountOptions)) {\n            existingMountOptions.forEach(pushNormalizedEntry);\n        } else if (existingMountOptions && typeof existingMountOptions === 'object') {\n            pushNormalizedEntry(existingMountOptions);\n        }\n\n        if (!normalizedOptions.length && Array.isArray(lens.lensMount)) {\n            lens.lensMount.forEach(pushNormalizedEntry);\n            delete lens.lensMount;\n        }\n\n        if (!normalizedOptions.length) {\n            const mountType = typeof lens.mount === 'string' ? lens.mount.trim() : '';\n            if (mountType) {\n                pushNormalizedEntry({ type: mountType, mount: 'native' });\n            }\n        }\n\n        const dedupedOptions = [];\n        normalizedOptions.forEach(opt => {\n            if (!opt || !opt.type) return;\n            const mountState = opt.mount === 'adapted' ? 'adapted' : 'native';\n            const alreadyPresent = dedupedOptions.some(existing => (\n                existing.type === opt.type && existing.mount === mountState\n            ));\n            if (!alreadyPresent) {\n                dedupedOptions.push({ type: opt.type, mount: mountState });\n            }\n        });\n\n        const safeMountOptions = Array.isArray(dedupedOptions) ? dedupedOptions : [];\n        lens.mountOptions = safeMountOptions;\n\n        const mountOptions = Array.isArray(lens.mountOptions) ? lens.mountOptions : [];\n\n        if (mountOptions.length) {\n            const primary = mountOptions.find(opt => opt && opt.mount === 'native' && opt.type)\n                || mountOptions[0];\n            const primaryType = primary && primary.type ? primary.type : '';\n            if (primaryType) {\n                lens.mount = primaryType;\n            } else if (typeof lens.mount === 'string') {\n                lens.mount = lens.mount.trim();\n            }\n        } else if (typeof lens.mount === 'string') {\n            lens.mount = lens.mount.trim();\n            if (!lens.mount) {\n                delete lens.mount;\n            }\n        }\n    });\n\n    ['monitors', 'video', 'viewfinders'].forEach(key => {\n        applyFixPowerInput(devicesData[key]);\n    });\n\n    const fizGroups = devicesData.fiz || {};\n    ['motors', 'controllers', 'distance'].forEach(key => {\n        applyFixPowerInput(fizGroups[key]);\n    });\n\n    // Normalize FIZ motors\n    Object.values(devicesData.fiz?.motors || {}).forEach(m => {\n        if (!m) return;\n        if (m.connector && !m.fizConnector) {\n            m.fizConnector = m.connector;\n            delete m.connector;\n        }\n        if (m.fizConnector) {\n            m.fizConnector = normalizeFizConnectorType(m.fizConnector);\n        }\n    });\n\n    // Normalize FIZ controllers\n    Object.values(devicesData.fiz?.controllers || {}).forEach(c => {\n        if (!c) return;\n        if (c.FIZ_connector && !c.fizConnector && !c.fizConnectors) {\n            c.fizConnector = c.FIZ_connector;\n            delete c.FIZ_connector;\n        }\n        if (Array.isArray(c.fizConnectors)) {\n            c.fizConnectors = c.fizConnectors.map(fc => {\n                if (!fc) return { type: '' };\n                const type = normalizeFizConnectorType(fc.type || fc);\n                const notes = fc.notes || undefined;\n                return notes ? { type, notes } : { type };\n            });\n        } else if (c.fizConnector) {\n            const parts = String(c.fizConnector)\n                .split(',')\n                .map(s => s.trim())\n                .filter(Boolean);\n            c.fizConnectors = parts.map(p => ({ type: normalizeFizConnectorType(p) }));\n            delete c.fizConnector;\n        } else {\n            c.fizConnectors = [];\n        }\n    });\n\n    markDevicesNormalized(devicesData);\n    return devicesData;\n}\n\nfunction normalizeDevicesForPersistence(devicesData) {\n    return unifyDevices(devicesData, { force: true });\n}\n\n// Expose to global scope for legacy compatibility\nglobalScope.cineDeviceNormalization = {\n    unifyDevices,\n    normalizeDevicesForPersistence,\n    markDevicesNormalized,\n    hasNormalizedDevicesMarker,\n    fixPowerInput,\n    normalizeVideoType,\n    normalizeFizConnectorType,\n    normalizeViewfinderType,\n    normalizePowerPortType,\n    ensureList\n};\n\n// Expose individual functions for backward compatibility if needed\nglobalScope.unifyDevices = unifyDevices;\nglobalScope.normalizeDevicesForPersistence = normalizeDevicesForPersistence;\nglobalScope.markDevicesNormalized = markDevicesNormalized;\n\nexport const cineDeviceNormalization = globalScope.cineDeviceNormalization;\nexport {\n    unifyDevices,\n    normalizeDevicesForPersistence,\n    markDevicesNormalized,\n    hasNormalizedDevicesMarker,\n    fixPowerInput,\n    normalizeVideoType,\n    normalizeFizConnectorType,\n    normalizeViewfinderType,\n    normalizePowerPortType,\n    ensureList\n};\n","import cineModules from './registry.js';\n// (function () {\n\nfunction fallbackDetectGlobalScope() {\n  if (typeof globalThis !== 'undefined') {\n    return globalThis;\n  }\n  if (typeof window !== 'undefined') {\n    return window;\n  }\n  if (typeof self !== 'undefined') {\n    return self;\n  }\n  if (typeof global !== 'undefined') {\n    return global;\n  }\n  return {};\n}\n\nfunction fallbackCollectCandidateScopes(primary) {\n  const scopes = [];\n\n  function pushScope(scope) {\n    if (!scope || (typeof scope !== 'object' && typeof scope !== 'function')) {\n      return;\n    }\n    if (scopes.indexOf(scope) === -1) {\n      scopes.push(scope);\n    }\n  }\n\n  pushScope(primary);\n  if (typeof globalThis !== 'undefined') pushScope(globalThis);\n  if (typeof window !== 'undefined') pushScope(window);\n  if (typeof self !== 'undefined') pushScope(self);\n  if (typeof global !== 'undefined') pushScope(global);\n\n  return scopes;\n}\n\nfunction loggingResolveStructuredClone(scope) {\n  if (typeof structuredClone === 'function') {\n    return structuredClone;\n  }\n\n  if (scope && typeof scope.structuredClone === 'function') {\n    try {\n      return scope.structuredClone.bind(scope);\n    } catch (bindError) {\n      void bindError;\n    }\n  }\n\n  /* Node require removed for ESM conversion */\n\n  return null;\n}\n\nfunction loggingJsonDeepClone(value) {\n  if (value === null || typeof value !== 'object') {\n    return value;\n  }\n\n  try {\n    return JSON.parse(JSON.stringify(value));\n  } catch (jsonCloneError) {\n    void jsonCloneError;\n  }\n\n  return value;\n}\n\n/**\n * DEEP DIVE: Structured Clone Resolution\n *\n * Secure, deep copying of complex objects (Sets, Maps, etc.) is vital for logging\n * state without mutations affecting the live app.\n *\n * Strategy:\n * 1. Try Native `structuredClone`.\n * 2. Try Node.js `util.structuredClone` (if running in tests).\n * 3. Fallback to `JSON.parse(JSON.stringify(x))` (lossy but safe).\n *\n * This singleton pattern ensures we only pay the resolution cost once at startup.\n */\nconst LOGGING_DEEP_CLONE = (function resolveLoggingDeepClone() {\n  const scope = fallbackDetectGlobalScope();\n  if (scope && typeof scope.__cineDeepClone === 'function') {\n    return scope.__cineDeepClone;\n  }\n\n  const structuredCloneImpl = loggingResolveStructuredClone(scope);\n  if (!structuredCloneImpl) {\n    return loggingJsonDeepClone;\n  }\n\n  return function loggingResilientDeepClone(value) {\n    if (value === null || typeof value !== 'object') {\n      return value;\n    }\n\n    try {\n      return structuredCloneImpl(value);\n    } catch (structuredCloneError) {\n      void structuredCloneError;\n    }\n\n    return loggingJsonDeepClone(value);\n  };\n})();\n\nfunction fallbackLoadModuleEnvironment(scope) {\n  /* Require removed */\n\n  const candidates = fallbackCollectCandidateScopes(scope);\n\n  for (let index = 0; index < candidates.length; index += 1) {\n    const candidate = candidates[index];\n    if (candidate && typeof candidate.cineModuleEnvironment === 'object') {\n      return candidate.cineModuleEnvironment;\n    }\n  }\n\n  return null;\n}\n\nfunction fallbackLoadEnvironmentBridge(scope) {\n  /* Require removed */\n\n  const candidates = fallbackCollectCandidateScopes(scope);\n\n  for (let index = 0; index < candidates.length; index += 1) {\n    const candidate = candidates[index];\n    if (candidate && typeof candidate.cineEnvironmentBridge === 'object') {\n      return candidate.cineEnvironmentBridge;\n    }\n  }\n\n  return null;\n}\n\nfunction fallbackResolveModuleGlobals(scope) {\n  /* Require removed */\n\n  const candidates = fallbackCollectCandidateScopes(scope);\n\n  for (let index = 0; index < candidates.length; index += 1) {\n    const candidate = candidates[index];\n    if (candidate && typeof candidate.cineModuleGlobals === 'object') {\n      return candidate.cineModuleGlobals;\n    }\n  }\n\n  return null;\n}\n\nfunction fallbackTryRequire(modulePath) {\n  return null;\n}\n\nconst LOCAL_SCOPE = fallbackDetectGlobalScope();\nconst MODULE_ENV = fallbackLoadModuleEnvironment(LOCAL_SCOPE);\nconst ENV_BRIDGE = fallbackLoadEnvironmentBridge(LOCAL_SCOPE);\nconst MODULE_GLOBALS = fallbackResolveModuleGlobals(LOCAL_SCOPE);\nconst GLOBAL_SCOPE =\n  (ENV_BRIDGE && typeof ENV_BRIDGE.getGlobalScope === 'function'\n    ? ENV_BRIDGE.getGlobalScope()\n    : null)\n  || (MODULE_ENV && typeof MODULE_ENV.getGlobalScope === 'function'\n    ? MODULE_ENV.getGlobalScope()\n    : null)\n  || LOCAL_SCOPE;\n\nconst tryRequire = (function resolveTryRequire() {\n  if (MODULE_GLOBALS && typeof MODULE_GLOBALS.tryRequire === 'function') {\n    return MODULE_GLOBALS.tryRequire;\n  }\n\n  if (ENV_BRIDGE && typeof ENV_BRIDGE.tryRequire === 'function') {\n    return function bridgeTryRequire(modulePath) {\n      const result = ENV_BRIDGE.tryRequire(modulePath);\n      return typeof result === 'undefined' ? fallbackTryRequire(modulePath) : result;\n    };\n  }\n\n  if (MODULE_ENV && typeof MODULE_ENV.tryRequire === 'function') {\n    return MODULE_ENV.tryRequire;\n  }\n\n  return fallbackTryRequire;\n})();\n\nconst structuredCloneCandidates = (function collectStructuredCloneCandidates() {\n  const candidates = [];\n\n  function addCandidate(fn, scope) {\n    if (typeof fn !== 'function') {\n      return;\n    }\n    const alreadyPresent = candidates.some(candidate => candidate && candidate.fn === fn);\n    if (!alreadyPresent) {\n      candidates.push({ fn, scope: scope || null });\n    }\n  }\n\n  if (MODULE_GLOBALS) {\n    if (typeof MODULE_GLOBALS.structuredClone === 'function') {\n      addCandidate(MODULE_GLOBALS.structuredClone, MODULE_GLOBALS);\n    }\n    if (typeof MODULE_GLOBALS.getStructuredClone === 'function') {\n      try {\n        const resolved = MODULE_GLOBALS.getStructuredClone();\n        addCandidate(resolved, MODULE_GLOBALS);\n      } catch (error) {\n        void error;\n      }\n    }\n  }\n\n  if (ENV_BRIDGE) {\n    if (typeof ENV_BRIDGE.structuredClone === 'function') {\n      addCandidate(ENV_BRIDGE.structuredClone, ENV_BRIDGE);\n    }\n    if (typeof ENV_BRIDGE.getStructuredClone === 'function') {\n      try {\n        const resolved = ENV_BRIDGE.getStructuredClone();\n        addCandidate(resolved, ENV_BRIDGE);\n      } catch (error) {\n        void error;\n      }\n    }\n  }\n\n  if (MODULE_ENV) {\n    if (typeof MODULE_ENV.structuredClone === 'function') {\n      addCandidate(MODULE_ENV.structuredClone, MODULE_ENV);\n    }\n    if (typeof MODULE_ENV.getStructuredClone === 'function') {\n      try {\n        const resolved = MODULE_ENV.getStructuredClone();\n        addCandidate(resolved, MODULE_ENV);\n      } catch (error) {\n        void error;\n      }\n    }\n  }\n\n  const scopes = fallbackCollectCandidateScopes(GLOBAL_SCOPE);\n  for (let index = 0; index < scopes.length; index += 1) {\n    const scope = scopes[index];\n    if (!scope || (typeof scope !== 'object' && typeof scope !== 'function')) {\n      continue;\n    }\n    const candidate = scope.structuredClone;\n    if (typeof candidate === 'function') {\n      addCandidate(candidate, scope);\n    }\n  }\n\n  return candidates;\n})();\n\nlet cachedStructuredCloneCandidate = null;\n\nfunction tryStructuredCloneValue(value) {\n  if (cachedStructuredCloneCandidate) {\n    try {\n      const candidate = cachedStructuredCloneCandidate;\n      return {\n        success: true,\n        value: candidate.scope ? candidate.fn.call(candidate.scope, value) : candidate.fn(value),\n      };\n    } catch (error) {\n      void error;\n      cachedStructuredCloneCandidate = null;\n    }\n  }\n\n  for (let index = 0; index < structuredCloneCandidates.length; index += 1) {\n    const candidate = structuredCloneCandidates[index];\n    if (!candidate || typeof candidate.fn !== 'function') {\n      continue;\n    }\n    try {\n      const cloned = candidate.scope ? candidate.fn.call(candidate.scope, value) : candidate.fn(value);\n      cachedStructuredCloneCandidate = candidate;\n      return { success: true, value: cloned };\n    } catch (error) {\n      void error;\n    }\n  }\n\n  return { success: false, value: null };\n}\n\nfunction resolveModuleRegistry(scope) {\n  if (MODULE_GLOBALS && typeof MODULE_GLOBALS.resolveModuleRegistry === 'function') {\n    try {\n      const resolved = MODULE_GLOBALS.resolveModuleRegistry(scope || GLOBAL_SCOPE);\n      if (resolved) {\n        return resolved;\n      }\n    } catch (error) {\n      void error;\n    }\n  }\n\n  if (ENV_BRIDGE && typeof ENV_BRIDGE.getModuleRegistry === 'function') {\n    try {\n      const bridged = ENV_BRIDGE.getModuleRegistry(scope || GLOBAL_SCOPE);\n      if (bridged) {\n        return bridged;\n      }\n    } catch (error) {\n      void error;\n    }\n  }\n\n  if (MODULE_ENV && typeof MODULE_ENV.resolveModuleRegistry === 'function') {\n    try {\n      return MODULE_ENV.resolveModuleRegistry(scope || GLOBAL_SCOPE);\n    } catch (error) {\n      void error;\n    }\n  }\n\n  // Use imported cineModules if available\n  if (cineModules && typeof cineModules === 'object') {\n    return cineModules;\n  }\n\n  const scopes = fallbackCollectCandidateScopes(scope || GLOBAL_SCOPE);\n\n  for (let index = 0; index < scopes.length; index += 1) {\n    const candidate = scopes[index];\n    if (candidate && typeof candidate.cineModules === 'object') {\n      return candidate.cineModules;\n    }\n  }\n\n  return null;\n}\n\nconst MODULE_REGISTRY = (function resolveRegistry() {\n  if (MODULE_GLOBALS && typeof MODULE_GLOBALS.getModuleRegistry === 'function') {\n    try {\n      const shared = MODULE_GLOBALS.getModuleRegistry(GLOBAL_SCOPE);\n      if (shared) {\n        return shared;\n      }\n    } catch (error) {\n      void error;\n    }\n  }\n\n  if (ENV_BRIDGE && typeof ENV_BRIDGE.getModuleRegistry === 'function') {\n    try {\n      const bridged = ENV_BRIDGE.getModuleRegistry(GLOBAL_SCOPE);\n      if (bridged) {\n        return bridged;\n      }\n    } catch (error) {\n      void error;\n    }\n  }\n\n  if (MODULE_ENV && typeof MODULE_ENV.getModuleRegistry === 'function') {\n    try {\n      const provided = MODULE_ENV.getModuleRegistry(GLOBAL_SCOPE);\n      if (provided) {\n        return provided;\n      }\n    } catch (error) {\n      void error;\n    }\n  }\n\n  return resolveModuleRegistry();\n})();\n\nconst queueModuleRegistration = (function resolveQueueModuleRegistration() {\n  if (MODULE_GLOBALS && typeof MODULE_GLOBALS.queueModuleRegistration === 'function') {\n    return function queueModuleRegistration(name, api, options, scope) {\n      try {\n        return MODULE_GLOBALS.queueModuleRegistration(name, api, options, scope || GLOBAL_SCOPE);\n      } catch (error) {\n        void error;\n        return false;\n      }\n    };\n  }\n\n  if (ENV_BRIDGE && typeof ENV_BRIDGE.queueModuleRegistration === 'function') {\n    return function bridgeQueueModuleRegistration(name, api, options) {\n      try {\n        const bridged = ENV_BRIDGE.queueModuleRegistration(name, api, options);\n        return typeof bridged === 'undefined' ? false : bridged;\n      } catch (error) {\n        void error;\n        return false;\n      }\n    };\n  }\n\n  if (MODULE_ENV && typeof MODULE_ENV.queueModuleRegistration === 'function') {\n    return function envQueueModuleRegistration(name, api, options, scope) {\n      try {\n        return MODULE_ENV.queueModuleRegistration(name, api, options, scope || GLOBAL_SCOPE);\n      } catch (error) {\n        void error;\n        return false;\n      }\n    };\n  }\n\n  return function fallbackQueueModuleRegistration() {\n    return false;\n  };\n})();\n\nconst registerOrQueueModule = (function resolveRegisterOrQueue() {\n  if (MODULE_GLOBALS && typeof MODULE_GLOBALS.registerOrQueueModule === 'function') {\n    return function registerOrQueueModule(name, api, options, onError, scope, registry) {\n      try {\n        const registered = MODULE_GLOBALS.registerOrQueueModule(\n          name,\n          api,\n          options,\n          onError,\n          scope || GLOBAL_SCOPE,\n          registry || MODULE_REGISTRY,\n        );\n        return typeof registered === 'undefined' ? false : registered;\n      } catch (error) {\n        void error;\n        return false;\n      }\n    };\n  }\n\n  if (ENV_BRIDGE && typeof ENV_BRIDGE.registerOrQueueModule === 'function') {\n    return function bridgeRegisterOrQueueModule(name, api, options, onError, scope, registry) {\n      try {\n        const bridged = ENV_BRIDGE.registerOrQueueModule(\n          name,\n          api,\n          options,\n          onError,\n          scope || GLOBAL_SCOPE,\n          registry || MODULE_REGISTRY,\n        );\n        return typeof bridged === 'undefined' ? false : bridged;\n      } catch (error) {\n        void error;\n        return false;\n      }\n    };\n  }\n\n  if (MODULE_ENV && typeof MODULE_ENV.registerOrQueueModule === 'function') {\n    return function envRegisterOrQueueModule(name, api, options, onError, scope, registry) {\n      try {\n        return MODULE_ENV.registerOrQueueModule(\n          name,\n          api,\n          options,\n          onError,\n          scope || GLOBAL_SCOPE,\n          registry || MODULE_REGISTRY,\n        );\n      } catch (error) {\n        void error;\n        return false;\n      }\n    };\n  }\n\n  return function fallbackRegisterOrQueueModule(name, api, options, onError) {\n    if (typeof onError === 'function') {\n      try {\n        // Attempt global registry fallback\n        if (typeof window !== 'undefined' && window.cineModuleRegistry && typeof window.cineModuleRegistry.register === 'function') {\n          window.cineModuleRegistry.register(name, api, options);\n          return true;\n        }\n        // Instead of throwing (\"onError(new Error...\"), just warn to console.\n        // Identify that we are in a fallback state but don't crash.\n        console.warn('Logging module registration deferred - queue unavailable.');\n      } catch (error) {\n        void error;\n      }\n    }\n    void name;\n    void api;\n    void options;\n    return false;\n  };\n})();\n\n\n\nfunction isNodeProcessReference(value) {\n  if (!value) {\n    return false;\n  }\n\n  if (typeof process === 'undefined' || !process) {\n    return false;\n  }\n\n  if (value === process) {\n    return true;\n  }\n\n  if (typeof value === 'object') {\n    try {\n      if (value.constructor && value.constructor.name === 'process') {\n        return true;\n      }\n    } catch (processInspectionError) {\n      void processInspectionError;\n    }\n\n    if (\n      typeof value.pid === 'number' &&\n      typeof value.nextTick === 'function' &&\n      typeof value.emit === 'function' &&\n      typeof value.binding === 'function'\n    ) {\n      return true;\n    }\n  }\n\n  if (typeof value === 'function') {\n    if (\n      value === process.binding ||\n      value === process._linkedBinding ||\n      value === process.dlopen\n    ) {\n      return true;\n    }\n\n    try {\n      const functionName = value.name || '';\n      if (functionName && (functionName === 'binding' || functionName === 'dlopen')) {\n        const source = Function.prototype.toString.call(value);\n        if (source && source.indexOf('[native code]') !== -1) {\n          return true;\n        }\n      }\n    } catch (functionInspectionError) {\n      void functionInspectionError;\n    }\n  }\n\n  return false;\n}\n\nfunction shouldBypassDeepFreeze(value) {\n  if (!value || typeof value !== 'object') {\n    return true;\n  }\n\n  if (isNodeProcessReference(value)) {\n    return true;\n  }\n\n  if (\n    typeof process !== 'undefined' &&\n    process &&\n    process.release &&\n    process.release.name === 'node'\n  ) {\n    return true;\n  }\n\n\n  const ctor = value.constructor;\n  if (!ctor) {\n    return false;\n  }\n\n  if (\n    ctor === Number\n    || ctor === String\n    || ctor === Boolean\n    || ctor === Date\n    || ctor === RegExp\n    || ctor === Promise\n    || ctor === WeakMap\n    || ctor === WeakSet\n    || ctor === Map\n    || ctor === Set\n  ) {\n    return true;\n  }\n\n  const ctorName = typeof ctor.name === 'string' ? ctor.name : '';\n  if (ctorName && /Error|Event|Response|Request|Headers|Node|Element|Window|Document/.test(ctorName)) {\n    return true;\n  }\n\n  try {\n    if (typeof value.then === 'function' || typeof value.catch === 'function') {\n      return true;\n    }\n    if (typeof value.pipe === 'function' || typeof value.on === 'function') {\n      return true;\n    }\n    if (typeof value.write === 'function' || typeof value.read === 'function') {\n      return true;\n    }\n    if (typeof value.getReader === 'function' || typeof value.getWriter === 'function') {\n      return true;\n    }\n    if (typeof value[Symbol.iterator] === 'function' && !Array.isArray(value)) {\n      return true;\n    }\n    if (typeof Symbol !== 'undefined' && value[Symbol.toStringTag]) {\n      const tag = value[Symbol.toStringTag];\n      if (typeof tag === 'string' && /Stream|Port|Process/.test(tag)) {\n        return true;\n      }\n    }\n  } catch (inspectionError) {\n    void inspectionError;\n  }\n\n  return false;\n}\n\nfunction fallbackFreezeDeep(value, seen) {\n  const visited = seen || (typeof WeakSet === 'function' ? new WeakSet() : {\n    add() { },\n    has() {\n      return false;\n    },\n  });\n\n  if (!value || typeof value !== 'object') {\n    return value;\n  }\n\n  if (shouldBypassDeepFreeze(value)) {\n    return value;\n  }\n\n  if (typeof process !== 'undefined' && process && process.env && process.env.JEST_WORKER_ID) {\n    try {\n      if (typeof Object.freeze === 'function') {\n        Object.freeze(value);\n      }\n    } catch (freezeError) {\n      void freezeError;\n    }\n    return value;\n  }\n\n  if (typeof visited.has === 'function' && visited.has(value)) {\n    return value;\n  }\n\n  if (typeof visited.add === 'function') {\n    visited.add(value);\n  }\n\n  const keys = Object.getOwnPropertyNames(value);\n  for (let index = 0; index < keys.length; index += 1) {\n    const key = keys[index];\n    let child;\n    try {\n      child = value[key];\n    } catch (accessError) {\n      void accessError;\n      child = undefined;\n    }\n    if (!child || typeof child === 'function' || (typeof child !== 'object' && typeof child !== 'function')) {\n      continue;\n    }\n    fallbackFreezeDeep(child, visited);\n  }\n\n  try {\n    try {\n      return Object.freeze(value);\n    } catch (freezeError) {\n      void freezeError;\n      return value;\n    }\n  } catch (freezeError) {\n    void freezeError;\n    return value;\n  }\n}\n\nconst freezeDeep = (function resolveFreezeDeep() {\n  if (MODULE_GLOBALS && typeof MODULE_GLOBALS.freezeDeep === 'function') {\n    return MODULE_GLOBALS.freezeDeep;\n  }\n\n  if (ENV_BRIDGE && typeof ENV_BRIDGE.freezeDeep === 'function') {\n    return function bridgeFreezeDeep(value, seen) {\n      try {\n        return ENV_BRIDGE.freezeDeep(value, seen);\n      } catch (error) {\n        void error;\n        return fallbackFreezeDeep(value, seen);\n      }\n    };\n  }\n\n  if (MODULE_ENV && typeof MODULE_ENV.freezeDeep === 'function') {\n    return MODULE_ENV.freezeDeep;\n  }\n\n  return fallbackFreezeDeep;\n})();\n\nfunction fallbackSafeWarn(message, detail) {\n  if (typeof console === 'undefined' || typeof console.warn !== 'function') {\n    return;\n  }\n\n  try {\n    if (typeof detail === 'undefined') {\n      console.warn(message);\n    } else {\n      console.warn(message, detail);\n    }\n  } catch (error) {\n    void error;\n  }\n}\n\nconst safeWarn = (function resolveSafeWarn() {\n  if (MODULE_GLOBALS && typeof MODULE_GLOBALS.safeWarn === 'function') {\n    return MODULE_GLOBALS.safeWarn;\n  }\n\n  if (ENV_BRIDGE && typeof ENV_BRIDGE.safeWarn === 'function') {\n    return function bridgeSafeWarn(message, detail) {\n      try {\n        ENV_BRIDGE.safeWarn(message, detail);\n      } catch (error) {\n        void error;\n        fallbackSafeWarn(message, detail);\n      }\n    };\n  }\n\n  if (MODULE_ENV && typeof MODULE_ENV.safeWarn === 'function') {\n    return MODULE_ENV.safeWarn;\n  }\n\n  return fallbackSafeWarn;\n})();\n\nconst CONSOLE_METHODS = ['debug', 'info', 'warn', 'error', 'log'];\nconst CONSOLE_PROXY_FLAG = typeof Symbol === 'function'\n  ? Symbol.for('cineLoggingConsoleProxyInstalled')\n  : '__cineLoggingConsoleProxyInstalled__';\n\n/**\n * DEEP DIVE: Console Proxying\n *\n * Why do we proxy `console` methods?\n * 1. Centralized Control: Users can \"silence\" logs via settings without code changes.\n * 2. Log Levels: We implement standard levels (DEBUG, INFO, WARN, ERROR) over the raw console.\n * 3. Remote Telemetry (Future): Allows hooking into logs to send them to a server/service.\n *\n * Safety First: We capture the *original* console functions first so we never create infinite loops.\n */\nconst ORIGINAL_CONSOLE_FUNCTIONS = (function captureOriginalConsoleFunctions() {\n  const store = Object.create(null);\n  if (typeof console === 'undefined' || !console) {\n    return store;\n  }\n\n  for (let index = 0; index < CONSOLE_METHODS.length; index += 1) {\n    const method = CONSOLE_METHODS[index];\n    try {\n      const fn = console[method];\n      store[method] = typeof fn === 'function' ? fn : null;\n    } catch (error) {\n      store[method] = null;\n      void error;\n    }\n  }\n\n  return store;\n})();\n\nlet consoleProxyInstalled = false;\nlet consoleProxyInstallationAttempted = false;\nlet consoleProxyInstallationFailed = false;\nlet lastConsoleCaptureState = null;\nlet consoleProxyWarningIssued = false;\nlet consoleProxyGuardDepth = 0;\n\nconst exposeGlobal = (function resolveExposeGlobal() {\n  if (MODULE_GLOBALS && typeof MODULE_GLOBALS.exposeGlobal === 'function') {\n    return function exposeGlobal(name, value, options) {\n      try {\n        return MODULE_GLOBALS.exposeGlobal(name, value, options);\n      } catch (error) {\n        void error;\n        return false;\n      }\n    };\n  }\n\n  return function fallbackExposeGlobal(name, value) {\n    if (!GLOBAL_SCOPE || (typeof GLOBAL_SCOPE !== 'object' && typeof GLOBAL_SCOPE !== 'function')) {\n      return false;\n    }\n    try {\n      GLOBAL_SCOPE[name] = value;\n      return true;\n    } catch (error) {\n      void error;\n      return false;\n    }\n  };\n})();\n\nfunction informModuleGlobals(name, api) {\n  if (!MODULE_GLOBALS || typeof MODULE_GLOBALS.recordModule !== 'function') {\n    return;\n  }\n\n  try {\n    MODULE_GLOBALS.recordModule(name, api);\n  } catch (error) {\n    void error;\n  }\n}\n\nconst LOG_LEVEL_MAP = {\n  debug: { priority: 10, consoleMethod: 'debug' },\n  info: { priority: 20, consoleMethod: 'info' },\n  warn: { priority: 30, consoleMethod: 'warn' },\n  error: { priority: 40, consoleMethod: 'error' },\n};\n\nconst LOG_LEVELS = freezeDeep(LOG_LEVEL_MAP);\n\nconst LEVEL_COUNTER_KEYS = Object.freeze(Object.keys(LOG_LEVEL_MAP).concat(['other']));\n\nfunction createLevelCounters() {\n  const counters = Object.create(null);\n  for (let index = 0; index < LEVEL_COUNTER_KEYS.length; index += 1) {\n    const key = LEVEL_COUNTER_KEYS[index];\n    counters[key] = 0;\n  }\n  return counters;\n}\n\nfunction resetLevelCounters(counters) {\n  if (!counters || typeof counters !== 'object') {\n    return;\n  }\n\n  for (let index = 0; index < LEVEL_COUNTER_KEYS.length; index += 1) {\n    const key = LEVEL_COUNTER_KEYS[index];\n    counters[key] = 0;\n  }\n}\n\nfunction resolveLevelKey(level) {\n  if (typeof level === 'string' && level) {\n    if (Object.prototype.hasOwnProperty.call(LOG_LEVEL_MAP, level)) {\n      return level;\n    }\n    const trimmed = level.trim().toLowerCase();\n    if (Object.prototype.hasOwnProperty.call(LOG_LEVEL_MAP, trimmed)) {\n      return trimmed;\n    }\n  }\n  return 'other';\n}\n\nfunction getCounterValue(counters, key) {\n  if (!counters || typeof counters !== 'object') {\n    return 0;\n  }\n\n  const value = counters[key];\n  return typeof value === 'number' && Number.isFinite(value) && value > 0 ? value : 0;\n}\n\nfunction applyLevelCounterDelta(counters, level, delta) {\n  if (!counters || typeof counters !== 'object') {\n    return;\n  }\n\n  if (typeof delta !== 'number' || !Number.isFinite(delta) || delta === 0) {\n    return;\n  }\n\n  const key = resolveLevelKey(level);\n  const current = getCounterValue(counters, key);\n  const next = current + delta;\n  counters[key] = next > 0 ? next : 0;\n}\n\nfunction applyLevelCounterDeltaForEntries(counters, entries, delta) {\n  if (!Array.isArray(entries) || !entries.length) {\n    return;\n  }\n\n  if (typeof delta !== 'number' || !Number.isFinite(delta) || delta === 0) {\n    return;\n  }\n\n  for (let index = 0; index < entries.length; index += 1) {\n    const entry = entries[index];\n    const level = entry && entry.level;\n    applyLevelCounterDelta(counters, level, delta);\n  }\n}\n\nfunction summariseEntriesByLevel(entries) {\n  const summary = createLevelCounters();\n  applyLevelCounterDeltaForEntries(summary, entries, 1);\n  return summary;\n}\n\nfunction accumulateLevelSummary(target, summary) {\n  if (!target || typeof target !== 'object' || !summary || typeof summary !== 'object') {\n    return;\n  }\n\n  for (let index = 0; index < LEVEL_COUNTER_KEYS.length; index += 1) {\n    const key = LEVEL_COUNTER_KEYS[index];\n    const increment = getCounterValue(summary, key);\n    if (increment) {\n      const current = getCounterValue(target, key);\n      target[key] = current + increment;\n    }\n  }\n}\n\nfunction cloneLevelSummary(summary) {\n  const clone = createLevelCounters();\n  accumulateLevelSummary(clone, summary);\n  return clone;\n}\n\nfunction freezeLevelSummary(summary) {\n  return freezeDeep(cloneLevelSummary(summary));\n}\n\nconst HISTORY_MIN_LIMIT = 50;\nconst HISTORY_ABSOLUTE_MIN_LIMIT = 1;\nconst HISTORY_MAX_LIMIT = 5000;\nconst HISTORY_STORAGE_KEY = '__cineLoggingHistory';\nconst CONFIG_STORAGE_KEY = '__cineLoggingConfig';\nconst ERROR_EVENT_FLAG =\n  typeof Symbol === 'function' ? Symbol.for('cineLoggingHandled') : '__cineLoggingHandled__';\nconst DEFAULT_CONFIG_VALUES = {\n  level: 'warn',\n  historyLevel: 'info',\n  historyLimit: 1200,\n  consoleOutput: true,\n  persistSession: true,\n  captureGlobalErrors: true,\n  captureConsole: false,\n  stackTraces: true,\n};\n\nconst DEFAULT_CONFIG = freezeDeep(DEFAULT_CONFIG_VALUES);\n\nconst SERVICE_WORKER_LOG_CHANNEL = 'cine-sw-logs';\nconst SERVICE_WORKER_LOG_ENTRY_TYPE = 'cine-sw:log-entry';\nconst SERVICE_WORKER_LOG_STATE_REQUEST = 'cine-sw:log-state-request';\nconst SERVICE_WORKER_LOG_STATE_RESPONSE = 'cine-sw:log-state';\nconst SERVICE_WORKER_LOG_REQUEST_TIMEOUT = 5000;\nconst SERVICE_WORKER_LOG_POLL_INTERVAL = 60 * 1000;\nconst SERVICE_WORKER_LOG_HISTORY_LIMIT = 200;\n\nfunction cloneDefaultConfig() {\n  return {\n    level: DEFAULT_CONFIG_VALUES.level,\n    historyLevel: DEFAULT_CONFIG_VALUES.historyLevel,\n    historyLimit: DEFAULT_CONFIG_VALUES.historyLimit,\n    consoleOutput: DEFAULT_CONFIG_VALUES.consoleOutput,\n    persistSession: DEFAULT_CONFIG_VALUES.persistSession,\n    captureGlobalErrors: DEFAULT_CONFIG_VALUES.captureGlobalErrors,\n    captureConsole: DEFAULT_CONFIG_VALUES.captureConsole,\n    stackTraces: DEFAULT_CONFIG_VALUES.stackTraces,\n  };\n}\n\nlet activeConfig = cloneDefaultConfig();\nconst logHistory = [];\nconst logSubscribers = new Set();\nconst configSubscribers = new Set();\nconst attachedErrorTargets = typeof WeakSet === 'function' ? new WeakSet() : [];\nlet runtimeEntryCount = 0;\nconst emittedLevelCounters = createLevelCounters();\nconst retainedLevelCounters = createLevelCounters();\nconst droppedLevelCounters = createLevelCounters();\nlet totalEntriesDropped = 0;\nlet lastHistoryDrop = null;\nconst serviceWorkerBridgeState = {\n  initialised: false,\n  supported: false,\n  requestInFlight: false,\n  lastRequestId: null,\n  pollTimer: null,\n  requestTimer: null,\n  broadcastChannel: null,\n  broadcastFailed: false,\n  seenIds: typeof Set === 'function' ? new Set() : null,\n  fallbackSeenIds: typeof Set !== 'function' ? [] : null,\n  lastSnapshotMeta: null,\n};\n\nfunction normalizeLevel(value, fallbackLevel) {\n  const fallback = typeof fallbackLevel === 'string' ? fallbackLevel : activeConfig.level;\n\n  if (typeof value === 'string') {\n    const trimmed = value.trim().toLowerCase();\n    if (Object.prototype.hasOwnProperty.call(LOG_LEVEL_MAP, trimmed)) {\n      return trimmed;\n    }\n    if (trimmed === 'log' || trimmed === 'information') {\n      return 'info';\n    }\n    if (trimmed === 'warning') {\n      return 'warn';\n    }\n    if (trimmed === 'trace' || trimmed === 'verbose') {\n      return 'debug';\n    }\n    if (trimmed === 'fatal' || trimmed === 'critical') {\n      return 'error';\n    }\n  }\n\n  if (Object.prototype.hasOwnProperty.call(LOG_LEVEL_MAP, fallback)) {\n    return fallback;\n  }\n\n  return 'info';\n}\n\nfunction getLevelPriority(level) {\n  const normalized = normalizeLevel(level, 'info');\n  const descriptor = LOG_LEVEL_MAP[normalized];\n  return descriptor ? descriptor.priority : LOG_LEVEL_MAP.info.priority;\n}\n\nfunction booleanFromValue(value, fallback) {\n  if (typeof value === 'boolean') {\n    return value;\n  }\n  if (typeof value === 'number') {\n    if (!Number.isFinite(value)) {\n      return Boolean(fallback);\n    }\n    if (value === 1) {\n      return true;\n    }\n    if (value === 0) {\n      return false;\n    }\n    return value > 0;\n  }\n  if (typeof value === 'string') {\n    const normalized = value.trim().toLowerCase();\n    if (normalized === 'true' || normalized === '1' || normalized === 'yes' || normalized === 'on') {\n      return true;\n    }\n    if (normalized === 'false' || normalized === '0' || normalized === 'no' || normalized === 'off') {\n      return false;\n    }\n  }\n  return typeof fallback === 'boolean' ? fallback : false;\n}\n\nfunction clampHistoryLimit(value, options) {\n  const allowReducedMinimum =\n    options && options.allowReducedMin === true ? true : false;\n  const effectiveMinimum = allowReducedMinimum ? HISTORY_ABSOLUTE_MIN_LIMIT : HISTORY_MIN_LIMIT;\n\n  if (typeof value === 'number' && Number.isFinite(value)) {\n    const absolute = Math.abs(Math.floor(value));\n    if (!absolute) {\n      return activeConfig.historyLimit;\n    }\n    return Math.max(effectiveMinimum, Math.min(HISTORY_MAX_LIMIT, absolute));\n  }\n\n  if (typeof value === 'string' && value) {\n    const parsed = Number(value);\n    if (Number.isFinite(parsed)) {\n      return clampHistoryLimit(parsed, options);\n    }\n  }\n\n  return activeConfig.historyLimit;\n}\n\nfunction coerceMessage(value) {\n  if (typeof value === 'string') {\n    return value;\n  }\n  if (value instanceof Error) {\n    return value.message || value.name || 'Error';\n  }\n  if (value && typeof value === 'object') {\n    if (typeof value.message === 'string') {\n      return value.message;\n    }\n    const ctorName = value.constructor && value.constructor.name;\n    if (ctorName) {\n      return ctorName;\n    }\n  }\n  if (typeof value === 'number' || typeof value === 'boolean') {\n    return String(value);\n  }\n  if (typeof value === 'undefined' || value === null) {\n    return '';\n  }\n  try {\n    return String(value);\n  } catch (error) {\n    void error;\n  }\n  return Object.prototype.toString.call(value);\n}\n\nfunction sanitizeForLog(value, depth, seen) {\n  const nextDepth = typeof depth === 'number' ? depth : 0;\n  const visited = seen || (typeof WeakSet === 'function' ? new WeakSet() : null);\n\n  if (value === null || typeof value === 'undefined') {\n    return null;\n  }\n\n  const valueType = typeof value;\n\n  if (valueType === 'string' || valueType === 'number' || valueType === 'boolean') {\n    return value;\n  }\n\n  if (valueType === 'bigint') {\n    try {\n      return value.toString();\n    } catch (error) {\n      void error;\n      return 'BigInt';\n    }\n  }\n\n  if (valueType === 'symbol') {\n    try {\n      return value.toString();\n    } catch (error) {\n      void error;\n      return 'Symbol';\n    }\n  }\n\n  if (valueType === 'function') {\n    const name = value.name ? ` ${value.name}` : '';\n    return `[Function${name}]`;\n  }\n\n  if (value instanceof Date) {\n    try {\n      return value.toISOString();\n    } catch (error) {\n      void error;\n      return value.toString();\n    }\n  }\n\n  if (typeof RegExp !== 'undefined' && value instanceof RegExp) {\n    try {\n      return value.toString();\n    } catch (error) {\n      void error;\n    }\n    return '[RegExp]';\n  }\n\n  if (value instanceof Error) {\n    const errorOutput = {\n      name: value.name,\n      message: value.message,\n    };\n    if (value.stack) {\n      errorOutput.stack = String(value.stack);\n    }\n    if (typeof value.code !== 'undefined') {\n      errorOutput.code = value.code;\n    }\n    if (typeof value.status !== 'undefined') {\n      errorOutput.status = value.status;\n    }\n    if (typeof value.cause !== 'undefined' && value.cause !== null) {\n      errorOutput.cause = sanitizeForLog(value.cause, nextDepth + 1, visited);\n    }\n    if (typeof value.details !== 'undefined') {\n      errorOutput.details = sanitizeForLog(value.details, nextDepth + 1, visited);\n    }\n    if (typeof value.errors !== 'undefined' && value.errors !== null) {\n      const collectedErrors = [];\n      const maxErrors = 10;\n      let truncatedErrors = 0;\n\n      const appendErrorDetail = function appendErrorDetail(candidate) {\n        if (collectedErrors.length >= maxErrors) {\n          truncatedErrors += 1;\n          return;\n        }\n        try {\n          collectedErrors.push(sanitizeForLog(candidate, nextDepth + 1, visited));\n        } catch (error) {\n          collectedErrors.push(\n            error && error.message ? `[Unserializable error: ${error.message}]` : '[Unserializable error]'\n          );\n        }\n      };\n\n      const rawErrors = value.errors;\n      if (Array.isArray(rawErrors)) {\n        for (let index = 0; index < rawErrors.length; index += 1) {\n          appendErrorDetail(rawErrors[index]);\n        }\n        if (rawErrors.length > collectedErrors.length) {\n          truncatedErrors += rawErrors.length - collectedErrors.length;\n        }\n      } else if (rawErrors && typeof rawErrors === 'object') {\n        let iterator = null;\n        try {\n          const symbolIterator = typeof Symbol === 'function' ? Symbol.iterator : null;\n          if (symbolIterator && typeof rawErrors[symbolIterator] === 'function') {\n            iterator = rawErrors[symbolIterator].call(rawErrors);\n          }\n        } catch (iteratorError) {\n          iterator = null;\n          void iteratorError;\n        }\n\n        if (iterator && typeof iterator.next === 'function') {\n          let result = iterator.next();\n          let count = 0;\n          while (!result.done) {\n            if (count < maxErrors) {\n              appendErrorDetail(result.value);\n            } else {\n              truncatedErrors += 1;\n            }\n            count += 1;\n            try {\n              result = iterator.next();\n            } catch (iterationError) {\n              truncatedErrors += 1;\n              void iterationError;\n              break;\n            }\n          }\n        } else {\n          appendErrorDetail(rawErrors);\n        }\n      } else {\n        appendErrorDetail(rawErrors);\n      }\n\n      if (collectedErrors.length) {\n        errorOutput.errors = collectedErrors;\n        if (truncatedErrors > 0) {\n          errorOutput.errorsTruncated = truncatedErrors;\n        }\n      }\n    }\n    return errorOutput;\n  }\n\n  if (valueType === 'object') {\n    if (visited) {\n      try {\n        if (visited.has(value)) {\n          return '[Circular]';\n        }\n        visited.add(value);\n      } catch (error) {\n        void error;\n      }\n    }\n\n    if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n      return {\n        __type: 'ArrayBuffer',\n        byteLength: value.byteLength,\n      };\n    }\n\n    if (typeof DataView !== 'undefined' && value instanceof DataView) {\n      return {\n        __type: 'DataView',\n        byteOffset: value.byteOffset,\n        byteLength: value.byteLength,\n      };\n    }\n\n    if (\n      typeof ArrayBuffer !== 'undefined'\n      && typeof ArrayBuffer.isView === 'function'\n      && ArrayBuffer.isView(value)\n    ) {\n      const ctorName = value.constructor && value.constructor.name;\n      const maxPreview = 32;\n      const length = typeof value.length === 'number' ? value.length : 0;\n      const preview = [];\n      const previewLength = Math.min(length, maxPreview);\n      for (let index = 0; index < previewLength; index += 1) {\n        preview.push(value[index]);\n      }\n      const summary = {\n        __type: ctorName || 'TypedArray',\n        length,\n        byteOffset: typeof value.byteOffset === 'number' ? value.byteOffset : 0,\n        byteLength: typeof value.byteLength === 'number' ? value.byteLength : 0,\n      };\n      if (preview.length) {\n        summary.preview = preview;\n      }\n      if (length > maxPreview) {\n        summary.__truncatedItems = length - maxPreview;\n      }\n      return summary;\n    }\n\n    const mapCtor = typeof Map === 'function' ? Map : null;\n    if (mapCtor && value instanceof mapCtor) {\n      const entries = [];\n      const maxEntries = 30;\n      let index = 0;\n      value.forEach((mapValue, mapKey) => {\n        if (index < maxEntries) {\n          entries.push({\n            key: sanitizeForLog(mapKey, nextDepth + 1, visited),\n            value: sanitizeForLog(mapValue, nextDepth + 1, visited),\n          });\n        }\n        index += 1;\n      });\n      const result = {\n        __type: 'Map',\n        size: typeof value.size === 'number' ? value.size : index,\n        entries,\n      };\n      if (index > maxEntries) {\n        result.__truncatedEntries = index - maxEntries;\n      }\n      return result;\n    }\n\n    const setCtor = typeof Set === 'function' ? Set : null;\n    if (setCtor && value instanceof setCtor) {\n      const items = [];\n      const maxItems = 30;\n      let index = 0;\n      value.forEach(item => {\n        if (index < maxItems) {\n          items.push(sanitizeForLog(item, nextDepth + 1, visited));\n        }\n        index += 1;\n      });\n      const result = {\n        __type: 'Set',\n        size: typeof value.size === 'number' ? value.size : index,\n        values: items,\n      };\n      if (index > maxItems) {\n        result.__truncatedValues = index - maxItems;\n      }\n      return result;\n    }\n\n    const urlParamsCtor = typeof URLSearchParams === 'function' ? URLSearchParams : null;\n    if (urlParamsCtor && value instanceof urlParamsCtor) {\n      const params = [];\n      const iterator = typeof value.entries === 'function' ? value.entries() : null;\n      let truncated = 0;\n      if (iterator && typeof iterator.next === 'function') {\n        const maxPairs = 40;\n        let count = 0;\n        let next = iterator.next();\n        while (!next.done) {\n          if (count < maxPairs) {\n            const pair = next.value || [];\n            params.push({\n              key: sanitizeForLog(pair[0], nextDepth + 1, visited),\n              value: sanitizeForLog(pair[1], nextDepth + 1, visited),\n            });\n          }\n          count += 1;\n          next = iterator.next();\n        }\n        if (count > params.length) {\n          truncated = count - params.length;\n        }\n      }\n      const result = {\n        __type: 'URLSearchParams',\n        entries: params,\n      };\n      if (truncated > 0) {\n        result.__truncatedEntries = truncated;\n      }\n      return result;\n    }\n\n    if (typeof URL === 'function' && value instanceof URL) {\n      try {\n        return value.toString();\n      } catch (error) {\n        void error;\n      }\n    }\n\n    if (nextDepth >= 4) {\n      const ctorName = value.constructor && value.constructor.name;\n      return ctorName ? `[${ctorName}]` : Object.prototype.toString.call(value);\n    }\n\n    if (Array.isArray(value)) {\n      const maxItems = 20;\n      const result = [];\n      const len = Math.min(value.length, maxItems);\n      for (let index = 0; index < len; index += 1) {\n        result.push(sanitizeForLog(value[index], nextDepth + 1, visited));\n      }\n      if (value.length > maxItems) {\n        result.push(` (${value.length - maxItems} more)`);\n      }\n      return result;\n    }\n\n    const output = {};\n    const keys = Object.keys(value);\n    const maxKeys = 30;\n    const length = Math.min(keys.length, maxKeys);\n    for (let index = 0; index < length; index += 1) {\n      const key = keys[index];\n      try {\n        output[key] = sanitizeForLog(value[key], nextDepth + 1, visited);\n      } catch (error) {\n        output[key] = `[Threw: ${error && error.message ? error.message : 'error'}]`;\n      }\n    }\n    if (keys.length > maxKeys) {\n      output.__truncatedKeys = keys.length - maxKeys;\n    }\n\n    if (typeof Object.getOwnPropertySymbols === 'function') {\n      const symbols = Object.getOwnPropertySymbols(value);\n      const symbolLength = Math.min(symbols.length, 5);\n      for (let index = 0; index < symbolLength; index += 1) {\n        const symbolKey = symbols[index];\n        const symbolName = typeof symbolKey === 'symbol' ? symbolKey.toString() : String(symbolKey);\n        try {\n          output[symbolName] = sanitizeForLog(value[symbolKey], nextDepth + 1, visited);\n        } catch (error) {\n          output[symbolName] = `[Threw: ${error && error.message ? error.message : 'error'}]`;\n        }\n      }\n    }\n\n    if (!keys.length) {\n      const ctorName = value.constructor && value.constructor.name;\n      if (ctorName) {\n        output.__className = ctorName;\n      }\n    }\n\n    return output;\n  }\n\n  const structuredCloneResult = tryStructuredCloneValue(value);\n  if (structuredCloneResult.success) {\n    return structuredCloneResult.value;\n  }\n\n  try {\n    return LOGGING_DEEP_CLONE(value);\n  } catch (error) {\n    void error;\n  }\n\n  try {\n    return String(value);\n  } catch (stringifyError) {\n    void stringifyError;\n  }\n\n  return null;\n}\n\nfunction normaliseStackTrace(stackValue) {\n  if (typeof stackValue !== 'string') {\n    return null;\n  }\n\n  const trimmed = stackValue.replace(/\\r\\n?/g, '\\n').trim();\n  if (!trimmed) {\n    return null;\n  }\n\n  const maxLength = 5000;\n  const charTruncated = trimmed.length > maxLength;\n  const limitedStack = charTruncated ? trimmed.slice(0, maxLength) : trimmed;\n\n  const rawLines = trimmed.split('\\n');\n  const frameLimit = 40;\n  const frames = [];\n  let frameTruncated = false;\n  for (let index = 0; index < rawLines.length; index += 1) {\n    const line = rawLines[index].trim();\n    if (!line) {\n      continue;\n    }\n    if (frames.length < frameLimit) {\n      frames.push(line.length > 500 ? `${line.slice(0, 500)}\\u2026` : line);\n    } else {\n      frameTruncated = true;\n      break;\n    }\n  }\n\n  return {\n    stack: limitedStack,\n    frames,\n    truncated: charTruncated || frameTruncated,\n  };\n}\n\nfunction normaliseOriginSnapshot(origin) {\n  if (!origin || typeof origin !== 'object') {\n    return null;\n  }\n\n  const source = typeof origin.source === 'string' && origin.source\n    ? origin.source\n    : 'unknown';\n\n  let stackSummary = null;\n  if (typeof origin.stack === 'string' && origin.stack) {\n    stackSummary = normaliseStackTrace(origin.stack);\n  }\n\n  const frames = [];\n  if (Array.isArray(origin.frames)) {\n    for (let index = 0; index < origin.frames.length && frames.length < 40; index += 1) {\n      const frame = origin.frames[index];\n      if (typeof frame === 'string' && frame) {\n        frames.push(frame);\n      } else if (frame !== null && typeof frame !== 'undefined') {\n        frames.push(coerceMessage(frame));\n      }\n    }\n  } else if (stackSummary && Array.isArray(stackSummary.frames)) {\n    for (let index = 0; index < stackSummary.frames.length; index += 1) {\n      frames.push(stackSummary.frames[index]);\n    }\n  }\n\n  const truncated = origin.truncated === true\n    || (stackSummary ? stackSummary.truncated === true : false)\n    || (frames.length > 0 && frames.length >= 40);\n\n  const snapshot = {\n    source,\n    truncated,\n  };\n\n  if (stackSummary && stackSummary.stack) {\n    snapshot.stack = stackSummary.stack;\n  } else if (typeof origin.stack === 'string' && origin.stack) {\n    snapshot.stack = origin.stack;\n  } else {\n    snapshot.stack = null;\n  }\n\n  if (frames.length) {\n    snapshot.frames = frames;\n  }\n\n  if (!snapshot.stack && (!snapshot.frames || !snapshot.frames.length)) {\n    return null;\n  }\n\n  return freezeDeep(snapshot);\n}\n\nfunction getSessionStorage() {\n  const scopes = fallbackCollectCandidateScopes(GLOBAL_SCOPE);\n  for (let index = 0; index < scopes.length; index += 1) {\n    const scope = scopes[index];\n    if (!scope || (typeof scope !== 'object' && typeof scope !== 'function')) {\n      continue;\n    }\n    try {\n      const storage = scope.sessionStorage;\n      if (storage && typeof storage.getItem === 'function' && typeof storage.setItem === 'function') {\n        return storage;\n      }\n    } catch (error) {\n      void error;\n    }\n  }\n  return null;\n}\n\nfunction clearStoredHistory() {\n  const storage = getSessionStorage();\n  if (!storage) {\n    return;\n  }\n  try {\n    storage.removeItem(HISTORY_STORAGE_KEY);\n  } catch (error) {\n    void error;\n  }\n}\n\nfunction persistConfigSafe() {\n  const storage = getSessionStorage();\n  if (!storage) {\n    return;\n  }\n\n  if (!activeConfig.persistSession) {\n    try {\n      storage.removeItem(CONFIG_STORAGE_KEY);\n    } catch (error) {\n      void error;\n    }\n    return;\n  }\n\n  try {\n    storage.setItem(\n      CONFIG_STORAGE_KEY,\n      JSON.stringify({\n        level: activeConfig.level,\n        historyLevel: activeConfig.historyLevel,\n        historyLimit: activeConfig.historyLimit,\n        consoleOutput: activeConfig.consoleOutput,\n        persistSession: activeConfig.persistSession,\n        captureGlobalErrors: activeConfig.captureGlobalErrors,\n        captureConsole: activeConfig.captureConsole,\n        stackTraces: activeConfig.stackTraces,\n      }),\n    );\n  } catch (error) {\n    console.warn('cineLogging: Unable to persist logging config', error);\n  }\n}\n\nfunction persistHistorySafe() {\n  if (!activeConfig.persistSession) {\n    clearStoredHistory();\n    return;\n  }\n\n  const storage = getSessionStorage();\n  if (!storage) {\n    return;\n  }\n\n  try {\n    storage.setItem(HISTORY_STORAGE_KEY, JSON.stringify(logHistory));\n  } catch (error) {\n    if (error && (error.name === 'QuotaExceededError' || error.name === 'NS_ERROR_DOM_QUOTA_REACHED')) {\n      // Disable persistence for this session to prevent loop\n      activeConfig.persistSession = false;\n      try {\n        storage.removeItem(HISTORY_STORAGE_KEY);\n      } catch (e) { void e; }\n      // Do NOT log a warning here, as it might trigger the proxy and cause a loop\n      return;\n    }\n    console.warn('cineLogging: Unable to persist log history', error);\n  }\n}\n\nfunction getEffectiveHistoryLimit() {\n  const effectiveMinimum = activeConfig.persistSession === false\n    ? HISTORY_ABSOLUTE_MIN_LIMIT\n    : HISTORY_MIN_LIMIT;\n\n  return Math.max(\n    effectiveMinimum,\n    Math.min(HISTORY_MAX_LIMIT, Math.floor(activeConfig.historyLimit)),\n  );\n}\n\nfunction recordHistoryDrop(removedEntries, limit, options) {\n  if (!Array.isArray(removedEntries) || removedEntries.length === 0) {\n    return null;\n  }\n\n  totalEntriesDropped += removedEntries.length;\n  const removedSummary = summariseEntriesByLevel(removedEntries);\n\n  const source = options && typeof options.source === 'string' && options.source.trim()\n    ? options.source.trim()\n    : 'enforce';\n\n  const oldestEntry = removedEntries[0] || null;\n  const newestEntry = removedEntries[removedEntries.length - 1] || null;\n\n  const dropTimestamp = Date.now();\n  let dropIsoTimestamp = '';\n  try {\n    dropIsoTimestamp = new Date(dropTimestamp).toISOString();\n  } catch (error) {\n    void error;\n    dropIsoTimestamp = String(dropTimestamp);\n  }\n\n  lastHistoryDrop = freezeDeep({\n    count: removedEntries.length,\n    limit,\n    source,\n    timestamp: dropTimestamp,\n    isoTimestamp: dropIsoTimestamp,\n    oldestEntryId:\n      oldestEntry && typeof oldestEntry.id === 'string' ? oldestEntry.id : null,\n    oldestEntryTimestamp:\n      oldestEntry && typeof oldestEntry.timestamp === 'number'\n        ? oldestEntry.timestamp\n        : null,\n    oldestEntryIsoTimestamp:\n      oldestEntry && typeof oldestEntry.isoTimestamp === 'string'\n        ? oldestEntry.isoTimestamp\n        : null,\n    newestEntryId:\n      newestEntry && typeof newestEntry.id === 'string' ? newestEntry.id : null,\n    newestEntryTimestamp:\n      newestEntry && typeof newestEntry.timestamp === 'number'\n        ? newestEntry.timestamp\n        : null,\n    newestEntryIsoTimestamp:\n      newestEntry && typeof newestEntry.isoTimestamp === 'string'\n        ? newestEntry.isoTimestamp\n        : null,\n    levels: freezeLevelSummary(removedSummary),\n  });\n\n  if (ORIGINAL_CONSOLE_FUNCTIONS && typeof ORIGINAL_CONSOLE_FUNCTIONS.warn === 'function') {\n    try {\n      ORIGINAL_CONSOLE_FUNCTIONS.warn('cineLogging: history trimmed to enforce retention limit', {\n        limit,\n        removed: removedEntries.length,\n        source,\n        levels: cloneLevelSummary(removedSummary),\n      });\n    } catch (warnError) {\n      void warnError;\n    }\n  } else {\n    // Fallback if original console is somehow missing or we are in a weird state\n    // We purposefully avoid safeWarn here to prevent recursion\n    try {\n      if (typeof console !== 'undefined' && typeof console.warn === 'function') {\n        // If console.warn IS the proxy, we can't easily detect it without checking equality to the proxy function\n        // But avoiding safeWarn wrapper helps if safeWarn adds extra logic. \n        // Ideally we just stop if we can't find the original.\n      }\n    } catch (e) { void e; }\n  }\n\n  return removedSummary;\n}\n\nfunction enforceHistoryLimit(options) {\n  const limit = getEffectiveHistoryLimit();\n  if (logHistory.length <= limit) {\n    return 0;\n  }\n\n  const overflow = logHistory.length - limit;\n  const removedEntries = logHistory.splice(0, overflow);\n  applyLevelCounterDeltaForEntries(retainedLevelCounters, removedEntries, -1);\n  const removedSummary = recordHistoryDrop(removedEntries, limit, options);\n  if (removedSummary) {\n    accumulateLevelSummary(droppedLevelCounters, removedSummary);\n  }\n  return overflow;\n}\n\nfunction shouldRecord(level) {\n  return getLevelPriority(level) >= getLevelPriority(activeConfig.historyLevel);\n}\n\nfunction shouldOutputToConsole(level) {\n  if (!activeConfig.consoleOutput) {\n    return false;\n  }\n  return getLevelPriority(level) >= getLevelPriority(activeConfig.level);\n}\n\nfunction getLevelState(level) {\n  const normalizedLevel = normalizeLevel(level, 'info');\n  const consoleEnabled = shouldOutputToConsole(normalizedLevel);\n  const historyEnabled = shouldRecord(normalizedLevel);\n\n  return freezeDeep({\n    level: normalizedLevel,\n    enabled: consoleEnabled || historyEnabled,\n    console: consoleEnabled,\n    history: historyEnabled,\n    thresholds: freezeDeep({\n      console: normalizeLevel(activeConfig.level, DEFAULT_CONFIG_VALUES.level),\n      history: normalizeLevel(activeConfig.historyLevel, DEFAULT_CONFIG_VALUES.historyLevel),\n    }),\n  });\n}\n\nfunction isLevelEnabled(level, options) {\n  const state = getLevelState(level);\n\n  if (!options || typeof options !== 'object') {\n    return state.enabled;\n  }\n\n  const checkConsole = options.console !== false;\n  const checkHistory = options.history !== false;\n\n  if (!checkConsole && !checkHistory) {\n    return false;\n  }\n\n  if (options.requireAll === true) {\n    if (checkConsole && !state.console) {\n      return false;\n    }\n    if (checkHistory && !state.history) {\n      return false;\n    }\n    return true;\n  }\n\n  if (checkConsole && state.console) {\n    return true;\n  }\n\n  if (checkHistory && state.history) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction createEntryId(timestamp) {\n  return `log-${timestamp}-${Math.random().toString(36).slice(2, 10)}`;\n}\n\nfunction pushEntryToHistory(entry) {\n  if (!entry) {\n    return;\n  }\n\n  try {\n    logHistory.push(entry);\n  } catch (pushError) {\n    // If the history array is somehow frozen or non-extensible, we silently drop the entry\n    // to avoid crashing the entire application.\n    void pushError;\n    return;\n  }\n  applyLevelCounterDelta(retainedLevelCounters, entry.level, 1);\n}\n\nfunction appendEntry(entry) {\n  pushEntryToHistory(entry);\n  runtimeEntryCount += 1;\n  enforceHistoryLimit({ source: 'append' });\n  persistHistorySafe();\n  notifyLogSubscribers(entry);\n}\n\nfunction notifyLogSubscribers(entry) {\n  if (!logSubscribers.size) {\n    return;\n  }\n  const listeners = Array.from(logSubscribers);\n  for (let index = 0; index < listeners.length; index += 1) {\n    const listener = listeners[index];\n    if (typeof listener !== 'function') {\n      continue;\n    }\n    try {\n      listener(entry);\n    } catch (error) {\n      safeWarn('cineLogging listener execution failed', error);\n    }\n  }\n}\n\nfunction getHistorySnapshot(limit) {\n  const effectiveLimit = typeof limit === 'number' && Number.isFinite(limit)\n    ? Math.max(0, Math.floor(limit))\n    : logHistory.length;\n  if (!effectiveLimit) {\n    return Object.freeze([]);\n  }\n  const start = Math.max(0, logHistory.length - effectiveLimit);\n  const slice = logHistory.slice(start);\n  return Object.freeze(slice.slice());\n}\n\nfunction notifyConfigSubscribers(snapshot) {\n  if (!configSubscribers.size) {\n    return;\n  }\n  const listeners = Array.from(configSubscribers);\n  for (let index = 0; index < listeners.length; index += 1) {\n    const listener = listeners[index];\n    if (typeof listener !== 'function') {\n      continue;\n    }\n    try {\n      listener(snapshot);\n    } catch (error) {\n      safeWarn('cineLogging config listener failed', error);\n    }\n  }\n}\n\nfunction arrayFromArrayLike(value) {\n  if (!value || typeof value.length !== 'number') {\n    return [];\n  }\n\n  const length = value.length;\n  const result = new Array(length);\n  for (let index = 0; index < length; index += 1) {\n    result[index] = value[index];\n  }\n\n  return result;\n}\n\nfunction safeArrayPush(target, value) {\n  if (!Array.isArray(target)) {\n    return false;\n  }\n  try {\n    if (typeof Object.isExtensible === 'function' && !Object.isExtensible(target)) {\n      return false;\n    }\n    target.push(value);\n    return true;\n  } catch (error) {\n    void error;\n  }\n  return false;\n}\n\nfunction getConsoleLevelForMethod(method) {\n  if (method === 'error') {\n    return 'error';\n  }\n  if (method === 'warn') {\n    return 'warn';\n  }\n  if (method === 'info') {\n    return 'info';\n  }\n  return 'debug';\n}\n\nfunction getStoredConsoleFunction(method) {\n  if (typeof method !== 'string' || !method) {\n    return null;\n  }\n\n  if (Object.prototype.hasOwnProperty.call(ORIGINAL_CONSOLE_FUNCTIONS, method)) {\n    const stored = ORIGINAL_CONSOLE_FUNCTIONS[method];\n    if (typeof stored === 'function') {\n      return stored;\n    }\n  }\n\n  if (typeof console !== 'undefined' && console) {\n    let candidate = null;\n    try {\n      candidate = console[method];\n    } catch (error) {\n      candidate = null;\n      void error;\n    }\n    if (typeof candidate === 'function' && (!candidate || !candidate[CONSOLE_PROXY_FLAG])) {\n      return candidate;\n    }\n  }\n\n  if ((method === 'debug' || method === 'log') && typeof ORIGINAL_CONSOLE_FUNCTIONS.log === 'function') {\n    return ORIGINAL_CONSOLE_FUNCTIONS.log;\n  }\n\n  if (method === 'info') {\n    if (typeof ORIGINAL_CONSOLE_FUNCTIONS.info === 'function') {\n      return ORIGINAL_CONSOLE_FUNCTIONS.info;\n    }\n    if (typeof ORIGINAL_CONSOLE_FUNCTIONS.log === 'function') {\n      return ORIGINAL_CONSOLE_FUNCTIONS.log;\n    }\n  }\n\n  if (method === 'warn') {\n    if (typeof ORIGINAL_CONSOLE_FUNCTIONS.warn === 'function') {\n      return ORIGINAL_CONSOLE_FUNCTIONS.warn;\n    }\n    if (typeof ORIGINAL_CONSOLE_FUNCTIONS.error === 'function') {\n      return ORIGINAL_CONSOLE_FUNCTIONS.error;\n    }\n  }\n\n  if (method === 'error' && typeof ORIGINAL_CONSOLE_FUNCTIONS.error === 'function') {\n    return ORIGINAL_CONSOLE_FUNCTIONS.error;\n  }\n\n  return null;\n}\n\nfunction invokeConsoleMethod(method, args) {\n  const fn = getStoredConsoleFunction(method);\n  if (typeof fn !== 'function') {\n    return undefined;\n  }\n\n  const receiver = typeof console !== 'undefined' && console\n    ? console\n    : GLOBAL_SCOPE && GLOBAL_SCOPE.console\n      ? GLOBAL_SCOPE.console\n      : null;\n  const finalArgs = Array.isArray(args) ? args : arrayFromArrayLike(args);\n\n  try {\n    return fn.apply(receiver, finalArgs);\n  } catch (applyError) {\n    void applyError;\n    try {\n      return Function.prototype.apply.call(fn, receiver, finalArgs);\n    } catch (callError) {\n      void callError;\n    }\n  }\n\n  return undefined;\n}\n\nfunction recordConsoleMessage(method, args, meta) {\n  const level = getConsoleLevelForMethod(method);\n  const rawArgs = Array.isArray(args) ? args : arrayFromArrayLike(args);\n  const messageParts = [];\n\n  for (let index = 0; index < rawArgs.length; index += 1) {\n    const value = rawArgs[index];\n    const valueType = typeof value;\n    if (valueType === 'string') {\n      safeArrayPush(messageParts, value);\n    } else if (valueType === 'number' || valueType === 'boolean') {\n      safeArrayPush(messageParts, String(value));\n    } else if (valueType === 'symbol') {\n      try {\n        safeArrayPush(messageParts, value.toString());\n      } catch (symbolError) {\n        void symbolError;\n      }\n    }\n  }\n\n  let message = messageParts.join(' ').trim();\n  if (!message) {\n    message = `[console.${method || level}]`;\n  }\n\n  let sanitizedArguments = null;\n  let detailPayload = null;\n  if (rawArgs.length) {\n    try {\n      sanitizedArguments = sanitizeForLog(rawArgs);\n      detailPayload = { arguments: sanitizedArguments };\n    } catch (detailError) {\n      detailPayload = { arguments: rawArgs.slice() };\n      void detailError;\n    }\n  }\n\n  const errorEntries = [];\n  const sanitizedArray = Array.isArray(sanitizedArguments) ? sanitizedArguments : null;\n\n  for (let index = 0; index < rawArgs.length; index += 1) {\n    const rawValue = rawArgs[index];\n    const sanitizedValue = sanitizedArray ? sanitizedArray[index] : null;\n    const isErrorInstance = rawValue instanceof Error;\n\n    const hasSanitizedErrorShape =\n      sanitizedValue && typeof sanitizedValue === 'object' && sanitizedValue !== null\n        ? Boolean(\n          typeof sanitizedValue.stack === 'string'\n          || typeof sanitizedValue.message === 'string'\n          || typeof sanitizedValue.name === 'string'\n        )\n        : false;\n\n    if (!isErrorInstance && !hasSanitizedErrorShape) {\n      continue;\n    }\n\n    let snapshot = hasSanitizedErrorShape ? sanitizedValue : null;\n\n    if (!snapshot) {\n      try {\n        snapshot = sanitizeForLog(rawValue);\n      } catch (argumentSanitizeError) {\n        snapshot = null;\n        void argumentSanitizeError;\n      }\n    }\n\n    if (!snapshot && isErrorInstance) {\n      snapshot = {\n        name: rawValue.name || null,\n        message: rawValue.message || coerceMessage(rawValue) || null,\n      };\n      if (typeof rawValue.code !== 'undefined') {\n        snapshot.code = rawValue.code;\n      }\n      if (typeof rawValue.status !== 'undefined') {\n        snapshot.status = rawValue.status;\n      }\n      if (typeof rawValue.stack === 'string' && rawValue.stack) {\n        snapshot.stack = rawValue.stack;\n      }\n    }\n\n    let valueClone = snapshot;\n    if (valueClone && typeof valueClone === 'object') {\n      try {\n        valueClone = LOGGING_DEEP_CLONE(valueClone);\n      } catch (cloneError) {\n        void cloneError;\n        try {\n          valueClone = Object.assign({}, valueClone);\n        } catch (assignError) {\n          valueClone = snapshot;\n          void assignError;\n        }\n      }\n    }\n\n    const entry = { index };\n    if (valueClone && typeof valueClone === 'object') {\n      entry.value = valueClone;\n      if (typeof valueClone.name === 'string' && valueClone.name) {\n        entry.name = valueClone.name;\n      }\n      if (typeof valueClone.message === 'string' && valueClone.message) {\n        entry.message = valueClone.message;\n      }\n      if (typeof valueClone.code !== 'undefined') {\n        entry.code = valueClone.code;\n      }\n      if (typeof valueClone.status !== 'undefined') {\n        entry.status = valueClone.status;\n      }\n    } else if (typeof valueClone !== 'undefined') {\n      entry.value = valueClone;\n      const coercedMessage = coerceMessage(valueClone);\n      if (coercedMessage) {\n        entry.message = coercedMessage;\n      }\n    } else {\n      entry.value = null;\n    }\n\n    const rawType = rawValue === null ? 'null' : typeof rawValue;\n    if (rawType === 'object' || rawType === 'function') {\n      const ctorName = rawValue && rawValue.constructor && rawValue.constructor.name;\n      entry.argumentType = typeof ctorName === 'string' && ctorName ? ctorName : rawType;\n    } else {\n      entry.argumentType = rawType;\n    }\n\n    const stackSummary = isErrorInstance && typeof rawValue.stack === 'string' && rawValue.stack\n      ? normaliseStackTrace(rawValue.stack)\n      : valueClone && typeof valueClone === 'object' && typeof valueClone.stack === 'string'\n        ? normaliseStackTrace(valueClone.stack)\n        : null;\n\n    if (stackSummary) {\n      if (typeof stackSummary.stack === 'string') {\n        entry.stack = stackSummary.stack;\n      }\n      if (Array.isArray(stackSummary.frames) && stackSummary.frames.length) {\n        entry.frames = stackSummary.frames;\n      }\n      if (stackSummary.truncated) {\n        entry.stackTruncated = true;\n      }\n    }\n\n    safeArrayPush(errorEntries, entry);\n  }\n\n  const contextMeta = { channel: 'console', method: method || 'log' };\n  if (meta && typeof meta === 'object') {\n    const metaKeys = Object.keys(meta);\n    for (let index = 0; index < metaKeys.length; index += 1) {\n      const key = metaKeys[index];\n      try {\n        contextMeta[key] = sanitizeForLog(meta[key]);\n      } catch (metaError) {\n        contextMeta[key] = meta[key];\n        void metaError;\n      }\n    }\n  }\n\n  if (errorEntries.length) {\n    detailPayload = detailPayload || {};\n    const errorIndices = [];\n    for (let index = 0; index < errorEntries.length; index += 1) {\n      const errorEntry = errorEntries[index];\n      errorIndices.push(errorEntry.index);\n    }\n    detailPayload.errors = errorEntries;\n    detailPayload.errorCount = errorEntries.length;\n    detailPayload.errorIndices = errorIndices;\n    detailPayload.primaryError = errorEntries[0];\n\n    contextMeta.errorCount = errorEntries.length;\n    contextMeta.errorIndices = errorIndices;\n\n    const primaryError = errorEntries[0];\n    if (primaryError) {\n      if (typeof primaryError.name === 'string' && primaryError.name) {\n        contextMeta.primaryErrorName = primaryError.name;\n      }\n      if (typeof primaryError.message === 'string' && primaryError.message) {\n        contextMeta.primaryErrorMessage = primaryError.message;\n      }\n      if (typeof primaryError.code !== 'undefined') {\n        contextMeta.primaryErrorCode = primaryError.code;\n      }\n      if (typeof primaryError.status !== 'undefined') {\n        contextMeta.primaryErrorStatus = primaryError.status;\n      }\n      if (primaryError.stack) {\n        contextMeta.primaryErrorHasStack = true;\n      }\n    }\n  }\n\n  const forceStackCapture = method === 'error' || errorEntries.length > 0;\n  const contextOptions = { namespace: 'console', meta: contextMeta };\n  if (forceStackCapture) {\n    contextOptions.captureStack = true;\n  }\n\n  return logInternal(\n    level,\n    message,\n    detailPayload,\n    contextOptions,\n    { silentConsole: true },\n  );\n}\n\nfunction installConsoleProxies() {\n  if (consoleProxyInstalled) {\n    return true;\n  }\n\n  consoleProxyInstallationAttempted = true;\n\n  if (typeof console === 'undefined' || !console) {\n    consoleProxyInstallationFailed = true;\n    return false;\n  }\n\n  try {\n    if (console[CONSOLE_PROXY_FLAG]) {\n      consoleProxyInstalled = true;\n      consoleProxyInstallationFailed = false;\n      return true;\n    }\n  } catch (flagReadError) {\n    void flagReadError;\n  }\n\n  let installedAny = false;\n\n  for (let index = 0; index < CONSOLE_METHODS.length; index += 1) {\n    const method = CONSOLE_METHODS[index];\n    let base = getStoredConsoleFunction(method);\n\n    if (typeof base !== 'function') {\n      try {\n        const candidate = console[method];\n        if (typeof candidate === 'function' && (!candidate || !candidate[CONSOLE_PROXY_FLAG])) {\n          base = candidate;\n        }\n      } catch (resolveError) {\n        base = null;\n        void resolveError;\n      }\n    }\n\n    if (!Object.prototype.hasOwnProperty.call(ORIGINAL_CONSOLE_FUNCTIONS, method) || ORIGINAL_CONSOLE_FUNCTIONS[method] === null) {\n      ORIGINAL_CONSOLE_FUNCTIONS[method] = typeof base === 'function' ? base : ORIGINAL_CONSOLE_FUNCTIONS[method];\n    }\n\n    if (typeof base !== 'function') {\n      continue;\n    }\n\n    const proxy = function consoleProxy() {\n      const argsArray = arrayFromArrayLike(arguments);\n      consoleProxyGuardDepth += 1;\n      try {\n        if (consoleProxyGuardDepth === 1) {\n          const firstArg = argsArray.length ? argsArray[0] : null;\n          const skipCapture = typeof firstArg === 'string' && firstArg.indexOf('cineLogging:') === 0;\n          if (!skipCapture) {\n            try {\n              recordConsoleMessage(method, argsArray, { captured: true });\n            } catch (recordError) {\n              void recordError;\n            }\n          }\n        }\n        return invokeConsoleMethod(method, argsArray);\n      } finally {\n        consoleProxyGuardDepth -= 1;\n        if (consoleProxyGuardDepth < 0) {\n          consoleProxyGuardDepth = 0;\n        }\n      }\n    };\n\n    try {\n      Object.defineProperty(proxy, CONSOLE_PROXY_FLAG, {\n        configurable: true,\n        enumerable: false,\n        writable: false,\n        value: true,\n      });\n    } catch (defineError) {\n      proxy[CONSOLE_PROXY_FLAG] = true;\n      void defineError;\n    }\n\n    try {\n      console[method] = proxy;\n      installedAny = true;\n    } catch (assignError) {\n      void assignError;\n    }\n  }\n\n  if (installedAny) {\n    consoleProxyInstalled = true;\n    consoleProxyInstallationFailed = false;\n    try {\n      Object.defineProperty(console, CONSOLE_PROXY_FLAG, {\n        configurable: true,\n        enumerable: false,\n        writable: false,\n        value: true,\n      });\n    } catch (flagError) {\n      try {\n        console[CONSOLE_PROXY_FLAG] = true;\n      } catch (assignFlagError) {\n        void assignFlagError;\n      }\n      void flagError;\n    }\n  } else {\n    consoleProxyInstallationFailed = true;\n  }\n\n  return consoleProxyInstalled;\n}\n\nfunction removeConsoleProxies() {\n  if (!consoleProxyInstalled) {\n    return false;\n  }\n\n  if (typeof console === 'undefined' || !console) {\n    consoleProxyInstalled = false;\n    return false;\n  }\n\n  let restoredAny = false;\n\n  for (let index = 0; index < CONSOLE_METHODS.length; index += 1) {\n    const method = CONSOLE_METHODS[index];\n    const original = ORIGINAL_CONSOLE_FUNCTIONS[method];\n    try {\n      if (typeof original === 'function') {\n        console[method] = original;\n        restoredAny = true;\n      } else if (method !== 'log' && method !== 'info') {\n        delete console[method];\n      }\n    } catch (restoreError) {\n      void restoreError;\n    }\n  }\n\n  try {\n    if (console && console[CONSOLE_PROXY_FLAG]) {\n      if (typeof Object.defineProperty === 'function') {\n        Object.defineProperty(console, CONSOLE_PROXY_FLAG, {\n          configurable: true,\n          enumerable: false,\n          writable: true,\n          value: false,\n        });\n      } else {\n        console[CONSOLE_PROXY_FLAG] = false;\n      }\n    }\n  } catch (flagError) {\n    void flagError;\n  }\n\n  consoleProxyInstalled = false;\n  return restoredAny;\n}\n\nfunction syncConsoleCaptureState() {\n  if (!activeConfig.captureConsole) {\n    if (consoleProxyInstalled) {\n      removeConsoleProxies();\n    }\n    if (lastConsoleCaptureState !== 'disabled') {\n      logInternal(\n        'info',\n        'Console output capture disabled',\n        buildConsoleCaptureDetail({ status: 'disabled' }),\n        { namespace: 'logging', meta: { channel: 'console', lifecycle: 'sync' } },\n        { silentConsole: true },\n      );\n      lastConsoleCaptureState = 'disabled';\n    }\n    consoleProxyWarningIssued = false;\n    consoleProxyInstallationFailed = false;\n    return true;\n  }\n\n  const installed = installConsoleProxies();\n  if (!installed) {\n    if (!consoleProxyWarningIssued) {\n      const reason = typeof console === 'undefined' || !console\n        ? 'console-unavailable'\n        : 'installation-failed';\n      logInternal(\n        'warn',\n        'Console output capture failed',\n        buildConsoleCaptureDetail({ status: 'failed', reason }),\n        { namespace: 'logging', meta: { channel: 'console', lifecycle: 'sync' } },\n        { silentConsole: true },\n      );\n      safeWarn('cineLogging: Unable to capture console output for diagnostics.');\n      consoleProxyWarningIssued = true;\n    }\n    lastConsoleCaptureState = 'failed';\n    return false;\n  }\n\n  consoleProxyWarningIssued = false;\n\n  if (lastConsoleCaptureState !== 'enabled') {\n    logInternal(\n      'info',\n      'Console output capture enabled',\n      buildConsoleCaptureDetail({ status: 'enabled' }),\n      { namespace: 'logging', meta: { channel: 'console', lifecycle: 'sync' } },\n      { silentConsole: true },\n    );\n    lastConsoleCaptureState = 'enabled';\n  }\n\n  return true;\n}\n\nfunction isConsoleCaptureActive() {\n  return Boolean(activeConfig.captureConsole) && consoleProxyInstalled === true;\n}\n\nfunction buildConsoleCaptureDetail(overrides) {\n  const detail = {\n    configured: activeConfig.captureConsole === true,\n    installed: consoleProxyInstalled === true,\n    attempted: consoleProxyInstallationAttempted === true,\n    failed: consoleProxyInstallationFailed === true,\n  };\n\n  if (typeof console === 'undefined' || !console) {\n    detail.consoleAvailable = false;\n  }\n\n  if (overrides && typeof overrides === 'object') {\n    const overrideKeys = Object.keys(overrides);\n    for (let index = 0; index < overrideKeys.length; index += 1) {\n      const key = overrideKeys[index];\n      detail[key] = overrides[key];\n    }\n  }\n\n  return detail;\n}\n\nfunction enableConsoleCapture(options) {\n  const setOptions = options && typeof options === 'object' ? options : null;\n  setConfig({ captureConsole: true }, setOptions || undefined);\n  return isConsoleCaptureActive();\n}\n\nfunction disableConsoleCapture(options) {\n  const setOptions = options && typeof options === 'object' ? options : null;\n  setConfig({ captureConsole: false }, setOptions || undefined);\n  return isConsoleCaptureActive();\n}\n\nfunction shouldCaptureOrigin(level, detail, context) {\n  const override = context && Object.prototype.hasOwnProperty.call(context, 'captureStack')\n    ? context.captureStack\n    : null;\n\n  if (override === true) {\n    return true;\n  }\n\n  if (override === false) {\n    return false;\n  }\n\n  if (activeConfig.stackTraces !== true) {\n    return false;\n  }\n\n  if (detail instanceof Error) {\n    return true;\n  }\n\n  return getLevelPriority(level) >= getLevelPriority('warn');\n}\n\nfunction captureLogOrigin(level, message, detail, context) {\n  if (!shouldCaptureOrigin(level, detail, context)) {\n    return null;\n  }\n\n  let stackSource = 'generated';\n  let stackValue = '';\n\n  if (detail instanceof Error) {\n    const detailStack = detail.stack;\n    if (typeof detailStack === 'string' && detailStack) {\n      stackSource = 'detail';\n      stackValue = detailStack;\n    }\n  }\n\n  if (!stackValue) {\n    try {\n      const stackMessage = typeof message === 'string' && message\n        ? message\n        : `Log ${level}`;\n      const captureError = new Error(stackMessage);\n      if (typeof Error.captureStackTrace === 'function') {\n        Error.captureStackTrace(captureError, captureLogOrigin);\n      }\n      if (typeof captureError.stack === 'string' && captureError.stack) {\n        stackValue = captureError.stack;\n      }\n    } catch (stackError) {\n      void stackError;\n    }\n  }\n\n  const summary = normaliseStackTrace(stackValue);\n  if (!summary) {\n    return null;\n  }\n\n  const origin = {\n    source: stackSource,\n    stack: summary.stack,\n    truncated: summary.truncated,\n  };\n\n  if (Array.isArray(summary.frames) && summary.frames.length) {\n    origin.frames = summary.frames;\n  }\n\n  return freezeDeep(origin);\n}\n\nfunction logInternal(level, message, detail, context, options) {\n  const normalizedLevel = normalizeLevel(level, 'info');\n  const timestamp = Date.now();\n  let isoTimestamp = '';\n  try {\n    isoTimestamp = new Date(timestamp).toISOString();\n  } catch (error) {\n    void error;\n    isoTimestamp = String(timestamp);\n  }\n\n  const captureContext = context && typeof context === 'object' ? context : null;\n  const origin = captureLogOrigin(normalizedLevel, message, detail, captureContext);\n\n  const namespace = captureContext && typeof captureContext.namespace === 'string' && captureContext.namespace\n    ? context.namespace\n    : null;\n\n  const meta = captureContext && typeof captureContext.meta !== 'undefined'\n    ? sanitizeForLog(captureContext.meta)\n    : null;\n\n  const sanitizedDetail = typeof detail === 'undefined'\n    ? null\n    : sanitizeForLog(detail);\n\n  const entry = freezeDeep({\n    id: createEntryId(timestamp),\n    level: normalizedLevel,\n    message: coerceMessage(message),\n    namespace,\n    detail: sanitizedDetail,\n    meta,\n    timestamp,\n    isoTimestamp,\n    origin,\n  });\n\n  applyLevelCounterDelta(emittedLevelCounters, normalizedLevel, 1);\n\n  if (shouldRecord(normalizedLevel)) {\n    appendEntry(entry);\n  }\n\n  const internalOptions = options && typeof options === 'object' ? options : null;\n\n  if (shouldOutputToConsole(normalizedLevel) && (!internalOptions || internalOptions.silentConsole !== true)) {\n    const descriptor = LOG_LEVEL_MAP[normalizedLevel] || LOG_LEVEL_MAP.info;\n    const methodName = descriptor.consoleMethod;\n    const prefixParts = ['[cine]'];\n    if (namespace) {\n      prefixParts.push(`[${namespace}]`);\n    }\n    prefixParts.push(entry.isoTimestamp);\n    const prefix = prefixParts.join(' ');\n    const consoleArgs = [`${prefix} ${entry.message}`];\n    if (detail !== undefined) {\n      safeArrayPush(consoleArgs, detail);\n    } else if (entry.detail !== null) {\n      safeArrayPush(consoleArgs, entry.detail);\n    }\n    if (entry.meta !== null) {\n      safeArrayPush(consoleArgs, { meta: entry.meta });\n    }\n    if (origin) {\n      safeArrayPush(consoleArgs, { origin });\n    }\n    invokeConsoleMethod(methodName, consoleArgs);\n  }\n\n  return entry;\n}\n\nfunction debug(message, detail, context) {\n  return logInternal('debug', message, detail, context);\n}\n\nfunction info(message, detail, context) {\n  return logInternal('info', message, detail, context);\n}\n\nfunction warn(message, detail, context) {\n  return logInternal('warn', message, detail, context);\n}\n\nfunction error(message, detail, context) {\n  return logInternal('error', message, detail, context);\n}\n\nfunction getConfigSnapshot() {\n  return freezeDeep({\n    level: activeConfig.level,\n    historyLevel: activeConfig.historyLevel,\n    historyLimit: activeConfig.historyLimit,\n    consoleOutput: activeConfig.consoleOutput,\n    persistSession: activeConfig.persistSession,\n    captureGlobalErrors: activeConfig.captureGlobalErrors,\n    captureConsole: activeConfig.captureConsole,\n    stackTraces: activeConfig.stackTraces,\n  });\n}\n\nfunction getHistory(options) {\n  const limit = options && typeof options.limit !== 'undefined' ? options.limit : undefined;\n  return getHistorySnapshot(limit);\n}\n\nfunction cloneLastDropSnapshot() {\n  if (!lastHistoryDrop) {\n    return null;\n  }\n\n  return freezeDeep({\n    count: typeof lastHistoryDrop.count === 'number' ? lastHistoryDrop.count : 0,\n    limit: typeof lastHistoryDrop.limit === 'number'\n      ? lastHistoryDrop.limit\n      : getEffectiveHistoryLimit(),\n    source: typeof lastHistoryDrop.source === 'string' ? lastHistoryDrop.source : 'enforce',\n    timestamp:\n      typeof lastHistoryDrop.timestamp === 'number'\n        ? lastHistoryDrop.timestamp\n        : null,\n    isoTimestamp: typeof lastHistoryDrop.isoTimestamp === 'string'\n      ? lastHistoryDrop.isoTimestamp\n      : null,\n    oldestEntryId: typeof lastHistoryDrop.oldestEntryId === 'string'\n      ? lastHistoryDrop.oldestEntryId\n      : null,\n    oldestEntryTimestamp: typeof lastHistoryDrop.oldestEntryTimestamp === 'number'\n      ? lastHistoryDrop.oldestEntryTimestamp\n      : null,\n    oldestEntryIsoTimestamp: typeof lastHistoryDrop.oldestEntryIsoTimestamp === 'string'\n      ? lastHistoryDrop.oldestEntryIsoTimestamp\n      : null,\n    newestEntryId: typeof lastHistoryDrop.newestEntryId === 'string'\n      ? lastHistoryDrop.newestEntryId\n      : null,\n    newestEntryTimestamp: typeof lastHistoryDrop.newestEntryTimestamp === 'number'\n      ? lastHistoryDrop.newestEntryTimestamp\n      : null,\n    newestEntryIsoTimestamp: typeof lastHistoryDrop.newestEntryIsoTimestamp === 'string'\n      ? lastHistoryDrop.newestEntryIsoTimestamp\n      : null,\n    levels: lastHistoryDrop.levels\n      ? freezeLevelSummary(lastHistoryDrop.levels)\n      : freezeLevelSummary(createLevelCounters()),\n  });\n}\n\nfunction getStats() {\n  return freezeDeep({\n    runtimeEntries: runtimeEntryCount,\n    retainedEntries: logHistory.length,\n    droppedEntries: totalEntriesDropped,\n    historyLimit: getEffectiveHistoryLimit(),\n    lastDrop: cloneLastDropSnapshot(),\n    levels: freezeDeep({\n      emitted: freezeLevelSummary(emittedLevelCounters),\n      retained: freezeLevelSummary(retainedLevelCounters),\n      dropped: freezeLevelSummary(droppedLevelCounters),\n    }),\n    consoleCapture: freezeDeep({\n      configured: activeConfig.captureConsole === true,\n      installed: consoleProxyInstalled,\n      attempted: consoleProxyInstallationAttempted,\n      failed: consoleProxyInstallationFailed,\n    }),\n  });\n}\n\nfunction clearHistory(options) {\n  logHistory.length = 0;\n  resetLevelCounters(retainedLevelCounters);\n  if (!options || options.persist !== false) {\n    persistHistorySafe();\n  }\n  return true;\n}\n\nfunction subscribe(listener) {\n  if (typeof listener !== 'function') {\n    return function unsubscribeNoop() {\n      return false;\n    };\n  }\n  logSubscribers.add(listener);\n  return function unsubscribe() {\n    logSubscribers.delete(listener);\n    return true;\n  };\n}\n\nfunction subscribeConfig(listener) {\n  if (typeof listener !== 'function') {\n    return function unsubscribeConfigNoop() {\n      return false;\n    };\n  }\n  configSubscribers.add(listener);\n  return function unsubscribeConfig() {\n    configSubscribers.delete(listener);\n    return true;\n  };\n}\n\nfunction mergeMeta(baseMeta, meta) {\n  if (!baseMeta && !meta) {\n    return null;\n  }\n\n  if (!baseMeta) {\n    return sanitizeForLog(meta);\n  }\n\n  if (!meta) {\n    return baseMeta;\n  }\n\n  if (typeof baseMeta !== 'object' || typeof meta !== 'object') {\n    return sanitizeForLog(meta);\n  }\n\n  const merged = {};\n  const baseKeys = Object.keys(baseMeta);\n  for (let index = 0; index < baseKeys.length; index += 1) {\n    const key = baseKeys[index];\n    merged[key] = baseMeta[key];\n  }\n  const metaKeys = Object.keys(meta);\n  for (let index = 0; index < metaKeys.length; index += 1) {\n    const key = metaKeys[index];\n    merged[key] = sanitizeForLog(meta[key]);\n  }\n  return merged;\n}\n\nfunction createLogger(namespace, options) {\n  const normalizedNamespace = typeof namespace === 'string' && namespace.trim()\n    ? namespace.trim()\n    : 'app';\n\n  const baseMeta = options && typeof options.meta !== 'undefined'\n    ? sanitizeForLog(options.meta)\n    : null;\n\n  function logWithNamespace(level, message, detail, meta) {\n    const mergedMeta = mergeMeta(baseMeta, meta);\n    return logInternal(level, message, detail, {\n      namespace: normalizedNamespace,\n      meta: mergedMeta,\n    });\n  }\n\n  return freezeDeep({\n    namespace: normalizedNamespace,\n    log(level, message, detail, meta) {\n      return logWithNamespace(level, message, detail, meta);\n    },\n    debug(message, detail, meta) {\n      return logWithNamespace('debug', message, detail, meta);\n    },\n    info(message, detail, meta) {\n      return logWithNamespace('info', message, detail, meta);\n    },\n    warn(message, detail, meta) {\n      return logWithNamespace('warn', message, detail, meta);\n    },\n    error(message, detail, meta) {\n      return logWithNamespace('error', message, detail, meta);\n    },\n    getConfig: getConfigSnapshot,\n    isLevelEnabled(level, optionOverrides) {\n      return isLevelEnabled(level, optionOverrides);\n    },\n    getLevelState(level) {\n      return getLevelState(level);\n    },\n  });\n}\n\nfunction markEventHandled(event) {\n  if (!event || (typeof event !== 'object' && typeof event !== 'function')) {\n    return false;\n  }\n\n  const flag = ERROR_EVENT_FLAG;\n\n  try {\n    if (typeof flag === 'symbol') {\n      if (event[flag]) {\n        return true;\n      }\n      event[flag] = true;\n      return false;\n    }\n\n    if (Object.prototype.hasOwnProperty.call(event, flag) && event[flag]) {\n      return true;\n    }\n\n    Object.defineProperty(event, flag, {\n      configurable: true,\n      enumerable: false,\n      writable: true,\n      value: true,\n    });\n    return false;\n  } catch (error) {\n    void error;\n  }\n\n  return false;\n}\n\nfunction handleGlobalError(event) {\n  if (!activeConfig.captureGlobalErrors) {\n    return;\n  }\n\n  if (markEventHandled(event)) {\n    return;\n  }\n\n  const detail = {\n    message: event && typeof event.message === 'string' ? event.message : '',\n    filename: event ? event.filename || event.fileName || null : null,\n    lineno: event ? event.lineno || event.lineNumber || null : null,\n    colno: event ? event.colno || event.columnNumber || null : null,\n    error: event && event.error ? sanitizeForLog(event.error) : null,\n  };\n\n  if (event && typeof event.preventDefault === 'function' && event.defaultPrevented) {\n    detail.defaultPrevented = true;\n  }\n\n  logInternal('error', 'Global error captured', detail, { namespace: 'global' });\n}\n\nfunction handleUnhandledRejection(event) {\n  if (!activeConfig.captureGlobalErrors) {\n    return;\n  }\n\n  if (markEventHandled(event)) {\n    return;\n  }\n\n  const detail = {\n    reason: event ? sanitizeForLog(event.reason) : null,\n  };\n\n  if (event && event.promise) {\n    detail.promiseState = '[Promise]';\n  }\n\n  if (event && typeof event.preventDefault === 'function' && event.defaultPrevented) {\n    detail.defaultPrevented = true;\n  }\n\n  logInternal('error', 'Unhandled promise rejection captured', detail, { namespace: 'global' });\n}\n\nfunction markTargetAttached(target) {\n  if (!target || (typeof target !== 'object' && typeof target !== 'function')) {\n    return false;\n  }\n\n  if (attachedErrorTargets instanceof WeakSet) {\n    if (attachedErrorTargets.has(target)) {\n      return true;\n    }\n    attachedErrorTargets.add(target);\n    return false;\n  }\n\n  const list = attachedErrorTargets;\n  const index = list.indexOf(target);\n  if (index !== -1) {\n    return true;\n  }\n  list.push(target);\n  return false;\n}\n\nfunction attachGlobalErrorListeners() {\n  if (!activeConfig.captureGlobalErrors) {\n    return;\n  }\n\n  const scopes = fallbackCollectCandidateScopes(GLOBAL_SCOPE);\n  for (let index = 0; index < scopes.length; index += 1) {\n    const scope = scopes[index];\n    if (!scope || typeof scope.addEventListener !== 'function') {\n      continue;\n    }\n\n    if (markTargetAttached(scope)) {\n      continue;\n    }\n\n    try {\n      scope.addEventListener('error', handleGlobalError, true);\n    } catch (error) {\n      void error;\n    }\n\n    try {\n      scope.addEventListener('unhandledrejection', handleUnhandledRejection, true);\n    } catch (error) {\n      void error;\n    }\n  }\n}\n\nfunction applyConfig(overrides) {\n  if (!overrides || typeof overrides !== 'object') {\n    return { changed: false, captureChanged: false, limitChanged: false };\n  }\n\n  let changed = false;\n  let captureChanged = false;\n  let limitChanged = false;\n  let consoleCaptureChanged = false;\n\n  const nextPersistSession = Object.prototype.hasOwnProperty.call(overrides, 'persistSession')\n    ? booleanFromValue(overrides.persistSession, activeConfig.persistSession)\n    : activeConfig.persistSession;\n\n  if (Object.prototype.hasOwnProperty.call(overrides, 'level')) {\n    const nextLevel = normalizeLevel(overrides.level, activeConfig.level);\n    if (nextLevel !== activeConfig.level) {\n      activeConfig.level = nextLevel;\n      changed = true;\n    }\n  }\n\n  if (Object.prototype.hasOwnProperty.call(overrides, 'historyLevel')) {\n    const nextHistoryLevel = normalizeLevel(overrides.historyLevel, activeConfig.historyLevel);\n    if (nextHistoryLevel !== activeConfig.historyLevel) {\n      activeConfig.historyLevel = nextHistoryLevel;\n      changed = true;\n    }\n  }\n\n  if (Object.prototype.hasOwnProperty.call(overrides, 'historyLimit')) {\n    const nextLimit = clampHistoryLimit(overrides.historyLimit, {\n      allowReducedMin: nextPersistSession === false,\n    });\n    if (nextLimit !== activeConfig.historyLimit) {\n      activeConfig.historyLimit = nextLimit;\n      changed = true;\n      limitChanged = true;\n    }\n  }\n\n  if (Object.prototype.hasOwnProperty.call(overrides, 'consoleOutput')) {\n    const nextConsole = booleanFromValue(overrides.consoleOutput, activeConfig.consoleOutput);\n    if (nextConsole !== activeConfig.consoleOutput) {\n      activeConfig.consoleOutput = nextConsole;\n      changed = true;\n    }\n  }\n\n  if (Object.prototype.hasOwnProperty.call(overrides, 'persistSession')) {\n    if (nextPersistSession !== activeConfig.persistSession) {\n      activeConfig.persistSession = nextPersistSession;\n      changed = true;\n    }\n  }\n\n  if (activeConfig.persistSession && activeConfig.historyLimit < HISTORY_MIN_LIMIT) {\n    activeConfig.historyLimit = HISTORY_MIN_LIMIT;\n    changed = true;\n    limitChanged = true;\n  }\n\n  if (Object.prototype.hasOwnProperty.call(overrides, 'captureGlobalErrors')) {\n    const nextCapture = booleanFromValue(overrides.captureGlobalErrors, activeConfig.captureGlobalErrors);\n    if (nextCapture !== activeConfig.captureGlobalErrors) {\n      activeConfig.captureGlobalErrors = nextCapture;\n      changed = true;\n      captureChanged = true;\n    }\n  }\n\n  if (Object.prototype.hasOwnProperty.call(overrides, 'captureConsole')) {\n    const nextConsoleCapture = booleanFromValue(overrides.captureConsole, activeConfig.captureConsole);\n    if (nextConsoleCapture !== activeConfig.captureConsole) {\n      activeConfig.captureConsole = nextConsoleCapture;\n      changed = true;\n      consoleCaptureChanged = true;\n    }\n  }\n\n  if (Object.prototype.hasOwnProperty.call(overrides, 'stackTraces')) {\n    const nextStackTraces = booleanFromValue(overrides.stackTraces, activeConfig.stackTraces);\n    if (nextStackTraces !== activeConfig.stackTraces) {\n      activeConfig.stackTraces = nextStackTraces;\n      changed = true;\n    }\n  }\n\n  return { changed, captureChanged, limitChanged, consoleCaptureChanged };\n}\n\nfunction setConfig(overrides, options) {\n  const previousCapture = activeConfig.captureGlobalErrors;\n  const previousConsoleCapture = activeConfig.captureConsole;\n  const result = applyConfig(overrides);\n\n  if (result.limitChanged) {\n    enforceHistoryLimit({ source: 'config' });\n  }\n\n  if (result.changed && (!options || options.persist !== false)) {\n    persistConfigSafe();\n    persistHistorySafe();\n  }\n\n  if (!activeConfig.persistSession) {\n    clearStoredHistory();\n  }\n\n  if (!previousCapture && activeConfig.captureGlobalErrors) {\n    attachGlobalErrorListeners();\n  }\n\n  if (result.consoleCaptureChanged || previousConsoleCapture !== activeConfig.captureConsole) {\n    syncConsoleCaptureState();\n  }\n\n  if (result.changed) {\n    notifyConfigSubscribers(getConfigSnapshot());\n  }\n\n  return getConfigSnapshot();\n}\n\nfunction resolveConfigPresetFromScopes() {\n  const scopes = fallbackCollectCandidateScopes(GLOBAL_SCOPE);\n  const keys = ['__cineLoggingConfig', '__CINE_LOGGING_CONFIG', 'cineLoggingConfig'];\n\n  for (let scopeIndex = 0; scopeIndex < scopes.length; scopeIndex += 1) {\n    const scope = scopes[scopeIndex];\n    if (!scope || (typeof scope !== 'object' && typeof scope !== 'function')) {\n      continue;\n    }\n\n    for (let keyIndex = 0; keyIndex < keys.length; keyIndex += 1) {\n      const key = keys[keyIndex];\n      let value;\n      try {\n        value = scope[key];\n      } catch (error) {\n        void error;\n        value = null;\n      }\n      if (value && typeof value === 'object') {\n        return value;\n      }\n    }\n  }\n\n  return null;\n}\n\nfunction applyConfigFromStorage() {\n  const storage = getSessionStorage();\n  if (!storage) {\n    return;\n  }\n\n  let raw = '';\n  try {\n    raw = storage.getItem(CONFIG_STORAGE_KEY) || '';\n  } catch (error) {\n    void error;\n    return;\n  }\n\n  if (!raw) {\n    return;\n  }\n\n  try {\n    const parsed = JSON.parse(raw);\n    applyConfig(parsed);\n  } catch (error) {\n    safeWarn('cineLogging: Unable to restore logging config from storage', error);\n  }\n}\n\nfunction applyConfigFromQuery() {\n  if (!GLOBAL_SCOPE || !GLOBAL_SCOPE.location) {\n    return;\n  }\n\n  let search = '';\n  try {\n    search = GLOBAL_SCOPE.location.search || '';\n  } catch (error) {\n    void error;\n    return;\n  }\n\n  if (typeof search !== 'string' || !search) {\n    return;\n  }\n\n  let params = null;\n  if (typeof URLSearchParams === 'function') {\n    try {\n      params = new URLSearchParams(search);\n    } catch (error) {\n      void error;\n    }\n  }\n\n  const updates = {};\n  let hasUpdates = false;\n\n  function assignUpdate(key, value) {\n    updates[key] = value;\n    hasUpdates = true;\n  }\n\n  if (params) {\n    if (params.has('cineLogLevel')) {\n      assignUpdate('level', params.get('cineLogLevel'));\n    }\n    if (params.has('cineLogHistoryLevel')) {\n      assignUpdate('historyLevel', params.get('cineLogHistoryLevel'));\n    }\n    if (params.has('cineLogLimit')) {\n      assignUpdate('historyLimit', params.get('cineLogLimit'));\n    }\n    if (params.has('cineLogConsole')) {\n      assignUpdate('consoleOutput', params.get('cineLogConsole'));\n    }\n    if (params.has('cineLogPersist')) {\n      assignUpdate('persistSession', params.get('cineLogPersist'));\n    }\n    if (params.has('cineLogCapture')) {\n      assignUpdate('captureGlobalErrors', params.get('cineLogCapture'));\n    }\n    if (params.has('cineLogConsoleCapture')) {\n      assignUpdate('captureConsole', params.get('cineLogConsoleCapture'));\n    }\n    if (params.has('cineLogStackTraces')) {\n      assignUpdate('stackTraces', params.get('cineLogStackTraces'));\n    }\n  } else {\n    const query = search.charAt(0) === '?' ? search.slice(1) : search;\n    const parts = query.split('&');\n    for (let index = 0; index < parts.length; index += 1) {\n      const part = parts[index];\n      if (!part) {\n        continue;\n      }\n      const eqIndex = part.indexOf('=');\n      const key = eqIndex === -1 ? decodeURIComponent(part) : decodeURIComponent(part.slice(0, eqIndex));\n      const value = eqIndex === -1 ? '' : decodeURIComponent(part.slice(eqIndex + 1));\n      if (key === 'cineLogLevel') {\n        assignUpdate('level', value);\n      } else if (key === 'cineLogHistoryLevel') {\n        assignUpdate('historyLevel', value);\n      } else if (key === 'cineLogLimit') {\n        assignUpdate('historyLimit', value);\n      } else if (key === 'cineLogConsole') {\n        assignUpdate('consoleOutput', value);\n      } else if (key === 'cineLogPersist') {\n        assignUpdate('persistSession', value);\n      } else if (key === 'cineLogCapture') {\n        assignUpdate('captureGlobalErrors', value);\n      } else if (key === 'cineLogConsoleCapture') {\n        assignUpdate('captureConsole', value);\n      } else if (key === 'cineLogStackTraces') {\n        assignUpdate('stackTraces', value);\n      }\n    }\n  }\n\n  if (hasUpdates) {\n    applyConfig(updates);\n  }\n}\n\nfunction normaliseStoredEntry(entry) {\n  if (!entry || typeof entry !== 'object') {\n    return null;\n  }\n\n  const normalizedLevel = normalizeLevel(entry.level, 'info');\n  const timestamp = typeof entry.timestamp === 'number' && Number.isFinite(entry.timestamp)\n    ? entry.timestamp\n    : Date.now();\n\n  let isoTimestamp = '';\n  if (typeof entry.isoTimestamp === 'string' && entry.isoTimestamp) {\n    isoTimestamp = entry.isoTimestamp;\n  } else {\n    try {\n      isoTimestamp = new Date(timestamp).toISOString();\n    } catch (error) {\n      void error;\n      isoTimestamp = String(timestamp);\n    }\n  }\n\n  const normalizedMessage = typeof entry.message === 'string'\n    ? entry.message\n    : coerceMessage(entry.message);\n\n  const normalizedNamespace = typeof entry.namespace === 'string' && entry.namespace\n    ? entry.namespace\n    : null;\n\n  const normalizedId = typeof entry.id === 'string' && entry.id\n    ? entry.id\n    : createEntryId(timestamp);\n\n  return freezeDeep({\n    id: normalizedId,\n    level: normalizedLevel,\n    message: normalizedMessage,\n    namespace: normalizedNamespace,\n    detail: typeof entry.detail === 'undefined' ? null : sanitizeForLog(entry.detail),\n    meta: typeof entry.meta === 'undefined' ? null : sanitizeForLog(entry.meta),\n    timestamp,\n    isoTimestamp,\n    origin: typeof entry.origin === 'undefined' ? null : normaliseOriginSnapshot(entry.origin),\n  });\n}\n\nfunction getGlobalNavigator() {\n  if (GLOBAL_SCOPE && typeof GLOBAL_SCOPE.navigator === 'object' && GLOBAL_SCOPE.navigator) {\n    return GLOBAL_SCOPE.navigator;\n  }\n  if (typeof navigator !== 'undefined' && navigator) {\n    return navigator;\n  }\n  if (typeof globalThis !== 'undefined' && globalThis && typeof globalThis.navigator === 'object') {\n    return globalThis.navigator;\n  }\n  return null;\n}\n\nfunction getNavigatorServiceWorker() {\n  const nav = getGlobalNavigator();\n  if (!nav || typeof nav !== 'object') {\n    return null;\n  }\n  if (!nav.serviceWorker) {\n    return null;\n  }\n  return nav.serviceWorker;\n}\n\nfunction markServiceWorkerEntrySeen(id) {\n  if (!id) {\n    return true;\n  }\n\n  if (serviceWorkerBridgeState.seenIds) {\n    if (serviceWorkerBridgeState.seenIds.has(id)) {\n      return false;\n    }\n    serviceWorkerBridgeState.seenIds.add(id);\n    return true;\n  }\n\n  if (Array.isArray(serviceWorkerBridgeState.fallbackSeenIds)) {\n    if (serviceWorkerBridgeState.fallbackSeenIds.indexOf(id) !== -1) {\n      return false;\n    }\n    serviceWorkerBridgeState.fallbackSeenIds.push(id);\n    return true;\n  }\n\n  return true;\n}\n\nfunction mergeServiceWorkerEntryMeta(entry, snapshotMeta) {\n  const merged = {};\n\n  if (entry && typeof entry.meta !== 'undefined') {\n    if (entry.meta && typeof entry.meta === 'object') {\n      for (const key in entry.meta) {\n        if (Object.prototype.hasOwnProperty.call(entry.meta, key)) {\n          merged[key] = entry.meta[key];\n        }\n      }\n    } else {\n      merged.value = entry.meta;\n    }\n  }\n\n  const channel = entry && typeof entry.channel === 'string' && entry.channel\n    ? entry.channel\n    : merged.channel;\n  if (channel) {\n    merged.channel = channel;\n  } else {\n    merged.channel = 'service-worker';\n  }\n\n  if (snapshotMeta && typeof snapshotMeta === 'object') {\n    if (snapshotMeta.cacheName && !merged.cacheName) {\n      merged.cacheName = snapshotMeta.cacheName;\n    }\n    if (snapshotMeta.cacheVersion && !merged.cacheVersion) {\n      merged.cacheVersion = snapshotMeta.cacheVersion;\n    }\n    if (typeof snapshotMeta.generatedAt === 'number' && Number.isFinite(snapshotMeta.generatedAt)) {\n      if (!merged.snapshotTimestamp) {\n        merged.snapshotTimestamp = snapshotMeta.generatedAt;\n      }\n    }\n    if (typeof snapshotMeta.historyLength === 'number' && Number.isFinite(snapshotMeta.historyLength)) {\n      if (!merged.snapshotSize) {\n        merged.snapshotSize = snapshotMeta.historyLength;\n      }\n    }\n  }\n\n  return merged;\n}\n\nfunction importServiceWorkerLogEntries(entries, snapshotMeta) {\n  if (!Array.isArray(entries) || !entries.length) {\n    return;\n  }\n\n  for (let index = 0; index < entries.length; index += 1) {\n    const rawEntry = entries[index];\n    if (!rawEntry || typeof rawEntry !== 'object') {\n      continue;\n    }\n\n    const entryId = typeof rawEntry.id === 'string' && rawEntry.id ? rawEntry.id : null;\n    if (!markServiceWorkerEntrySeen(entryId)) {\n      continue;\n    }\n\n    const origin = rawEntry.origin && typeof rawEntry.origin === 'object'\n      ? rawEntry.origin\n      : { runtime: 'service-worker' };\n\n    const normalized = normaliseStoredEntry({\n      id: entryId || undefined,\n      level: rawEntry.level,\n      message: rawEntry.message,\n      namespace: typeof rawEntry.namespace === 'string' && rawEntry.namespace\n        ? rawEntry.namespace\n        : 'service-worker',\n      detail: typeof rawEntry.detail === 'undefined' ? null : rawEntry.detail,\n      meta: mergeServiceWorkerEntryMeta(rawEntry, snapshotMeta),\n      timestamp: rawEntry.timestamp,\n      isoTimestamp: rawEntry.isoTimestamp,\n      origin,\n    });\n\n    if (normalized) {\n      appendEntry(normalized);\n    }\n  }\n}\n\nfunction finalizeServiceWorkerLogRequest(requestId) {\n  if (!serviceWorkerBridgeState.requestInFlight) {\n    return;\n  }\n\n  if (requestId && serviceWorkerBridgeState.lastRequestId && requestId !== serviceWorkerBridgeState.lastRequestId) {\n    return;\n  }\n\n  serviceWorkerBridgeState.requestInFlight = false;\n  serviceWorkerBridgeState.lastRequestId = null;\n\n  if (serviceWorkerBridgeState.requestTimer && typeof clearTimeout === 'function') {\n    try {\n      clearTimeout(serviceWorkerBridgeState.requestTimer);\n    } catch (error) {\n      void error;\n    }\n  }\n\n  serviceWorkerBridgeState.requestTimer = null;\n}\n\nfunction scheduleServiceWorkerLogPoll() {\n  if (serviceWorkerBridgeState.broadcastChannel || serviceWorkerBridgeState.broadcastFailed) {\n    return;\n  }\n\n  if (serviceWorkerBridgeState.pollTimer || typeof setTimeout !== 'function') {\n    return;\n  }\n\n  try {\n    serviceWorkerBridgeState.pollTimer = setTimeout(() => {\n      serviceWorkerBridgeState.pollTimer = null;\n      requestServiceWorkerLogSnapshot('poll');\n    }, SERVICE_WORKER_LOG_POLL_INTERVAL);\n  } catch (error) {\n    void error;\n  }\n}\n\nfunction ensureServiceWorkerBroadcastChannel() {\n  if (serviceWorkerBridgeState.broadcastFailed) {\n    return null;\n  }\n\n  if (serviceWorkerBridgeState.broadcastChannel) {\n    return serviceWorkerBridgeState.broadcastChannel;\n  }\n\n  if (typeof BroadcastChannel !== 'function') {\n    serviceWorkerBridgeState.broadcastFailed = true;\n    return null;\n  }\n\n  try {\n    const channel = new BroadcastChannel(SERVICE_WORKER_LOG_CHANNEL);\n    channel.addEventListener('message', handleServiceWorkerLogMessage);\n    serviceWorkerBridgeState.broadcastChannel = channel;\n    if (serviceWorkerBridgeState.pollTimer && typeof clearTimeout === 'function') {\n      try {\n        clearTimeout(serviceWorkerBridgeState.pollTimer);\n      } catch (error) {\n        void error;\n      }\n      serviceWorkerBridgeState.pollTimer = null;\n    }\n    return channel;\n  } catch (error) {\n    serviceWorkerBridgeState.broadcastFailed = true;\n    safeWarn('cineLogging: Unable to open service worker diagnostics channel', error);\n    return null;\n  }\n}\n\nfunction handleServiceWorkerLogMessage(event) {\n  if (!event) {\n    return;\n  }\n\n  let data = null;\n  try {\n    data = event.data || null;\n  } catch (error) {\n    void error;\n    data = null;\n  }\n\n  if (!data || typeof data !== 'object') {\n    return;\n  }\n\n  if (data.type === SERVICE_WORKER_LOG_ENTRY_TYPE) {\n    importServiceWorkerLogEntries([data.entry], serviceWorkerBridgeState.lastSnapshotMeta);\n    scheduleServiceWorkerLogPoll();\n    return;\n  }\n\n  if (data.type === SERVICE_WORKER_LOG_STATE_RESPONSE) {\n    finalizeServiceWorkerLogRequest(data.requestId || null);\n\n    const state = data.state && typeof data.state === 'object' ? data.state : null;\n    if (!state) {\n      scheduleServiceWorkerLogPoll();\n      return;\n    }\n\n    serviceWorkerBridgeState.lastSnapshotMeta = {\n      cacheName: typeof state.cacheName === 'string' && state.cacheName ? state.cacheName : null,\n      cacheVersion: state.cacheVersion || null,\n      generatedAt: typeof state.generatedAt === 'number' && Number.isFinite(state.generatedAt)\n        ? state.generatedAt\n        : Date.now(),\n      historyLength: typeof state.historyLength === 'number' && Number.isFinite(state.historyLength)\n        ? state.historyLength\n        : null,\n    };\n\n    importServiceWorkerLogEntries(state.history, serviceWorkerBridgeState.lastSnapshotMeta);\n    scheduleServiceWorkerLogPoll();\n  }\n}\n\nfunction requestServiceWorkerLogSnapshot(reason) {\n  if (serviceWorkerBridgeState.requestInFlight) {\n    return;\n  }\n\n  const serviceWorker = getNavigatorServiceWorker();\n  if (!serviceWorker) {\n    return;\n  }\n\n  serviceWorkerBridgeState.supported = true;\n\n  const requestId = `sw-log-${Date.now()}-${Math.random().toString(36).slice(2, 10)}`;\n  serviceWorkerBridgeState.requestInFlight = true;\n  serviceWorkerBridgeState.lastRequestId = requestId;\n\n  const message = {\n    type: SERVICE_WORKER_LOG_STATE_REQUEST,\n    limit: SERVICE_WORKER_LOG_HISTORY_LIMIT,\n    reason: typeof reason === 'string' && reason ? reason : 'sync',\n    requestId,\n  };\n\n  const closeMessageChannel = channel => {\n    if (!channel) {\n      return;\n    }\n\n    try {\n      channel.port1.onmessage = null;\n    } catch (clearHandlerError) {\n      void clearHandlerError;\n    }\n\n    if (typeof channel.port1.onmessageerror !== 'undefined') {\n      try {\n        channel.port1.onmessageerror = null;\n      } catch (clearErrorHandlerError) {\n        void clearErrorHandlerError;\n      }\n    }\n\n    try {\n      channel.port1.close();\n    } catch (closePort1Error) {\n      void closePort1Error;\n    }\n\n    try {\n      channel.port2.close();\n    } catch (closePort2Error) {\n      void closePort2Error;\n    }\n  };\n\n  const readyPromise = serviceWorker.ready && typeof serviceWorker.ready.then === 'function'\n    ? serviceWorker.ready.then(registration => (registration && registration.active) || serviceWorker.controller || null)\n    : Promise.resolve(serviceWorker.controller || null);\n\n  Promise.resolve(readyPromise)\n    .then(worker => {\n      const controller = serviceWorker.controller || null;\n      const targetWorker = worker || controller;\n\n      if (!targetWorker || typeof targetWorker.postMessage !== 'function') {\n        finalizeServiceWorkerLogRequest(requestId);\n        scheduleServiceWorkerLogPoll();\n        return;\n      }\n\n      let settled = false;\n      let channel = null;\n\n      const finalize = () => {\n        if (settled) {\n          return;\n        }\n        settled = true;\n        closeMessageChannel(channel);\n        finalizeServiceWorkerLogRequest(requestId);\n      };\n\n      const finalizeWithPoll = () => {\n        finalize();\n        scheduleServiceWorkerLogPoll();\n      };\n\n      const handleResponse = event => {\n        finalize();\n        handleServiceWorkerLogMessage(event);\n      };\n\n      const handleChannelError = () => {\n        safeWarn('cineLogging: Service worker diagnostics channel closed before a response was received', { requestId });\n        finalizeWithPoll();\n      };\n\n      const postWithoutChannel = () => {\n        try {\n          targetWorker.postMessage(message);\n        } catch (error) {\n          safeWarn('cineLogging: Unable to post service worker diagnostics request', error);\n          finalizeWithPoll();\n          return;\n        }\n\n        if (typeof setTimeout === 'function') {\n          try {\n            serviceWorkerBridgeState.requestTimer = setTimeout(() => {\n              if (settled) {\n                return;\n              }\n              finalizeWithPoll();\n            }, SERVICE_WORKER_LOG_REQUEST_TIMEOUT);\n          } catch (error) {\n            void error;\n          }\n        }\n      };\n\n      const shouldUseMessageChannel = () => {\n        if (typeof MessageChannel !== 'function') {\n          return false;\n        }\n\n        if (!controller) {\n          return false;\n        }\n\n        return targetWorker === controller;\n      };\n\n      if (!shouldUseMessageChannel()) {\n        postWithoutChannel();\n        return;\n      }\n\n      channel = new MessageChannel();\n      channel.port1.onmessage = handleResponse;\n\n      if (typeof channel.port1.onmessageerror !== 'undefined') {\n        channel.port1.onmessageerror = handleChannelError;\n      }\n\n      if (typeof channel.port1.start === 'function') {\n        try {\n          channel.port1.start();\n        } catch (startError) {\n          void startError;\n        }\n      }\n\n      try {\n        targetWorker.postMessage(message, [channel.port2]);\n      } catch (error) {\n        closeMessageChannel(channel);\n        channel = null;\n        safeWarn('cineLogging: Unable to request service worker diagnostics', error);\n        postWithoutChannel();\n        return;\n      }\n\n      if (typeof setTimeout === 'function') {\n        try {\n          serviceWorkerBridgeState.requestTimer = setTimeout(() => {\n            if (settled) {\n              return;\n            }\n            handleChannelError();\n          }, SERVICE_WORKER_LOG_REQUEST_TIMEOUT);\n        } catch (error) {\n          void error;\n        }\n      }\n    })\n    .catch(error => {\n      finalizeServiceWorkerLogRequest(requestId);\n      safeWarn('cineLogging: Unable to await service worker for diagnostics', error);\n      scheduleServiceWorkerLogPoll();\n    });\n}\n\nfunction setupServiceWorkerLogBridge() {\n  if (serviceWorkerBridgeState.initialised) {\n    return;\n  }\n\n  serviceWorkerBridgeState.initialised = true;\n\n  const serviceWorker = getNavigatorServiceWorker();\n  if (!serviceWorker) {\n    return;\n  }\n\n  serviceWorkerBridgeState.supported = true;\n\n  ensureServiceWorkerBroadcastChannel();\n\n  if (typeof serviceWorker.addEventListener === 'function') {\n    try {\n      serviceWorker.addEventListener('message', handleServiceWorkerLogMessage);\n    } catch (error) {\n      safeWarn('cineLogging: Unable to attach service worker diagnostics listener', error);\n    }\n  } else if (typeof serviceWorker.onmessage === 'undefined') {\n    try {\n      serviceWorker.onmessage = handleServiceWorkerLogMessage;\n    } catch (error) {\n      void error;\n    }\n  }\n\n  requestServiceWorkerLogSnapshot('initial-sync');\n  if (!serviceWorkerBridgeState.broadcastChannel) {\n    scheduleServiceWorkerLogPoll();\n  }\n}\n\nfunction loadPersistedHistory() {\n  if (!activeConfig.persistSession) {\n    return;\n  }\n\n  const storage = getSessionStorage();\n  if (!storage) {\n    return;\n  }\n\n  let raw = '';\n  try {\n    raw = storage.getItem(HISTORY_STORAGE_KEY) || '';\n  } catch (error) {\n    void error;\n    return;\n  }\n\n  if (!raw) {\n    return;\n  }\n\n  try {\n    const parsed = JSON.parse(raw);\n    if (!Array.isArray(parsed)) {\n      return;\n    }\n    for (let index = 0; index < parsed.length; index += 1) {\n      const entry = normaliseStoredEntry(parsed[index]);\n      if (entry) {\n        pushEntryToHistory(entry);\n      }\n    }\n    enforceHistoryLimit({ source: 'restore' });\n  } catch (error) {\n    safeWarn('cineLogging: Unable to restore log history from storage', error);\n  }\n}\n\nfunction initialiseConfig() {\n  activeConfig = cloneDefaultConfig();\n\n  const preset = resolveConfigPresetFromScopes();\n  if (preset) {\n    applyConfig(preset);\n  }\n\n  applyConfigFromStorage();\n  applyConfigFromQuery();\n}\n\ninitialiseConfig();\nloadPersistedHistory();\nsetupServiceWorkerLogBridge();\n\nsyncConsoleCaptureState();\n\nif (activeConfig.captureGlobalErrors) {\n  attachGlobalErrorListeners();\n}\n\ndebug(\n  'cineLogging initialized',\n  { config: getConfigSnapshot(), stats: getStats() },\n  { namespace: 'logging', meta: { lifecycle: 'init' } },\n);\n\nconst loggingAPI = freezeDeep({\n  log: logInternal,\n  debug,\n  info,\n  warn,\n  error,\n  createLogger,\n  getHistory,\n  getStats,\n  clearHistory,\n  getConfig: getConfigSnapshot,\n  setConfig,\n  getLevelState,\n  isLevelEnabled,\n  subscribe,\n  subscribeConfig,\n  enableConsoleCapture,\n  disableConsoleCapture,\n  syncConsoleCapture: syncConsoleCaptureState,\n  isConsoleCaptureActive,\n  constants: freezeDeep({\n    LOG_LEVELS,\n    DEFAULT_CONFIG,\n  }),\n});\n\ninformModuleGlobals('cineLogging', loggingAPI);\n\nconst registrationOptions = {\n  category: 'diagnostics',\n  description: 'Structured logging utilities for debugging and diagnostics.',\n  replace: true,\n  connections: ['cineModuleGlobals', 'cineModuleEnvironment', 'cineEnvironmentBridge', 'cineModuleContext'],\n};\n\nconst registered = registerOrQueueModule(\n  'cineLogging',\n  loggingAPI,\n  registrationOptions,\n  function (error) {\n    safeWarn('Unable to register cineLogging module.', error);\n  },\n  GLOBAL_SCOPE,\n  MODULE_REGISTRY,\n);\n\nif (!registered) {\n  queueModuleRegistration('cineLogging', loggingAPI, registrationOptions, GLOBAL_SCOPE);\n}\n\nif (!exposeGlobal('cineLogging', loggingAPI, {\n  configurable: true,\n  enumerable: false,\n  writable: false,\n})) {\n  safeWarn('Unable to expose cineLogging globally.');\n}\n\n// if (typeof module !== 'undefined' && module && module.exports) {\n//   module.exports = loggingAPI;\n// }\n// }) ();\n\nexport const cineLogging = loggingAPI;\n\n","/**\n * Console Helpers Module\n * Ensures console methods stay writable for diagnostics tooling.\n */\n\nconst GLOBAL_SCOPE =\n    typeof globalThis !== 'undefined'\n        ? globalThis\n        : typeof window !== 'undefined'\n            ? window\n            : typeof self !== 'undefined'\n                ? self\n                : typeof global !== 'undefined'\n                    ? global\n                    : null;\n\n/**\n * Detects the global scope.\n * @returns {object|null} The global scope object or null if not found.\n */\nexport function detectGlobalScope() {\n    return (GLOBAL_SCOPE && typeof GLOBAL_SCOPE === 'object' ? GLOBAL_SCOPE : null)\n        || (typeof globalThis !== 'undefined' ? globalThis : null);\n}\n\n/**\n * Ensures that specified console methods are writable.\n * @param {string[]|string} [methods] - List of methods to ensure are writable.\n * @returns {object|null} The proxied console object or base console, or null on failure.\n */\nexport function ensureConsoleMethodsWritable(methods) {\n    const scope = detectGlobalScope();\n    if (!scope) {\n        return null;\n    }\n\n    let baseConsole;\n    let consoleDescriptor = null;\n    try {\n        baseConsole = scope.console;\n        consoleDescriptor = Object.getOwnPropertyDescriptor(scope, 'console');\n    } catch (consoleReadError) {\n        baseConsole = typeof console !== 'undefined' ? console : null;\n        void consoleReadError;\n    }\n\n    if (!baseConsole || typeof baseConsole !== 'object') {\n        return null;\n    }\n\n    let requestedMethods = [];\n    if (Array.isArray(methods)) {\n        requestedMethods = methods;\n    } else if (typeof methods === 'string' && methods) {\n        requestedMethods = [methods];\n    } else {\n        requestedMethods = ['warn', 'info'];\n    }\n\n    const unique = Object.create(null);\n    for (let i = 0; i < requestedMethods.length; i += 1) {\n        const methodName = requestedMethods[i];\n        if (typeof methodName === 'string' && methodName) {\n            unique[methodName] = true;\n        }\n    }\n\n    const methodNames = Object.keys(unique);\n    if (!methodNames.length) {\n        return baseConsole;\n    }\n\n    const storage = Object.create(null);\n    for (let i = 0; i < methodNames.length; i += 1) {\n        const methodName = methodNames[i];\n        let value = baseConsole[methodName];\n        try {\n            const descriptor = Object.getOwnPropertyDescriptor(baseConsole, methodName);\n            if (descriptor && Object.prototype.hasOwnProperty.call(descriptor, 'value')) {\n                value = descriptor.value;\n            }\n        } catch (descriptorError) {\n            void descriptorError;\n        }\n        if (typeof value === 'function') {\n            try {\n                storage[methodName] = value.bind(baseConsole);\n            } catch (bindError) {\n                storage[methodName] = value;\n                void bindError;\n            }\n        } else {\n            storage[methodName] = value;\n        }\n    }\n\n    const proxy = new Proxy(baseConsole, {\n        get(target, property, receiver) {\n            if (Object.prototype.hasOwnProperty.call(storage, property)) {\n                return storage[property];\n            }\n            return Reflect.get(target, property, receiver);\n        },\n        set(target, property, value, receiver) {\n            if (Object.prototype.hasOwnProperty.call(storage, property)) {\n                storage[property] = value;\n                return true;\n            }\n            try {\n                Reflect.set(target, property, value, receiver);\n                return true;\n            } catch (setError) {\n                void setError;\n            }\n            return false;\n        },\n        defineProperty(target, property, descriptor) {\n            if (Object.prototype.hasOwnProperty.call(storage, property)) {\n                if (descriptor && Object.prototype.hasOwnProperty.call(descriptor, 'value')) {\n                    storage[property] = descriptor.value;\n                }\n                return true;\n            }\n            return Reflect.defineProperty(target, property, descriptor);\n        },\n        getOwnPropertyDescriptor(target, property) {\n            if (Object.prototype.hasOwnProperty.call(storage, property)) {\n                return {\n                    configurable: true,\n                    enumerable: true,\n                    writable: true,\n                    value: storage[property],\n                };\n            }\n            return Reflect.getOwnPropertyDescriptor(target, property);\n        },\n        ownKeys(target) {\n            const keys = Reflect.ownKeys(target);\n            for (let i = 0; i < methodNames.length; i += 1) {\n                if (keys.indexOf(methodNames[i]) === -1) {\n                    keys.push(methodNames[i]);\n                }\n            }\n            return keys;\n        },\n    });\n\n    try {\n        Object.defineProperty(scope, 'console', {\n            configurable: true,\n            enumerable: consoleDescriptor ? consoleDescriptor.enumerable !== false : true,\n            writable: true,\n            value: proxy,\n        });\n    } catch (defineError) {\n        scope.console = proxy;\n        void defineError;\n    }\n\n    return proxy;\n}\n","// console-helpers.js - Ensures console methods stay writable for diagnostics tooling.\n// SHIM ADAPTER - Imports from src/scripts/modules/console-helpers.js\n\nimport { ensureConsoleMethodsWritable, detectGlobalScope } from './modules/console-helpers.js';\n\nexport { ensureConsoleMethodsWritable };\n\nconst globalScope = detectGlobalScope();\n\nif (globalScope && typeof globalScope === 'object') {\n  try {\n    if (typeof globalScope.__cineEnsureConsoleMethodsWritable !== 'function') {\n      globalScope.__cineEnsureConsoleMethodsWritable = ensureConsoleMethodsWritable;\n    }\n  } catch (exposeError) {\n    void exposeError;\n  }\n}\n","import './base.js';\nimport './logging.js';\n\n/* global cineModuleBase */\n\n// ESM Wrapper replacement\n// (function () {\nfunction detectGlobalScope() {\n  if (typeof globalThis !== 'undefined') {\n    return globalThis;\n  }\n  if (typeof window !== 'undefined') {\n    return window;\n  }\n  if (typeof self !== 'undefined') {\n    return self;\n  }\n  if (typeof global !== 'undefined') {\n    return global;\n  }\n  return {};\n}\n\nconst GLOBAL_SCOPE = detectGlobalScope();\n\nfunction resolveModuleBase(scope) {\n  // if (baseApi) return baseApi;\n\n  if (typeof cineModuleBase === 'object' && cineModuleBase) {\n    return cineModuleBase;\n  }\n\n  if (scope && typeof scope.cineModuleBase === 'object') {\n    return scope.cineModuleBase;\n  }\n\n  return null;\n}\n\nconst MODULE_BASE = resolveModuleBase(GLOBAL_SCOPE);\n\nconst baseFreezeDeep = MODULE_BASE && typeof MODULE_BASE.freezeDeep === 'function'\n  ? MODULE_BASE.freezeDeep\n  : function identity(value) {\n    return value;\n  };\n\nconst freezeDeep = value => {\n  try {\n    return baseFreezeDeep(value);\n  } catch (error) {\n    void error;\n    return value;\n  }\n};\n\nfunction fallbackCollectCandidateScopes(primary) {\n  const scopes = [];\n\n  function push(scope) {\n    if (!scope || (typeof scope !== 'object' && typeof scope !== 'function')) {\n      return;\n    }\n    if (scopes.indexOf(scope) === -1) {\n      scopes.push(scope);\n    }\n  }\n\n  if (primary) push(primary);\n  if (typeof globalThis !== 'undefined') push(globalThis);\n  if (typeof window !== 'undefined') push(window);\n  if (typeof self !== 'undefined') push(self);\n  if (typeof global !== 'undefined') push(global);\n\n  return scopes;\n}\n\nconst collectCandidateScopes = MODULE_BASE && typeof MODULE_BASE.collectCandidateScopes === 'function'\n  ? function collect(primary) {\n    try {\n      const result = MODULE_BASE.collectCandidateScopes(primary, GLOBAL_SCOPE);\n      if (Array.isArray(result) && result.length) {\n        return result;\n      }\n    } catch (error) {\n      void error;\n    }\n    return fallbackCollectCandidateScopes(primary || GLOBAL_SCOPE);\n  }\n  : fallbackCollectCandidateScopes;\n\nfunction fallbackSafeWarn(message, detail) {\n  if (typeof console === 'undefined' || typeof console.warn !== 'function') {\n    return;\n  }\n\n  try {\n    if (typeof detail === 'undefined') {\n      console.warn(message);\n    } else {\n      console.warn(message, detail);\n    }\n  } catch (error) {\n    void error;\n  }\n}\n\nconst safeWarn = MODULE_BASE && typeof MODULE_BASE.safeWarn === 'function'\n  ? MODULE_BASE.safeWarn\n  : fallbackSafeWarn;\n\nfunction resolveLoggingFromScope(scope) {\n  if (!scope || (typeof scope !== 'object' && typeof scope !== 'function')) {\n    return null;\n  }\n\n  let logging = null;\n  try {\n    logging = scope.cineLogging || null;\n  } catch (error) {\n    void error;\n    logging = null;\n  }\n\n  if (logging && typeof logging === 'object') {\n    return logging;\n  }\n\n  return null;\n}\n\nfunction tryRequireLogging() {\n  // if (loggingApi && typeof loggingApi === 'object') {\n  //   return loggingApi;\n  // }\n  return null;\n}\n\nfunction resolveLogging(options = {}) {\n  const baseScope = options.baseScope || GLOBAL_SCOPE;\n  const allowRequire = options.allowRequire !== false;\n\n  if (allowRequire) {\n    const required = tryRequireLogging();\n    if (required) {\n      return required;\n    }\n  }\n\n  const scopes = collectCandidateScopes(baseScope);\n  for (let index = 0; index < scopes.length; index += 1) {\n    const logging = resolveLoggingFromScope(scopes[index]);\n    if (logging) {\n      return logging;\n    }\n  }\n\n  return null;\n}\n\nfunction cloneMeta(value, seen = new WeakMap()) {\n  if (value === null || typeof value !== 'object') {\n    return value;\n  }\n\n  if (seen.has(value)) {\n    return seen.get(value);\n  }\n\n  if (Array.isArray(value)) {\n    const clone = [];\n    seen.set(value, clone);\n    for (let index = 0; index < value.length; index += 1) {\n      clone[index] = cloneMeta(value[index], seen);\n    }\n    return clone;\n  }\n\n  const clone = {};\n  seen.set(value, clone);\n  const keys = Object.keys(value);\n  for (let index = 0; index < keys.length; index += 1) {\n    const key = keys[index];\n    clone[key] = cloneMeta(value[key], seen);\n  }\n  return clone;\n}\n\nfunction mergeMeta(baseMeta, meta) {\n  if (!baseMeta && !meta) {\n    return null;\n  }\n\n  if (!baseMeta) {\n    return cloneMeta(meta);\n  }\n\n  if (!meta) {\n    return cloneMeta(baseMeta);\n  }\n\n  if (typeof baseMeta !== 'object' || typeof meta !== 'object') {\n    return cloneMeta(meta);\n  }\n\n  const merged = cloneMeta(baseMeta);\n  const keys = Object.keys(meta);\n  for (let index = 0; index < keys.length; index += 1) {\n    const key = keys[index];\n    merged[key] = cloneMeta(meta[key]);\n  }\n  return merged;\n}\n\nfunction resolveConsoleMethod(level) {\n  if (typeof console === 'undefined' || !console) {\n    return null;\n  }\n\n  const normalized = typeof level === 'string' ? level.toLowerCase() : '';\n\n  if (normalized === 'error' && typeof console.error === 'function') {\n    return console.error.bind(console);\n  }\n  if (normalized === 'warn' && typeof console.warn === 'function') {\n    return console.warn.bind(console);\n  }\n  if (normalized === 'info' && typeof console.info === 'function') {\n    return console.info.bind(console);\n  }\n  if (normalized === 'debug' && typeof console.debug === 'function') {\n    return console.debug.bind(console);\n  }\n  if (typeof console.log === 'function') {\n    return console.log.bind(console);\n  }\n\n  return null;\n}\n\nlet fallbackWarningIssued = false;\n\nfunction createConsoleFallbackLogger(namespace, options = {}) {\n  const normalizedNamespace = typeof namespace === 'string' && namespace.trim()\n    ? namespace.trim()\n    : 'app';\n\n  const baseMeta = options && typeof options.meta !== 'undefined'\n    ? cloneMeta(options.meta)\n    : null;\n\n  function output(level, message, detail, meta) {\n    const consoleMethod = resolveConsoleMethod(level);\n    if (!consoleMethod) {\n      return null;\n    }\n\n    const prefixParts = ['[cine-fallback]'];\n    if (normalizedNamespace) {\n      prefixParts.push(`[${normalizedNamespace}]`);\n    }\n\n    const timestamp = new Date();\n    try {\n      prefixParts.push(timestamp.toISOString());\n    } catch (error) {\n      void error;\n      prefixParts.push(String(timestamp.getTime()));\n    }\n\n    const prefix = prefixParts.join(' ');\n    const resolvedMessage = typeof message === 'string' && message\n      ? message\n      : 'Log entry';\n\n    const args = [`${prefix} ${resolvedMessage}`];\n\n    if (typeof detail !== 'undefined') {\n      args.push(detail);\n    }\n\n    const mergedMeta = mergeMeta(baseMeta, meta);\n    if (mergedMeta) {\n      args.push({ meta: mergedMeta, source: 'console-fallback' });\n    }\n\n    try {\n      consoleMethod(...args);\n    } catch (error) {\n      void error;\n    }\n\n    if (!fallbackWarningIssued && typeof console !== 'undefined' && typeof console.warn === 'function') {\n      fallbackWarningIssued = true;\n      try {\n        console.warn('[cine-fallback] Structured logging unavailable, using console logger.');\n      } catch (warnError) {\n        void warnError;\n      }\n    }\n\n    return null;\n  }\n\n  const logger = {\n    namespace: normalizedNamespace,\n    log(level, message, detail, meta) {\n      return output(level, message, detail, meta);\n    },\n    debug(message, detail, meta) {\n      return output('debug', message, detail, meta);\n    },\n    info(message, detail, meta) {\n      return output('info', message, detail, meta);\n    },\n    warn(message, detail, meta) {\n      return output('warn', message, detail, meta);\n    },\n    error(message, detail, meta) {\n      return output('error', message, detail, meta);\n    },\n    getConfig() {\n      return null;\n    },\n    isLevelEnabled() {\n      return true;\n    },\n    getLevelState(level) {\n      return {\n        level: typeof level === 'string' && level ? level : 'all',\n        enabled: true,\n        source: 'console-fallback',\n      };\n    },\n    __cineLoggingFallback: true,\n  };\n\n  return freezeDeep(logger);\n}\n\nfunction resolveLogger(namespace, options = {}) {\n  const logging = resolveLogging(options);\n  const meta = options && typeof options.meta !== 'undefined' ? options.meta : undefined;\n\n  if (logging && typeof logging.createLogger === 'function') {\n    try {\n      const logger = logging.createLogger(namespace, typeof meta !== 'undefined' ? { meta } : undefined);\n      if (logger) {\n        return logger;\n      }\n    } catch (error) {\n      safeWarn('cineLoggingResolver: createLogger failed, falling back to console.', error);\n    }\n  }\n\n  if (options.allowConsoleFallback === false) {\n    return null;\n  }\n\n  return createConsoleFallbackLogger(namespace, { meta });\n}\n\nconst resolverApi = freezeDeep({\n  resolveLogging,\n  resolveLogger,\n  createConsoleFallbackLogger,\n});\n\nconst registry = MODULE_BASE && typeof MODULE_BASE.resolveModuleRegistry === 'function'\n  ? MODULE_BASE.resolveModuleRegistry(GLOBAL_SCOPE)\n  : null;\n\nif (MODULE_BASE && typeof MODULE_BASE.registerOrQueueModule === 'function') {\n  const registered = MODULE_BASE.registerOrQueueModule(\n    'cineLoggingResolver',\n    resolverApi,\n    {\n      category: 'diagnostics',\n      description: 'Helpers to resolve cineLogging instances and console fallbacks across runtimes.',\n      replace: true,\n      connections: ['cineLogging', 'cineModuleBase', 'cineEnvironmentBridge'],\n    },\n    (error) => {\n      safeWarn('Unable to register cineLoggingResolver module.', error);\n    },\n    GLOBAL_SCOPE,\n    registry,\n  );\n\n  if (!registered && typeof MODULE_BASE.queueModuleRegistration === 'function') {\n    try {\n      MODULE_BASE.queueModuleRegistration(\n        'cineLoggingResolver',\n        resolverApi,\n        {\n          category: 'diagnostics',\n          description: 'Helpers to resolve cineLogging instances and console fallbacks across runtimes.',\n          replace: true,\n        },\n        GLOBAL_SCOPE,\n      );\n    } catch (queueError) {\n      safeWarn('Unable to queue cineLoggingResolver registration.', queueError);\n    }\n  }\n}\n\nif (MODULE_BASE && typeof MODULE_BASE.exposeGlobal === 'function') {\n  MODULE_BASE.exposeGlobal('cineLoggingResolver', resolverApi, GLOBAL_SCOPE, {\n    configurable: true,\n    enumerable: false,\n    writable: false,\n  });\n} else {\n  try {\n    GLOBAL_SCOPE.cineLoggingResolver = resolverApi;\n  } catch (error) {\n    void error;\n  }\n}\n\n/*\nif (typeof module !== 'undefined' && module && module.exports) {\n  module.exports = resolverApi;\n}\n*/\n// ESM Export\nexport { resolverApi as cineLoggingResolver };\nexport default resolverApi;\n\n","/* global cineModuleBase */\n\n// ---------------------------------------------------------------------------\n// Contacts feature module\n// ---------------------------------------------------------------------------\n// The contacts helper keeps personal crew information alongside the power\n// planner project data. Because these records can include critical call sheet\n// notes we keep the implementation intentionally small and well documented.\n// The additional comments below explain how each helper works so that future\n// maintainers understand the user data safeguards without having to reverse\n// engineer the storage flow.\n\n// ESM Version\nfunction detectGlobalScope() {\n  if (typeof globalThis !== 'undefined') {\n    return globalThis;\n  }\n  if (typeof window !== 'undefined') {\n    return window;\n  }\n  if (typeof self !== 'undefined') {\n    return self;\n  }\n  if (typeof global !== 'undefined') {\n    return global;\n  }\n  return {};\n}\n\nconst GLOBAL_SCOPE = detectGlobalScope();\n\nconst MODULE_BASE =\n  (typeof cineModuleBase === 'object' && cineModuleBase)\n  || (GLOBAL_SCOPE && typeof GLOBAL_SCOPE.cineModuleBase === 'object' ? GLOBAL_SCOPE.cineModuleBase : null);\n\n// Prefer the runtime provided logging facade so that diagnostics remain\n// consistent across the application. Falling back to console.warn keeps the\n// module functional inside tests and legacy entry points.\nconst safeWarn = MODULE_BASE && typeof MODULE_BASE.safeWarn === 'function'\n  ? MODULE_BASE.safeWarn\n  : function fallbackWarn(message, error) {\n    if (typeof console === 'undefined' || !console || typeof console.warn !== 'function') {\n      return;\n    }\n    try {\n      if (typeof error === 'undefined') {\n        console.warn(message);\n      } else {\n        console.warn(message, error);\n      }\n    } catch (consoleError) {\n      void consoleError;\n    }\n  };\n\n// Contacts live under a dedicated storage key to avoid colliding with other\n// project level metadata. The name mirrors the legacy implementation so\n// existing backups import cleanly.\nconst CONTACTS_STORAGE_KEY = 'cameraPowerPlanner_contacts';\n\nfunction resolveLocalStorage(scope) {\n  // The helper intentionally accepts an optional scope so that callers can\n  // inject mocked storage instances during tests. When no override is\n  // provided we fall back to the detected global scope.\n  const target = scope || GLOBAL_SCOPE;\n  try {\n    if (target && typeof target.localStorage !== 'undefined') {\n      return target.localStorage;\n    }\n  } catch (error) {\n    safeWarn('cine.features.contacts could not access localStorage.', error);\n  }\n  return null;\n}\n\nfunction generateContactId() {\n  // Persisting a random suffix avoids accidental collisions when multiple\n  // contacts are created in quick succession before the autosave triggers.\n  return `contact-${Date.now().toString(36)}-${Math.random().toString(36).slice(2, 8)}`;\n}\n\nfunction sanitizeContactValue(value) {\n  // Every field in the contact form is stored as a trimmed string so backup\n  // exports stay compact and predictable. Numeric and boolean values from\n  // older backups are coerced to strings instead of being dropped so that no\n  // contact information is lost during migrations.\n  if (typeof value === 'string') {\n    return value.trim();\n  }\n\n  if (typeof value === 'number') {\n    if (!Number.isFinite(value)) {\n      return '';\n    }\n    return String(value).trim();\n  }\n\n  if (typeof value === 'bigint') {\n    try {\n      return value.toString();\n    } catch (bigintError) {\n      void bigintError;\n    }\n    return '';\n  }\n\n  if (typeof value === 'boolean') {\n    return value ? 'true' : 'false';\n  }\n\n  if (value && typeof value === 'object') {\n    try {\n      const primitive = value.valueOf();\n      if (primitive !== value) {\n        return sanitizeContactValue(primitive);\n      }\n\n      if (typeof value.toString === 'function') {\n        const stringified = value.toString();\n        if (typeof stringified === 'string' && stringified && stringified !== '[object Object]') {\n          return stringified.trim();\n        }\n      }\n    } catch (coercionError) {\n      void coercionError;\n    }\n  }\n\n  return '';\n}\n\nfunction normalizeContactEntry(entry) {\n  // The normalisation step ensures that manually constructed contacts (for\n  // example when importing older backups) adopt the latest schema without\n  // mutating the original payload. This is critical for preserving user data\n  // across application upgrades.\n  if (!entry || typeof entry !== 'object') {\n    return null;\n  }\n\n  const id = sanitizeContactValue(entry.id) || generateContactId();\n  const name = sanitizeContactValue(entry.name);\n  const role = sanitizeContactValue(entry.role);\n  const phone = sanitizeContactValue(entry.phone);\n  const email = sanitizeContactValue(entry.email);\n  const website = sanitizeContactValue(entry.website || entry.url);\n  const notes = sanitizeContactValue(entry.notes || entry.note || entry.text);\n  const avatar = typeof entry.avatar === 'string' && entry.avatar.startsWith('data:')\n    ? entry.avatar\n    : '';\n  const createdAt = Number.isFinite(entry.createdAt) ? entry.createdAt : Date.now();\n  const updatedAt = Number.isFinite(entry.updatedAt) ? entry.updatedAt : createdAt;\n\n  const normalized = { id, name, role, phone, email, website, notes, createdAt, updatedAt };\n  if (avatar) {\n    normalized.avatar = avatar;\n  }\n\n  return normalized;\n}\n\nfunction sortContacts(list) {\n  // Contacts are sorted alphabetically so that the UI provides a predictable\n  // reading order. When names are missing we fall back to creation time which\n  // keeps imported records stable.\n  return (Array.isArray(list) ? list.filter(Boolean) : [])\n    .map(normalizeContactEntry)\n    .filter(Boolean)\n    .sort((a, b) => {\n      const nameA = (a && a.name ? a.name : '').toLowerCase();\n      const nameB = (b && b.name ? b.name : '').toLowerCase();\n      if (nameA && nameB && nameA !== nameB) {\n        try {\n          return nameA.localeCompare(nameB);\n        } catch (error) {\n          safeWarn('cine.features.contacts could not sort contacts by locale.', error);\n        }\n      }\n      if (nameA && !nameB) {\n        return -1;\n      }\n      if (!nameA && nameB) {\n        return 1;\n      }\n      return (a && a.createdAt ? a.createdAt : 0) - (b && b.createdAt ? b.createdAt : 0);\n    });\n}\n\nfunction loadStoredContacts(options = {}) {\n  // The load helper wraps JSON.parse inside a try/catch so that a single\n  // corrupted entry never risks crashing the surrounding autosave recovery.\n  const storage = resolveLocalStorage(options.scope);\n  if (!storage || typeof storage.getItem !== 'function') {\n    return [];\n  }\n  const storageKey = typeof options.storageKey === 'string' && options.storageKey\n    ? options.storageKey\n    : CONTACTS_STORAGE_KEY;\n\n  try {\n    const raw = storage.getItem(storageKey);\n    if (!raw) {\n      return [];\n    }\n    const parsed = JSON.parse(raw);\n    if (!Array.isArray(parsed)) {\n      return [];\n    }\n    return sortContacts(parsed);\n  } catch (error) {\n    safeWarn('cine.features.contacts could not load contacts from storage.', error);\n    return [];\n  }\n}\n\nfunction saveContactsToStorage(contacts, options = {}) {\n  // We serialise the entire contact list in one go to avoid partial writes.\n  // This keeps backups and offline snapshots coherent even if the browser\n  // crashes mid-operation.\n  const storage = resolveLocalStorage(options.scope);\n  if (!storage || typeof storage.setItem !== 'function') {\n    return false;\n  }\n  const storageKey = typeof options.storageKey === 'string' && options.storageKey\n    ? options.storageKey\n    : CONTACTS_STORAGE_KEY;\n\n  try {\n    storage.setItem(storageKey, JSON.stringify(Array.isArray(contacts) ? contacts : []));\n    return true;\n  } catch (error) {\n    safeWarn('cine.features.contacts could not save contacts to storage.', error);\n    return false;\n  }\n}\n\nconst moduleApi = Object.freeze({\n  CONTACTS_STORAGE_KEY,\n  generateContactId,\n  sanitizeContactValue,\n  normalizeContactEntry,\n  sortContacts,\n  loadStoredContacts,\n  saveContactsToStorage,\n});\n\nif (MODULE_BASE && typeof MODULE_BASE.registerOrQueueModule === 'function') {\n  try {\n    MODULE_BASE.registerOrQueueModule(\n      'cine.features.contacts',\n      moduleApi,\n      {\n        category: 'features',\n        description: 'Shared helpers for contacts management.',\n        replace: true,\n        connections: ['cineModuleBase', 'cineModuleGlobals', 'cinePersistence'],\n      },\n      (error) => safeWarn('Unable to register cine.features.contacts module.', error),\n      GLOBAL_SCOPE,\n      MODULE_BASE.getModuleRegistry && MODULE_BASE.getModuleRegistry(GLOBAL_SCOPE),\n    );\n  } catch (error) {\n    safeWarn('cine.features.contacts registration failed.', error);\n  }\n}\n\nlet exposedViaModuleBase = false;\nif (MODULE_BASE && typeof MODULE_BASE.exposeGlobal === 'function') {\n  try {\n    MODULE_BASE.exposeGlobal('cineFeaturesContacts', moduleApi, GLOBAL_SCOPE, {\n      configurable: true,\n      enumerable: false,\n      writable: false,\n    });\n    exposedViaModuleBase = true;\n  } catch (error) {\n    safeWarn('cine.features.contacts could not expose global api.', error);\n  }\n}\n\nif (!exposedViaModuleBase) {\n  try {\n    GLOBAL_SCOPE.cineFeaturesContacts = moduleApi;\n  } catch (error) {\n    safeWarn('cine.features.contacts could not assign global api.', error);\n  }\n}\n\n// ESM Export\nexport default moduleApi;\n","/**\n * @interface StorageInterface\n * Defines the standard contract for all storage drivers (LocalStorage, IndexedDB, etc.).\n * All methods must return Promises to ensure future compatibility with asynchronous engines.\n */\nexport default class StorageInterface {\n    /**\n     * Initialize the storage driver\n     * @returns {Promise<void>}\n     */\n    async init() {\n        throw new Error('Method \"init()\" must be implemented.');\n    }\n\n    /**\n     * Retrieve an item by key\n     * @param {string} key \n     * @returns {Promise<any>} The parsed value or null\n     */\n    async getItem(key) {\n        throw new Error('Method \"getItem()\" must be implemented.');\n    }\n\n    /**\n     * Save an item by key\n     * @param {string} key \n     * @param {any} value \n     * @returns {Promise<void>}\n     */\n    async setItem(key, value) {\n        throw new Error('Method \"setItem()\" must be implemented.');\n    }\n\n    /**\n     * Remove an item by key\n     * @param {string} key \n     * @returns {Promise<void>}\n     */\n    async removeItem(key) {\n        throw new Error('Method \"removeItem()\" must be implemented.');\n    }\n\n    /**\n     * Clear all keys managed by this driver context\n     * @returns {Promise<void>}\n     */\n    async clear() {\n        throw new Error('Method \"clear()\" must be implemented.');\n    }\n\n    /**\n     * Get all keys stored by this driver\n     * @returns {Promise<string[]>}\n     */\n    async getKeys() {\n        throw new Error('Method \"getKeys()\" must be implemented.');\n    }\n}\n","import { get, set, del, clear, keys } from 'idb-keyval';\nimport LZString from 'lz-string';\nimport StorageInterface from '../StorageInterface.js';\n\n/**\n * @class IndexedDBAdapter\n * High-performance, asynchronous storage driver using IndexedDB.\n * Features transparent compression via LZ-String to maximize storage efficiency.\n */\nexport default class IndexedDBAdapter extends StorageInterface {\n    constructor() {\n        super();\n        this.name = 'IndexedDBAdapter';\n    }\n\n    /** @override */\n    async init() {\n        // IndexedDB/idb-keyval lazy-loads the DB connection on first request,\n        // so explicit init isn't strictly necessary but good for verification.\n        try {\n            if (typeof indexedDB === 'undefined') {\n                throw new Error('IndexedDB is not supported in this environment.');\n            }\n            return Promise.resolve();\n        } catch (e) {\n            console.warn('IndexedDB initialization failed:', e);\n            throw e;\n        }\n    }\n\n    /** @override */\n    async getItem(key) {\n        try {\n            const compressed = await get(key);\n            if (compressed === null || compressed === undefined) return null;\n\n            if (typeof compressed !== 'string') {\n                if (compressed && typeof compressed === 'object') {\n                    try {\n                        return JSON.parse(JSON.stringify(compressed));\n                    } catch {\n                        return compressed;\n                    }\n                }\n\n                return compressed;\n            }\n\n            // Detect if the data is actually compressed or legacy uncompressed (migration safety)\n            // LZ-String compressed strings usually don't look like JSON.\n            // We attempt decompression first.\n            let decompressed = LZString.decompressFromUTF16(compressed);\n\n            // If decompression returns null (invalid/empty input) but we had data,\n            // it might be raw data (though we ensure we always compress on write).\n            // Or it might be that LZString returns null on failure.\n\n            const payload = decompressed !== null ? decompressed : compressed;\n\n            try {\n                return JSON.parse(payload);\n            } catch {\n                // If it's not JSON, return raw string (rare case for us)\n                return payload;\n            }\n        } catch (e) {\n            console.warn(`[IndexedDBAdapter] Failed to get/decompress item: ${key}`, e);\n            return null;\n        }\n    }\n\n    /** @override */\n    async setItem(key, value) {\n        try {\n            const stringified = typeof value === 'string' ? value : JSON.stringify(value);\n            const compressed = LZString.compressToUTF16(stringified);\n            await set(key, compressed);\n        } catch (e) {\n            console.error(`[IndexedDBAdapter] Failed to compress/save item: ${key}`, e);\n            throw e;\n        }\n    }\n\n    /** @override */\n    async removeItem(key) {\n        return del(key);\n    }\n\n    /** @override */\n    async clear() {\n        return clear();\n    }\n\n    /** @override */\n    async getKeys() {\n        return keys();\n    }\n}\n","/**\n * @class UserContext\n * Manages the current user identity (UUID) and device identity for sync/locks.\n * - userId: Persistent anonymous identifier for the user (survives factory reset on same device)\n * - deviceId: Per-browser-profile identifier for lock management\n * - sessionId: Per-tab identifier for fine-grained lock tracking\n */\nexport class UserContext {\n    constructor() {\n        this.userId = null;\n        this.deviceId = null;\n        this.sessionId = null;\n        this.storageKey = 'cine_user_uuid';\n        this.deviceStorageKey = 'cine_device_uuid';\n    }\n\n    /**\n     * Generates a cryptographically random UUID or fallback.\n     * @returns {string}\n     */\n    generateUUID() {\n        if (typeof crypto !== 'undefined' && crypto.randomUUID) {\n            return crypto.randomUUID();\n        }\n        // Fallback for older environments\n        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {\n            const r = (Math.random() * 16) | 0;\n            const v = c === 'x' ? r : (r & 0x3) | 0x8;\n            return v.toString(16);\n        });\n    }\n\n    /**\n     * Initializes the user context.\n     * Checks localStorage for existing UUID, otherwise generates one.\n     */\n    init() {\n        if (this.userId && this.deviceId && this.sessionId) return this.userId;\n\n        // User ID (persistent across sessions)\n        let uuid = localStorage.getItem(this.storageKey);\n        if (!uuid) {\n            uuid = this.generateUUID();\n            localStorage.setItem(this.storageKey, uuid);\n            console.log('[UserContext] Generated new User UUID:', uuid);\n        } else {\n            console.log('[UserContext] Loaded User UUID:', uuid);\n        }\n        this.userId = uuid;\n\n        // Device ID (persistent per browser profile, for cross-tab coordination)\n        let deviceId = localStorage.getItem(this.deviceStorageKey);\n        if (!deviceId) {\n            deviceId = this.generateUUID();\n            localStorage.setItem(this.deviceStorageKey, deviceId);\n            console.log('[UserContext] Generated new Device UUID:', deviceId);\n        }\n        this.deviceId = deviceId;\n\n        // Session ID (unique per tab, for lock granularity)\n        this.sessionId = this.generateUUID();\n        console.log('[UserContext] Session UUID:', this.sessionId);\n\n        return uuid;\n    }\n\n    getUserId() {\n        if (!this.userId) return this.init();\n        return this.userId;\n    }\n\n    /**\n     * Returns the device UUID (unique per browser profile).\n     * Used for cross-device lock detection via cloud sync.\n     */\n    getDeviceId() {\n        if (!this.deviceId) this.init();\n        return this.deviceId;\n    }\n\n    /**\n     * Returns the session UUID (unique per tab).\n     * Used for same-device, cross-tab lock coordination.\n     */\n    getSessionId() {\n        if (!this.sessionId) this.init();\n        return this.sessionId;\n    }\n\n    /**\n     * Scopes a storage key with the current user ID.\n     * @param {string} key \n     */\n    getScopedKey(key) {\n        const uuid = this.getUserId();\n        return `user_${uuid}_${key}`;\n    }\n\n    /**\n     * Returns a full identity object for sync metadata.\n     */\n    getIdentity() {\n        return {\n            userId: this.getUserId(),\n            deviceId: this.getDeviceId(),\n            sessionId: this.getSessionId(),\n        };\n    }\n\n    /**\n     * Clears the user identity (Factory Reset).\n     * Note: Does NOT clear deviceId to maintain device tracking.\n     */\n    reset() {\n        localStorage.removeItem(this.storageKey);\n        this.userId = null;\n        this.sessionId = null;\n    }\n}\n\nexport const userContext = new UserContext();\n\n","import { userContext } from '../core/UserContext.js';\n\n/**\n * @module SyncMetadata\n * \n * Provides metadata wrappers for all stored data to enable:\n * - Offline-first sync with Firebase\n * - Conflict detection and resolution\n * - Lock management timestamps\n * - Change tracking at document level\n * \n * All data stored through the sync-aware API gets wrapped with _meta.\n */\n\n// Schema version for future migrations\nconst SYNC_METADATA_VERSION = 1;\n\n// Sync status constants\nexport const SyncStatus = Object.freeze({\n    /** Data has been synced to cloud */\n    SYNCED: 'synced',\n    /** Data has local changes not yet synced */\n    PENDING: 'pending',\n    /** Data has conflicts that need resolution */\n    CONFLICT: 'conflict',\n    /** Data is being synced right now */\n    SYNCING: 'syncing',\n    /** Data has never been synced (new) */\n    LOCAL_ONLY: 'local_only',\n});\n\n// Lock status constants\nexport const LockStatus = Object.freeze({\n    /** No lock held */\n    UNLOCKED: 'unlocked',\n    /** Locked by current session */\n    LOCKED_BY_SELF: 'locked_by_self',\n    /** Locked by another session on same device */\n    LOCKED_BY_OTHER_TAB: 'locked_by_other_tab',\n    /** Locked by another device */\n    LOCKED_BY_OTHER_DEVICE: 'locked_by_other_device',\n});\n\n/**\n * Generates an ISO timestamp string.\n * @returns {string}\n */\nfunction nowISO() {\n    return new Date().toISOString();\n}\n\n/**\n * Generates a unique document ID.\n * @param {string} [prefix] - Optional prefix for the ID\n * @returns {string}\n */\nexport function generateDocId(prefix = 'doc') {\n    const timestamp = Date.now().toString(36);\n    const random = Math.random().toString(36).substring(2, 10);\n    return `${prefix}_${timestamp}_${random}`;\n}\n\n/**\n * Creates fresh sync metadata for a new document.\n * @param {Object} options - Options for metadata creation\n * @param {string} [options.docId] - Document ID (generated if not provided)\n * @param {string} [options.docType] - Type of document (e.g., 'project', 'settings')\n * @returns {Object} Fresh metadata object\n */\nexport function createSyncMetadata(options = {}) {\n    const identity = userContext.getIdentity();\n    const now = nowISO();\n\n    return {\n        version: SYNC_METADATA_VERSION,\n        docId: options.docId || generateDocId(options.docType || 'doc'),\n        docType: options.docType || 'unknown',\n\n        // Ownership\n        ownerId: identity.userId,\n\n        // Timestamps\n        createdAt: now,\n        updatedAt: now,\n\n        // Sync state\n        syncStatus: SyncStatus.LOCAL_ONLY,\n        syncedAt: null,\n        syncError: null,\n\n        // Change tracking\n        changeCount: 1,\n        lastChangeBy: identity.userId,\n        lastChangeDevice: identity.deviceId,\n        lastChangeSession: identity.sessionId,\n\n        // Lock state (for active editing)\n        lock: null, // Will be { deviceId, sessionId, acquiredAt, heartbeat } when locked\n\n        // Collaboration (future)\n        sharedWith: [], // Array of user IDs\n        permissions: {}, // { userId: 'read' | 'write' | 'admin' }\n    };\n}\n\n/**\n * Updates sync metadata when data is modified.\n * @param {Object} existingMeta - Current metadata\n * @returns {Object} Updated metadata\n */\nexport function updateSyncMetadata(existingMeta) {\n    if (!existingMeta || typeof existingMeta !== 'object') {\n        return createSyncMetadata();\n    }\n\n    const identity = userContext.getIdentity();\n    const now = nowISO();\n\n    return {\n        ...existingMeta,\n        version: SYNC_METADATA_VERSION,\n        updatedAt: now,\n        syncStatus: existingMeta.syncStatus === SyncStatus.SYNCED\n            ? SyncStatus.PENDING\n            : existingMeta.syncStatus,\n        changeCount: (existingMeta.changeCount || 0) + 1,\n        lastChangeBy: identity.userId,\n        lastChangeDevice: identity.deviceId,\n        lastChangeSession: identity.sessionId,\n    };\n}\n\n/**\n * Marks metadata as successfully synced.\n * @param {Object} existingMeta - Current metadata\n * @param {string} [serverTimestamp] - Server timestamp if available\n * @returns {Object} Updated metadata\n */\nexport function markAsSynced(existingMeta, serverTimestamp = null) {\n    if (!existingMeta || typeof existingMeta !== 'object') {\n        console.warn('[SyncMetadata] Cannot mark null metadata as synced');\n        return existingMeta;\n    }\n\n    return {\n        ...existingMeta,\n        syncStatus: SyncStatus.SYNCED,\n        syncedAt: serverTimestamp || nowISO(),\n        syncError: null,\n    };\n}\n\n/**\n * Marks metadata as having a sync conflict.\n * @param {Object} existingMeta - Current metadata\n * @param {string} errorMessage - Conflict description\n * @returns {Object} Updated metadata\n */\nexport function markAsConflict(existingMeta, errorMessage) {\n    if (!existingMeta || typeof existingMeta !== 'object') {\n        return existingMeta;\n    }\n\n    return {\n        ...existingMeta,\n        syncStatus: SyncStatus.CONFLICT,\n        syncError: errorMessage,\n    };\n}\n\n/**\n * Wraps raw data with sync metadata.\n * @param {any} data - The actual data to store\n * @param {Object} [existingMeta] - Existing metadata to update, or null for new\n * @param {Object} [options] - Options for new metadata\n * @returns {Object} Wrapped data with _meta\n */\nexport function wrapWithMetadata(data, existingMeta = null, options = {}) {\n    const meta = existingMeta\n        ? updateSyncMetadata(existingMeta)\n        : createSyncMetadata(options);\n\n    return {\n        _meta: meta,\n        data: data,\n    };\n}\n\n/**\n * Unwraps data from metadata wrapper.\n * @param {Object} wrapped - Data with _meta wrapper\n * @returns {{ data: any, meta: Object }} Separated data and metadata\n */\nexport function unwrapMetadata(wrapped) {\n    if (!wrapped || typeof wrapped !== 'object') {\n        return { data: wrapped, meta: null };\n    }\n\n    // Check if this is wrapped data\n    if (wrapped._meta && 'data' in wrapped) {\n        return { data: wrapped.data, meta: wrapped._meta };\n    }\n\n    // Legacy data without metadata wrapper\n    return { data: wrapped, meta: null };\n}\n\n/**\n * Checks if data has sync metadata.\n * @param {any} data - Data to check\n * @returns {boolean}\n */\nexport function hasMetadata(data) {\n    return data && typeof data === 'object' && '_meta' in data && 'data' in data;\n}\n\n/**\n * Determines the lock status of a document relative to current session.\n * @param {Object} meta - Document metadata\n * @returns {string} One of LockStatus values\n */\nexport function getLockStatus(meta) {\n    if (!meta || !meta.lock) {\n        return LockStatus.UNLOCKED;\n    }\n\n    const identity = userContext.getIdentity();\n    const lock = meta.lock;\n\n    // Check if lock has expired (30 second heartbeat timeout)\n    const lockAge = Date.now() - new Date(lock.heartbeat || lock.acquiredAt).getTime();\n    if (lockAge > 30000) {\n        return LockStatus.UNLOCKED; // Lock expired\n    }\n\n    // Check session ownership\n    if (lock.sessionId === identity.sessionId) {\n        return LockStatus.LOCKED_BY_SELF;\n    }\n\n    // Check device ownership\n    if (lock.deviceId === identity.deviceId) {\n        return LockStatus.LOCKED_BY_OTHER_TAB;\n    }\n\n    return LockStatus.LOCKED_BY_OTHER_DEVICE;\n}\n\n/**\n * Creates a lock object for the current session.\n * @returns {Object} Lock object\n */\nexport function createLock() {\n    const identity = userContext.getIdentity();\n    const now = nowISO();\n\n    return {\n        userId: identity.userId,\n        deviceId: identity.deviceId,\n        sessionId: identity.sessionId,\n        acquiredAt: now,\n        heartbeat: now,\n    };\n}\n\n/**\n * Updates the heartbeat timestamp of an existing lock.\n * @param {Object} lock - Existing lock object\n * @returns {Object} Updated lock object\n */\nexport function updateLockHeartbeat(lock) {\n    if (!lock) return createLock();\n\n    return {\n        ...lock,\n        heartbeat: nowISO(),\n    };\n}\n\n/**\n * Gets items that need syncing from an array of wrapped items.\n * @param {Array} items - Array of wrapped data items\n * @returns {Array} Items with pending sync status\n */\nexport function getPendingSyncItems(items) {\n    if (!Array.isArray(items)) return [];\n\n    return items.filter(item => {\n        if (!hasMetadata(item)) return false;\n        const { meta } = unwrapMetadata(item);\n        return meta && (\n            meta.syncStatus === SyncStatus.PENDING ||\n            meta.syncStatus === SyncStatus.LOCAL_ONLY\n        );\n    });\n}\n\nexport default {\n    SyncStatus,\n    LockStatus,\n    generateDocId,\n    createSyncMetadata,\n    updateSyncMetadata,\n    markAsSynced,\n    markAsConflict,\n    wrapWithMetadata,\n    unwrapMetadata,\n    hasMetadata,\n    getLockStatus,\n    createLock,\n    updateLockHeartbeat,\n    getPendingSyncItems,\n};\n","import { userContext } from '../core/UserContext.js';\nimport {\n    createLock,\n    updateLockHeartbeat,\n    getLockStatus,\n    LockStatus\n} from './SyncMetadata.js';\n\n/**\n * @class ProjectLockService\n * \n * Manages project edit locks to prevent simultaneous editing across:\n * - Multiple browser tabs (same device)\n * - Multiple devices (via cloud sync)\n * \n * Lock Strategy:\n * 1. BroadcastChannel for instant cross-tab coordination (same browser)\n * 2. localStorage/IndexedDB heartbeats for persistence (survives page refresh)\n * 3. Cloud lock document for cross-device coordination (future Firebase)\n * \n * Lock Lifecycle:\n * - Acquire: Check if unlocked  Set lock  Start heartbeat\n * - Heartbeat: Update timestamp every 5s to prove \"still alive\"\n * - Release: Clear lock on page unload or explicit release\n * - Takeover: Force acquire when user confirms takeover prompt\n * \n * Timeout: Lock expires if heartbeat not updated for 30 seconds\n */\n\nconst LOCK_CHANNEL_NAME = 'cine-project-locks';\nconst HEARTBEAT_INTERVAL_MS = 5000; // 5 seconds\nconst LOCK_TIMEOUT_MS = 30000; // 30 seconds\nconst LOCK_STORAGE_PREFIX = 'cine_project_lock_';\n\n// Event types for BroadcastChannel\nconst LockEvent = Object.freeze({\n    LOCK_ACQUIRED: 'lock_acquired',\n    LOCK_RELEASED: 'lock_released',\n    LOCK_HEARTBEAT: 'lock_heartbeat',\n    LOCK_TAKEOVER: 'lock_takeover',\n    LOCK_QUERY: 'lock_query',\n    LOCK_STATUS: 'lock_status',\n});\n\n/**\n * @typedef {Object} Lock\n * @property {string} projectId - The project being locked\n * @property {string} userId - Owner of the lock\n * @property {string} deviceId - Device holding the lock\n * @property {string} sessionId - Tab/session holding the lock\n * @property {string} acquiredAt - ISO timestamp when lock was acquired\n * @property {string} heartbeat - ISO timestamp of last heartbeat\n */\n\nclass ProjectLockService {\n    constructor() {\n        /** @type {BroadcastChannel|null} */\n        this.channel = null;\n\n        /** @type {Map<string, Lock>} Project ID -> Lock */\n        this.localLocks = new Map();\n\n        /** @type {Map<string, number>} Project ID -> Interval ID */\n        this.heartbeatIntervals = new Map();\n\n        /** @type {Set<Function>} */\n        this.lockChangeListeners = new Set();\n\n        /** @type {boolean} */\n        this.initialized = false;\n    }\n\n    /**\n     * Initializes the lock service.\n     * Must be called before using any lock operations.\n     */\n    init() {\n        if (this.initialized) return;\n\n        // Ensure UserContext is initialized\n        userContext.init();\n\n        // Setup BroadcastChannel for cross-tab coordination\n        if (typeof BroadcastChannel !== 'undefined') {\n            try {\n                this.channel = new BroadcastChannel(LOCK_CHANNEL_NAME);\n                this.channel.onmessage = (event) => this._handleChannelMessage(event);\n                console.log('[ProjectLockService] BroadcastChannel initialized');\n            } catch (err) {\n                console.warn('[ProjectLockService] BroadcastChannel not available:', err);\n            }\n        }\n\n        // Restore locks from localStorage (for page refresh scenarios)\n        this._restoreLocksFromStorage();\n\n        // Setup page unload handler to release locks\n        if (typeof window !== 'undefined') {\n            window.addEventListener('beforeunload', () => this._handlePageUnload());\n            window.addEventListener('pagehide', () => this._handlePageUnload());\n        }\n\n        this.initialized = true;\n        console.log('[ProjectLockService] Initialized');\n    }\n\n    /**\n     * Attempts to acquire a lock on a project.\n     * @param {string} projectId - Project to lock\n     * @param {Object} [options] - Lock options\n     * @param {boolean} [options.force] - Force takeover even if locked by another\n     * @returns {Promise<{ success: boolean, status: string, lock: Lock|null }>}\n     */\n    async acquireLock(projectId, options = {}) {\n        this.init();\n\n        const existingLock = this._getStoredLock(projectId);\n        const status = this._getLockStatusForLock(existingLock);\n\n        // Already locked by current session\n        if (status === LockStatus.LOCKED_BY_SELF) {\n            return { success: true, status, lock: existingLock };\n        }\n\n        // Locked by another and not forcing takeover\n        if (status !== LockStatus.UNLOCKED && !options.force) {\n            return { success: false, status, lock: existingLock };\n        }\n\n        // If forcing takeover, notify the other session\n        if (options.force && existingLock) {\n            this._broadcastTakeover(projectId, existingLock);\n        }\n\n        // Create and store the lock\n        const lock = this._createLockObject(projectId);\n        this._storeLock(projectId, lock);\n        this.localLocks.set(projectId, lock);\n\n        // Start heartbeat\n        this._startHeartbeat(projectId);\n\n        // Notify other tabs\n        this._broadcastLockAcquired(projectId, lock);\n\n        // Notify local listeners\n        this._notifyListeners(projectId, LockStatus.LOCKED_BY_SELF, lock);\n\n        console.log('[ProjectLockService] Lock acquired:', projectId);\n        return { success: true, status: LockStatus.LOCKED_BY_SELF, lock };\n    }\n\n    /**\n     * Releases a lock on a project.\n     * @param {string} projectId - Project to unlock\n     * @returns {Promise<boolean>} Whether release was successful\n     */\n    async releaseLock(projectId) {\n        this.init();\n\n        const existingLock = this._getStoredLock(projectId);\n        const status = this._getLockStatusForLock(existingLock);\n\n        // Can only release own locks\n        if (status !== LockStatus.LOCKED_BY_SELF) {\n            console.warn('[ProjectLockService] Cannot release lock not owned by this session');\n            return false;\n        }\n\n        // Stop heartbeat\n        this._stopHeartbeat(projectId);\n\n        // Remove lock\n        this._clearStoredLock(projectId);\n        this.localLocks.delete(projectId);\n\n        // Notify other tabs\n        this._broadcastLockReleased(projectId);\n\n        // Notify local listeners\n        this._notifyListeners(projectId, LockStatus.UNLOCKED, null);\n\n        console.log('[ProjectLockService] Lock released:', projectId);\n        return true;\n    }\n\n    /**\n     * Gets the current lock status for a project.\n     * @param {string} projectId - Project to check\n     * @returns {{ status: string, lock: Lock|null, isEditable: boolean }}\n     */\n    getLockInfo(projectId) {\n        this.init();\n\n        const lock = this._getStoredLock(projectId);\n        const status = this._getLockStatusForLock(lock);\n\n        return {\n            status,\n            lock: lock,\n            isEditable: status === LockStatus.UNLOCKED || status === LockStatus.LOCKED_BY_SELF,\n        };\n    }\n\n    /**\n     * Subscribes to lock change events.\n     * @param {Function} callback - Called with (projectId, status, lock)\n     * @returns {Function} Unsubscribe function\n     */\n    subscribe(callback) {\n        this.lockChangeListeners.add(callback);\n        return () => this.lockChangeListeners.delete(callback);\n    }\n\n    /**\n     * Refreshes the heartbeat for a lock.\n     * Called automatically, but can be triggered manually.\n     * @param {string} projectId \n     */\n    refreshHeartbeat(projectId) {\n        const lock = this.localLocks.get(projectId);\n        if (!lock) return;\n\n        const identity = userContext.getIdentity();\n\n        // Verify we still own this lock\n        if (lock.sessionId !== identity.sessionId) {\n            this._stopHeartbeat(projectId);\n            return;\n        }\n\n        // Update heartbeat\n        lock.heartbeat = new Date().toISOString();\n        this._storeLock(projectId, lock);\n\n        // Notify other tabs\n        this._broadcastHeartbeat(projectId, lock);\n    }\n\n    // --- Private Methods ---\n\n    _createLockObject(projectId) {\n        const identity = userContext.getIdentity();\n        const now = new Date().toISOString();\n\n        return {\n            projectId,\n            userId: identity.userId,\n            deviceId: identity.deviceId,\n            sessionId: identity.sessionId,\n            acquiredAt: now,\n            heartbeat: now,\n        };\n    }\n\n    _getStorageKey(projectId) {\n        return LOCK_STORAGE_PREFIX + projectId;\n    }\n\n    _storeLock(projectId, lock) {\n        try {\n            localStorage.setItem(this._getStorageKey(projectId), JSON.stringify(lock));\n        } catch (err) {\n            console.warn('[ProjectLockService] Failed to store lock:', err);\n        }\n    }\n\n    _getStoredLock(projectId) {\n        try {\n            const data = localStorage.getItem(this._getStorageKey(projectId));\n            if (!data) return null;\n\n            const lock = JSON.parse(data);\n\n            // Check if lock has expired\n            if (this._isLockExpired(lock)) {\n                this._clearStoredLock(projectId);\n                return null;\n            }\n\n            return lock;\n        } catch (err) {\n            console.warn('[ProjectLockService] Failed to read lock:', err);\n            return null;\n        }\n    }\n\n    _clearStoredLock(projectId) {\n        try {\n            localStorage.removeItem(this._getStorageKey(projectId));\n        } catch (err) {\n            console.warn('[ProjectLockService] Failed to clear lock:', err);\n        }\n    }\n\n    _isLockExpired(lock) {\n        if (!lock || !lock.heartbeat) return true;\n        const age = Date.now() - new Date(lock.heartbeat).getTime();\n        return age > LOCK_TIMEOUT_MS;\n    }\n\n    _getLockStatusForLock(lock) {\n        if (!lock || this._isLockExpired(lock)) {\n            return LockStatus.UNLOCKED;\n        }\n\n        const identity = userContext.getIdentity();\n\n        if (lock.sessionId === identity.sessionId) {\n            return LockStatus.LOCKED_BY_SELF;\n        }\n\n        if (lock.deviceId === identity.deviceId) {\n            return LockStatus.LOCKED_BY_OTHER_TAB;\n        }\n\n        return LockStatus.LOCKED_BY_OTHER_DEVICE;\n    }\n\n    _startHeartbeat(projectId) {\n        this._stopHeartbeat(projectId); // Clear any existing\n\n        const intervalId = setInterval(() => {\n            this.refreshHeartbeat(projectId);\n        }, HEARTBEAT_INTERVAL_MS);\n\n        this.heartbeatIntervals.set(projectId, intervalId);\n    }\n\n    _stopHeartbeat(projectId) {\n        const intervalId = this.heartbeatIntervals.get(projectId);\n        if (intervalId) {\n            clearInterval(intervalId);\n            this.heartbeatIntervals.delete(projectId);\n        }\n    }\n\n    _restoreLocksFromStorage() {\n        const identity = userContext.getIdentity();\n\n        try {\n            for (let i = 0; i < localStorage.length; i++) {\n                const key = localStorage.key(i);\n                if (!key || !key.startsWith(LOCK_STORAGE_PREFIX)) continue;\n\n                const projectId = key.slice(LOCK_STORAGE_PREFIX.length);\n                const lock = this._getStoredLock(projectId);\n\n                // Only restore locks owned by this session\n                if (lock && lock.sessionId === identity.sessionId) {\n                    this.localLocks.set(projectId, lock);\n                    this._startHeartbeat(projectId);\n                    console.log('[ProjectLockService] Restored lock:', projectId);\n                }\n            }\n        } catch (err) {\n            console.warn('[ProjectLockService] Failed to restore locks:', err);\n        }\n    }\n\n    _handlePageUnload() {\n        // Release all locks held by this session\n        for (const projectId of this.localLocks.keys()) {\n            this._stopHeartbeat(projectId);\n            this._clearStoredLock(projectId);\n            this._broadcastLockReleased(projectId);\n        }\n        this.localLocks.clear();\n    }\n\n    _notifyListeners(projectId, status, lock) {\n        for (const callback of this.lockChangeListeners) {\n            try {\n                callback(projectId, status, lock);\n            } catch (err) {\n                console.warn('[ProjectLockService] Listener error:', err);\n            }\n        }\n    }\n\n    // --- BroadcastChannel Methods ---\n\n    _broadcast(type, data) {\n        if (!this.channel) return;\n        try {\n            this.channel.postMessage({ type, ...data });\n        } catch (err) {\n            console.warn('[ProjectLockService] Broadcast failed:', err);\n        }\n    }\n\n    _broadcastLockAcquired(projectId, lock) {\n        this._broadcast(LockEvent.LOCK_ACQUIRED, { projectId, lock });\n    }\n\n    _broadcastLockReleased(projectId) {\n        this._broadcast(LockEvent.LOCK_RELEASED, { projectId });\n    }\n\n    _broadcastHeartbeat(projectId, lock) {\n        this._broadcast(LockEvent.LOCK_HEARTBEAT, { projectId, lock });\n    }\n\n    _broadcastTakeover(projectId, oldLock) {\n        this._broadcast(LockEvent.LOCK_TAKEOVER, { projectId, oldLock });\n    }\n\n    _handleChannelMessage(event) {\n        const { type, projectId, lock, oldLock } = event.data || {};\n        if (!projectId) return;\n\n        const identity = userContext.getIdentity();\n\n        switch (type) {\n            case LockEvent.LOCK_ACQUIRED:\n                // Another tab acquired a lock\n                if (lock && lock.sessionId !== identity.sessionId) {\n                    this._notifyListeners(projectId, this._getLockStatusForLock(lock), lock);\n                }\n                break;\n\n            case LockEvent.LOCK_RELEASED:\n                // Another tab released a lock\n                this._notifyListeners(projectId, LockStatus.UNLOCKED, null);\n                break;\n\n            case LockEvent.LOCK_TAKEOVER:\n                // Another tab is taking over our lock\n                if (oldLock && oldLock.sessionId === identity.sessionId) {\n                    console.warn('[ProjectLockService] Lock taken over by another tab:', projectId);\n                    this._stopHeartbeat(projectId);\n                    this.localLocks.delete(projectId);\n                    this._notifyListeners(projectId, LockStatus.LOCKED_BY_OTHER_TAB, null);\n                }\n                break;\n\n            case LockEvent.LOCK_HEARTBEAT:\n                // Update our knowledge of external lock heartbeat\n                if (lock && lock.sessionId !== identity.sessionId) {\n                    this._storeLock(projectId, lock);\n                }\n                break;\n        }\n    }\n\n    /**\n     * Cleanup method for testing or shutdown.\n     */\n    destroy() {\n        // Stop all heartbeats\n        for (const projectId of this.heartbeatIntervals.keys()) {\n            this._stopHeartbeat(projectId);\n        }\n\n        // Close channel\n        if (this.channel) {\n            this.channel.close();\n            this.channel = null;\n        }\n\n        this.localLocks.clear();\n        this.lockChangeListeners.clear();\n        this.initialized = false;\n    }\n}\n\n// Export singleton instance\nexport const projectLockService = new ProjectLockService();\n\nexport default projectLockService;\n","import IndexedDBAdapter from './drivers/IndexedDBAdapter.js';\nimport { userContext } from '../core/UserContext.js';\nimport {\n    wrapWithMetadata,\n    unwrapMetadata,\n    hasMetadata,\n    markAsSynced,\n    markAsConflict,\n    SyncStatus,\n    LockStatus,\n    generateDocId,\n} from './SyncMetadata.js';\nimport { projectLockService } from './ProjectLockService.js';\n\nconst PROJECT_KEY_PREFIX = 'cine_project:';\n\n/**\n * @class StorageRepository\n * The main entry point for data persistence.\n * \n * Features:\n * - User-scoped storage via UserContext\n * - Sync metadata wrapping for cloud-ready data\n * - Project locking integration for concurrent edit prevention\n * - Driver swapping (LocalStorage  IndexedDB)\n */\nexport class StorageRepository {\n    constructor() {\n        this.driver = new IndexedDBAdapter();\n        this.initialized = false;\n    }\n\n    /**\n     * Initializes the active storage driver.\n     */\n    async init() {\n        if (this.initialized) return;\n\n        // Default to LocalStorage\n        await this.driver.init();\n        console.log('[StorageRepository] Initialized with default driver:', this.driver.constructor.name);\n        this.initialized = true;\n\n        // Initialize project lock service\n        projectLockService.init();\n    }\n\n    /**\n     * Switches the underlying driver at runtime.\n     * Useful after migration completes.\n     * @param {StorageInterface} newDriver \n     */\n    async switchDriver(newDriver) {\n        console.log('[StorageRepository] Switching driver to:', newDriver.constructor.name);\n        await newDriver.init();\n        this.driver = newDriver;\n    }\n\n    // --- Core Storage Methods ---\n\n    async getItem(key) {\n        if (!this.initialized) await this.init();\n        const scopedKey = userContext.getScopedKey(key);\n        return this.driver.getItem(scopedKey);\n    }\n\n    async setItem(key, value) {\n        if (!this.initialized) await this.init();\n        const scopedKey = userContext.getScopedKey(key);\n        return this.driver.setItem(scopedKey, value);\n    }\n\n    async removeItem(key) {\n        if (!this.initialized) await this.init();\n        const scopedKey = userContext.getScopedKey(key);\n        return this.driver.removeItem(scopedKey);\n    }\n\n    async clear() {\n        if (!this.initialized) await this.init();\n        const keys = await this.driver.getKeys();\n        // Use the user_${userId}_ prefix to avoid deleting other users' data in shared storage.\n        const prefix = `user_${userContext.getUserId()}_`;\n        const deletionPromises = keys\n            .filter(k => k.startsWith(prefix))\n            .map(k => this.driver.removeItem(k));\n        await Promise.all(deletionPromises);\n    }\n\n    async getKeys() {\n        if (!this.initialized) await this.init();\n        const allKeys = await this.driver.getKeys();\n        // Use the user_${userId}_ prefix to avoid exposing other users' data in shared storage.\n        const prefix = `user_${userContext.getUserId()}_`;\n        return allKeys\n            .filter(k => k.startsWith(prefix))\n            .map(k => k.slice(prefix.length));\n    }\n\n    getProjectKeyPrefix() {\n        return PROJECT_KEY_PREFIX;\n    }\n\n    getProjectStorageKey(projectKey) {\n        return `${PROJECT_KEY_PREFIX}${projectKey}`;\n    }\n\n    getProjectKeyFromStorageKey(storageKey) {\n        if (typeof storageKey !== 'string') return storageKey;\n        if (!storageKey.startsWith(PROJECT_KEY_PREFIX)) {\n            return storageKey;\n        }\n        return storageKey.slice(PROJECT_KEY_PREFIX.length);\n    }\n\n    isProjectStorageKey(storageKey) {\n        return typeof storageKey === 'string' && storageKey.startsWith(PROJECT_KEY_PREFIX);\n    }\n\n    async getProjectKeys() {\n        const keys = await this.getKeys();\n        return keys\n            .filter(key => this.isProjectStorageKey(key))\n            .map(key => this.getProjectKeyFromStorageKey(key));\n    }\n\n    // --- Sync-Aware Project Methods ---\n\n    /**\n     * Loads a project with its sync metadata.\n     * @param {string} projectKey \n     * @returns {Promise<{ data: any, meta: Object|null }>}\n     */\n    async loadProject(projectKey) {\n        const storageKey = this.getProjectStorageKey(projectKey);\n        const raw = await this.getItem(storageKey);\n        return unwrapMetadata(raw);\n    }\n\n    /**\n     * Loads raw project data without unwrapping (legacy compatibility).\n     * @param {string} projectKey \n     * @returns {Promise<any>}\n     */\n    async loadProjectRaw(projectKey) {\n        const result = await this.loadProject(projectKey);\n        return result.data;\n    }\n\n    /**\n     * Saves a project with sync metadata.\n     * @param {string} projectKey - Unique project identifier\n     * @param {Object} projectData - The actual project data\n     * @param {Object} [existingMeta] - Existing metadata to update\n     * @returns {Promise<{ success: boolean, meta: Object }>}\n     */\n    async saveProject(projectKey, projectData, existingMeta = null) {\n        if (!this.initialized) await this.init();\n\n        // Check lock status\n        const lockInfo = projectLockService.getLockInfo(projectKey);\n        if (!lockInfo.isEditable) {\n            console.warn('[StorageRepository] Cannot save - project is locked by another session');\n            return {\n                success: false,\n                error: 'PROJECT_LOCKED',\n                lockInfo\n            };\n        }\n\n        // Wrap with metadata\n        const wrapped = wrapWithMetadata(projectData, existingMeta, {\n            docType: 'project',\n            docId: projectKey,\n        });\n\n        // Save to storage\n        const storageKey = this.getProjectStorageKey(projectKey);\n        await this.setItem(storageKey, wrapped);\n\n        // Best-effort OPFS DataVault snapshot: optional for local saves, never blocks the\n        // primary save path, and exists to strengthen offline recovery resilience.\n        import('./DataVault.js').then(({ dataVault }) => {\n            if (dataVault) {\n                dataVault.saveSnapshot(projectKey, wrapped).catch(err =>\n                    console.warn('Auto-backup failed', err)\n                );\n            }\n        });\n\n        console.log('[StorageRepository] Project saved with metadata:', projectKey);\n        return { success: true, meta: wrapped._meta };\n    }\n\n    /**\n     * Gets only the sync metadata for a project without loading full data.\n     * Useful for sync status checks.\n     * @param {string} projectKey \n     * @returns {Promise<Object|null>}\n     */\n    async getProjectMeta(projectKey) {\n        const storageKey = this.getProjectStorageKey(projectKey);\n        const raw = await this.getItem(storageKey);\n        if (!hasMetadata(raw)) return null;\n        return raw._meta;\n    }\n\n    /**\n     * Marks a project as synced with the cloud.\n     * @param {string} projectKey \n     * @param {string} [serverTimestamp] - Timestamp from server\n     * @returns {Promise<boolean>}\n     */\n    async markProjectSynced(projectKey, serverTimestamp = null) {\n        const storageKey = this.getProjectStorageKey(projectKey);\n        const raw = await this.getItem(storageKey);\n        if (!hasMetadata(raw)) {\n            console.warn('[StorageRepository] Cannot mark as synced - no metadata');\n            return false;\n        }\n\n        raw._meta = markAsSynced(raw._meta, serverTimestamp);\n        await this.setItem(storageKey, raw);\n        return true;\n    }\n\n    /**\n     * Marks a project as having a sync conflict.\n     * @param {string} projectKey \n     * @param {string} errorMessage \n     * @returns {Promise<boolean>}\n     */\n    async markProjectConflict(projectKey, errorMessage) {\n        const storageKey = this.getProjectStorageKey(projectKey);\n        const raw = await this.getItem(storageKey);\n        if (!hasMetadata(raw)) return false;\n\n        raw._meta = markAsConflict(raw._meta, errorMessage);\n        await this.setItem(storageKey, raw);\n        return true;\n    }\n\n    /**\n     * Gets all projects that need syncing.\n     * @returns {Promise<Array<{ key: string, meta: Object }>>}\n     */\n    async getPendingSyncProjects() {\n        const keys = await this.getProjectKeys();\n        const pending = [];\n\n        for (const key of keys) {\n            const meta = await this.getProjectMeta(key);\n            if (meta && (\n                meta.syncStatus === SyncStatus.PENDING ||\n                meta.syncStatus === SyncStatus.LOCAL_ONLY\n            )) {\n                pending.push({ key, meta });\n            }\n        }\n\n        return pending;\n    }\n\n    /**\n     * Lists all projects with their metadata.\n     * @returns {Promise<Array<{ key: string, data: any, meta: Object|null }>>}\n     */\n    async listProjects() {\n        const keys = await this.getProjectKeys();\n        const projects = [];\n\n        for (const key of keys) {\n            const { data, meta } = await this.loadProject(key);\n            // Filter to only items that look like projects (have metadata with docType)\n            if (meta && meta.docType === 'project') {\n                projects.push({ key, data, meta });\n            }\n        }\n\n        return projects;\n    }\n\n    // --- Lock Management Pass-through ---\n\n    /**\n     * Attempts to acquire an edit lock on a project.\n     * @param {string} projectKey \n     * @param {Object} [options] - { force: boolean }\n     * @returns {Promise<{ success: boolean, status: string }>}\n     */\n    async acquireProjectLock(projectKey, options = {}) {\n        if (!this.initialized) await this.init();\n        return projectLockService.acquireLock(projectKey, options);\n    }\n\n    /**\n     * Releases an edit lock on a project.\n     * @param {string} projectKey \n     * @returns {Promise<boolean>}\n     */\n    async releaseProjectLock(projectKey) {\n        return projectLockService.releaseLock(projectKey);\n    }\n\n    /**\n     * Gets lock info for a project.\n     * @param {string} projectKey \n     * @returns {{ status: string, isEditable: boolean }}\n     */\n    getProjectLockInfo(projectKey) {\n        return projectLockService.getLockInfo(projectKey);\n    }\n\n    /**\n     * Subscribe to lock changes.\n     * @param {Function} callback - (projectKey, status, lock) => void\n     * @returns {Function} Unsubscribe function\n     */\n    onLockChange(callback) {\n        return projectLockService.subscribe(callback);\n    }\n\n    async removeProject(projectKey) {\n        const storageKey = this.getProjectStorageKey(projectKey);\n        return this.removeItem(storageKey);\n    }\n\n    async migrateUnprefixedProjectRecords({ projectIndexKeys = [] } = {}) {\n        if (!this.initialized) await this.init();\n\n        const keys = await this.getKeys();\n        const prefixedKeys = new Set(keys.filter(key => this.isProjectStorageKey(key)));\n        const candidates = new Set();\n        const indexKeys = Array.isArray(projectIndexKeys) ? projectIndexKeys : [];\n\n        indexKeys.forEach((key) => {\n            const rawKey = this.getProjectKeyFromStorageKey(key);\n            if (typeof rawKey === 'string' && rawKey) {\n                candidates.add(rawKey);\n            }\n        });\n\n        for (const key of keys) {\n            if (this.isProjectStorageKey(key)) continue;\n            if (candidates.has(key)) continue;\n\n            const value = await this.getItem(key);\n            if (hasMetadata(value) && value._meta && value._meta.docType === 'project') {\n                candidates.add(key);\n            }\n        }\n\n        const migrated = [];\n\n        for (const rawKey of candidates) {\n            if (typeof rawKey !== 'string' || !rawKey) continue;\n            const prefixedKey = this.getProjectStorageKey(rawKey);\n            if (prefixedKeys.has(prefixedKey)) {\n                continue;\n            }\n\n            const value = await this.getItem(rawKey);\n            if (value === null || value === undefined) {\n                continue;\n            }\n\n            try {\n                await this.setItem(prefixedKey, value);\n                await this.removeItem(rawKey);\n                prefixedKeys.add(prefixedKey);\n                migrated.push(rawKey);\n            } catch (migrationError) {\n                console.warn(`[StorageRepository] Failed to migrate project key \"${rawKey}\"`, migrationError);\n            }\n        }\n\n        return { migratedKeys: migrated };\n    }\n}\n\n// Export a singleton instance\nexport const storageRepo = new StorageRepository();\n","import StorageInterface from '../StorageInterface.js';\n\n/**\n * @class LocalStorageAdapter\n * Adapts specific localStorage operations to the standard asynchronous StorageInterface.\n * Acts as a backward-compatibility layer.\n */\nexport default class LocalStorageAdapter extends StorageInterface {\n    constructor() {\n        super();\n        try {\n            this.storage = window.localStorage;\n        } catch (error) {\n            console.warn('[LocalStorageAdapter] Unable to access window.localStorage.', error);\n            this.storage = null;\n        }\n    }\n\n    /** @override */\n    async init() {\n        // LocalStorage is synchronous and always ready (if available)\n        if (!this.storage) {\n            throw new Error(\n                'LocalStorage is unavailable. Access to window.localStorage failed or is blocked.'\n            );\n        }\n        return Promise.resolve();\n    }\n\n    /** @override */\n    async getItem(key) {\n        try {\n            const raw = this.storage.getItem(key);\n            if (raw === null) return null;\n            // Attempt generic JSON parse, fallback to raw string if it's not JSON\n            try {\n                return JSON.parse(raw);\n            } catch {\n                return raw;\n            }\n        } catch (e) {\n            console.warn(`[LocalStorageAdapter] Failed to get item: ${key}`, e);\n            return null;\n        }\n    }\n\n    /** @override */\n    async setItem(key, value) {\n        try {\n            // Store strings directly, object/arrays as JSON\n            const payload = typeof value === 'string' ? value : JSON.stringify(value);\n            this.storage.setItem(key, payload);\n        } catch (e) {\n            console.error(`[LocalStorageAdapter] Failed to save item: ${key}`, e);\n            throw e; // Propagate error (e.g., QuotaExceededError)\n        }\n    }\n\n    /** @override */\n    async removeItem(key) {\n        try {\n            this.storage.removeItem(key);\n        } catch (e) {\n            console.warn(`[LocalStorageAdapter] Failed to remove item: ${key}`, e);\n        }\n    }\n\n    /** @override */\n    async clear() {\n        try {\n            this.storage.clear();\n        } catch (e) {\n            console.warn('[LocalStorageAdapter] Failed to clear storage', e);\n        }\n    }\n\n    /** @override */\n    async getKeys() {\n        const keys = [];\n        for (let i = 0; i < this.storage.length; i += 1) {\n            const key = this.storage.key(i);\n            if (key !== null) {\n                keys.push(key);\n            }\n        }\n        return keys;\n    }\n}\n","import { storageRepo } from './StorageRepository.js';\nimport LocalStorageAdapter from './drivers/LocalStorageAdapter.js';\nimport IndexedDBAdapter from './drivers/IndexedDBAdapter.js';\n\nconst MIGRATION_FLAG_KEY = 'cine_storage_migrated_v2';\n\n/**\n * Service to handle the one-time migration from LocalStorage to IndexedDB.\n */\nexport class StorageMigrationService {\n    constructor() {\n        this.localStorage = new LocalStorageAdapter();\n        this.indexedDB = new IndexedDBAdapter();\n    }\n\n    /**\n     * Checks if migration is needed and executes it.\n     * @returns {Promise<boolean>} True if migration occurred, False otherwise.\n     */\n    async runMigrationIfNeeded() {\n        try {\n            await this.localStorage.init();\n            await this.indexedDB.init();\n\n            const alreadyMigrated = await this.localStorage.getItem(MIGRATION_FLAG_KEY);\n            if (alreadyMigrated === 'true') {\n                console.log('[MigrationService] Storage already migrated to IndexedDB.');\n                return false;\n            }\n\n            console.log('[MigrationService] Starting storage migration...');\n\n            const keys = await this.localStorage.getKeys();\n            if (keys.length === 0) {\n                console.log('[MigrationService] No local storage data found. safe to skip.');\n                await this.markAsMigrated();\n                return false;\n            }\n\n            // Filter out internal flags that don't need migration\n            // Note: cine_user_uuid is regenerated/scoped by UserContext; migrating it risks cross-user contamination.\n            const keysToMigrate = keys.filter(k => k !== MIGRATION_FLAG_KEY && k !== 'cine_user_uuid');\n\n            // [Update] Get User Context to scope the new keys in IDB\n            // We perform the scoping manually here because we are writing directly to the IDB driver\n            // via StorageRepository (which now scopes), OR we use the adapter directly?\n            // Wait, StorageRepository.setItem NOW uses UserContext.\n            // But MigrationService has `new IndexedDBAdapter()`.\n            // If we use adapter directly, we must manually scope.\n            // Let's use the `userContext` helper.\n\n            let userContext;\n            try {\n                userContext = await this.loadUserContext();\n            } catch (importError) {\n                console.error('[MigrationService] Failed to load UserContext for scoping. Aborting migration to prevent data loss.', importError);\n                // We must abort if we can't scope correctly, otherwise we write unscoped data to IDB which V2 won't see.\n                return false;\n            }\n\n            for (const key of keysToMigrate) {\n                try {\n                    const value = await this.localStorage.getItem(key);\n                    if (value !== null) {\n                        // Scope the key for the IDB destination\n                        const scopedKey = userContext.getScopedKey(key);\n                        await this.indexedDB.setItem(scopedKey, value);\n                        console.log(`[MigrationService] Migrated key: ${key} -> ${scopedKey}`);\n                    }\n                } catch (itemError) {\n                    console.error(`[MigrationService] Failed to migrate key: ${key}`, itemError);\n                    // We continue migration even if one key fails, but we should probably alert the user in a real app.\n                    // For now, robust logging is key.\n                }\n            }\n\n            await this.markAsMigrated();\n            console.log('[MigrationService] Migration complete. IndexedDB is now the primary storage.');\n            return true;\n\n        } catch (e) {\n            console.error('[MigrationService] Critical migration failure:', e);\n            return false; // Safely fail, app will continue using whatever repo is set (default LocalStorage)\n        }\n    }\n\n    async markAsMigrated() {\n        // We set the flag in BOTH storages for safety.\n        // We use a robust approach: try both, log errors, but don't fail the operation\n        // if at least one succeeds (or even if both fail, we might want to continue, but let's try best effort).\n        const setSafely = async (adapter, name) => {\n            try {\n                await adapter.setItem(MIGRATION_FLAG_KEY, 'true');\n            } catch (e) {\n                console.warn(`[MigrationService] Failed to set migration flag in ${name}:`, e);\n            }\n        };\n\n        await Promise.all([\n            setSafely(this.localStorage, 'LocalStorage'),\n            setSafely(this.indexedDB, 'IndexedDB')\n        ]);\n    }\n\n    /**\n     * Loads the UserContext instance for key scoping during migration.\n     * @returns {Promise<import('../core/UserContext.js').UserContext>}\n     */\n    async loadUserContext() {\n        const module = await import('../core/UserContext.js');\n        const userContext = module.userContext;\n        if (!userContext) {\n            throw new Error('UserContext module loaded but userContext export is missing');\n        }\n        userContext.init(); // Ensure user ID exists\n        return userContext;\n    }\n\n    /**\n     * Checks if the migration flag is set in either storage.\n     * @returns {Promise<boolean>}\n     */\n    async isMigrated() {\n        try {\n            // Check LocalStorage first (faster)\n            const lsFlag = await this.localStorage.getItem(MIGRATION_FLAG_KEY);\n            if (lsFlag === 'true') return true;\n\n            // Fallback: Check IndexedDB (in case LS was wiped but IDB persists)\n            const idbFlag = await this.indexedDB.getItem(MIGRATION_FLAG_KEY);\n            return idbFlag === 'true';\n        } catch (e) {\n            console.warn('[MigrationService] Failed to check migration status:', e);\n            return false;\n        }\n    }\n}\n\nexport const migrationService = new StorageMigrationService();\n","import { storageRepo } from '../storage/StorageRepository.js';\n\nconst OWN_GEAR_KEY = 'cameraPowerPlanner_ownGear';\n\n/**\n * @class GearRepository\n * Unifies access to built-in device library and user's \"Own Gear\".\n * Migrates \"Own Gear\" to IndexedDB/StorageRepository.\n */\nclass GearRepository {\n    constructor() {\n        this.memoryCache = null;\n    }\n\n    /**\n     * Loads user-defined gear.\n     * Uses the central StorageRepository (which now uses IndexedDB).\n     * @returns {Promise<Array>}\n     */\n    async getOwnGear() {\n        if (this.memoryCache) return this.memoryCache;\n\n        try {\n            const data = await storageRepo.getItem(OWN_GEAR_KEY);\n\n            // Normalize data structure\n            // Format: { items: [...] } or [...]\n            if (!data) return [];\n\n            if (Array.isArray(data)) {\n                this.memoryCache = data;\n            } else if (data.items && Array.isArray(data.items)) {\n                this.memoryCache = data.items;\n            } else {\n                this.memoryCache = [];\n            }\n        } catch (e) {\n            console.warn('[GearRepository] Failed to load own gear:', e);\n            this.memoryCache = [];\n        }\n\n        return this.memoryCache;\n    }\n\n    /**\n     * Saves user-defined gear.\n     * @param {Array} items \n     */\n    async saveOwnGear(items) {\n        if (!Array.isArray(items)) {\n            console.error('[GearRepository] saveOwnGear expects an array');\n            return;\n        }\n\n        this.memoryCache = items;\n\n        // Wrap in object if needed or store as array.\n        // Legacy storage used { items: [...] } sometimes, but let's standardize.\n        // However, to keep compatibility with old JSON format, maybe stick to array if that's what was used.\n        // storage.js used to store it as entries directly or wrapped.\n        // Let's store as is.\n        await storageRepo.setItem(OWN_GEAR_KEY, items);\n    }\n\n    /**\n     * Add a single item to own gear.\n     * @param {Object} item \n     */\n    async addOwnGearItem(item) {\n        const items = await this.getOwnGear();\n        items.push(item);\n        await this.saveOwnGear(items);\n    }\n\n    /**\n   * Returns the static global device library.\n   * Assumes global object 'deviceLibrary' exists (loaded via script).\n   * @returns {Object}\n   */\n    getLibrary() {\n        if (typeof window !== 'undefined' && window.deviceLibrary) {\n            return window.deviceLibrary;\n        }\n        if (typeof globalThis !== 'undefined' && globalThis.deviceLibrary) {\n            return globalThis.deviceLibrary;\n        }\n        return {};\n    }\n\n    /**\n     * Unified search for gear.\n     * Searches both static library and own gear.\n     * @param {string} query \n     * @returns {Promise<Array>}\n     */\n    async searchGear(query) {\n        if (!query) return [];\n        const q = query.toLowerCase();\n\n        // 1. Search Own Gear\n        const ownGear = await this.getOwnGear();\n        const ownMatches = ownGear.filter(item =>\n            (item.name && item.name.toLowerCase().includes(q)) ||\n            (item.brand && item.brand.toLowerCase().includes(q))\n        );\n\n        // 2. Search Static Library\n        // This requires traversing the complex deviceLibrary object structure\n        // We'll skip deep traversal for now as V1 had specific search logic we might want to reuse.\n        // For now, returning ownMatches is a good start.\n\n        return ownMatches;\n    }\n}\n\nexport const gearRepo = new GearRepository();\n","/**\n * @class DataVault\n * Manages long-term file storage using the Origin Private File System (OPFS).\n * Provides a \"Vault\" for immutable checkpoints and backups.\n */\nexport class DataVault {\n    constructor() {\n        this.root = null;\n        this.initialized = false;\n    }\n\n    async init() {\n        if (this.initialized) return;\n        try {\n            if (!navigator.storage || !navigator.storage.getDirectory) {\n                console.warn('[DataVault] OPFS is not supported in this browser.');\n                return;\n            }\n            this.root = await navigator.storage.getDirectory();\n            this.initialized = true;\n        } catch (e) {\n            console.error('[DataVault] Failed to initialize OPFS:', e);\n        }\n    }\n\n    /**\n     * Saves a project snapshot to the vault.\n     * @param {string} filename \n     * @param {Object} data \n     */\n    async saveSnapshot(filename, data) {\n        if (!this.initialized) await this.init();\n        if (!this.root) throw new Error('OPFS not available');\n\n        try {\n            // Sanitize filename to strict alphanumeric + safe chars to avoid path separators\n            const safeFilename = filename.replace(/[^a-z0-9_\\-\\.\\s]/gi, '_');\n            const fileHandle = await this.root.getFileHandle(safeFilename + '.json', { create: true });\n\n            // Create a writable stream\n            const writable = await fileHandle.createWritable();\n\n            // Write data (JSON stringified)\n            await writable.write(JSON.stringify(data));\n\n            // Close the file\n            await writable.close();\n\n            console.log(`[DataVault] Saved snapshot: ${filename}`);\n            return true;\n        } catch (e) {\n            console.error(`[DataVault] Failed to save snapshot ${filename}:`, e);\n            throw e;\n        }\n    }\n\n    /**\n     * Lists all available snapshots in the vault.\n     * @returns {Promise<string[]>} List of filenames\n     */\n    async listSnapshots() {\n        if (!this.initialized) await this.init();\n        if (!this.root) return [];\n\n        const files = [];\n        try {\n            // Iterate over entries\n            // Note: OPFS iteration syntax varies slightly by browser, but standard is async iterator\n            for await (const [name, handle] of this.root.entries()) {\n                if (handle.kind === 'file' && name.endsWith('.json')) {\n                    files.push(name);\n                }\n            }\n        } catch (e) {\n            console.error('[DataVault] Failed to list snapshots:', e);\n        }\n        return files.sort().reverse(); // Newest first (assuming timestamped names)\n    }\n\n    /**\n     * Reads a snapshot from the vault.\n     * @param {string} filename \n     * @returns {Promise<Object>} The parsed data\n     */\n    async restoreSnapshot(filename) {\n        if (!this.initialized) await this.init();\n        if (!this.root) throw new Error('OPFS not available');\n\n        try {\n            const fileHandle = await this.root.getFileHandle(filename);\n            const file = await fileHandle.getFile();\n            const text = await file.text();\n            return JSON.parse(text);\n        } catch (e) {\n            console.error(`[DataVault] Failed to restore snapshot ${filename}:`, e);\n            throw e;\n        }\n    }\n\n    /**\n     * Deletes a snapshot.\n     * @param {string} filename \n     */\n    async deleteSnapshot(filename) {\n        if (!this.initialized) await this.init();\n        if (!this.root) return;\n\n        try {\n            await this.root.removeEntry(filename);\n            console.log(`[DataVault] Deleted snapshot: ${filename}`);\n        } catch (e) {\n            console.warn(`[DataVault] Failed to delete snapshot ${filename}:`, e);\n        }\n    }\n\n    /**\n     * Wipes the entire vault (Factory Reset).\n     */\n    async clear() {\n        if (!this.initialized) await this.init();\n        if (!this.root) return;\n\n        try {\n            const files = await this.listSnapshots();\n            for (const file of files) {\n                await this.root.removeEntry(file);\n            }\n            console.log('[DataVault] All data wiped.');\n        } catch (e) {\n            console.error('[DataVault] Failed to wipe vault:', e);\n        }\n    }\n}\n\nexport const dataVault = new DataVault();\n","\n/**\n * Cine Power Planner - Storage Orchestration\n * \n * This module manages all persistence operations, project indexing, and data backups.\n * It implements a hybrid architecture:\n * 1. Synchronous Memory Cache: For near-instant reads and Auto-Gear compatibility.\n * 2. Asynchronous Storage Drivers: Leveraging LocalStorage (legacy) and IndexedDB (modern).\n * 3. Cross-Tab Coordination: synchronizing state across multiple open tabs via BroadcastChannel.\n * \n * The module also handles the critical migration path from monolithic LocalStorage \n * to granular IndexedDB shards to ensure no data loss during application updates.\n */\nconsole.log('DEBUG: storage.js execution started');\n// storage.js - Handles reading from and writing to localStorage.\nimport * as consoleHelpersImport from './console-helpers.js';\nimport loggingResolverImport from './modules/logging-resolver.js';\nimport contactsModuleImport from './modules/features/contacts.js';\nimport { storageRepo } from './modules/storage/StorageRepository.js';\nimport { migrationService } from './modules/storage/StorageMigrationService.js';\nimport IndexedDBAdapter from './modules/storage/drivers/IndexedDBAdapter.js';\nimport { gearRepo } from './modules/gear/GearRepository.js';\nimport { userContext } from './modules/core/UserContext.js';\nimport { dataVault } from './modules/storage/DataVault.js';\n\nimport LZString from 'lz-string';\n\n// [Refactor] In-Memory Cache for Synchronous Read Capability (Hybrid IDB)\nlet projectMemoryCache = {};\nlet isProjectCacheHydrated = false;\n\n// Helper to hydrate cache from StorageRepository\n/**\n * Synchronous Project Cache Hydration\n * \n * RATIONALE: Certain application features (like Auto-Gear) require synchronous \n * access to project data. Since modern storage (IndexedDB) is inherently asynchronous, \n * we hydrate an in-memory cache on startup to provide the necessary performance \n * and compatibility guarantees.\n */\nasync function hydrateProjectCache() {\n  if (isProjectCacheHydrated) return;\n  console.log('[storage.js] Hydrating project cache from storage...');\n\n  try {\n    const projectKeys =\n      storageRepo && typeof storageRepo.getProjectKeys === 'function'\n        ? await storageRepo.getProjectKeys()\n        : [];\n    // [Agent Implementation] Actual Hydration Logic with Deterministic Ordering (Monolith First -> Shards Overwrite)\n    const monolithKey = 'cameraPowerPlanner_project';\n    let monolithValue = null;\n    const shardKeys = projectKeys.slice();\n\n    if (storageRepo && typeof storageRepo.getItem === 'function') {\n      const rawIndex = await storageRepo.getItem(PROJECT_INDEX_KEY);\n      const normalizedIndex = normalizeProjectIndexForCache(rawIndex);\n      if (normalizedIndex) {\n        projectIndexCache = normalizedIndex;\n      }\n\n      // Intentionally non-blocking cache warm-ups for synchronous reads; hydration continues in the background.\n      storageRepo.getItem(AUTO_GEAR_MONITOR_DEFAULTS_STORAGE_KEY).then(val => { if (val) autoGearMonitorDefaultsCache = val; });\n      storageRepo.getItem(AUTO_GEAR_ACTIVE_PRESET_STORAGE_KEY).then(val => { if (val) autoGearActivePresetIdCache = val; });\n      storageRepo.getItem(AUTO_GEAR_AUTO_PRESET_STORAGE_KEY).then(val => { if (val) autoGearAutoPresetIdCache = val; });\n      storageRepo.getItem(AUTO_GEAR_BACKUPS_STORAGE_KEY).then(val => {\n        if (Array.isArray(val)) {\n          autoGearBackupsCache = val;\n        }\n      });\n      storageRepo.getItem(AUTO_GEAR_BACKUP_RETENTION_STORAGE_KEY).then(val => { if (val) autoGearBackupRetentionCache = val; });\n      storageRepo.getItem(AUTO_GEAR_BACKUP_VISIBILITY_STORAGE_KEY).then(val => { if (val) autoGearBackupVisibilityCache = val; });\n      storageRepo.getItem(CUSTOM_FONT_STORAGE_KEY_DEFAULT).then(val => { if (val) customFontsCache = val; });\n      storageRepo.getItem(CUSTOM_LOGO_STORAGE_KEY).then(val => { if (val) customLogoCache = val; });\n      storageRepo.getItem(CAMERA_COLOR_STORAGE_KEY).then(val => { if (val) cameraColorsCache = val; });\n      storageRepo.getItem(PRINT_PREFERENCES_STORAGE_KEY).then(val => { if (val) printPreferencesCache = val; });\n      storageRepo.getItem(CONTACTS_STORAGE_KEY).then(val => { if (val) contactsCache = val; });\n      storageRepo.getItem(OWN_GEAR_STORAGE_KEY).then(val => { if (val) ownGearCache = val; });\n      storageRepo.getItem(USER_PROFILE_STORAGE_KEY).then(val => { if (val) userProfileCache = val; });\n      storageRepo.getItem(FAVORITES_STORAGE_KEY).then(val => { if (val) favoritesCache = val; });\n      storageRepo.getItem(TEMPERATURE_UNIT_STORAGE_KEY_NAME).then(val => { if (val) temperatureUnitCache = val; });\n      storageRepo.getItem(FOCUS_SCALE_STORAGE_KEY_NAME).then(val => { if (val) focusScaleCache = val; });\n      storageRepo.getItem(getMountVoltageStorageKeyName()).then(val => { if (val) mountVoltagesCache = val; });\n      storageRepo.getItem(FULL_BACKUP_HISTORY_STORAGE_KEY).then(val => { if (val) fullBackupHistoryCache = val; });\n\n      monolithValue = await storageRepo.getItem(monolithKey);\n    }\n\n    // 1. Load Monolith (if exists)\n    if (monolithValue && typeof monolithValue === 'object') {\n      try {\n        Object.assign(projectMemoryCache, monolithValue);\n      } catch (monoErr) {\n        console.warn('[hydrate] Failed to load monolith', monoErr);\n      }\n    }\n\n    // 2. Load Shards (Parallel) - Overwrites monolith entries if collision\n    const shardPromises = shardKeys.map(async (key) => {\n      try {\n        const val = await storageRepo.loadProjectRaw(key);\n        if (val) {\n          projectMemoryCache[key] = val;\n        }\n      } catch (shardErr) {\n        console.warn('[hydrate] Failed to load shard', key, shardErr);\n      }\n    });\n\n    await Promise.all(shardPromises);\n    isProjectCacheHydrated = true;\n    console.log('[storage.js] Project cache hydrated. Keys:', Object.keys(projectMemoryCache).length);\n  } catch (e) {\n    console.warn('Cache hydration failed', e);\n  }\n}\n\n// (function initializeStorageModule() {\n\nconst GLOBAL_SCOPE =\n\n\n  typeof globalThis !== 'undefined'\n    ? globalThis\n    : typeof window !== 'undefined'\n      ? window\n      : typeof global !== 'undefined'\n        ? global\n        : typeof self !== 'undefined'\n          ? self\n          : null;\n\n// Test suites and certain recovery tools need a way to force the storage\n// module to rebuild itself. This flag lets those callers opt-in without\n// impacting normal user sessions.\nconst FORCE_STORAGE_REINITIALIZE =\n  typeof process !== 'undefined' &&\n  process &&\n  process.env &&\n  (process.env.JEST_WORKER_ID || process.env.CINE_FORCE_STORAGE_REINIT);\n\n\n\nconst FACTORY_RESET_LOCK_KEY = 'cine_factory_reset_lock';\n\n\nif (GLOBAL_SCOPE && GLOBAL_SCOPE.__cineStorageInitialized) {\n  if (FORCE_STORAGE_REINITIALIZE) {\n    try {\n      delete GLOBAL_SCOPE.__cineStorageInitialized;\n    } catch (resetInitFlagError) {\n      GLOBAL_SCOPE.__cineStorageInitialized = false;\n      void resetInitFlagError;\n    }\n\n    try {\n      delete GLOBAL_SCOPE.__cineStorageApi;\n    } catch (resetApiError) {\n      GLOBAL_SCOPE.__cineStorageApi = null;\n      void resetApiError;\n    }\n\n    try {\n      delete GLOBAL_SCOPE.__cineMonolithicProjectCleanupDone;\n    } catch (resetCleanupFlagError) {\n      GLOBAL_SCOPE.__cineMonolithicProjectCleanupDone = false;\n      void resetCleanupFlagError;\n    }\n  } else {\n    if (\n      typeof module !== 'undefined' &&\n      module.exports &&\n      GLOBAL_SCOPE.__cineStorageApi &&\n      typeof GLOBAL_SCOPE.__cineStorageApi === 'object'\n    ) {\n      module.exports = GLOBAL_SCOPE.__cineStorageApi;\n    }\n    // ESM: Cannot use top-level return, so we set a flag to skip main logic\n\n  }\n}\n\n// [Added by Agent] Lifecycle channel for cross-tab coordination\n/**\n * Lifecycle Channel (Cross-Tab Coordination)\n * \n * RATIONALE: To ensure a consistent user experience when multiple tabs are open, \n * this channel broadcasts critical events like factory resets or project changes. \n * This prevents data corruption and ensures that all instances of the app \n * reflect the same underlying state.\n */\nconst LIFECYCLE_CHANNEL_NAME = 'cine-power-planner-lifecycle';\nlet lifecycleChannel = null;\nconst isJestWorker = typeof process !== 'undefined' && process && process.env && process.env.JEST_WORKER_ID;\nif (typeof BroadcastChannel !== 'undefined' && !isJestWorker) {\n  try {\n    lifecycleChannel = new BroadcastChannel(LIFECYCLE_CHANNEL_NAME);\n    if (lifecycleChannel) {\n      lifecycleChannel.onmessage = (event) => {\n        if (event && event.data === 'factory-reset') {\n          if (GLOBAL_SCOPE) {\n            GLOBAL_SCOPE.__cameraPowerPlannerFactoryResetting = true;\n            try {\n              if (typeof sessionStorage !== 'undefined') {\n                sessionStorage.setItem(FACTORY_RESET_LOCK_KEY, 'true');\n              }\n              if (typeof localStorage !== 'undefined') {\n                localStorage.setItem(FACTORY_RESET_LOCK_KEY, 'true');\n              }\n            } catch (lockError) {\n              void lockError;\n            }\n            // Clear session storage locally before reload to ensure it doesn't survive\n            // since page reload alone might preserve it in some browsers.\n            if (typeof sessionStorage !== 'undefined' && typeof sessionStorage.clear === 'function') {\n              try {\n                // We must preserve the lock key if we just set it\n                const lockValue = sessionStorage.getItem(FACTORY_RESET_LOCK_KEY);\n                sessionStorage.clear();\n                if (lockValue) {\n                  sessionStorage.setItem(FACTORY_RESET_LOCK_KEY, lockValue);\n                }\n              } catch (e) {\n                void e;\n              }\n            }\n            if (typeof GLOBAL_SCOPE.location !== 'undefined' && typeof GLOBAL_SCOPE.location.reload === 'function') {\n              GLOBAL_SCOPE.location.reload();\n            }\n          }\n        } else if (event.data === 'project-shards-changed') {\n          invalidateProjectReadCache();\n        }\n      };\n    }\n  } catch (channelError) {\n    // BroadcastChannel might be restricted in some environments\n    void channelError;\n  }\n}\n\nif (GLOBAL_SCOPE) {\n  try {\n    // Clear any lingering factory reset lock on initialization\n    const scopeList = [\n      typeof window !== 'undefined' ? window : null,\n      typeof sessionStorage !== 'undefined' ? sessionStorage : null,\n      typeof localStorage !== 'undefined' ? localStorage : null\n    ];\n\n    // [Agent Change] Check if we are freshly returning from a factory reset.\n    // We set a flag so that loadJSONFromStorage knows to skip backup recovery\n    // for this session, allowing a clean slate.\n    let justReset = false;\n    scopeList.forEach(s => {\n      if (s && typeof s.getItem === 'function') {\n        try {\n          if (s.getItem(FACTORY_RESET_LOCK_KEY)) justReset = true;\n        } catch (e) { void e; }\n      }\n    });\n    if (justReset) {\n      GLOBAL_SCOPE.__cineJustFactoryReset = true;\n    }\n\n    scopeList.forEach(s => {\n      if (s && typeof s.removeItem === 'function') {\n        try { s.removeItem(FACTORY_RESET_LOCK_KEY); } catch (e) { void e; }\n      }\n    });\n\n    Object.defineProperty(GLOBAL_SCOPE, '__cineStorageInitialized', {\n      configurable: true,\n      writable: true,\n      value: true,\n    });\n\n    /**\n     * Storage Migration and Driver Initialization\n     * \n     * RATIONALE: We fire the migration asynchronously to avoid blocking the main \n     * thread during UI boot. The StorageRepository defaults to LocalStorage \n     * for immediate availability, then upgrades to IndexedDB once the migration \n     * (the \"sharding\" process) is safely completed.\n     */\n    (async () => {\n      try {\n        let shouldHydrateProjectCache = false;\n        if (migrationService && typeof migrationService.runMigrationIfNeeded === 'function') {\n          const migrated = await migrationService.runMigrationIfNeeded();\n          const isNative = await migrationService.isMigrated();\n          if (migrated || isNative) {\n            if (migrated) console.log('[storage.js] Migration successful. Switching to IndexedDB.');\n            else console.log('[storage.js] Native IndexedDB mode active.');\n\n            await storageRepo.switchDriver(new IndexedDBAdapter());\n            shouldHydrateProjectCache = true;\n          }\n        } else if (migrationService && typeof migrationService.init === 'function') {\n          // Fallback for V2 init method\n          const migrated = await migrationService.init();\n          // We can try to guess if we should be native here too, but legacy service might lack isMigrated\n          let isNative = false;\n          if (typeof migrationService.isMigrated === 'function') {\n            isNative = await migrationService.isMigrated();\n          }\n\n          if (migrated || isNative) {\n            await storageRepo.switchDriver(new IndexedDBAdapter());\n            shouldHydrateProjectCache = true;\n          }\n        }\n\n        const prefixMigrationOutcome = await migrateProjectKeyPrefixOnStartup();\n\n        if (shouldHydrateProjectCache) {\n          await hydrateProjectCache();\n          if (\n            (!prefixMigrationOutcome.hasIndex || !projectIndexCache)\n            && isProjectCacheHydrated\n            && projectMemoryCache\n            && Object.keys(projectMemoryCache).length > 0\n          ) {\n            try {\n              updateProjectIndex(projectMemoryCache, getSafeLocalStorage());\n            } catch (indexRefreshError) {\n              console.warn('Failed to refresh project index after migration', indexRefreshError);\n            }\n          }\n        }\n      } catch (migrationError) {\n        console.warn('[storage.js] Migration service failed:', migrationError);\n      }\n    })();\n\n  } catch (storageInitFlagError) {\n    GLOBAL_SCOPE.__cineStorageInitialized = true;\n    void storageInitFlagError;\n  }\n}\n\n// [Added by Agent] Expose a teardown method for tests to close the channel\n// and allow the process to exit cleanly.\nfunction closeStorageLifecycle() {\n  if (lifecycleChannel) {\n    try {\n      lifecycleChannel.close();\n    } catch (closeError) {\n      void closeError;\n    }\n    lifecycleChannel = null;\n  }\n}\n// Export it if we are in a testing environment (implied by module.exports existence)\nif (typeof module !== 'undefined' && module.exports) {\n  module.exports.closeStorageLifecycle = closeStorageLifecycle;\n  module.exports.hydrateProjectCache = hydrateProjectCache;\n  module.exports.__resetProjectMemoryCache = () => {\n    projectMemoryCache = {};\n    isProjectCacheHydrated = false;\n  };\n}\n\n// Perform a defensive deep clone that keeps us safe even when the runtime\n// does not provide a structured clone implementation. JSON serialization is\n// attempted first, but this manual path is the resilient safety net that\n// prevents backup/restore data from being mutated when serialization fails.\nfunction storageManualDeepClone(value, references) {\n  if (value === null || typeof value !== 'object') {\n    return value;\n  }\n\n  let referenceStore = references;\n  if (!referenceStore) {\n    referenceStore =\n      typeof WeakMap === 'function'\n        ? new WeakMap()\n        : [];\n  }\n\n  if (typeof referenceStore.has === 'function' && typeof referenceStore.get === 'function') {\n    if (referenceStore.has(value)) {\n      return referenceStore.get(value);\n    }\n  } else if (Array.isArray(referenceStore)) {\n    for (let index = 0; index < referenceStore.length; index += 1) {\n      const entry = referenceStore[index];\n      if (entry && entry[0] === value) {\n        return entry[1];\n      }\n    }\n  }\n\n  const valueTag = Object.prototype.toString.call(value);\n  if (valueTag === '[object Date]') {\n    let clonedDate;\n    try {\n      const timeValue = typeof value.getTime === 'function' ? value.getTime() : value.valueOf();\n      clonedDate = new Date(timeValue);\n    } catch (dateCloneError) {\n      clonedDate = new Date(value);\n      void dateCloneError;\n    }\n\n    if (typeof referenceStore.set === 'function') {\n      referenceStore.set(value, clonedDate);\n    } else if (Array.isArray(referenceStore)) {\n      referenceStore.push([value, clonedDate]);\n    }\n\n    return clonedDate;\n  }\n\n  const clone = Array.isArray(value) ? [] : {};\n\n  if (typeof referenceStore.set === 'function') {\n    referenceStore.set(value, clone);\n  } else if (Array.isArray(referenceStore)) {\n    referenceStore.push([value, clone]);\n  }\n\n  if (Array.isArray(value)) {\n    for (let index = 0; index < value.length; index += 1) {\n      clone[index] = storageManualDeepClone(value[index], referenceStore);\n    }\n  } else {\n    const keys = Object.keys(value);\n    for (let index = 0; index < keys.length; index += 1) {\n      const key = keys[index];\n      clone[key] = storageManualDeepClone(value[key], referenceStore);\n    }\n  }\n\n  return clone;\n}\n\n// Try to clone via JSON first so we get predictable behaviour when the data\n// is serializable. If that throws, we fall back to the manual deep clone to\n// keep user backups and restore payloads protected from mutation.\nfunction storageJsonDeepClone(value) {\n  if (value === null || typeof value !== 'object') {\n    return value;\n  }\n\n  try {\n    return JSON.parse(JSON.stringify(value));\n  } catch (jsonCloneError) {\n    void jsonCloneError;\n  }\n\n  return storageManualDeepClone(value, null);\n}\n\n// Try to locate a built-in structuredClone implementation on whichever\n// runtime we are executing in. This is intentionally exhaustive because the\n// application must behave identically in browsers, service workers and\n// automated test environments.\nfunction storageResolveStructuredClone(scope) {\n  if (typeof structuredClone === 'function') {\n    return structuredClone;\n  }\n\n  if (scope && typeof scope.structuredClone === 'function') {\n    try {\n      return scope.structuredClone.bind(scope);\n    } catch (bindError) {\n      void bindError;\n    }\n  }\n\n  /* REMOVED node:util require for ESM\n  if (typeof require === 'function') {\n    try {\n      const nodeUtil = require('node:util');\n      if (nodeUtil && typeof nodeUtil.structuredClone === 'function') {\n        return nodeUtil.structuredClone.bind(nodeUtil);\n      }\n    } catch (nodeUtilError) {\n      void nodeUtilError;\n    }\n \n    try {\n      const legacyUtil = require('util');\n      if (legacyUtil && typeof legacyUtil.structuredClone === 'function') {\n        return legacyUtil.structuredClone.bind(legacyUtil);\n      }\n    } catch (legacyUtilError) {\n      void legacyUtilError;\n    }\n  }\n  */\n\n  return null;\n}\n\n// Wrap the structuredClone implementation in a safety net. If the platform\n// throws (for example because of cloning functions), we gracefully fall back\n// to the JSON based strategy so that persistence keeps working.\nfunction storageCreateResilientDeepClone(scope) {\n  const structuredCloneImpl = storageResolveStructuredClone(scope);\n\n  if (!structuredCloneImpl) {\n    return storageJsonDeepClone;\n  }\n\n  /**\n   * Resilient Deep Clone Strategy\n   * \n   * RATIONALE: Persistence operations frequently involve creating snapshots of large \n   * project objects. To prevent accidental mutations of shared state, we use a \n   * resilient cloning strategy that prioritizes native structuredClone, \n   * falls back to JSON serialization, and finally uses a manual deep clone for \n   * complex objects that cannot be normally serialized.\n   */\n  return function storageResilientDeepClone(value) {\n    if (value === null || typeof value !== 'object') {\n      return value;\n    }\n\n    try {\n      return structuredCloneImpl(value);\n    } catch (structuredCloneError) {\n      void structuredCloneError;\n    }\n\n    return storageJsonDeepClone(value);\n  };\n}\n\nconst STORAGE_DEEP_CLONE =\n  GLOBAL_SCOPE && typeof GLOBAL_SCOPE.__cineDeepClone === 'function'\n    ? GLOBAL_SCOPE.__cineDeepClone\n    : storageCreateResilientDeepClone(GLOBAL_SCOPE);\n\n// Track sessionStorage instances we have already vetted. This allows us to\n// reuse safe handles even when multiple windows or execution contexts are\n// interacting with the planner simultaneously.\nconst knownSessionStorages =\n  typeof WeakSet === 'function' ? new WeakSet() : null;\n\n// Register a sessionStorage reference that we know is safe to use. The\n// WeakSet ensures we do not keep windows alive longer than necessary.\nfunction registerKnownSessionStorage(storage) {\n  if (\n    !knownSessionStorages\n    || typeof knownSessionStorages.add !== 'function'\n    || !storage\n  ) {\n    return;\n  }\n\n  try {\n    knownSessionStorages.add(storage);\n  } catch (error) {\n    void error;\n  }\n}\n\n// Resolve the sessionStorage object from a candidate scope while silently\n// handling cross-origin access errors. We prefer returning null over\n// throwing so that autosave logic can continue without interruption.\nfunction resolveSessionStorageFromScope(scope) {\n  if (!scope || (typeof scope !== 'object' && typeof scope !== 'function')) {\n    return null;\n  }\n\n  try {\n    const candidate = scope.sessionStorage;\n    if (candidate && typeof candidate.getItem === 'function') {\n      return candidate;\n    }\n  } catch (error) {\n    void error;\n  }\n\n  return null;\n}\n\n// Attempt to discover sessionStorage references across all known scopes once\n// during module initialisation. This keeps read/write operations snappy later\n// on and avoids repeated try/catch cost when autosave is active.\n(function primeSessionStorageCandidates() {\n  const scopes = [\n    GLOBAL_SCOPE,\n    GLOBAL_SCOPE && GLOBAL_SCOPE.window ? GLOBAL_SCOPE.window : null,\n    GLOBAL_SCOPE && GLOBAL_SCOPE.__cineGlobal\n      ? GLOBAL_SCOPE.__cineGlobal\n      : null,\n    typeof window !== 'undefined' ? window : null,\n    typeof self !== 'undefined' ? self : null,\n    typeof global !== 'undefined' ? global : null,\n  ];\n\n  for (let index = 0; index < scopes.length; index += 1) {\n    const candidate = resolveSessionStorageFromScope(scopes[index]);\n    if (candidate) {\n      registerKnownSessionStorage(candidate);\n    }\n  }\n\n  if (typeof sessionStorage !== 'undefined') {\n    try {\n      registerKnownSessionStorage(sessionStorage);\n    } catch (error) {\n      void error;\n    }\n  }\n})();\n\nfunction resolveLocalStorageFromScope(scope) {\n  if (!scope || (typeof scope !== 'object' && typeof scope !== 'function')) {\n    return null;\n  }\n\n  try {\n    const candidate = scope.localStorage;\n    if (candidate && typeof candidate.getItem === 'function') {\n      return candidate;\n    }\n  } catch (error) {\n    void error;\n  }\n\n  return null;\n}\n\nfunction collectLocalStorageCandidates() {\n  const scopes = [\n    GLOBAL_SCOPE,\n    GLOBAL_SCOPE && GLOBAL_SCOPE.window ? GLOBAL_SCOPE.window : null,\n    GLOBAL_SCOPE && GLOBAL_SCOPE.__cineGlobal ? GLOBAL_SCOPE.__cineGlobal : null,\n    typeof window !== 'undefined' ? window : null,\n    typeof globalThis !== 'undefined' ? globalThis : null,\n    typeof self !== 'undefined' ? self : null,\n    typeof global !== 'undefined' ? global : null,\n  ];\n\n  const candidates = [];\n  const seen = typeof WeakSet === 'function' ? new WeakSet() : null;\n\n  for (let index = 0; index < scopes.length; index += 1) {\n    const candidate = resolveLocalStorageFromScope(scopes[index]);\n    if (!candidate) {\n      continue;\n    }\n\n    if (seen) {\n      try {\n        if (seen.has(candidate)) {\n          continue;\n        }\n        seen.add(candidate);\n      } catch (error) {\n        void error;\n      }\n    } else if (candidates.indexOf(candidate) !== -1) {\n      continue;\n    }\n\n    candidates.push(candidate);\n  }\n\n  return candidates;\n}\n\nif (GLOBAL_SCOPE && typeof GLOBAL_SCOPE.__cineDeepClone !== 'function') {\n  try {\n    GLOBAL_SCOPE.__cineDeepClone = STORAGE_DEEP_CLONE;\n  } catch (storageDeepCloneError) {\n    void storageDeepCloneError;\n  }\n}\n\nfunction isFactoryResetActive() {\n  const readFlag = (scope) => {\n    if (!scope || (typeof scope !== 'object' && typeof scope !== 'function')) {\n      return false;\n    }\n    try {\n      return scope.__cameraPowerPlannerFactoryResetting === true;\n    } catch (error) {\n      void error;\n      return false;\n    }\n  };\n\n  if (readFlag(GLOBAL_SCOPE)) {\n    return true;\n  }\n\n  const fallbackScopes = [\n    typeof window !== 'undefined' ? window : null,\n    typeof self !== 'undefined' ? self : null,\n    typeof global !== 'undefined' ? global : null,\n  ];\n\n  for (let index = 0; index < fallbackScopes.length; index += 1) {\n    const scope = fallbackScopes[index];\n    if (scope && scope !== GLOBAL_SCOPE && readFlag(scope)) {\n      return true;\n    }\n  }\n\n  try {\n    if (\n      (typeof sessionStorage !== 'undefined' && sessionStorage.getItem(FACTORY_RESET_LOCK_KEY)) ||\n      (typeof localStorage !== 'undefined' && localStorage.getItem(FACTORY_RESET_LOCK_KEY))\n    ) {\n      return true;\n    }\n  } catch (storageError) {\n    void storageError;\n  }\n\n  return false;\n}\n\nvar DEVICE_STORAGE_KEY = 'cameraPowerPlanner_devices';\nvar DEVICE_STORAGE_KEY_VARIANTS = null;\nvar SETUP_STORAGE_KEY = 'cameraPowerPlanner_setups';\nvar SESSION_STATE_KEY = 'cameraPowerPlanner_session';\nvar FEEDBACK_STORAGE_KEY = 'cameraPowerPlanner_feedback';\nvar PROJECT_STORAGE_KEY = 'cameraPowerPlanner_project';\nvar PROJECT_STORAGE_REV_KEY = 'cameraPowerPlanner_project_rev';\nvar FAVORITES_STORAGE_KEY = 'cameraPowerPlanner_favorites';\nvar CONTACTS_STORAGE_KEY = 'cameraPowerPlanner_contacts';\nvar OWN_GEAR_STORAGE_KEY = 'cameraPowerPlanner_ownGear';\nvar USER_PROFILE_STORAGE_KEY = 'cameraPowerPlanner_userProfile';\nvar DOCUMENTATION_TRACKER_STORAGE_KEY = 'cameraPowerPlanner_documentationTracker';\nvar DEVICE_SCHEMA_CACHE_KEY = 'cameraPowerPlanner_schemaCache';\nvar LEGACY_SCHEMA_CACHE_KEY = 'cinePowerPlanner_schemaCache';\nvar CUSTOM_FONT_STORAGE_KEY_DEFAULT = 'cameraPowerPlanner_customFonts';\nvar MOUNT_VOLTAGE_STORAGE_KEY_FALLBACK = 'cameraPowerPlanner_mountVoltages';\nvar CAMERA_COLOR_STORAGE_KEY = 'cameraPowerPlanner_cameraColors';\nvar PRINT_PREFERENCES_STORAGE_KEY = 'cineRentalPrintSections';\nvar PROJECT_INDEX_KEY = 'cameraPowerPlanner_projectIndex';\nvar MOUNT_VOLTAGE_STORAGE_KEY_SYMBOL =\n  typeof Symbol === 'function'\n    ? Symbol.for('cinePowerPlanner.mountVoltageKey')\n    : null;\n\nvar PROJECT_STORAGE_READ_CACHE = null;\n\nvar STORAGE_CACHE_SYMBOL =\n  typeof Symbol === 'function'\n    ? Symbol.for('cinePowerPlanner.storageCache')\n    : '__cineStorageStateCache';\n\nvar PROJECT_SHARD_PREFIX = 'cameraPowerPlanner_prj_';\n\nvar STORAGE_STATE_CACHE_WEAKMAP =\n  typeof WeakMap === 'function' && typeof Map === 'function'\n    ? new WeakMap()\n    : null;\n\nvar CONTACTS_MODULE_API = null;\nvar CONTACTS_MODULE_RESOLUTION_ATTEMPTED = false;\n\nvar COMPRESSION_STRATEGY_CACHE =\n  typeof Map === 'function'\n    ? new Map()\n    : null;\nvar COMPRESSION_STRATEGY_CACHE_KEYS = [];\nvar COMPRESSION_STRATEGY_CACHE_LIMIT = 6;\nvar COMPRESSION_CANDIDATE_CACHE_MISS =\n  typeof Object.freeze === 'function'\n    ? Object.freeze({ __cineCompressionMiss: true })\n    : { __cineCompressionMiss: true };\nvar STORAGE_COMPRESSION_CANDIDATE_CACHE = createCompressionCandidateCache(8);\nvar MIGRATION_BACKUP_COMPRESSION_CANDIDATE_CACHE = createCompressionCandidateCache(6);\n\nvar AUTO_BACKUP_COMPRESSION_CACHE =\n  typeof Map === 'function'\n    ? new Map()\n    : null;\nvar AUTO_BACKUP_COMPRESSION_CACHE_KEYS = [];\nvar AUTO_BACKUP_COMPRESSION_CACHE_LIMIT = 16;\n\n// Compression payloads are reused frequently while we keep the UI responsive.\n// We clone objects before storing them so that later mutations never corrupt\n// previous snapshots.\nfunction cloneAutoBackupCompressionValue(value) {\n  if (!value || typeof value !== 'object') {\n    return value;\n  }\n\n  if (Array.isArray(value)) {\n    return value.slice();\n  }\n\n  var clone = {};\n  var keys = Object.keys(value);\n  for (var index = 0; index < keys.length; index += 1) {\n    var key = keys[index];\n    var original = value[key];\n    clone[key] = Array.isArray(original) ? original.slice() : original;\n  }\n\n  return clone;\n}\n\n// Retrieve a previously cached compression payload. Returning a shallow clone\n// protects the caller from mutating the cache entry by accident.\nfunction readAutoBackupCompressionCache(signature) {\n  if (!AUTO_BACKUP_COMPRESSION_CACHE || typeof signature !== 'string' || !signature) {\n    return null;\n  }\n\n  var cached;\n  try {\n    cached = AUTO_BACKUP_COMPRESSION_CACHE.get(signature);\n  } catch (cacheReadError) {\n    cached = null;\n    void cacheReadError;\n  }\n\n  if (!cached || !cached.payload) {\n    return null;\n  }\n\n  return {\n    payload: cloneAutoBackupCompressionValue(cached.payload),\n    compression: cached.compression\n      ? cloneAutoBackupCompressionValue(cached.compression)\n      : null,\n  };\n}\n\n// Store compression metadata for automatic backups. The cache is intentionally\n// size-limited to keep memory predictable during long offline sessions.\nfunction writeAutoBackupCompressionCache(signature, payload, compression) {\n  if (\n    !AUTO_BACKUP_COMPRESSION_CACHE\n    || typeof signature !== 'string'\n    || !signature\n    || !isCompressedAutoBackupSnapshotPayload(payload)\n  ) {\n    return;\n  }\n\n  var entry = {\n    payload: cloneAutoBackupCompressionValue(payload),\n    compression: compression ? cloneAutoBackupCompressionValue(compression) : null,\n  };\n\n  try {\n    AUTO_BACKUP_COMPRESSION_CACHE.set(signature, entry);\n  } catch (cacheStoreError) {\n    void cacheStoreError;\n    return;\n  }\n\n  var existingIndex = AUTO_BACKUP_COMPRESSION_CACHE_KEYS.indexOf(signature);\n  if (existingIndex !== -1) {\n    AUTO_BACKUP_COMPRESSION_CACHE_KEYS.splice(existingIndex, 1);\n  }\n\n  AUTO_BACKUP_COMPRESSION_CACHE_KEYS.push(signature);\n\n  while (AUTO_BACKUP_COMPRESSION_CACHE_KEYS.length > AUTO_BACKUP_COMPRESSION_CACHE_LIMIT) {\n    var oldest = AUTO_BACKUP_COMPRESSION_CACHE_KEYS.shift();\n    if (!oldest || oldest === signature) {\n      continue;\n    }\n\n    try {\n      AUTO_BACKUP_COMPRESSION_CACHE.delete(oldest);\n    } catch (cacheDeleteError) {\n      void cacheDeleteError;\n    }\n  }\n}\n\nfunction resetAutoBackupCompressionCache() {\n  if (AUTO_BACKUP_COMPRESSION_CACHE && typeof AUTO_BACKUP_COMPRESSION_CACHE.clear === 'function') {\n    try {\n      AUTO_BACKUP_COMPRESSION_CACHE.clear();\n    } catch (cacheClearError) {\n      void cacheClearError;\n    }\n  }\n\n  AUTO_BACKUP_COMPRESSION_CACHE_KEYS.length = 0;\n}\n\n// Allow unlimited compression warnings so diagnostics are never suppressed.\nvar COMPRESSION_WARNING_LIMIT = Number.POSITIVE_INFINITY;\nvar COMPRESSION_WARNING_BATCH_SIZE = 8;\nvar COMPRESSION_LOG_SUMMARY_WINDOW_MS = 60 * 1000;\nvar compressionWarningRegistry = {\n  entries: Object.create(null),\n  totalWarnings: 0,\n  suppressionNoticeShown: false,\n};\nvar ensureConsoleMethodsWritable = null;\nvar storageLoggingResolverCache = null;\nvar storageLoggerCache = null;\nvar storageLoggerResolutionAttempted = false;\nif (consoleHelpersImport && typeof consoleHelpersImport.ensureConsoleMethodsWritable === 'function') {\n  ensureConsoleMethodsWritable = consoleHelpersImport.ensureConsoleMethodsWritable;\n}\n\nvar ACTIVE_PROJECT_COMPRESSION_HOLD_KEY = '';\nvar ACTIVE_PROJECT_COMPRESSION_HOLD_ENABLED = false;\n\nif (\n  !ensureConsoleMethodsWritable\n  && GLOBAL_SCOPE\n  && typeof GLOBAL_SCOPE.__cineEnsureConsoleMethodsWritable === 'function'\n) {\n  ensureConsoleMethodsWritable = GLOBAL_SCOPE.__cineEnsureConsoleMethodsWritable;\n}\n\nif (typeof ensureConsoleMethodsWritable === 'function') {\n  ensureConsoleMethodsWritable(['warn', 'info']);\n}\n\nfunction collectStorageLoggingScopes() {\n  var scopes = [];\n\n  var enqueue = function enqueue(scope) {\n    if (!scope || (typeof scope !== 'object' && typeof scope !== 'function')) {\n      return;\n    }\n    if (scopes.indexOf(scope) === -1) {\n      scopes.push(scope);\n    }\n  };\n\n  enqueue(GLOBAL_SCOPE);\n  enqueue(typeof globalThis !== 'undefined' ? globalThis : null);\n  enqueue(typeof window !== 'undefined' ? window : null);\n  enqueue(typeof self !== 'undefined' ? self : null);\n  enqueue(typeof global !== 'undefined' ? global : null);\n\n  return scopes;\n}\n\nfunction resolveStorageLoggingResolver() {\n  if (storageLoggingResolverCache) {\n    return storageLoggingResolverCache;\n  }\n\n  if (loggingResolverImport && typeof loggingResolverImport.resolveLogger === 'function') {\n    storageLoggingResolverCache = loggingResolverImport;\n    return storageLoggingResolverCache;\n  }\n\n  var scopes = collectStorageLoggingScopes();\n  for (var index = 0; index < scopes.length; index += 1) {\n    var scope = scopes[index];\n    if (!scope || (typeof scope !== 'object' && typeof scope !== 'function')) {\n      continue;\n    }\n\n    try {\n      var resolver = scope.cineLoggingResolver;\n      if (resolver && typeof resolver.resolveLogger === 'function') {\n        storageLoggingResolverCache = resolver;\n        return storageLoggingResolverCache;\n      }\n    } catch (scopeResolverError) {\n      void scopeResolverError;\n    }\n  }\n\n  storageLoggingResolverCache = null;\n  return storageLoggingResolverCache;\n}\n\nfunction resolveStorageLogger() {\n  if (storageLoggerCache || storageLoggerResolutionAttempted) {\n    return storageLoggerCache;\n  }\n\n  storageLoggerResolutionAttempted = true;\n\n  var resolver = resolveStorageLoggingResolver();\n  if (resolver && typeof resolver.resolveLogger === 'function') {\n    try {\n      var logger = resolver.resolveLogger('storage', { meta: { source: 'storage-module' } });\n      if (logger) {\n        storageLoggerCache = logger;\n        return storageLoggerCache;\n      }\n    } catch (resolverError) {\n      void resolverError;\n    }\n  }\n\n  storageLoggerCache = null;\n  return storageLoggerCache;\n}\n\nfunction sanitizeStorageError(error) {\n  if (!error) {\n    return null;\n  }\n\n  if (typeof error === 'string') {\n    return { message: error };\n  }\n\n  var result = {};\n  if (typeof error.name === 'string' && error.name) {\n    result.name = error.name;\n  }\n  if (typeof error.message === 'string' && error.message) {\n    result.message = error.message;\n  }\n  if (typeof error.stack === 'string' && error.stack) {\n    result.stack = error.stack;\n  }\n\n  if (!Object.keys(result).length) {\n    try {\n      result.message = String(error);\n    } catch (stringifyError) {\n      void stringifyError;\n      return null;\n    }\n  }\n\n  return result;\n}\n\nfunction getActiveStorageType(storage) {\n  if (storage && typeof safeLocalStorageInfo !== 'undefined' && safeLocalStorageInfo && safeLocalStorageInfo.storage === storage) {\n    return safeLocalStorageInfo && typeof safeLocalStorageInfo.type === 'string'\n      ? safeLocalStorageInfo.type\n      : 'unknown';\n  }\n\n  if (storage && GLOBAL_SCOPE) {\n    try {\n      if (GLOBAL_SCOPE.localStorage && storage === GLOBAL_SCOPE.localStorage) {\n        return 'local';\n      }\n    } catch (localStorageCompareError) {\n      void localStorageCompareError;\n    }\n    try {\n      if (GLOBAL_SCOPE.sessionStorage && storage === GLOBAL_SCOPE.sessionStorage) {\n        return 'session';\n      }\n    } catch (sessionStorageCompareError) {\n      void sessionStorageCompareError;\n    }\n  }\n\n  if (typeof safeLocalStorageInfo !== 'undefined' && safeLocalStorageInfo && typeof safeLocalStorageInfo.type === 'string') {\n    return safeLocalStorageInfo.type;\n  }\n\n  return 'unknown';\n}\n\nfunction logStorageEvent(level, message, detail, meta, consoleCallback) {\n  var normalizedLevel = typeof level === 'string' && level ? level.toLowerCase() : 'info';\n  var normalizedMessage = typeof message === 'string' && message ? message : 'Storage event';\n  var logger = resolveStorageLogger();\n  var handled = false;\n  var resolvedMeta = { module: 'storage' };\n\n  if (meta && typeof meta === 'object') {\n    resolvedMeta = { module: 'storage' };\n    var metaKeys = Object.keys(meta);\n    for (var metaIndex = 0; metaIndex < metaKeys.length; metaIndex += 1) {\n      var metaKey = metaKeys[metaIndex];\n      resolvedMeta[metaKey] = meta[metaKey];\n    }\n  }\n\n  if (logger) {\n    if (typeof logger[normalizedLevel] === 'function') {\n      try {\n        logger[normalizedLevel](normalizedMessage, detail, resolvedMeta);\n        handled = true;\n      } catch (loggingError) {\n        handled = false;\n        void loggingError;\n      }\n    } else if (typeof logger.log === 'function') {\n      try {\n        logger.log(normalizedLevel, normalizedMessage, detail, resolvedMeta);\n        handled = true;\n      } catch (loggerLogError) {\n        handled = false;\n        void loggerLogError;\n      }\n    }\n  }\n\n  if (typeof consoleCallback === 'function') {\n    try {\n      consoleCallback();\n    } catch (consoleCallbackError) {\n      void consoleCallbackError;\n    }\n    return handled;\n  }\n\n  if (typeof console === 'undefined' || !console) {\n    return handled;\n  }\n\n  var fallback = null;\n  if (normalizedLevel === 'error' && typeof console.error === 'function') {\n    fallback = console.error;\n  } else if (normalizedLevel === 'warn' && typeof console.warn === 'function') {\n    fallback = console.warn;\n  } else if (normalizedLevel === 'info' && typeof console.info === 'function') {\n    fallback = console.info;\n  } else if (normalizedLevel === 'debug' && typeof console.debug === 'function') {\n    fallback = console.debug;\n  } else if (typeof console.log === 'function') {\n    fallback = console.log;\n  }\n\n  if (typeof fallback === 'function') {\n    try {\n      fallback.call(console, normalizedMessage, detail || null);\n    } catch (fallbackError) {\n      void fallbackError;\n    }\n  }\n\n  return handled;\n}\n\nfunction getCompressionLogTimestamp() {\n  if (typeof Date === 'undefined') {\n    return null;\n  }\n\n  if (typeof Date.now === 'function') {\n    return Date.now();\n  }\n\n  try {\n    return new Date().getTime();\n  } catch (timestampError) {\n    void timestampError;\n  }\n\n  return null;\n}\n\nfunction logCompressionSavingsEvent(kind, identifier, message, savings, percent) {\n  var entryKey = typeof kind === 'string' && kind ? kind : 'generic';\n  var keyLabel = null;\n  if (typeof identifier === 'string' && identifier) {\n    keyLabel = identifier;\n  } else if (identifier !== null && identifier !== undefined) {\n    try {\n      keyLabel = String(identifier);\n    } catch (stringifyError) {\n      keyLabel = null;\n      void stringifyError;\n    }\n  }\n\n  var detail = {\n    event: 'compression-savings',\n    kind: entryKey,\n    key: keyLabel,\n    storageType: getActiveStorageType(),\n  };\n  if (typeof savings === 'number' && Number.isFinite(savings)) {\n    detail.savings = savings;\n  }\n  if (typeof percent === 'number' && Number.isFinite(percent)) {\n    detail.percent = percent;\n  }\n\n  var consoleLogger = function logCompressionToConsole() {\n    if (typeof console === 'undefined') {\n      return;\n    }\n\n    var registry = compressionWarningRegistry;\n    var entry = registry.entries[entryKey];\n    var now = getCompressionLogTimestamp();\n\n    if (!entry) {\n      entry = {\n        kind: entryKey,\n        occurrences: 0,\n        totalSavings: 0,\n        lastPercent: null,\n        lastKey: null,\n        uniqueKeys: Object.create(null),\n        uniqueKeyCount: 0,\n        firstLoggedAt: now,\n        lastLoggedAt: now,\n        lastSummaryAt: null,\n        suppressedTotal: 0,\n        suppressedSinceSummary: 0,\n      };\n      registry.entries[entryKey] = entry;\n    }\n\n    entry.occurrences += 1;\n    entry.lastLoggedAt = now;\n    if (keyLabel) {\n      entry.lastKey = keyLabel;\n      if (!entry.uniqueKeys[keyLabel]) {\n        entry.uniqueKeys[keyLabel] = true;\n        entry.uniqueKeyCount += 1;\n      }\n    }\n\n    if (typeof savings === 'number' && Number.isFinite(savings)) {\n      entry.totalSavings += savings;\n    }\n    if (typeof percent === 'number' && Number.isFinite(percent)) {\n      entry.lastPercent = percent;\n    }\n\n    if (registry.totalWarnings < COMPRESSION_WARNING_LIMIT) {\n      if (typeof ensureConsoleMethodsWritable === 'function') {\n        ensureConsoleMethodsWritable('warn');\n      }\n      if (typeof console.warn === 'function' && message) {\n        console.warn(message);\n      }\n      registry.totalWarnings += 1;\n      return;\n    }\n\n    entry.suppressedTotal += 1;\n    entry.suppressedSinceSummary += 1;\n\n    if (!registry.suppressionNoticeShown && typeof console.info === 'function') {\n      if (typeof ensureConsoleMethodsWritable === 'function') {\n        ensureConsoleMethodsWritable('info');\n      }\n      console.info(\n        'Additional storage compression warnings are being batched to keep diagnostics readable.',\n        {\n          limit: COMPRESSION_WARNING_LIMIT,\n          batchSize: COMPRESSION_WARNING_BATCH_SIZE,\n        },\n      );\n      registry.suppressionNoticeShown = true;\n    }\n\n    var shouldSummarize = false;\n    if (!entry.lastSummaryAt) {\n      shouldSummarize = true;\n    } else if (entry.suppressedSinceSummary >= COMPRESSION_WARNING_BATCH_SIZE) {\n      shouldSummarize = true;\n    } else if (\n      now !== null &&\n      entry.lastSummaryAt !== null &&\n      entry.suppressedSinceSummary > 0 &&\n      now - entry.lastSummaryAt >= COMPRESSION_LOG_SUMMARY_WINDOW_MS\n    ) {\n      shouldSummarize = true;\n    }\n\n    if (shouldSummarize && typeof console.info === 'function') {\n      if (typeof ensureConsoleMethodsWritable === 'function') {\n        ensureConsoleMethodsWritable('info');\n      }\n      console.info('Suppressed repeated storage compression warnings.', {\n        kind: entry.kind,\n        mostRecentKey: entry.lastKey,\n        suppressedSinceSummary: entry.suppressedSinceSummary,\n        suppressedTotal: entry.suppressedTotal,\n        totalOccurrences: entry.occurrences,\n        totalSavings: entry.totalSavings,\n        lastPercent: entry.lastPercent,\n        uniqueKeys: entry.uniqueKeyCount,\n      });\n      entry.lastSummaryAt = now;\n      entry.suppressedSinceSummary = 0;\n    }\n  };\n\n  logStorageEvent('info', message, detail, { event: 'compression-savings', kind: entryKey }, consoleLogger);\n}\n\nfunction getCompressionLogSnapshot() {\n  var entries = {};\n  var keys = Object.keys(compressionWarningRegistry.entries);\n\n  for (var i = 0; i < keys.length; i += 1) {\n    var key = keys[i];\n    var source = compressionWarningRegistry.entries[key];\n    if (!source) {\n      continue;\n    }\n\n    entries[key] = {\n      kind: source.kind,\n      occurrences: source.occurrences,\n      totalSavings: source.totalSavings,\n      lastPercent: source.lastPercent,\n      lastKey: source.lastKey,\n      uniqueKeyCount: source.uniqueKeyCount,\n      firstLoggedAt: source.firstLoggedAt,\n      lastLoggedAt: source.lastLoggedAt,\n      lastSummaryAt: source.lastSummaryAt,\n      suppressedTotal: source.suppressedTotal,\n    };\n  }\n\n  return {\n    limit: COMPRESSION_WARNING_LIMIT,\n    batchSize: COMPRESSION_WARNING_BATCH_SIZE,\n    summaryWindowMs: COMPRESSION_LOG_SUMMARY_WINDOW_MS,\n    totalWarnings: compressionWarningRegistry.totalWarnings,\n    suppressionNoticeShown: compressionWarningRegistry.suppressionNoticeShown,\n    entries: entries,\n  };\n}\n\nfunction getCompressionStrategyCacheKey(variants) {\n  if (!Array.isArray(variants) || !variants.length) {\n    return null;\n  }\n\n  var segments = [];\n  for (var i = 0; i < variants.length; i += 1) {\n    var variant = variants[i] || {};\n    var name = typeof variant.variant === 'string' ? variant.variant : '';\n    var compressName = typeof variant.compress === 'string' ? variant.compress : '';\n    var decompressName = typeof variant.decompress === 'string' ? variant.decompress : '';\n    segments.push(name + ':' + compressName + ':' + decompressName);\n  }\n\n  return segments.join('|');\n}\n\nfunction readCompressionStrategyCache(cacheKey, lzReference) {\n  if (!COMPRESSION_STRATEGY_CACHE || !cacheKey) {\n    return null;\n  }\n\n  var cached;\n  try {\n    cached = COMPRESSION_STRATEGY_CACHE.get(cacheKey);\n  } catch (cacheReadError) {\n    cached = null;\n    void cacheReadError;\n  }\n\n  if (!cached || cached.lz !== lzReference) {\n    return null;\n  }\n\n  if (!Array.isArray(cached.strategies) || !cached.strategies.length) {\n    return Array.isArray(cached.strategies) ? [] : null;\n  }\n\n  return cached.strategies.slice();\n}\n\nfunction pruneCompressionStrategyCache(cacheKey) {\n  if (!COMPRESSION_STRATEGY_CACHE || !cacheKey) {\n    return;\n  }\n\n  var existingIndex = COMPRESSION_STRATEGY_CACHE_KEYS.indexOf(cacheKey);\n  if (existingIndex !== -1) {\n    COMPRESSION_STRATEGY_CACHE_KEYS.splice(existingIndex, 1);\n  }\n\n  COMPRESSION_STRATEGY_CACHE_KEYS.push(cacheKey);\n\n  while (COMPRESSION_STRATEGY_CACHE_KEYS.length > COMPRESSION_STRATEGY_CACHE_LIMIT) {\n    var oldestKey = COMPRESSION_STRATEGY_CACHE_KEYS.shift();\n    if (typeof COMPRESSION_STRATEGY_CACHE.delete === 'function') {\n      try {\n        COMPRESSION_STRATEGY_CACHE.delete(oldestKey);\n      } catch (cacheDeleteError) {\n        void cacheDeleteError;\n      }\n    }\n  }\n}\n\nfunction writeCompressionStrategyCache(cacheKey, lzReference, strategies) {\n  if (!COMPRESSION_STRATEGY_CACHE || !cacheKey) {\n    return;\n  }\n\n  var payload = {\n    lz: lzReference,\n    strategies: Array.isArray(strategies) ? strategies.slice() : [],\n  };\n\n  try {\n    COMPRESSION_STRATEGY_CACHE.set(cacheKey, payload);\n    pruneCompressionStrategyCache(cacheKey);\n  } catch (cacheStoreError) {\n    void cacheStoreError;\n  }\n}\n\nfunction computeStorageCompressionWrapperBaseLength() {\n  if (typeof JSON === 'undefined' || !JSON || typeof JSON.stringify !== 'function') {\n    return 0;\n  }\n\n  try {\n    var skeleton = {\n      [STORAGE_COMPRESSION_FLAG_KEY]: true,\n      version: STORAGE_COMPRESSION_VERSION,\n      algorithm: STORAGE_COMPRESSION_ALGORITHM,\n      namespace: STORAGE_COMPRESSION_NAMESPACE,\n      data: '',\n      originalLength: 0,\n      compressedPayloadLength: 0,\n      compressionVariant: '',\n    };\n\n    var serialized = JSON.stringify(skeleton);\n    if (typeof serialized !== 'string' || !serialized) {\n      return 0;\n    }\n\n    var emptyLiteralLength = JSON.stringify('').length;\n    if (!(emptyLiteralLength > 0)) {\n      return 0;\n    }\n\n    return serialized.length - emptyLiteralLength * 2 - String(0).length * 2;\n  } catch (wrapperLengthError) {\n    void wrapperLengthError;\n  }\n\n  return 0;\n}\n\nfunction createCompressionCandidateCache(limit) {\n  if (typeof Map !== 'function') {\n    return null;\n  }\n\n  var numericLimit = Number(limit);\n  if (!(numericLimit > 0)) {\n    return null;\n  }\n\n  return {\n    map: new Map(),\n    keys: [],\n    limit: Math.floor(numericLimit),\n  };\n}\n\nfunction cloneCompressionCandidate(candidate) {\n  if (!candidate || typeof candidate !== 'object') {\n    return null;\n  }\n\n  var clone = {};\n  var keys = Object.keys(candidate);\n  for (var i = 0; i < keys.length; i += 1) {\n    clone[keys[i]] = candidate[keys[i]];\n  }\n\n  return clone;\n}\n\nfunction touchCompressionCandidateCacheKey(cache, key) {\n  if (!cache || !Array.isArray(cache.keys)) {\n    return;\n  }\n\n  var existingIndex = cache.keys.indexOf(key);\n  if (existingIndex !== -1) {\n    cache.keys.splice(existingIndex, 1);\n  }\n\n  cache.keys.push(key);\n}\n\nfunction readCompressionCandidateCacheEntry(cache, key) {\n  if (!cache || !cache.map || typeof cache.map.get !== 'function') {\n    return { hit: false };\n  }\n\n  if (typeof key !== 'string' || !key) {\n    return { hit: false };\n  }\n\n  var entry;\n  try {\n    entry = cache.map.get(key);\n  } catch (cacheReadError) {\n    void cacheReadError;\n    return { hit: false };\n  }\n\n  if (entry === undefined) {\n    return { hit: false };\n  }\n\n  touchCompressionCandidateCacheKey(cache, key);\n\n  if (entry === COMPRESSION_CANDIDATE_CACHE_MISS) {\n    return { hit: true, candidate: null };\n  }\n\n  var cloned = cloneCompressionCandidate(entry);\n  if (!cloned) {\n    return { hit: true, candidate: null };\n  }\n\n  return { hit: true, candidate: cloned };\n}\n\nfunction writeCompressionCandidateCacheEntry(cache, key, candidate) {\n  if (!cache || !cache.map || typeof cache.map.set !== 'function') {\n    return;\n  }\n\n  if (typeof key !== 'string' || !key) {\n    return;\n  }\n\n  if (!cache.limit || cache.limit <= 0) {\n    return;\n  }\n\n  var entry = candidate && typeof candidate === 'object'\n    ? cloneCompressionCandidate(candidate)\n    : COMPRESSION_CANDIDATE_CACHE_MISS;\n\n  try {\n    cache.map.set(key, entry);\n  } catch (cacheStoreError) {\n    void cacheStoreError;\n    return;\n  }\n\n  touchCompressionCandidateCacheKey(cache, key);\n\n  while (cache.keys.length > cache.limit) {\n    var oldestKey = cache.keys.shift();\n    if (typeof oldestKey !== 'string' || oldestKey === key) {\n      continue;\n    }\n\n    try {\n      cache.map.delete(oldestKey);\n    } catch (cacheDeleteError) {\n      void cacheDeleteError;\n    }\n  }\n}\n\nfunction getStorageStateCacheMap(storage, createIfMissing) {\n  if (!storage || (typeof storage !== 'object' && typeof storage !== 'function')) {\n    return null;\n  }\n\n  let existing = null;\n  if (STORAGE_CACHE_SYMBOL) {\n    try {\n      existing = storage[STORAGE_CACHE_SYMBOL];\n    } catch (readError) {\n      existing = null;\n      void readError;\n    }\n  }\n\n  if (!existing && STORAGE_STATE_CACHE_WEAKMAP) {\n    try {\n      existing = STORAGE_STATE_CACHE_WEAKMAP.get(storage) || null;\n    } catch (weakMapReadError) {\n      existing = null;\n      void weakMapReadError;\n    }\n  }\n\n  if (existing || !createIfMissing) {\n    return existing || null;\n  }\n\n  const map = new Map();\n  let assigned = false;\n\n  if (STORAGE_CACHE_SYMBOL) {\n    try {\n      Object.defineProperty(storage, STORAGE_CACHE_SYMBOL, {\n        configurable: true,\n        writable: true,\n        value: map,\n      });\n      assigned = true;\n    } catch (defineError) {\n      void defineError;\n      try {\n        storage[STORAGE_CACHE_SYMBOL] = map;\n        assigned = true;\n      } catch (assignError) {\n        assigned = false;\n        void assignError;\n      }\n    }\n  }\n\n  if (!assigned && STORAGE_STATE_CACHE_WEAKMAP) {\n    try {\n      STORAGE_STATE_CACHE_WEAKMAP.set(storage, map);\n      assigned = true;\n    } catch (weakMapStoreError) {\n      assigned = false;\n      void weakMapStoreError;\n    }\n  }\n\n  return assigned ? map : null;\n}\n\nfunction getCachedStorageEntry(storage, key) {\n  const map = getStorageStateCacheMap(storage, false);\n  if (!map || typeof key !== 'string' || !key) {\n    return null;\n  }\n  return map.get(key) || null;\n}\n\nfunction clearCachedStorageEntry(storage, key) {\n  const map = getStorageStateCacheMap(storage, false);\n  if (!map || typeof key !== 'string' || !key) {\n    return;\n  }\n\n  if (typeof map.delete === 'function') {\n    map.delete(key);\n  }\n\n  if (map.size === 0) {\n    if (STORAGE_CACHE_SYMBOL) {\n      try {\n        if (storage && (typeof storage === 'object' || typeof storage === 'function')) {\n          if (Object.prototype.hasOwnProperty.call(storage, STORAGE_CACHE_SYMBOL)) {\n            delete storage[STORAGE_CACHE_SYMBOL];\n          }\n        }\n      } catch (clearError) {\n        void clearError;\n      }\n    }\n    if (STORAGE_STATE_CACHE_WEAKMAP) {\n      try {\n        STORAGE_STATE_CACHE_WEAKMAP.delete(storage);\n      } catch (weakMapDeleteError) {\n        void weakMapDeleteError;\n      }\n    }\n  }\n}\n\nfunction cloneValueForCache(value) {\n  if (value === null || typeof value !== 'object') {\n    return value;\n  }\n\n  try {\n    return STORAGE_DEEP_CLONE(value);\n  } catch (cloneError) {\n    void cloneError;\n  }\n\n  return value;\n}\n\nfunction cloneCachedEntryValue(entry) {\n  if (!entry) {\n    return undefined;\n  }\n\n  const { value } = entry;\n  if (value === null || typeof value !== 'object') {\n    return value;\n  }\n\n  return cloneValueForCache(value);\n}\n\nfunction cloneLookupMap(source, options) {\n  const map = new Map();\n  if (!source || typeof source.forEach !== 'function') {\n    return map;\n  }\n\n  const { freezeArray = false } = options || {};\n\n  source.forEach((value, key) => {\n    if (Array.isArray(value)) {\n      const copy = value.slice();\n      if (freezeArray) {\n        try {\n          Object.freeze(copy);\n        } catch (freezeError) {\n          void freezeError;\n        }\n      }\n      map.set(key, copy);\n    } else {\n      map.set(key, value);\n    }\n  });\n\n  return map;\n}\n\nfunction cloneProjectLookupSnapshotForReturn(lookup) {\n  if (!lookup || typeof lookup !== 'object') {\n    return { raw: new Map(), normalized: new Map() };\n  }\n\n  return {\n    raw: cloneLookupMap(lookup.raw),\n    normalized: cloneLookupMap(lookup.normalized),\n  };\n}\n\nfunction captureProjectLookupSnapshotForCache(lookup) {\n  if (!lookup || typeof lookup !== 'object') {\n    return { raw: new Map(), normalized: new Map() };\n  }\n\n  return {\n    raw: cloneLookupMap(lookup.raw),\n    normalized: cloneLookupMap(lookup.normalized, { freezeArray: true }),\n  };\n}\n\nfunction freezeProjectSnapshotProjects(projects) {\n  if (!isPlainObject(projects)) {\n    return {};\n  }\n\n  const frozen = {};\n  const keys = Object.keys(projects);\n  for (let index = 0; index < keys.length; index += 1) {\n    const key = keys[index];\n    const entry = projects[key];\n    if (entry && typeof entry === 'object') {\n      try {\n        Object.freeze(entry);\n      } catch (freezeError) {\n        void freezeError;\n      }\n    }\n    frozen[key] = entry;\n  }\n\n  try {\n    Object.freeze(frozen);\n  } catch (freezeRootError) {\n    void freezeRootError;\n  }\n\n  return frozen;\n}\n\nfunction setProjectReadCacheSnapshot(snapshot) {\n  if (!snapshot || typeof snapshot !== 'object') {\n    PROJECT_STORAGE_READ_CACHE = null;\n    return;\n  }\n\n  PROJECT_STORAGE_READ_CACHE = {\n    projects: freezeProjectSnapshotProjects(snapshot.projects),\n    changed: Boolean(snapshot.changed),\n    originalValue: snapshot.originalValue,\n    lookup: captureProjectLookupSnapshotForCache(snapshot.lookup),\n    rawValue: snapshot.rawValue === undefined ? undefined : snapshot.rawValue,\n  };\n}\n\nfunction getProjectReadCacheClone(options) {\n  if (!PROJECT_STORAGE_READ_CACHE) {\n    return null;\n  }\n\n  const safeStorage = getSafeLocalStorage();\n  let currentRaw = null;\n  if (safeStorage && typeof safeStorage.getItem === 'function') {\n    try {\n      currentRaw = safeStorage.getItem(PROJECT_STORAGE_KEY);\n    } catch (storageReadError) {\n      currentRaw = null;\n      void storageReadError;\n    }\n  }\n\n  if (\n    PROJECT_STORAGE_READ_CACHE.rawValue !== undefined\n    && PROJECT_STORAGE_READ_CACHE.rawValue !== currentRaw\n  ) {\n    PROJECT_STORAGE_READ_CACHE = null;\n    return null;\n  }\n\n  const { forMutation = false } = options || {};\n  const projects = forMutation\n    ? STORAGE_DEEP_CLONE(PROJECT_STORAGE_READ_CACHE.projects)\n    : PROJECT_STORAGE_READ_CACHE.projects;\n\n  return {\n    projects,\n    changed: PROJECT_STORAGE_READ_CACHE.changed,\n    originalValue: PROJECT_STORAGE_READ_CACHE.originalValue,\n    lookup: cloneProjectLookupSnapshotForReturn(PROJECT_STORAGE_READ_CACHE.lookup),\n  };\n}\n\nfunction invalidateProjectReadCache() {\n  PROJECT_STORAGE_READ_CACHE = null;\n}\n\nfunction normalizeProjectStorageRevisionValue(value) {\n  if (typeof value === 'number' && Number.isFinite(value)) {\n    return Math.max(0, Math.floor(value));\n  }\n  if (typeof value === 'string') {\n    const trimmed = value.trim();\n    if (!trimmed) {\n      return null;\n    }\n    const parsed = Number(trimmed);\n    if (Number.isFinite(parsed)) {\n      return Math.max(0, Math.floor(parsed));\n    }\n  }\n  return null;\n}\n\nfunction getProjectStorageRevisionKeyName() {\n  return PROJECT_STORAGE_REV_KEY;\n}\n\nfunction loadProjectStorageRevision(storageOverride) {\n  const storage = storageOverride || getSafeLocalStorage();\n  if (!storage || typeof storage.getItem !== 'function') {\n    return null;\n  }\n  const parsed = loadJSONFromStorage(\n    storage,\n    PROJECT_STORAGE_REV_KEY,\n    'Error reading project storage revision from localStorage:',\n    null,\n    { validate: (value) => value === null || typeof value === 'number' || typeof value === 'string' },\n  );\n  return normalizeProjectStorageRevisionValue(parsed);\n}\n\nfunction bumpProjectStorageRevision(storageOverride) {\n  const storage = storageOverride || getSafeLocalStorage();\n  if (!storage || typeof storage.setItem !== 'function') {\n    return null;\n  }\n  const current = loadProjectStorageRevision(storage);\n  const next = Number.isFinite(current) ? current + 1 : 1;\n  saveJSONToStorage(\n    storage,\n    PROJECT_STORAGE_REV_KEY,\n    next,\n    'Error saving project storage revision to localStorage:',\n    { disableCompression: true, enableCompressionSweep: false },\n  );\n  return next;\n}\n\nfunction cacheStorageValue(storage, key, rawValue, normalizedValue, value) {\n  if (typeof key !== 'string' || !key) {\n    return;\n  }\n\n  if (!storage || (typeof storage !== 'object' && typeof storage !== 'function')) {\n    return;\n  }\n\n  const map = getStorageStateCacheMap(storage, true);\n  if (!map) {\n    return;\n  }\n\n  const cachedValue = cloneValueForCache(value);\n  const normalized = typeof normalizedValue === 'string' && normalizedValue\n    ? normalizedValue\n    : typeof rawValue === 'string' && rawValue\n      ? rawValue\n      : null;\n\n  const cacheEntry = {\n    raw: typeof rawValue === 'string' && rawValue ? rawValue : null,\n    normalizedRaw: normalized,\n    value: cachedValue,\n  };\n\n  map.set(key, cacheEntry);\n}\n\nfunction tryGetCachedStorageValue(storage, key, primaryRaw, rawStored) {\n  const entry = getCachedStorageEntry(storage, key);\n  if (!entry) {\n    return { hit: false };\n  }\n\n  if (typeof rawStored === 'string' && rawStored) {\n    if (entry.raw && entry.raw === rawStored) {\n      return { hit: true, value: cloneCachedEntryValue(entry) };\n    }\n  }\n\n  if (typeof primaryRaw === 'string' && primaryRaw) {\n    if (entry.normalizedRaw && entry.normalizedRaw === primaryRaw) {\n      return { hit: true, value: cloneCachedEntryValue(entry) };\n    }\n    if (entry.raw && entry.raw === primaryRaw) {\n      return { hit: true, value: cloneCachedEntryValue(entry) };\n    }\n  }\n\n  return { hit: false };\n}\n\nfunction readGlobalStringValue(scope, key) {\n  if (!scope || typeof scope !== 'object') {\n    return '';\n  }\n\n  var descriptor;\n  try {\n    descriptor = Object.getOwnPropertyDescriptor(scope, key);\n  } catch (descriptorError) {\n    descriptor = null;\n    void descriptorError;\n  }\n\n  if (\n    descriptor &&\n    Object.prototype.hasOwnProperty.call(descriptor, 'value') &&\n    typeof descriptor.value === 'string' &&\n    descriptor.value\n  ) {\n    return descriptor.value;\n  }\n\n  var directValue;\n  try {\n    directValue = scope[key];\n  } catch (readError) {\n    directValue = '';\n    void readError;\n  }\n\n  if (typeof directValue === 'string' && directValue) {\n    return directValue;\n  }\n\n  if (key === 'MOUNT_VOLTAGE_STORAGE_KEY' && MOUNT_VOLTAGE_STORAGE_KEY_SYMBOL) {\n    try {\n      const symbolValue = scope[MOUNT_VOLTAGE_STORAGE_KEY_SYMBOL];\n      if (typeof symbolValue === 'string' && symbolValue) {\n        return symbolValue;\n      }\n    } catch (symbolReadError) {\n      void symbolReadError;\n    }\n  }\n\n  return '';\n}\n\nfunction exposeGlobalStringValue(scope, key, value) {\n  if (!scope || typeof scope !== 'object') {\n    return '';\n  }\n\n  if (key === 'MOUNT_VOLTAGE_STORAGE_KEY' && MOUNT_VOLTAGE_STORAGE_KEY_SYMBOL) {\n    try {\n      scope[MOUNT_VOLTAGE_STORAGE_KEY_SYMBOL] = value;\n      const symbolAssigned = scope[MOUNT_VOLTAGE_STORAGE_KEY_SYMBOL];\n      if (typeof symbolAssigned === 'string' && symbolAssigned) {\n        return symbolAssigned;\n      }\n    } catch (symbolExposeError) {\n      void symbolExposeError;\n    }\n  }\n\n  var descriptor;\n  try {\n    descriptor = Object.getOwnPropertyDescriptor(scope, key);\n  } catch (descriptorError) {\n    descriptor = null;\n    void descriptorError;\n  }\n\n  if (\n    descriptor &&\n    Object.prototype.hasOwnProperty.call(descriptor, 'value') &&\n    typeof descriptor.value === 'string' &&\n    descriptor.value\n  ) {\n    return descriptor.value;\n  }\n\n  if (descriptor && descriptor.configurable === false && descriptor.writable === false) {\n    return '';\n  }\n\n  var assigned = '';\n\n  try {\n    scope[key] = value;\n    assigned = scope[key];\n  } catch (assignError) {\n    assigned = '';\n    void assignError;\n  }\n\n  if (typeof assigned === 'string' && assigned) {\n    return assigned;\n  }\n\n  if (\n    key === 'MOUNT_VOLTAGE_STORAGE_KEY' &&\n    typeof console !== 'undefined' &&\n    typeof console.warn === 'function'\n  ) {\n    console.warn(\n      'Unable to expose mount voltage storage key globally. Using fallback only.'\n    );\n  }\n\n  return '';\n}\n\nfunction resolveMountVoltageStorageKeyName() {\n  if (!GLOBAL_SCOPE || typeof GLOBAL_SCOPE !== 'object') {\n    return MOUNT_VOLTAGE_STORAGE_KEY_FALLBACK;\n  }\n\n  var existing = readGlobalStringValue(GLOBAL_SCOPE, 'MOUNT_VOLTAGE_STORAGE_KEY');\n  if (existing) {\n    return existing;\n  }\n\n  var exposed = exposeGlobalStringValue(\n    GLOBAL_SCOPE,\n    'MOUNT_VOLTAGE_STORAGE_KEY',\n    MOUNT_VOLTAGE_STORAGE_KEY_FALLBACK\n  );\n  if (exposed) {\n    return exposed;\n  }\n\n  return MOUNT_VOLTAGE_STORAGE_KEY_FALLBACK;\n}\n\nvar MOUNT_VOLTAGE_STORAGE_KEY_NAME = resolveMountVoltageStorageKeyName();\n\nfunction refreshMountVoltageStorageKeyName() {\n  const resolved = resolveMountVoltageStorageKeyName();\n  if (resolved && resolved !== MOUNT_VOLTAGE_STORAGE_KEY_NAME) {\n    MOUNT_VOLTAGE_STORAGE_KEY_NAME = resolved;\n    if (GLOBAL_SCOPE) {\n      exposeGlobalStringValue(\n        GLOBAL_SCOPE,\n        'MOUNT_VOLTAGE_STORAGE_KEY',\n        resolved,\n      );\n    }\n    if (typeof RAW_STORAGE_BACKUP_KEYS !== 'undefined' && RAW_STORAGE_BACKUP_KEYS && typeof RAW_STORAGE_BACKUP_KEYS.add === 'function') {\n      RAW_STORAGE_BACKUP_KEYS.add(resolved);\n      const variants = getStorageKeyVariants(resolved);\n      for (let i = 0; i < variants.length; i += 1) {\n        const variant = variants[i];\n        if (typeof variant === 'string' && variant) {\n          RAW_STORAGE_BACKUP_KEYS.add(variant);\n        }\n      }\n    }\n  }\n  return MOUNT_VOLTAGE_STORAGE_KEY_NAME;\n}\n\nfunction getMountVoltageStorageKeyName() {\n  return refreshMountVoltageStorageKeyName();\n}\n\nfunction getMountVoltageStorageBackupKeyName() {\n  const key = refreshMountVoltageStorageKeyName();\n  return key ? `${key}__backup` : `${MOUNT_VOLTAGE_STORAGE_KEY_FALLBACK}__backup`;\n}\n\nfunction ensureCustomFontStorageKeyName() {\n  if (!GLOBAL_SCOPE) {\n    return CUSTOM_FONT_STORAGE_KEY_DEFAULT;\n  }\n\n  const existingName =\n    typeof GLOBAL_SCOPE.CUSTOM_FONT_STORAGE_KEY_NAME === 'string'\n      ? GLOBAL_SCOPE.CUSTOM_FONT_STORAGE_KEY_NAME\n      : typeof GLOBAL_SCOPE.CUSTOM_FONT_STORAGE_KEY === 'string'\n        ? GLOBAL_SCOPE.CUSTOM_FONT_STORAGE_KEY\n        : CUSTOM_FONT_STORAGE_KEY_DEFAULT;\n\n  let normalizedName = existingName;\n  if (existingName === 'cinePowerPlanner_customFonts') {\n    normalizedName = CUSTOM_FONT_STORAGE_KEY_DEFAULT;\n  }\n\n  if (GLOBAL_SCOPE.CUSTOM_FONT_STORAGE_KEY !== normalizedName) {\n    GLOBAL_SCOPE.CUSTOM_FONT_STORAGE_KEY = normalizedName;\n  }\n\n  if (GLOBAL_SCOPE.CUSTOM_FONT_STORAGE_KEY_NAME !== normalizedName) {\n    GLOBAL_SCOPE.CUSTOM_FONT_STORAGE_KEY_NAME = normalizedName;\n  }\n\n  return normalizedName;\n}\n\nfunction getCustomFontStorageKeyName() {\n  if (GLOBAL_SCOPE &&\n    typeof GLOBAL_SCOPE.CUSTOM_FONT_STORAGE_KEY_NAME === 'string') {\n    return GLOBAL_SCOPE.CUSTOM_FONT_STORAGE_KEY_NAME;\n  }\n\n  return ensureCustomFontStorageKeyName();\n}\n\nensureCustomFontStorageKeyName();\n\nvar CUSTOM_LOGO_STORAGE_KEY = 'customLogo';\nvar TEMPERATURE_UNIT_STORAGE_KEY_DEFAULT = 'cameraPowerPlanner_temperatureUnit';\nvar FOCUS_SCALE_STORAGE_KEY_DEFAULT = 'cameraPowerPlanner_focusScale';\n\nfunction resolveTemperatureUnitStorageKey() {\n  if (!GLOBAL_SCOPE) {\n    return TEMPERATURE_UNIT_STORAGE_KEY_DEFAULT;\n  }\n\n  const existing =\n    typeof GLOBAL_SCOPE.TEMPERATURE_UNIT_STORAGE_KEY === 'string'\n      ? GLOBAL_SCOPE.TEMPERATURE_UNIT_STORAGE_KEY\n      : TEMPERATURE_UNIT_STORAGE_KEY_DEFAULT;\n\n  if (GLOBAL_SCOPE.TEMPERATURE_UNIT_STORAGE_KEY !== existing) {\n    try {\n      GLOBAL_SCOPE.TEMPERATURE_UNIT_STORAGE_KEY = existing;\n    } catch (assignError) {\n      if (typeof console !== 'undefined' && typeof console.warn === 'function') {\n        console.warn('Unable to assign temperature unit storage key globally.', assignError);\n      }\n      try {\n        Object.defineProperty(GLOBAL_SCOPE, 'TEMPERATURE_UNIT_STORAGE_KEY', {\n          configurable: true,\n          writable: true,\n          value: existing,\n        });\n      } catch (defineError) {\n        if (typeof console !== 'undefined' && typeof console.warn === 'function') {\n          console.warn('Unable to expose temperature unit storage key globally.', defineError);\n        }\n      }\n    }\n  }\n\n  return existing;\n}\n\nvar TEMPERATURE_UNIT_STORAGE_KEY_NAME = resolveTemperatureUnitStorageKey();\nvar FOCUS_SCALE_STORAGE_KEY_NAME = (function resolveFocusScaleStorageKey() {\n  if (!GLOBAL_SCOPE) {\n    return FOCUS_SCALE_STORAGE_KEY_DEFAULT;\n  }\n\n  const existing =\n    typeof GLOBAL_SCOPE.FOCUS_SCALE_STORAGE_KEY === 'string'\n      ? GLOBAL_SCOPE.FOCUS_SCALE_STORAGE_KEY\n      : FOCUS_SCALE_STORAGE_KEY_DEFAULT;\n\n  if (GLOBAL_SCOPE.FOCUS_SCALE_STORAGE_KEY !== existing) {\n    try {\n      GLOBAL_SCOPE.FOCUS_SCALE_STORAGE_KEY = existing;\n    } catch (assignError) {\n      if (typeof console !== 'undefined' && typeof console.warn === 'function') {\n        console.warn('Unable to assign focus scale storage key globally.', assignError);\n      }\n    }\n  }\n\n  if (GLOBAL_SCOPE.FOCUS_SCALE_STORAGE_KEY_NAME !== existing) {\n    try {\n      GLOBAL_SCOPE.FOCUS_SCALE_STORAGE_KEY_NAME = existing;\n    } catch (defineError) {\n      if (typeof console !== 'undefined' && typeof console.warn === 'function') {\n        console.warn('Unable to expose focus scale storage key globally.', defineError);\n      }\n    }\n  }\n\n  return existing;\n})();\nvar AUTO_GEAR_RULES_STORAGE_KEY = 'cameraPowerPlanner_autoGearRules';\nvar AUTO_GEAR_SEEDED_STORAGE_KEY = 'cameraPowerPlanner_autoGearSeeded';\nvar AUTO_GEAR_BACKUPS_STORAGE_KEY = 'cameraPowerPlanner_autoGearBackups';\nvar AUTO_GEAR_PRESETS_STORAGE_KEY = 'cameraPowerPlanner_autoGearPresets';\nvar AUTO_GEAR_MONITOR_DEFAULTS_STORAGE_KEY = 'cameraPowerPlanner_autoGearMonitorDefaults';\nvar AUTO_GEAR_ACTIVE_PRESET_STORAGE_KEY = 'cameraPowerPlanner_autoGearActivePreset';\nvar AUTO_GEAR_AUTO_PRESET_STORAGE_KEY = 'cameraPowerPlanner_autoGearAutoPreset';\nvar AUTO_GEAR_BACKUP_VISIBILITY_STORAGE_KEY = 'cameraPowerPlanner_autoGearShowBackups';\nvar AUTO_GEAR_BACKUP_RETENTION_STORAGE_KEY = 'cameraPowerPlanner_autoGearBackupRetention';\nvar FULL_BACKUP_HISTORY_STORAGE_KEY = 'cameraPowerPlanner_fullBackups';\nvar STORAGE_AUTO_BACKUP_NAME_PREFIX = 'auto-backup-';\nvar STORAGE_AUTO_BACKUP_DELETION_PREFIX = 'auto-backup-before-delete-';\nvar STORAGE_AUTO_BACKUP_RENAMED_FLAG = '__cineAutoBackupRenamed';\nvar AUTO_BACKUP_METADATA_PROPERTY = '__cineAutoBackupMetadata';\nvar AUTO_BACKUP_SNAPSHOT_PROPERTY = '__cineAutoBackupSnapshot';\nvar AUTO_BACKUP_SNAPSHOT_VERSION = 1;\nvar AUTO_BACKUP_PAYLOAD_COMPRESSION_FLAG = '__cineAutoBackupCompressedPayload';\nvar AUTO_BACKUP_CYCLE_PLACEHOLDER = '__cineCircular__';\n\nvar projectActivityTimestamps = new Map();\nvar forcedCompressedProjectKeys = typeof Set === 'function' ? new Set() : null;\nvar AUTO_BACKUP_PAYLOAD_COMPRESSION_MIN_LENGTH = 2048;\n\nfunction isAutoBackupStorageKey(name) {\n  return typeof name === 'string'\n    && (name.startsWith(STORAGE_AUTO_BACKUP_NAME_PREFIX)\n      || name.startsWith(STORAGE_AUTO_BACKUP_DELETION_PREFIX));\n}\n\nif (GLOBAL_SCOPE && typeof GLOBAL_SCOPE === 'object') {\n  try {\n    if (!Object.prototype.hasOwnProperty.call(GLOBAL_SCOPE, '__CINE_AUTO_BACKUP_RENAMED_FLAG')) {\n      Object.defineProperty(GLOBAL_SCOPE, '__CINE_AUTO_BACKUP_RENAMED_FLAG', {\n        configurable: true,\n        writable: false,\n        value: STORAGE_AUTO_BACKUP_RENAMED_FLAG,\n      });\n    }\n  } catch (error) {\n    void error;\n    try {\n      GLOBAL_SCOPE.__CINE_AUTO_BACKUP_RENAMED_FLAG = STORAGE_AUTO_BACKUP_RENAMED_FLAG;\n    } catch (assignmentError) {\n      void assignmentError;\n    }\n  }\n}\nvar MAX_AUTO_BACKUPS = 240;\nvar MAX_DELETION_BACKUPS = 20;\nvar MAX_FULL_BACKUP_HISTORY_ENTRIES = 200;\nvar AUTO_GEAR_BACKUP_RETENTION_DEFAULT_VALUE = 36;\nvar AUTO_GEAR_BACKUP_RETENTION_MIN = 1;\nvar AUTO_GEAR_BACKUP_RETENTION_MAX = 120;\n\nfunction ensureGlobalAutoGearBackupDefaults() {\n  if (!GLOBAL_SCOPE || typeof GLOBAL_SCOPE !== 'object') {\n    return;\n  }\n\n  if (typeof GLOBAL_SCOPE.AUTO_GEAR_BACKUP_RETENTION_DEFAULT !== 'number') {\n    try {\n      GLOBAL_SCOPE.AUTO_GEAR_BACKUP_RETENTION_DEFAULT = AUTO_GEAR_BACKUP_RETENTION_DEFAULT_VALUE;\n    } catch (error) {\n      if (typeof console !== 'undefined' && typeof console.warn === 'function') {\n        console.warn('Unable to expose auto gear backup retention default globally.', error);\n      }\n    }\n  }\n\n  if (typeof GLOBAL_SCOPE.AUTO_GEAR_BACKUP_RETENTION_MIN !== 'number') {\n    try {\n      GLOBAL_SCOPE.AUTO_GEAR_BACKUP_RETENTION_MIN = AUTO_GEAR_BACKUP_RETENTION_MIN;\n    } catch (error) {\n      if (typeof console !== 'undefined' && typeof console.warn === 'function') {\n        console.warn('Unable to expose auto gear backup retention minimum globally.', error);\n      }\n    }\n  }\n}\n\nensureGlobalAutoGearBackupDefaults();\n\nfunction cloneAutoBackupMetadata(metadata) {\n  if (!metadata || typeof metadata !== 'object') {\n    return null;\n  }\n\n  return {\n    version: Number.isFinite(metadata.version) ? metadata.version : AUTO_BACKUP_SNAPSHOT_VERSION,\n    snapshotType: metadata.snapshotType === 'delta' ? 'delta' : 'full',\n    base: typeof metadata.base === 'string' ? metadata.base : null,\n    sequence: Number.isFinite(metadata.sequence) ? metadata.sequence : (metadata.snapshotType === 'delta' ? 1 : 0),\n    createdAt: typeof metadata.createdAt === 'string' ? metadata.createdAt : null,\n    changedKeys: Array.isArray(metadata.changedKeys) ? metadata.changedKeys.slice() : [],\n    removedKeys: Array.isArray(metadata.removedKeys) ? metadata.removedKeys.slice() : [],\n    payloadSignature: typeof metadata.payloadSignature === 'string'\n      ? metadata.payloadSignature\n      : null,\n    payloadCompression: isPlainObject(metadata.payloadCompression)\n      ? { ...metadata.payloadCompression }\n      : null,\n    compressedPayload: isPlainObject(metadata.compressedPayload)\n      ? cloneAutoBackupValue(metadata.compressedPayload, { stripMetadata: true })\n      : metadata.compressedPayload && typeof metadata.compressedPayload === 'string'\n        ? metadata.compressedPayload\n        : null,\n  };\n}\n\nfunction defineAutoBackupMetadata(target, metadata) {\n  if (!target || typeof target !== 'object') {\n    return;\n  }\n\n  const clonedMetadata = cloneAutoBackupMetadata(metadata);\n\n  try {\n    Object.defineProperty(target, AUTO_BACKUP_METADATA_PROPERTY, {\n      configurable: true,\n      enumerable: false,\n      writable: true,\n      value: clonedMetadata,\n    });\n  } catch (error) {\n    void error;\n    try {\n      target[AUTO_BACKUP_METADATA_PROPERTY] = clonedMetadata;\n    } catch (assignmentError) {\n      void assignmentError;\n    }\n  }\n}\n\nfunction getAutoBackupMetadata(value) {\n  if (!value || typeof value !== 'object') {\n    return null;\n  }\n\n  const metadata = value[AUTO_BACKUP_METADATA_PROPERTY];\n  if (!metadata || typeof metadata !== 'object') {\n    return null;\n  }\n\n  return metadata;\n}\n\nfunction copyAutoBackupMetadata(source, target) {\n  if (!target || typeof target !== 'object') {\n    return;\n  }\n\n  const metadata = getAutoBackupMetadata(source);\n  if (metadata) {\n    defineAutoBackupMetadata(target, metadata);\n  }\n}\n\nfunction cloneAutoBackupValue(value, options, state) {\n  const opts = options || {};\n  const cloneState = state || (typeof WeakSet === 'function'\n    ? { stack: new WeakSet(), reportedCycle: false }\n    : null);\n\n  const handleCircularClone = (input, compute) => {\n    if (!cloneState || !cloneState.stack) {\n      return compute();\n    }\n    if (cloneState.stack.has(input)) {\n      if (!cloneState.reportedCycle\n        && typeof console !== 'undefined'\n        && console\n        && typeof console.warn === 'function') {\n        try {\n          console.warn(\n            'Detected circular reference while cloning automatic backup data. Using a placeholder to keep serialization stable.',\n          );\n        } catch (e) {\n          void e;\n          // Ignore warning errors during recursion\n        }\n      }\n      if (cloneState) {\n        cloneState.reportedCycle = true;\n      }\n      return AUTO_BACKUP_CYCLE_PLACEHOLDER;\n    }\n    cloneState.stack.add(input);\n    try {\n      return compute();\n    } finally {\n      cloneState.stack.delete(input);\n    }\n  };\n\n  if (value === null || typeof value !== 'object') {\n    return value;\n  }\n\n  if (value instanceof Date) {\n    return new Date(value.getTime());\n  }\n\n  if (Array.isArray(value)) {\n    return handleCircularClone(value, () => value.map((item) => cloneAutoBackupValue(item, opts, cloneState)));\n  }\n\n  return handleCircularClone(value, () => {\n    const clone = {};\n    Object.keys(value).forEach((key) => {\n      if (opts.stripMetadata && key === AUTO_BACKUP_METADATA_PROPERTY) {\n        return;\n      }\n      clone[key] = cloneAutoBackupValue(value[key], opts, cloneState);\n    });\n\n    if (!opts.stripMetadata) {\n      const metadata = getAutoBackupMetadata(value);\n      if (metadata) {\n        defineAutoBackupMetadata(clone, metadata);\n      }\n    }\n\n    return clone;\n  });\n}\n\nfunction cloneAutoBackupValueWithLegacyNormalization(value, options) {\n  const cloneState = typeof WeakSet === 'function'\n    ? { stack: new WeakSet(), reportedCycle: false }\n    : null;\n  const cloned = cloneAutoBackupValue(value, options, cloneState);\n  const normalized = normalizeLegacyLongGopStructure(cloned);\n  return normalized !== cloned ? normalized : cloned;\n}\n\nfunction isCompressedAutoBackupSnapshotPayload(payload) {\n  if (!isPlainObject(payload)) {\n    return false;\n  }\n  if (payload[AUTO_BACKUP_PAYLOAD_COMPRESSION_FLAG] !== true) {\n    return false;\n  }\n  return typeof payload.data === 'string' && payload.data;\n}\n\nfunction prepareAutoBackupSnapshotPayloadForStorage(payload, contextName, options) {\n  if (!payload || typeof payload !== 'object') {\n    return {\n      payload,\n      compression: null,\n      compressed: false,\n      reused: false,\n      payloadSignature: null,\n    };\n  }\n\n  const opts = options || {};\n  if (opts.disableCompression) {\n    return {\n      payload,\n      compression: null,\n      compressed: false,\n      reused: false,\n      payloadSignature: typeof opts.payloadSignature === 'string'\n        ? opts.payloadSignature\n        : null,\n    };\n  }\n\n  const shouldReport = opts.reportCompression !== false;\n\n  let computedSignature = null;\n  try {\n    computedSignature = typeof opts.payloadSignature === 'string'\n      ? opts.payloadSignature\n      : createStableValueSignature(payload);\n  } catch (signatureError) {\n    computedSignature = null;\n    console.warn(\n      'Unable to compute stable signature for automatic backup payload before compression',\n      signatureError,\n    );\n  }\n\n  const existingSignature = typeof opts.existingPayloadSignature === 'string'\n    ? opts.existingPayloadSignature\n    : null;\n\n  if (\n    existingSignature\n    && computedSignature\n    && existingSignature === computedSignature\n    && isCompressedAutoBackupSnapshotPayload(opts.existingCompressedPayload)\n  ) {\n    const reusedPayload = cloneAutoBackupValue(opts.existingCompressedPayload, { stripMetadata: true });\n    const reusedCompression = isPlainObject(opts.existingPayloadCompression)\n      ? { ...opts.existingPayloadCompression }\n      : null;\n    if (\n      !opts.disableCompression\n      && typeof computedSignature === 'string'\n      && computedSignature\n    ) {\n      writeAutoBackupCompressionCache(computedSignature, reusedPayload, reusedCompression);\n    }\n    return {\n      payload: reusedPayload,\n      compression: reusedCompression,\n      compressed: true,\n      reused: true,\n      payloadSignature: computedSignature,\n    };\n  }\n\n  if (\n    !opts.disableCompression\n    && typeof computedSignature === 'string'\n    && computedSignature\n  ) {\n    const cached = readAutoBackupCompressionCache(computedSignature);\n    if (cached && cached.payload) {\n      return {\n        payload: cached.payload,\n        compression: cached.compression,\n        compressed: true,\n        reused: true,\n        payloadSignature: computedSignature,\n      };\n    }\n  }\n\n  let serialized;\n  try {\n    serialized = JSON.stringify(payload);\n  } catch (error) {\n    console.warn('Unable to serialize auto backup payload before compression', error);\n    return {\n      payload,\n      compression: null,\n      compressed: false,\n      reused: false,\n      payloadSignature: computedSignature,\n    };\n  }\n\n  if (typeof serialized !== 'string' || serialized.length < AUTO_BACKUP_PAYLOAD_COMPRESSION_MIN_LENGTH) {\n    return {\n      payload,\n      compression: null,\n      compressed: false,\n      reused: false,\n      payloadSignature: computedSignature,\n    };\n  }\n\n  if (\n    !opts.disableCompression\n    && isCompressedAutoBackupSnapshotPayload(opts.existingCompressedPayload)\n  ) {\n    const decodedExisting = decodeCompressedJsonStorageValue(\n      opts.existingCompressedPayload.data,\n    );\n    if (decodedExisting.success && typeof decodedExisting.value === 'string') {\n      if (decodedExisting.value === serialized) {\n        const reusedPayload = cloneAutoBackupValue(opts.existingCompressedPayload, {\n          stripMetadata: true,\n        });\n        const reusedCompression = isPlainObject(opts.existingPayloadCompression)\n          ? { ...opts.existingPayloadCompression }\n          : null;\n        const resolvedSignature = typeof computedSignature === 'string'\n          && computedSignature\n          ? computedSignature\n          : (typeof existingSignature === 'string' && existingSignature\n            ? existingSignature\n            : null);\n        if (resolvedSignature) {\n          writeAutoBackupCompressionCache(\n            resolvedSignature,\n            reusedPayload,\n            reusedCompression,\n          );\n        }\n        return {\n          payload: reusedPayload,\n          compression: reusedCompression,\n          compressed: true,\n          reused: true,\n          payloadSignature: resolvedSignature,\n        };\n      }\n    }\n  }\n\n  const candidate = createCompressedJsonStorageCandidate(serialized);\n  if (!candidate || typeof candidate.serialized !== 'string') {\n    return {\n      payload,\n      compression: null,\n      compressed: false,\n      reused: false,\n      payloadSignature: computedSignature,\n    };\n  }\n\n  const savings = candidate.originalLength - candidate.wrappedLength;\n  const compressedPayload = {\n    [AUTO_BACKUP_PAYLOAD_COMPRESSION_FLAG]: true,\n    data: candidate.serialized,\n    originalLength: candidate.originalLength,\n    compressedLength: candidate.wrappedLength,\n    compressionVariant: candidate.compressionVariant || null,\n  };\n\n  const compressionInfo =\n    typeof candidate.originalLength === 'number'\n      && Number.isFinite(candidate.originalLength)\n      && typeof candidate.wrappedLength === 'number'\n      && Number.isFinite(candidate.wrappedLength)\n      ? {\n        originalLength: candidate.originalLength,\n        compressedLength: candidate.wrappedLength,\n        compressionVariant: candidate.compressionVariant || null,\n      }\n      : null;\n\n  if (\n    !opts.disableCompression\n    && typeof computedSignature === 'string'\n    && computedSignature\n  ) {\n    writeAutoBackupCompressionCache(\n      computedSignature,\n      compressedPayload,\n      compressionInfo,\n    );\n  }\n\n  if (\n    shouldReport\n    && typeof console !== 'undefined'\n    && typeof console.warn === 'function'\n    && savings > 0\n  ) {\n    const label = typeof contextName === 'string' && contextName\n      ? `\"${contextName}\"`\n      : 'an automatic backup';\n    const percent = candidate.originalLength > 0\n      ? Math.round((savings / candidate.originalLength) * 100)\n      : 0;\n    const message = `Stored compressed payload for ${label} snapshot to reduce storage usage by ${savings} characters (${percent}%).`;\n    logCompressionSavingsEvent('auto-backup', contextName || label, message, savings, percent);\n  }\n\n  return {\n    payload: compressedPayload,\n    compression: {\n      originalLength: candidate.originalLength,\n      compressedLength: candidate.wrappedLength,\n      compressionVariant: candidate.compressionVariant || null,\n    },\n    compressed: true,\n    reused: false,\n    payloadSignature: computedSignature,\n  };\n}\n\nfunction restoreAutoBackupSnapshotPayload(snapshot, contextName) {\n  if (!snapshot || typeof snapshot !== 'object') {\n    return { payload: snapshot, compressed: false };\n  }\n\n  const rawPayload = snapshot.payload;\n  if (!isCompressedAutoBackupSnapshotPayload(rawPayload)) {\n    return { payload: rawPayload, compressed: false };\n  }\n\n  const decoded = decodeCompressedJsonStorageValue(rawPayload.data);\n  if (!decoded.success || typeof decoded.value !== 'string') {\n    const details = decoded && decoded.error ? decoded.error : null;\n    console.warn('Unable to decompress automatic backup payload.', contextName, details);\n    throw new Error('Failed to decompress automatic backup payload');\n  }\n\n  try {\n    const parsed = JSON.parse(decoded.value);\n    return { payload: parsed, compressed: true };\n  } catch (error) {\n    console.warn('Unable to parse decompressed automatic backup payload.', contextName, error);\n    throw error;\n  }\n}\n\nfunction deriveAutoBackupCreatedAt(name, fallbackDate) {\n  const info = parseAutoBackupKey(name);\n  if (info && Number.isFinite(info.timestamp) && info.timestamp > 0) {\n    try {\n      return new Date(info.timestamp).toISOString();\n    } catch (error) {\n      void error;\n    }\n  }\n\n  const sourceDate = fallbackDate instanceof Date ? fallbackDate : new Date();\n  try {\n    return sourceDate.toISOString();\n  } catch (error) {\n    void error;\n    return new Date().toISOString();\n  }\n}\n\nfunction detectCyclicAutoBackupReference(entries, name, metadata) {\n  if (!isPlainObject(entries) || !metadata || metadata.snapshotType !== 'delta') {\n    return { cycle: false, path: [] };\n  }\n\n  const visited = new Set();\n  const path = [];\n  const maxSteps = Math.max(10, Object.keys(entries).length + 5);\n  let steps = 0;\n  let currentName = name;\n  let currentMetadata = metadata;\n\n  while (currentMetadata && currentMetadata.snapshotType === 'delta') {\n    if (steps > maxSteps) {\n      return { cycle: true, path };\n    }\n\n    const baseName = typeof currentMetadata.base === 'string' ? currentMetadata.base : null;\n    if (!baseName) {\n      return { cycle: false, path };\n    }\n\n    if (!isAutoBackupStorageKey(baseName)) {\n      return { cycle: false, path };\n    }\n\n    if (visited.has(baseName)) {\n      path.push(baseName);\n      return { cycle: true, path };\n    }\n\n    visited.add(currentName);\n    path.push(currentName);\n\n    const baseEntry = Object.prototype.hasOwnProperty.call(entries, baseName)\n      ? entries[baseName]\n      : null;\n    if (!isPlainObject(baseEntry)) {\n      return { cycle: false, path };\n    }\n\n    currentName = baseName;\n    currentMetadata = getAutoBackupMetadata(baseEntry);\n    if (!currentMetadata) {\n      return { cycle: false, path };\n    }\n\n    steps += 1;\n  }\n\n  return { cycle: false, path };\n}\n\nfunction promoteAutoBackupMetadataToFull(metadata, name, value) {\n  if (!metadata || typeof metadata !== 'object') {\n    return;\n  }\n\n  metadata.snapshotType = 'full';\n  metadata.base = null;\n  metadata.sequence = 0;\n  metadata.removedKeys = [];\n\n  const keys = isPlainObject(value) ? Object.keys(value) : [];\n  metadata.changedKeys = keys.slice();\n\n  if (typeof metadata.createdAt !== 'string' || !metadata.createdAt) {\n    metadata.createdAt = deriveAutoBackupCreatedAt(name);\n  }\n}\n\nfunction expandAutoBackupEntries(container, options) {\n  if (!isPlainObject(container)) {\n    return container;\n  }\n\n  const result = {};\n  const cache = new Map();\n  const opts = options || {};\n  const isAutoBackupKey = typeof opts.isAutoBackupKey === 'function'\n    ? opts.isAutoBackupKey\n    : isAutoBackupStorageKey;\n  const filter = typeof opts.filter === 'function' ? opts.filter : null;\n\n  const shouldIncludeEntry = filter\n    ? (name) => {\n      let include = false;\n      try {\n        include = filter(name);\n      } catch (filterError) {\n        include = false;\n        void filterError;\n      }\n      return include;\n    }\n    : () => true;\n\n  const resolve = (name, stack) => {\n    if (cache.has(name)) {\n      return cache.get(name);\n    }\n\n    const rawValue = container[name];\n    const restored = restoreCompressedProjectEntry(rawValue, name);\n    const value = restored.restored ? restored.value : rawValue;\n    if (!isPlainObject(value)) {\n      const clonedValue = cloneAutoBackupValue(value);\n      cache.set(name, clonedValue);\n      return clonedValue;\n    }\n\n    const snapshot = value[AUTO_BACKUP_SNAPSHOT_PROPERTY];\n    if (snapshot && typeof snapshot === 'object') {\n      if (stack.has(name)) {\n        console.warn('Detected cyclic auto-backup reference while expanding snapshot', name);\n        let fallbackPayload = {};\n        let payloadKeys = [];\n        let payloadSignature = null;\n\n        try {\n          const payloadInfo = restoreAutoBackupSnapshotPayload(snapshot, name);\n          if (payloadInfo && isPlainObject(payloadInfo.payload)) {\n            fallbackPayload = cloneAutoBackupValue(payloadInfo.payload);\n            payloadKeys = Object.keys(payloadInfo.payload);\n            try {\n              payloadSignature = createStableValueSignature(payloadInfo.payload);\n            } catch (cycleSignatureError) {\n              payloadSignature = null;\n              console.warn(\n                'Unable to compute stable signature for automatic backup payload after detecting a cycle',\n                cycleSignatureError,\n              );\n            }\n          }\n        } catch (cyclePayloadError) {\n          console.warn(\n            'Failed to restore automatic backup payload after detecting a cyclic reference',\n            name,\n            cyclePayloadError,\n          );\n        }\n\n        const metadata = {\n          version: Number.isFinite(snapshot.version) ? snapshot.version : AUTO_BACKUP_SNAPSHOT_VERSION,\n          snapshotType: 'full',\n          base: null,\n          sequence: Number.isFinite(snapshot.sequence) ? snapshot.sequence : 0,\n          createdAt: typeof snapshot.createdAt === 'string'\n            ? snapshot.createdAt\n            : deriveAutoBackupCreatedAt(name),\n          changedKeys: payloadKeys.slice(),\n          removedKeys: [],\n          payloadSignature,\n        };\n\n        if (isCompressedAutoBackupSnapshotPayload(snapshot.payload)) {\n          metadata.compressedPayload = cloneAutoBackupValue(snapshot.payload, { stripMetadata: true });\n          metadata.payloadCompression = isPlainObject(snapshot.payloadCompression)\n            ? { ...snapshot.payloadCompression }\n            : null;\n        } else {\n          metadata.compressedPayload = null;\n          metadata.payloadCompression = null;\n        }\n\n        defineAutoBackupMetadata(fallbackPayload, metadata);\n        cache.set(name, fallbackPayload);\n        return fallbackPayload;\n      }\n\n      stack.add(name);\n\n      const snapshotType = snapshot.snapshotType === 'delta' ? 'delta' : 'full';\n      const baseName = snapshotType === 'delta' && typeof snapshot.base === 'string'\n        ? snapshot.base\n        : null;\n      const baseValue = baseName ? cloneAutoBackupValue(resolve(baseName, stack)) : {};\n      let payloadInfo;\n      try {\n        payloadInfo = restoreAutoBackupSnapshotPayload(snapshot, name);\n      } catch (payloadError) {\n        console.warn('Failed to restore automatic backup payload while expanding snapshot', name, payloadError);\n        throw payloadError;\n      }\n      const payload = isPlainObject(payloadInfo.payload) ? payloadInfo.payload : {};\n      const changedKeys = Array.isArray(snapshot.changedKeys) && snapshot.changedKeys.length\n        ? snapshot.changedKeys\n        : Object.keys(payload);\n      const removedKeys = Array.isArray(snapshot.removedKeys) ? snapshot.removedKeys : [];\n\n      const expanded = cloneAutoBackupValue(baseValue);\n\n      changedKeys.forEach((key) => {\n        if (Object.prototype.hasOwnProperty.call(payload, key)) {\n          if (expanded) {\n            expanded[key] = cloneAutoBackupValue(payload[key]);\n          }\n        }\n      });\n\n      removedKeys.forEach((key) => {\n        if (Object.prototype.hasOwnProperty.call(expanded, key)) {\n          delete expanded[key];\n        }\n      });\n\n      const metadata = {\n        version: Number.isFinite(snapshot.version) ? snapshot.version : AUTO_BACKUP_SNAPSHOT_VERSION,\n        snapshotType,\n        base: snapshotType === 'delta' ? baseName : null,\n        sequence: Number.isFinite(snapshot.sequence)\n          ? snapshot.sequence\n          : (snapshotType === 'delta' ? 1 : 0),\n        createdAt: typeof snapshot.createdAt === 'string'\n          ? snapshot.createdAt\n          : deriveAutoBackupCreatedAt(name),\n        changedKeys: changedKeys.slice(),\n        removedKeys: removedKeys.slice(),\n      };\n\n      try {\n        metadata.payloadSignature = createStableValueSignature(payload);\n      } catch (payloadSignatureError) {\n        metadata.payloadSignature = null;\n        console.warn(\n          'Unable to compute stable signature for automatic backup payload during expansion',\n          payloadSignatureError,\n        );\n      }\n\n      if (isCompressedAutoBackupSnapshotPayload(snapshot.payload)) {\n        metadata.compressedPayload = cloneAutoBackupValue(snapshot.payload, { stripMetadata: true });\n        metadata.payloadCompression = isPlainObject(snapshot.payloadCompression)\n          ? { ...snapshot.payloadCompression }\n          : null;\n      } else {\n        metadata.compressedPayload = null;\n        metadata.payloadCompression = null;\n      }\n\n      defineAutoBackupMetadata(expanded, metadata);\n      cache.set(name, expanded);\n      stack.delete(name);\n      return expanded;\n    }\n\n    const cloned = cloneAutoBackupValue(value);\n    if (isAutoBackupKey(name)) {\n      const metadata = {\n        version: AUTO_BACKUP_SNAPSHOT_VERSION,\n        snapshotType: 'full',\n        base: null,\n        sequence: 0,\n        createdAt: deriveAutoBackupCreatedAt(name),\n        changedKeys: Object.keys(cloned),\n        removedKeys: [],\n      };\n      defineAutoBackupMetadata(cloned, metadata);\n    }\n    cache.set(name, cloned);\n    return cloned;\n  };\n\n  Object.keys(container).forEach((name) => {\n    if (!shouldIncludeEntry(name)) {\n      return;\n    }\n    if (!isAutoBackupKey(name)) {\n      const value = container[name];\n      result[name] = isPlainObject(value)\n        ? cloneAutoBackupValue(value)\n        : value;\n      return;\n    }\n\n    result[name] = resolve(name, new Set());\n  });\n\n  return result;\n}\n\nfunction computeAutoBackupDiff(currentValue, baseValue) {\n  const payload = {};\n  const changedKeys = [];\n  const removedKeys = [];\n\n  const baseKeys = isPlainObject(baseValue) ? Object.keys(baseValue) : [];\n  const currentKeys = isPlainObject(currentValue) ? Object.keys(currentValue) : [];\n  const allKeys = new Set([...baseKeys, ...currentKeys]);\n\n  allKeys.forEach((key) => {\n    if (key === AUTO_BACKUP_METADATA_PROPERTY) {\n      return;\n    }\n\n    const hasCurrent = Object.prototype.hasOwnProperty.call(currentValue || {}, key);\n    const hasBase = Object.prototype.hasOwnProperty.call(baseValue || {}, key);\n\n    if (!hasCurrent && hasBase) {\n      removedKeys.push(key);\n      return;\n    }\n\n    if (!hasCurrent) {\n      return;\n    }\n\n    const currentEntry = currentValue ? currentValue[key] : undefined;\n    const baseEntry = hasBase ? baseValue[key] : undefined;\n\n    const currentSignature = createStableValueSignature(currentEntry);\n    const baseSignature = createStableValueSignature(baseEntry);\n\n    if (currentSignature !== baseSignature) {\n      changedKeys.push(key);\n      payload[key] = cloneAutoBackupValue(currentEntry, { stripMetadata: true });\n    }\n  });\n\n  return { payload, changedKeys, removedKeys };\n}\n\nfunction serializeAutoBackupEntries(entries, options) {\n  if (!isPlainObject(entries)) {\n    return entries;\n  }\n\n  const opts = options || {};\n  const isAutoBackupKey = typeof opts.isAutoBackupKey === 'function'\n    ? opts.isAutoBackupKey\n    : isAutoBackupStorageKey;\n\n  const serialized = {};\n  const entryNames = Object.keys(entries);\n\n  const latestAutoBackupNames = (() => {\n    const groups = new Map();\n    entryNames.forEach((name) => {\n      if (!isAutoBackupKey(name)) {\n        return;\n      }\n      const value = entries[name];\n      const metadata = getAutoBackupMetadata(value);\n      let timestamp = Number.NEGATIVE_INFINITY;\n      if (metadata && typeof metadata.createdAt === 'string') {\n        const parsed = Date.parse(metadata.createdAt);\n        if (!Number.isNaN(parsed)) {\n          timestamp = parsed;\n        }\n      }\n      if (!Number.isFinite(timestamp)) {\n        const parsedKey = parseAutoBackupKey(name);\n        if (parsedKey && Number.isFinite(parsedKey.timestamp)) {\n          timestamp = parsedKey.timestamp;\n        }\n      }\n      const groupKey = name.startsWith(STORAGE_AUTO_BACKUP_DELETION_PREFIX)\n        ? STORAGE_AUTO_BACKUP_DELETION_PREFIX\n        : STORAGE_AUTO_BACKUP_NAME_PREFIX;\n      const current = groups.get(groupKey);\n      if (\n        !current\n        || timestamp > current.timestamp\n        || (timestamp === current.timestamp && name.localeCompare(current.name) > 0)\n      ) {\n        groups.set(groupKey, { name, timestamp });\n      }\n    });\n    const result = new Set();\n    groups.forEach(({ name }) => {\n      if (typeof name === 'string' && name) {\n        result.add(name);\n      }\n    });\n    return result;\n  })();\n\n  entryNames.forEach((name) => {\n    const value = entries[name];\n    const normalizedValue = cloneAutoBackupValueWithLegacyNormalization(value, { stripMetadata: true });\n\n    if (!isAutoBackupKey(name) || !isPlainObject(normalizedValue)) {\n      serialized[name] = normalizedValue;\n      return;\n    }\n\n    const disableCompressionForName = latestAutoBackupNames.has(name);\n    const metadata = getAutoBackupMetadata(value);\n    if (metadata && metadata.snapshotType === 'delta') {\n      const cycleInfo = detectCyclicAutoBackupReference(entries, name, metadata);\n      if (cycleInfo.cycle) {\n        if (typeof console !== 'undefined' && typeof console.warn === 'function') {\n          console.warn(\n            'Detected cyclic automatic backup chain during serialization. Promoting to full snapshot.',\n            name,\n          );\n        }\n        promoteAutoBackupMetadataToFull(metadata, name, normalizedValue);\n      }\n    }\n    const createdAt = metadata && typeof metadata.createdAt === 'string'\n      ? metadata.createdAt\n      : deriveAutoBackupCreatedAt(name);\n\n    if (!metadata || metadata.snapshotType !== 'delta') {\n      serialized[name] = {};\n      const snapshot = {\n        version: AUTO_BACKUP_SNAPSHOT_VERSION,\n        snapshotType: 'full',\n        base: null,\n        sequence: 0,\n        createdAt,\n        changedKeys: Object.keys(normalizedValue || {}),\n        removedKeys: [],\n      };\n      let payloadSignature;\n      try {\n        payloadSignature = createStableValueSignature(normalizedValue);\n      } catch (signatureError) {\n        payloadSignature = null;\n        console.warn(\n          'Unable to compute stable signature for automatic backup payload before serialization',\n          signatureError,\n        );\n      }\n      const prepared = prepareAutoBackupSnapshotPayloadForStorage(normalizedValue, name, {\n        disableCompression: disableCompressionForName,\n        payloadSignature,\n        existingCompressedPayload: metadata ? metadata.compressedPayload : null,\n        existingPayloadCompression: metadata ? metadata.payloadCompression : null,\n        existingPayloadSignature: metadata ? metadata.payloadSignature : null,\n      });\n      snapshot.payload = prepared.payload;\n      if (prepared.compression) {\n        snapshot.payloadCompression = prepared.compression;\n      }\n      if (metadata) {\n        const resolvedSignature = typeof prepared.payloadSignature === 'string'\n          ? prepared.payloadSignature\n          : payloadSignature;\n        metadata.payloadSignature = resolvedSignature || null;\n        if (prepared.compressed) {\n          metadata.compressedPayload = cloneAutoBackupValue(prepared.payload, { stripMetadata: true });\n          metadata.payloadCompression = prepared.compression\n            ? { ...prepared.compression }\n            : null;\n        } else {\n          metadata.compressedPayload = null;\n          metadata.payloadCompression = null;\n        }\n      }\n      serialized[name][AUTO_BACKUP_SNAPSHOT_PROPERTY] = snapshot;\n      return;\n    }\n\n    const baseName = typeof metadata.base === 'string' ? metadata.base : null;\n    const baseValue = baseName && Object.prototype.hasOwnProperty.call(entries, baseName)\n      ? entries[baseName]\n      : null;\n\n    if (!baseValue || !isPlainObject(baseValue)) {\n      serialized[name] = {};\n      const snapshot = {\n        version: AUTO_BACKUP_SNAPSHOT_VERSION,\n        snapshotType: 'full',\n        base: null,\n        sequence: 0,\n        createdAt,\n        changedKeys: Object.keys(normalizedValue || {}),\n        removedKeys: [],\n      };\n      let payloadSignature;\n      try {\n        payloadSignature = createStableValueSignature(normalizedValue);\n      } catch (signatureError) {\n        payloadSignature = null;\n        console.warn(\n          'Unable to compute stable signature for automatic backup payload before serialization',\n          signatureError,\n        );\n      }\n      const prepared = prepareAutoBackupSnapshotPayloadForStorage(normalizedValue, name, {\n        disableCompression: disableCompressionForName,\n        payloadSignature,\n        existingCompressedPayload: metadata ? metadata.compressedPayload : null,\n        existingPayloadCompression: metadata ? metadata.payloadCompression : null,\n        existingPayloadSignature: metadata ? metadata.payloadSignature : null,\n      });\n      snapshot.payload = prepared.payload;\n      if (prepared.compression) {\n        snapshot.payloadCompression = prepared.compression;\n      }\n      if (metadata) {\n        const resolvedSignature = typeof prepared.payloadSignature === 'string'\n          ? prepared.payloadSignature\n          : payloadSignature;\n        metadata.payloadSignature = resolvedSignature || null;\n        if (prepared.compressed) {\n          metadata.compressedPayload = cloneAutoBackupValue(prepared.payload, { stripMetadata: true });\n          metadata.payloadCompression = prepared.compression\n            ? { ...prepared.compression }\n            : null;\n        } else {\n          metadata.compressedPayload = null;\n          metadata.payloadCompression = null;\n        }\n      }\n      serialized[name][AUTO_BACKUP_SNAPSHOT_PROPERTY] = snapshot;\n      return;\n    }\n\n    const normalizedBase = cloneAutoBackupValueWithLegacyNormalization(baseValue, { stripMetadata: true });\n    const diff = computeAutoBackupDiff(normalizedValue, normalizedBase);\n\n    serialized[name] = {};\n    const snapshot = {\n      version: Number.isFinite(metadata.version) ? metadata.version : AUTO_BACKUP_SNAPSHOT_VERSION,\n      snapshotType: 'delta',\n      base: baseName,\n      sequence: Number.isFinite(metadata.sequence) ? metadata.sequence : 1,\n      createdAt,\n      changedKeys: diff.changedKeys,\n      removedKeys: diff.removedKeys,\n    };\n    let payloadSignature;\n    try {\n      payloadSignature = createStableValueSignature(diff.payload);\n    } catch (signatureError) {\n      payloadSignature = null;\n      console.warn(\n        'Unable to compute stable signature for automatic backup delta payload before serialization',\n        signatureError,\n      );\n    }\n    const prepared = prepareAutoBackupSnapshotPayloadForStorage(diff.payload, name, {\n      disableCompression: disableCompressionForName,\n      payloadSignature,\n      existingCompressedPayload: metadata ? metadata.compressedPayload : null,\n      existingPayloadCompression: metadata ? metadata.payloadCompression : null,\n      existingPayloadSignature: metadata ? metadata.payloadSignature : null,\n    });\n    snapshot.payload = prepared.payload;\n    if (prepared.compression) {\n      snapshot.payloadCompression = prepared.compression;\n    }\n    if (metadata) {\n      const resolvedSignature = typeof prepared.payloadSignature === 'string'\n        ? prepared.payloadSignature\n        : payloadSignature;\n      metadata.payloadSignature = resolvedSignature || null;\n      if (prepared.compressed) {\n        metadata.compressedPayload = cloneAutoBackupValue(prepared.payload, { stripMetadata: true });\n        metadata.payloadCompression = prepared.compression\n          ? { ...prepared.compression }\n          : null;\n      } else {\n        metadata.compressedPayload = null;\n        metadata.payloadCompression = null;\n      }\n    }\n    serialized[name][AUTO_BACKUP_SNAPSHOT_PROPERTY] = snapshot;\n  });\n\n  return serialized;\n}\n\nfunction getStorageKeyVariants(key) {\n  if (typeof key !== 'string' || !key) {\n    return [key];\n  }\n\n  const variants = new Set([key]);\n\n  if (key.startsWith('cameraPowerPlanner_')) {\n    variants.add(`cinePowerPlanner_${key.slice('cameraPowerPlanner_'.length)}`);\n  } else if (key.startsWith('cinePowerPlanner_')) {\n    variants.add(`cameraPowerPlanner_${key.slice('cinePowerPlanner_'.length)}`);\n  }\n\n  return Array.from(variants);\n}\n\nvar SETUP_STORAGE_KEY_VARIANTS = new Set(getStorageKeyVariants(SETUP_STORAGE_KEY));\n\nfunction getDeviceStorageKeyVariants() {\n  if (\n    !DEVICE_STORAGE_KEY_VARIANTS\n    || typeof DEVICE_STORAGE_KEY_VARIANTS.has !== 'function'\n  ) {\n    DEVICE_STORAGE_KEY_VARIANTS = new Set(getStorageKeyVariants(DEVICE_STORAGE_KEY));\n  }\n  return DEVICE_STORAGE_KEY_VARIANTS;\n}\n\nfunction isDeviceStorageKeyVariant(key) {\n  if (typeof key !== 'string' || !key) {\n    return false;\n  }\n\n  const variants = getDeviceStorageKeyVariants();\n  if (variants && typeof variants.has === 'function') {\n    return variants.has(key);\n  }\n\n  return key === DEVICE_STORAGE_KEY;\n}\n\nfunction shouldAllowCriticalSweepPrimaryInspection(key) {\n  if (typeof key !== 'string' || !key) {\n    return false;\n  }\n\n  if (!SETUP_STORAGE_KEY_VARIANTS || typeof SETUP_STORAGE_KEY_VARIANTS.has !== 'function') {\n    return false;\n  }\n\n  if (!SETUP_STORAGE_KEY_VARIANTS.has(key)) {\n    return false;\n  }\n\n  if (ACTIVE_PROJECT_COMPRESSION_HOLD_ENABLED) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction inspectSetupStorageForQuotaRecovery(storage, skipKeysSet) {\n  if (!storage || typeof storage.getItem !== 'function') {\n    return;\n  }\n\n  if (!SETUP_STORAGE_KEY_VARIANTS || typeof SETUP_STORAGE_KEY_VARIANTS.forEach !== 'function') {\n    return;\n  }\n\n  const visited = new Set();\n  const skipSet = skipKeysSet && typeof skipKeysSet.has === 'function' ? skipKeysSet : null;\n\n  SETUP_STORAGE_KEY_VARIANTS.forEach((key) => {\n    if (typeof key !== 'string' || !key || visited.has(key)) {\n      return;\n    }\n\n    visited.add(key);\n\n    if (skipSet && skipSet.has(key)) {\n      return;\n    }\n\n    try {\n      storage.getItem(key);\n    } catch (inspectionError) {\n      void inspectionError;\n    }\n  });\n}\n\nvar STORAGE_BACKUP_SUFFIX = '__backup';\nvar MAX_SAVE_ATTEMPTS = 3;\nvar MAX_QUOTA_RECOVERY_STEPS = 100;\nvar STORAGE_MIGRATION_BACKUP_SUFFIX = '__legacyMigrationBackup';\nvar RAW_STORAGE_BACKUP_KEYS = new Set([\n  getCustomFontStorageKeyName(),\n  CUSTOM_LOGO_STORAGE_KEY,\n  DEVICE_SCHEMA_CACHE_KEY,\n  CONTACTS_STORAGE_KEY,\n  OWN_GEAR_STORAGE_KEY,\n  DOCUMENTATION_TRACKER_STORAGE_KEY,\n  MOUNT_VOLTAGE_STORAGE_KEY_NAME,\n  FOCUS_SCALE_STORAGE_KEY_NAME,\n  PRINT_PREFERENCES_STORAGE_KEY,\n]);\n\nArray.from(RAW_STORAGE_BACKUP_KEYS).forEach((key) => {\n  getStorageKeyVariants(key).forEach((variant) => {\n    if (typeof variant === 'string' && variant) {\n      RAW_STORAGE_BACKUP_KEYS.add(variant);\n    }\n  });\n});\n\nvar CRITICAL_BACKUP_KEY_PROVIDERS = [\n  () => ({ key: DEVICE_STORAGE_KEY }),\n  () => ({ key: SETUP_STORAGE_KEY }),\n  () => ({ key: SESSION_STATE_KEY }),\n  () => ({ key: FEEDBACK_STORAGE_KEY }),\n  () => ({\n    key: PROJECT_STORAGE_KEY,\n    valueProvider: () => {\n      // Since we sharded projects, the main PROJECT_STORAGE_KEY is likely empty or gone.\n      // We want to reconstruct the monolithic object so that the backup file contains\n      // all projects, acting as a \"full backup\" safety net.\n      if (typeof readAllProjectsFromStorage === 'function') {\n        try {\n          const { projects } = readAllProjectsFromStorage({ forMutation: false });\n          if (projects && typeof projects === 'object') {\n            // Serialize manually to string as ensureCriticalStorageBackups expects string-ish values\n            return JSON.stringify(projects);\n          }\n        } catch (e) {\n          if (typeof console !== 'undefined' && console.warn) {\n            console.warn('Failed to reconstruct monolithic project backup', e);\n          }\n        }\n      }\n      return null;\n    }\n  }),\n  () => ({ key: FAVORITES_STORAGE_KEY }),\n  () => ({ key: CONTACTS_STORAGE_KEY }),\n  () => ({ key: OWN_GEAR_STORAGE_KEY }),\n  () => ({ key: DOCUMENTATION_TRACKER_STORAGE_KEY }),\n  () => ({ key: DEVICE_SCHEMA_CACHE_KEY }),\n  () => ({ key: AUTO_GEAR_RULES_STORAGE_KEY }),\n  () => ({ key: AUTO_GEAR_SEEDED_STORAGE_KEY }),\n  () => ({ key: AUTO_GEAR_BACKUPS_STORAGE_KEY }),\n  () => ({ key: AUTO_GEAR_PRESETS_STORAGE_KEY }),\n  () => ({ key: AUTO_GEAR_ACTIVE_PRESET_STORAGE_KEY }),\n  () => ({ key: AUTO_GEAR_AUTO_PRESET_STORAGE_KEY }),\n  () => ({ key: AUTO_GEAR_BACKUP_VISIBILITY_STORAGE_KEY }),\n  () => ({ key: AUTO_GEAR_BACKUP_RETENTION_STORAGE_KEY }),\n  () => ({ key: AUTO_GEAR_MONITOR_DEFAULTS_STORAGE_KEY }),\n  () => ({ key: FULL_BACKUP_HISTORY_STORAGE_KEY }),\n  () => ({ key: CUSTOM_LOGO_STORAGE_KEY }),\n  () => ({ key: getCustomFontStorageKeyName() }),\n  () => ({ key: 'darkMode' }),\n  () => ({ key: 'pinkMode' }),\n  () => ({ key: 'highContrast' }),\n  () => ({ key: 'reduceMotion' }),\n  () => ({ key: 'relaxedSpacing' }),\n  () => ({ key: 'showAutoBackups' }),\n  () => ({ key: 'accentColor' }),\n  () => ({ key: 'fontSize' }),\n  () => ({ key: 'fontFamily' }),\n  () => ({ key: 'language' }),\n  () => ({ key: 'iosPwaHelpShown' }),\n  () => ({ key: PRINT_PREFERENCES_STORAGE_KEY }),\n  () => ({ key: TEMPERATURE_UNIT_STORAGE_KEY_NAME }),\n  () => ({ key: getMountVoltageStorageKeyName(), backupKey: getMountVoltageStorageBackupKeyName() }),\n];\n\nfunction createCriticalStorageEntry(candidate, options = {}) {\n  if (!candidate || typeof candidate !== 'object') {\n    return null;\n  }\n\n  const { key, backupKey, storage = null } = candidate;\n  if (typeof key !== 'string' || !key) {\n    return null;\n  }\n\n  const resolvedBackupKey = typeof backupKey === 'string' && backupKey\n    ? backupKey\n    : `${key}${STORAGE_BACKUP_SUFFIX}`;\n\n  return {\n    key,\n    backupKey: resolvedBackupKey,\n    storage,\n    label: typeof options.label === 'string' ? options.label : key,\n    valueProvider: typeof candidate.valueProvider === 'function' ? candidate.valueProvider : null,\n  };\n}\n\nfunction gatherCriticalStorageEntries(options = {}) {\n  const entries = [];\n  const seen = new Set();\n\n  const pushEntry = (entry) => {\n    if (!entry) {\n      return;\n    }\n\n    const variants = getStorageKeyVariants(entry.key);\n    const expectedBaseBackupKey = `${entry.key}${STORAGE_BACKUP_SUFFIX}`;\n\n    for (let index = 0; index < variants.length; index += 1) {\n      const variantKey = variants[index];\n      if (typeof variantKey !== 'string' || !variantKey) {\n        continue;\n      }\n\n      let resolvedBackupKey = entry.backupKey;\n      if (variantKey !== entry.key) {\n        if (entry.backupKey === expectedBaseBackupKey) {\n          resolvedBackupKey = `${variantKey}${STORAGE_BACKUP_SUFFIX}`;\n        }\n      }\n\n      const variantEntry = variantKey === entry.key\n        ? entry\n        : {\n          ...entry,\n          key: variantKey,\n          backupKey: resolvedBackupKey,\n        };\n\n      const storageId = variantEntry.storage || null;\n      const id = `${variantEntry.key}__${storageId ? String(storageId) : 'default'}`;\n      if (seen.has(id)) {\n        continue;\n      }\n\n      seen.add(id);\n      entries.push(variantEntry);\n    }\n  };\n\n  for (let i = 0; i < CRITICAL_BACKUP_KEY_PROVIDERS.length; i += 1) {\n    const provider = CRITICAL_BACKUP_KEY_PROVIDERS[i];\n    if (typeof provider !== 'function') {\n      continue;\n    }\n    let result;\n    try {\n      result = provider(options);\n    } catch (providerError) {\n      var providerDetail = {\n        event: 'critical-storage',\n        action: 'collect-keys',\n        reason: 'provider-error',\n        storageType: getActiveStorageType(options && options.storage ? options.storage : null),\n        error: sanitizeStorageError(providerError),\n      };\n      logStorageEvent(\n        'warn',\n        'Critical storage key provider failed',\n        providerDetail,\n        { event: 'critical-storage', stage: 'gather' },\n        function logProviderErrorToConsole() {\n          if (typeof console !== 'undefined' && typeof console.warn === 'function') {\n            console.warn('Critical storage key provider failed', providerError);\n          }\n        },\n      );\n      continue;\n    }\n    const entry = createCriticalStorageEntry(result, options);\n    if (entry) {\n      pushEntry(entry);\n    }\n  }\n\n  return entries;\n}\n\nlet lastCriticalStorageGuardResult = null;\n\nfunction registerCriticalStorageGuardResult(result) {\n  lastCriticalStorageGuardResult = result;\n  if (!GLOBAL_SCOPE || typeof GLOBAL_SCOPE !== 'object') {\n    return;\n  }\n\n  try {\n    GLOBAL_SCOPE.__cineCriticalStorageGuard = result;\n  } catch (exposeError) {\n    void exposeError;\n    try {\n      Object.defineProperty(GLOBAL_SCOPE, '__cineCriticalStorageGuard', {\n        configurable: true,\n        writable: true,\n        value: result,\n      });\n    } catch (definitionError) {\n      void definitionError;\n    }\n  }\n}\n\nfunction ensureCriticalStorageBackups(options = {}) {\n  let safeStorage = options && options.storage ? options.storage : null;\n  if (!safeStorage) {\n    try {\n      safeStorage = getSafeLocalStorage();\n    } catch (guardError) {\n      var guardDetail = {\n        event: 'critical-storage',\n        action: 'resolve-storage',\n        reason: 'resolve-failed',\n        storageType: getActiveStorageType(options && options.storage ? options.storage : null),\n        error: sanitizeStorageError(guardError),\n      };\n      logStorageEvent(\n        'warn',\n        'Unable to resolve safe storage while ensuring backups',\n        guardDetail,\n        { event: 'critical-storage', stage: 'ensure' },\n        function logGuardErrorToConsole() {\n          if (typeof console !== 'undefined' && typeof console.warn === 'function') {\n            console.warn('Unable to resolve safe storage while ensuring backups', guardError);\n          }\n        },\n      );\n      safeStorage = null;\n    }\n  }\n\n  const summary = {\n    ensured: [],\n    skipped: [],\n    errors: [],\n    timestamp: new Date().toISOString(),\n    storageType: safeLocalStorageInfo && safeLocalStorageInfo.type ? safeLocalStorageInfo.type : 'unknown',\n  };\n\n  const entries = gatherCriticalStorageEntries(options);\n  const targetStorage = safeStorage && typeof safeStorage.getItem === 'function'\n    ? safeStorage\n    : null;\n\n  for (let index = 0; index < entries.length; index += 1) {\n    const entry = entries[index];\n    const storage = entry.storage && typeof entry.storage.getItem === 'function'\n      ? entry.storage\n      : targetStorage;\n\n    if (!storage || typeof storage.getItem !== 'function' || typeof storage.setItem !== 'function') {\n      summary.skipped.push({ key: entry.key, reason: 'unavailable-storage' });\n      continue;\n    }\n\n    let primaryValue;\n    try {\n      if (entry.valueProvider) {\n        primaryValue = entry.valueProvider();\n      } else {\n        primaryValue = storage.getItem(entry.key);\n      }\n    } catch (readError) {\n      summary.errors.push({ key: entry.key, reason: 'read-failed', error: readError });\n      var primaryReadDetail = {\n        event: 'critical-storage',\n        action: 'inspect-primary',\n        key: entry.key,\n        storageType: getActiveStorageType(storage),\n        reason: 'read-failed',\n        error: sanitizeStorageError(readError),\n      };\n      logStorageEvent(\n        'warn',\n        'Critical storage guard could not inspect ' + entry.key,\n        primaryReadDetail,\n        { event: 'critical-storage', stage: 'ensure' },\n        function logPrimaryReadFailureToConsole() {\n          if (typeof console !== 'undefined' && typeof console.warn === 'function') {\n            console.warn('Critical storage guard could not inspect ' + entry.key, readError);\n          }\n        },\n      );\n      continue;\n    }\n\n    if (primaryValue === null || primaryValue === undefined) {\n      summary.skipped.push({ key: entry.key, reason: 'missing' });\n      continue;\n    }\n\n    let backupValue;\n    try {\n      backupValue = storage.getItem(entry.backupKey);\n    } catch (backupReadError) {\n      summary.errors.push({ key: entry.key, reason: 'backup-read-failed', error: backupReadError });\n      var backupReadDetail = {\n        event: 'critical-storage',\n        action: 'inspect-backup',\n        key: entry.key,\n        backupKey: entry.backupKey,\n        storageType: getActiveStorageType(storage),\n        reason: 'backup-read-failed',\n        error: sanitizeStorageError(backupReadError),\n      };\n      logStorageEvent(\n        'warn',\n        'Critical storage guard could not read backup for ' + entry.key,\n        backupReadDetail,\n        { event: 'critical-storage', stage: 'ensure' },\n        function logBackupReadFailureToConsole() {\n          if (typeof console !== 'undefined' && typeof console.warn === 'function') {\n            console.warn('Critical storage guard could not read backup for ' + entry.key, backupReadError);\n          }\n        },\n      );\n      continue;\n    }\n\n    if (typeof backupValue === 'string') {\n      summary.skipped.push({ key: entry.key, reason: 'exists' });\n      continue;\n    }\n\n    const stringPrimaryValue = typeof primaryValue === 'string'\n      ? primaryValue\n      : primaryValue === null || primaryValue === undefined\n        ? ''\n        : String(primaryValue);\n\n    const tryStoreBackup = (candidate) => {\n      try {\n        storage.setItem(entry.backupKey, candidate);\n        return { success: true, error: null };\n      } catch (error) {\n        return { success: false, error };\n      }\n    };\n\n    const recordError = (error, reason = 'backup-write-failed') => {\n      summary.errors.push({ key: entry.key, reason, error });\n      var mirrorDetail = {\n        event: 'critical-storage',\n        action: 'mirror-backup',\n        key: entry.key,\n        backupKey: entry.backupKey,\n        storageType: getActiveStorageType(storage),\n        reason: reason,\n        error: sanitizeStorageError(error),\n      };\n      if (compressionInfo) {\n        mirrorDetail.compressed = true;\n      }\n      logStorageEvent(\n        'error',\n        'Critical storage guard could not mirror ' + entry.key,\n        mirrorDetail,\n        { event: 'critical-storage', stage: 'ensure' },\n        function logMirrorErrorToConsole() {\n          if (typeof console !== 'undefined' && typeof console.error === 'function') {\n            console.error('Critical storage guard could not mirror ' + entry.key, error);\n          }\n        },\n      );\n    };\n\n    const shouldAttemptCompression = typeof stringPrimaryValue === 'string'\n      && stringPrimaryValue\n      && !stringPrimaryValue.includes(`\"${STORAGE_COMPRESSION_FLAG_KEY}\":true`)\n      && !isDeviceStorageKeyVariant(entry.key);\n\n    let candidateValue = stringPrimaryValue;\n    let compressionInfo = null;\n    let writeResult = tryStoreBackup(candidateValue);\n\n    if (!writeResult.success && writeResult.error) {\n      if (!isQuotaExceededError(writeResult.error)) {\n        recordError(writeResult.error);\n        continue;\n      }\n\n      if (shouldAttemptCompression) {\n        const compressedCandidate = createCompressedJsonStorageCandidate(stringPrimaryValue);\n        if (compressedCandidate && typeof compressedCandidate.serialized === 'string' && compressedCandidate.serialized) {\n          candidateValue = compressedCandidate.serialized;\n          compressionInfo = compressedCandidate;\n          writeResult = tryStoreBackup(candidateValue);\n        }\n      }\n\n      if (!writeResult.success && writeResult.error && isQuotaExceededError(writeResult.error)) {\n        const skipKeys = new Set();\n\n        if (typeof entry.backupKey === 'string' && entry.backupKey) {\n          skipKeys.add(entry.backupKey);\n        }\n\n        const shouldInspectPrimaryDuringSweep = shouldAllowCriticalSweepPrimaryInspection(entry.key);\n        if (!shouldInspectPrimaryDuringSweep && typeof entry.key === 'string' && entry.key) {\n          skipKeys.add(entry.key);\n        }\n\n        if (!shouldInspectPrimaryDuringSweep && !ACTIVE_PROJECT_COMPRESSION_HOLD_ENABLED) {\n          inspectSetupStorageForQuotaRecovery(storage, skipKeys);\n        }\n\n        const sweepResult = attemptStorageCompressionSweep(storage, { skipKeys: Array.from(skipKeys) });\n        if (sweepResult && sweepResult.success) {\n          writeResult = tryStoreBackup(candidateValue);\n        }\n      }\n\n      if (!writeResult.success) {\n        recordError(writeResult.error, isQuotaExceededError(writeResult.error) ? 'backup-quota-exceeded' : 'backup-write-failed');\n        if (isQuotaExceededError(writeResult.error)) {\n          alertStorageError('critical-backup-quota');\n        }\n        continue;\n      }\n    }\n\n    summary.ensured.push({\n      key: entry.key,\n      backupKey: entry.backupKey,\n      compressed: Boolean(compressionInfo),\n    });\n\n    if (\n      compressionInfo\n      && typeof compressionInfo.originalLength === 'number'\n      && typeof compressionInfo.wrappedLength === 'number'\n    ) {\n      const savings = compressionInfo.originalLength - compressionInfo.wrappedLength;\n      const percent = compressionInfo.originalLength > 0\n        ? Math.round((savings / compressionInfo.originalLength) * 100)\n        : 0;\n      const message = `Stored compressed critical backup for ${entry.key}, reducing storage usage by ${savings} characters (${percent}%).`;\n      logCompressionSavingsEvent('critical-backup', entry.key, message, savings, percent);\n    }\n  }\n\n  registerCriticalStorageGuardResult(summary);\n\n  if (summary.ensured.length) {\n    var ensuredDetail = {\n      event: 'critical-storage',\n      action: 'mirror-summary',\n      storageType: summary.storageType || getActiveStorageType(),\n      count: summary.ensured.length,\n      timestamp: summary.timestamp,\n      entries: summary.ensured.map(function mapEnsured(entry) {\n        return {\n          key: entry.key,\n          backupKey: entry.backupKey,\n          compressed: Boolean(entry.compressed),\n        };\n      }),\n    };\n    logStorageEvent(\n      'info',\n      'Critical storage guard mirrored backup copies',\n      ensuredDetail,\n      { event: 'critical-storage', stage: 'ensure' },\n      function logEnsuredSummaryToConsole() {\n        if (typeof console !== 'undefined' && typeof console.info === 'function') {\n          const mirroredDetails = summary.ensured.map((entry) => ({\n            key: entry.key,\n            backupKey: entry.backupKey,\n          }));\n          console.info('Critical storage guard mirrored backup copies', {\n            count: summary.ensured.length,\n            entries: mirroredDetails,\n          });\n        }\n      },\n    );\n  }\n\n  if (summary.errors.length) {\n    var errorDetail = {\n      event: 'critical-storage',\n      action: 'mirror-summary',\n      storageType: summary.storageType || getActiveStorageType(),\n      count: summary.errors.length,\n      timestamp: summary.timestamp,\n      reason: 'errors-detected',\n      entries: summary.errors.map(function mapErrors(entry) {\n        return {\n          key: entry && entry.key,\n          reason: entry && entry.reason,\n          error: sanitizeStorageError(entry && entry.error),\n        };\n      }),\n    };\n    logStorageEvent(\n      'warn',\n      'Critical storage guard encountered issues',\n      errorDetail,\n      { event: 'critical-storage', stage: 'ensure' },\n      function logErrorSummaryToConsole() {\n        if (typeof console !== 'undefined' && typeof console.warn === 'function') {\n          console.warn('Critical storage guard encountered issues', summary.errors);\n        }\n      },\n    );\n  }\n\n  return summary;\n}\n\nfunction getLastCriticalStorageGuardResult() {\n  return lastCriticalStorageGuardResult;\n}\n\nvar MAX_MIGRATION_BACKUP_CLEANUP_STEPS = 10;\nvar MIGRATION_BACKUP_COMPRESSION_ALGORITHM = 'lz-string';\nvar MIGRATION_BACKUP_COMPRESSION_ENCODING = 'json-string';\nvar MIGRATION_BACKUP_COMPRESSION_VARIANTS = [\n  { variant: 'utf16', compress: 'compressToUTF16', decompress: 'decompressFromUTF16' },\n  { variant: 'uri-component', compress: 'compressToEncodedURIComponent', decompress: 'decompressFromEncodedURIComponent' },\n  { variant: 'base64', compress: 'compressToBase64', decompress: 'decompressFromBase64' },\n];\n\nvar STORAGE_COMPRESSION_FLAG_KEY = '__cineStorageCompressed';\nvar STORAGE_COMPRESSION_VERSION = 1;\nvar STORAGE_COMPRESSION_ALGORITHM = 'lz-string';\nvar LEGACY_STORAGE_COMPRESSION_ALGORITHM = 'lz-string-utf16';\nvar STORAGE_COMPRESSION_VARIANTS = MIGRATION_BACKUP_COMPRESSION_VARIANTS;\nvar STORAGE_COMPRESSION_NAMESPACE = 'camera-power-planner:storage-compression';\nvar STORAGE_COMPRESSION_ALGORITHM_LITERAL =\n  typeof JSON !== 'undefined' && JSON && typeof JSON.stringify === 'function'\n    ? JSON.stringify(STORAGE_COMPRESSION_ALGORITHM)\n    : '\"'.concat(String(STORAGE_COMPRESSION_ALGORITHM || ''), '\"');\nvar STORAGE_COMPRESSION_NAMESPACE_LITERAL =\n  typeof JSON !== 'undefined' && JSON && typeof JSON.stringify === 'function'\n    ? JSON.stringify(STORAGE_COMPRESSION_NAMESPACE)\n    : '\"'.concat(String(STORAGE_COMPRESSION_NAMESPACE || ''), '\"');\nvar STORAGE_COMPRESSION_WRAPPER_BASE_LENGTH = computeStorageCompressionWrapperBaseLength();\nvar storageCompressionPatchedStorages = typeof WeakSet === 'function' ? new WeakSet() : null;\nvar STORAGE_COMPRESSION_SWEEP_LIMIT = 40;\nvar STORAGE_COMPRESSION_SWEEP_MIN_SAVINGS = 128;\nvar STORAGE_RAW_GET_ITEM_PROPERTY = '__cineRawGetItem';\nvar STORAGE_PROACTIVE_COMPRESSION_MIN_LENGTH = 1024;\nvar STORAGE_PROACTIVE_COMPRESSION_MIN_SAVINGS = 256;\nvar STORAGE_PROACTIVE_COMPRESSION_MIN_RATIO = 0.08;\n\nfunction getAvailableLZStringCompressionStrategies(variants) {\n  if (!Array.isArray(variants) || !variants.length) {\n    return [];\n  }\n\n  var lzReference = LZString;\n  if (!lzReference) {\n    return [];\n  }\n\n  var cacheKey = getCompressionStrategyCacheKey(variants);\n  var cachedStrategies = readCompressionStrategyCache(cacheKey, lzReference);\n  if (cachedStrategies !== null && cachedStrategies !== undefined) {\n    return cachedStrategies;\n  }\n\n  var available = [];\n  for (var i = 0; i < variants.length; i += 1) {\n    var variant = variants[i];\n    if (!variant) {\n      continue;\n    }\n\n    var compressFn = typeof lzReference[variant.compress] === 'function'\n      ? lzReference[variant.compress]\n      : null;\n    var decompressFn = typeof lzReference[variant.decompress] === 'function'\n      ? lzReference[variant.decompress]\n      : null;\n    var variantLiteral = null;\n    var variantLiteralLength = 0;\n    if (typeof JSON !== 'undefined' && JSON && typeof JSON.stringify === 'function') {\n      try {\n        variantLiteral = JSON.stringify(String(variant.variant || ''));\n        if (typeof variantLiteral === 'string' && variantLiteral) {\n          variantLiteralLength = variantLiteral.length;\n        } else {\n          variantLiteral = null;\n          variantLiteralLength = 0;\n        }\n      } catch (variantLiteralError) {\n        variantLiteral = null;\n        variantLiteralLength = 0;\n        void variantLiteralError;\n      }\n    }\n\n    if (compressFn && decompressFn) {\n      available.push({\n        variant: variant.variant,\n        compress: compressFn,\n        decompress: decompressFn,\n        variantLiteral: variantLiteralLength > 0 ? variantLiteral : null,\n        variantLiteralLength,\n      });\n    }\n  }\n\n  var result = available.length ? available.slice() : [];\n\n  if (cacheKey) {\n    writeCompressionStrategyCache(cacheKey, lzReference, result);\n  }\n\n  return result;\n}\n\nfunction tryDecompressWithStrategies(data, variants, preferredVariant, contextLabel) {\n  if (typeof data !== 'string' || !data) {\n    return { success: false };\n  }\n\n  var available = getAvailableLZStringCompressionStrategies(variants);\n  if (!available.length) {\n    return { success: false };\n  }\n\n  var attempts = [];\n  if (preferredVariant) {\n    var preferred = null;\n    for (var i = 0; i < available.length; i += 1) {\n      if (available[i].variant === preferredVariant) {\n        preferred = available[i];\n        break;\n      }\n    }\n    if (preferred) {\n      attempts.push(preferred);\n    } else if (typeof console !== 'undefined' && typeof console.warn === 'function') {\n      console.warn(\"Compression variant \"\n        .concat(preferredVariant, \" is unavailable while reading \"\n        ).concat(contextLabel || 'compressed payload', \".\"));\n    }\n  }\n\n  for (var j = 0; j < available.length; j += 1) {\n    if (!preferredVariant || available[j].variant !== preferredVariant) {\n      attempts.push(available[j]);\n    }\n  }\n\n  var lastError = null;\n  for (var k = 0; k < attempts.length; k += 1) {\n    var strategy = attempts[k];\n    try {\n      var decompressed = strategy.decompress(data);\n      if (typeof decompressed === 'string' && decompressed) {\n        return { success: true, value: decompressed, variant: strategy.variant };\n      }\n    } catch (error) {\n      lastError = error;\n      if (typeof console !== 'undefined' && typeof console.warn === 'function') {\n        console.warn(\"Unable to decompress \"\n          .concat(contextLabel || 'compressed payload', \" with \")\n          .concat(strategy.variant, \" variant\"), error);\n      }\n    }\n  }\n\n  return { success: false, error: lastError };\n}\n\nfunction canUseMigrationBackupCompression() {\n  return getAvailableLZStringCompressionStrategies(MIGRATION_BACKUP_COMPRESSION_VARIANTS).length > 0;\n}\n\nfunction tryCreateCompressedMigrationBackupCandidate(serializedPayload, createdAt) {\n  if (typeof serializedPayload !== 'string' || !serializedPayload) {\n    return null;\n  }\n  if (!canUseMigrationBackupCompression()) {\n    return null;\n  }\n\n  var cached = readCompressionCandidateCacheEntry(\n    MIGRATION_BACKUP_COMPRESSION_CANDIDATE_CACHE,\n    serializedPayload,\n  );\n  if (cached.hit) {\n    return cached.candidate;\n  }\n\n  var bestCandidate = null;\n  var strategies = getAvailableLZStringCompressionStrategies(MIGRATION_BACKUP_COMPRESSION_VARIANTS);\n\n  if (!strategies.length) {\n    return null;\n  }\n\n  for (var i = 0; i < strategies.length; i += 1) {\n    var strategy = strategies[i];\n    var compressed = null;\n    try {\n      compressed = strategy.compress(serializedPayload);\n    } catch (compressionError) {\n      console.warn(\"Unable to compress migration backup payload with \"\n        .concat(strategy.variant, \" variant\"), compressionError);\n      continue;\n    }\n\n    if (typeof compressed !== 'string' || !compressed || compressed.length >= serializedPayload.length) {\n      continue;\n    }\n\n    var record = {\n      createdAt: createdAt,\n      compression: MIGRATION_BACKUP_COMPRESSION_ALGORITHM,\n      compressionVariant: strategy.variant,\n      encoding: MIGRATION_BACKUP_COMPRESSION_ENCODING,\n      data: compressed,\n      originalSize: serializedPayload.length,\n      compressedSize: compressed.length,\n    };\n\n    var serializedCompressedPayload;\n    try {\n      serializedCompressedPayload = JSON.stringify(record);\n    } catch (serializationError) {\n      console.warn('Unable to serialize compressed migration backup payload', serializationError);\n      continue;\n    }\n\n    if (typeof serializedCompressedPayload !== 'string' || !serializedCompressedPayload) {\n      continue;\n    }\n\n    if (serializedCompressedPayload.length >= serializedPayload.length) {\n      continue;\n    }\n\n    if (!bestCandidate || serializedCompressedPayload.length < bestCandidate.serializedLength) {\n      bestCandidate = {\n        serialized: serializedCompressedPayload,\n        serializedLength: serializedCompressedPayload.length,\n        originalSize: serializedPayload.length,\n        compressedSize: compressed.length,\n        variant: strategy.variant,\n      };\n    }\n  }\n\n  writeCompressionCandidateCacheEntry(\n    MIGRATION_BACKUP_COMPRESSION_CANDIDATE_CACHE,\n    serializedPayload,\n    bestCandidate,\n  );\n\n  return bestCandidate;\n}\n\nfunction parseMigrationBackupMetadata(raw) {\n  if (typeof raw !== 'string' || !raw) {\n    return { createdAt: 0, size: typeof raw === 'string' ? raw.length : 0 };\n  }\n\n  const metadata = { createdAt: 0, size: raw.length };\n\n  try {\n    const parsed = JSON.parse(raw);\n    if (parsed && typeof parsed === 'object') {\n      let candidate = null;\n      if (typeof parsed.createdAt === 'string') {\n        candidate = parsed.createdAt.trim();\n      } else if (\n        typeof parsed.createdAt === 'number'\n        && Number.isFinite(parsed.createdAt)\n      ) {\n        metadata.createdAt = parsed.createdAt;\n      }\n\n      if (candidate) {\n        const timestamp = Date.parse(candidate);\n        if (!Number.isNaN(timestamp)) {\n          metadata.createdAt = timestamp;\n        }\n      } else {\n        for (let i = 0; i < MIGRATION_BACKUP_LEGACY_CREATED_AT_KEYS.length; i += 1) {\n          const key = MIGRATION_BACKUP_LEGACY_CREATED_AT_KEYS[i];\n          if (typeof parsed[key] === 'string') {\n            const trimmed = parsed[key].trim();\n            if (trimmed) {\n              const timestamp = Date.parse(trimmed);\n              if (!Number.isNaN(timestamp)) {\n                metadata.createdAt = timestamp;\n                break;\n              }\n            }\n          } else if (\n            typeof parsed[key] === 'number'\n            && Number.isFinite(parsed[key])\n          ) {\n            metadata.createdAt = parsed[key];\n            break;\n          }\n        }\n      }\n    }\n  } catch (error) {\n    void error;\n  }\n\n  return metadata;\n}\n\nfunction canUseJsonValueCompression() {\n  return canUseMigrationBackupCompression();\n}\n\nfunction createCompressedJsonStorageCandidate(serialized) {\n  if (typeof serialized !== 'string' || !serialized) {\n    return null;\n  }\n  if (!canUseJsonValueCompression()) {\n    return null;\n  }\n\n  var cached = readCompressionCandidateCacheEntry(STORAGE_COMPRESSION_CANDIDATE_CACHE, serialized);\n  if (cached.hit) {\n    return cached.candidate;\n  }\n\n  var strategies = getAvailableLZStringCompressionStrategies(STORAGE_COMPRESSION_VARIANTS);\n  if (!strategies.length) {\n    return null;\n  }\n\n  var baseWrapperLength =\n    typeof STORAGE_COMPRESSION_WRAPPER_BASE_LENGTH === 'number'\n      ? STORAGE_COMPRESSION_WRAPPER_BASE_LENGTH\n      : 0;\n  var best = null;\n  var bestSerialized = null;\n  var bestCompressedLiteral = null;\n  var bestVariantLiteral = null;\n  var originalLengthDigits = String(serialized.length).length;\n  for (var i = 0; i < strategies.length; i += 1) {\n    var strategy = strategies[i];\n    var compressed = null;\n    try {\n      compressed = strategy.compress(serialized);\n    } catch (compressionError) {\n      console.warn('Unable to compress storage payload with '\n        .concat(strategy.variant, ' variant'), compressionError);\n      continue;\n    }\n\n    if (typeof compressed !== 'string' || !compressed) {\n      continue;\n    }\n\n    var compressedLiteral;\n    try {\n      compressedLiteral = JSON.stringify(compressed);\n    } catch (compressedLiteralError) {\n      console.warn(\n        'Unable to serialize compressed storage payload candidate',\n        compressedLiteralError,\n      );\n      continue;\n    }\n\n    if (typeof compressedLiteral !== 'string' || !compressedLiteral) {\n      continue;\n    }\n\n    var variantLiteral =\n      typeof strategy.variantLiteral === 'string' && strategy.variantLiteral\n        ? strategy.variantLiteral\n        : null;\n    var variantLiteralLength =\n      typeof strategy.variantLiteralLength === 'number' && strategy.variantLiteralLength > 0\n        ? strategy.variantLiteralLength\n        : 0;\n    if (!variantLiteral) {\n      if (typeof JSON !== 'undefined' && JSON && typeof JSON.stringify === 'function') {\n        try {\n          variantLiteral = JSON.stringify(String(strategy.variant || ''));\n          variantLiteralLength =\n            typeof variantLiteral === 'string' && variantLiteral ? variantLiteral.length : 0;\n        } catch (variantLiteralError) {\n          variantLiteral = null;\n          variantLiteralLength = 0;\n          void variantLiteralError;\n        }\n      }\n    }\n\n    var candidateSerialized = null;\n    var candidateLength = Number.POSITIVE_INFINITY;\n\n    if (baseWrapperLength > 0 && variantLiteralLength > 0) {\n      var compressedLengthDigits = String(compressed.length).length;\n      candidateLength =\n        baseWrapperLength\n        + compressedLiteral.length\n        + originalLengthDigits\n        + compressedLengthDigits\n        + variantLiteralLength;\n    } else {\n      var legacyWrapper = {\n        [STORAGE_COMPRESSION_FLAG_KEY]: true,\n        version: STORAGE_COMPRESSION_VERSION,\n        algorithm: STORAGE_COMPRESSION_ALGORITHM,\n        namespace: STORAGE_COMPRESSION_NAMESPACE,\n        data: compressed,\n        originalLength: serialized.length,\n        compressedPayloadLength: compressed.length,\n        compressionVariant: strategy.variant,\n      };\n\n      try {\n        candidateSerialized = JSON.stringify(legacyWrapper);\n      } catch (serializationError) {\n        console.warn('Unable to serialize compressed storage payload wrapper', serializationError);\n        continue;\n      }\n\n      if (typeof candidateSerialized !== 'string' || !candidateSerialized) {\n        continue;\n      }\n\n      candidateLength = candidateSerialized.length;\n    }\n\n    if (!(candidateLength < serialized.length)) {\n      continue;\n    }\n\n    if (!best || candidateLength < best.wrappedLength) {\n      best = {\n        originalLength: serialized.length,\n        wrappedLength: candidateLength,\n        compressedPayloadLength: compressed.length,\n        compressionVariant: strategy.variant,\n      };\n      bestSerialized = candidateSerialized;\n      bestCompressedLiteral = compressedLiteral;\n      bestVariantLiteral = variantLiteral;\n    }\n  }\n\n  if (best && (!bestSerialized || typeof bestSerialized !== 'string')) {\n    if (typeof bestCompressedLiteral !== 'string' || !bestCompressedLiteral) {\n      best = null;\n    } else {\n      var finalVariantLiteral;\n      if (typeof bestVariantLiteral === 'string' && bestVariantLiteral) {\n        finalVariantLiteral = bestVariantLiteral;\n      } else if (typeof JSON !== 'undefined' && JSON && typeof JSON.stringify === 'function') {\n        try {\n          finalVariantLiteral = JSON.stringify(String(best.compressionVariant || ''));\n        } catch (variantLiteralError) {\n          finalVariantLiteral = null;\n          void variantLiteralError;\n        }\n      }\n\n      if (typeof finalVariantLiteral !== 'string' || !finalVariantLiteral) {\n        best = null;\n      } else {\n        var serializedWrapper =\n          '{\"'\n            .concat(STORAGE_COMPRESSION_FLAG_KEY, '\":true,\"version\":')\n            .concat(String(STORAGE_COMPRESSION_VERSION), ',\"algorithm\":')\n            .concat(STORAGE_COMPRESSION_ALGORITHM_LITERAL, ',\"namespace\":')\n            .concat(STORAGE_COMPRESSION_NAMESPACE_LITERAL, ',\"data\":')\n            .concat(bestCompressedLiteral, ',\"originalLength\":')\n            .concat(String(best.originalLength), ',\"compressedPayloadLength\":')\n            .concat(String(best.compressedPayloadLength), ',\"compressionVariant\":')\n            .concat(finalVariantLiteral, '}');\n\n        bestSerialized = serializedWrapper;\n      }\n    }\n  }\n\n  if (\n    best\n    && bestSerialized\n    && typeof bestSerialized === 'string'\n    && bestSerialized.length < best.originalLength\n  ) {\n    best.serialized = bestSerialized;\n    best.wrappedLength = bestSerialized.length;\n  } else {\n    best = null;\n  }\n\n  writeCompressionCandidateCacheEntry(STORAGE_COMPRESSION_CANDIDATE_CACHE, serialized, best);\n\n  return best;\n}\n\nfunction decodeCompressedJsonStorageValue(raw) {\n  if (typeof raw !== 'string') {\n    return { success: false };\n  }\n\n  if (!raw || raw.charCodeAt(0) !== 123) {\n    return { success: false };\n  }\n\n  if (\n    !raw.includes(`\"${STORAGE_COMPRESSION_FLAG_KEY}\":true`)\n    || !raw.includes(`\"namespace\":\"${STORAGE_COMPRESSION_NAMESPACE}`)\n  ) {\n    return { success: false };\n  }\n\n  let parsed;\n  try {\n    parsed = JSON.parse(raw);\n  } catch (parseError) {\n    return { success: false, error: parseError };\n  }\n\n  if (!parsed || parsed[STORAGE_COMPRESSION_FLAG_KEY] !== true) {\n    return { success: false };\n  }\n\n  if (parsed.namespace !== STORAGE_COMPRESSION_NAMESPACE) {\n    return { success: false };\n  }\n\n  if (parsed.version !== STORAGE_COMPRESSION_VERSION) {\n    console.warn('Unsupported storage compression version', parsed.version);\n    return { success: false };\n  }\n\n  if (\n    parsed.algorithm !== STORAGE_COMPRESSION_ALGORITHM\n    && parsed.algorithm !== LEGACY_STORAGE_COMPRESSION_ALGORITHM\n  ) {\n    console.warn('Unsupported storage compression algorithm', parsed.algorithm);\n    return { success: false };\n  }\n\n  if (typeof parsed.data !== 'string' || !parsed.data) {\n    return { success: false };\n  }\n\n  if (!canUseJsonValueCompression()) {\n    console.warn('Compressed storage payload detected but compression library is unavailable.');\n    return { success: false };\n  }\n\n  var preferredVariant = null;\n  if (typeof parsed.compressionVariant === 'string' && parsed.compressionVariant) {\n    preferredVariant = parsed.compressionVariant;\n  } else if (parsed.algorithm === LEGACY_STORAGE_COMPRESSION_ALGORITHM) {\n    preferredVariant = 'utf16';\n  }\n\n  var decoded = tryDecompressWithStrategies(parsed.data, STORAGE_COMPRESSION_VARIANTS, preferredVariant, 'storage payload');\n  if (!decoded.success) {\n    return { success: false, error: decoded.error };\n  }\n\n  if (!parsed.compressionVariant && decoded.variant) {\n    parsed.compressionVariant = decoded.variant;\n  }\n\n  return { success: true, value: decoded.value, metadata: parsed };\n}\n\nfunction restoreCompressedProjectEntry(value, contextName) {\n  if (typeof value === 'string') {\n    const decoded = decodeCompressedJsonStorageValue(value);\n    if (!decoded.success || typeof decoded.value !== 'string') {\n      return { restored: false, value };\n    }\n\n    try {\n      return { restored: true, value: JSON.parse(decoded.value) };\n    } catch (parseError) {\n      console.warn(\n        'Unable to parse decompressed project entry payload',\n        contextName || 'project entry',\n        parseError,\n      );\n      return { restored: false, value };\n    }\n  }\n\n  if (isPlainObject(value) && value[STORAGE_COMPRESSION_FLAG_KEY] === true) {\n    let serialized;\n    try {\n      serialized = JSON.stringify(value);\n    } catch (serializationError) {\n      console.warn(\n        'Unable to reserialize compressed project entry wrapper before restoration',\n        contextName || 'project entry',\n        serializationError,\n      );\n      return { restored: false, value };\n    }\n\n    if (typeof serialized === 'string' && serialized) {\n      return restoreCompressedProjectEntry(serialized, contextName);\n    }\n  }\n\n  return { restored: false, value };\n}\n\nfunction markProjectActivity(name, timestamp) {\n  if (typeof name !== 'string') {\n    return;\n  }\n\n  const recordTime = typeof timestamp === 'number' && Number.isFinite(timestamp)\n    ? timestamp\n    : Date.now();\n\n  const normalized = normalizeProjectStorageKey(name);\n  if (normalized) {\n    projectActivityTimestamps.set(normalized, recordTime);\n    if (normalized !== name) {\n      projectActivityTimestamps.set(name, recordTime);\n    }\n    return;\n  }\n\n  projectActivityTimestamps.set(name, recordTime);\n}\n\nfunction markProjectCollectionActivity(projects, timestamp) {\n  if (!projects || typeof projects !== 'object') {\n    return;\n  }\n\n  const recordTime = typeof timestamp === 'number' && Number.isFinite(timestamp)\n    ? timestamp\n    : Date.now();\n\n  Object.keys(projects).forEach((key) => {\n    if (typeof key !== 'string' || !key || isAutoBackupStorageKey(key)) {\n      return;\n    }\n\n    markProjectActivity(key, recordTime);\n  });\n}\n\nfunction removeProjectActivity(name) {\n  if (typeof name !== 'string') {\n    return;\n  }\n\n  const normalized = normalizeProjectStorageKey(name);\n  projectActivityTimestamps.delete(name);\n  if (normalized && normalized !== name) {\n    projectActivityTimestamps.delete(normalized);\n  }\n}\n\n\n\n\n\nfunction normalizeForcedProjectCompressionKey(name) {\n  if (typeof name !== 'string') {\n    return '';\n  }\n\n  const normalized = normalizeProjectStorageKey(name);\n  return typeof normalized === 'string' && normalized ? normalized : '';\n}\n\nfunction isForcedProjectCompressionLocked(name) {\n  if (!forcedCompressedProjectKeys || typeof forcedCompressedProjectKeys.has !== 'function') {\n    return false;\n  }\n\n  const normalized = normalizeForcedProjectCompressionKey(name);\n  if (!normalized) {\n    return false;\n  }\n\n  try {\n    return forcedCompressedProjectKeys.has(normalized);\n  } catch (error) {\n    void error;\n  }\n\n  return false;\n}\n\n\n\n\n\nfunction ensureProjectEntryUncompressed(value, contextName) {\n  const restored = restoreCompressedProjectEntry(value, contextName);\n  if (restored.restored) {\n    return restored.value;\n  }\n  return value;\n}\n\nfunction ensureProjectEntriesUncompressed(container) {\n  if (!isPlainObject(container)) {\n    return container;\n  }\n\n  Object.keys(container).forEach((key) => {\n    container[key] = ensureProjectEntryUncompressed(container[key], key);\n  });\n\n  return container;\n}\n\n\n\n\n\nfunction registerActiveSetupStorageSkipKeys(skipSet) {\n  if (!skipSet || typeof skipSet.add !== 'function') {\n    return;\n  }\n\n  const keysToSkip = [\n    PROJECT_STORAGE_KEY,\n    `${PROJECT_STORAGE_KEY}${STORAGE_BACKUP_SUFFIX}`,\n    SETUP_STORAGE_KEY,\n    `${SETUP_STORAGE_KEY}${STORAGE_BACKUP_SUFFIX}`,\n  ];\n\n  for (let i = 0; i < keysToSkip.length; i += 1) {\n    const key = keysToSkip[i];\n    if (typeof key === 'string' && key) {\n      skipSet.add(key);\n    }\n  }\n}\n\nfunction registerProtectedCompressionSkipKeys(skipSet) {\n  if (!skipSet || typeof skipSet.add !== 'function') {\n    return;\n  }\n\n  const keysToProtect = [\n    CONTACTS_STORAGE_KEY,\n    OWN_GEAR_STORAGE_KEY,\n    USER_PROFILE_STORAGE_KEY,\n    DEVICE_STORAGE_KEY,\n  ];\n\n  for (let index = 0; index < keysToProtect.length; index += 1) {\n    const key = keysToProtect[index];\n    if (typeof key !== 'string' || !key) {\n      continue;\n    }\n\n    const variants = getStorageKeyVariants(key);\n    for (let variantIndex = 0; variantIndex < variants.length; variantIndex += 1) {\n      const variant = variants[variantIndex];\n      if (typeof variant !== 'string' || !variant) {\n        continue;\n      }\n\n      skipSet.add(variant);\n\n      if (typeof STORAGE_BACKUP_SUFFIX === 'string' && STORAGE_BACKUP_SUFFIX) {\n        skipSet.add(`${variant}${STORAGE_BACKUP_SUFFIX}`);\n      }\n    }\n  }\n}\n\nfunction maybeDecompressStoredString(raw, options) {\n  if (typeof raw !== 'string') {\n    return raw;\n  }\n\n  const decoded = decodeCompressedJsonStorageValue(raw);\n  if (!decoded.success) {\n    return raw;\n  }\n\n  if (options && typeof options.onDecoded === 'function') {\n    try {\n      options.onDecoded(decoded);\n    } catch (callbackError) {\n      console.warn('Error while processing storage decompression callback', callbackError);\n    }\n  }\n\n  return decoded.value;\n}\n\nfunction attemptStorageCompressionSweep(storage, options) {\n  if (\n    !storage\n    || typeof storage.length !== 'number'\n    || typeof storage.key !== 'function'\n  ) {\n    return { success: false, compressed: 0, freed: 0 };\n  }\n\n  if (isSessionStorageInstance(storage)) {\n    // Session storage entries are intentionally left uncompressed to prioritize\n    // short-lived data integrity over quota recoveries. Compressing them risks\n    // losing user context during transient errors, so skip sweeps entirely.\n    return { success: false, compressed: 0, freed: 0 };\n  }\n\n  const { skipKeys = [], limit = STORAGE_COMPRESSION_SWEEP_LIMIT, minSavings = STORAGE_COMPRESSION_SWEEP_MIN_SAVINGS } = options || {};\n\n  const skipSet = new Set();\n  if (ACTIVE_PROJECT_COMPRESSION_HOLD_ENABLED && ACTIVE_PROJECT_COMPRESSION_HOLD_KEY) {\n    skipSet.add(ACTIVE_PROJECT_COMPRESSION_HOLD_KEY);\n  }\n  if (ACTIVE_PROJECT_COMPRESSION_HOLD_ENABLED) {\n    registerActiveSetupStorageSkipKeys(skipSet);\n  }\n  registerProtectedCompressionSkipKeys(skipSet);\n  if (Array.isArray(skipKeys)) {\n    for (let i = 0; i < skipKeys.length; i += 1) {\n      const key = skipKeys[i];\n      if (typeof key === 'string' && key) {\n        skipSet.add(key);\n      }\n    }\n  }\n\n  const minSavingsThreshold = typeof minSavings === 'number' && minSavings > 0 ? minSavings : 0;\n  const total = storage.length;\n  const candidates = [];\n\n  for (let index = 0; index < total; index += 1) {\n    let key;\n    try {\n      key = storage.key(index);\n    } catch (keyError) {\n      void keyError;\n      key = null;\n    }\n\n    if (typeof key !== 'string' || !key || skipSet.has(key)) {\n      continue;\n    }\n\n    let raw;\n    try {\n      raw = storage.getItem(key);\n    } catch (readError) {\n      void readError;\n      continue;\n    }\n\n    if (typeof raw !== 'string' || !raw) {\n      continue;\n    }\n\n    if (raw.includes(`\"${STORAGE_COMPRESSION_FLAG_KEY}\":true`)) {\n      continue;\n    }\n\n    const candidate = createCompressedJsonStorageCandidate(raw);\n    if (!candidate || typeof candidate.serialized !== 'string' || !candidate.serialized) {\n      continue;\n    }\n\n    const savings = typeof candidate.originalLength === 'number' && typeof candidate.wrappedLength === 'number'\n      ? candidate.originalLength - candidate.wrappedLength\n      : 0;\n    if (savings < minSavingsThreshold) {\n      continue;\n    }\n\n    candidates.push({\n      key,\n      serialized: candidate.serialized,\n      savings: savings > 0 ? savings : 0,\n      originalLength: typeof candidate.originalLength === 'number' ? candidate.originalLength : 0,\n    });\n  }\n\n  if (!candidates.length) {\n    return { success: false, compressed: 0, freed: 0 };\n  }\n\n  candidates.sort((a, b) => {\n    if (b.savings !== a.savings) {\n      return b.savings - a.savings;\n    }\n    return b.originalLength - a.originalLength;\n  });\n\n  const upperLimit = typeof limit === 'number' && limit > 0 ? Math.min(limit, candidates.length) : candidates.length;\n\n  let compressedCount = 0;\n  let freedCharacters = 0;\n\n  for (let index = 0; index < candidates.length && compressedCount < upperLimit; index += 1) {\n    const entry = candidates[index];\n    if (!entry || typeof entry.serialized !== 'string' || !entry.serialized) {\n      continue;\n    }\n\n    try {\n      storage.setItem(entry.key, entry.serialized);\n      compressedCount += 1;\n      freedCharacters += entry.savings;\n    } catch (writeError) {\n      void writeError;\n    }\n  }\n\n  if (compressedCount === 0) {\n    return { success: false, compressed: 0, freed: 0 };\n  }\n\n  if (typeof console !== 'undefined' && typeof console.warn === 'function') {\n    if (freedCharacters > 0) {\n      console.warn(\n        `Compressed ${compressedCount} stored entr${compressedCount === 1 ? 'y' : 'ies'} during quota recovery, freeing approximately ${freedCharacters} characters.`,\n      );\n    } else {\n      console.warn(`Compressed ${compressedCount} stored entr${compressedCount === 1 ? 'y' : 'ies'} during quota recovery.`);\n    }\n  }\n\n  return { success: true, compressed: compressedCount, freed: freedCharacters };\n}\n\nfunction decodeStoredValue(raw) {\n  if (raw === null || raw === undefined) {\n    return raw;\n  }\n  return maybeDecompressStoredString(raw);\n}\n\nfunction patchIndividualStorageGetItem(storage) {\n  if (!storage || typeof storage.getItem !== 'function') {\n    return;\n  }\n\n  if (\n    storageCompressionPatchedStorages\n    && typeof storageCompressionPatchedStorages.has === 'function'\n    && storageCompressionPatchedStorages.has(storage)\n  ) {\n    return;\n  }\n\n  const originalGetItem = storage.getItem;\n  const rawGetItem = typeof originalGetItem === 'function'\n    ? function rawStorageGetItem(key) {\n      return originalGetItem.call(this, key);\n    }\n    : null;\n  const patchedGetItem = function patchedStorageGetItem(key) {\n    const rawValue = rawGetItem ? rawGetItem.call(this, key) : undefined;\n    return maybeDecompressStoredString(rawValue);\n  };\n\n  try {\n    Object.defineProperty(storage, 'getItem', {\n      configurable: true,\n      writable: true,\n      value: patchedGetItem,\n    });\n  } catch (defineError) {\n    const suppressDefineWarning =\n      defineError\n      && typeof defineError.message === 'string'\n      && defineError.message.includes('Cannot redefine property');\n    if (!suppressDefineWarning) {\n      console.warn('Unable to redefine storage.getItem descriptor for compression support', defineError);\n    }\n    try {\n      storage.getItem = patchedGetItem;\n    } catch (assignError) {\n      const suppressAssignWarning =\n        assignError\n        && typeof assignError.message === 'string'\n        && assignError.message.includes('Cannot assign to read only property');\n      if (!suppressAssignWarning) {\n        console.warn('Unable to patch storage instance getItem for compression support', assignError);\n      }\n      if (suppressDefineWarning && suppressAssignWarning) {\n        return;\n      }\n      if (!suppressDefineWarning && !suppressAssignWarning) {\n        return;\n      }\n      return;\n    }\n  }\n\n  if (rawGetItem) {\n    try {\n      Object.defineProperty(storage, STORAGE_RAW_GET_ITEM_PROPERTY, {\n        configurable: true,\n        writable: true,\n        value: rawGetItem,\n      });\n    } catch (rawAssignError) {\n      try {\n        storage[STORAGE_RAW_GET_ITEM_PROPERTY] = rawGetItem;\n      } catch (rawStoreError) {\n        void rawStoreError;\n      }\n      void rawAssignError;\n    }\n  }\n\n  if (\n    storageCompressionPatchedStorages\n    && typeof storageCompressionPatchedStorages.add === 'function'\n  ) {\n    try {\n      storageCompressionPatchedStorages.add(storage);\n    } catch (trackError) {\n      void trackError;\n    }\n  }\n}\n\nfunction patchStorageGetItemForCompression() {\n  if (typeof Storage === 'undefined') {\n    const candidates = [];\n    if (GLOBAL_SCOPE && typeof GLOBAL_SCOPE === 'object') {\n      if (GLOBAL_SCOPE.localStorage) {\n        candidates.push(GLOBAL_SCOPE.localStorage);\n      }\n      if (GLOBAL_SCOPE.sessionStorage) {\n        candidates.push(GLOBAL_SCOPE.sessionStorage);\n      }\n    }\n    if (typeof global !== 'undefined' && global && global !== GLOBAL_SCOPE) {\n      if (global.localStorage) {\n        candidates.push(global.localStorage);\n      }\n      if (global.sessionStorage) {\n        candidates.push(global.sessionStorage);\n      }\n    }\n    candidates.forEach(patchIndividualStorageGetItem);\n    return;\n  }\n\n  const prototype = Storage.prototype;\n  if (!prototype || typeof prototype.getItem !== 'function') {\n    return;\n  }\n\n  if (prototype.__cineStorageCompressionPatched) {\n    return;\n  }\n\n  const originalGetItem = prototype.getItem;\n  const rawGetItem = function rawStorageGetItem(key) {\n    return originalGetItem.call(this, key);\n  };\n  const patchedGetItem = function patchedStorageGetItem(key) {\n    const rawValue = rawGetItem.call(this, key);\n    return maybeDecompressStoredString(rawValue);\n  };\n\n  try {\n    Object.defineProperty(prototype, 'getItem', {\n      configurable: true,\n      writable: true,\n      value: patchedGetItem,\n    });\n  } catch (patchError) {\n    console.warn('Unable to patch Storage.getItem for compression support', patchError);\n    return;\n  }\n\n  try {\n    Object.defineProperty(prototype, STORAGE_RAW_GET_ITEM_PROPERTY, {\n      configurable: true,\n      writable: false,\n      value: rawGetItem,\n    });\n  } catch (rawError) {\n    try {\n      prototype[STORAGE_RAW_GET_ITEM_PROPERTY] = rawGetItem;\n    } catch (assignError) {\n      void assignError;\n    }\n    void rawError;\n  }\n\n  try {\n    Object.defineProperty(prototype, '__cineStorageCompressionPatched', {\n      configurable: true,\n      writable: false,\n      value: true,\n    });\n  } catch (flagError) {\n    prototype.__cineStorageCompressionPatched = true;\n    void flagError;\n  }\n\n  const candidates = [];\n  if (GLOBAL_SCOPE && typeof GLOBAL_SCOPE === 'object') {\n    if (GLOBAL_SCOPE.localStorage) {\n      candidates.push(GLOBAL_SCOPE.localStorage);\n    }\n    if (GLOBAL_SCOPE.sessionStorage) {\n      candidates.push(GLOBAL_SCOPE.sessionStorage);\n    }\n  }\n  if (typeof global !== 'undefined' && global && global !== GLOBAL_SCOPE) {\n    if (global.localStorage) {\n      candidates.push(global.localStorage);\n    }\n    if (global.sessionStorage) {\n      candidates.push(global.sessionStorage);\n    }\n  }\n  candidates.forEach(patchIndividualStorageGetItem);\n}\n\nfunction getRawStorageGetter(storage) {\n  if (!storage || typeof storage !== 'object') {\n    return null;\n  }\n\n  const direct = storage[STORAGE_RAW_GET_ITEM_PROPERTY];\n  if (typeof direct === 'function') {\n    return direct;\n  }\n\n  const prototype = Object.getPrototypeOf(storage);\n  if (prototype && typeof prototype[STORAGE_RAW_GET_ITEM_PROPERTY] === 'function') {\n    return prototype[STORAGE_RAW_GET_ITEM_PROPERTY];\n  }\n\n  return null;\n}\n\nfunction readRawStorageValue(storage, key, rawGetterOverride) {\n  if (!storage || typeof key !== 'string' || !key) {\n    return null;\n  }\n\n  const getter = typeof rawGetterOverride === 'function'\n    ? rawGetterOverride\n    : getRawStorageGetter(storage);\n  if (typeof getter !== 'function') {\n    return null;\n  }\n\n  try {\n    return getter.call(storage, key);\n  } catch (error) {\n    void error;\n    return null;\n  }\n}\n\nfunction collectMigrationBackupEntriesForCleanup(storage, excludeKey) {\n  if (!storage) {\n    return [];\n  }\n\n  let snapshot;\n  try {\n    snapshot = snapshotStorageEntries(storage, { suppressAlerts: true });\n  } catch (error) {\n    console.warn('Unable to inspect storage while preparing migration backup cleanup', error);\n    return [];\n  }\n\n  if (!snapshot || typeof snapshot !== 'object') {\n    return [];\n  }\n\n  return Object.keys(snapshot)\n    .filter((candidate) => {\n      if (typeof candidate !== 'string' || !candidate) {\n        return false;\n      }\n      if (!candidate.endsWith(STORAGE_MIGRATION_BACKUP_SUFFIX)) {\n        return false;\n      }\n      if (excludeKey && candidate === excludeKey) {\n        return false;\n      }\n      return true;\n    })\n    .map((candidate) => {\n      const raw = snapshot[candidate];\n      const normalized = typeof raw === 'string' ? raw : raw === null || raw === undefined ? '' : String(raw);\n      const metadata = parseMigrationBackupMetadata(normalized);\n      return {\n        key: candidate,\n        createdAt: metadata.createdAt,\n        size: metadata.size,\n      };\n    })\n    .sort((a, b) => {\n      if (a.createdAt && b.createdAt && a.createdAt !== b.createdAt) {\n        return a.createdAt - b.createdAt;\n      }\n      if (a.createdAt && !b.createdAt) {\n        return -1;\n      }\n      if (!a.createdAt && b.createdAt) {\n        return 1;\n      }\n      if (a.size !== b.size) {\n        return b.size - a.size;\n      }\n      return a.key.localeCompare(b.key);\n    });\n}\n\nfunction pruneMigrationBackupEntriesForCleanup(storage, excludeKey) {\n  const entries = collectMigrationBackupEntriesForCleanup(storage, excludeKey);\n  if (!entries.length) {\n    return [];\n  }\n\n  const removedKeys = [];\n  const target = entries[0];\n  try {\n    storage.removeItem(target.key);\n    removedKeys.push(target.key);\n  } catch (error) {\n    console.warn(`Unable to remove migration backup ${target.key} during cleanup`, error);\n  }\n\n  return removedKeys;\n}\n\nfunction attemptMigrationBackupQuotaRecovery(storage, key, backupKey, tryWrite) {\n  if (!storage || typeof storage.setItem !== 'function') {\n    return { success: false, error: null };\n  }\n\n  const removedBackups = [];\n  let lastError = null;\n\n  if (typeof tryWrite !== 'function') {\n    return { success: false, error: null };\n  }\n\n  const attemptWrite = () => {\n    const result = tryWrite();\n    if (result && typeof result === 'object' && 'error' in result && result.error) {\n      lastError = result.error;\n    }\n    if (result && result.success) {\n      return { success: true, quota: false };\n    }\n    if (result && result.quota) {\n      return { success: false, quota: true, error: result.error || null };\n    }\n    return { success: false, quota: false, error: result && result.error ? result.error : null };\n  };\n\n  if (typeof clearUiCacheStorageEntries === 'function') {\n    let cleared = false;\n    try {\n      clearUiCacheStorageEntries();\n      cleared = true;\n    } catch (clearError) {\n      console.warn('Unable to clear cached UI storage entries before creating migration backup', clearError);\n    }\n\n    if (cleared) {\n      const retryAfterClear = attemptWrite();\n      if (retryAfterClear.success) {\n        console.warn(`Cleared cached planner data to free storage before creating migration backup for ${key}.`);\n        return { success: true, error: null };\n      }\n      if (!retryAfterClear.quota) {\n        return { success: false, error: retryAfterClear.error };\n      }\n    }\n  }\n\n  for (let attempt = 0; attempt < MAX_MIGRATION_BACKUP_CLEANUP_STEPS; attempt += 1) {\n    const removed = pruneMigrationBackupEntriesForCleanup(storage, backupKey);\n    if (!removed.length) {\n      break;\n    }\n    removedBackups.push(...removed);\n    const retry = attemptWrite();\n    if (retry.success) {\n      console.warn(\n        `Removed ${removedBackups.length} older migration backup${removedBackups.length > 1 ? 's' : ''} to free up storage before creating migration backup for ${key}.`,\n        removedBackups,\n      );\n      return { success: true, error: null };\n    }\n    if (!retry.quota) {\n      return { success: false, error: retry.error };\n    }\n  }\n\n  if (removedBackups.length > 0) {\n    console.warn(\n      `Removed ${removedBackups.length} older migration backup${removedBackups.length > 1 ? 's' : ''} while attempting to create migration backup for ${key}, but storage quota is still exceeded.`,\n      removedBackups,\n    );\n  }\n\n  return { success: false, error: lastError };\n}\n\nfunction ensurePreWriteMigrationBackup(storage, key) {\n  if (!storage || typeof storage.getItem !== 'function' || !key) {\n    return null;\n  }\n\n  let rawValue = null;\n  try {\n    rawValue = storage.getItem(key);\n  } catch (inspectionError) {\n    console.warn(`Unable to inspect existing value for ${key} before creating migration backup`, inspectionError);\n    return null;\n  }\n\n  if (rawValue === null || rawValue === undefined) {\n    return null;\n  }\n\n  let parsedValue = rawValue;\n  let normalizedRawValue = rawValue;\n  if (typeof rawValue === 'string' && rawValue) {\n    normalizedRawValue = maybeDecompressStoredString(rawValue);\n    if (typeof normalizedRawValue === 'string' && normalizedRawValue) {\n      try {\n        parsedValue = JSON.parse(normalizedRawValue);\n      } catch (parseError) {\n        void parseError;\n      }\n    } else {\n      parsedValue = normalizedRawValue;\n    }\n  }\n\n  if (\n    parsedValue &&\n    typeof parsedValue === 'object' &&\n    ((Array.isArray(parsedValue) && parsedValue.length === 0) ||\n      (!Array.isArray(parsedValue) && Object.keys(parsedValue).length === 0))\n  ) {\n    return parsedValue;\n  }\n\n  createStorageMigrationBackup(storage, key, parsedValue);\n  return parsedValue;\n}\n\nvar MIGRATION_BACKUP_LEGACY_DATA_KEYS = [\n  'payload',\n  'value',\n  'content',\n  'entries',\n  'snapshot',\n  'state',\n  'record',\n];\n\nvar MIGRATION_BACKUP_LEGACY_CREATED_AT_KEYS = ['iso', 'timestamp', 'time'];\n\nfunction trySerializeMigrationBackupValue(value) {\n  try {\n    return JSON.stringify(value);\n  } catch (serializationError) {\n    console.warn('Unable to serialize normalized migration backup payload', serializationError);\n    return null;\n  }\n}\n\nfunction normalizeLegacyMigrationBackupCreatedAt(value, fallbackIso) {\n  const fallback = typeof fallbackIso === 'string' && fallbackIso\n    ? fallbackIso\n    : null;\n\n  if (typeof value === 'string') {\n    const trimmed = value.trim();\n    if (!trimmed) {\n      return { value: fallback || new Date().toISOString(), changed: true };\n    }\n    const numeric = Number(trimmed);\n    if (!Number.isNaN(numeric) && Number.isFinite(numeric) && String(numeric) === trimmed) {\n      try {\n        return { value: new Date(numeric).toISOString(), changed: true };\n      } catch (error) {\n        void error;\n        return { value: fallback || new Date().toISOString(), changed: true };\n      }\n    }\n    const timestamp = Date.parse(trimmed);\n    if (!Number.isNaN(timestamp)) {\n      try {\n        const iso = new Date(timestamp).toISOString();\n        return { value: iso, changed: iso !== trimmed };\n      } catch (error) {\n        void error;\n        return { value: fallback || new Date().toISOString(), changed: true };\n      }\n    }\n    return { value: trimmed, changed: trimmed !== value };\n  }\n\n  if (typeof value === 'number' && Number.isFinite(value)) {\n    try {\n      return { value: new Date(value).toISOString(), changed: true };\n    } catch (error) {\n      void error;\n      return { value: fallback || new Date().toISOString(), changed: true };\n    }\n  }\n\n  if (value instanceof Date) {\n    const time = value.getTime();\n    if (Number.isFinite(time)) {\n      try {\n        return { value: value.toISOString(), changed: true };\n      } catch (error) {\n        void error;\n        return { value: fallback || new Date().toISOString(), changed: true };\n      }\n    }\n  }\n\n  if (fallback) {\n    return { value: fallback, changed: true };\n  }\n\n  const generated = new Date().toISOString();\n  return { value: generated, changed: true };\n}\n\nfunction normalizeLegacyMigrationBackupValue(rawValue, fallbackIso) {\n  if (typeof rawValue !== 'string' || !rawValue) {\n    return null;\n  }\n\n  const fallback = typeof fallbackIso === 'string' && fallbackIso\n    ? fallbackIso\n    : new Date().toISOString();\n\n  let parsed;\n  try {\n    parsed = JSON.parse(rawValue);\n  } catch (parseError) {\n    void parseError;\n    return trySerializeMigrationBackupValue({ createdAt: fallback, data: rawValue });\n  }\n\n  // If parsed is null/undefined or not object, wrap it\n  if (!parsed || typeof parsed !== 'object') {\n    const dataValue = parsed === undefined ? rawValue : parsed;\n    return trySerializeMigrationBackupValue({ createdAt: fallback, data: dataValue });\n  }\n\n  // If it's an array of backup entries, check if it is already in modern format\n  // If it's an array of backup entries, it's a valid modern format for history.\n  if (Array.isArray(parsed)) {\n    let listChanged = false;\n    const normalizedList = parsed.map((item) => {\n      if (!item || typeof item !== 'object') {\n        listChanged = true;\n        return { createdAt: fallback, data: item };\n      }\n\n      const hasData = Object.prototype.hasOwnProperty.call(item, 'data');\n      const itemCreatedAt = item.createdAt;\n      const { value: normalizedDate, changed: dateChanged } = normalizeLegacyMigrationBackupCreatedAt(\n        itemCreatedAt, fallback\n      );\n\n      if (!hasData) {\n        listChanged = true;\n        // Treat the whole item as data if it's not a valid envelope\n        return { createdAt: normalizedDate, data: item };\n      }\n\n      if (dateChanged || itemCreatedAt !== normalizedDate) {\n        listChanged = true;\n        return { ...item, createdAt: normalizedDate };\n      }\n\n      return item;\n    });\n\n    if (!listChanged) {\n      return null;\n    }\n    return trySerializeMigrationBackupValue(normalizedList);\n  }\n\n  let normalized;\n  let changed = false;\n\n  if (Object.prototype.hasOwnProperty.call(parsed, 'data')) {\n    normalized = { ...parsed };\n  } else {\n    let usedKey = null;\n    for (let i = 0; i < MIGRATION_BACKUP_LEGACY_DATA_KEYS.length; i += 1) {\n      const key = MIGRATION_BACKUP_LEGACY_DATA_KEYS[i];\n      if (Object.prototype.hasOwnProperty.call(parsed, key)) {\n        usedKey = key;\n        break;\n      }\n    }\n\n    if (usedKey) {\n      normalized = { ...parsed };\n      normalized.data = parsed[usedKey];\n      delete normalized[usedKey];\n      changed = true;\n    } else {\n      normalized = { data: parsed };\n      changed = true;\n    }\n  }\n\n  let rawCreatedAt = normalized.createdAt;\n  let createdAtSourceKey = 'createdAt';\n  if (rawCreatedAt === undefined) {\n    for (let i = 0; i < MIGRATION_BACKUP_LEGACY_CREATED_AT_KEYS.length; i += 1) {\n      const key = MIGRATION_BACKUP_LEGACY_CREATED_AT_KEYS[i];\n      if (Object.prototype.hasOwnProperty.call(parsed, key)) {\n        rawCreatedAt = parsed[key];\n        createdAtSourceKey = key;\n        break;\n      }\n    }\n  }\n\n  const { value: createdAt, changed: createdAtChanged } = normalizeLegacyMigrationBackupCreatedAt(\n    rawCreatedAt,\n    fallback,\n  );\n\n  normalized.createdAt = createdAt;\n  if (createdAtSourceKey !== 'createdAt' && createdAtSourceKey && Object.prototype.hasOwnProperty.call(normalized, createdAtSourceKey)) {\n    delete normalized[createdAtSourceKey];\n    changed = true;\n  }\n\n  if (createdAtChanged) {\n    changed = true;\n  }\n\n  if (!changed) {\n    return null;\n  }\n\n  return trySerializeMigrationBackupValue(normalized);\n}\n\nfunction upgradeLegacyMigrationBackupEntry(storage, backupKey, rawValue, fallbackIso) {\n  const normalized = normalizeLegacyMigrationBackupValue(rawValue, fallbackIso);\n  if (normalized === null) {\n    return true;\n  }\n  if (typeof normalized !== 'string' || !normalized) {\n    return false;\n  }\n  if (normalized === rawValue) {\n    return true;\n  }\n  try {\n    storage.setItem(backupKey, normalized);\n    return true;\n  } catch (error) {\n    console.warn(`Unable to normalize legacy migration backup for ${backupKey}`, error);\n    return false;\n  }\n}\n\nfunction createStorageMigrationBackup(storage, key, originalValue) {\n  if (!storage || typeof storage.setItem !== 'function') {\n    return;\n  }\n  if (originalValue === null || originalValue === undefined) {\n    return;\n  }\n\n  const backupKey = `${key}${STORAGE_MIGRATION_BACKUP_SUFFIX}`;\n  let hasExistingBackup = false;\n\n  if (typeof storage.getItem === 'function') {\n    try {\n      const existing = storage.getItem(backupKey);\n      if (existing !== null && existing !== undefined) {\n        hasExistingBackup = true;\n        const fallbackCreatedAt = new Date().toISOString();\n        upgradeLegacyMigrationBackupEntry(storage, backupKey, existing, fallbackCreatedAt);\n      }\n    } catch (inspectionError) {\n      console.warn(`Unable to inspect migration backup for ${key}`, inspectionError);\n    }\n  }\n\n  if (hasExistingBackup) {\n    // If we already have a backup, we append to a list to keep history.\n    try {\n      const existingRaw = storage.getItem(backupKey);\n      const decoded = decodeStoredValue(existingRaw);\n      let existingData = null;\n      try {\n        existingData = JSON.parse(decoded);\n      } catch (jsonError) {\n        void jsonError;\n        existingData = decoded;\n      }\n\n      let list = Array.isArray(existingData) ? existingData : [existingData];\n      const newEntry = { createdAt: new Date().toISOString(), data: originalValue };\n      list.push(newEntry);\n\n      // Limit history size to prevent indefinite growth\n      const MAX_BACKUP_HISTORY = 5;\n      if (list.length > MAX_BACKUP_HISTORY) {\n        list = list.slice(list.length - MAX_BACKUP_HISTORY);\n      }\n\n      const tryStoreList = (candidateList) => {\n        try {\n          storage.setItem(backupKey, JSON.stringify(candidateList));\n          return { success: true };\n        } catch (itemError) {\n          return { success: false, quota: isQuotaExceededError(itemError), error: itemError };\n        }\n      };\n\n      let result = tryStoreList(list);\n\n      // If quota exceeded, try to shrink the list further\n      while (!result.success && result.quota && list.length > 1) {\n        list.shift(); // Remove oldest\n        console.warn(`Pruning oldest migration backup for ${key} due to quota limit.`);\n        result = tryStoreList(list);\n      }\n\n      if (result.success) {\n        return;\n      }\n\n      // If still failing, try to prune OTHER backups\n      if (!result.success && result.quota) {\n        const recovery = attemptMigrationBackupQuotaRecovery(storage, key, backupKey, () => tryStoreList(list));\n        if (recovery && recovery.success) {\n          return;\n        }\n      }\n\n      console.warn('Unable to append to migration backup', result.error);\n      return;\n    } catch (appendError) {\n      console.warn('Unable to append to migration backup', appendError);\n      return;\n    }\n  }\n\n  let serialized;\n  const createdAt = new Date().toISOString();\n  try {\n    serialized = JSON.stringify({\n      createdAt,\n      data: originalValue,\n    });\n  } catch (serializationError) {\n    console.warn(`Unable to serialize migration backup for ${key}`, serializationError);\n    return;\n  }\n\n  const tryStoreSerialized = (candidate, options = {}) => {\n    const { logCompression = false, info = null } = options || {};\n    try {\n      storage.setItem(backupKey, candidate.serialized);\n      if (logCompression && info && !tryStoreSerialized.compressionLogged) {\n        tryStoreSerialized.compressionLogged = true;\n        const storedLength = typeof info.serializedLength === 'number'\n          ? info.serializedLength\n          : info.compressedSize;\n        const rawSavings = info.originalSize - storedLength;\n        const savings = rawSavings > 0 ? rawSavings : 0;\n        const percent = info.originalSize > 0\n          ? Math.round((savings / info.originalSize) * 100)\n          : 0;\n        const message = `Stored compressed migration backup for ${key} to reduce storage usage by ${savings} characters (${percent}%) using ${info.variant || 'unknown'} variant.`;\n        logCompressionSavingsEvent('migration-backup', key, message, savings, percent);\n      }\n      return { success: true, quota: false };\n    } catch (error) {\n      return { success: false, quota: isQuotaExceededError(error), error };\n    }\n  };\n  tryStoreSerialized.compressionLogged = tryStoreSerialized.compressionLogged || false;\n\n  const standardCandidate = { serialized };\n  const standardResult = tryStoreSerialized(standardCandidate);\n  if (standardResult.success) {\n    return;\n  }\n\n  const handleFailure = (error) => {\n    console.warn(`Unable to create migration backup for ${key}`, error);\n  };\n\n  if (!standardResult.quota) {\n    handleFailure(standardResult.error);\n    return;\n  }\n\n  const allowCompressedBackup = !isDeviceStorageKeyVariant(key);\n  const compressedCandidate = allowCompressedBackup\n    ? tryCreateCompressedMigrationBackupCandidate(serialized, createdAt)\n    : null;\n\n  const runRecoveryWith = (candidate, options, fallbackError) => {\n    const recovery = attemptMigrationBackupQuotaRecovery(storage, key, backupKey, () =>\n      tryStoreSerialized(candidate, options),\n    );\n    if (recovery && recovery.success) {\n      return true;\n    }\n    const errorToReport = recovery && recovery.error ? recovery.error : fallbackError;\n    handleFailure(errorToReport);\n    alertStorageError('migration-backup-quota');\n    return false;\n  };\n\n  if (compressedCandidate) {\n    const compressedResult = tryStoreSerialized(compressedCandidate, {\n      logCompression: true,\n      info: compressedCandidate,\n    });\n    if (compressedResult.success) {\n      return;\n    }\n    if (!compressedResult.quota) {\n      handleFailure(compressedResult.error);\n      return;\n    }\n    if (runRecoveryWith(compressedCandidate, { logCompression: true, info: compressedCandidate }, compressedResult.error)) {\n      return;\n    }\n    return;\n  }\n\n  if (runRecoveryWith(standardCandidate, {}, standardResult.error)) {\n    return;\n  }\n}\n\nvar PRIMARY_STORAGE_KEYS = [\n  DEVICE_STORAGE_KEY,\n  SETUP_STORAGE_KEY,\n  SESSION_STATE_KEY,\n  FEEDBACK_STORAGE_KEY,\n  PROJECT_STORAGE_KEY,\n  FAVORITES_STORAGE_KEY,\n  DEVICE_SCHEMA_CACHE_KEY,\n  AUTO_GEAR_RULES_STORAGE_KEY,\n  AUTO_GEAR_SEEDED_STORAGE_KEY,\n  AUTO_GEAR_BACKUPS_STORAGE_KEY,\n  AUTO_GEAR_PRESETS_STORAGE_KEY,\n  AUTO_GEAR_ACTIVE_PRESET_STORAGE_KEY,\n  AUTO_GEAR_AUTO_PRESET_STORAGE_KEY,\n  AUTO_GEAR_BACKUP_VISIBILITY_STORAGE_KEY,\n  AUTO_GEAR_MONITOR_DEFAULTS_STORAGE_KEY,\n  AUTO_GEAR_BACKUP_RETENTION_STORAGE_KEY,\n  FULL_BACKUP_HISTORY_STORAGE_KEY,\n];\n\nvar SIMPLE_STORAGE_KEYS = [\n  CUSTOM_LOGO_STORAGE_KEY,\n  getCustomFontStorageKeyName(),\n  'darkMode',\n  'pinkMode',\n  'highContrast',\n  'reduceMotion',\n  'relaxedSpacing',\n  'showAutoBackups',\n  'accentColor',\n  'fontSize',\n  'fontFamily',\n  'language',\n  'iosPwaHelpShown',\n  CAMERA_COLOR_STORAGE_KEY,\n  TEMPERATURE_UNIT_STORAGE_KEY_NAME,\n];\n\nvar STORAGE_ALERT_FLAG_NAME = '__cameraPowerPlannerStorageAlertShown';\nvar SESSION_FALLBACK_ALERT_FLAG_NAME = '__cameraPowerPlannerSessionFallbackAlertShown';\n\nvar storageErrorAlertShown = false;\nif (GLOBAL_SCOPE) {\n  if (typeof GLOBAL_SCOPE[STORAGE_ALERT_FLAG_NAME] === 'boolean') {\n    storageErrorAlertShown = GLOBAL_SCOPE[STORAGE_ALERT_FLAG_NAME];\n  } else {\n    GLOBAL_SCOPE[STORAGE_ALERT_FLAG_NAME] = false;\n  }\n}\n\nvar sessionFallbackAlertShown = false;\nif (GLOBAL_SCOPE) {\n  if (typeof GLOBAL_SCOPE[SESSION_FALLBACK_ALERT_FLAG_NAME] === 'boolean') {\n    sessionFallbackAlertShown = GLOBAL_SCOPE[SESSION_FALLBACK_ALERT_FLAG_NAME];\n  } else {\n    GLOBAL_SCOPE[SESSION_FALLBACK_ALERT_FLAG_NAME] = false;\n  }\n}\n\nvar DEVICE_COLLECTION_KEYS = [\n  'cameras',\n  'monitors',\n  'video',\n  'viewfinders',\n  'directorMonitors',\n  'iosVideo',\n  'videoAssist',\n  'media',\n  'lenses',\n  'batteries',\n  'batteryHotswaps',\n  'wirelessReceivers',\n];\n\nvar FIZ_COLLECTION_KEYS = ['motors', 'handUnits', 'controllers', 'distance'];\n\nvar ACCESSORY_COLLECTION_KEYS = [\n  'chargers',\n  'cages',\n  'powerPlates',\n  'cameraSupport',\n  'matteboxes',\n  'filters',\n  'rigging',\n  'batteries',\n  'cables',\n  'videoAssist',\n  'media',\n  'cardReaders',\n  'tripodHeads',\n  'tripods',\n  'sliders',\n  'cameraStabiliser',\n  'grip',\n  'carts',\n];\n\nvar getStorageManager = () =>\n  typeof navigator !== 'undefined' &&\n    navigator &&\n    typeof navigator.storage === 'object'\n    ? navigator.storage\n    : null;\n\n// Safely detect usable localStorage. Some environments (like private browsing)\n// may block access and throw errors. If unavailable, fall back to\n// sessionStorage when possible so data persists across reloads within the same\n// tab. When neither storage option is available we fall back to a simple\n// in-memory store to avoid runtime errors even though the data will be lost on\n// reload.\nvar STORAGE_TEST_KEY = '__storage_test__';\n\nvar QUOTA_ERROR_NAMES = new Set([\n  'QuotaExceededError',\n  'NS_ERROR_DOM_QUOTA_REACHED',\n]);\nvar QUOTA_ERROR_CODES = new Set([22, 1014]);\nvar QUOTA_ERROR_NUMBERS = new Set([22, 1014]);\n\nfunction isQuotaExceededError(error) {\n  if (!error || typeof error !== 'object') {\n    return false;\n  }\n  if (typeof error.code === 'number' && QUOTA_ERROR_CODES.has(error.code)) {\n    return true;\n  }\n  if (typeof error.number === 'number' && QUOTA_ERROR_NUMBERS.has(error.number)) {\n    return true;\n  }\n  if (typeof error.name === 'string' && QUOTA_ERROR_NAMES.has(error.name)) {\n    return true;\n  }\n  return false;\n}\n\nfunction hasStoredEntries(storage) {\n  if (!storage) return false;\n\n  try {\n    if (typeof storage.length === 'number' && storage.length > 0) {\n      return true;\n    }\n  } catch (lengthError) {\n    console.warn('Unable to read storage length after quota error', lengthError);\n  }\n\n  if (typeof storage.getItem === 'function') {\n    try {\n      for (let i = 0; i < PRIMARY_STORAGE_KEYS.length; i += 1) {\n        const key = PRIMARY_STORAGE_KEYS[i];\n        const variants = getStorageKeyVariants(key);\n        for (let j = 0; j < variants.length; j += 1) {\n          const candidateKey = variants[j];\n          if (storage.getItem(candidateKey) !== null) {\n            return true;\n          }\n          const backupKey = `${candidateKey}${STORAGE_BACKUP_SUFFIX}`;\n          if (storage.getItem(backupKey) !== null) {\n            return true;\n          }\n        }\n      }\n\n      for (let i = 0; i < SIMPLE_STORAGE_KEYS.length; i += 1) {\n        const key = SIMPLE_STORAGE_KEYS[i];\n        const variants = getStorageKeyVariants(key);\n        for (let j = 0; j < variants.length; j += 1) {\n          const candidateKey = variants[j];\n          if (storage.getItem(candidateKey) !== null) {\n            return true;\n          }\n          if (RAW_STORAGE_BACKUP_KEYS.has(candidateKey)) {\n            const backupKey = `${candidateKey}${STORAGE_BACKUP_SUFFIX}`;\n            if (storage.getItem(backupKey) !== null) {\n              return true;\n            }\n          }\n        }\n      }\n    } catch (inspectionError) {\n      console.warn('Unable to inspect known storage keys after quota error', inspectionError);\n    }\n  }\n\n  if (typeof storage.key === 'function') {\n    try {\n      const length = typeof storage.length === 'number' ? storage.length : 0;\n      for (let index = 0; index < length; index += 1) {\n        const candidate = storage.key(index);\n        if (typeof candidate === 'string' && candidate) {\n          return true;\n        }\n      }\n    } catch (iterationError) {\n      console.warn('Unable to iterate storage keys after quota error', iterationError);\n    }\n  }\n\n  return false;\n}\n\nfunction verifyStorage(storage) {\n  if (!storage) return null;\n  try {\n    storage.setItem(STORAGE_TEST_KEY, '1');\n  } catch (error) {\n    if (isQuotaExceededError(error) && hasStoredEntries(storage)) {\n      console.warn(\n        'localStorage quota exceeded. Existing planner data will remain available but new saves may fail.',\n        error,\n      );\n      return storage;\n    }\n    throw error;\n  }\n\n  try {\n    storage.removeItem(STORAGE_TEST_KEY);\n  } catch (cleanupError) {\n    console.warn('Unable to clean up storage test key', cleanupError);\n  }\n\n  return storage;\n}\n\nfunction createMemoryStorage() {\n  let memoryStore = {};\n  return {\n    get length() {\n      return Object.keys(memoryStore).length;\n    },\n    key(index) {\n      const keys = Object.keys(memoryStore);\n      return index >= 0 && index < keys.length ? keys[index] : null;\n    },\n    getItem(key) {\n      if (!Object.prototype.hasOwnProperty.call(memoryStore, key)) {\n        return null;\n      }\n      return maybeDecompressStoredString(memoryStore[key]);\n    },\n    setItem(key, value) {\n      memoryStore[key] = String(value);\n    },\n    removeItem(key) {\n      delete memoryStore[key];\n    },\n    clear() {\n      memoryStore = {};\n    },\n    keys() {\n      return Object.keys(memoryStore);\n    },\n  };\n}\n\nfunction initializeSafeLocalStorage() {\n  const localCandidates = collectLocalStorageCandidates();\n\n  for (let index = 0; index < localCandidates.length; index += 1) {\n    const candidate = localCandidates[index];\n    if (!candidate) {\n      continue;\n    }\n\n    try {\n      const storage = verifyStorage(candidate);\n      if (storage) {\n        lastFailedUpgradeCandidate = null;\n        return { storage, type: 'local' };\n      }\n    } catch (error) {\n      console.warn('localStorage is unavailable:', error);\n      lastFailedUpgradeCandidate = candidate;\n    }\n  }\n\n  if (typeof window !== 'undefined') {\n    try {\n      if ('sessionStorage' in window) {\n        const storage = verifyStorage(window.sessionStorage);\n        if (storage) {\n          registerKnownSessionStorage(storage);\n          console.warn('Falling back to sessionStorage; data persists for this tab only.');\n          alertSessionFallback();\n          return { storage, type: 'session' };\n        }\n      }\n    } catch (e) {\n      console.warn('sessionStorage fallback is unavailable:', e);\n    }\n  }\n\n  alertStorageError();\n  return { storage: createMemoryStorage(), type: 'memory' };\n}\n\nvar lastFailedUpgradeCandidate = null;\nvar safeLocalStorageInfo = initializeSafeLocalStorage();\n\nfunction migrateSnapshotToStorage(snapshot, target) {\n  const migratedKeys = [];\n  const failedKeys = [];\n\n  if (!snapshot || !target || typeof target.setItem !== 'function') {\n    return { migratedKeys, failedKeys };\n  }\n\n  Object.keys(snapshot).forEach((key) => {\n    const value = snapshot[key];\n    if (value === null || value === undefined) {\n      return;\n    }\n\n    let existing = null;\n    let existingRead = false;\n    try {\n      existing = target.getItem(key);\n      existingRead = true;\n    } catch (readError) {\n      console.warn('Unable to inspect localStorage during upgrade', key, readError);\n    }\n\n    if (existingRead && existing !== null && existing !== undefined && existing !== value) {\n      createStorageMigrationBackup(target, key, existing);\n    }\n\n    if (existingRead && existing === value) {\n      migratedKeys.push(key);\n      return;\n    }\n\n    try {\n      target.setItem(key, value);\n      migratedKeys.push(key);\n    } catch (writeError) {\n      console.warn('Unable to migrate storage key during upgrade', key, writeError);\n      failedKeys.push(key);\n    }\n  });\n\n  return { migratedKeys, failedKeys };\n}\n\nfunction clearMigratedKeys(snapshot, source, keysToRemove) {\n  if (!snapshot || !source || typeof source.removeItem !== 'function') {\n    return;\n  }\n\n  const keys = Array.isArray(keysToRemove) && keysToRemove.length > 0\n    ? keysToRemove\n    : Object.keys(snapshot);\n\n  keys.forEach((key) => {\n    try {\n      source.removeItem(key);\n    } catch (error) {\n      console.warn('Unable to remove migrated storage key from fallback', key, error);\n    }\n  });\n}\n\nfunction rollbackMigratedKeys(target, keys) {\n  if (!target || typeof target.removeItem !== 'function' || !Array.isArray(keys)) {\n    return;\n  }\n\n  keys.forEach((key) => {\n    try {\n      target.removeItem(key);\n    } catch (error) {\n      console.warn('Unable to roll back migrated storage key after upgrade failure', key, error);\n    }\n  });\n}\n\nfunction snapshotStorageEntries(storage, options = {}) {\n  const snapshot = Object.create(null);\n  if (!storage) {\n    return snapshot;\n  }\n\n  const { suppressAlerts = false } = options || {};\n\n  const captureKey = (key) => {\n    if (typeof key !== 'string' || !key) {\n      return;\n    }\n    let value;\n    try {\n      if (typeof storage.getItem === 'function') {\n        value = storage.getItem(key);\n      } else if (Object.prototype.hasOwnProperty.call(storage, key)) {\n        value = storage[key];\n      }\n    } catch (error) {\n      console.warn('Unable to read storage key during snapshot', key, error);\n      if (!suppressAlerts) {\n        alertStorageError('migration-read');\n      }\n      return;\n    }\n    if (value === null || value === undefined) {\n      return;\n    }\n    snapshot[key] = String(value);\n  };\n\n  if (typeof storage.key === 'function' && typeof storage.length === 'number') {\n    for (let index = 0; index < storage.length; index += 1) {\n      captureKey(storage.key(index));\n    }\n    return snapshot;\n  }\n\n  if (typeof storage.keys === 'function') {\n    try {\n      const keys = storage.keys();\n      if (Array.isArray(keys)) {\n        keys.forEach(captureKey);\n      }\n    } catch (error) {\n      console.warn('Unable to enumerate storage keys during snapshot', error);\n      if (!suppressAlerts) {\n        alertStorageError('migration-read');\n      }\n    }\n    return snapshot;\n  }\n\n  if (typeof storage.forEach === 'function') {\n    try {\n      storage.forEach((value, key) => {\n        if (typeof key !== 'string') {\n          return;\n        }\n        if (value === null || value === undefined) {\n          return;\n        }\n        snapshot[key] = String(value);\n      });\n    } catch (error) {\n      console.warn('Unable to iterate storage entries during snapshot', error);\n      if (!suppressAlerts) {\n        alertStorageError('migration-read');\n      }\n    }\n    return snapshot;\n  }\n\n  Object.keys(storage).forEach(captureKey);\n  return snapshot;\n}\n\nfunction updateGlobalSafeLocalStorageReference() {\n  if (!GLOBAL_SCOPE || typeof GLOBAL_SCOPE !== 'object') {\n    return;\n  }\n\n  try {\n    Object.defineProperty(GLOBAL_SCOPE, 'SAFE_LOCAL_STORAGE', {\n      configurable: true,\n      get: getSafeLocalStorage,\n    });\n    return;\n  } catch (defineError) {\n    void defineError;\n    try {\n      GLOBAL_SCOPE.SAFE_LOCAL_STORAGE = getSafeLocalStorage();\n      return;\n    } catch (assignError) {\n      console.warn('Unable to refresh SAFE_LOCAL_STORAGE global reference', assignError);\n    }\n  }\n}\n\nfunction downgradeSafeLocalStorageToMemory(reason, error, failingStorage) {\n  if (!safeLocalStorageInfo || safeLocalStorageInfo.type === 'memory') {\n    return;\n  }\n\n  const activeStorage = safeLocalStorageInfo.storage;\n  if (!activeStorage || (failingStorage && failingStorage !== activeStorage)) {\n    return;\n  }\n\n  let snapshot = Object.create(null);\n  try {\n    snapshot = snapshotStorageEntries(activeStorage, { suppressAlerts: true });\n  } catch (snapshotError) {\n    console.warn('Unable to capture storage snapshot during downgrade', snapshotError);\n  }\n\n  let fallbackStorage = null;\n  let fallbackType = 'memory';\n\n  if (safeLocalStorageInfo.type !== 'session') {\n    const sessionScopes = [\n      GLOBAL_SCOPE,\n      GLOBAL_SCOPE && GLOBAL_SCOPE.window ? GLOBAL_SCOPE.window : null,\n      GLOBAL_SCOPE && GLOBAL_SCOPE.__cineGlobal ? GLOBAL_SCOPE.__cineGlobal : null,\n      typeof window !== 'undefined' ? window : null,\n      typeof self !== 'undefined' ? self : null,\n      typeof global !== 'undefined' ? global : null,\n    ];\n\n    for (let index = 0; index < sessionScopes.length; index += 1) {\n      const candidate = resolveSessionStorageFromScope(sessionScopes[index]);\n      if (!candidate || candidate === activeStorage || (failingStorage && candidate === failingStorage)) {\n        continue;\n      }\n\n      try {\n        const verified = verifyStorage(candidate);\n        if (verified) {\n          fallbackStorage = verified;\n          fallbackType = 'session';\n          registerKnownSessionStorage(verified);\n          break;\n        }\n      } catch (sessionError) {\n        console.warn('Unable to activate sessionStorage fallback during downgrade', sessionError);\n      }\n    }\n  }\n\n  if (!fallbackStorage) {\n    fallbackStorage = createMemoryStorage();\n  }\n\n  Object.keys(snapshot).forEach((key) => {\n    const value = snapshot[key];\n    if (value === null || value === undefined) {\n      return;\n    }\n    try {\n      if (typeof fallbackStorage.setItem === 'function') {\n        fallbackStorage.setItem(key, value);\n      } else {\n        fallbackStorage[key] = value;\n      }\n    } catch (copyError) {\n      const label = fallbackType === 'session' ? 'sessionStorage' : 'memory';\n      console.warn(`Unable to copy storage entry to ${label} during downgrade`, key, copyError);\n    }\n  });\n\n  safeLocalStorageInfo = { storage: fallbackStorage, type: fallbackType };\n  lastFailedUpgradeCandidate = null;\n\n  const fallbackDescription = fallbackType === 'session' ? 'sessionStorage' : 'in-memory fallback';\n  console.warn(\n    reason\n      ? `Downgraded planner storage to ${fallbackDescription} after ${reason} errors.`\n      : `Downgraded planner storage to ${fallbackDescription} after storage errors.`,\n    error,\n  );\n\n  if (fallbackType === 'session') {\n    alertSessionFallback();\n  }\n\n  updateGlobalSafeLocalStorageReference();\n}\n\nfunction attemptLocalStorageUpgrade() {\n  if (!safeLocalStorageInfo || safeLocalStorageInfo.type === 'local') {\n    return safeLocalStorageInfo.storage;\n  }\n\n  const candidates = collectLocalStorageCandidates();\n  const currentStorage = safeLocalStorageInfo.storage;\n  let selectedCandidate = null;\n  let verifiedStorage = null;\n\n  for (let index = 0; index < candidates.length; index += 1) {\n    const candidate = candidates[index];\n    if (!candidate || candidate === currentStorage) {\n      continue;\n    }\n    if (candidate === lastFailedUpgradeCandidate) {\n      continue;\n    }\n\n    let verified;\n    try {\n      verified = verifyStorage(candidate);\n    } catch (verificationError) {\n      console.warn('localStorage upgrade verification failed', verificationError);\n      lastFailedUpgradeCandidate = candidate;\n      continue;\n    }\n\n    if (!verified || verified === currentStorage) {\n      if (!verified) {\n        lastFailedUpgradeCandidate = candidate;\n      }\n      continue;\n    }\n\n    selectedCandidate = candidate;\n    verifiedStorage = verified;\n    break;\n  }\n\n  if (!verifiedStorage) {\n    return currentStorage;\n  }\n\n  const snapshot = snapshotStorageEntries(currentStorage);\n  const { migratedKeys, failedKeys } = migrateSnapshotToStorage(snapshot, verifiedStorage);\n\n  if (failedKeys.length > 0) {\n    rollbackMigratedKeys(verifiedStorage, migratedKeys);\n    console.warn(\n      'Aborting localStorage upgrade because some entries could not be migrated. Continuing to use fallback storage.',\n      failedKeys,\n    );\n    alertStorageError('migration-write');\n    lastFailedUpgradeCandidate = selectedCandidate || verifiedStorage;\n    return currentStorage;\n  }\n\n  clearMigratedKeys(snapshot, currentStorage, migratedKeys);\n\n  safeLocalStorageInfo = { storage: verifiedStorage, type: 'local' };\n  lastFailedUpgradeCandidate = null;\n  return verifiedStorage;\n}\n\nfunction getSafeLocalStorage() {\n  // [Refactor] Delegate to the new StorageRepository driver if compatible\n  if (storageRepo && storageRepo.driver && storageRepo.driver.storage) {\n    return storageRepo.driver.storage;\n  }\n\n  if (!safeLocalStorageInfo || !safeLocalStorageInfo.storage) {\n    safeLocalStorageInfo = initializeSafeLocalStorage();\n    if (typeof console !== 'undefined' && console.log) {\n      console.log('DEBUG: storage initialized with type:', safeLocalStorageInfo.type);\n    }\n  }\n\n  if (safeLocalStorageInfo.type !== 'local') {\n    attemptLocalStorageUpgrade();\n  }\n  const resultStorage = safeLocalStorageInfo.storage;\n  console.log('DEBUG: getSafeLocalStorage returning', resultStorage ? 'object' : resultStorage);\n  return resultStorage;\n}\n\nupdateGlobalSafeLocalStorageReference();\npatchStorageGetItemForCompression();\n\nvar persistentStorageRequestPromise = null;\n\nfunction requestPersistentStorage() {\n  const storageManager = getStorageManager();\n  const supportsPersist =\n    storageManager && typeof storageManager.persist === 'function';\n\n  if (!supportsPersist) {\n    return Promise.resolve({\n      supported: false,\n      granted: false,\n      alreadyGranted: false,\n    });\n  }\n\n  if (persistentStorageRequestPromise) {\n    return persistentStorageRequestPromise;\n  }\n\n  const requestPromise = (async () => {\n    let alreadyGranted = false;\n    const supportsPersistedCheck = typeof storageManager.persisted === 'function';\n\n    if (supportsPersistedCheck) {\n      try {\n        alreadyGranted = await storageManager.persisted();\n      } catch (persistedError) {\n        console.warn('Unable to determine persistent storage state', persistedError);\n      }\n    }\n\n    if (alreadyGranted) {\n      return {\n        supported: true,\n        granted: true,\n        alreadyGranted: true,\n      };\n    }\n\n    try {\n      const granted = await storageManager.persist();\n      if (!granted && supportsPersistedCheck) {\n        try {\n          const persisted = await storageManager.persisted();\n          if (persisted) {\n            return {\n              supported: true,\n              granted: true,\n              alreadyGranted: true,\n            };\n          }\n        } catch (verifyError) {\n          console.warn('Unable to verify persistent storage after request', verifyError);\n        }\n      }\n\n      return {\n        supported: true,\n        granted,\n        alreadyGranted: false,\n      };\n    } catch (error) {\n      console.warn('Persistent storage request failed', error);\n      return {\n        supported: true,\n        granted: false,\n        alreadyGranted: false,\n        error,\n      };\n    }\n  })();\n\n  const trackedPromise = requestPromise.then(\n    (result) => {\n      if (!result || result.granted !== true) {\n        persistentStorageRequestPromise = null;\n      }\n      return result;\n    },\n    (error) => {\n      persistentStorageRequestPromise = null;\n      throw error;\n    },\n  );\n\n  persistentStorageRequestPromise = trackedPromise;\n  return trackedPromise;\n}\n\nif (typeof window !== 'undefined' && typeof navigator !== 'undefined') {\n  requestPersistentStorage();\n}\n\n// Helper to check for plain objects\nfunction isPlainObject(val) {\n  if (val === null || typeof val !== 'object') {\n    return false;\n  }\n  let prototype;\n  try {\n    prototype = Object.getPrototypeOf(val);\n  } catch {\n    return false;\n  }\n  if (prototype === null || prototype === Object.prototype) {\n    return true;\n  }\n  const secondLevel = Object.getPrototypeOf(prototype);\n  if (secondLevel === null && typeof prototype.constructor === 'function') {\n    const name = prototype.constructor.name;\n    return name === 'Object' || name === '';\n  }\n  return false;\n}\n\nfunction isMapLike(value) {\n  if (!value || typeof value !== 'object') {\n    return false;\n  }\n\n  const tag = Object.prototype.toString.call(value);\n  if (tag === '[object Map]') {\n    return true;\n  }\n\n  if (typeof Map !== 'undefined') {\n    try {\n      if (value instanceof Map) {\n        return true;\n      }\n    } catch (error) {\n      void error;\n    }\n  }\n\n  return (\n    typeof value.size === 'number'\n    && typeof value.entries === 'function'\n    && typeof value.forEach === 'function'\n    && typeof value.get === 'function'\n    && typeof value.set === 'function'\n  );\n}\n\nfunction convertMapLikeKey(key) {\n  if (typeof key === 'string') {\n    return key;\n  }\n  if (typeof key === 'number' || typeof key === 'boolean' || typeof key === 'bigint') {\n    return String(key);\n  }\n  if (typeof key === 'symbol') {\n    return key.description || key.toString();\n  }\n  if (key && typeof key === 'object') {\n    try {\n      const json = JSON.stringify(key);\n      if (json && json !== '{}') {\n        return json;\n      }\n    } catch (error) {\n      void error;\n    }\n  }\n  try {\n    return String(key);\n  } catch (error) {\n    void error;\n  }\n  return null;\n}\n\nfunction convertMapLikeToObject(mapLike) {\n  if (!isMapLike(mapLike)) {\n    return null;\n  }\n\n  const snapshot = Object.create(null);\n  const assignEntry = (rawKey, value) => {\n    const key = convertMapLikeKey(rawKey);\n    if (key === null || key === undefined) {\n      return;\n    }\n    if (Object.prototype.hasOwnProperty.call(snapshot, key)) {\n      return;\n    }\n    snapshot[key] = value;\n  };\n\n  let iterated = false;\n\n  if (typeof mapLike.entries === 'function') {\n    try {\n      const iterator = mapLike.entries();\n      if (iterator && typeof iterator.next === 'function') {\n        for (let step = iterator.next(); !step.done; step = iterator.next()) {\n          const entry = step && step.value;\n          if (Array.isArray(entry) && entry.length >= 2) {\n            assignEntry(entry[0], entry[1]);\n          }\n        }\n        iterated = true;\n      }\n    } catch (error) {\n      console.warn('Unable to iterate map-like value entries', error);\n    }\n  }\n\n  if (!iterated && typeof mapLike.forEach === 'function') {\n    try {\n      mapLike.forEach((value, key) => {\n        assignEntry(key, value);\n      });\n      iterated = true;\n    } catch (error) {\n      console.warn('Unable to iterate map-like value via forEach', error);\n    }\n  }\n\n  if (!Object.keys(snapshot).length && !iterated) {\n    return null;\n  }\n\n  return snapshot;\n}\n\nvar LEGACY_LONG_GOP_TOKEN_REGEX = /^long[\\s_-]?gop$/i;\n\nfunction inferLegacyLongGopCompressionVariant(value) {\n  if (typeof value !== 'string') {\n    return null;\n  }\n\n  var trimmed = value.trim();\n  if (!trimmed) {\n    return null;\n  }\n\n  var lower = trimmed.toLowerCase();\n  if (lower === 'utf16' || lower === 'utf-16') {\n    return 'utf16';\n  }\n  if (lower === 'uri-component' || lower === 'uri_component' || lower === 'encoded-uri-component' || lower === 'uri') {\n    return 'uri-component';\n  }\n  if (lower === 'base64') {\n    return 'base64';\n  }\n\n  if (LEGACY_LONG_GOP_TOKEN_REGEX.test(lower)) {\n    return 'utf16';\n  }\n\n  return null;\n}\n\nfunction normalizeLegacyLongGopString(value) {\n  if (typeof value !== 'string') {\n    return value;\n  }\n\n  const trimmed = value.trim();\n  if (LEGACY_LONG_GOP_TOKEN_REGEX.test(trimmed)) {\n    return 'long-gop';\n  }\n\n  return value;\n}\n\nfunction normalizeLegacyLongGopKey(key) {\n  if (typeof key !== 'string') {\n    return key;\n  }\n\n  return LEGACY_LONG_GOP_TOKEN_REGEX.test(key) ? 'long-gop' : key;\n}\n\nfunction normalizeLegacyLongGopStructure(value, visited) {\n  if (value === null || typeof value !== 'object') {\n    return normalizeLegacyLongGopString(value);\n  }\n\n  const seen = visited || new WeakSet();\n  if (seen.has(value)) {\n    return value;\n  }\n  seen.add(value);\n\n  if (Array.isArray(value)) {\n    let changed = false;\n    const normalizedArray = value.map((item) => {\n      const normalizedItem = normalizeLegacyLongGopStructure(item, seen);\n      if (normalizedItem !== item) {\n        changed = true;\n      }\n      return normalizedItem;\n    });\n    return changed ? normalizedArray : value;\n  }\n\n  if (isPlainObject(value)) {\n    let changed = false;\n    const normalizedObject = {};\n    Object.keys(value).forEach((key) => {\n      const normalizedKey = normalizeLegacyLongGopKey(key);\n      const originalValue = value[key];\n      const normalizedValue = normalizeLegacyLongGopStructure(originalValue, seen);\n      if (normalizedKey !== key || normalizedValue !== originalValue) {\n        changed = true;\n      }\n      normalizedObject[normalizedKey] = normalizedValue;\n    });\n    return changed ? normalizedObject : value;\n  }\n\n  return normalizeLegacyLongGopString(value);\n}\n\nfunction normalizeLegacyLongGopBackups(backups) {\n  if (!Array.isArray(backups)) {\n    return { normalized: Array.isArray(backups) ? backups : [], changed: false };\n  }\n\n  let changed = false;\n  const normalized = backups.map((entry) => {\n    if (entry === null || entry === undefined) {\n      return entry;\n    }\n    const normalizedEntry = normalizeLegacyLongGopStructure(entry);\n    if (normalizedEntry !== entry) {\n      changed = true;\n    }\n    return normalizedEntry;\n  });\n\n  return { normalized, changed };\n}\n\nfunction parseAutoBackupKey(name) {\n  if (typeof name !== 'string') {\n    return { timestamp: Number.NEGATIVE_INFINITY, label: '' };\n  }\n\n  const parseWithPrefix = (prefix, options = {}) => {\n    const remainder = name.slice(prefix.length);\n    const parts = remainder.split('-');\n    if (parts.length < 5) {\n      return null;\n    }\n\n    const [yearPart, monthPart, dayPart, hourPart, minutePart] = parts;\n    const year = Number.parseInt(yearPart, 10);\n    const month = Number.parseInt(monthPart, 10) - 1;\n    const day = Number.parseInt(dayPart, 10);\n    const hour = Number.parseInt(hourPart, 10);\n    const minute = Number.parseInt(minutePart, 10);\n\n    if ([year, month, day, hour, minute].some(value => Number.isNaN(value))) {\n      return null;\n    }\n\n    let includeSeconds = false;\n    let seconds = 0;\n    let labelStartIndex = 5;\n\n    if (parts.length > labelStartIndex) {\n      const secondsCandidate = parts[labelStartIndex];\n      if (/^\\d{1,2}$/u.test(secondsCandidate)) {\n        includeSeconds = true;\n        seconds = Number.parseInt(secondsCandidate, 10);\n        labelStartIndex += 1;\n      } else if (options.requireSeconds) {\n        return null;\n      }\n    } else if (options.requireSeconds) {\n      return null;\n    }\n\n    const label = parts.slice(labelStartIndex).join('-').trim();\n    const date = new Date(year, month, day, hour, minute, includeSeconds ? seconds : 0, 0);\n    const timestamp = date.getTime();\n\n    if (Number.isNaN(timestamp)) {\n      return null;\n    }\n\n    return { timestamp, label };\n  };\n\n  if (name.startsWith(STORAGE_AUTO_BACKUP_NAME_PREFIX)) {\n    const parsed = parseWithPrefix(STORAGE_AUTO_BACKUP_NAME_PREFIX);\n    if (parsed) {\n      return parsed;\n    }\n    return { timestamp: Number.NEGATIVE_INFINITY, label: '' };\n  }\n\n  if (name.startsWith(STORAGE_AUTO_BACKUP_DELETION_PREFIX)) {\n    const parsed = parseWithPrefix(STORAGE_AUTO_BACKUP_DELETION_PREFIX, { requireSeconds: false });\n    if (parsed) {\n      return parsed;\n    }\n    return { timestamp: Number.NEGATIVE_INFINITY, label: '' };\n  }\n\n  return { timestamp: Number.NEGATIVE_INFINITY, label: '' };\n}\n\nfunction collectAutoBackupEntries(container, prefix) {\n  if (!isPlainObject(container) || typeof prefix !== 'string') {\n    return [];\n  }\n\n  return Object.keys(container)\n    .filter((key) => typeof key === 'string' && key.startsWith(prefix))\n    .map((key) => {\n      const { timestamp, label } = parseAutoBackupKey(key);\n      return { key, timestamp, label };\n    })\n    .sort((a, b) => {\n      if (a.timestamp !== b.timestamp) {\n        return a.timestamp - b.timestamp;\n      }\n      return a.key.localeCompare(b.key);\n    });\n}\n\nfunction markAutoBackupValueAsRenamed(value) {\n  if (!value || typeof value !== 'object') {\n    return;\n  }\n\n  try {\n    value[STORAGE_AUTO_BACKUP_RENAMED_FLAG] = true;\n  } catch (assignmentError) {\n    void assignmentError;\n    try {\n      Object.defineProperty(value, STORAGE_AUTO_BACKUP_RENAMED_FLAG, {\n        configurable: true,\n        enumerable: true,\n        writable: true,\n        value: true,\n      });\n    } catch (definitionError) {\n      void definitionError;\n    }\n  }\n\n  if (isPlainObject(value.projectInfo)) {\n    try {\n      value.projectInfo[STORAGE_AUTO_BACKUP_RENAMED_FLAG] = true;\n    } catch (infoError) {\n      void infoError;\n    }\n  }\n}\n\nfunction isAutoBackupValueRenamed(value) {\n  if (!value || typeof value !== 'object') {\n    return false;\n  }\n  if (value[STORAGE_AUTO_BACKUP_RENAMED_FLAG] === true) {\n    return true;\n  }\n  if (\n    isPlainObject(value.projectInfo)\n    && value.projectInfo[STORAGE_AUTO_BACKUP_RENAMED_FLAG] === true\n  ) {\n    return true;\n  }\n  return false;\n}\n\nfunction isRenamedAutoBackupEntry(container, key) {\n  if (!isPlainObject(container) || typeof key !== 'string') {\n    return false;\n  }\n  return isAutoBackupValueRenamed(container[key]);\n}\n\nfunction getAutoBackupLabelKey(entry) {\n  if (!entry || typeof entry !== 'object') {\n    return '';\n  }\n  if (typeof entry.label === 'string') {\n    const trimmed = entry.label.trim();\n    if (trimmed) {\n      return trimmed;\n    }\n  }\n  if (typeof entry.key === 'string' && entry.key.trim()) {\n    const key = entry.key.trim();\n    if (\n      key.startsWith(STORAGE_AUTO_BACKUP_NAME_PREFIX)\n      || key.startsWith(STORAGE_AUTO_BACKUP_DELETION_PREFIX)\n    ) {\n      return '__auto-backup:unlabeled__';\n    }\n    return key;\n  }\n  return '__auto-backup:unlabeled__';\n}\n\nfunction getAutoBackupEntrySignature(container, entry) {\n  if (!isPlainObject(container) || !entry || typeof entry.key !== 'string') {\n    return 'undefined';\n  }\n  const value = Object.prototype.hasOwnProperty.call(container, entry.key)\n    ? container[entry.key]\n    : undefined;\n  try {\n    let preparedValue = value;\n    if (isPlainObject(value) && value[AUTO_BACKUP_SNAPSHOT_PROPERTY]) {\n      const cloneForSignature = cloneAutoBackupValue(value, { stripMetadata: true });\n      const snapshot = cloneForSignature[AUTO_BACKUP_SNAPSHOT_PROPERTY];\n      if (snapshot && typeof snapshot === 'object') {\n        try {\n          const restored = restoreAutoBackupSnapshotPayload(snapshot, entry.key);\n          snapshot.payload = restored.payload;\n          if (Object.prototype.hasOwnProperty.call(snapshot, 'payloadCompression')) {\n            delete snapshot.payloadCompression;\n          }\n        } catch (payloadError) {\n          console.warn('Failed to expand automatic backup payload for signature comparison', entry.key, payloadError);\n        }\n      }\n      preparedValue = cloneForSignature;\n    }\n\n    const normalizedValue = cloneAutoBackupValueWithLegacyNormalization(preparedValue, {\n      stripMetadata: true,\n    });\n    return createStableValueSignature(normalizedValue);\n  } catch (error) {\n    console.warn('Failed to create stable signature for automatic backup entry', error);\n    return 'undefined';\n  }\n}\n\nfunction createStableValueSignature(value, state) {\n  const signatureState = state || (typeof WeakSet === 'function'\n    ? { seen: new WeakSet(), reportedCycle: false }\n    : null);\n  const seenSet = signatureState && signatureState.seen ? signatureState.seen : null;\n\n  const handleCircularSignature = (input, compute) => {\n    if (!seenSet) {\n      return compute();\n    }\n    if (seenSet.has(input)) {\n      if (!signatureState.reportedCycle\n        && typeof console !== 'undefined'\n        && console\n        && typeof console.warn === 'function') {\n        console.warn(\n          'Detected circular reference while computing automatic backup signature. Using a placeholder token to keep backups stable.',\n        );\n      }\n      signatureState.reportedCycle = true;\n      return AUTO_BACKUP_CYCLE_PLACEHOLDER;\n    }\n    seenSet.add(input);\n    try {\n      return compute();\n    } finally {\n      seenSet.delete(input);\n    }\n  };\n\n  if (value === null) {\n    return 'null';\n  }\n  if (value === undefined) {\n    return 'undefined';\n  }\n  if (Array.isArray(value)) {\n    return handleCircularSignature(value, () => {\n      let signature = '[';\n      for (let index = 0; index < value.length; index += 1) {\n        if (index > 0) {\n          signature += ',';\n        }\n        signature += createStableValueSignature(value[index], signatureState);\n      }\n      signature += ']';\n      return signature;\n    });\n  }\n  if (value instanceof Date) {\n    return handleCircularSignature(value, () => {\n      const timestamp = value.getTime();\n      if (Number.isNaN(timestamp)) {\n        return 'date:invalid';\n      }\n      return `date:${timestamp}`;\n    });\n  }\n  if (isPlainObject(value)) {\n    return handleCircularSignature(value, () => {\n      const keys = Object.keys(value).sort();\n      let signature = '{';\n      for (let index = 0; index < keys.length; index += 1) {\n        const key = keys[index];\n        if (index > 0) {\n          signature += ',';\n        }\n        signature += `${JSON.stringify(key)}:${createStableValueSignature(value[key], signatureState)}`;\n      }\n      signature += '}';\n      return signature;\n    });\n  }\n  if (value && typeof value === 'object') {\n    return handleCircularSignature(value, () => `${typeof value}:${String(value)}`);\n  }\n  if (typeof value === 'number') {\n    if (Number.isNaN(value)) {\n      return 'number:NaN';\n    }\n    if (!Number.isFinite(value)) {\n      return value > 0 ? 'number:Infinity' : 'number:-Infinity';\n    }\n    return `number:${value}`;\n  }\n  if (typeof value === 'bigint') {\n    return `bigint:${value.toString()}`;\n  }\n  if (typeof value === 'boolean') {\n    return value ? 'boolean:true' : 'boolean:false';\n  }\n  if (typeof value === 'string') {\n    const decoded = decodeCompressedJsonStorageValue(value);\n    if (decoded.success && typeof decoded.value === 'string') {\n      try {\n        const parsed = JSON.parse(decoded.value);\n        return createStableValueSignature(parsed, signatureState);\n      } catch (signatureParseError) {\n        console.warn(\n          'Unable to decode compressed string while computing stable value signature',\n          signatureParseError,\n        );\n      }\n    }\n    return `string:${value}`;\n  }\n  if (typeof value === 'symbol') {\n    return `symbol:${String(value)}`;\n  }\n  if (typeof value === 'function') {\n    return `function:${value.name || 'anonymous'}`;\n  }\n  return `${typeof value}:${String(value)}`;\n}\n\nfunction removeSingleDuplicateAutoBackupEntry(container, entries) {\n  if (!isPlainObject(container) || !Array.isArray(entries) || entries.length < 2) {\n    return null;\n  }\n\n  const seenSignaturesByLabel = new Map();\n\n  for (let index = entries.length - 1; index >= 0; index -= 1) {\n    const entry = entries[index];\n    if (!entry || typeof entry.key !== 'string') {\n      continue;\n    }\n    if (isRenamedAutoBackupEntry(container, entry.key)) {\n      continue;\n    }\n\n    const labelKey = getAutoBackupLabelKey(entry);\n    let labelSignatures = seenSignaturesByLabel.get(labelKey);\n    if (!labelSignatures) {\n      labelSignatures = new Map();\n      seenSignaturesByLabel.set(labelKey, labelSignatures);\n    }\n\n    const value = Object.prototype.hasOwnProperty.call(container, entry.key)\n      ? container[entry.key]\n      : undefined;\n    const signature = createStableValueSignature(value);\n    const seen = labelSignatures.get(signature);\n\n    if (seen && typeof seen.key === 'string') {\n      delete container[entry.key];\n      entries.splice(index, 1);\n\n      if (\n        typeof console !== 'undefined'\n        && typeof console.info === 'function'\n      ) {\n        console.info('Removed duplicate automatic backup while preserving newer copy.', {\n          removedKey: entry.key,\n          preservedKey: seen.key,\n          label: labelKey,\n        });\n      }\n\n      return entry.key;\n    }\n\n    labelSignatures.set(signature, {\n      key: entry.key,\n      signature,\n    });\n  }\n\n  return null;\n}\n\nfunction removeDuplicateAutoBackupEntries(container, entries) {\n  const removedKeys = [];\n  while (true) {\n    const removedKey = removeSingleDuplicateAutoBackupEntry(container, entries);\n    if (!removedKey) {\n      break;\n    }\n    removedKeys.push(removedKey);\n  }\n  return removedKeys;\n}\n\nfunction pruneAutoBackupEntries(container, entries, limit, removedKeys) {\n  if (!isPlainObject(container) || !Array.isArray(entries) || entries.length <= limit) {\n    return;\n  }\n\n  const duplicateBuckets = new Map();\n  for (let index = 0; index < entries.length; index += 1) {\n    const entry = entries[index];\n    if (!entry || typeof entry.key !== 'string') {\n      continue;\n    }\n    const labelKey = getAutoBackupLabelKey(entry);\n    const signature = getAutoBackupEntrySignature(container, entry);\n    const bucketKey = `${labelKey}__${signature}`;\n    const existing = duplicateBuckets.get(bucketKey);\n    if (existing) {\n      existing.push(index);\n    } else {\n      duplicateBuckets.set(bucketKey, [index]);\n    }\n  }\n\n  const removable = Array.from(duplicateBuckets.values())\n    .filter(indexes => Array.isArray(indexes) && indexes.length > 1)\n    .flatMap(indexes => indexes.slice(0, -1))\n    .sort((a, b) => a - b);\n\n  if (!removable.length) {\n    if (entries.length > limit) {\n      console.warn(\n        'Skipped trimming automatic backups because all remaining versions are unique.',\n        { limit, total: entries.length },\n      );\n    }\n    return;\n  }\n\n  for (let i = removable.length - 1; i >= 0 && entries.length > limit; i -= 1) {\n    const index = removable[i];\n    const entry = entries[index];\n    if (!entry || typeof entry.key !== 'string') {\n      continue;\n    }\n    if (isRenamedAutoBackupEntry(container, entry.key)) {\n      continue;\n    }\n    delete container[entry.key];\n    entries.splice(index, 1);\n    removedKeys.push(entry.key);\n  }\n\n  if (entries.length > limit) {\n    console.warn(\n      'Unable to trim automatic backups down to the configured limit without losing unique data.',\n      { limit, remaining: entries.length },\n    );\n  }\n}\n\nfunction enforceAutoBackupLimits(container) {\n  if (!isPlainObject(container)) {\n    return [];\n  }\n\n  const removed = [];\n\n  const autoBackups = collectAutoBackupEntries(container, STORAGE_AUTO_BACKUP_NAME_PREFIX);\n  removed.push(...removeDuplicateAutoBackupEntries(container, autoBackups));\n  if (autoBackups.length > MAX_AUTO_BACKUPS) {\n    pruneAutoBackupEntries(container, autoBackups, MAX_AUTO_BACKUPS, removed);\n  }\n\n  const deletionBackups = collectAutoBackupEntries(container, STORAGE_AUTO_BACKUP_DELETION_PREFIX);\n  removed.push(...removeDuplicateAutoBackupEntries(container, deletionBackups));\n  if (deletionBackups.length > MAX_DELETION_BACKUPS) {\n    pruneAutoBackupEntries(container, deletionBackups, MAX_DELETION_BACKUPS, removed);\n  }\n\n  if (removed.length > 0) {\n    console.warn(\n      `Removed ${removed.length} older automatic backup${removed.length > 1 ? 's' : ''} to stay within storage limits.`,\n      removed,\n    );\n  }\n\n  return removed;\n}\n\nfunction removeOldestAutoBackupEntry(container, options = {}) {\n  if (!isPlainObject(container)) {\n    return null;\n  }\n\n  const { force = false } = options;\n\n  const removeFromEntries = (entries, { respectRename = true } = {}) => {\n    if (!Array.isArray(entries) || entries.length === 0) {\n      return null;\n    }\n\n    for (let index = 0; index < entries.length; index += 1) {\n      const entry = entries[index];\n      if (!entry || typeof entry.key !== 'string') {\n        continue;\n      }\n\n      const hasValue = Object.prototype.hasOwnProperty.call(container, entry.key);\n      const value = hasValue ? container[entry.key] : undefined;\n\n      if (!hasValue || value === undefined || value === null || typeof value !== 'object') {\n        delete container[entry.key];\n        return entry.key;\n      }\n\n      if (respectRename && isRenamedAutoBackupEntry(container, entry.key)) {\n        continue;\n      }\n\n      delete container[entry.key];\n      return entry.key;\n    }\n\n    return null;\n  };\n\n  const autoBackups = collectAutoBackupEntries(container, STORAGE_AUTO_BACKUP_NAME_PREFIX);\n  const duplicateAutoBackupKey = removeSingleDuplicateAutoBackupEntry(container, autoBackups);\n  if (duplicateAutoBackupKey) {\n    return duplicateAutoBackupKey;\n  }\n\n  const deletionBackups = collectAutoBackupEntries(container, STORAGE_AUTO_BACKUP_DELETION_PREFIX);\n  const duplicateDeletionBackupKey = removeSingleDuplicateAutoBackupEntry(container, deletionBackups);\n  if (duplicateDeletionBackupKey) {\n    return duplicateDeletionBackupKey;\n  }\n\n  const oldestDeletionBackupKey = removeFromEntries(deletionBackups, { respectRename: false });\n  if (oldestDeletionBackupKey) {\n    return oldestDeletionBackupKey;\n  }\n  if (deletionBackups.length > 0) {\n    console.warn(\n      'Unable to free space by removing pre-deletion backups because all copies appear to be protected.',\n    );\n  }\n\n  const oldestAutoBackupKey = removeFromEntries(autoBackups, { respectRename: !force });\n  if (oldestAutoBackupKey) {\n    return oldestAutoBackupKey;\n  }\n  if (autoBackups.length > 0) {\n    console.warn(\n      'Unable to free space by removing automatic backups because the remaining copies were renamed or protected.',\n    );\n  }\n\n  return null;\n}\n\n\n\nfunction describeAutoGearBackupEntry(entry) {\n  if (!entry || typeof entry !== 'object') {\n    return '';\n  }\n\n  if (typeof entry.note === 'string') {\n    const trimmedNote = entry.note.trim();\n    if (trimmedNote) {\n      return trimmedNote;\n    }\n  }\n\n  if (typeof entry.createdAt === 'string') {\n    const trimmedTimestamp = entry.createdAt.trim();\n    if (trimmedTimestamp) {\n      return trimmedTimestamp;\n    }\n  }\n\n  if (typeof entry.id === 'string') {\n    return entry.id;\n  }\n\n  return '';\n}\n\nfunction removeOldestAutoGearBackupEntry(backups) {\n  if (!Array.isArray(backups) || backups.length === 0) {\n    return null;\n  }\n\n  const removeAt = (index) => {\n    const [removed] = backups.splice(index, 1);\n    return {\n      removed,\n      label: describeAutoGearBackupEntry(removed),\n    };\n  };\n\n  for (let index = backups.length - 1; index >= 0; index -= 1) {\n    const entry = backups[index];\n    if (!entry || typeof entry !== 'object') {\n      return removeAt(index);\n    }\n    if (!Array.isArray(entry.rules)) {\n      return removeAt(index);\n    }\n  }\n\n  return removeAt(backups.length - 1);\n}\n\nfunction cleanupAutoGearBackupMigrationCopies(storage) {\n  if (!storage || typeof storage.getItem !== 'function' || typeof storage.removeItem !== 'function') {\n    return false;\n  }\n\n  const migrationBackupKey = `${AUTO_GEAR_BACKUPS_STORAGE_KEY}${STORAGE_MIGRATION_BACKUP_SUFFIX}`;\n  const removedKeys = [];\n\n  try {\n    const existing = storage.getItem(migrationBackupKey);\n    if (existing !== null && existing !== undefined) {\n      storage.removeItem(migrationBackupKey);\n      removedKeys.push(migrationBackupKey);\n    }\n  } catch (error) {\n    console.warn(\n      'Unable to inspect automatic gear backup migration snapshot while recovering storage quota.',\n      error,\n    );\n  }\n\n  try {\n    const pruned = pruneMigrationBackupEntriesForCleanup(storage, migrationBackupKey);\n    if (Array.isArray(pruned) && pruned.length > 0) {\n      removedKeys.push(...pruned);\n    }\n  } catch (error) {\n    console.warn('Unable to prune migration backups while recovering storage for automatic gear backups.', error);\n  }\n\n  if (removedKeys.length > 0) {\n    console.warn(\n      `Removed ${removedKeys.length} migration backup${removedKeys.length > 1 ? 's' : ''} while freeing storage for automatic gear backups.`,\n      removedKeys,\n    );\n    return true;\n  }\n\n  return false;\n}\n\nfunction clearCachedPlannerDataForAutoGearBackups() {\n  if (typeof clearUiCacheStorageEntries !== 'function') {\n    return false;\n  }\n\n  try {\n    clearUiCacheStorageEntries();\n    console.warn(\n      'Cleared cached planner data to free up storage space before saving automatic gear backups.',\n    );\n    return true;\n  } catch (error) {\n    console.warn(\n      'Unable to clear cached planner data while recovering storage for automatic gear backups.',\n      error,\n    );\n  }\n\n  return false;\n}\n\nfunction shouldDisplayStorageAlert(reason) {\n  if (!reason) {\n    return true;\n  }\n\n  if (reason === 'migration-read') {\n    if (typeof safeLocalStorageInfo !== 'undefined' && safeLocalStorageInfo) {\n      if (safeLocalStorageInfo.type && safeLocalStorageInfo.type !== 'memory') {\n        return false;\n      }\n    }\n  }\n\n  return true;\n}\n\nfunction alertStorageError(reason) {\n  if (!shouldDisplayStorageAlert(reason)) {\n    return;\n  }\n\n  if (GLOBAL_SCOPE && typeof GLOBAL_SCOPE[STORAGE_ALERT_FLAG_NAME] === 'boolean') {\n    storageErrorAlertShown = GLOBAL_SCOPE[STORAGE_ALERT_FLAG_NAME];\n  }\n\n  if (storageErrorAlertShown) {\n    return;\n  }\n\n  storageErrorAlertShown = true;\n  if (GLOBAL_SCOPE) {\n    GLOBAL_SCOPE[STORAGE_ALERT_FLAG_NAME] = true;\n  }\n\n  if (typeof window === 'undefined' || typeof window.alert !== 'function') return;\n  let msg = 'Storage error: Unable to access local data. Changes may not be saved.';\n  try {\n    if (typeof window !== 'undefined' && window.texts) {\n      const texts = window.texts;\n      const currentLang = window.currentLang || 'en';\n      const lang = texts[currentLang] ? currentLang : 'en';\n      msg = texts[lang]?.alertStorageError || msg;\n    }\n  } catch (err) {\n    void err;\n    // ignore and fall back to default\n  }\n  window.alert(msg);\n}\n\nfunction alertSessionFallback() {\n  if (sessionFallbackAlertShown) {\n    return;\n  }\n\n  sessionFallbackAlertShown = true;\n  if (GLOBAL_SCOPE) {\n    GLOBAL_SCOPE[SESSION_FALLBACK_ALERT_FLAG_NAME] = true;\n  }\n\n  if (typeof window === 'undefined' || typeof window.alert !== 'function') return;\n\n  let msg = 'Warning: Local storage is unavailable. Data will only persist for this browser tab.';\n  try {\n    if (typeof window !== 'undefined' && window.texts) {\n      const texts = window.texts;\n      const currentLang = window.currentLang || 'en';\n      const lang = texts[currentLang] ? currentLang : 'en';\n      msg = texts[lang]?.alertSessionFallback || msg;\n    }\n  } catch (err) {\n    void err;\n    // ignore and fall back to default\n  }\n\n  window.alert(msg);\n}\n\nfunction getWindowStorage(name) {\n  if (typeof window === 'undefined') {\n    return null;\n  }\n\n  try {\n    return window[name];\n  } catch (error) {\n    console.warn(`Unable to access ${name} during legacy migration`, error);\n    return null;\n  }\n}\n\nfunction collectUniqueStorages(storages) {\n  if (!Array.isArray(storages) || storages.length === 0) {\n    return [];\n  }\n\n  const unique = [];\n  const seen = new Set();\n\n  for (let i = 0; i < storages.length; i += 1) {\n    const storage = storages[i];\n    if (!storage || typeof storage.getItem !== 'function' || seen.has(storage)) {\n      continue;\n    }\n\n    seen.add(storage);\n    unique.push(storage);\n  }\n\n  return unique;\n}\n\nfunction migrateKeyBetweenStorages(source, target, legacyKey, modernKey, options = {}) {\n  if (!source || typeof source.getItem !== 'function') {\n    return false;\n  }\n\n  const { keepLegacy = false } = options;\n\n  let legacyValue;\n  try {\n    legacyValue = source.getItem(legacyKey);\n  } catch (error) {\n    console.warn(`Unable to read legacy storage key ${legacyKey}`, error);\n    alertStorageError('migration-read');\n    return false;\n  }\n\n  if (legacyValue === null || legacyValue === undefined) {\n    return false;\n  }\n\n  const destination = target && typeof target.setItem === 'function' ? target : source;\n\n  try {\n    const existing = destination.getItem(modernKey);\n    if (existing !== null && existing !== undefined) {\n      if (!keepLegacy && (source !== destination || legacyKey !== modernKey)) {\n        try {\n          source.removeItem(legacyKey);\n        } catch (removeError) {\n          console.warn(`Unable to remove legacy storage key ${legacyKey}`, removeError);\n        }\n      }\n      return false;\n    }\n  } catch (readError) {\n    console.warn(`Unable to inspect destination storage for ${modernKey}`, readError);\n  }\n\n  try {\n    destination.setItem(modernKey, legacyValue);\n  } catch (writeError) {\n    console.warn(`Unable to migrate legacy storage key ${legacyKey}`, writeError);\n    return false;\n  }\n\n  if (!keepLegacy) {\n    try {\n      source.removeItem(legacyKey);\n    } catch (removeError) {\n      console.warn(`Unable to remove legacy storage key ${legacyKey} after migration`, removeError);\n    }\n  }\n\n  return true;\n}\n\nfunction migrateKeyInStorages(storages, preferredTarget, legacyKey, modernKey, options) {\n  let migrated = false;\n  for (let i = 0; i < storages.length; i += 1) {\n    if (migrateKeyBetweenStorages(storages[i], preferredTarget, legacyKey, modernKey, options)) {\n      migrated = true;\n    }\n  }\n  return migrated;\n}\n\nfunction migrateLegacyStorageKeys() {\n  const safeStorage = getSafeLocalStorage();\n  const localStorages = collectUniqueStorages([\n    getWindowStorage('localStorage'),\n    safeStorage,\n  ]);\n  const sessionStorages = collectUniqueStorages([\n    getWindowStorage('sessionStorage'),\n    typeof sessionStorage !== 'undefined' ? sessionStorage : null,\n  ]);\n\n  const legacyPrefix = 'cinePowerPlanner_';\n\n  const mappings = [\n    { legacy: `${legacyPrefix}devices`, modern: DEVICE_STORAGE_KEY },\n    { legacy: `${legacyPrefix}setups`, modern: SETUP_STORAGE_KEY },\n    { legacy: `${legacyPrefix}session`, modern: SESSION_STATE_KEY, includeSession: true },\n    { legacy: `${legacyPrefix}feedback`, modern: FEEDBACK_STORAGE_KEY },\n    { legacy: `${legacyPrefix}project`, modern: PROJECT_STORAGE_KEY },\n    { legacy: `${legacyPrefix}projects`, modern: PROJECT_STORAGE_KEY },\n    { legacy: `${legacyPrefix}favorites`, modern: FAVORITES_STORAGE_KEY },\n    { legacy: `${legacyPrefix}ownGear`, modern: OWN_GEAR_STORAGE_KEY },\n    { legacy: `${legacyPrefix}schemaCache`, modern: DEVICE_SCHEMA_CACHE_KEY },\n    { legacy: `${legacyPrefix}autoGearRules`, modern: AUTO_GEAR_RULES_STORAGE_KEY },\n    { legacy: `${legacyPrefix}autoGearBackups`, modern: AUTO_GEAR_BACKUPS_STORAGE_KEY },\n    { legacy: `${legacyPrefix}autoGearSeeded`, modern: AUTO_GEAR_SEEDED_STORAGE_KEY },\n    { legacy: `${legacyPrefix}autoGearPresets`, modern: AUTO_GEAR_PRESETS_STORAGE_KEY },\n    { legacy: `${legacyPrefix}autoGearActivePreset`, modern: AUTO_GEAR_ACTIVE_PRESET_STORAGE_KEY },\n    { legacy: `${legacyPrefix}autoGearAutoPreset`, modern: AUTO_GEAR_AUTO_PRESET_STORAGE_KEY },\n    { legacy: `${legacyPrefix}autoGearShowBackups`, modern: AUTO_GEAR_BACKUP_VISIBILITY_STORAGE_KEY },\n    { legacy: `${legacyPrefix}autoGearBackupRetention`, modern: AUTO_GEAR_BACKUP_RETENTION_STORAGE_KEY },\n    { legacy: `${legacyPrefix}autoGearMonitorDefaults`, modern: AUTO_GEAR_MONITOR_DEFAULTS_STORAGE_KEY },\n    { legacy: `${legacyPrefix}customFonts`, modern: CUSTOM_FONT_STORAGE_KEY_DEFAULT, updateFontKey: true },\n  ];\n\n  mappings.forEach(({ legacy, modern, includeSession = false, updateFontKey = false }) => {\n    const migratedLocal = migrateKeyInStorages(localStorages, safeStorage, legacy, modern);\n    migrateKeyInStorages(\n      localStorages,\n      safeStorage,\n      `${legacy}${STORAGE_BACKUP_SUFFIX}`,\n      `${modern}${STORAGE_BACKUP_SUFFIX}`,\n    );\n\n    if (includeSession) {\n      migrateKeyInStorages(sessionStorages, null, legacy, modern);\n      migrateKeyInStorages(\n        sessionStorages,\n        null,\n        `${legacy}${STORAGE_BACKUP_SUFFIX}`,\n        `${modern}${STORAGE_BACKUP_SUFFIX}`,\n      );\n    }\n\n    if (updateFontKey && migratedLocal && GLOBAL_SCOPE) {\n      if (GLOBAL_SCOPE.CUSTOM_FONT_STORAGE_KEY === legacy) {\n        GLOBAL_SCOPE.CUSTOM_FONT_STORAGE_KEY = modern;\n      }\n      if (GLOBAL_SCOPE.CUSTOM_FONT_STORAGE_KEY_NAME === legacy) {\n        GLOBAL_SCOPE.CUSTOM_FONT_STORAGE_KEY_NAME = modern;\n      }\n    }\n  });\n}\n\nfunction applyLegacyStorageMigrations() {\n  migrateLegacyStorageKeys();\n}\n\n// Generic helpers for storage access\nfunction isSessionStorageInstance(storage) {\n  if (!storage || typeof storage.getItem !== 'function') {\n    return false;\n  }\n\n  if (\n    knownSessionStorages\n    && typeof knownSessionStorages.has === 'function'\n    && knownSessionStorages.has(storage)\n  ) {\n    return true;\n  }\n\n  if (\n    safeLocalStorageInfo\n    && safeLocalStorageInfo.type === 'session'\n    && safeLocalStorageInfo.storage === storage\n  ) {\n    registerKnownSessionStorage(storage);\n    return true;\n  }\n\n  const safeLocal = getSafeLocalStorage();\n  if (\n    safeLocal\n    && safeLocalStorageInfo\n    && safeLocalStorageInfo.type === 'session'\n    && safeLocal === storage\n  ) {\n    registerKnownSessionStorage(storage);\n    return true;\n  }\n\n  const scopes = [\n    GLOBAL_SCOPE,\n    GLOBAL_SCOPE && GLOBAL_SCOPE.__cineGlobal ? GLOBAL_SCOPE.__cineGlobal : null,\n    GLOBAL_SCOPE && GLOBAL_SCOPE.window ? GLOBAL_SCOPE.window : null,\n    typeof window !== 'undefined' ? window : null,\n    typeof self !== 'undefined' ? self : null,\n    typeof global !== 'undefined' ? global : null,\n  ];\n\n  for (let index = 0; index < scopes.length; index += 1) {\n    const candidate = resolveSessionStorageFromScope(scopes[index]);\n    if (candidate && candidate === storage) {\n      registerKnownSessionStorage(candidate);\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction loadJSONFromStorage(\n  storage,\n  key,\n  errorMessage,\n  defaultValue = null,\n  options = {},\n) {\n  if (!storage) return defaultValue;\n\n  const {\n    disableBackup = false,\n    backupKey,\n    validate,\n    restoreIfMissing = false,\n    alertOnFailure = null,\n    migrationBackupKey,\n  } = options || {};\n\n  const fallbackKey = typeof backupKey === 'string' && backupKey\n    ? backupKey\n    : `${key}${STORAGE_BACKUP_SUFFIX}`;\n  const useBackup = !disableBackup && fallbackKey && fallbackKey !== key;\n  const skipBackupRecovery = isFactoryResetActive() || (GLOBAL_SCOPE && GLOBAL_SCOPE.__cineJustFactoryReset);\n  const allowBackupRecovery = useBackup && !skipBackupRecovery;\n  const allowMigrationBackupRecovery = !skipBackupRecovery;\n\n  const migrationBackupCandidates = (() => {\n    const seen = new Set();\n    const candidates = [];\n\n    const pushCandidate = (candidate) => {\n      if (typeof candidate !== 'string' || !candidate || seen.has(candidate)) {\n        return;\n      }\n      seen.add(candidate);\n      candidates.push(candidate);\n    };\n\n    if (typeof migrationBackupKey === 'string' && migrationBackupKey) {\n      pushCandidate(migrationBackupKey);\n    }\n\n    const variants = getStorageKeyVariants(key);\n    for (let i = 0; i < variants.length; i += 1) {\n      pushCandidate(`${variants[i]}${STORAGE_MIGRATION_BACKUP_SUFFIX}`);\n    }\n\n    return candidates;\n  })();\n\n  const rawGetter = getRawStorageGetter(storage);\n  let rawStoredValue =\n    typeof rawGetter === 'function'\n      ? readRawStorageValue(storage, key, rawGetter)\n      : undefined;\n\n  let shouldAlert = false;\n\n  const parseRawValue = (raw, label) => {\n    if (raw === null || raw === undefined) {\n      return { ok: false, reason: 'missing' };\n    }\n    const normalizedRaw = typeof raw === 'string'\n      ? maybeDecompressStoredString(raw)\n      : raw;\n\n    if (\n      typeof raw === 'string'\n      && raw\n      && normalizedRaw === raw\n      && raw.includes(`\"${STORAGE_COMPRESSION_FLAG_KEY}\":true`)\n      && raw.includes(`\"namespace\":\"${STORAGE_COMPRESSION_NAMESPACE}`)\n    ) {\n      console.warn(\n        `${errorMessage} Compressed value could not be decoded${label ? ` (${label})` : ''}.`,\n      );\n      shouldAlert = true;\n      return { ok: false, reason: 'compressed' };\n    }\n    try {\n      const parsed = JSON.parse(normalizedRaw);\n      if (typeof validate === 'function' && !validate(parsed)) {\n        console.warn(`${errorMessage} Invalid data${label ? ` (${label})` : ''}.`);\n        shouldAlert = true;\n        return { ok: false, reason: 'invalid' };\n      }\n      return {\n        ok: true,\n        value: parsed,\n        raw,\n        normalizedRaw,\n      };\n    } catch (err) {\n      console.error(`${errorMessage}${label ? ` (${label})` : ''}`, err);\n      shouldAlert = true;\n      return { ok: false, reason: 'error' };\n    }\n  };\n\n  let primaryRaw = null;\n  try {\n    primaryRaw = storage.getItem(key);\n  } catch (err) {\n    console.error(`${errorMessage} (read)`, err);\n    downgradeSafeLocalStorageToMemory('read access', err, storage);\n    shouldAlert = true;\n  }\n\n  if (typeof rawStoredValue === 'undefined' && typeof rawGetter === 'function') {\n    rawStoredValue = readRawStorageValue(storage, key, rawGetter);\n  }\n\n  if (\n    (primaryRaw === null || primaryRaw === undefined)\n    && (rawStoredValue === null || rawStoredValue === undefined)\n  ) {\n    clearCachedStorageEntry(storage, key);\n  }\n\n  const cachedPrimary = tryGetCachedStorageValue(storage, key, primaryRaw, rawStoredValue);\n  if (cachedPrimary.hit) {\n    return cachedPrimary.value;\n  }\n\n  const primary = parseRawValue(primaryRaw, '');\n  if (primary.ok) {\n    const normalizedForCache = typeof primary.normalizedRaw === 'string' && primary.normalizedRaw\n      ? primary.normalizedRaw\n      : typeof primary.raw === 'string' && primary.raw\n        ? primary.raw\n        : null;\n    const rawForCache = typeof rawStoredValue === 'string' && rawStoredValue\n      ? rawStoredValue\n      : typeof primary.raw === 'string' && primary.raw\n        ? primary.raw\n        : null;\n    cacheStorageValue(storage, key, rawForCache, normalizedForCache, primary.value);\n    return primary.value;\n  }\n\n  const missingPrimary = !primary.ok && primary.reason === 'missing';\n\n  const attemptMigrationBackupRecovery = () => {\n    if (!migrationBackupCandidates.length) {\n      return { success: false, shouldAlert: false };\n    }\n\n    for (let i = 0; i < migrationBackupCandidates.length; i += 1) {\n      const candidateKey = migrationBackupCandidates[i];\n      let migrationRaw = null;\n      let migrationRawStored;\n\n      try {\n        migrationRaw = storage.getItem(candidateKey);\n      } catch (migrationReadError) {\n        console.error(`${errorMessage} (migration backup read)`, migrationReadError);\n        downgradeSafeLocalStorageToMemory('read access', migrationReadError, storage);\n        return { success: false, shouldAlert: true };\n      }\n\n      if (typeof rawGetter === 'function') {\n        migrationRawStored = readRawStorageValue(storage, candidateKey, rawGetter);\n      }\n\n      if (\n        (migrationRaw === null || migrationRaw === undefined)\n        && (migrationRawStored === null || migrationRawStored === undefined)\n      ) {\n        clearCachedStorageEntry(storage, candidateKey);\n        continue;\n      }\n\n      const rawSource = migrationRaw !== null && migrationRaw !== undefined\n        ? migrationRaw\n        : migrationRawStored;\n\n      const entry = { key: candidateKey, value: rawSource, type: 'migration-backup' };\n      const extracted = extractSnapshotStoredValue(entry);\n\n      if (typeof extracted === 'undefined') {\n        continue;\n      }\n\n      let candidateValue = extracted;\n      if (typeof candidateValue === 'string') {\n        const trimmed = candidateValue.trim();\n        if (trimmed) {\n          try {\n            candidateValue = JSON.parse(trimmed);\n          } catch (parseError) {\n            void parseError;\n          }\n        } else {\n          candidateValue = '';\n        }\n      }\n\n      if (typeof validate === 'function' && !validate(candidateValue)) {\n        console.warn(`Ignored migration backup for ${key} because it failed validation.`);\n        continue;\n      }\n\n      const migrationRawForCache = typeof migrationRawStored === 'string' && migrationRawStored\n        ? migrationRawStored\n        : typeof rawSource === 'string' && rawSource\n          ? rawSource\n          : null;\n      const normalizedMigrationRaw = typeof rawSource === 'string' && rawSource\n        ? rawSource\n        : typeof migrationRawStored === 'string' && migrationRawStored\n          ? migrationRawStored\n          : null;\n      cacheStorageValue(\n        storage,\n        candidateKey,\n        migrationRawForCache,\n        normalizedMigrationRaw,\n        candidateValue,\n      );\n\n      let serializedCandidate = null;\n      try {\n        serializedCandidate = JSON.stringify(candidateValue);\n      } catch (serializationError) {\n        console.warn(`Unable to serialize recovered migration backup for ${key}`, serializationError);\n        serializedCandidate = null;\n      }\n\n      let restoredRawValue = null;\n      let shouldEscalate = false;\n\n      if (serializedCandidate !== null) {\n        let payloadToStore = serializedCandidate;\n        const recompressed = typeof serializedCandidate === 'string'\n          ? createCompressedJsonStorageCandidate(serializedCandidate)\n          : null;\n        if (recompressed && typeof recompressed.serialized === 'string') {\n          payloadToStore = recompressed.serialized;\n        }\n\n        try {\n          storage.setItem(key, payloadToStore);\n          restoredRawValue = payloadToStore;\n        } catch (restoreError) {\n          console.warn(`Unable to restore primary copy for ${key} from migration backup`, restoreError);\n          downgradeSafeLocalStorageToMemory('write access', restoreError, storage);\n          shouldEscalate = true;\n        }\n      } else {\n        shouldEscalate = true;\n      }\n\n      if (restoredRawValue !== null) {\n        cacheStorageValue(storage, key, restoredRawValue, serializedCandidate, candidateValue);\n      } else if (serializedCandidate !== null) {\n        cacheStorageValue(storage, key, serializedCandidate, serializedCandidate, candidateValue);\n      } else {\n        cacheStorageValue(storage, key, null, null, candidateValue);\n      }\n\n      console.warn(\n        restoredRawValue !== null\n          ? `Recovered ${key} from migration backup copy.`\n          : `Recovered ${key} from migration backup copy but could not rewrite the primary entry.`,\n      );\n\n      // Remove the migration backup to prevent repeated recovery loops\n      try {\n        storage.removeItem(candidateKey);\n        clearCachedStorageEntry(storage, candidateKey);\n      } catch (removeError) {\n        console.warn(`Unable to remove migration backup ${candidateKey} after recovery`, removeError);\n      }\n\n      return { success: true, value: candidateValue, shouldAlert: shouldEscalate };\n    }\n\n    return { success: false, shouldAlert: false };\n  };\n\n  const shouldAttemptBackup =\n    allowBackupRecovery && (shouldAlert || restoreIfMissing || missingPrimary);\n\n  if (shouldAttemptBackup) {\n    let backupRaw = null;\n    try {\n      backupRaw = storage.getItem(fallbackKey);\n    } catch (err) {\n      console.error(`${errorMessage} (backup read)`, err);\n      downgradeSafeLocalStorageToMemory('read access', err, storage);\n      shouldAlert = true;\n    }\n\n    const backupRawStored = typeof rawGetter === 'function'\n      ? readRawStorageValue(storage, fallbackKey, rawGetter)\n      : undefined;\n    const backup = parseRawValue(backupRaw, 'backup');\n    if (backup.ok) {\n      if (shouldAlert || missingPrimary) {\n        console.warn(`Recovered ${key} from backup copy.`);\n      }\n      if (backup.raw !== null && backup.raw !== undefined) {\n        let restoredRawValue = null;\n        try {\n          if (typeof backup.raw === 'string') {\n            const recompressSource = typeof backup.normalizedRaw === 'string'\n              && backup.normalizedRaw\n              ? backup.normalizedRaw\n              : backup.raw;\n            const recompressed = createCompressedJsonStorageCandidate(recompressSource);\n            if (recompressed && typeof recompressed.serialized === 'string') {\n              storage.setItem(key, recompressed.serialized);\n              restoredRawValue = recompressed.serialized;\n            } else if (recompressSource !== backup.raw) {\n              storage.setItem(key, recompressSource);\n              restoredRawValue = recompressSource;\n            } else {\n              storage.setItem(key, backup.raw);\n              restoredRawValue = backup.raw;\n            }\n          } else {\n            storage.setItem(key, backup.raw);\n            restoredRawValue = typeof backup.raw === 'string' ? backup.raw : null;\n          }\n        } catch (restoreError) {\n          console.warn(`Unable to restore primary copy for ${key} from backup`, restoreError);\n          restoredRawValue = null;\n        }\n\n        const normalizedBackup = typeof backup.normalizedRaw === 'string' && backup.normalizedRaw\n          ? backup.normalizedRaw\n          : typeof backup.raw === 'string' && backup.raw\n            ? backup.raw\n            : null;\n        const fallbackRawForCache = typeof backupRawStored === 'string' && backupRawStored\n          ? backupRawStored\n          : typeof backup.raw === 'string' && backup.raw\n            ? backup.raw\n            : null;\n        cacheStorageValue(storage, fallbackKey, fallbackRawForCache, normalizedBackup, backup.value);\n        if (typeof restoredRawValue === 'string' && restoredRawValue) {\n          cacheStorageValue(storage, key, restoredRawValue, normalizedBackup, backup.value);\n        }\n        return backup.value;\n      }\n    }\n  }\n\n  const shouldAttemptMigrationBackup =\n    allowMigrationBackupRecovery\n    && migrationBackupCandidates.length > 0\n    && (missingPrimary || restoreIfMissing || shouldAlert);\n\n  if (shouldAttemptMigrationBackup) {\n    const migrationRecovery = attemptMigrationBackupRecovery();\n    if (migrationRecovery.success) {\n      if (migrationRecovery.shouldAlert) {\n        shouldAlert = true;\n      }\n\n      // Hard cleanup of migration key to ensure no loop\n      if (migrationBackupCandidates.length) {\n        const cleanupKey = migrationBackupCandidates[0].key;\n        try {\n          storage.removeItem(cleanupKey);\n          // Also force delete from internal fallback if present\n          if (storage[STORAGE_RAW_GET_ITEM_PROPERTY] && storage.removeItem) {\n            storage.removeItem(cleanupKey);\n          }\n        } catch (cleanupErr) {\n          console.warn('Post-migration cleanup error:', cleanupErr);\n        }\n      }\n\n      return migrationRecovery.value;\n    }\n    if (migrationRecovery.shouldAlert) {\n      shouldAlert = true;\n    }\n  }\n\n  if (shouldAlert) {\n    alertStorageError(alertOnFailure);\n  }\n\n  clearCachedStorageEntry(storage, key);\n  // Log why we are returning default\n  if (missingPrimary && !shouldAttemptBackup && !shouldAttemptMigrationBackup) {\n    console.debug(`[Storage] Returning default for ${key} (No primary, no backups found)`);\n  }\n  return defaultValue;\n}\n\nfunction saveJSONToStorage(\n  storage,\n  key,\n  value,\n  errorMessage,\n  options = {},\n) {\n  if (!storage) {\n    console.warn('DEBUG: saveJSONToStorage NO STORAGE');\n    return;\n  }\n  if (isFactoryResetActive()) {\n    console.warn('DEBUG: saveJSONToStorage RESET ACTIVE');\n    return;\n  }\n\n  const {\n    disableBackup = false,\n    backupKey,\n    onQuotaExceeded,\n    enableCompressionSweep = true,\n    disableCompression = false,\n    forceCompressionOnQuota = false,\n  } = options || {};\n  const fallbackKey = typeof backupKey === 'string' && backupKey\n    ? backupKey\n    : `${key}${STORAGE_BACKUP_SUFFIX}`;\n  const useBackup = !disableBackup && fallbackKey && fallbackKey !== key;\n  const sessionScopedStorage = isSessionStorageInstance(storage);\n  const compressionBlocked = sessionScopedStorage || Boolean(disableCompression);\n  const allowQuotaCompression =\n    sessionScopedStorage ? false : forceCompressionOnQuota === true;\n\n  const rawGetter = getRawStorageGetter(storage);\n  const loadRawValue = (targetKey) => readRawStorageValue(storage, targetKey, rawGetter);\n\n  let standardSerializedCache;\n  let standardSerializationComputed = false;\n  let compressionCandidate;\n  let useCompressedSerialization = false;\n  let compressionAttempted = false;\n  let compressionLogged = false;\n\n  const resetSerializationState = () => {\n    standardSerializedCache = undefined;\n    standardSerializationComputed = false;\n    compressionCandidate = undefined;\n    useCompressedSerialization = false;\n    compressionAttempted = false;\n    compressionLogged = false;\n  };\n\n  const computeStandardSerialized = () => {\n    if (standardSerializationComputed) {\n      return standardSerializedCache;\n    }\n    standardSerializationComputed = true;\n    try {\n      standardSerializedCache = JSON.stringify(value);\n    } catch (serializationError) {\n      standardSerializedCache = null;\n      console.error(errorMessage, serializationError);\n      alertStorageError();\n    }\n    return standardSerializedCache;\n  };\n\n  const computeCompressedSerialized = () => {\n    if (compressionCandidate !== undefined) {\n      return compressionCandidate && typeof compressionCandidate.serialized === 'string'\n        ? compressionCandidate.serialized\n        : null;\n    }\n\n    const baseline = computeStandardSerialized();\n    if (typeof baseline !== 'string' || !baseline) {\n      compressionCandidate = null;\n      return null;\n    }\n\n    const candidate = createCompressedJsonStorageCandidate(baseline);\n    if (!candidate || typeof candidate.serialized !== 'string') {\n      compressionCandidate = null;\n      return null;\n    }\n\n    compressionCandidate = candidate;\n    return candidate.serialized;\n  };\n\n  const getSerializedForAttempt = () => {\n    if (useCompressedSerialization) {\n      const compressed = computeCompressedSerialized();\n      if (typeof compressed === 'string') {\n        return compressed;\n      }\n      useCompressedSerialization = false;\n    }\n\n    const standard = computeStandardSerialized();\n    if (typeof standard === 'string') {\n      return standard;\n    }\n    return null;\n  };\n\n  const tryEnableCompression = ({ force = false } = {}) => {\n    const forcing = force && allowQuotaCompression;\n    if (compressionBlocked && !forcing) {\n      compressionAttempted = true;\n      return false;\n    }\n    if (useCompressedSerialization) {\n      return false;\n    }\n    if (compressionAttempted && !forcing) {\n      return false;\n    }\n    compressionAttempted = true;\n    const baseline = computeStandardSerialized();\n    if (typeof baseline !== 'string' || !baseline) {\n      return false;\n    }\n    const compressed = computeCompressedSerialized();\n    if (typeof compressed !== 'string' || !compressed) {\n      return false;\n    }\n    if (compressed.length >= baseline.length) {\n      return false;\n    }\n    useCompressedSerialization = true;\n    return true;\n  };\n\n  const logCompressionIfNeeded = () => {\n    if (!useCompressedSerialization || !compressionCandidate || compressionLogged) {\n      return;\n    }\n\n    const { originalLength, wrappedLength } = compressionCandidate;\n    if (\n      typeof originalLength === 'number'\n      && typeof wrappedLength === 'number'\n      && wrappedLength < originalLength\n    ) {\n      const savings = originalLength - wrappedLength;\n      const percent = originalLength > 0 ? Math.round((savings / originalLength) * 100) : 0;\n      const message = `Stored compressed value for ${key} to reduce storage usage by ${savings} characters (${percent}%).`;\n      logCompressionSavingsEvent('storage-value', key, message, savings, percent);\n    }\n\n    compressionLogged = true;\n  };\n\n  const maybeEnableProactiveCompression = () => {\n    if (compressionBlocked) {\n      compressionAttempted = true;\n      return;\n    }\n    if (useCompressedSerialization || compressionAttempted) {\n      return;\n    }\n\n    const baseline = computeStandardSerialized();\n    if (typeof baseline !== 'string' || !baseline) {\n      return;\n    }\n\n    if (baseline.length < STORAGE_PROACTIVE_COMPRESSION_MIN_LENGTH) {\n      return;\n    }\n\n    const compressed = computeCompressedSerialized();\n    if (typeof compressed !== 'string' || !compressed) {\n      return;\n    }\n\n    const savings = baseline.length - compressed.length;\n    if (savings < STORAGE_PROACTIVE_COMPRESSION_MIN_SAVINGS) {\n      return;\n    }\n\n    const ratio = baseline.length > 0 ? savings / baseline.length : 0;\n    if (ratio < STORAGE_PROACTIVE_COMPRESSION_MIN_RATIO) {\n      return;\n    }\n\n    const rawExisting = loadRawValue(key);\n    if (typeof rawExisting === 'string' && rawExisting === compressed) {\n      return;\n    }\n\n    useCompressedSerialization = true;\n    compressionAttempted = true;\n  };\n\n  let preservedBackupValue;\n  let hasPreservedBackup = false;\n  let removedBackupDuringRetry = false;\n  let quotaRecoverySteps = 0;\n  let quotaRecoveryFailed = false;\n  let compressionSweepAttempted = false;\n\n  maybeEnableProactiveCompression();\n\n  const registerQuotaRecoveryStep = () => {\n    quotaRecoverySteps += 1;\n    if (quotaRecoverySteps > MAX_QUOTA_RECOVERY_STEPS) {\n      quotaRecoveryFailed = true;\n      console.warn(`Exceeded maximum storage recovery attempts while saving ${key}.`);\n      return false;\n    }\n    return true;\n  };\n\n  const attemptStorageCleanup = (storage, options) => {\n    if (!storage || typeof storage.length !== 'number' || typeof storage.key !== 'function') {\n      return { success: false, freed: 0 };\n    }\n\n    const { skipKeys = [] } = options || {};\n    const skipSet = new Set(skipKeys);\n    if (ACTIVE_PROJECT_COMPRESSION_HOLD_ENABLED && ACTIVE_PROJECT_COMPRESSION_HOLD_KEY) {\n      skipSet.add(ACTIVE_PROJECT_COMPRESSION_HOLD_KEY);\n    }\n\n    const candidates = [];\n    const total = storage.length;\n\n    for (let i = 0; i < total; i += 1) {\n      let key;\n      try {\n        key = storage.key(i);\n      } catch {\n        continue;\n      }\n\n      if (!key || skipSet.has(key)) continue;\n\n      // Priority 1: Legacy migration backups (safest to delete)\n      if (key.endsWith('__legacyMigrationBackup')) {\n        candidates.push({ key, priority: 1, size: 0 }); // Size calc is expensive, do lazily if needed or just count on priority\n        continue;\n      }\n\n      // Priority 2: Standard backups (safe if we have primary)\n      if (key.endsWith('__backup')) {\n        candidates.push({ key, priority: 2, size: 0 });\n        continue;\n      }\n\n      // Priority 3: Caches (can be rebuilt)\n      if (key === DEVICE_SCHEMA_CACHE_KEY || key === LEGACY_SCHEMA_CACHE_KEY) {\n        candidates.push({ key, priority: 3, size: 0 });\n        continue;\n      }\n\n      // Priority 4: Auto-backup project shards (oldest first, safe to delete)\n      if (key.startsWith(PROJECT_SHARD_PREFIX) && key.includes('auto-backup-')) {\n        candidates.push({ key, priority: 4, size: 0 });\n        continue;\n      }\n    }\n\n    if (!candidates.length) {\n      return { success: false, freed: 0 };\n    }\n\n    // Sort by priority (ascending)\n    candidates.sort((a, b) => a.priority - b.priority);\n\n    let freed = 0;\n    let cleaned = 0;\n\n    for (let i = 0; i < candidates.length; i += 1) {\n      const candidate = candidates[i];\n      try {\n        const val = storage.getItem(candidate.key);\n        const size = val ? val.length : 0;\n        storage.removeItem(candidate.key);\n        clearCachedStorageEntry(storage, candidate.key);\n        freed += size;\n        cleaned += 1;\n        console.warn(`[Storage Cleanup] Removed ${candidate.key} to free ${size} chars.`);\n        // If we freed a significant amount, we might stop, but for now let's be aggressive\n        // to ensure the user's save succeeds.\n        if (freed > 500000) { // Arbitrary threshold to stop if we freed \"enough\"\n          break;\n        }\n      } catch (e) {\n        console.warn(`[Storage Cleanup] Failed to remove ${candidate.key}`, e);\n      }\n    }\n\n    return { success: cleaned > 0, freed };\n  };\n\n  const attemptHandleQuota = (error, context = {}) => {\n    if (!isQuotaExceededError(error)) {\n      return false;\n    }\n\n    if (typeof onQuotaExceeded === 'function') {\n      try {\n        if (\n          onQuotaExceeded(error, {\n            storage,\n            key,\n            value,\n            ...context,\n          }) === true\n        ) {\n          return true;\n        }\n      } catch (handlerError) {\n        const scope = context && context.isBackup ? ' (backup)' : '';\n        console.error(`Error while handling quota exceed for ${key}${scope}`, handlerError);\n      }\n    }\n\n    // First try compression\n    if (!compressionSweepAttempted && enableCompressionSweep !== false) {\n      compressionSweepAttempted = true;\n      const skipKeys = [key];\n      if (useBackup && typeof fallbackKey === 'string' && fallbackKey && fallbackKey !== key) {\n        skipKeys.push(fallbackKey);\n      }\n      if (context && typeof context.backupKey === 'string' && context.backupKey) {\n        skipKeys.push(context.backupKey);\n      }\n\n      const sweepResult = attemptStorageCompressionSweep(storage, { skipKeys });\n      if (sweepResult && sweepResult.success) {\n        return true;\n      }\n    }\n\n    // If compression failed or wasn't enough, try cleanup\n    const skipKeysCleanup = [key];\n    if (useBackup && typeof fallbackKey === 'string' && fallbackKey) {\n      skipKeysCleanup.push(fallbackKey);\n    }\n    const cleanupResult = attemptStorageCleanup(storage, { skipKeys: skipKeysCleanup });\n    return Boolean(cleanupResult && cleanupResult.success);\n  };\n\n  let attempts = 0;\n  while (attempts < MAX_SAVE_ATTEMPTS) {\n    attempts += 1;\n\n    const serialized = getSerializedForAttempt();\n    if (typeof serialized !== 'string') {\n      return;\n    }\n\n    const normalizedSerialized = computeStandardSerialized();\n    const normalizedString = typeof normalizedSerialized === 'string' && normalizedSerialized\n      ? normalizedSerialized\n      : null;\n\n    let skipPrimaryWrite = false;\n    let existingBackupValue;\n    let hasExistingBackup = false;\n    let existingBackupRaw = null;\n    let observedPrimaryRawValue = null;\n    let observedBackupRawValue = null;\n\n    if (typeof storage.getItem === 'function') {\n      try {\n        const existingValue = storage.getItem(key);\n        if (existingValue === serialized) {\n          skipPrimaryWrite = true;\n          observedPrimaryRawValue = serialized;\n        } else if (useCompressedSerialization) {\n          const existingRawValue = loadRawValue(key);\n          if (typeof existingRawValue === 'string') {\n            observedPrimaryRawValue = existingRawValue;\n            if (existingRawValue === serialized) {\n              skipPrimaryWrite = true;\n            }\n          }\n        } else if (typeof existingValue === 'string') {\n          observedPrimaryRawValue = existingValue;\n        }\n      } catch (inspectError) {\n        console.warn(`Unable to inspect existing value for ${key}`, inspectError);\n      }\n    }\n\n    if (useBackup && typeof storage.getItem === 'function') {\n      try {\n        existingBackupValue = storage.getItem(fallbackKey);\n        hasExistingBackup = typeof existingBackupValue === 'string';\n        if (hasExistingBackup && useCompressedSerialization) {\n          existingBackupRaw = loadRawValue(fallbackKey);\n          if (typeof existingBackupRaw === 'string') {\n            observedBackupRawValue = existingBackupRaw;\n          }\n        } else if (hasExistingBackup) {\n          observedBackupRawValue = existingBackupValue;\n        }\n      } catch (inspectError) {\n        console.warn(`Unable to inspect existing backup for ${key}`, inspectError);\n      }\n    }\n\n    if (!hasPreservedBackup && hasExistingBackup && typeof existingBackupValue === 'string') {\n      preservedBackupValue = existingBackupValue;\n      hasPreservedBackup = true;\n    }\n\n    const backupCandidates = (() => {\n      if (!useBackup) {\n        return [];\n      }\n\n      const candidates = [];\n\n      if (useCompressedSerialization) {\n        const standardSerialized = computeStandardSerialized();\n        if (typeof standardSerialized === 'string' && standardSerialized) {\n          candidates.push({ serialized: standardSerialized, compressed: false });\n        }\n\n        if (\n          typeof serialized === 'string'\n          && serialized\n          && (!candidates.length || candidates[candidates.length - 1].serialized !== serialized)\n        ) {\n          candidates.push({ serialized, compressed: true });\n        }\n      } else if (typeof serialized === 'string' && serialized) {\n        candidates.push({ serialized, compressed: false });\n      }\n\n      return candidates;\n    })();\n\n    const preferredBackupCandidate = backupCandidates.length ? backupCandidates[0] : null;\n\n    const backupMatchesPreferred = hasExistingBackup\n      && preferredBackupCandidate\n      && typeof preferredBackupCandidate.serialized === 'string'\n      && (\n        existingBackupValue === preferredBackupCandidate.serialized\n        || (\n          typeof existingBackupRaw === 'string'\n          && existingBackupRaw === preferredBackupCandidate.serialized\n        )\n      );\n\n    if (skipPrimaryWrite && (!useBackup || backupMatchesPreferred)) {\n      if (normalizedString) {\n        const rawForCacheUpdate = useCompressedSerialization\n          ? (typeof observedPrimaryRawValue === 'string' && observedPrimaryRawValue\n            ? observedPrimaryRawValue\n            : serialized)\n          : serialized;\n        cacheStorageValue(storage, key, rawForCacheUpdate, normalizedString, value);\n        if (useBackup && hasExistingBackup) {\n          const backupRawForCache = useCompressedSerialization\n            ? (typeof existingBackupRaw === 'string' && existingBackupRaw\n              ? existingBackupRaw\n              : observedBackupRawValue)\n            : observedBackupRawValue;\n          if (typeof backupRawForCache === 'string' && backupRawForCache) {\n            cacheStorageValue(storage, fallbackKey, backupRawForCache, normalizedString, value);\n          }\n        }\n      }\n      return;\n    }\n\n    if (!skipPrimaryWrite) {\n      try {\n        storage.setItem(key, serialized);\n        logCompressionIfNeeded();\n        if (normalizedString) {\n          cacheStorageValue(storage, key, serialized, normalizedString, value);\n        }\n      } catch (error) {\n        if (attemptHandleQuota(error)) {\n          resetSerializationState();\n          if (!registerQuotaRecoveryStep()) {\n            break;\n          }\n          if (attempts > 0) {\n            attempts -= 1;\n          }\n          continue;\n        }\n        if (!quotaRecoveryFailed && tryEnableCompression({ force: allowQuotaCompression })) {\n          if (!registerQuotaRecoveryStep()) {\n            break;\n          }\n          if (attempts > 0) {\n            attempts -= 1;\n          }\n          continue;\n        }\n        console.error(errorMessage, error);\n        downgradeSafeLocalStorageToMemory('write access', error, storage);\n        alertStorageError();\n        return;\n      }\n    }\n\n    if (!useBackup) {\n      return;\n    }\n\n    if (backupMatchesPreferred) {\n      if (normalizedString && hasExistingBackup) {\n        const backupRawForCache = useCompressedSerialization\n          ? (typeof existingBackupRaw === 'string' && existingBackupRaw\n            ? existingBackupRaw\n            : observedBackupRawValue)\n          : observedBackupRawValue;\n        if (typeof backupRawForCache === 'string' && backupRawForCache) {\n          cacheStorageValue(storage, fallbackKey, backupRawForCache, normalizedString, value);\n        }\n      }\n      return;\n    }\n\n    const attemptBackupWrite = () => {\n      const candidates = backupCandidates.length\n        ? backupCandidates\n        : [{ serialized, compressed: useCompressedSerialization }];\n\n      let backupError = null;\n      let backupRemovedForRetry = false;\n      let lastCandidate = null;\n\n      const tryStoreCandidate = (candidate) => {\n        try {\n          storage.setItem(fallbackKey, candidate.serialized);\n          if (candidate.compressed) {\n            logCompressionIfNeeded();\n          }\n          removedBackupDuringRetry = false;\n          return true;\n        } catch (error) {\n          backupError = error;\n          return false;\n        }\n      };\n\n      for (let index = 0; index < candidates.length; index += 1) {\n        const candidate = candidates[index];\n        lastCandidate = candidate;\n\n        if (tryStoreCandidate(candidate)) {\n          if (normalizedString) {\n            const normalizedForBackup = candidate.compressed && normalizedString\n              ? normalizedString\n              : candidate.serialized;\n            cacheStorageValue(storage, fallbackKey, candidate.serialized, normalizedForBackup, value);\n          }\n          return 'success';\n        }\n\n        if (!isQuotaExceededError(backupError)) {\n          break;\n        }\n\n        if (!backupRemovedForRetry && hasExistingBackup) {\n          try {\n            storage.removeItem(fallbackKey);\n            clearCachedStorageEntry(storage, fallbackKey);\n            backupRemovedForRetry = true;\n            removedBackupDuringRetry = true;\n            hasExistingBackup = false;\n            if (tryStoreCandidate(candidate)) {\n              if (normalizedString) {\n                const normalizedForBackup = candidate.compressed && normalizedString\n                  ? normalizedString\n                  : candidate.serialized;\n                cacheStorageValue(storage, fallbackKey, candidate.serialized, normalizedForBackup, value);\n              }\n              return 'success';\n            }\n          } catch (removeError) {\n            console.warn(`Unable to remove previous backup for ${key}`, removeError);\n          }\n        }\n      }\n\n      if (isQuotaExceededError(backupError)) {\n        if (attemptHandleQuota(backupError, {\n          serialized: lastCandidate && typeof lastCandidate.serialized === 'string'\n            ? lastCandidate.serialized\n            : serialized,\n          backupKey: fallbackKey,\n          isBackup: true,\n        })) {\n          resetSerializationState();\n          if (!registerQuotaRecoveryStep()) {\n            return 'failure';\n          }\n          return 'retry';\n        }\n\n        if (!quotaRecoveryFailed && tryEnableCompression({ force: allowQuotaCompression })) {\n          resetSerializationState();\n          if (!registerQuotaRecoveryStep()) {\n            return 'failure';\n          }\n          return 'retry';\n        }\n      }\n\n      if (backupRemovedForRetry && typeof existingBackupValue === 'string') {\n        try {\n          storage.setItem(fallbackKey, existingBackupValue);\n          if (normalizedString) {\n            cacheStorageValue(storage, fallbackKey, existingBackupValue, normalizedString, value);\n          }\n          removedBackupDuringRetry = false;\n        } catch (restoreError) {\n          console.warn(`Unable to restore previous backup for ${key}`, restoreError);\n        }\n      }\n\n      console.warn(`Unable to update backup copy for ${key}`, backupError);\n      alertStorageError();\n      return 'failure';\n    };\n\n    const backupResult = attemptBackupWrite();\n    if (backupResult === 'success') {\n      return;\n    }\n\n    if (backupResult === 'retry') {\n      if (attempts > 0) {\n        attempts -= 1;\n      }\n      continue;\n    }\n\n    if (quotaRecoveryFailed) {\n      break;\n    }\n\n    return;\n  }\n\n  if (hasPreservedBackup && removedBackupDuringRetry && typeof preservedBackupValue === 'string') {\n    try {\n      storage.setItem(fallbackKey, preservedBackupValue);\n      clearCachedStorageEntry(storage, fallbackKey);\n    } catch (restoreError) {\n      console.warn(`Unable to restore preserved backup for ${key}`, restoreError);\n    }\n  }\n\n  console.error(errorMessage, new Error('Unable to save value after multiple attempts.'));\n  alertStorageError();\n}\n\n// Generic helper to delete a key from storage with consistent error handling\nfunction deleteFromStorage(storage, key, errorMessage, options = {}) {\n  if (!storage) return;\n\n  // [Agent Refactor] Also clear from new repo (best effort, async)\n  if (storageRepo) {\n    storageRepo.removeItem(key).catch(() => { });\n  }\n\n  const { disableBackup = false, backupKey, disableMigrationCleanup = false } = options || {};\n  const fallbackKey = typeof backupKey === 'string' && backupKey\n    ? backupKey\n    : `${key}${STORAGE_BACKUP_SUFFIX}`;\n  const useBackup = !disableBackup && fallbackKey && fallbackKey !== key;\n\n  clearCachedStorageEntry(storage, key);\n  if (useBackup) {\n    clearCachedStorageEntry(storage, fallbackKey);\n  }\n\n  if (key === PROJECT_STORAGE_KEY) {\n    invalidateProjectReadCache();\n  }\n\n  try {\n    storage.removeItem(key);\n  } catch (e) {\n    console.error(errorMessage, e);\n    downgradeSafeLocalStorageToMemory('deletion', e, storage);\n    alertStorageError();\n  }\n\n  if (useBackup) {\n    try {\n      storage.removeItem(fallbackKey);\n    } catch (backupError) {\n      console.error(`${errorMessage} (backup)`, backupError);\n      downgradeSafeLocalStorageToMemory('deletion', backupError, storage);\n      alertStorageError();\n    }\n  }\n\n  if (!disableMigrationCleanup) {\n    const migrationBackupKey = `${key}${STORAGE_MIGRATION_BACKUP_SUFFIX}`;\n    try {\n      storage.removeItem(migrationBackupKey);\n    } catch (migrationError) {\n      console.warn(`Unable to remove migration backup for ${key}`, migrationError);\n    }\n  }\n}\n\nvar UI_CACHE_STORAGE_KEYS = [\n  DEVICE_SCHEMA_CACHE_KEY,\n  LEGACY_SCHEMA_CACHE_KEY,\n];\n\nvar UI_CACHE_STORAGE_ACCESS_WARNINGS = new Set();\n\nfunction collectUiCacheStorages() {\n  const candidates = [];\n  const seenScopes = new Set();\n\n  const pushCandidate = (candidate) => {\n    if (!candidate || typeof candidate.getItem !== 'function') {\n      return;\n    }\n    candidates.push(candidate);\n  };\n\n  const readProperty = (scope, property, label) => {\n    if (!scope || (typeof scope !== 'object' && typeof scope !== 'function')) {\n      return null;\n    }\n    try {\n      return scope[property];\n    } catch (error) {\n      if (label && !UI_CACHE_STORAGE_ACCESS_WARNINGS.has(label)) {\n        UI_CACHE_STORAGE_ACCESS_WARNINGS.add(label);\n        console.warn(`Unable to access ${label} while clearing UI caches`, error);\n      }\n      return null;\n    }\n  };\n\n  const inspectScope = (scope, label) => {\n    if (!scope || seenScopes.has(scope)) {\n      return;\n    }\n    seenScopes.add(scope);\n\n    pushCandidate(readProperty(scope, 'SAFE_LOCAL_STORAGE', `${label}.SAFE_LOCAL_STORAGE`));\n    pushCandidate(readProperty(scope, 'localStorage', `${label}.localStorage`));\n    pushCandidate(readProperty(scope, 'sessionStorage', `${label}.sessionStorage`));\n\n    const nested = readProperty(scope, '__cineGlobal', `${label}.__cineGlobal`);\n    if (nested && nested !== scope) {\n      inspectScope(nested, `${label}.__cineGlobal`);\n    }\n  };\n\n  inspectScope(typeof globalThis !== 'undefined' ? globalThis : null, 'globalThis');\n  inspectScope(typeof window !== 'undefined' ? window : null, 'window');\n  inspectScope(typeof self !== 'undefined' ? self : null, 'self');\n  inspectScope(typeof global !== 'undefined' ? global : null, 'global');\n  if (GLOBAL_SCOPE && GLOBAL_SCOPE.__cineGlobal) {\n    inspectScope(GLOBAL_SCOPE.__cineGlobal, '__cineGlobal');\n  }\n\n  if (safeLocalStorageInfo && safeLocalStorageInfo.storage) {\n    pushCandidate(safeLocalStorageInfo.storage);\n  }\n\n  if (typeof getSafeLocalStorage === 'function' && getSafeLocalStorage()) {\n    pushCandidate(getSafeLocalStorage());\n  }\n\n  try {\n    pushCandidate(getSafeLocalStorage());\n  } catch (error) {\n    if (!UI_CACHE_STORAGE_ACCESS_WARNINGS.has('getSafeLocalStorage')) {\n      UI_CACHE_STORAGE_ACCESS_WARNINGS.add('getSafeLocalStorage');\n      console.warn('Unable to access safe local storage while clearing UI caches', error);\n    }\n  }\n\n  pushCandidate(getWindowStorage('localStorage'));\n  pushCandidate(getWindowStorage('sessionStorage'));\n\n  if (typeof localStorage !== 'undefined') {\n    pushCandidate(localStorage);\n  }\n\n  if (typeof sessionStorage !== 'undefined') {\n    pushCandidate(sessionStorage);\n  }\n\n  return collectUniqueStorages(candidates);\n}\n\nfunction clearUiCacheStorageEntries() {\n  const storages = collectUiCacheStorages();\n  if (!storages.length) {\n    return;\n  }\n\n  UI_CACHE_STORAGE_KEYS.forEach((key) => {\n    // [Agent] Clean from new repo as well (async)\n    if (storageRepo) {\n      storageRepo.removeItem(key).catch(e => console.warn('Failed to clear UI cache from repo', e));\n    }\n\n    if (typeof key !== 'string' || !key) {\n      return;\n    }\n\n    storages.forEach((storage) => {\n      deleteFromStorage(storage, key, `Failed to clear UI cache entry ${key}`);\n    });\n  });\n}\n\nfunction loadFlagFromStorage(storage, key, errorMessage) {\n  if (!storage) return false;\n  try {\n    return storage.getItem(key) === '1';\n  } catch (e) {\n    console.error(errorMessage, e);\n    downgradeSafeLocalStorageToMemory('read access', e, storage);\n    alertStorageError();\n    return false;\n  }\n}\n\nfunction saveFlagToStorage(storage, key, value, errorMessage) {\n  if (!storage) return;\n  try {\n    if (value) {\n      storage.setItem(key, '1');\n    } else {\n      storage.removeItem(key);\n    }\n  } catch (e) {\n    console.error(errorMessage, e);\n    downgradeSafeLocalStorageToMemory('write access', e, storage);\n    alertStorageError();\n  }\n}\n\n// Attempt to load JSON from a primary storage. If missing, try a fallback\n// storage and migrate the data to the primary one. Useful for gradually moving\n// keys from sessionStorage to localStorage.\nfunction loadWithMigration(\n  primary,\n  fallback,\n  key,\n  primaryLoadMsg,\n  fallbackLoadMsg,\n  saveMsg,\n  deleteMsg,\n  loadOptions,\n) {\n  const value = loadJSONFromStorage(primary, key, primaryLoadMsg, null, loadOptions);\n  if (value !== null) return value;\n  if (!fallback) return null;\n  const fallbackOptions = {\n    ...(loadOptions || {}),\n    alertOnFailure: 'migration-read',\n  };\n  const migrated = loadJSONFromStorage(\n    fallback,\n    key,\n    fallbackLoadMsg,\n    null,\n    fallbackOptions,\n  );\n  if (migrated !== null) {\n    saveJSONToStorage(primary, key, migrated, saveMsg);\n    deleteFromStorage(fallback, key, deleteMsg);\n    return migrated;\n  }\n  return null;\n}\n\n// Generate a unique name by appending numeric suffixes if needed\n// Comparisons are case-insensitive and ignore surrounding whitespace.\n// Optionally accepts a set of normalized names to avoid recomputing the\n// normalised lookup on each call when generating many names in a loop.\nfunction generateUniqueName(base, usedNames, normalizedNames) {\n  const trimmedBase = base.trim();\n  let name = trimmedBase;\n  let suffix = 2;\n\n  const normalized = normalizedNames || new Set(\n    [...usedNames].map((n) => n.trim().toLowerCase()),\n  );\n  let candidate = trimmedBase.toLowerCase();\n  while (normalized.has(candidate)) {\n    name = `${trimmedBase} (${suffix++})`;\n    candidate = name.toLowerCase();\n  }\n  usedNames.add(name);\n  normalized.add(candidate);\n  return name;\n}\n\nfunction ensureImportedProjectBaseName(rawName) {\n  const trimmed = typeof rawName === \"string\" ? rawName.trim() : \"\";\n  if (!trimmed) {\n    return \"Project-imported\";\n  }\n\n  const importedMatch = trimmed.match(/^(.*?)-imported(?:-(\\d+))?$/i);\n  if (importedMatch) {\n    const prefix = typeof importedMatch[1] === \"string\"\n      ? importedMatch[1].trim()\n      : \"\";\n    return prefix ? `${prefix}-imported` : \"Project-imported\";\n  }\n\n  if (trimmed.toLowerCase().endsWith(\"-imported\")) {\n    return trimmed;\n  }\n\n  return `${trimmed}-imported`;\n}\n\nfunction resolveImportedProjectNamingContext(rawName) {\n  const trimmed = typeof rawName === \"string\" ? rawName.trim() : \"\";\n  const base = ensureImportedProjectBaseName(rawName);\n\n  if (!trimmed) {\n    return {\n      base,\n      initialCandidate: base,\n      suffixStart: 2,\n    };\n  }\n\n  const importedMatch = trimmed.match(/^(.*?)-imported(?:-(\\d+))?$/i);\n  const parsedSuffix = importedMatch && importedMatch[2]\n    ? Number(importedMatch[2])\n    : NaN;\n  const suffixStart = Number.isFinite(parsedSuffix) ? parsedSuffix + 1 : 2;\n\n  if (importedMatch) {\n    return {\n      base,\n      initialCandidate: trimmed,\n      suffixStart,\n    };\n  }\n\n  return {\n    base,\n    initialCandidate: base,\n    suffixStart: 2,\n  };\n}\n\nfunction generateImportedProjectName(baseName, usedNames, normalizedNames) {\n  const normalized = normalizedNames\n    || new Set(\n      [...usedNames]\n        .map((name) => (typeof name === \"string\" ? name.trim().toLowerCase() : \"\"))\n        .filter((name) => name),\n    );\n\n  const context = resolveImportedProjectNamingContext(baseName);\n  let candidate = typeof context.initialCandidate === \"string\"\n    ? context.initialCandidate.trim()\n    : \"\";\n\n  if (!candidate) {\n    candidate = context.base || \"Project-imported\";\n  }\n\n  let normalizedCandidate = candidate.trim().toLowerCase();\n  let suffix = context.suffixStart;\n  while (normalizedCandidate && normalized.has(normalizedCandidate)) {\n    const base = context.base || \"Project-imported\";\n    candidate = `${base}-${suffix++}`;\n    normalizedCandidate = candidate.trim().toLowerCase();\n  }\n\n  usedNames.add(candidate);\n  if (normalizedCandidate) {\n    normalized.add(normalizedCandidate);\n  }\n\n  return candidate;\n}\n\nfunction ensureUpdatedProjectBaseName(rawName) {\n  const trimmed = typeof rawName === \"string\" ? rawName.trim() : \"\";\n  if (!trimmed) {\n    return \"Project-updated\";\n  }\n  if (trimmed.toLowerCase().endsWith(\"-updated\")) {\n    return trimmed;\n  }\n  return `${trimmed}-updated`;\n}\n\nfunction generateUpdatedProjectName(baseName, usedNames, normalizedNames) {\n  const normalized = normalizedNames || new Set(\n    [...usedNames]\n      .map((name) => (typeof name === \"string\" ? name.trim().toLowerCase() : \"\"))\n      .filter((name) => name),\n  );\n  const base = ensureUpdatedProjectBaseName(baseName);\n  let candidate = base;\n  let suffix = 2;\n  let normalizedCandidate = candidate.trim().toLowerCase();\n  while (normalizedCandidate && normalized.has(normalizedCandidate)) {\n    candidate = `${base}-${suffix++}`;\n    normalizedCandidate = candidate.trim().toLowerCase();\n  }\n  return candidate;\n}\n\n// --- Session State Storage ---\n// Store the current session (unsaved setup) in localStorage so it survives\n// full app reloads.\nfunction collectStringValues(value) {\n  if (value === null || value === undefined) {\n    return [];\n  }\n  if (typeof value === 'string') {\n    const trimmed = value.trim();\n    return trimmed ? [trimmed] : [];\n  }\n  if (Array.isArray(value)) {\n    return value\n      .filter((item) => typeof item === 'string')\n      .map((item) => item.trim())\n      .filter((item) => item);\n  }\n  if (isPlainObject(value)) {\n    return Object.values(value)\n      .filter((item) => typeof item === 'string')\n      .map((item) => item.trim())\n      .filter((item) => item);\n  }\n  return [];\n}\n\nfunction arraysEqual(a, b) {\n  if (a === b) {\n    return true;\n  }\n  if (!Array.isArray(a) || !Array.isArray(b) || a.length !== b.length) {\n    return false;\n  }\n  for (let i = 0; i < a.length; i += 1) {\n    if (a[i] !== b[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction normalizeDiagramPositions(positions) {\n  if (!positions || typeof positions !== 'object') {\n    return {};\n  }\n  const normalized = {};\n  Object.keys(positions).forEach((key) => {\n    const value = positions[key];\n    if (!value || typeof value !== 'object') {\n      return;\n    }\n    const x = Number(value.x);\n    const y = Number(value.y);\n    if (!Number.isFinite(x) || !Number.isFinite(y)) {\n      return;\n    }\n    normalized[key] = { x, y };\n  });\n  return normalized;\n}\n\nfunction diagramPositionsEqual(a, b) {\n  const keysA = Object.keys(a || {});\n  const keysB = Object.keys(b || {});\n  if (keysA.length !== keysB.length) {\n    return false;\n  }\n  for (let i = 0; i < keysA.length; i += 1) {\n    const key = keysA[i];\n    if (!Object.prototype.hasOwnProperty.call(b || {}, key)) {\n      return false;\n    }\n    const valueA = a[key];\n    const valueB = b[key];\n    if (!valueA || typeof valueA !== 'object' || !valueB || typeof valueB !== 'object') {\n      return false;\n    }\n    if (Number(valueA.x) !== valueB.x || Number(valueA.y) !== valueB.y) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction normalizeSessionStatePayload(raw) {\n  if (!isPlainObject(raw)) {\n    return { state: null, changed: false };\n  }\n\n  const state = { ...raw };\n  let changed = false;\n\n  const normalizeStringField = (key) => {\n    if (!Object.prototype.hasOwnProperty.call(state, key)) {\n      return;\n    }\n    const value = state[key];\n    if (typeof value === 'string') {\n      const trimmed = value.trim();\n      if (trimmed !== value) {\n        state[key] = trimmed;\n        changed = true;\n      }\n      return;\n    }\n    if (value === null || value === undefined) {\n      state[key] = '';\n      changed = true;\n      return;\n    }\n    if (typeof value === 'number' || typeof value === 'boolean') {\n      state[key] = String(value);\n      changed = true;\n      return;\n    }\n    state[key] = '';\n    changed = true;\n  };\n\n  [\n    'setupName',\n    'setupSelect',\n    'camera',\n    'monitor',\n    'video',\n    'cage',\n    'distance',\n    'batteryPlate',\n    'battery',\n    'batteryHotswap',\n    'sliderBowl',\n    'easyrig',\n  ].forEach(normalizeStringField);\n\n  const mergeArrayField = (targetKey, legacyKeys = []) => {\n    const values = [];\n    const keys = [targetKey, ...legacyKeys];\n    let hadLegacyData = false;\n\n    keys.forEach((key) => {\n      if (Object.prototype.hasOwnProperty.call(state, key)) {\n        const collected = collectStringValues(state[key]);\n        if (key !== targetKey) {\n          hadLegacyData = true;\n        }\n        if (collected.length) {\n          values.push(...collected);\n        }\n      }\n    });\n\n    keys.slice(1).forEach((legacyKey) => {\n      if (Object.prototype.hasOwnProperty.call(state, legacyKey)) {\n        delete state[legacyKey];\n        changed = true;\n      }\n    });\n\n    const unique = [];\n    const seen = new Set();\n    values.forEach((val) => {\n      if (!seen.has(val)) {\n        seen.add(val);\n        unique.push(val);\n      }\n    });\n\n    const hasTargetKey = Object.prototype.hasOwnProperty.call(state, targetKey);\n    const existing = hasTargetKey && Array.isArray(state[targetKey])\n      ? state[targetKey].filter((item) => typeof item === 'string').map((item) => item.trim()).filter((item) => item)\n      : [];\n\n    if (!hasTargetKey && !hadLegacyData && unique.length === 0 && existing.length === 0) {\n      return;\n    }\n\n    if (!arraysEqual(existing, unique)) {\n      state[targetKey] = unique;\n      changed = true;\n    }\n  };\n\n  mergeArrayField('motors', ['motor', 'motorSelect']);\n  mergeArrayField('controllers', ['controller', 'controllerSelect']);\n\n  if (Object.prototype.hasOwnProperty.call(state, 'projectInfo') && !isPlainObject(state.projectInfo)) {\n    state.projectInfo = null;\n    changed = true;\n  }\n\n  if (Object.prototype.hasOwnProperty.call(state, 'autoGearHighlight')) {\n    const value = state.autoGearHighlight;\n    const normalized = value === true || value === 'true' || value === 1 || value === '1';\n    if (value !== normalized || typeof value !== 'boolean') {\n      state.autoGearHighlight = normalized;\n      changed = true;\n    }\n  }\n\n  if (Object.prototype.hasOwnProperty.call(state, 'diagramPositions')) {\n    const normalizedPositions = normalizeDiagramPositions(state.diagramPositions);\n    if (Object.keys(normalizedPositions).length === 0) {\n      delete state.diagramPositions;\n      changed = true;\n    } else if (!diagramPositionsEqual(state.diagramPositions, normalizedPositions)) {\n      state.diagramPositions = normalizedPositions;\n      changed = true;\n    }\n  }\n\n  const normalizedState = normalizeLegacyLongGopStructure(state);\n  if (normalizedState !== state) {\n    return { state: normalizedState, changed: true };\n  }\n\n  return { state, changed };\n}\n\nfunction loadSessionState() {\n  applyLegacyStorageMigrations();\n  const safeStorage = getSafeLocalStorage();\n  const raw = loadWithMigration(\n    safeStorage,\n    typeof sessionStorage !== 'undefined' ? sessionStorage : null,\n    SESSION_STATE_KEY,\n    \"Error loading session state from localStorage:\",\n    \"Error loading session state from sessionStorage:\",\n    \"Error saving session state to localStorage:\",\n    \"Error deleting session state from sessionStorage:\",\n    { validate: (value) => value === null || isPlainObject(value) },\n  );\n  if (raw === null) {\n    return null;\n  }\n\n  const { state, changed } = normalizeSessionStatePayload(raw);\n  if (!state) {\n    return null;\n  }\n\n  if (changed) {\n    createStorageMigrationBackup(safeStorage, SESSION_STATE_KEY, raw);\n    saveSessionState(state);\n  }\n\n  return state;\n}\n\nfunction saveSessionState(state, options = {}) {\n  const safeStorage = getSafeLocalStorage();\n  if (state === null || state === undefined) {\n    deleteFromStorage(\n      safeStorage,\n      SESSION_STATE_KEY,\n      \"Error deleting session state from localStorage:\",\n    );\n    return;\n  }\n\n  if (!isPlainObject(state)) {\n    console.warn('Ignoring invalid session state payload. Expected a plain object.');\n    return;\n  }\n\n  ensurePreWriteMigrationBackup(safeStorage, SESSION_STATE_KEY);\n  const normalizedState = normalizeLegacyLongGopStructure(state);\n  const normalizedOptions = isPlainObject(options) ? options : {};\n\n  // We default to disabling compression for session state to keep it human-readable\n  // and safer to edit manually if needed, BUT we must allow it if the user is\n  // running out of space.\n  const disableCompression = normalizedOptions.disableCompression !== false;\n\n  const saveOptions = {\n    ...normalizedOptions,\n    disableCompression,\n    forceCompressionOnQuota: true,\n    onQuotaExceeded: () => {\n      // If we hit a quota limit while saving the session, try to clear out\n      // old auto-backups or other non-essential data to make room.\n\n\n      // 1. Try clearing the oldest auto-gear backup first\n      if (typeof removeOldestAutoGearBackupEntry === 'function') {\n        // We need to load them first to find the oldest\n        const backups = loadAutoGearBackups();\n        if (removeOldestAutoGearBackupEntry(backups)) {\n          console.warn('Removed oldest automatic gear backup to free up space for session state.');\n          return true;\n        }\n      }\n\n      // 2. Try clearing cached planner data\n      if (typeof clearCachedPlannerDataForAutoGearBackups === 'function') {\n        if (clearCachedPlannerDataForAutoGearBackups()) {\n          console.warn('Cleared cached planner data to free up space for session state.');\n          return true;\n        }\n      }\n\n      return false;\n    },\n  };\n\n  saveJSONToStorage(\n    safeStorage,\n    SESSION_STATE_KEY,\n    normalizedState,\n    \"Error saving session state to localStorage:\",\n    saveOptions,\n  );\n}\n\n// --- Device Data Storage ---\nfunction normalizeDeviceDataPayload(rawData) {\n  if (!isPlainObject(rawData)) {\n    return { data: null, changed: false };\n  }\n\n  const data = { ...rawData };\n  let changed = false;\n\n  const ensureObject = (target, key) => {\n    if (!isPlainObject(target[key])) {\n      target[key] = {};\n      changed = true;\n    }\n    return target[key];\n  };\n\n  const mergeTrailingSpaceKeys = (collection) => {\n    if (!isPlainObject(collection)) {\n      return;\n    }\n    const entries = Object.entries(collection);\n    entries.forEach(([key, value]) => {\n      if (typeof key !== 'string') {\n        return;\n      }\n      const trimmedKey = key.trim();\n      if (!trimmedKey || trimmedKey === key) {\n        return;\n      }\n      if (!isPlainObject(value)) {\n        if (!Object.prototype.hasOwnProperty.call(collection, trimmedKey)) {\n          collection[trimmedKey] = value;\n          delete collection[key];\n          changed = true;\n        }\n        return;\n      }\n\n      const target = ensureObject(collection, trimmedKey);\n      const usedNames = new Set(Object.keys(target));\n      const normalizedNames = new Set(\n        [...usedNames].map((name) => name.trim().toLowerCase()),\n      );\n\n      Object.entries(value).forEach(([deviceName, deviceData]) => {\n        if (Object.prototype.hasOwnProperty.call(target, deviceName)) {\n          const uniqueName = generateUniqueName(deviceName, usedNames, normalizedNames);\n          target[uniqueName] = deviceData;\n          return;\n        }\n        target[deviceName] = deviceData;\n        usedNames.add(deviceName);\n        normalizedNames.add(deviceName.trim().toLowerCase());\n      });\n\n      delete collection[key];\n      changed = true;\n    });\n  };\n\n  DEVICE_COLLECTION_KEYS.forEach((key) => {\n    ensureObject(data, key);\n  });\n\n  if (!isPlainObject(data.fiz)) {\n    data.fiz = {};\n    changed = true;\n  }\n  FIZ_COLLECTION_KEYS.forEach((key) => {\n    ensureObject(data.fiz, key);\n  });\n\n  if (!isPlainObject(data.accessories)) {\n    data.accessories = {};\n    changed = true;\n  }\n  ACCESSORY_COLLECTION_KEYS.forEach((key) => {\n    ensureObject(data.accessories, key);\n  });\n\n  mergeTrailingSpaceKeys(data.accessories);\n  mergeTrailingSpaceKeys(data.fiz);\n\n  if (!Array.isArray(data.filterOptions)) {\n    data.filterOptions = Array.isArray(rawData.filterOptions)\n      ? rawData.filterOptions.slice()\n      : [];\n    changed = true;\n  }\n\n  return { data, changed };\n}\n\nfunction loadDeviceData() {\n  applyLegacyStorageMigrations();\n  const safeStorage = getSafeLocalStorage();\n  const parsedData = loadJSONFromStorage(\n    safeStorage,\n    DEVICE_STORAGE_KEY,\n    \"Error loading device data from localStorage:\",\n    null,\n    { validate: (value) => value === null || isPlainObject(value) },\n  );\n  const { data, changed } = normalizeDeviceDataPayload(parsedData);\n  if (!data) {\n    return null;\n  }\n\n  if (changed) {\n    createStorageMigrationBackup(safeStorage, DEVICE_STORAGE_KEY, parsedData);\n    saveJSONToStorage(\n      safeStorage,\n      DEVICE_STORAGE_KEY,\n      data,\n      \"Error updating device data in localStorage during normalization:\",\n      {\n        disableCompression: true,\n        forceCompressionOnQuota: false,\n      },\n    );\n  }\n\n  return data;\n}\n\nfunction saveDeviceData(deviceData) {\n  const safeStorage = getSafeLocalStorage();\n  if (deviceData === null || deviceData === undefined) {\n    deleteFromStorage(\n      safeStorage,\n      DEVICE_STORAGE_KEY,\n      \"Error deleting device data from localStorage:\",\n    );\n    return;\n  }\n\n  if (!isPlainObject(deviceData)) {\n    console.warn('Ignoring invalid device data payload. Expected a plain object.');\n    return;\n  }\n\n  const { data: normalizedDeviceData } = normalizeDeviceDataPayload(deviceData);\n  const dataToPersist = normalizedDeviceData || deviceData;\n\n  ensurePreWriteMigrationBackup(safeStorage, DEVICE_STORAGE_KEY);\n  saveJSONToStorage(\n    safeStorage,\n    DEVICE_STORAGE_KEY,\n    dataToPersist,\n    \"Error saving device data to localStorage:\",\n    {\n      disableCompression: false,\n      forceCompressionOnQuota: true,\n    },\n  );\n}\n\n// --- Setup Data Storage ---\nfunction normalizeSetups(rawData) {\n  if (!rawData) {\n    return { data: {}, changed: false };\n  }\n\n  if (Array.isArray(rawData)) {\n    const obj = {};\n    const used = new Set();\n    const normalized = new Set();\n    for (let idx = 0; idx < rawData.length; idx += 1) {\n      const item = rawData[idx];\n      if (!isPlainObject(item)) {\n        continue;\n      }\n      const base = item.name || item.setupName || `Setup ${idx + 1}`;\n      const key = generateUniqueName(base, used, normalized);\n      obj[key] = item;\n    }\n    return { data: obj, changed: true };\n  }\n\n  if (!isPlainObject(rawData)) {\n    return { data: {}, changed: true };\n  }\n\n  const normalized = {};\n  let changed = false;\n  Object.keys(rawData).forEach((name) => {\n    const value = rawData[name];\n    if (isPlainObject(value)) {\n      const normalizedValue = normalizeLegacyLongGopStructure(value);\n      if (normalizedValue !== value) {\n        changed = true;\n      }\n      normalized[name] = normalizedValue;\n    } else {\n      changed = true;\n    }\n  });\n\n  if (!changed) {\n    return { data: rawData, changed: false };\n  }\n\n  return { data: normalized, changed: true };\n}\n\nfunction loadSetups() {\n  applyLegacyStorageMigrations();\n  const safeStorage = getSafeLocalStorage();\n  const parsedData = loadJSONFromStorage(\n    safeStorage,\n    SETUP_STORAGE_KEY,\n    \"Error loading setups from localStorage:\",\n    null,\n    {\n      validate: (value) =>\n        value === null || Array.isArray(value) || isPlainObject(value),\n    },\n  );\n  const { data: setups, changed } = normalizeSetups(parsedData);\n  if (changed) {\n    createStorageMigrationBackup(safeStorage, SETUP_STORAGE_KEY, parsedData);\n    saveJSONToStorage(\n      safeStorage,\n      SETUP_STORAGE_KEY,\n      setups,\n      \"Error updating setups in localStorage during normalization:\",\n    );\n  }\n\n  try {\n    return expandAutoBackupEntries(setups, {\n      isAutoBackupKey: (name) => typeof name === 'string'\n        && name.startsWith(STORAGE_AUTO_BACKUP_NAME_PREFIX),\n    });\n  } catch (error) {\n    console.warn('Failed to expand automatic backup entries while loading setups', error);\n    return cloneAutoBackupValue(setups);\n  }\n}\n\nfunction saveSetups(setups) {\n\n  const { data: normalizedSetups } = normalizeSetups(setups);\n  enforceAutoBackupLimits(normalizedSetups);\n  const serializedSetups = serializeAutoBackupEntries(normalizedSetups, {\n    isAutoBackupKey: (name) => typeof name === 'string'\n      && name.startsWith(STORAGE_AUTO_BACKUP_NAME_PREFIX),\n  });\n  ensureProjectEntriesUncompressed(serializedSetups);\n  const safeStorage = getSafeLocalStorage();\n\n  // [Fix] Maintain V2 Project Index for Dashboard Performance\n  // This ensures that when we save via legacy Shim, the optimized index used by V2 is also updated.\n  if (typeof updateProjectIndex === 'function') {\n    updateProjectIndex(normalizedSetups, safeStorage);\n  }\n\n  ensurePreWriteMigrationBackup(safeStorage, SETUP_STORAGE_KEY);\n  saveJSONToStorage(\n    safeStorage,\n    SETUP_STORAGE_KEY,\n    serializedSetups,\n    \"Error saving setups to localStorage:\",\n    {\n      disableCompression: false,\n      forceCompressionOnQuota: true,\n      onQuotaExceeded: () => {\n        const removedKey = removeOldestAutoBackupEntry(serializedSetups);\n        if (!removedKey) {\n          return false;\n        }\n        console.warn(\n          `Removed automatic backup \"${removedKey}\" to free up storage space before saving setups.`,\n        );\n        return true;\n      },\n    },\n  );\n}\n\nfunction updateSetups(callback) {\n  const setups = loadSetups();\n  const { result, changed = true } = callback(setups) || {};\n  if (changed) {\n    saveSetups(setups);\n  }\n  return result;\n}\n\nfunction saveSetup(name, setup) {\n  updateSetups((setups) => {\n    setups[name] = setup;\n    return { changed: true };\n  });\n}\n\nfunction loadSetup(name) {\n  const setups = loadSetups();\n  return setups[name];\n}\n\nfunction deleteSetup(name) {\n  updateSetups((setups) => {\n    if (Object.prototype.hasOwnProperty.call(setups, name)) {\n      delete setups[name];\n      return { changed: true };\n    }\n    return { changed: false };\n  });\n}\n\nfunction renameSetup(oldName, newName) {\n  return updateSetups((setups) => {\n    if (!Object.prototype.hasOwnProperty.call(setups, oldName)) {\n      return { result: null, changed: false };\n    }\n    const sanitized = newName.trim();\n    // Guard against empty or whitespace-only names. Renaming to such a value\n    // would create an empty key in the setups object. In that case simply keep\n    // the original name.\n    if (!sanitized) {\n      return { result: oldName, changed: false };\n    }\n    if (oldName.trim().toLowerCase() === sanitized.toLowerCase()) {\n      return { result: oldName, changed: false };\n    }\n    const used = new Set(Object.keys(setups));\n    used.delete(oldName);\n    const target = generateUniqueName(sanitized, used);\n    const movedValue = setups[oldName];\n    setups[target] = movedValue;\n    delete setups[oldName];\n    const wasAutoBackup = typeof oldName === 'string'\n      && oldName.startsWith(STORAGE_AUTO_BACKUP_NAME_PREFIX);\n    const targetIsAutoBackup = typeof target === 'string'\n      && target.startsWith(STORAGE_AUTO_BACKUP_NAME_PREFIX);\n    if (wasAutoBackup && targetIsAutoBackup) {\n      markAutoBackupValueAsRenamed(movedValue);\n    }\n    return { result: target, changed: true };\n  });\n}\n\n// --- Project Storage ---\nvar REQUIREMENT_FIELDS_KEEP_NEWLINES = new Set(['prepDays', 'shootingDays', 'returnDays', 'crew', 'productionCompany', 'productionCompanyAddress']);\n\nvar LEGACY_PROJECT_FIELD_LABELS = {\n  productionCompany: [\n    'Production Company',\n    'Produktionsfirma',\n    'Socit de production',\n    'Productora',\n    'Casa di produzione',\n  ],\n  productionCompanyAddress: [\n    'Production Company Address',\n    'Adresse der Produktionsfirma',\n    'Adresse de la socit de production',\n    'Direccin de la productora',\n    'Indirizzo della casa di produzione',\n  ],\n  productionCompanyStreet: [\n    'Street address',\n    'Strae und Hausnummer',\n    'Adresse',\n    'Direccin',\n    'Indirizzo',\n  ],\n  productionCompanyStreet2: [\n    'Address line 2',\n    'Adresszusatz',\n    \"Complment d'adresse\",\n    'Lnea 2 de direccin',\n    'Seconda linea indirizzo',\n  ],\n  productionCompanyCity: [\n    'City',\n    'Stadt',\n    'Ville',\n    'Ciudad',\n    'Citt',\n  ],\n  productionCompanyRegion: [\n    'State / Province / Region',\n    'Bundesland / Region',\n    'tat / Rgion / Dpartement',\n    'Estado / Provincia / Regin',\n    'Regione / Provincia / Stato',\n  ],\n  productionCompanyPostalCode: [\n    'Postal code',\n    'Postleitzahl',\n    'Code postal',\n    'Cdigo postal',\n    'CAP',\n  ],\n  productionCompanyCountry: [\n    'Country',\n    'Land',\n    'Pays',\n    'Pas',\n    'Paese',\n  ],\n  rentalHouse: ['Rental', 'Kameraverleih', 'Loueur', 'Noleggio', 'Verleih', 'Location', 'Rental House'],\n  crew: ['Crew', 'Team', 'quipe', 'Equipo', 'Troupe'],\n  prepDays: [\n    'Prep Days',\n    'Prep-Tage',\n    'Jours de prparation',\n    'Das de preparacin',\n    'Giorni di preparazione',\n  ],\n  shootingDays: [\n    'Shooting Days',\n    'Drehtage',\n    'Jours de tournage',\n    'Das de rodaje',\n    'Giorni di riprese',\n  ],\n  returnDays: [\n    'Return Days',\n    'Rckgabetage',\n    'Jours de restitution',\n    'Das de devolucin',\n    'Giorni di restituzione',\n  ],\n  deliveryResolution: [\n    'Delivery Resolution',\n    'Auslieferungsauflsung',\n    'Rsolution de livraison',\n    'Resolucin de entrega',\n    'Risoluzione di consegna',\n  ],\n  recordingResolution: [\n    'Recording Resolution',\n    'Aufnahmeauflsung',\n    'Rsolution denregistrement',\n    'Resolucin de grabacin',\n    'Risoluzione di registrazione',\n  ],\n  slowMotionRecordingResolution: [\n    'Slow Motion Recording Resolution',\n    'Zeitlupen-Aufnahmeauflsung',\n    'Rsolution denregistrement au ralenti',\n    'Resolucin de grabacin en cmara lenta',\n    'Risoluzione di registrazione slow motion',\n  ],\n  aspectRatio: [\n    'Aspect Ratio',\n    'Seitenverhltnis',\n    \"Format dimage\",\n    'Relacin de aspecto',\n    'Formato',\n  ],\n  codec: ['Codec', 'Codec', 'Codec', 'Cdec', 'Codec'],\n  baseFrameRate: [\n    'Base Frame Rate',\n    'Basis-Framerate',\n    'Cadence de base',\n    'Velocidad base',\n    'Frame rate base',\n  ],\n  slowMotionBaseFrameRate: [\n    'Slow Motion Base Frame Rate',\n    'Zeitlupen-Basis-Framerate',\n    'Cadence de base au ralenti',\n    'Velocidad base en cmara lenta',\n    'Frame rate base slow motion',\n  ],\n  recordingFrameRate: [\n    'Recording Frame Rate',\n    'Aufnahmebildrate',\n    'Cadence denregistrement',\n    'Velocidad de grabacin',\n    'Frame rate di registrazione',\n  ],\n  slowMotionRecordingFrameRate: [\n    'Slow Motion Recording Frame Rate',\n    'Zeitlupen-Aufnahmebildrate',\n    'Cadence denregistrement au ralenti',\n    'Velocidad de grabacin en cmara lenta',\n    'Frame rate di registrazione slow motion',\n  ],\n  sensorMode: [\n    'Sensor Mode',\n    'Sensormodus',\n    'Mode capteur',\n    'Modo de sensor',\n    'Modalit sensore',\n  ],\n  slowMotionSensorMode: [\n    'Slow Motion Sensor Mode',\n    'Zeitlupen-Sensormodus',\n    'Mode capteur au ralenti',\n    'Modo de sensor en cmara lenta',\n    'Modalit sensore slow motion',\n  ],\n  slowMotionAspectRatio: [\n    'Slow Motion Aspect Ratio',\n    'Zeitlupen-Seitenverhltnis',\n    \"Format dimage au ralenti\",\n    'Relacin de aspecto en cmara lenta',\n    'Formato slow motion',\n  ],\n  lenses: ['Lenses', 'Objektive', 'Optiques', 'pticas', 'Obiettivi'],\n  requiredScenarios: [\n    'Required Scenarios',\n    'Anforderungen',\n    'Scnarios requis',\n    'Escenarios requeridos',\n    'Scenari richiesti',\n  ],\n  cameraHandle: [\n    'Camera Handle',\n    'Kamera-Handgriff',\n    'Poigne camra',\n    'Empuadura de cmara',\n    'Maniglia camera',\n  ],\n  viewfinderExtension: [\n    'Viewfinder Extension',\n    'Sucher-Verlngerung',\n    'Extension viseur',\n    'Extensin de visor',\n    'Prolunga mirino',\n  ],\n  viewfinderEyeLeatherColor: [\n    'Viewfinder Eye Leather Color',\n    'Sucher-Augenmuschel-Farbe',\n    \"Couleur de lil du viseur\",\n    'Color del ocular del visor',\n    'Colore gomma mirino',\n  ],\n  mattebox: ['Mattebox', 'Matte-Box', 'Matte box', 'Matte box', 'Matte box'],\n  gimbal: [\n    'Gimbal',\n    'Gimbal-Stabilisator',\n    'Stabilisateur gimbal',\n    'Estabilizador gimbal',\n    'Stabilizzatore gimbal',\n  ],\n  videoDistribution: [\n    'Video Distribution',\n    'Videoverteilung',\n    'Distribution vido',\n    'Distribucin de vdeo',\n    'Distribuzione video',\n  ],\n  monitoringSupport: [\n    'Monitoring support',\n    'Monitoring-Support',\n    'Support de monitoring',\n    'Soporte de monitorizacin',\n    'Supporto monitoraggio',\n  ],\n  monitoringConfiguration: [\n    'Monitoring configuration',\n    'Monitoring-Konfiguration',\n    'Configuration de monitoring',\n    'Configuracin de monitorizacin',\n    'Configurazione monitoraggio',\n  ],\n  focusMonitor: [\n    'Focus Monitor',\n    'Fokusmonitor',\n    'Moniteur focus',\n    'Monitor de foco',\n    'Monitor fuoco',\n  ],\n  monitorUserButtons: [\n    'Onboard Monitor User Buttons',\n    'Onboard-Monitor-Buttons',\n    'Boutons personnaliss du moniteur',\n    'Botones de usuario del monitor integrado',\n    'Tasti monitor onboard',\n  ],\n  cameraUserButtons: [\n    'Camera User Buttons',\n    'Kamera-Buttons',\n    'Boutons personnaliss camra',\n    'Botones de usuario de la cmara',\n    'Tasti camera',\n  ],\n  viewfinderUserButtons: [\n    'Viewfinder User Buttons',\n    'Sucher-Buttons',\n    'Boutons personnaliss viseur',\n    'Botones de usuario del visor',\n    'Tasti mirino',\n  ],\n  tripodHeadBrand: [\n    'Tripod Head Brand',\n    'Kopfmarke',\n    'Marque de la tte',\n    'Marca de la cabeza',\n    'Marca della testa',\n  ],\n  tripodBowl: [\n    'Tripod Bowl',\n    'Schalentyp',\n    'Type de bol',\n    'Tipo de bowl',\n    'Tipo di bowl',\n  ],\n  tripodTypes: [\n    'Tripod Types',\n    'Stativtypen',\n    'Types de trpied',\n    'Tipos de trpode',\n    'Tipi di treppiede',\n  ],\n  tripodSpreader: [\n    'Tripod Spreader',\n    'Spreizer-Option',\n    'Type de spreader',\n    'Tipo de esparcidor',\n    'Tipo di spreader',\n  ],\n  sliderBowl: [\n    'Slider Bowl',\n    'Slider-Schale',\n    'Slider bowl',\n    'Bowl del slider',\n    'Slider bowl',\n  ],\n  easyrig: [\n    'Further Stabilisation',\n    'Weitere Stabilisierung',\n    'Stabilisation complmentaire',\n    'Estabilizacin adicional',\n    'Stabilizzazione aggiuntiva',\n  ],\n};\n\nvar PRODUCTION_COMPANY_FIELD_ORDER = [\n  'productionCompanyAddress',\n  'productionCompanyStreet',\n  'productionCompanyStreet2',\n  'productionCompanyCity',\n  'productionCompanyRegion',\n  'productionCompanyPostalCode',\n  'productionCompanyCountry',\n];\n\nfunction normalizeProjectFieldLabel(label) {\n  if (typeof label !== 'string') {\n    return '';\n  }\n  return label.trim().replace(/[:]\\s*$/, '').trim();\n}\n\nfunction getProductionCompanyLabelSets(projectLabels) {\n  var labelSets = {};\n  var textsObj = typeof window !== 'undefined' && window.texts ? window.texts : null;\n  var fallbackProjectLabels = (textsObj && textsObj.en && textsObj.en.projectFields) || {};\n  var allKeys = ['productionCompany'].concat(PRODUCTION_COMPANY_FIELD_ORDER);\n  allKeys.forEach(function (key) {\n    var set = new Set();\n    var addLabel = function (value) {\n      if (typeof value !== 'string') return;\n      var normalized = normalizeProjectFieldLabel(value);\n      if (normalized) {\n        set.add(normalized);\n      }\n    };\n    if (projectLabels && projectLabels[key]) {\n      addLabel(projectLabels[key]);\n    }\n    if (fallbackProjectLabels && fallbackProjectLabels[key]) {\n      addLabel(fallbackProjectLabels[key]);\n    }\n    var legacyLabels = LEGACY_PROJECT_FIELD_LABELS[key];\n    if (Array.isArray(legacyLabels)) {\n      legacyLabels.forEach(addLabel);\n    }\n    labelSets[key] = set;\n  });\n  return labelSets;\n}\n\nfunction expandCombinedProductionCompanyInfo(rawText, projectLabels, metadata) {\n  if (typeof rawText !== 'string') {\n    return null;\n  }\n  var normalizedText = rawText\n    .replace(/\\r\\n?/g, '\\n')\n    .split('\\n')\n    .map(function (segment) { return segment.trim(); })\n    .filter(function (segment) { return segment; });\n  if (!normalizedText.length) {\n    return null;\n  }\n  var labelSets = getProductionCompanyLabelSets(projectLabels);\n  var result = {};\n  var firstLine = normalizedText[0];\n  if (firstLine) {\n    result.productionCompany = firstLine;\n  }\n  var metadataLines = Array.isArray(metadata === null || metadata === void 0 ? void 0 : metadata.lines)\n    ? metadata.lines\n    : null;\n  if (metadataLines && metadataLines.length) {\n    var collectedFromMetadata = {};\n    metadataLines.forEach(function (entry) {\n      if (!entry || typeof entry.text !== 'string') return;\n      var text = entry.text.trim();\n      if (!text) return;\n      var fields = entry.fields;\n      if (typeof fields === 'string') {\n        fields = fields.split(/\\s+/);\n      }\n      if (!Array.isArray(fields) || !fields.length) return;\n      fields\n        .map(function (field) { return typeof field === 'string' ? field.trim() : ''; })\n        .filter(function (field) { return field && PRODUCTION_COMPANY_FIELD_ORDER.includes(field); })\n        .forEach(function (field) {\n          if (!collectedFromMetadata[field]) {\n            collectedFromMetadata[field] = [];\n          }\n          collectedFromMetadata[field].push(text);\n        });\n    });\n    if (Object.keys(collectedFromMetadata).length) {\n      if (collectedFromMetadata.productionCompanyAddress && collectedFromMetadata.productionCompanyAddress.length) {\n        result.productionCompanyAddress = collectedFromMetadata.productionCompanyAddress.join('\\n');\n      }\n      if (collectedFromMetadata.productionCompanyStreet && collectedFromMetadata.productionCompanyStreet.length) {\n        var streetParts = collectedFromMetadata.productionCompanyStreet;\n        result.productionCompanyStreet = streetParts[0];\n        if (streetParts.length > 1) {\n          var secondary = streetParts.slice(1).join('\\n');\n          if (secondary) {\n            result.productionCompanyStreet2 = secondary;\n          }\n        }\n      }\n      if (collectedFromMetadata.productionCompanyStreet2 && collectedFromMetadata.productionCompanyStreet2.length) {\n        var streetTwo = collectedFromMetadata.productionCompanyStreet2.join('\\n');\n        if (streetTwo) {\n          result.productionCompanyStreet2 = result.productionCompanyStreet2\n            ? result.productionCompanyStreet2 + '\\n' + streetTwo\n            : streetTwo;\n        }\n      }\n      var joinCollected = function (field) {\n        if (!collectedFromMetadata[field] || !collectedFromMetadata[field].length) return;\n        var combined = collectedFromMetadata[field].join(' ');\n        if (combined) {\n          result[field] = combined;\n        }\n      };\n      ['productionCompanyCity', 'productionCompanyRegion', 'productionCompanyPostalCode', 'productionCompanyCountry']\n        .forEach(joinCollected);\n      return result;\n    }\n  }\n  var collected = {};\n  var activeField = null;\n  normalizedText.slice(1).forEach(function (line) {\n    var normalizedLine = normalizeProjectFieldLabel(line);\n    var matchedField = null;\n    PRODUCTION_COMPANY_FIELD_ORDER.forEach(function (field) {\n      if (matchedField || !labelSets[field]) return;\n      if (labelSets[field].has(normalizedLine)) {\n        matchedField = field;\n      }\n    });\n    if (matchedField) {\n      activeField = matchedField;\n      if (!collected[activeField]) {\n        collected[activeField] = [];\n      }\n      return;\n    }\n    if (!activeField) {\n      if (result.productionCompany) {\n        result.productionCompany += '\\n' + line;\n      } else {\n        result.productionCompany = line;\n      }\n      return;\n    }\n    if (!collected[activeField]) {\n      collected[activeField] = [];\n    }\n    collected[activeField].push(line);\n  });\n\n  if (collected.productionCompanyAddress && collected.productionCompanyAddress.length) {\n    result.productionCompanyAddress = collected.productionCompanyAddress.join('\\n');\n  }\n  if (collected.productionCompanyStreet && collected.productionCompanyStreet.length) {\n    var streetLines = collected.productionCompanyStreet;\n    result.productionCompanyStreet = streetLines[0];\n    if (streetLines.length > 1) {\n      result.productionCompanyStreet2 = streetLines.slice(1).join('\\n');\n    }\n  }\n  if (collected.productionCompanyCity && collected.productionCompanyCity.length) {\n    result.productionCompanyCity = collected.productionCompanyCity.join(' ');\n  }\n  if (collected.productionCompanyRegion && collected.productionCompanyRegion.length) {\n    result.productionCompanyRegion = collected.productionCompanyRegion.join(' ');\n  }\n  if (collected.productionCompanyPostalCode && collected.productionCompanyPostalCode.length) {\n    result.productionCompanyPostalCode = collected.productionCompanyPostalCode.join(' ');\n  }\n  if (collected.productionCompanyCountry && collected.productionCompanyCountry.length) {\n    result.productionCompanyCountry = collected.productionCompanyCountry.join(' ');\n  }\n\n  return result;\n}\n\nvar LEGACY_PROJECT_LABEL_FIELD_MAP = (() => {\n  const map = new Map();\n  const normalize = (label) => {\n    if (typeof label !== 'string') return '';\n    return label\n      .normalize('NFD')\n      .replace(/[\\u0300-\\u036f]/g, '')\n      .replace(/[:]/g, '')\n      .replace(/[^a-zA-Z0-9]+/g, ' ')\n      .trim()\n      .toLowerCase();\n  };\n  Object.entries(LEGACY_PROJECT_FIELD_LABELS).forEach(([field, labels]) => {\n    labels.forEach((label) => {\n      const normalized = normalize(label);\n      if (normalized && !map.has(normalized)) {\n        map.set(normalized, field);\n      }\n    });\n  });\n  return map;\n})();\n\nvar HTML_ENTITY_MAP = {\n  amp: '&',\n  lt: '<',\n  gt: '>',\n  quot: '\"',\n  apos: \"'\",\n  nbsp: ' ',\n};\n\nfunction decodeHtmlEntities(value) {\n  if (typeof value !== 'string' || !value) {\n    return '';\n  }\n  return value.replace(/&(#x?[0-9a-fA-F]+|[a-zA-Z]+);/g, (match, entity) => {\n    if (!entity) return match;\n    if (entity[0] === '#') {\n      const code = entity[1] === 'x' || entity[1] === 'X'\n        ? parseInt(entity.slice(2), 16)\n        : parseInt(entity.slice(1), 10);\n      return Number.isFinite(code) ? String.fromCodePoint(code) : match;\n    }\n    const mapped = HTML_ENTITY_MAP[entity.toLowerCase()];\n    return mapped !== undefined ? mapped : match;\n  });\n}\n\nfunction stripHtmlTags(value) {\n  if (typeof value !== 'string') return '';\n  // Remove all HTML tags by repeatedly applying the regex until no tags remain.\n  let previous;\n  do {\n    previous = value;\n    value = value.replace(/<[^>]*>/g, '');\n  } while (value !== previous);\n  return value;\n}\n\nfunction normalizeRequirementValueFromHtml(rawHtml, fieldName) {\n  if (typeof rawHtml !== 'string') {\n    return '';\n  }\n  const normalizedBreaks = rawHtml\n    .replace(/<\\s*br\\s*\\/?\\s*>/gi, '\\n')\n    .replace(/<\\/(p|div|li|ul|ol)>/gi, '\\n')\n    .replace(/<li[^>]*>/gi, '');\n  const text = decodeHtmlEntities(stripHtmlTags(normalizedBreaks))\n    .replace(/\\r\\n/g, '\\n')\n    .replace(/\\r/g, '\\n');\n  const parts = text\n    .split('\\n')\n    .map((part) => part.replace(/\\s+/g, ' ').trim())\n    .filter((part) => part);\n  if (!parts.length) {\n    return '';\n  }\n  if (fieldName && REQUIREMENT_FIELDS_KEEP_NEWLINES.has(fieldName)) {\n    return parts.join('\\n');\n  }\n  return parts.join(', ');\n}\n\nfunction extractRequirementValueMetadata(rawHtml) {\n  if (typeof rawHtml !== 'string') {\n    return null;\n  }\n  const spanRegex = /<span([^>]*)>([\\s\\S]*?)<\\/span>/gi;\n  const lines = [];\n  let match;\n  while ((match = spanRegex.exec(rawHtml))) {\n    const attrs = match[1] || '';\n    if (!/class=[\"'][^\"']*req-sub-line[^\"']*[\"']/i.test(attrs)) {\n      continue;\n    }\n    const content = match[2] || '';\n    const text = decodeHtmlEntities(stripHtmlTags(content)).replace(/\\s+/g, ' ').trim();\n    if (!text) {\n      continue;\n    }\n    const fieldsAttrMatch = attrs.match(/data-fields=[\"']([^\"']+)[\"']/i);\n    const singleFieldMatch = fieldsAttrMatch\n      ? null\n      : attrs.match(/data-field=[\"']([^\"']+)[\"']/i);\n    const rawFields = fieldsAttrMatch ? fieldsAttrMatch[1] : singleFieldMatch ? singleFieldMatch[1] : '';\n    const fields = typeof rawFields === 'string'\n      ? rawFields.split(/\\s+/).map((field) => field.trim()).filter((field) => field)\n      : [];\n    lines.push({ text, fields });\n  }\n  return lines.length ? { lines } : null;\n}\n\nfunction mapLegacyRequirementLabel(labelText) {\n  if (typeof labelText !== 'string') {\n    return '';\n  }\n  const normalized = labelText\n    .normalize('NFD')\n    .replace(/[\\u0300-\\u036f]/g, '')\n    .replace(/[:]/g, '')\n    .replace(/[^a-zA-Z0-9]+/g, ' ')\n    .trim()\n    .toLowerCase();\n  if (!normalized) {\n    return '';\n  }\n  return LEGACY_PROJECT_LABEL_FIELD_MAP.get(normalized) || '';\n}\n\nfunction extractProjectInfoFromHtml(html) {\n  if (typeof html !== 'string') {\n    return null;\n  }\n  const trimmed = html.trim();\n  if (!trimmed) {\n    return null;\n  }\n  const info = {};\n  const gridOpenMatch = trimmed.match(/<div[^>]*class=[\"'][^\"']*requirements-grid[^\"']*[\"'][^>]*>/i);\n  const gridStartIndex = gridOpenMatch ? gridOpenMatch.index : -1;\n  if (gridStartIndex === -1) {\n    const headingMatch = trimmed.match(/<h2[^>]*>([\\s\\S]*?)<\\/h2>/i);\n    if (headingMatch) {\n      const title = decodeHtmlEntities(stripHtmlTags(headingMatch[1]));\n      const projectName = title.replace(/[\"']/g, '').trim();\n      if (projectName) {\n        info.projectName = projectName;\n      }\n    }\n    return Object.keys(info).length ? info : null;\n  }\n  const gridHtml = trimmed.slice(gridStartIndex);\n  const prefix = trimmed.slice(0, gridStartIndex);\n  const headingMatch = prefix.match(/<h2[^>]*>([\\s\\S]*?)<\\/h2>/i);\n  if (headingMatch) {\n    const title = decodeHtmlEntities(stripHtmlTags(headingMatch[1]));\n    const projectName = title.replace(/[\"']/g, '').trim();\n    if (projectName && !/gear list/i.test(projectName)) {\n      info.projectName = projectName;\n    }\n  }\n  const boxRegex = /<div[^>]*class=[\"'][^\"']*requirement-box[^\"']*[\"'][^>]*>[\\s\\S]*?<\\/div>/gi;\n  let match;\n  const textsObj = typeof window !== 'undefined' && window.texts ? window.texts : null;\n  const globalLang = typeof window !== 'undefined' && window.currentLang ? window.currentLang : null;\n  const lang = typeof globalLang === 'string' && textsObj && textsObj[globalLang] ? globalLang : 'en';\n  const projectLabels = textsObj && textsObj[lang] && textsObj[lang].projectFields\n    ? textsObj[lang].projectFields\n    : textsObj && textsObj.en && textsObj.en.projectFields\n      ? textsObj.en.projectFields\n      : {};\n  while ((match = boxRegex.exec(gridHtml))) {\n    const boxHtml = match[0];\n    const fieldMatch = boxHtml.match(/data-field=[\"']([^\"']+)[\"']/i);\n    const labelMatch = boxHtml.match(/<span[^>]*class=[\"'][^\"']*req-label[^\"']*[\"'][^>]*>([\\s\\S]*?)<\\/span>/i);\n    const valueMatch = boxHtml.match(/<span[^>]*class=[\"'][^\"']*req-value[^\"']*[\"'][^>]*>([\\s\\S]*)<\\/span\\s*>/i);\n    const rawField = fieldMatch ? fieldMatch[1].trim() : '';\n    const label = labelMatch ? decodeHtmlEntities(stripHtmlTags(labelMatch[1])) : '';\n    const fieldName = rawField || mapLegacyRequirementLabel(label);\n    if (!fieldName) {\n      continue;\n    }\n    const rawValue = valueMatch ? valueMatch[1] : '';\n    const normalizedValue = normalizeRequirementValueFromHtml(rawValue, fieldName);\n    if (!normalizedValue) {\n      continue;\n    }\n    let valueToStore = normalizedValue;\n    let metadata = null;\n    if (fieldName === 'productionCompany') {\n      metadata = extractRequirementValueMetadata(rawValue);\n      const expanded = expandCombinedProductionCompanyInfo(normalizedValue, projectLabels, metadata);\n      if (expanded && typeof expanded === 'object') {\n        if (expanded.productionCompany) {\n          valueToStore = expanded.productionCompany;\n        }\n        Object.entries(expanded).forEach(([expandedField, expandedValue]) => {\n          if (expandedField === 'productionCompany') {\n            return;\n          }\n          if (!Object.prototype.hasOwnProperty.call(info, expandedField)) {\n            info[expandedField] = expandedValue;\n          }\n        });\n      }\n    }\n    if (!Object.prototype.hasOwnProperty.call(info, fieldName)) {\n      info[fieldName] = valueToStore;\n    }\n  }\n  return Object.keys(info).length ? info : null;\n}\n\nfunction cloneProjectData(value) {\n  if (Array.isArray(value)) {\n    return value.map((item) => cloneProjectData(item));\n  }\n  if (isPlainObject(value)) {\n    const clone = {};\n    Object.entries(value).forEach(([key, val]) => {\n      clone[key] = cloneProjectData(val);\n    });\n    return clone;\n  }\n  return value;\n}\n\nfunction cloneProjectInfo(projectInfo) {\n  if (!isPlainObject(projectInfo)) {\n    return null;\n  }\n  try {\n    return STORAGE_DEEP_CLONE(projectInfo);\n  } catch (error) {\n    console.warn('Unable to serialize project info during normalization', error);\n    try {\n      return cloneProjectData(projectInfo);\n    } catch (fallbackError) {\n      console.warn('Unable to deep clone project info during normalization', fallbackError);\n      return { ...projectInfo };\n    }\n  }\n}\n\nfunction sanitizeImportedCrewEntries(entries) {\n  if (!Array.isArray(entries)) {\n    return [];\n  }\n  const sanitized = [];\n  entries.forEach((entry) => {\n    if (!isPlainObject(entry)) {\n      const normalized = sanitizeImportedValue(entry);\n      if (normalized !== null && normalized !== undefined) {\n        sanitized.push(normalized);\n      }\n      return;\n    }\n    const result = {};\n    const name = typeof entry.name === 'string' ? entry.name.trim() : '';\n    if (name) {\n      result.name = name;\n    }\n    const phone = typeof entry.phone === 'string' ? entry.phone.trim() : '';\n    if (phone) {\n      result.phone = phone;\n    }\n    const email = typeof entry.email === 'string' ? entry.email.trim() : '';\n    if (email) {\n      result.email = email;\n    }\n    const websiteValue =\n      typeof entry.website === 'string'\n        ? entry.website.trim()\n        : (typeof entry.url === 'string' ? entry.url.trim() : '');\n    const website = websiteValue;\n    if (website) {\n      result.website = website;\n    }\n    const note = typeof entry.text === 'string' ? entry.text.trim() : '';\n    if (note) {\n      result.text = note;\n    }\n    const role = typeof entry.role === 'string' ? entry.role.trim() : '';\n    if (role) {\n      result.role = role;\n    }\n    if (Object.keys(result).length) {\n      sanitized.push(result);\n    }\n  });\n  return sanitized;\n}\n\nfunction sanitizeImportedValue(value) {\n  if (value === null || value === undefined) {\n    return null;\n  }\n  if (typeof value === 'string') {\n    const trimmed = value.trim();\n    return trimmed ? trimmed : null;\n  }\n  if (typeof value === 'number') {\n    return Number.isNaN(value) ? null : value;\n  }\n  if (typeof value === 'boolean') {\n    return value ? true : null;\n  }\n  if (Array.isArray(value)) {\n    const sanitized = value\n      .map((item) => sanitizeImportedValue(item))\n      .filter((item) => item !== null && item !== undefined && !(typeof item === 'string' && !item));\n    return sanitized.length ? sanitized : null;\n  }\n  if (isPlainObject(value)) {\n    return sanitizeImportedProjectInfo(value);\n  }\n  return null;\n}\n\nfunction sanitizeImportedProjectInfo(info) {\n  if (!isPlainObject(info)) {\n    return null;\n  }\n  const normalized = {};\n  const fallbackLensNames = [];\n  const fallbackLensNameSet = new Set();\n  const addFallbackLensName = (name) => {\n    if (typeof name !== 'string') {\n      return;\n    }\n    const trimmed = name.trim();\n    if (!trimmed || fallbackLensNameSet.has(trimmed)) {\n      return;\n    }\n    fallbackLensNameSet.add(trimmed);\n    fallbackLensNames.push(trimmed);\n  };\n  const registerFallbackLensNames = (source, options = {}) => {\n    if (source === null || source === undefined) {\n      return;\n    }\n    if (options.fromSelections) {\n      const entries = Array.isArray(source) ? source : [source];\n      entries.forEach((entry) => {\n        if (isMapLike(entry)) {\n          const converted = convertMapLikeToObject(entry);\n          if (converted) {\n            registerFallbackLensNames(converted, { fromSelections: true });\n            return;\n          }\n        }\n        if (isPlainObject(entry)) {\n          const mapped = deriveLensSelectionsFromNameMap(entry);\n          if (mapped.length) {\n            mapped.forEach((selection) => {\n              if (selection && typeof selection.name === 'string') {\n                addFallbackLensName(selection.name);\n              }\n            });\n            return;\n          }\n        }\n        const candidate = normalizeProjectLensNameCandidate(entry);\n        if (candidate) {\n          addFallbackLensName(candidate);\n        }\n      });\n      return;\n    }\n    const names = extractLensNamesFromSource(source);\n    if (!names.length) {\n      return;\n    }\n    names.forEach((name) => {\n      addFallbackLensName(name);\n    });\n  };\n\n  registerFallbackLensNames(info.lenses);\n  if (Object.prototype.hasOwnProperty.call(info, 'lensSelections')) {\n    registerFallbackLensNames(info.lensSelections, { fromSelections: true });\n  }\n\n  Object.entries(info).forEach(([key, raw]) => {\n    if (raw === null || raw === undefined) {\n      return;\n    }\n    if (key === 'people') {\n      const crew = sanitizeImportedCrewEntries(raw);\n      if (crew.length) {\n        normalized.people = crew;\n      }\n      return;\n    }\n    if (key === 'lenses') {\n      const { names } = normalizeProjectLensNamesField(raw);\n      normalized.lenses = names.slice();\n      return;\n    }\n    if (key === 'lensSelections') {\n      const result = normalizeProjectLensSelectionsFromSources(raw, fallbackLensNames);\n      if (result.selections && result.selections.length) {\n        normalized.lensSelections = result.selections;\n      }\n      return;\n    }\n    const value = sanitizeImportedValue(raw);\n    if (value !== null && value !== undefined) {\n      normalized[key] = value;\n    }\n  });\n\n  if (!Object.prototype.hasOwnProperty.call(normalized, 'lenses') && fallbackLensNames.length) {\n    normalized.lenses = fallbackLensNames.slice();\n  }\n  if (\n    !Object.prototype.hasOwnProperty.call(normalized, 'lensSelections')\n    && fallbackLensNames.length\n  ) {\n    const derived = normalizeProjectLensSelectionsFromSources([], fallbackLensNames);\n    if (derived.selections && derived.selections.length) {\n      normalized.lensSelections = derived.selections;\n    }\n  }\n\n  if (!Object.keys(normalized).length) {\n    return null;\n  }\n\n  const normalizedWithLegacySupport = normalizeLegacyLongGopStructure(normalized);\n  return normalizedWithLegacySupport;\n}\n\nfunction cloneAutoGearRules(rules) {\n  if (!Array.isArray(rules) || !rules.length) {\n    return null;\n  }\n  try {\n    return STORAGE_DEEP_CLONE(rules);\n  } catch (error) {\n    console.warn('Unable to serialize automatic gear rules during normalization', error);\n    try {\n      return cloneProjectData(rules);\n    } catch (fallbackError) {\n      console.warn('Unable to deep clone automatic gear rules during normalization', fallbackError);\n      return rules.slice();\n    }\n  }\n}\n\nfunction cloneDiagramPositionsForStorage(positions) {\n  if (!isPlainObject(positions) || !Object.keys(positions).length) {\n    return {};\n  }\n  try {\n    return STORAGE_DEEP_CLONE(positions);\n  } catch (error) {\n    console.warn('Unable to serialize diagram positions during normalization', error);\n    try {\n      return cloneProjectData(positions);\n    } catch (fallbackError) {\n      console.warn('Unable to deep clone diagram positions during normalization', fallbackError);\n      return { ...positions };\n    }\n  }\n}\n\nvar PROJECT_FILTER_DEFAULT_SIZE = '4x5.65';\n\nfunction normalizeImportedFilterValues(raw) {\n  if (raw === null || raw === undefined) {\n    return [];\n  }\n\n  if (Array.isArray(raw)) {\n    const values = [];\n    raw.forEach((item) => {\n      if (item === null || item === undefined) {\n        return;\n      }\n      if (Array.isArray(item)) {\n        values.push(...normalizeImportedFilterValues(item));\n        return;\n      }\n      if (isMapLike(item)) {\n        const converted = convertMapLikeToObject(item);\n        if (converted) {\n          values.push(...normalizeImportedFilterValues(converted));\n          return;\n        }\n      }\n      if (typeof item === 'object') {\n        values.push(...normalizeImportedFilterValues(Object.values(item)));\n        return;\n      }\n      const normalized = String(item).trim();\n      if (normalized) {\n        values.push(normalized);\n      }\n    });\n    return values;\n  }\n\n  if (isMapLike(raw)) {\n    const converted = convertMapLikeToObject(raw);\n    if (converted) {\n      return normalizeImportedFilterValues(converted);\n    }\n  }\n\n  if (typeof raw === 'object') {\n    if (Object.prototype.hasOwnProperty.call(raw, 'values')) {\n      return normalizeImportedFilterValues(raw.values);\n    }\n    if (Object.prototype.hasOwnProperty.call(raw, 'selected')) {\n      return normalizeImportedFilterValues(raw.selected);\n    }\n    return normalizeImportedFilterValues(Object.values(raw));\n  }\n\n  if (typeof raw === 'string') {\n    const trimmed = raw.trim();\n    if (!trimmed || trimmed === '!') {\n      return [];\n    }\n    const parsed = tryParseJSONLike(trimmed);\n    if (parsed.success) {\n      return normalizeImportedFilterValues(parsed.parsed);\n    }\n    return trimmed\n      .split(/[|,]/)\n      .map((value) => value.trim())\n      .filter((value) => value);\n  }\n\n  const normalized = String(raw).trim();\n  return normalized ? [normalized] : [];\n}\n\nfunction normalizeImportedFilterEntry(entry, fallbackType = '') {\n  if (entry === null || entry === undefined) {\n    return null;\n  }\n\n  if (typeof entry === 'string') {\n    const trimmed = entry.trim();\n    if (!trimmed) {\n      return null;\n    }\n    const parsed = tryParseJSONLike(trimmed);\n    if (parsed.success) {\n      return normalizeImportedFilterEntry(parsed.parsed, fallbackType);\n    }\n    const parts = trimmed.split(':');\n    const typePart = parts.shift();\n    const type = typePart ? typePart.trim() : '';\n    if (!type) {\n      return null;\n    }\n    const sizePart = parts.shift();\n    const size = sizePart && sizePart.trim() ? sizePart.trim() : PROJECT_FILTER_DEFAULT_SIZE;\n    if (!parts.length) {\n      return { type, size, values: [], hasExplicitValues: false };\n    }\n    const rawValues = parts.join(':');\n    if (rawValues === '!') {\n      return { type, size, values: [], hasExplicitValues: true };\n    }\n    const values = normalizeImportedFilterValues(rawValues);\n    return {\n      type,\n      size,\n      values,\n      hasExplicitValues: true,\n    };\n  }\n\n  if (Array.isArray(entry)) {\n    if (!entry.length) {\n      return null;\n    }\n    if (entry.length === 1) {\n      return normalizeImportedFilterEntry(entry[0], fallbackType);\n    }\n    const [typeCandidate, sizeCandidate, valuesCandidate] = entry;\n    let type = typeof typeCandidate === 'string' ? typeCandidate.trim() : '';\n    if (!type && typeof fallbackType === 'string') {\n      type = fallbackType.trim();\n    }\n    if (!type) {\n      return null;\n    }\n    const size = typeof sizeCandidate === 'string' && sizeCandidate.trim()\n      ? sizeCandidate.trim()\n      : PROJECT_FILTER_DEFAULT_SIZE;\n    const hasExplicitValues = entry.length > 2;\n    const values = hasExplicitValues ? normalizeImportedFilterValues(valuesCandidate) : [];\n    return { type, size, values, hasExplicitValues };\n  }\n\n  if (isMapLike(entry)) {\n    const converted = convertMapLikeToObject(entry);\n    if (converted) {\n      return normalizeImportedFilterEntry(converted, fallbackType);\n    }\n  }\n\n  if (typeof entry === 'object') {\n    let type = '';\n    const typeKeys = ['type', 'filter', 'name', 'label'];\n    for (let i = 0; i < typeKeys.length; i += 1) {\n      const key = typeKeys[i];\n      if (typeof entry[key] === 'string') {\n        const candidate = entry[key].trim();\n        if (candidate) {\n          type = candidate;\n          break;\n        }\n      }\n    }\n    if (!type && typeof fallbackType === 'string' && fallbackType.trim()) {\n      type = fallbackType.trim();\n    }\n    if (!type) {\n      return null;\n    }\n\n    const sizeKeys = ['size', 'filterSize', 'format', 'dimension', 'dimensions', 'diameter'];\n    let size = '';\n    for (let i = 0; i < sizeKeys.length; i += 1) {\n      const key = sizeKeys[i];\n      if (typeof entry[key] === 'string') {\n        const candidate = entry[key].trim();\n        if (candidate) {\n          size = candidate;\n          break;\n        }\n      }\n    }\n    if (!size) {\n      size = PROJECT_FILTER_DEFAULT_SIZE;\n    }\n\n    const valueKeys = [\n      'values',\n      'value',\n      'strengths',\n      'strength',\n      'options',\n      'selected',\n      'selections',\n      'choices',\n    ];\n    let hasExplicitValues = false;\n    let values = [];\n    for (let i = 0; i < valueKeys.length; i += 1) {\n      const key = valueKeys[i];\n      if (Object.prototype.hasOwnProperty.call(entry, key)) {\n        hasExplicitValues = true;\n        values = normalizeImportedFilterValues(entry[key]);\n        break;\n      }\n    }\n\n    return { type, size, values, hasExplicitValues };\n  }\n\n  return null;\n}\n\nfunction serializeNormalizedFilterEntry(entry) {\n  if (!entry || !entry.type) {\n    return null;\n  }\n  const type = entry.type;\n  const size = entry.size && entry.size.trim() ? entry.size.trim() : PROJECT_FILTER_DEFAULT_SIZE;\n  let token = `${type}:${size}`;\n  const values = Array.isArray(entry.values)\n    ? Array.from(\n      new Set(\n        entry.values\n          .map((value) => (typeof value === 'string' ? value.trim() : String(value ?? '').trim()))\n          .filter((value) => value),\n      ),\n    )\n    : [];\n  if (entry.hasExplicitValues || values.length) {\n    token += values.length ? `:${values.join('|')}` : ':!';\n  }\n  return token;\n}\n\nfunction normalizeImportedFilterValue(value) {\n  if (value === undefined) {\n    return null;\n  }\n  if (value === null) {\n    return '';\n  }\n  if (typeof value === 'string') {\n    const trimmed = value.trim();\n    if (!trimmed) {\n      return '';\n    }\n    const parsed = tryParseJSONLike(trimmed);\n    if (parsed.success) {\n      return normalizeImportedFilterValue(parsed.parsed);\n    }\n    return trimmed;\n  }\n  if (Array.isArray(value)) {\n    const entries = value\n      .map((entry) => normalizeImportedFilterEntry(entry))\n      .filter(Boolean);\n    if (!entries.length) {\n      return '';\n    }\n    return entries\n      .map((entry) => serializeNormalizedFilterEntry(entry))\n      .filter(Boolean)\n      .join(',');\n  }\n  if (isMapLike(value)) {\n    const converted = convertMapLikeToObject(value);\n    if (converted) {\n      return normalizeImportedFilterValue(converted);\n    }\n  }\n  if (typeof value === 'object') {\n    const singleEntry = normalizeImportedFilterEntry(value);\n    if (singleEntry) {\n      const serialized = serializeNormalizedFilterEntry(singleEntry);\n      return serialized || '';\n    }\n    const entries = [];\n    Object.entries(value).forEach(([key, candidate]) => {\n      const normalized = normalizeImportedFilterEntry(candidate, key);\n      if (normalized) {\n        entries.push(normalized);\n      }\n    });\n    if (!entries.length) {\n      return '';\n    }\n    return entries\n      .map((entry) => serializeNormalizedFilterEntry(entry))\n      .filter(Boolean)\n      .join(',');\n  }\n  return String(value).trim();\n}\n\nfunction normalizeImportedProjectFilters(info) {\n  if (!isPlainObject(info)) {\n    return;\n  }\n\n  const normalizedFilter = normalizeImportedFilterValue(info.filter);\n  if (normalizedFilter !== null) {\n    if (normalizedFilter) {\n      info.filter = normalizedFilter;\n    } else {\n      delete info.filter;\n    }\n  } else {\n    const fallback = normalizeImportedFilterValue(info.filters);\n    if (fallback !== null) {\n      if (fallback) {\n        info.filter = fallback;\n      } else {\n        delete info.filter;\n      }\n    }\n  }\n\n  if (Object.prototype.hasOwnProperty.call(info, 'filters')) {\n    delete info.filters;\n  }\n}\n\nfunction cloneProjectGearSelectors(selectors) {\n  if (!isPlainObject(selectors)) {\n    return null;\n  }\n\n  const cloneSelectorValue = (value) => {\n    if (Array.isArray(value)) {\n      const result = value\n        .map((item) => cloneSelectorValue(item))\n        .filter((item) => item !== undefined);\n      return result;\n    }\n    if (isPlainObject(value)) {\n      const nested = {};\n      Object.entries(value).forEach(([key, nestedValue]) => {\n        if (typeof key !== 'string' || !key) {\n          return;\n        }\n        const clonedNestedValue = cloneSelectorValue(nestedValue);\n        if (clonedNestedValue !== undefined) {\n          nested[key] = clonedNestedValue;\n        }\n      });\n      return nested;\n    }\n    if (value === undefined || value === null) {\n      return '';\n    }\n    if (typeof value === 'string') {\n      return value;\n    }\n    if (typeof value === 'number' || typeof value === 'boolean') {\n      return String(value);\n    }\n    try {\n      return String(value);\n    } catch (stringifyError) {\n      void stringifyError;\n    }\n    return '';\n  };\n\n  const clone = {};\n  Object.entries(selectors).forEach(([id, value]) => {\n    if (typeof id !== 'string' || !id) {\n      return;\n    }\n    const clonedValue = cloneSelectorValue(value);\n    if (clonedValue !== undefined) {\n      clone[id] = clonedValue;\n    }\n  });\n  return Object.keys(clone).length ? clone : null;\n}\n\nfunction normalizeProjectPowerSelection(raw) {\n  if (raw == null) {\n    return null;\n  }\n  const normalizeString = (value) => {\n    if (typeof value === \"string\") {\n      return value.trim();\n    }\n    if (value === null || value === undefined) {\n      return \"\";\n    }\n    if (typeof value === \"number\" || typeof value === \"boolean\") {\n      return String(value);\n    }\n    return \"\";\n  };\n  if (!isPlainObject(raw)) {\n    return null;\n  }\n  const normalized = {\n    batteryPlate: normalizeString(raw.batteryPlate),\n    battery: normalizeString(raw.battery),\n    batteryHotswap: normalizeString(raw.batteryHotswap),\n  };\n  const hasValue = Object.keys(normalized).some((key) => normalized[key]);\n  return hasValue ? normalized : null;\n}\n\nfunction cloneProjectPowerSelection(selection) {\n  const normalized = normalizeProjectPowerSelection(selection);\n  if (!normalized) {\n    return null;\n  }\n  return {\n    batteryPlate: normalized.batteryPlate,\n    battery: normalized.battery,\n    batteryHotswap: normalized.batteryHotswap,\n  };\n}\n\nconst LEGACY_LENS_SELECTION_META_KEYS = new Set([\n  'name',\n  'lensname',\n  'label',\n  'title',\n  'text',\n  'lens',\n  'mount',\n  'mountlabel',\n  'mountname',\n  'mounts',\n  'note',\n  'notes',\n  'names',\n  'values',\n  'selection',\n  'legacyvalue',\n  'lensselections',\n  'selections',\n  'entries',\n  'items',\n  'options',\n  'meta',\n  'metadata',\n  'count',\n  'version',\n  'length',\n  'size',\n  'updated',\n  'created',\n  'createdat',\n  'timestamp',\n  'id',\n  'uuid',\n  'key',\n  'value',\n]);\n\nfunction isLikelyLensNameKey(key) {\n  if (typeof key !== 'string') {\n    return false;\n  }\n  const trimmed = key.trim();\n  if (!trimmed) {\n    return false;\n  }\n  if (/^[0-9]+$/u.test(trimmed)) {\n    return false;\n  }\n  const normalized = trimmed.toLowerCase();\n  if (normalized.startsWith('__proto__')) {\n    return false;\n  }\n  if (normalized === 'prototype' || normalized === 'constructor') {\n    return false;\n  }\n  if (LEGACY_LENS_SELECTION_META_KEYS.has(normalized)) {\n    return false;\n  }\n  return true;\n}\n\nfunction deriveLensNameKeysFromObject(value) {\n  if (!isPlainObject(value)) {\n    return [];\n  }\n  const keys = Object.keys(value);\n  const result = [];\n  keys.forEach((key) => {\n    if (!isLikelyLensNameKey(key)) {\n      return;\n    }\n    const trimmed = key.trim();\n    if (trimmed) {\n      result.push(trimmed);\n    }\n  });\n  return result;\n}\n\nfunction normalizeProjectLensNameCandidate(value) {\n  if (value === null || value === undefined) {\n    return '';\n  }\n\n  if (\n    typeof value === 'string'\n    || typeof value === 'number'\n    || typeof value === 'boolean'\n    || typeof value === 'bigint'\n  ) {\n    const stringValue = typeof value === 'string' ? value : String(value);\n    const trimmed = stringValue.trim();\n    return trimmed;\n  }\n\n  if (Array.isArray(value)) {\n    for (let index = 0; index < value.length; index += 1) {\n      const candidate = normalizeProjectLensNameCandidate(value[index]);\n      if (candidate) {\n        return candidate;\n      }\n    }\n    return '';\n  }\n\n  if (isMapLike(value)) {\n    const converted = convertMapLikeToObject(value);\n    if (converted) {\n      return normalizeProjectLensNameCandidate(converted);\n    }\n  }\n\n  if (isPlainObject(value)) {\n    const nameCandidates = [\n      value.name,\n      value.lensName,\n      value.label,\n      value.title,\n      value.text,\n      value.lens,\n    ];\n    for (let index = 0; index < nameCandidates.length; index += 1) {\n      const candidate = nameCandidates[index];\n      if (typeof candidate === 'string') {\n        const trimmed = candidate.trim();\n        if (trimmed) {\n          return trimmed;\n        }\n      }\n    }\n\n    const keyDerivedNames = deriveLensNameKeysFromObject(value);\n    if (keyDerivedNames.length) {\n      return keyDerivedNames[0];\n    }\n\n    if (Array.isArray(value.names) && value.names.length) {\n      const nestedName = normalizeProjectLensNameCandidate(value.names[0]);\n      if (nestedName) {\n        return nestedName;\n      }\n    }\n\n    if (Array.isArray(value.values) && value.values.length) {\n      const nestedValue = normalizeProjectLensNameCandidate(value.values[0]);\n      if (nestedValue) {\n        return nestedValue;\n      }\n    }\n\n    const nestedEntries = Object.values(value);\n    for (let index = 0; index < nestedEntries.length; index += 1) {\n      const nested = normalizeProjectLensNameCandidate(nestedEntries[index]);\n      if (nested) {\n        return nested;\n      }\n    }\n  }\n\n  return '';\n}\n\nfunction extractLensNamesFromSource(value) {\n  if (value === null || value === undefined) {\n    return [];\n  }\n\n  if (Array.isArray(value)) {\n    const names = [];\n    value.forEach((entry) => {\n      if (entry === null || entry === undefined) {\n        return;\n      }\n      if (typeof entry === 'string') {\n        const parsed = tryParseJSONLike(entry);\n        if (parsed.success) {\n          names.push(...extractLensNamesFromSource(parsed.parsed));\n          return;\n        }\n        const trimmed = entry.trim();\n        if (trimmed) {\n          names.push(trimmed);\n        }\n        return;\n      }\n      if (\n        typeof entry === 'number'\n        || typeof entry === 'boolean'\n        || typeof entry === 'bigint'\n      ) {\n        names.push(String(entry));\n        return;\n      }\n      const normalized = normalizeProjectLensNameCandidate(entry);\n      if (normalized) {\n        names.push(normalized);\n        return;\n      }\n      if (Array.isArray(entry)) {\n        names.push(...extractLensNamesFromSource(entry));\n        return;\n      }\n      if (isMapLike(entry)) {\n        const converted = convertMapLikeToObject(entry);\n        if (converted) {\n          names.push(...extractLensNamesFromSource(converted));\n        }\n        return;\n      }\n      if (isPlainObject(entry)) {\n        names.push(...extractLensNamesFromSource(Object.values(entry)));\n      }\n    });\n    return names;\n  }\n\n  if (\n    typeof value === 'number'\n    || typeof value === 'boolean'\n    || typeof value === 'bigint'\n  ) {\n    return [String(value)];\n  }\n\n  if (typeof value === 'string') {\n    const parsed = tryParseJSONLike(value);\n    if (parsed.success) {\n      return extractLensNamesFromSource(parsed.parsed);\n    }\n    return value\n      .split(/[\\n,;]/u)\n      .map((part) => part.trim())\n      .filter((part) => part);\n  }\n\n  if (isMapLike(value)) {\n    const converted = convertMapLikeToObject(value);\n    if (converted) {\n      return extractLensNamesFromSource(converted);\n    }\n  }\n\n  if (isPlainObject(value)) {\n    const keyNames = deriveLensNameKeysFromObject(value);\n    if (keyNames.length) {\n      return keyNames;\n    }\n    const direct = normalizeProjectLensNameCandidate(value);\n    if (direct) {\n      return [direct];\n    }\n    const collected = [];\n    if (Array.isArray(value.names)) {\n      collected.push(...extractLensNamesFromSource(value.names));\n    }\n    if (Array.isArray(value.values)) {\n      collected.push(...extractLensNamesFromSource(value.values));\n    }\n    if (!collected.length) {\n      collected.push(...extractLensNamesFromSource(Object.values(value)));\n    }\n    return collected;\n  }\n\n  return [];\n}\n\nfunction normalizeProjectLensNamesField(value) {\n  const names = extractLensNamesFromSource(value);\n  const isNormalized = Array.isArray(value)\n    && value.length === names.length\n    && value.every(\n      (entry, index) => typeof entry === 'string' && entry.trim() === names[index],\n    );\n  return { names, changed: !isNormalized };\n}\n\nfunction normalizeProjectLensSelectionEntry(entry) {\n  if (entry === null || entry === undefined) {\n    return { selection: null, changed: false };\n  }\n\n  if (\n    typeof entry === 'string'\n    || typeof entry === 'number'\n    || typeof entry === 'boolean'\n    || typeof entry === 'bigint'\n  ) {\n    const name = normalizeProjectLensNameCandidate(entry);\n    if (!name) {\n      return { selection: null, changed: true };\n    }\n    return { selection: { name, mount: '' }, changed: true };\n  }\n\n  if (isMapLike(entry)) {\n    const converted = convertMapLikeToObject(entry);\n    if (converted) {\n      return normalizeProjectLensSelectionEntry(converted);\n    }\n  }\n\n  if (Array.isArray(entry)) {\n    if (!entry.length) {\n      return { selection: null, changed: true };\n    }\n    const name = normalizeProjectLensNameCandidate(entry[0]);\n    if (!name) {\n      return { selection: null, changed: true };\n    }\n    const mountValue = entry.length > 1 ? entry[1] : '';\n    const mount = typeof mountValue === 'string' ? mountValue.trim() : '';\n    const normalized = { name };\n    normalized.mount = mount || '';\n    return { selection: normalized, changed: true };\n  }\n\n  if (isPlainObject(entry)) {\n    const normalized = { ...entry };\n    let changed = false;\n\n    const name = normalizeProjectLensNameCandidate(entry);\n    if (!name) {\n      return { selection: null, changed: true };\n    }\n    if (normalized.name !== name) {\n      normalized.name = name;\n      changed = true;\n    }\n    if (!Object.prototype.hasOwnProperty.call(normalized, 'name')) {\n      normalized.name = name;\n      changed = true;\n    }\n\n    const mountCandidates = [];\n    if (typeof entry.mount === 'string') {\n      mountCandidates.push(entry.mount);\n    }\n    if (typeof entry.mountLabel === 'string') {\n      mountCandidates.push(entry.mountLabel);\n    }\n    if (typeof entry.mountName === 'string') {\n      mountCandidates.push(entry.mountName);\n    }\n    if (Array.isArray(entry.mounts)) {\n      for (let index = 0; index < entry.mounts.length; index += 1) {\n        const candidate = entry.mounts[index];\n        if (typeof candidate === 'string' && candidate.trim()) {\n          mountCandidates.push(candidate);\n          break;\n        }\n      }\n    }\n\n    let mount = '';\n    for (let index = 0; index < mountCandidates.length; index += 1) {\n      const candidate = mountCandidates[index];\n      if (typeof candidate === 'string') {\n        const trimmed = candidate.trim();\n        if (trimmed) {\n          mount = trimmed;\n          break;\n        }\n      }\n    }\n\n    if (typeof normalized.mount === 'string') {\n      const trimmedMount = normalized.mount.trim();\n      if (trimmedMount !== normalized.mount) {\n        normalized.mount = trimmedMount;\n        changed = true;\n      }\n      if (!mount && trimmedMount) {\n        mount = trimmedMount;\n      }\n    }\n\n    if (!mount) {\n      mount = '';\n    }\n\n    if (normalized.mount !== mount) {\n      normalized.mount = mount;\n      changed = true;\n    }\n\n    if (!Object.prototype.hasOwnProperty.call(normalized, 'mount')) {\n      normalized.mount = mount;\n      changed = true;\n    }\n\n    return { selection: normalized, changed };\n  }\n\n  return { selection: null, changed: true };\n}\n\nfunction deriveLensSelectionsFromNameMap(source) {\n  if (!isPlainObject(source)) {\n    return [];\n  }\n\n  const directNameCandidates = [\n    source.name,\n    source.lensName,\n    source.label,\n    source.title,\n    source.text,\n    source.lens,\n  ];\n  for (let index = 0; index < directNameCandidates.length; index += 1) {\n    const candidate = directNameCandidates[index];\n    if (typeof candidate === 'string' && candidate.trim()) {\n      return [];\n    }\n  }\n\n  const derived = [];\n  Object.entries(source).forEach(([rawKey, rawValue]) => {\n    if (!isLikelyLensNameKey(rawKey)) {\n      return;\n    }\n    const name = rawKey.trim();\n    if (!name) {\n      return;\n    }\n\n    let value = rawValue;\n    if (isMapLike(value)) {\n      const converted = convertMapLikeToObject(value);\n      if (converted) {\n        value = converted;\n      }\n    }\n\n    if (isPlainObject(value)) {\n      const selection = { ...value };\n      selection.name = name;\n      let mount = '';\n      const mountFields = ['mount', 'mountLabel', 'mountName'];\n      for (let index = 0; index < mountFields.length; index += 1) {\n        const field = mountFields[index];\n        if (typeof selection[field] !== 'string') {\n          continue;\n        }\n        const candidate = selection[field].trim();\n        if (candidate && candidate.toLowerCase() !== name.toLowerCase()) {\n          mount = candidate;\n          break;\n        }\n      }\n      if (!mount && Array.isArray(selection.mounts)) {\n        const candidate = normalizeProjectLensNameCandidate(selection.mounts);\n        if (candidate && candidate.toLowerCase() !== name.toLowerCase()) {\n          mount = candidate;\n        }\n      }\n      selection.mount = typeof mount === 'string' ? mount : '';\n      derived.push(selection);\n      return;\n    }\n\n    if (Array.isArray(value)) {\n      const candidate = normalizeProjectLensNameCandidate(value);\n      const mount = candidate && candidate.toLowerCase() !== name.toLowerCase() ? candidate : '';\n      derived.push({ name, mount });\n      return;\n    }\n\n    if (\n      typeof value === 'string'\n      || typeof value === 'number'\n      || typeof value === 'boolean'\n      || typeof value === 'bigint'\n    ) {\n      const candidate = normalizeProjectLensNameCandidate(value);\n      const mount = candidate && candidate.toLowerCase() !== name.toLowerCase() ? candidate : '';\n      derived.push({ name, mount });\n      return;\n    }\n\n    if (value === null || value === undefined) {\n      derived.push({ name, mount: '' });\n      return;\n    }\n\n    const fallback = normalizeProjectLensNameCandidate(value);\n    const mount = fallback && fallback.toLowerCase() !== name.toLowerCase() ? fallback : '';\n    derived.push({ name, mount });\n  });\n  return derived;\n}\n\nfunction normalizeProjectLensSelectionsFromSources(sources, fallbackNames = []) {\n  const sourceList = Array.isArray(sources) ? sources : [sources];\n  const normalized = [];\n  const seenNames = new Set();\n  let changed = false;\n\n  const addSelection = (selection, entryChanged) => {\n    if (!selection || typeof selection !== 'object') {\n      if (entryChanged) {\n        changed = true;\n      }\n      return;\n    }\n\n    const clone = { ...selection };\n    const rawName = typeof clone.name === 'string' ? clone.name : '';\n    const name = rawName.trim();\n    if (!name) {\n      if (entryChanged) {\n        changed = true;\n      }\n      return;\n    }\n\n    if (clone.name !== name) {\n      clone.name = name;\n      entryChanged = true;\n    }\n\n    const rawMount = typeof clone.mount === 'string' ? clone.mount : '';\n    const mount = rawMount.trim();\n    if (clone.mount !== mount) {\n      clone.mount = mount;\n      entryChanged = true;\n    }\n    if (!Object.prototype.hasOwnProperty.call(clone, 'mount')) {\n      clone.mount = mount;\n      entryChanged = true;\n    }\n\n    if (Object.prototype.hasOwnProperty.call(clone, 'mountState')) {\n      const rawMountState = typeof clone.mountState === 'string' ? clone.mountState : '';\n      const mountState = rawMountState.trim();\n      if (clone.mountState !== mountState) {\n        clone.mountState = mountState;\n        entryChanged = true;\n      }\n      if (!mountState) {\n        delete clone.mountState;\n        entryChanged = true;\n      }\n    }\n\n    if (entryChanged) {\n      changed = true;\n    }\n\n    normalized.push(clone);\n    seenNames.add(name);\n  };\n\n  const processSourceValue = (source) => {\n    if (source === null || source === undefined) {\n      return;\n    }\n\n    if (typeof source === 'string') {\n      const parsed = tryParseJSONLike(source);\n      if (parsed.success) {\n        processSourceValue(parsed.parsed);\n        changed = true;\n        return;\n      }\n      const names = extractLensNamesFromSource(source);\n      if (names.length) {\n        names.forEach((name) => {\n          addSelection({ name, mount: '' }, true);\n        });\n      } else {\n        changed = true;\n      }\n      return;\n    }\n\n    if (\n      typeof source === 'number'\n      || typeof source === 'boolean'\n      || typeof source === 'bigint'\n    ) {\n      addSelection({ name: String(source), mount: '' }, true);\n      return;\n    }\n\n    if (Array.isArray(source)) {\n      if (\n        source.length\n        && source.length <= 2\n        && (\n          typeof source[0] === 'string'\n          || typeof source[0] === 'number'\n          || typeof source[0] === 'boolean'\n          || typeof source[0] === 'bigint'\n        )\n      ) {\n        const { selection, changed: entryChanged } = normalizeProjectLensSelectionEntry(source);\n        if (selection) {\n          addSelection(selection, entryChanged);\n          return;\n        }\n      }\n      source.forEach((entry) => {\n        const { selection, changed: entryChanged } = normalizeProjectLensSelectionEntry(entry);\n        if (selection) {\n          addSelection(selection, entryChanged);\n        } else if (entryChanged) {\n          changed = true;\n        }\n      });\n      return;\n    }\n\n    if (isMapLike(source)) {\n      const converted = convertMapLikeToObject(source);\n      if (converted) {\n        processSourceValue(converted);\n        changed = true;\n      }\n      return;\n    }\n\n    if (isPlainObject(source)) {\n      const mappedSelections = deriveLensSelectionsFromNameMap(source);\n      if (mappedSelections.length) {\n        mappedSelections.forEach((entry) => {\n          addSelection(entry, true);\n        });\n        return;\n      }\n      const { selection, changed: entryChanged } = normalizeProjectLensSelectionEntry(source);\n      if (selection) {\n        addSelection(selection, entryChanged);\n        return;\n      }\n      const values = Object.values(source);\n      if (values.length) {\n        processSourceValue(values);\n        changed = true;\n      }\n      return;\n    }\n\n    const fallbackName = normalizeProjectLensNameCandidate(source);\n    if (fallbackName) {\n      addSelection({ name: fallbackName, mount: '' }, true);\n    } else {\n      changed = true;\n    }\n  };\n\n  for (let index = 0; index < sourceList.length; index += 1) {\n    processSourceValue(sourceList[index]);\n  }\n\n  if (Array.isArray(fallbackNames)) {\n    fallbackNames.forEach((rawName) => {\n      if (typeof rawName !== 'string') {\n        return;\n      }\n      const name = rawName.trim();\n      if (!name || seenNames.has(name)) {\n        return;\n      }\n      normalized.push({ name, mount: '' });\n      seenNames.add(name);\n      changed = true;\n    });\n  }\n\n  if (!normalized.length) {\n    return { selections: null, changed };\n  }\n\n  return { selections: normalized, changed };\n}\n\nfunction normalizeProject(data) {\n  const restored = restoreCompressedProjectEntry(data);\n  if (restored.restored) {\n    return normalizeProject(restored.value);\n  }\n\n  if (typeof data === \"string\") {\n    const parsed = tryParseJSONLike(data);\n    if (parsed.success) {\n      const normalized = normalizeProject(parsed.parsed);\n      if (normalized) {\n        return normalized;\n      }\n    }\n    return normalizeProject({ gearList: data, projectInfo: null });\n  }\n  if (isMapLike(data)) {\n    const converted = convertMapLikeToObject(data);\n    if (converted) {\n      return normalizeProject(converted);\n    }\n    return null;\n  }\n  if (isPlainObject(data)) {\n    // New format { gearList, projectInfo }\n    if (Object.prototype.hasOwnProperty.call(data, \"gearList\") || Object.prototype.hasOwnProperty.call(data, \"projectInfo\")) {\n      const projectContainer = isMapLike(data.project)\n        ? convertMapLikeToObject(data.project)\n        : data.project;\n\n      let projectInfoSource = data.projectInfo;\n      if (isMapLike(projectInfoSource)) {\n        projectInfoSource = convertMapLikeToObject(projectInfoSource);\n      }\n\n      let normalizedProjectInfo = isPlainObject(projectInfoSource)\n        ? projectInfoSource\n        : null;\n      if (!normalizedProjectInfo && typeof projectInfoSource === \"string\") {\n        const parsedInfo = tryParseJSONLike(projectInfoSource);\n        if (parsedInfo.success && isPlainObject(parsedInfo.parsed)) {\n          normalizedProjectInfo = parsedInfo.parsed;\n        }\n      }\n      if (!normalizedProjectInfo && isPlainObject(projectContainer)) {\n        let nestedProjectInfo = projectContainer.projectInfo;\n        if (isMapLike(nestedProjectInfo)) {\n          nestedProjectInfo = convertMapLikeToObject(nestedProjectInfo);\n        }\n        if (isPlainObject(nestedProjectInfo)) {\n          normalizedProjectInfo = nestedProjectInfo;\n        } else if (typeof nestedProjectInfo === \"string\") {\n          const parsedProjectInfo = tryParseJSONLike(nestedProjectInfo);\n          if (parsedProjectInfo.success && isPlainObject(parsedProjectInfo.parsed)) {\n            normalizedProjectInfo = parsedProjectInfo.parsed;\n          }\n        }\n      }\n\n      let normalizedAutoGearRules = null;\n      const assignAutoGearRules = (source) => {\n        if (normalizedAutoGearRules && normalizedAutoGearRules.length) {\n          return;\n        }\n        if (source === null || source === undefined) {\n          return;\n        }\n        let candidate = source;\n        if (isMapLike(candidate)) {\n          const convertedRules = convertMapLikeToObject(candidate);\n          if (convertedRules) {\n            candidate = Object.values(convertedRules).filter((entry) => entry !== null && entry !== undefined);\n          }\n        }\n        if (Array.isArray(candidate) && candidate.length) {\n          normalizedAutoGearRules = candidate;\n          return;\n        }\n        if (isPlainObject(candidate)) {\n          const values = Object.values(candidate).filter((entry) => entry !== null && entry !== undefined);\n          if (values.length) {\n            normalizedAutoGearRules = values;\n            return;\n          }\n        }\n        if (typeof candidate === \"string\") {\n          const parsedRules = tryParseJSONLike(candidate);\n          if (parsedRules.success && Array.isArray(parsedRules.parsed) && parsedRules.parsed.length) {\n            normalizedAutoGearRules = parsedRules.parsed;\n          }\n        }\n      };\n\n      assignAutoGearRules(data.autoGearRules);\n      if (!normalizedAutoGearRules && isPlainObject(projectContainer)) {\n        assignAutoGearRules(projectContainer.autoGearRules);\n      }\n\n      let gearListSource = isMapLike(data.gearList)\n        ? convertMapLikeToObject(data.gearList)\n        : data.gearList;\n      if (\n        (gearListSource === null\n          || gearListSource === undefined\n          || (typeof gearListSource === \"string\" && !gearListSource))\n        && isPlainObject(projectContainer)\n        && Object.prototype.hasOwnProperty.call(projectContainer, \"gearList\")\n      ) {\n        gearListSource = projectContainer.gearList;\n      }\n      if (isMapLike(gearListSource)) {\n        const convertedGearList = convertMapLikeToObject(gearListSource);\n        if (convertedGearList) {\n          gearListSource = convertedGearList;\n        }\n      }\n\n      let normalizedGearList =\n        typeof gearListSource === \"string\" || (gearListSource && typeof gearListSource === \"object\")\n          ? gearListSource\n          : \"\";\n\n      let normalizedGearSelectors = null;\n      const gearSelectorsSource = isMapLike(data.gearSelectors)\n        ? convertMapLikeToObject(data.gearSelectors)\n        : data.gearSelectors;\n      if (isPlainObject(gearSelectorsSource)) {\n        normalizedGearSelectors = cloneProjectGearSelectors(gearSelectorsSource);\n      } else if (typeof gearSelectorsSource === \"string\") {\n        const parsedSelectors = tryParseJSONLike(gearSelectorsSource);\n        if (parsedSelectors.success && isPlainObject(parsedSelectors.parsed)) {\n          normalizedGearSelectors = cloneProjectGearSelectors(parsedSelectors.parsed);\n        }\n      }\n      const powerSelectionSource = isMapLike(data.powerSelection)\n        ? convertMapLikeToObject(data.powerSelection)\n        : data.powerSelection;\n      let normalizedPowerSelection = normalizeProjectPowerSelection(powerSelectionSource);\n      if (!normalizedPowerSelection && isPlainObject(powerSelectionSource)) {\n        normalizedPowerSelection = normalizeProjectPowerSelection(powerSelectionSource);\n      }\n\n      if (typeof normalizedGearList === \"string\") {\n        const parsedGear = tryParseJSONLike(normalizedGearList);\n        if (parsedGear.success) {\n          const nested = normalizeProject(parsedGear.parsed);\n          if (nested) {\n            normalizedGearList = nested.gearList;\n            if (!normalizedProjectInfo && nested.projectInfo) {\n              normalizedProjectInfo = nested.projectInfo;\n            }\n            if (\n              (!normalizedAutoGearRules || !normalizedAutoGearRules.length)\n              && Array.isArray(nested.autoGearRules)\n              && nested.autoGearRules.length\n            ) {\n              normalizedAutoGearRules = nested.autoGearRules;\n            }\n            if (!normalizedGearSelectors && isPlainObject(nested.gearSelectors)) {\n              normalizedGearSelectors = cloneProjectGearSelectors(nested.gearSelectors);\n            }\n            if (!normalizedPowerSelection && isPlainObject(nested.powerSelection)) {\n              normalizedPowerSelection = normalizeProjectPowerSelection(nested.powerSelection);\n            }\n          } else if (\n            typeof parsedGear.parsed === \"string\"\n            || (isPlainObject(parsedGear.parsed)\n              && Object.values(parsedGear.parsed).every((value) => typeof value === \"string\"))\n          ) {\n            normalizedGearList = parsedGear.parsed;\n          }\n        }\n      }\n\n      if (\n        normalizedGearList\n        && typeof normalizedGearList === \"object\"\n        && !isPlainObject(normalizedGearList)\n      ) {\n        normalizedGearList = \"\";\n      }\n\n      if (normalizedProjectInfo) {\n        normalizeImportedProjectFilters(normalizedProjectInfo);\n      }\n      if (normalizedProjectInfo) {\n        normalizedProjectInfo = sanitizeImportedProjectInfo(normalizedProjectInfo) || null;\n      }\n      if (normalizedProjectInfo) {\n        normalizeImportedProjectFilters(normalizedProjectInfo);\n      }\n\n      const normalized = {\n        gearList: Array.isArray(normalizedGearList) || isPlainObject(normalizedGearList)\n          ? cloneProjectData(normalizedGearList)\n          : normalizedGearList,\n        projectInfo: normalizedProjectInfo ? cloneProjectInfo(normalizedProjectInfo) : null,\n      };\n      const diagramSource = isMapLike(data.diagramPositions)\n        ? convertMapLikeToObject(data.diagramPositions)\n        : data.diagramPositions;\n      let normalizedDiagramPositions = normalizeDiagramPositions(diagramSource);\n      if (\n        Object.keys(normalizedDiagramPositions).length === 0\n        && isPlainObject(projectContainer)\n      ) {\n        const nestedDiagramSource = isMapLike(projectContainer.diagramPositions)\n          ? convertMapLikeToObject(projectContainer.diagramPositions)\n          : projectContainer.diagramPositions;\n        normalizedDiagramPositions = normalizeDiagramPositions(nestedDiagramSource);\n      }\n      if (Object.keys(normalizedDiagramPositions).length) {\n        normalized.diagramPositions = cloneDiagramPositionsForStorage(normalizedDiagramPositions);\n      }\n      const htmlSources = [];\n      if (typeof data.projectHtml === 'string') {\n        htmlSources.push(data.projectHtml);\n      }\n      if (typeof data.gearHtml === 'string') {\n        htmlSources.push(data.gearHtml);\n      }\n      if (isPlainObject(projectContainer)) {\n        if (typeof projectContainer.projectHtml === 'string') {\n          htmlSources.push(projectContainer.projectHtml);\n        }\n        if (typeof projectContainer.gearHtml === 'string') {\n          htmlSources.push(projectContainer.gearHtml);\n        }\n      }\n      if (isPlainObject(gearListSource) && typeof gearListSource.gearHtml === 'string') {\n        htmlSources.push(gearListSource.gearHtml);\n      }\n      if (isPlainObject(normalizedGearList)) {\n        if (typeof normalizedGearList.projectHtml === 'string') {\n          htmlSources.push(normalizedGearList.projectHtml);\n        }\n        if (typeof normalizedGearList.gearHtml === 'string') {\n          htmlSources.push(normalizedGearList.gearHtml);\n        }\n      } else if (typeof normalizedGearList === 'string') {\n        htmlSources.push(normalizedGearList);\n      }\n      if (!normalizedGearSelectors && isPlainObject(projectContainer)) {\n        const nestedSelectorsSource = isMapLike(projectContainer.gearSelectors)\n          ? convertMapLikeToObject(projectContainer.gearSelectors)\n          : projectContainer.gearSelectors;\n        if (isPlainObject(nestedSelectorsSource)) {\n          normalizedGearSelectors = cloneProjectGearSelectors(nestedSelectorsSource);\n        }\n      }\n      if (!normalizedGearSelectors && isPlainObject(normalizedGearList) && isPlainObject(normalizedGearList.gearSelectors)) {\n        normalizedGearSelectors = cloneProjectGearSelectors(normalizedGearList.gearSelectors);\n      }\n      if (!normalizedPowerSelection && isPlainObject(projectContainer)) {\n        const nestedPowerSelection = isMapLike(projectContainer.powerSelection)\n          ? convertMapLikeToObject(projectContainer.powerSelection)\n          : projectContainer.powerSelection;\n        if (isPlainObject(nestedPowerSelection)) {\n          normalizedPowerSelection = normalizeProjectPowerSelection(nestedPowerSelection);\n        }\n      }\n      if (!normalizedProjectInfo) {\n        for (let i = 0; i < htmlSources.length; i += 1) {\n          const recovered = extractProjectInfoFromHtml(htmlSources[i]);\n          if (recovered) {\n            normalized.projectInfo = cloneProjectInfo(recovered);\n            break;\n          }\n        }\n      } else if (htmlSources.length) {\n        for (let i = 0; i < htmlSources.length; i += 1) {\n          const recovered = extractProjectInfoFromHtml(htmlSources[i]);\n          if (recovered) {\n            const recoveredClone = cloneProjectInfo(recovered) || {};\n            const normalizedClone = cloneProjectInfo(normalizedProjectInfo) || {};\n            normalized.projectInfo = { ...recoveredClone, ...normalizedClone };\n            break;\n          }\n        }\n      }\n      const fallbackLensNames = [];\n      const fallbackLensNameSet = new Set();\n      const addFallbackLensName = (name) => {\n        if (typeof name !== 'string') {\n          return;\n        }\n        const trimmed = name.trim();\n        if (!trimmed || fallbackLensNameSet.has(trimmed)) {\n          return;\n        }\n        fallbackLensNameSet.add(trimmed);\n        fallbackLensNames.push(trimmed);\n      };\n      const registerFallbackLensNames = (source, options = {}) => {\n        if (source === null || source === undefined) {\n          return;\n        }\n        if (options.fromSelections) {\n          const entries = Array.isArray(source) ? source : [source];\n          entries.forEach((entry) => {\n            if (isMapLike(entry)) {\n              const converted = convertMapLikeToObject(entry);\n              if (converted) {\n                registerFallbackLensNames(converted, { fromSelections: true });\n                return;\n              }\n            }\n            if (isPlainObject(entry)) {\n              const mapped = deriveLensSelectionsFromNameMap(entry);\n              if (mapped.length) {\n                mapped.forEach((selection) => {\n                  if (selection && typeof selection.name === 'string') {\n                    addFallbackLensName(selection.name);\n                  }\n                });\n                return;\n              }\n            }\n            const candidate = normalizeProjectLensNameCandidate(entry);\n            if (candidate) {\n              addFallbackLensName(candidate);\n            }\n          });\n          return;\n        }\n        const names = extractLensNamesFromSource(source);\n        if (!names.length) {\n          return;\n        }\n        names.forEach((name) => {\n          addFallbackLensName(name);\n        });\n      };\n\n      if (\n        normalized.projectInfo\n        && Object.prototype.hasOwnProperty.call(normalized.projectInfo, 'lenses')\n      ) {\n        const { names } = normalizeProjectLensNamesField(normalized.projectInfo.lenses);\n        normalized.projectInfo = normalized.projectInfo && typeof normalized.projectInfo === 'object'\n          ? normalized.projectInfo\n          : {};\n        normalized.projectInfo.lenses = names.slice();\n        registerFallbackLensNames(names);\n      }\n\n      registerFallbackLensNames(data.lenses);\n      if (isPlainObject(projectContainer)) {\n        registerFallbackLensNames(projectContainer.lenses);\n      }\n      registerFallbackLensNames(gearListSource && gearListSource.lenses);\n      if (isPlainObject(normalizedGearList)) {\n        registerFallbackLensNames(normalizedGearList.lenses);\n      }\n\n      if (\n        (!normalized.projectInfo\n          || !Array.isArray(normalized.projectInfo.lenses)\n          || !normalized.projectInfo.lenses.length)\n        && fallbackLensNames.length\n      ) {\n        normalized.projectInfo = normalized.projectInfo && typeof normalized.projectInfo === 'object'\n          ? normalized.projectInfo\n          : {};\n        normalized.projectInfo.lenses = fallbackLensNames.slice();\n      }\n\n      const lensSelectionSources = [];\n      if (\n        normalized.projectInfo\n        && Object.prototype.hasOwnProperty.call(normalized.projectInfo, 'lensSelections')\n      ) {\n        registerFallbackLensNames(normalized.projectInfo.lensSelections, { fromSelections: true });\n        lensSelectionSources.push(normalized.projectInfo.lensSelections);\n      }\n      if (Object.prototype.hasOwnProperty.call(data, 'lensSelections')) {\n        registerFallbackLensNames(data.lensSelections, { fromSelections: true });\n        lensSelectionSources.push(data.lensSelections);\n      }\n      if (\n        isPlainObject(projectContainer)\n        && Object.prototype.hasOwnProperty.call(projectContainer, 'lensSelections')\n      ) {\n        registerFallbackLensNames(projectContainer.lensSelections, { fromSelections: true });\n        lensSelectionSources.push(projectContainer.lensSelections);\n      }\n      if (\n        isPlainObject(gearListSource)\n        && Object.prototype.hasOwnProperty.call(gearListSource, 'lensSelections')\n      ) {\n        registerFallbackLensNames(gearListSource.lensSelections, { fromSelections: true });\n        lensSelectionSources.push(gearListSource.lensSelections);\n      }\n      if (\n        isPlainObject(normalizedGearList)\n        && Object.prototype.hasOwnProperty.call(normalizedGearList, 'lensSelections')\n      ) {\n        registerFallbackLensNames(normalizedGearList.lensSelections, { fromSelections: true });\n        lensSelectionSources.push(normalizedGearList.lensSelections);\n      }\n\n      const lensSelectionResult = normalizeProjectLensSelectionsFromSources(\n        lensSelectionSources,\n        fallbackLensNames,\n      );\n\n      if (\n        lensSelectionResult\n        && lensSelectionResult.selections\n        && lensSelectionResult.selections.length\n      ) {\n        normalized.projectInfo = normalized.projectInfo && typeof normalized.projectInfo === 'object'\n          ? normalized.projectInfo\n          : {};\n        normalized.projectInfo.lensSelections = lensSelectionResult.selections;\n        if (\n          !Array.isArray(normalized.projectInfo.lenses)\n          || !normalized.projectInfo.lenses.length\n        ) {\n          normalized.projectInfo.lenses = lensSelectionResult.selections\n            .map((entry) => (typeof entry.name === 'string' ? entry.name : ''))\n            .filter((name) => name);\n        }\n      } else if (\n        lensSelectionResult\n        && lensSelectionResult.changed\n        && normalized.projectInfo\n        && Object.prototype.hasOwnProperty.call(normalized.projectInfo, 'lensSelections')\n      ) {\n        delete normalized.projectInfo.lensSelections;\n      }\n      const derivedGenerationFlag = typeof data.gearListAndProjectRequirementsGenerated === 'boolean'\n        ? data.gearListAndProjectRequirementsGenerated\n        : htmlSources.some((value) => typeof value === 'string' && value.trim());\n      normalized.gearListAndProjectRequirementsGenerated = derivedGenerationFlag;\n      if (normalizedAutoGearRules && normalizedAutoGearRules.length) {\n        normalized.autoGearRules = cloneAutoGearRules(normalizedAutoGearRules);\n      }\n      if (normalizedGearSelectors && Object.keys(normalizedGearSelectors).length) {\n        normalized.gearSelectors = normalizedGearSelectors;\n      }\n      if (normalizedPowerSelection) {\n        normalized.powerSelection = cloneProjectPowerSelection(normalizedPowerSelection);\n      }\n      copyAutoBackupMetadata(data, normalized);\n      if (normalized.projectInfo) {\n        normalizeImportedProjectFilters(normalized.projectInfo);\n      }\n      if (normalized.projectInfo) {\n        const normalizedInfo = normalizeLegacyLongGopStructure(normalized.projectInfo);\n        if (normalizedInfo !== normalized.projectInfo) {\n          normalized.projectInfo = normalizedInfo;\n        }\n      }\n      if (normalized.autoGearRules) {\n        const normalizedRules = normalizeLegacyLongGopStructure(normalized.autoGearRules);\n        if (normalizedRules !== normalized.autoGearRules) {\n          normalized.autoGearRules = normalizedRules;\n        }\n      }\n      if (normalized.gearSelectors) {\n        const normalizedSelectors = normalizeLegacyLongGopStructure(normalized.gearSelectors);\n        if (normalizedSelectors !== normalized.gearSelectors) {\n          normalized.gearSelectors = normalizedSelectors;\n        }\n      }\n      if (normalized.diagramPositions) {\n        const normalizedDiagram = normalizeLegacyLongGopStructure(normalized.diagramPositions);\n        if (normalizedDiagram !== normalized.diagramPositions) {\n          normalized.diagramPositions = normalizedDiagram;\n        }\n      }\n      if (normalized.powerSelection) {\n        const normalizedPower = normalizeLegacyLongGopStructure(normalized.powerSelection);\n        if (normalizedPower !== normalized.powerSelection) {\n          normalized.powerSelection = normalizedPower;\n        }\n      }\n      return normalized;\n    }\n    // Legacy format { projectHtml, gearHtml }\n    if (Object.prototype.hasOwnProperty.call(data, \"projectHtml\") || Object.prototype.hasOwnProperty.call(data, \"gearHtml\")) {\n      return {\n        gearList: { projectHtml: data.projectHtml || \"\", gearHtml: data.gearHtml || \"\" },\n        projectInfo: null,\n      };\n    }\n\n    if (isPlainObject(data.project)) {\n      const nested = normalizeProject(data.project);\n      if (nested) {\n        return nested;\n      }\n    } else if (typeof data.project === \"string\") {\n      const parsedProject = tryParseJSONLike(data.project);\n      if (parsedProject.success) {\n        const nested = normalizeProject(parsedProject.parsed);\n        if (nested) {\n          return nested;\n        }\n      }\n    }\n  }\n  return null;\n}\n\nvar LEGACY_PROJECT_ROOT_KEYS = new Set([\n  \"gearList\",\n  \"projectInfo\",\n  \"projectHtml\",\n  \"gearHtml\",\n  \"autoGearRules\",\n  \"powerSelection\",\n  \"gearListAndProjectRequirementsGenerated\",\n]);\n\nvar NORMALIZED_PROJECT_KEYS = new Set([\n  \"gearList\",\n  \"projectInfo\",\n  \"autoGearRules\",\n  \"diagramPositions\",\n  \"gearSelectors\",\n  \"powerSelection\",\n  \"gearListAndProjectRequirementsGenerated\",\n]);\n\nfunction isNormalizedProjectEntry(entry) {\n  if (!isPlainObject(entry)) {\n    return false;\n  }\n  const keys = Object.keys(entry);\n  if (!keys.every((key) => NORMALIZED_PROJECT_KEYS.has(key))) {\n    return false;\n  }\n  const { gearList, projectInfo } = entry;\n  if (\n    typeof gearList !== \"string\" &&\n    !(isPlainObject(gearList) &&\n      Object.keys(gearList).every((key) => typeof gearList[key] === \"string\"))\n  ) {\n    return false;\n  }\n  if (projectInfo !== null && !isPlainObject(projectInfo)) {\n    return false;\n  }\n  if (Object.prototype.hasOwnProperty.call(entry, \"autoGearRules\")) {\n    if (!Array.isArray(entry.autoGearRules) || !entry.autoGearRules.length) {\n      return false;\n    }\n  }\n  if (\n    Object.prototype.hasOwnProperty.call(entry, \"diagramPositions\")\n    && !isPlainObject(entry.diagramPositions)\n  ) {\n    return false;\n  }\n  if (\n    Object.prototype.hasOwnProperty.call(entry, \"gearSelectors\")\n    && !isPlainObject(entry.gearSelectors)\n  ) {\n    return false;\n  }\n  if (\n    Object.prototype.hasOwnProperty.call(entry, \"powerSelection\")\n  ) {\n    const powerSelection = entry.powerSelection;\n    if (!isPlainObject(powerSelection)) {\n      return false;\n    }\n  }\n  if (\n    Object.prototype.hasOwnProperty.call(entry, \"gearListAndProjectRequirementsGenerated\")\n    && typeof entry.gearListAndProjectRequirementsGenerated !== \"boolean\"\n  ) {\n    return false;\n  }\n  return true;\n}\n\nfunction normalizeProjectStorageKey(name) {\n  if (typeof name !== \"string\") {\n    return \"\";\n  }\n  return name.trim();\n}\n\nfunction setActiveProjectCompressionHold(name) {\n  if (name === null || name === undefined) {\n    ACTIVE_PROJECT_COMPRESSION_HOLD_KEY = '';\n    ACTIVE_PROJECT_COMPRESSION_HOLD_ENABLED = false;\n    return '';\n  }\n\n  const normalized = normalizeProjectStorageKey(name);\n  if (isForcedProjectCompressionLocked(normalized)) {\n    ACTIVE_PROJECT_COMPRESSION_HOLD_KEY = '';\n    ACTIVE_PROJECT_COMPRESSION_HOLD_ENABLED = false;\n    return normalized;\n  }\n  ACTIVE_PROJECT_COMPRESSION_HOLD_KEY = normalized;\n  ACTIVE_PROJECT_COMPRESSION_HOLD_ENABLED = true;\n  return normalized;\n}\n\nfunction clearActiveProjectCompressionHold(name) {\n  if (!ACTIVE_PROJECT_COMPRESSION_HOLD_ENABLED) {\n    return false;\n  }\n\n  if (name !== undefined) {\n    const normalized = normalizeProjectStorageKey(name);\n    if (normalized !== ACTIVE_PROJECT_COMPRESSION_HOLD_KEY) {\n      return false;\n    }\n  }\n\n  ACTIVE_PROJECT_COMPRESSION_HOLD_KEY = '';\n  ACTIVE_PROJECT_COMPRESSION_HOLD_ENABLED = false;\n  return true;\n}\n\n\n\nfunction resolveProjectKey(projects, lookup, name, options = {}) {\n  if (!projects || typeof projects !== \"object\") {\n    return null;\n  }\n\n  const rawName = typeof name === \"string\" ? name : \"\";\n  if (Object.prototype.hasOwnProperty.call(projects, rawName)) {\n    return rawName;\n  }\n\n  const normalizedName = normalizeProjectStorageKey(rawName);\n  if (\n    normalizedName\n    && normalizedName !== rawName\n    && Object.prototype.hasOwnProperty.call(projects, normalizedName)\n  ) {\n    return normalizedName;\n  }\n\n  if (!lookup || typeof lookup !== \"object\") {\n    return null;\n  }\n\n  const { raw: rawMap, normalized: normalizedMap } = lookup;\n\n  if (rawMap && typeof rawMap.get === \"function\" && rawMap.has(rawName)) {\n    const candidate = rawMap.get(rawName);\n    if (Object.prototype.hasOwnProperty.call(projects, candidate)) {\n      return candidate;\n    }\n  }\n\n  if (\n    normalizedMap\n    && typeof normalizedMap.get === \"function\"\n    && normalizedMap.has(normalizedName)\n  ) {\n    const candidates = normalizedMap.get(normalizedName);\n    if (Array.isArray(candidates)) {\n      if (options && options.preferExact && rawName) {\n        const exact = candidates.find(\n          (candidate) => candidate === rawName && Object.prototype.hasOwnProperty.call(projects, candidate),\n        );\n        if (exact) {\n          return exact;\n        }\n      }\n      const firstExisting = candidates.find((candidate) =>\n        Object.prototype.hasOwnProperty.call(projects, candidate)\n      );\n      if (firstExisting) {\n        return firstExisting;\n      }\n    } else if (\n      typeof candidates === \"string\"\n      && Object.prototype.hasOwnProperty.call(projects, candidates)\n    ) {\n      return candidates;\n    }\n  }\n\n  return null;\n}\n\nfunction buildProjectLookupFromProjects(projects = {}) {\n  const rawKeyLookup = new Map();\n  const normalizedKeyLookup = new Map();\n  const entries = projects && typeof projects === 'object' ? Object.keys(projects) : [];\n\n  entries.forEach((key) => {\n    if (typeof key !== 'string') {\n      return;\n    }\n    rawKeyLookup.set(key, key);\n    const normalized = normalizeProjectStorageKey(key);\n    if (!normalizedKeyLookup.has(normalized)) {\n      normalizedKeyLookup.set(normalized, []);\n    }\n    normalizedKeyLookup.get(normalized).push(key);\n  });\n\n  return { raw: rawKeyLookup, normalized: normalizedKeyLookup };\n}\n\nfunction readAllProjectsFromStorage(options = {}) {\n  const {\n    forceRefresh = false,\n    forMutation = false,\n    skipMigrations = false,\n    skipAutoBackupExpansion = false,\n  } = options || {};\n\n  if (!skipMigrations) {\n    applyLegacyStorageMigrations();\n  }\n\n  // [Refactor] Hybrid Approach: Use Memory Cache if Hydrated (IndexedDB active)\n  if (isProjectCacheHydrated && !forceRefresh) {\n    const projectsSnapshot = { ...projectMemoryCache };\n    const lookupSnapshot = buildProjectLookupFromProjects(projectsSnapshot);\n    return {\n      projects: projectsSnapshot,\n      changed: false,\n      originalValue: { ...projectMemoryCache },\n      lookup: cloneProjectLookupSnapshotForReturn(lookupSnapshot),\n    };\n  }\n\n  // Fallback to Legacy LocalStorage Logic\n  const safeStorage = getSafeLocalStorage();\n  let storageRaw = null;\n  if (safeStorage && typeof safeStorage.getItem === 'function') {\n    try {\n      storageRaw = safeStorage.getItem(PROJECT_STORAGE_KEY);\n    } catch (storageReadError) {\n      storageRaw = null;\n      void storageReadError;\n    }\n  }\n\n  const parsed = loadJSONFromStorage(\n    safeStorage,\n    PROJECT_STORAGE_KEY,\n    \"Error loading project from localStorage:\",\n    null,\n    {\n      validate: (value) =>\n        value === null\n        || typeof value === \"string\"\n        || Array.isArray(value)\n        || isPlainObject(value),\n    },\n  );\n  const originalValue = parsed;\n  let combinedRawEntries = null;\n\n  if (isPlainObject(parsed)) {\n    combinedRawEntries = { ...parsed };\n  } else {\n    combinedRawEntries = {};\n  }\n\n  if (safeStorage && typeof safeStorage.length === 'number') {\n    const count = safeStorage.length;\n    for (let i = 0; i < count; i++) {\n      const key = safeStorage.key(i);\n      if (!key || !key.startsWith(PROJECT_SHARD_PREFIX)) {\n        continue;\n      }\n      const rawName = key.substring(PROJECT_SHARD_PREFIX.length);\n      if (rawName === null || rawName === undefined) {\n        continue;\n      }\n      try {\n        const rawVal = safeStorage.getItem(key);\n        const parsedVal = JSON.parse(decodeStoredValue(rawVal));\n        // Store raw value to allow expansion of backups later\n        if (combinedRawEntries === null) {\n          combinedRawEntries = {};\n        }\n        combinedRawEntries[rawName] = parsedVal;\n      } catch (e) {\n        void e;\n      }\n    }\n  }\n\n  let inputForExpansion = parsed;\n  // preferring combined object if we have shards or if existing was object\n  if (combinedRawEntries !== null && Object.keys(combinedRawEntries).length > 0) {\n    inputForExpansion = combinedRawEntries;\n  } else if (isPlainObject(parsed)) {\n    inputForExpansion = combinedRawEntries;\n  }\n\n  const expandOptions = {\n    isAutoBackupKey: isAutoBackupStorageKey,\n  };\n  if (skipAutoBackupExpansion) {\n    expandOptions.filter = (name) => !isAutoBackupStorageKey(name);\n  }\n  const expandedParsed = expandAutoBackupEntries(inputForExpansion, expandOptions);\n  const projects = {};\n  let changed = false;\n  const usedProjectNames = new Set();\n  const normalizedProjectNames = new Set();\n  const markProjectNameUsed = (name) => {\n    if (typeof name !== \"string\") {\n      return;\n    }\n    usedProjectNames.add(name);\n    const trimmed = name.trim();\n    if (trimmed) {\n      normalizedProjectNames.add(trimmed.toLowerCase());\n    }\n  };\n\n  const rawKeyLookup = new Map();\n  const normalizedKeyLookup = new Map();\n  const registerLookupKey = (rawKey, storedKey) => {\n    if (typeof rawKey !== \"string\") {\n      return;\n    }\n    const effectiveKey = typeof storedKey === \"string\" ? storedKey : rawKey;\n    rawKeyLookup.set(rawKey, effectiveKey);\n    const normalized = normalizeProjectStorageKey(rawKey);\n    if (!normalizedKeyLookup.has(normalized)) {\n      normalizedKeyLookup.set(normalized, []);\n    }\n    normalizedKeyLookup.get(normalized).push(effectiveKey);\n  };\n\n  const createLookupSnapshot = () => ({\n    raw: cloneLookupMap(rawKeyLookup),\n    normalized: cloneLookupMap(normalizedKeyLookup),\n  });\n\n  const finalize = () => {\n\n    const snapshot = {\n      projects,\n      changed,\n      originalValue,\n      lookup: createLookupSnapshot(),\n      rawValue: storageRaw,\n    };\n\n    if (changed) {\n      setProjectReadCacheSnapshot(null);\n      if (forMutation) {\n        return {\n          projects: STORAGE_DEEP_CLONE(snapshot.projects),\n          changed: snapshot.changed,\n          originalValue: snapshot.originalValue,\n          lookup: cloneProjectLookupSnapshotForReturn(snapshot.lookup),\n        };\n      }\n      return snapshot;\n    }\n\n    const shouldUseCache = !forceRefresh;\n    if (!shouldUseCache) {\n      return snapshot;\n    }\n\n    setProjectReadCacheSnapshot(snapshot);\n    const cached = getProjectReadCacheClone({ forMutation });\n    return cached || snapshot;\n  };\n\n  if (expandedParsed === null || expandedParsed === undefined) {\n    return finalize();\n  }\n\n  if (typeof expandedParsed === \"string\") {\n    const normalized = normalizeProject(expandedParsed);\n    if (normalized) {\n      const suggestedName =\n        (normalized && normalized.projectInfo && typeof normalized.projectInfo.projectName === 'string')\n          ? normalized.projectInfo.projectName\n          : \"\";\n      const updatedName = generateUpdatedProjectName(suggestedName, usedProjectNames, normalizedProjectNames);\n      projects[updatedName] = normalized;\n      registerLookupKey(\"\", updatedName);\n      markProjectNameUsed(updatedName);\n    }\n    changed = true;\n    return finalize();\n  }\n\n  if (Array.isArray(expandedParsed)) {\n    const usedNames = usedProjectNames;\n    const normalizedNames = normalizedProjectNames;\n    expandedParsed.forEach((item, index) => {\n      const normalized = normalizeProject(item);\n      if (!normalized) {\n        changed = true;\n        return;\n      }\n      const baseName =\n        isPlainObject(item) && typeof item.name === \"string\"\n          ? item.name.trim()\n          : `Project ${index + 1}`;\n      const candidate = baseName || `Project ${index + 1}`;\n      const unique = generateUpdatedProjectName(candidate, usedNames, normalizedNames);\n      projects[unique] = normalized;\n      registerLookupKey(candidate, unique);\n      markProjectNameUsed(unique);\n    });\n    changed = true;\n    return finalize();\n  }\n\n  if (!isPlainObject(expandedParsed)) {\n    changed = true;\n    return finalize();\n  }\n\n  const keys = Object.keys(expandedParsed);\n  const maybeLegacy =\n    keys.length > 0 && keys.every((key) => LEGACY_PROJECT_ROOT_KEYS.has(key));\n\n  if (maybeLegacy) {\n    const normalized = normalizeProject(expandedParsed);\n    if (normalized) {\n      const updatedName = generateUpdatedProjectName(\"\", usedProjectNames, normalizedProjectNames);\n      projects[updatedName] = normalized;\n      registerLookupKey(\"\", updatedName);\n      markProjectNameUsed(updatedName);\n    }\n    changed = true;\n    return finalize();\n  }\n\n  keys.forEach((key) => {\n    if (isNormalizedProjectEntry(expandedParsed[key])) {\n      const trimmedKey = typeof key === \"string\" ? key.trim() : \"\";\n      if (trimmedKey) {\n        normalizedProjectNames.add(trimmedKey.toLowerCase());\n      }\n    }\n  });\n\n  keys.forEach((key) => {\n    const normalized = normalizeProject(expandedParsed[key]);\n    if (normalized) {\n      const originalEntry = expandedParsed[key];\n      const isNormalized = isNormalizedProjectEntry(originalEntry);\n      // console.log('DEBUG: readAllProjectsFromStorage key:', key, 'isNormalized:', isNormalized);\n      const needsUpgrade = !isNormalized;\n      let requiresContentUpdate = false;\n      if (!needsUpgrade) {\n        try {\n          const normalizedSignature = createStableValueSignature(normalized);\n          const originalSignature = createStableValueSignature(originalEntry);\n          if (normalizedSignature !== originalSignature) {\n            requiresContentUpdate = true;\n          }\n        } catch (signatureError) {\n          requiresContentUpdate = true;\n          console.warn(\n            'Unable to compare stored project entry during legacy long-GOP normalization check',\n            signatureError,\n          );\n        }\n      }\n      let finalKey = key;\n      if (needsUpgrade) {\n        const innerName = (normalized && normalized.projectInfo && typeof normalized.projectInfo.projectName === 'string' && normalized.projectInfo.projectName)\n          ? normalized.projectInfo.projectName\n          : key;\n        finalKey = generateUpdatedProjectName(innerName, usedProjectNames, normalizedProjectNames);\n        changed = true;\n      }\n      if (\n        finalKey !== key\n        && Object.prototype.hasOwnProperty.call(projects, finalKey)\n      ) {\n        const adjusted = generateUpdatedProjectName(finalKey, usedProjectNames, normalizedProjectNames);\n        finalKey = adjusted;\n      }\n      projects[finalKey] = normalized;\n      registerLookupKey(key, finalKey);\n      markProjectNameUsed(finalKey);\n      if (!needsUpgrade && requiresContentUpdate) {\n        changed = true;\n      }\n    } else {\n      changed = true;\n    }\n  });\n\n  return finalize();\n}\n\nfunction pruneOrphanProjectShards(storage, projects) {\n  if (!storage || typeof storage.length !== 'number' || !isPlainObject(projects)) {\n    return;\n  }\n  const projectKeys = new Set(\n    Object.keys(projects).map((name) => normalizeProjectStorageKey(name)),\n  );\n  const keysToDelete = [];\n  for (let i = 0; i < storage.length; i += 1) {\n    const key = storage.key(i);\n    if (key && key.startsWith(PROJECT_SHARD_PREFIX)) {\n      const rawName = key.substring(PROJECT_SHARD_PREFIX.length);\n      if (!projectKeys.has(rawName)) {\n        keysToDelete.push(key);\n      }\n    }\n  }\n  keysToDelete.forEach((key) =>\n    deleteFromStorage(storage, key, 'Pruning orphan project shard:'),\n  );\n}\n\nfunction cleanupMonolithicProjectStorage(storage) {\n  if (!storage) return;\n\n  // Skip if we've already handled the monolith this session\n  if (GLOBAL_SCOPE && GLOBAL_SCOPE.__cineMonolithicProjectCleanupDone) {\n    return;\n  }\n\n  const raw = storage.getItem(PROJECT_STORAGE_KEY);\n  // If it's already empty, mark as done and return.\n  if (!raw) {\n    if (GLOBAL_SCOPE) {\n      GLOBAL_SCOPE.__cineMonolithicProjectCleanupDone = true;\n    }\n    return;\n  }\n\n  // Ensure we have a migration backup before we delete the monolith\n  try {\n    const parsed = JSON.parse(decodeStoredValue(raw));\n    if (parsed) {\n      createStorageMigrationBackup(storage, PROJECT_STORAGE_KEY, parsed);\n    }\n  } catch (e) {\n    // If parsing fails, we skip migration backup but proceed with cleanup to prevent infinite loops\n    // if the data is corrupted and causing other issues.\n    void e;\n  }\n\n  deleteFromStorage(\n    storage,\n    PROJECT_STORAGE_KEY,\n    \"Error clearing project monolithic storage after sharding:\",\n    {\n      disableBackup: false,\n      disableMigrationCleanup: true\n    }\n  );\n\n  // Mark as done so we don't repeat this process\n  if (GLOBAL_SCOPE) {\n    GLOBAL_SCOPE.__cineMonolithicProjectCleanupDone = true;\n  }\n}\n\nfunction persistProjectShard(name, project, options = {}) {\n  if (name === null || name === undefined || project === undefined || project === null) {\n    return false;\n  }\n  const safeStorage = getSafeLocalStorage();\n  if (!safeStorage) {\n    return false;\n  }\n\n  const { skipCompression = false } = options || {};\n  const shardKey = PROJECT_SHARD_PREFIX + normalizeProjectStorageKey(name);\n\n  // Prepare a temporary object to use existing serialization logic\n  const entries = {};\n  entries[name] = project;\n\n  const serialized = serializeAutoBackupEntries(entries, {\n    isAutoBackupKey: isAutoBackupStorageKey,\n  });\n  const projectData = serialized[name];\n\n  const result = saveJSONToStorage(\n    safeStorage,\n    shardKey,\n    projectData,\n    `Error saving project shard \"${name}\":`,\n    {\n      disableCompression: skipCompression,\n      forceCompressionOnQuota: true,\n      disableBackup: true,\n      onQuotaExceeded: () => {\n        // Cross-shard quota recovery: try to prune the oldest auto-backup shard.\n        // Note: we don't want forMutation: true here because we are in the middle of a save.\n        const { projects } = readAllProjectsFromStorage({ forMutation: false, skipMigrations: true });\n        let removedKey = removeOldestAutoBackupEntry(projects);\n\n        if (!removedKey) {\n          removedKey = removeOldestAutoBackupEntry(projects, { force: true });\n        }\n\n        if (removedKey) {\n          const victimKey = PROJECT_SHARD_PREFIX + normalizeProjectStorageKey(removedKey);\n          deleteFromStorage(safeStorage, victimKey, `Pruning shard \"${removedKey}\" to recover space:`);\n          return true;\n        }\n        return false;\n      },\n    }\n  );\n\n  return result === 'success';\n}\n\nfunction persistAllProjects(projects, options = {}) {\n  const { skipCompression = false } = options || {};\n  const safeStorage = getSafeLocalStorage();\n\n  if (!projects || typeof projects !== 'object') return;\n\n  // Prune within the projects object first (handling auto-backup counts)\n  enforceAutoBackupLimits(projects);\n\n  // CRITICAL: Clean up orphan shards BEFORE persisting new ones.\n  // This frees storage space first, preventing quota exceeded errors\n  // when old auto-backup shards persist from previous sessions.\n  pruneOrphanProjectShards(safeStorage, projects);\n\n  // Persist each project as its own shard.\n  Object.keys(projects).forEach((name) => {\n    persistProjectShard(name, projects[name], { skipCompression });\n  });\n\n  // Monolithic key cleanup (migration from old format)\n  cleanupMonolithicProjectStorage(safeStorage);\n\n  bumpProjectStorageRevision(safeStorage);\n\n  // [Performance] Update the Project Index\n  try {\n    updateProjectIndex(projects, safeStorage);\n  } catch (indexError) {\n    console.warn('Failed to update project index', indexError);\n  }\n\n  invalidateProjectReadCache();\n  if (lifecycleChannel) {\n    try {\n      lifecycleChannel.postMessage('project-shards-changed');\n    } catch (e) {\n      void e;\n    }\n  }\n}\n\n/**\n * Reads, validates, and returns the project index from storage.\n * Returns null if missing or invalid.\n */\n// [Agent Refactor] Memory Cache for Project Index (Synchronous Read Support)\nlet projectIndexCache = null;\n\nfunction normalizeProjectIndexForCache(index) {\n  if (!index || typeof index !== 'object') {\n    return null;\n  }\n\n  const normalized = {};\n  const keys = Object.keys(index);\n  keys.forEach((key) => {\n    if (typeof key !== 'string') {\n      return;\n    }\n    const rawKey =\n      storageRepo && typeof storageRepo.getProjectKeyFromStorageKey === 'function'\n        ? storageRepo.getProjectKeyFromStorageKey(key)\n        : key;\n    if (rawKey === null || rawKey === undefined) {\n      return;\n    }\n    const entry = index[key];\n\n    if (!Object.prototype.hasOwnProperty.call(normalized, rawKey)) {\n      normalized[rawKey] = entry;\n      return;\n    }\n\n    const existing = normalized[rawKey];\n    const entryModified =\n      entry && typeof entry === 'object' && typeof entry.lastModified === 'number'\n        ? entry.lastModified\n        : null;\n    const existingModified =\n      existing && typeof existing === 'object' && typeof existing.lastModified === 'number'\n        ? existing.lastModified\n        : null;\n\n    if (\n      typeof entryModified === 'number'\n      && typeof existingModified === 'number'\n      && entryModified > existingModified\n    ) {\n      normalized[rawKey] = entry;\n    }\n  });\n\n  return Object.keys(normalized).length ? normalized : null;\n}\n\nfunction buildProjectIndexForRepo(index) {\n  if (!index || typeof index !== 'object') {\n    return null;\n  }\n  if (!storageRepo || typeof storageRepo.getProjectStorageKey !== 'function') {\n    return index;\n  }\n\n  const prefixed = {};\n  Object.keys(index).forEach((key) => {\n    if (typeof key !== 'string') {\n      return;\n    }\n    const storageKey = storageRepo.getProjectStorageKey(key);\n    prefixed[storageKey] = index[key];\n  });\n  return prefixed;\n}\n\nasync function migrateProjectKeyPrefixOnStartup() {\n  if (!storageRepo || typeof storageRepo.migrateUnprefixedProjectRecords !== 'function') {\n    return { migratedKeys: [], hasIndex: false };\n  }\n\n  try {\n    const storedIndex = await storageRepo.getItem(PROJECT_INDEX_KEY);\n    const indexKeys = storedIndex && typeof storedIndex === 'object'\n      ? Object.keys(storedIndex)\n      : [];\n    const normalizedIndex = normalizeProjectIndexForCache(storedIndex);\n    const migrationResult = await storageRepo.migrateUnprefixedProjectRecords({\n      projectIndexKeys: indexKeys,\n    });\n\n    if (normalizedIndex) {\n      projectIndexCache = normalizedIndex;\n      const prefixedIndex = buildProjectIndexForRepo(normalizedIndex);\n      if (prefixedIndex) {\n        await storageRepo.setItem(PROJECT_INDEX_KEY, prefixedIndex);\n      }\n    }\n\n    return { migratedKeys: migrationResult.migratedKeys || [], hasIndex: Boolean(normalizedIndex) };\n  } catch (migrationError) {\n    console.warn('[storage.js] Project prefix migration failed', migrationError);\n    return { migratedKeys: [], hasIndex: false };\n  }\n}\n\n/**\n * Reads, validates, and returns the project index from storage.\n * Returns null if missing or invalid.\n */\nfunction readProjectIndex() {\n  // Return cached version if available (hydrated from IDB)\n  if (projectIndexCache) {\n    return projectIndexCache;\n  }\n\n  // Fallback to legacy LocalStorage if cache not ready (rare, only during rapid boot)\n  const safeStorage = getSafeLocalStorage();\n  const isIndexedDB = storageRepo && storageRepo.driver && storageRepo.driver.constructor && storageRepo.driver.constructor.name === 'IndexedDBAdapter';\n\n  if (!safeStorage || typeof safeStorage.getItem !== 'function') return null;\n\n  // If we are strictly on IDB and cache is empty, we return null (assuming hydration handles it).\n  // But for safety during migration, we can check legacy one last time?\n  // No, if isIndexedDB is active, we should rely on cache.\n  if (isIndexedDB) {\n    return null;\n  }\n\n  try {\n    const raw = safeStorage.getItem(PROJECT_INDEX_KEY);\n    if (!raw) return null;\n\n    const index = JSON.parse(raw);\n    if (index && typeof index === 'object') {\n      return normalizeProjectIndexForCache(index) || index;\n    }\n  } catch (e) {\n    console.warn('Failed to read project index', e);\n  }\n  return null;\n}\n\n/**\n * Updates the persisted project index based on the full projects map.\n */\nfunction updateProjectIndex(projects, safeStorage) {\n  // if (!safeStorage || typeof safeStorage.setItem !== 'function') return; // Relaxed for repo support\n  if (!projects || typeof projects !== 'object') return;\n\n  const index = {};\n  Object.keys(projects).forEach(key => {\n    // Skip auto-backups in the index to keep it small\n    if (isAutoBackupStorageKey(key)) return;\n\n    const project = projects[key];\n    if (!project) return;\n\n    index[key] = {\n      color: project.color,\n      icon: project.icon,\n      lastModified: project.lastModified,\n      prepDays: project.prepDays,\n      shootingDays: project.shootingDays,\n      returnDays: project.returnDays,\n      archived: project.archived,\n      status: project.status\n    };\n  });\n\n  // [Agent Refactor] Update Cache & Repo\n  projectIndexCache = index;\n\n  const isIndexedDB = storageRepo && storageRepo.driver && storageRepo.driver.constructor && storageRepo.driver.constructor.name === 'IndexedDBAdapter';\n  if (storageRepo) {\n    // Async write to new storage\n    const prefixedIndex = buildProjectIndexForRepo(index);\n    storageRepo.setItem(PROJECT_INDEX_KEY, prefixedIndex).catch(e => console.warn('Failed to persist index to repo', e));\n  }\n\n  // Legacy writes only if NOT on IndexedDB\n  if (!isIndexedDB && safeStorage && typeof safeStorage.setItem === 'function') {\n    try {\n      safeStorage.setItem(PROJECT_INDEX_KEY, JSON.stringify(index));\n    } catch (e) {\n      console.warn('Failed to write project index', e);\n    }\n  }\n}\n\nfunction loadProject(name) {\n  const skipAutoBackupExpansion =\n    name !== undefined\n    && !(typeof name === 'string' && isAutoBackupStorageKey(name));\n\n  let { projects, changed, originalValue, lookup } = readAllProjectsFromStorage({\n    skipAutoBackupExpansion,\n  });\n  let resolvedKey = null;\n\n  if (name !== undefined) {\n    resolvedKey = resolveProjectKey(projects, lookup, name, { preferExact: true });\n    if (resolvedKey !== null && resolvedKey !== undefined) {\n      markProjectActivity(resolvedKey);\n    }\n  }\n\n  if (changed) {\n    const safeStorage = getSafeLocalStorage();\n    if (safeStorage) {\n      createStorageMigrationBackup(safeStorage, PROJECT_STORAGE_KEY, originalValue);\n    }\n    const mutableProjects = STORAGE_DEEP_CLONE(projects);\n    persistAllProjects(mutableProjects);\n    projects = mutableProjects;\n  }\n  if (name === undefined) {\n    markProjectCollectionActivity(projects);\n    return projects;\n  }\n  if (\n    resolvedKey !== null\n    && resolvedKey !== undefined\n    && Object.prototype.hasOwnProperty.call(projects, resolvedKey)\n  ) {\n    const project = projects[resolvedKey];\n    if (project && (!project.gearList || project.gearList === \"\")) {\n      const setups = loadSetups();\n      const setup = setups[resolvedKey];\n      if (setup) {\n        if (setup.gearList) {\n          project.gearList = setup.gearList;\n        }\n      }\n    }\n    return project;\n  }\n  return null;\n}\n\nfunction loadProjectMetadata() {\n  // 1. Try to load from optimized Index\n  const cachedIndex = readProjectIndex();\n  if (cachedIndex) {\n    return cachedIndex;\n  }\n\n  // 2. Fallback: Full Load (Slow)\n  // We also skip auto-backup expansion here to save memory/time\n  const loaded = readAllProjectsFromStorage({ forMutation: false, skipAutoBackupExpansion: true });\n  const result = {};\n\n  if (loaded && loaded.projects) {\n    const keys = Object.keys(loaded.projects);\n    for (let i = 0; i < keys.length; i++) {\n      const key = keys[i];\n\n      // Skip auto-backups if they leaked through\n      if (isAutoBackupStorageKey(key)) continue;\n\n      const project = loaded.projects[key];\n      if (!project) continue;\n\n      // Optimized metadata extraction\n      result[key] = {\n        color: project.color,\n        icon: project.icon,\n        lastModified: project.lastModified,\n        prepDays: project.prepDays,\n        shootingDays: project.shootingDays,\n        returnDays: project.returnDays,\n        archived: project.archived,\n        status: project.status\n      };\n    }\n\n    // 3. Self-Heal: Create the index for next time\n    const safeStorage = getSafeLocalStorage();\n    if (safeStorage) {\n      try {\n        updateProjectIndex(loaded.projects, safeStorage);\n      } catch (e) {\n        void e;\n      }\n    }\n  }\n  return result;\n}\n\nfunction sanitizeProjectNameForBackup(name) {\n  if (typeof name !== 'string') {\n    return '';\n  }\n  const collapsed = name.replace(/\\s+/g, ' ').trim();\n  if (!collapsed) {\n    return '';\n  }\n  if (collapsed.length <= 120) {\n    return collapsed;\n  }\n  return collapsed.slice(0, 120);\n}\n\nfunction formatAutoBackupTimestamp(date) {\n  const pad = (value) => String(value).padStart(2, '0');\n  return [\n    date.getFullYear(),\n    pad(date.getMonth() + 1),\n    pad(date.getDate()),\n    pad(date.getHours()),\n    pad(date.getMinutes()),\n    pad(date.getSeconds()),\n  ].join('-');\n}\n\nfunction generateDeletionBackupMetadata(projectName, projects) {\n  const now = new Date();\n  const timestamp = formatAutoBackupTimestamp(now);\n  const sanitizedName = sanitizeProjectNameForBackup(projectName);\n  const baseName = sanitizedName\n    ? `${STORAGE_AUTO_BACKUP_DELETION_PREFIX}${timestamp}-${sanitizedName}`\n    : `${STORAGE_AUTO_BACKUP_DELETION_PREFIX}${timestamp}`;\n  const usedNames = new Set(Object.keys(projects));\n  if (!usedNames.has(baseName)) {\n    return { name: baseName };\n  }\n  let suffix = 2;\n  let candidate = `${baseName}-${suffix}`;\n  while (usedNames.has(candidate)) {\n    suffix += 1;\n    candidate = `${baseName}-${suffix}`;\n  }\n  return { name: candidate };\n}\n\nfunction cloneProjectEntryForBackup(entry) {\n  if (entry === undefined) {\n    return undefined;\n  }\n  if (entry === null || typeof entry !== 'object') {\n    return entry;\n  }\n  try {\n    const cloned = STORAGE_DEEP_CLONE(entry);\n    const normalized = normalizeLegacyLongGopStructure(cloned);\n    return normalized !== cloned ? normalized : cloned;\n  } catch (error) {\n    console.warn('Unable to deep clone project for backup', error);\n    const fallback = { ...entry };\n    const normalized = normalizeLegacyLongGopStructure(fallback);\n    return normalized !== fallback ? normalized : fallback;\n  }\n}\n\nfunction maybeCreateProjectDeletionBackup(projects, key) {\n  if (!projects || !Object.prototype.hasOwnProperty.call(projects, key)) {\n    return { status: 'missing' };\n  }\n  if (typeof key === 'string' && key.startsWith(STORAGE_AUTO_BACKUP_NAME_PREFIX)) {\n    return { status: 'skipped' };\n  }\n  const entry = projects[key];\n  if (entry === undefined) {\n    return { status: 'missing' };\n  }\n  const { name: backupName } = generateDeletionBackupMetadata(key, projects);\n  if (!backupName) {\n    return { status: 'failed' };\n  }\n  const cloned = cloneProjectEntryForBackup(entry);\n  if (cloned === undefined) {\n    if (typeof console !== 'undefined' && typeof console.warn === 'function') {\n      console.warn(\n        `Skipping deletion backup for project \"${key}\" because no stored data was available during backup creation.`,\n      );\n    }\n    return { status: 'missing' };\n  }\n  projects[backupName] = cloned;\n  return { status: 'created', backupName };\n}\n\nfunction createProjectDeletionBackup(name) {\n  const { projects, changed, originalValue, lookup } = readAllProjectsFromStorage({ forMutation: true });\n  if (!projects || typeof projects !== 'object') {\n    return { status: 'invalid' };\n  }\n\n  const resolvedKey = resolveProjectKey(projects, lookup, name, { preferExact: true });\n  const normalizedName = normalizeProjectStorageKey(name);\n  const key =\n    resolvedKey !== null && resolvedKey !== undefined\n      ? resolvedKey\n      : normalizedName;\n\n  if (!Object.prototype.hasOwnProperty.call(projects, key)) {\n    return { status: 'missing' };\n  }\n\n  const backupOutcome = maybeCreateProjectDeletionBackup(projects, key);\n  if (backupOutcome.status !== 'created') {\n    return backupOutcome;\n  }\n\n  if (changed) {\n    const safeStorage = getSafeLocalStorage();\n    if (safeStorage) {\n      createStorageMigrationBackup(safeStorage, PROJECT_STORAGE_KEY, originalValue);\n    }\n  }\n\n  markProjectActivity(backupOutcome.backupName);\n  persistAllProjects(projects);\n  return backupOutcome;\n}\n\nfunction generateOverwriteBackupMetadata(projectName, projects) {\n  const timestamp = formatAutoBackupTimestamp(new Date());\n  const sanitizedName = sanitizeProjectNameForBackup(projectName);\n  const baseName = sanitizedName\n    ? `${STORAGE_AUTO_BACKUP_NAME_PREFIX}${timestamp}-${sanitizedName}`\n    : `${STORAGE_AUTO_BACKUP_NAME_PREFIX}${timestamp}`;\n  const usedNames = new Set(Object.keys(projects));\n  if (!usedNames.has(baseName)) {\n    return { name: baseName };\n  }\n  let suffix = 2;\n  let candidate = `${baseName}-${suffix}`;\n  while (usedNames.has(candidate)) {\n    suffix += 1;\n    candidate = `${baseName}-${suffix}`;\n  }\n  return { name: candidate };\n}\n\nfunction maybeCreateProjectOverwriteBackup(projects, key) {\n  if (!isPlainObject(projects) || typeof key !== 'string') {\n    return { status: 'invalid' };\n  }\n  if (!Object.prototype.hasOwnProperty.call(projects, key)) {\n    return { status: 'missing' };\n  }\n  if (\n    key.startsWith(STORAGE_AUTO_BACKUP_NAME_PREFIX)\n    || key.startsWith(STORAGE_AUTO_BACKUP_DELETION_PREFIX)\n  ) {\n    return { status: 'skipped' };\n  }\n\n  const backupSource = cloneProjectEntryForBackup(projects[key]);\n  if (backupSource === undefined) {\n    return { status: 'failed' };\n  }\n\n  const { name: backupName } = generateOverwriteBackupMetadata(key, projects);\n  if (!backupName) {\n    return { status: 'failed' };\n  }\n\n  projects[backupName] = backupSource;\n  return { status: 'created', backupName };\n}\n\n/**\n * Safe Project Persistence\n *\n * This function implements a robust \"safe save\" strategy to prevent data loss:\n * 1. NORMALIZATION: Ensures the project structure is valid and standardizes properties (e.g. trimming strings).\n * 2. MIGRATION BACKUP: If the storage snapshot has changed since the last read (detected via 'changed' flag),\n *    we create a safety backup of the PREVIOUS state before overwriting it. This protects against race conditions\n *    where two tabs might try to save, preserving the first tab's work in a backup file.\n * 3. OVERWRITE BACKUP: Before overwriting an existing project with the same name, we verify content diffs.\n *    If the content differs, we create a specific overwrite backup (e.g. \"MyProject-backup\").\n * 4. ATOMIC COMMIT: We finally write the new project data.\n *\n * @param {string} name - The intended name for the project.\n * @param {object} project - The project data object.\n * @param {object} [options] - Save options (e.g. skipOverwriteBackup, skipCompression).\n */\nfunction saveProject(name, project, options = {}) {\n  if (!isPlainObject(project)) return;\n\n  const normalized = normalizeProject(project);\n  if (!normalized) {\n    if (typeof console !== 'undefined' && typeof console.warn === 'function') {\n      console.warn(\n        `Skipped saving project \"${name || ''}\" because the payload could not be normalised.`,\n      );\n    }\n    return;\n  }\n  const skipOverwriteBackup = Boolean(options && options.skipOverwriteBackup);\n  const skipCompression = Boolean(options && options.skipCompression);\n\n  const requestedKey = typeof name === 'string' ? name : '';\n  const preferredKey = normalizeProjectStorageKey(requestedKey);\n\n  // Initial check: if what we are about to write will overwrite something that has changed\n  // on disk (via another tab), we must safeguard that data first.\n  const initialSnapshot = readAllProjectsFromStorage({ forMutation: true });\n  const initialProjects = isPlainObject(initialSnapshot.projects) ? initialSnapshot.projects : {};\n  if (initialSnapshot.changed) {\n    const safeStorage = getSafeLocalStorage();\n    if (safeStorage) {\n      // [SAFETY] Create a migration backup to preserve the state before this write.\n      createStorageMigrationBackup(safeStorage, PROJECT_STORAGE_KEY, initialSnapshot.originalValue);\n    }\n  }\n\n  const initialResolvedKey = resolveProjectKey(\n    initialProjects,\n    initialSnapshot.lookup,\n    requestedKey,\n    { preferExact: true },\n  );\n  const initialExistingEntry =\n    initialResolvedKey !== null\n      && initialResolvedKey !== undefined\n      && Object.prototype.hasOwnProperty.call(initialProjects, initialResolvedKey)\n      ? initialProjects[initialResolvedKey]\n      : null;\n  const initialExistingSignature = initialExistingEntry\n    ? createStableValueSignature(initialExistingEntry)\n    : null;\n\n  /*\n   * We re-read the projects after the initial snapshot because another tab can write to storage\n   * between our first check and this save. An offline-first app must treat that window as unsafe\n   * for user data, so we verify the latest state before touching anything.\n   *\n   * This second read mitigates cross-tab race conditions by ensuring we evaluate the most recent\n   * project list and signatures. It lets us detect late-arriving changes and take backup paths\n   * instead of overwriting or deleting user data from a different session.\n   *\n   * The resolveProjectKey lookup compares the requested name against the latest index so we know\n   * whether it is safe to overwrite, or if we should write to a preferred key and delete a rename.\n   * Signature comparisons then confirm that any overwrite or rename cleanup only happens when the\n   * entry we saw initially still matches the stored data, keeping backups intact and preventing\n   * data loss across tabs.\n   */\n\n  const latestSnapshot = readAllProjectsFromStorage({ forMutation: true });\n  const projects = isPlainObject(latestSnapshot.projects) ? latestSnapshot.projects : {};\n  if (latestSnapshot.changed) {\n    const safeStorage = getSafeLocalStorage();\n    if (safeStorage) {\n      // [SAFETY] Double-check safeguards if a race condition happened between the checks.\n      createStorageMigrationBackup(safeStorage, PROJECT_STORAGE_KEY, latestSnapshot.originalValue);\n    }\n  }\n\n  const resolvedKey = resolveProjectKey(projects, latestSnapshot.lookup, requestedKey, { preferExact: true });\n\n  let storageKey = resolvedKey;\n  let renamedFromKey = null;\n  if (\n    preferredKey\n    && preferredKey !== resolvedKey\n    && !Object.prototype.hasOwnProperty.call(projects, preferredKey)\n  ) {\n    storageKey = preferredKey;\n    renamedFromKey = resolvedKey;\n  }\n\n  if (storageKey === null || storageKey === undefined) {\n    storageKey = preferredKey;\n  }\n\n  if (!storageKey && storageKey !== '') {\n    storageKey = '';\n  }\n\n  const existingKey = renamedFromKey !== null && renamedFromKey !== undefined\n    ? renamedFromKey\n    : storageKey;\n  const hasExistingEntry =\n    existingKey !== null\n    && existingKey !== undefined\n    && Object.prototype.hasOwnProperty.call(projects, existingKey);\n  const existingEntry = hasExistingEntry ? projects[existingKey] : null;\n\n  if (hasExistingEntry && !skipOverwriteBackup) {\n    const existingSignature = createStableValueSignature(existingEntry);\n    const nextSignature = createStableValueSignature(normalized);\n    if (existingSignature !== nextSignature) {\n      // [SAFETY] Overwrite Protection: If we are modifying an existing project, create a specific backup.\n      const backupOutcome = maybeCreateProjectOverwriteBackup(projects, existingKey);\n      if (backupOutcome.status === 'failed') {\n        console.warn(\n          `Automatic backup before overwriting project \"${existingKey}\" failed. Proceeding with save.`,\n        );\n      }\n    }\n  }\n\n  if (\n    renamedFromKey !== null\n    && renamedFromKey !== undefined\n    && renamedFromKey !== storageKey\n  ) {\n    // Logic to safely handle renames by deleting the old key only if it hasn't changed.\n    let shouldDelete = Boolean(initialExistingSignature);\n    if (Object.prototype.hasOwnProperty.call(projects, renamedFromKey)) {\n      if (initialExistingSignature) {\n        const latestSignature = createStableValueSignature(projects[renamedFromKey]);\n        if (latestSignature !== initialExistingSignature) {\n          shouldDelete = false;\n        }\n      } else {\n        shouldDelete = false;\n      }\n    } else {\n      shouldDelete = false;\n    }\n\n    if (shouldDelete) {\n      delete projects[renamedFromKey];\n      removeProjectActivity(renamedFromKey);\n    } else if (typeof console !== 'undefined' && typeof console.warn === 'function') {\n      console.warn(\n        `Skipped removing \"${renamedFromKey}\" while saving \"${storageKey}\" because the original entry changed in another tab.`,\n      );\n    }\n  }\n\n  // Explicit rename handling from options (e.g. from handleSaveSetupClick)\n  const manualRenamedFrom = options && options.renamedFrom;\n  if (manualRenamedFrom && manualRenamedFrom !== storageKey) {\n    const resolvedOld = resolveProjectKey(projects, latestSnapshot.lookup, manualRenamedFrom, { preferExact: true });\n    if (resolvedOld && Object.prototype.hasOwnProperty.call(projects, resolvedOld)) {\n      delete projects[resolvedOld];\n      removeProjectActivity(resolvedOld);\n    }\n  }\n\n  const finalKey = storageKey || '';\n  projects[finalKey] = normalized;\n  markProjectActivity(finalKey);\n\n  // Prune within the projects object first (handling auto-backup counts)\n  enforceAutoBackupLimits(projects);\n\n  // [Agent Refactor] Dual-Write to StorageRepository & Memory Cache\n  // Keep the offline data sources aligned by writing both the durable repo (IndexedDB-backed)\n  // and the in-memory cache used for synchronous reads. This prevents drift between tabs/sessions\n  // and ensures autosave, backup, and restore flows always have the latest snapshot available.\n  if (storageRepo) {\n    storageRepo.saveProject(finalKey, normalized).catch(err => console.warn('[saveProject] Repo write failed', err));\n  }\n  if (isProjectCacheHydrated) {\n    projectMemoryCache[finalKey] = normalized;\n  }\n\n  // Instead of calling persistAllProjects(projects), which would trigger a massive monolithic rewrite,\n  // we now use sharded persistence for the specific project being saved.\n  // [Agent Refactor] Skip legacy LocalStorage write if we are using IndexedDB to avoid quota errors.\n  // When IndexedDB is active, we avoid a redundant monolithic LocalStorage write that risks quota\n  // exhaustion; we still preserve backups through the repository and the sharded persistence path.\n  // Shard persistence is preferred because it limits blast radius and avoids monolithic write failures.\n  const isIndexedDB = storageRepo && storageRepo.driver && storageRepo.driver.constructor && storageRepo.driver.constructor.name === 'IndexedDBAdapter';\n  let shardSuccess = true;\n\n  if (!isIndexedDB || !isProjectCacheHydrated) {\n    shardSuccess = persistProjectShard(finalKey, normalized, { skipCompression });\n  }\n\n  if (shardSuccess) {\n    const safeStorage = getSafeLocalStorage();\n    // Clean up shards that are no longer in the projects map (renames or pruned backups)\n    pruneOrphanProjectShards(safeStorage, projects);\n    // Ensure migration from monolithic is finalized\n    cleanupMonolithicProjectStorage(safeStorage);\n\n    // Trigger cross-tab invalidation.\n    invalidateProjectReadCache();\n    if (lifecycleChannel) {\n      try {\n        lifecycleChannel.postMessage('project-shards-changed');\n      } catch (e) {\n        void e;\n      }\n    }\n    bumpProjectStorageRevision(safeStorage);\n  } else {\n    // Fallback for extreme cases (storage issues), though persistAllProjects would likely fail too.\n    persistAllProjects(projects, { skipCompression });\n  }\n}\n\nfunction deleteProject(name) {\n  if (name === undefined) {\n    // ... (Factory reset logic) ...\n    const storagesToPrune = [getSafeLocalStorage()];\n    if (typeof localStorage !== 'undefined' && storagesToPrune.indexOf(localStorage) === -1) {\n      storagesToPrune.push(localStorage);\n    }\n\n    storagesToPrune.forEach((storage) => {\n      // Force delete primary and backup keys directly first to ensure factory reset reliability\n      if (storage && typeof storage.removeItem === 'function') {\n        try {\n          storage.removeItem(PROJECT_STORAGE_KEY);\n          const backupSuffix = typeof STORAGE_BACKUP_SUFFIX === 'string' ? STORAGE_BACKUP_SUFFIX : '__backup';\n          storage.removeItem(`${PROJECT_STORAGE_KEY}${backupSuffix}`);\n          // Also remove hardcoded potential legacy/default backup key just in case\n          storage.removeItem('cameraPowerPlanner_project__backup');\n        } catch (e) {\n          console.warn(`[FactoryReset] Failed to force delete project keys`, e);\n        }\n      }\n\n      deleteFromStorage(\n        storage,\n        PROJECT_STORAGE_KEY,\n        \"Error deleting project from storage:\",\n      );\n\n      if (storage && typeof storage.length === 'number') {\n        const shardKeys = [];\n        for (let i = 0; i < storage.length; i++) {\n          const key = storage.key(i);\n          if (key && key.startsWith(PROJECT_SHARD_PREFIX)) {\n            shardKeys.push(key);\n          }\n        }\n        shardKeys.forEach((key) => deleteFromStorage(\n          storage,\n          key,\n          \"Error deleting project shard from storage:\",\n        ));\n      }\n    });\n\n    // [Refactor] Clear IndexedDB and OPFS Data Vault\n    // This ensures a true Factory Reset across all storage layers.\n    try {\n      if (storageRepo) {\n        storageRepo.clear().catch(e => console.warn('[FactoryReset] Failed to clear StorageRepository', e));\n      }\n      if (dataVault) {\n        dataVault.clear().catch(e => console.warn('[FactoryReset] Failed to clear DataVault', e));\n      }\n      if (userContext) {\n        userContext.reset();\n      }\n    } catch (e) {\n      console.warn('[FactoryReset] Error clearing modern storage', e);\n    }\n    // ... (Clear UI caches and notify tabs) ...\n    if (typeof clearUiCacheStorageEntries === 'function') {\n      try {\n        clearUiCacheStorageEntries();\n      } catch (uiCacheError) {\n        console.warn('Failed to clear UI cache during project deletion', uiCacheError);\n      }\n    }\n\n    invalidateProjectReadCache();\n    if (lifecycleChannel) { try { lifecycleChannel.postMessage('project-shards-changed'); } catch (e) { void e; } }\n    if (projectActivityTimestamps && typeof projectActivityTimestamps.clear === 'function') {\n      projectActivityTimestamps.clear();\n    }\n    const currentSafeStorage = getSafeLocalStorage();\n    if (currentSafeStorage) {\n      bumpProjectStorageRevision(currentSafeStorage);\n    }\n    return;\n  }\n\n  const { projects, changed, originalValue, lookup } = readAllProjectsFromStorage({ forMutation: true });\n  if (changed) {\n    const safeStorage = getSafeLocalStorage();\n    if (safeStorage) {\n      createStorageMigrationBackup(safeStorage, PROJECT_STORAGE_KEY, originalValue);\n    }\n  }\n  const resolvedKey = resolveProjectKey(projects, lookup, name, { preferExact: true });\n  const key =\n    resolvedKey !== null && resolvedKey !== undefined\n      ? resolvedKey\n      : normalizeProjectStorageKey(name);\n\n  if (!Object.prototype.hasOwnProperty.call(projects, key)) {\n    // If key not found in project map, try deleting potential orphan shard directly\n    const potentialShardKey = PROJECT_SHARD_PREFIX + normalizeProjectStorageKey(name);\n    const safeStorage = getSafeLocalStorage();\n    if (safeStorage) {\n      deleteFromStorage(safeStorage, potentialShardKey, \"Error deleting orphan project shard:\");\n    }\n    return;\n  }\n\n  // [SAFETY] Create a \"Deletion Backup\" (undoable operation support)\n  const backupOutcome = maybeCreateProjectDeletionBackup(projects, key);\n  if (backupOutcome.status === 'failed') {\n    console.warn(`Automatic backup before deleting project \"${key}\" failed. Deletion aborted.`);\n    alertStorageError();\n    return;\n  }\n  const shardKey = PROJECT_SHARD_PREFIX + normalizeProjectStorageKey(key);\n  const safeStorage = getSafeLocalStorage();\n  // [Agent Refactor] Skip legacy LocalStorage delete if we are using IndexedDB\n  const isIndexedDB = storageRepo && storageRepo.driver && storageRepo.driver.constructor && storageRepo.driver.constructor.name === 'IndexedDBAdapter';\n\n  if (safeStorage && !isIndexedDB) {\n    deleteFromStorage(safeStorage, shardKey, \"Error deleting project shard:\");\n  }\n  // Update Memory Cache\n  if (isProjectCacheHydrated) {\n    delete projectMemoryCache[key];\n  }\n\n  // Update StorageRepository (Async)\n  // We fire and forget the delete, but UI updates immediately via cache/events\n  if (storageRepo && typeof storageRepo.removeProject === 'function') {\n    storageRepo.removeProject(key).catch(e => console.warn('Failed to delete from repo', e));\n  } else if (storageRepo) {\n    storageRepo.removeItem(key).catch(e => console.warn('Failed to delete from repo', e));\n  }\n\n  delete projects[key];\n  removeProjectActivity(key);\n  // persistAllProjects(projects); // Legacy persistence\n\n  // Dispatch events\n  invalidateProjectReadCache();\n  if (lifecycleChannel) { try { lifecycleChannel.postMessage('project-shards-changed'); } catch (e) { void e; } }\n}\n\nfunction renameProject(oldName, newName) {\n  if (!oldName || !newName) return null;\n  // Use read logic to get current state (memory or storage)\n  const { projects } = readAllProjectsFromStorage({ forMutation: true });\n\n  // Resolve keys\n  const resolvedKey = resolveProjectKey(projects, null, oldName, { preferExact: true });\n  if (!resolvedKey || !projects[resolvedKey]) {\n    return null;\n  }\n\n  const targetName = newName.trim();\n  if (!targetName || targetName === resolvedKey) {\n    return resolvedKey;\n  }\n\n  const projectData = projects[resolvedKey];\n  projectData.name = targetName; // Update internal name\n  if (!isPlainObject(projectData.projectInfo)) {\n    projectData.projectInfo = {};\n  }\n  projectData.projectInfo.projectName = targetName;\n\n  // Update Memory Cache\n  if (isProjectCacheHydrated) {\n    delete projectMemoryCache[resolvedKey];\n    projectMemoryCache[targetName] = projectData;\n  } else {\n    // Legacy fallback: modify local map passed from readAllProjects\n    delete projects[resolvedKey];\n    projects[targetName] = projectData;\n  }\n\n  // Update Storage (Async)\n  if (storageRepo && typeof storageRepo.removeProject === 'function') {\n    storageRepo.removeProject(resolvedKey).catch(e => console.warn('Failed to delete old project key', e));\n  } else if (storageRepo) {\n    storageRepo.removeItem(resolvedKey).catch(e => console.warn('Failed to delete old project key', e));\n  }\n  // We use the new saveProject which handles repo save + cache update redundancy\n  saveProject(targetName, projectData);\n\n  // Dispatch events\n  invalidateProjectReadCache();\n  if (lifecycleChannel) { try { lifecycleChannel.postMessage('project-shards-changed'); } catch (e) { void e; } }\n\n  return targetName;\n}\n\nfunction createProjectImporter() {\n  const { projects, changed, originalValue } = readAllProjectsFromStorage({ forMutation: true });\n  if (changed) {\n    const safeStorage = getSafeLocalStorage();\n    if (safeStorage) {\n      createStorageMigrationBackup(safeStorage, PROJECT_STORAGE_KEY, originalValue);\n    }\n  }\n  const usedNames = new Set(Object.keys(projects));\n  const normalizedNames = new Set(\n    [...usedNames].map((name) => name.trim().toLowerCase()),\n  );\n  const defaultName = \"Imported project\";\n\n  return (rawName, project, fallbackName = defaultName) => {\n    const normalizedProject = normalizeProject(project);\n    if (!normalizedProject) return;\n\n    const originalHasGenerationFlag =\n      project\n      && typeof project === \"object\"\n      && Object.prototype.hasOwnProperty.call(project, \"gearListAndProjectRequirementsGenerated\")\n      && typeof project.gearListAndProjectRequirementsGenerated === \"boolean\";\n\n    if (\n      !originalHasGenerationFlag\n      && typeof normalizedProject.gearListAndProjectRequirementsGenerated !== 'boolean'\n    ) {\n      normalizedProject.gearListAndProjectRequirementsGenerated = false;\n    }\n\n    const candidates = [];\n    if (typeof rawName === \"string\") {\n      candidates.push(rawName.trim());\n    }\n    if (isPlainObject(project)) {\n      if (typeof project.name === \"string\") {\n        candidates.push(project.name.trim());\n      }\n      const info = project.projectInfo;\n      if (isPlainObject(info) && typeof info.projectName === \"string\") {\n        candidates.push(info.projectName.trim());\n      }\n    }\n\n\n    const fallback = typeof fallbackName === \"string\" && fallbackName.trim()\n      ? fallbackName.trim()\n      : defaultName;\n\n    const baseName = candidates.length > 0 ? candidates[0] : fallback;\n    const normalizedBase = typeof baseName === \"string\" ? baseName.trim().toLowerCase() : \"\";\n    const uniqueName = normalizedNames.has(normalizedBase)\n      ? generateImportedProjectName(baseName, usedNames, normalizedNames)\n      : generateUniqueName(baseName, usedNames, normalizedNames);\n    saveProject(uniqueName, normalizedProject, { skipCompression: false });\n    usedNames.add(uniqueName);\n    normalizedNames.add(uniqueName.trim().toLowerCase());\n  };\n}\n\nfunction tryParseJSONLike(value) {\n  if (typeof value !== \"string\") {\n    return { success: false, parsed: null };\n  }\n\n  const trimmed = value.trim();\n  if (!trimmed) {\n    return { success: false, parsed: null };\n  }\n\n  const firstChar = trimmed[0];\n  const lastChar = trimmed[trimmed.length - 1];\n  let expectedClosing = null;\n  if (firstChar === \"{\") {\n    expectedClosing = \"}\";\n  } else if (firstChar === \"[\") {\n    expectedClosing = \"]\";\n  } else if (firstChar === \"\\\"\") {\n    expectedClosing = \"\\\"\";\n  }\n\n  if (!expectedClosing || lastChar !== expectedClosing) {\n    return { success: false, parsed: null };\n  }\n\n  try {\n    return { success: true, parsed: JSON.parse(trimmed) };\n  } catch (error) {\n    void error;\n    return { success: false, parsed: null };\n  }\n}\n\nfunction importProjectCollection(collection, ensureImporter, fallbackLabel = \"Imported project\") {\n  if (typeof collection === \"string\") {\n    const parsed = tryParseJSONLike(collection);\n    if (parsed.success) {\n      return importProjectCollection(parsed.parsed, ensureImporter, fallbackLabel);\n    }\n\n    const importProject = ensureImporter();\n    importProject(fallbackLabel, collection, fallbackLabel);\n    return true;\n  }\n\n  if (isMapLike(collection)) {\n    const converted = convertMapLikeToObject(collection);\n    if (converted) {\n      return importProjectCollection(Object.entries(converted), ensureImporter, fallbackLabel);\n    }\n    return false;\n  }\n\n  if (Array.isArray(collection)) {\n    const entries = collection\n      .map((proj) => {\n        if (proj === null || proj === undefined) {\n          return null;\n        }\n        if (Array.isArray(proj) && proj.length >= 2) {\n          return { name: proj[0], project: proj[1] };\n        }\n        if (isPlainObject(proj) && typeof proj.name === \"string\") {\n          const projectData = Object.prototype.hasOwnProperty.call(proj, \"project\")\n            ? proj.project\n            : proj;\n          // Preserve named project wrappers from legacy exports without dropping the actual project payload.\n          return { name: proj.name, project: projectData };\n        }\n        return { name: '', project: proj };\n      })\n      .filter(Boolean);\n\n    if (!entries.length) {\n      return true;\n    }\n\n    const importProject = ensureImporter();\n    let count = 0;\n    entries.forEach(({ name, project }) => {\n      if (project === null || project === undefined) {\n        return;\n      }\n      count += 1;\n      let normalizedName = '';\n      if (typeof name === 'string') {\n        normalizedName = name;\n      } else if (typeof name === 'number' || typeof name === 'boolean' || typeof name === 'bigint') {\n        normalizedName = String(name);\n      } else if (typeof name === 'symbol') {\n        normalizedName = name.description || name.toString();\n      }\n      importProject(normalizedName, project, `${fallbackLabel} ${count}`);\n    });\n    return true;\n  }\n\n  if (isPlainObject(collection)) {\n    const importProject = ensureImporter();\n    Object.entries(collection).forEach(([name, proj]) => {\n      const normalizedName = typeof name === 'string' ? name : convertMapLikeKey(name);\n      importProject(\n        typeof normalizedName === 'string' && normalizedName\n          ? normalizedName\n          : fallbackLabel,\n        proj,\n        fallbackLabel,\n      );\n    });\n    return true;\n  }\n\n  return false;\n}\n\nfunction collectLegacyProjectCollections(container) {\n  if (!container || typeof container !== \"object\") {\n    return [];\n  }\n\n  const collections = [];\n  const addCollection = (value) => {\n    if (value === null || value === undefined) {\n      return;\n    }\n    collections.push(value);\n  };\n\n  const legacyKeys = [\n    \"projectData\",\n    \"projectCollection\",\n    \"projectEntries\",\n    \"legacyProjects\",\n    \"legacyProjectData\",\n  ];\n\n  legacyKeys.forEach((key) => {\n    if (Object.prototype.hasOwnProperty.call(container, key)) {\n      addCollection(container[key]);\n    }\n  });\n\n  if (isPlainObject(container.data)) {\n    if (Object.prototype.hasOwnProperty.call(container.data, \"project\")) {\n      addCollection(container.data.project);\n    }\n    if (Object.prototype.hasOwnProperty.call(container.data, \"projects\")) {\n      addCollection(container.data.projects);\n    }\n  }\n\n  const plannerData = container.plannerData;\n  if (Array.isArray(plannerData)) {\n    plannerData.forEach((entry) => {\n      if (Array.isArray(entry) && entry.length >= 2) {\n        const key = entry[0];\n        if (typeof key === \"string\" && key.toLowerCase().includes(\"project\")) {\n          addCollection(entry[1]);\n        }\n        return;\n      }\n\n      if (!entry || typeof entry !== \"object\") {\n        return;\n      }\n\n      const key = typeof entry.key === \"string\"\n        ? entry.key\n        : typeof entry.name === \"string\"\n          ? entry.name\n          : typeof entry.id === \"string\"\n            ? entry.id\n            : typeof entry.section === \"string\"\n              ? entry.section\n              : null;\n\n      if (!key || !key.toLowerCase().includes(\"project\")) {\n        return;\n      }\n\n      const value = Object.prototype.hasOwnProperty.call(entry, \"value\")\n        ? entry.value\n        : Object.prototype.hasOwnProperty.call(entry, \"data\")\n          ? entry.data\n          : Object.prototype.hasOwnProperty.call(entry, \"project\")\n            ? entry.project\n            : Object.prototype.hasOwnProperty.call(entry, \"projects\")\n              ? entry.projects\n              : null;\n\n      if (value !== null && value !== undefined) {\n        addCollection(value);\n      }\n    });\n  }\n\n  return collections;\n}\n\n// --- Favorites Storage ---\nfunction loadFavorites() {\n  applyLegacyStorageMigrations();\n  const safeStorage = getSafeLocalStorage();\n  const parsed = loadJSONFromStorage(\n    safeStorage,\n    FAVORITES_STORAGE_KEY,\n    \"Error loading favorites from localStorage:\",\n    {},\n    { validate: (value) => value === null || isPlainObject(value) },\n  );\n  return isPlainObject(parsed) ? parsed : {};\n}\n\nfunction saveFavorites(favs) {\n  const safeStorage = getSafeLocalStorage();\n  if (favs === null || favs === undefined) {\n    deleteFromStorage(\n      safeStorage,\n      FAVORITES_STORAGE_KEY,\n      \"Error deleting favorites from localStorage:\",\n    );\n    return;\n  }\n\n  if (!isPlainObject(favs)) {\n    console.warn('Ignoring invalid favorites payload. Expected a plain object.');\n    return;\n  }\n\n  ensurePreWriteMigrationBackup(safeStorage, FAVORITES_STORAGE_KEY);\n  saveJSONToStorage(\n    safeStorage,\n    FAVORITES_STORAGE_KEY,\n    favs,\n    \"Error saving favorites to localStorage:\",\n  );\n}\n\nfunction resolveContactsModuleApi() {\n  if (CONTACTS_MODULE_API) {\n    return CONTACTS_MODULE_API;\n  }\n\n  if (!CONTACTS_MODULE_RESOLUTION_ATTEMPTED) {\n    CONTACTS_MODULE_RESOLUTION_ATTEMPTED = true;\n    if (contactsModuleImport) {\n      CONTACTS_MODULE_API = contactsModuleImport;\n    }\n  }\n\n  if (CONTACTS_MODULE_API) {\n    return CONTACTS_MODULE_API;\n  }\n\n  const scope = GLOBAL_SCOPE && typeof GLOBAL_SCOPE === 'object' ? GLOBAL_SCOPE : null;\n  if (scope && scope.cineFeaturesContacts && typeof scope.cineFeaturesContacts === 'object') {\n    CONTACTS_MODULE_API = scope.cineFeaturesContacts;\n    return CONTACTS_MODULE_API;\n  }\n\n  const moduleBase = scope && typeof scope.cineModuleBase === 'object' ? scope.cineModuleBase : null;\n  if (moduleBase && typeof moduleBase.resolveModule === 'function') {\n    try {\n      const resolved = moduleBase.resolveModule('cine.features.contacts', scope);\n      if (resolved && typeof resolved === 'object') {\n        CONTACTS_MODULE_API = resolved;\n        return CONTACTS_MODULE_API;\n      }\n    } catch (error) {\n      void error;\n    }\n  }\n\n  return CONTACTS_MODULE_API;\n}\n\nfunction fallbackSanitizeContactValue(value) {\n  if (typeof value === 'string') {\n    return value.trim();\n  }\n\n  if (typeof value === 'number') {\n    if (!Number.isFinite(value)) {\n      return '';\n    }\n    return String(value).trim();\n  }\n\n  if (typeof value === 'bigint') {\n    try {\n      return value.toString();\n    } catch (bigintError) {\n      void bigintError;\n    }\n    return '';\n  }\n\n  if (typeof value === 'boolean') {\n    return value ? 'true' : 'false';\n  }\n\n  if (value && typeof value === 'object') {\n    try {\n      const primitive = value.valueOf();\n      if (primitive !== value) {\n        return fallbackSanitizeContactValue(primitive);\n      }\n\n      if (typeof value.toString === 'function') {\n        const stringified = value.toString();\n        if (typeof stringified === 'string' && stringified && stringified !== '[object Object]') {\n          return stringified.trim();\n        }\n      }\n    } catch (coercionError) {\n      void coercionError;\n    }\n  }\n\n  return '';\n}\n\nfunction fallbackGenerateContactId(moduleApi) {\n  if (moduleApi && typeof moduleApi.generateContactId === 'function') {\n    try {\n      const generated = moduleApi.generateContactId();\n      if (typeof generated === 'string' && generated) {\n        return generated;\n      }\n    } catch (error) {\n      void error;\n    }\n  }\n  return `contact-${Date.now().toString(36)}-${Math.random().toString(36).slice(2, 8)}`;\n}\n\nfunction fallbackNormalizeContactEntry(entry, moduleApi) {\n  if (!entry || typeof entry !== 'object') {\n    return null;\n  }\n\n  const sanitize = fallbackSanitizeContactValue;\n  const id = sanitize(entry.id) || fallbackGenerateContactId(moduleApi);\n  const name = sanitize(entry.name);\n  const role = sanitize(entry.role);\n  const phone = sanitize(entry.phone);\n  const email = sanitize(entry.email);\n  const website = sanitize(entry.website || entry.url);\n  const notes = sanitize(entry.notes || entry.note || entry.text);\n  const avatarSource = typeof entry.avatar === 'string' ? entry.avatar.trim() : '';\n  const avatar = avatarSource && avatarSource.startsWith('data:') ? avatarSource : '';\n  const createdAt = Number.isFinite(entry.createdAt) ? entry.createdAt : Date.now();\n  const updatedAt = Number.isFinite(entry.updatedAt) ? entry.updatedAt : createdAt;\n\n  const normalized = { id, name, role, phone, email, website, notes, createdAt, updatedAt };\n  if (avatar) {\n    normalized.avatar = avatar;\n  }\n\n  return normalized;\n}\n\nfunction fallbackSortContacts(list) {\n  if (!Array.isArray(list)) {\n    return [];\n  }\n\n  const cloned = list\n    .filter((entry) => entry && typeof entry === 'object')\n    .map((entry) => ({ ...entry }));\n\n  cloned.sort((a, b) => {\n    const nameA = (a && a.name ? a.name : '').toLowerCase();\n    const nameB = (b && b.name ? b.name : '').toLowerCase();\n    if (nameA && nameB && nameA !== nameB) {\n      try {\n        return nameA.localeCompare(nameB);\n      } catch (error) {\n        void error;\n      }\n    }\n    if (nameA && !nameB) {\n      return -1;\n    }\n    if (!nameA && nameB) {\n      return 1;\n    }\n    const createdA = a && typeof a.createdAt === 'number' ? a.createdAt : 0;\n    const createdB = b && typeof b.createdAt === 'number' ? b.createdAt : 0;\n    return createdA - createdB;\n  });\n\n  return cloned;\n}\n\nfunction normalizeContactsList(entries) {\n  if (!Array.isArray(entries)) {\n    return [];\n  }\n\n  const moduleApi = resolveContactsModuleApi();\n\n  if (moduleApi && typeof moduleApi.sortContacts === 'function') {\n    try {\n      const sorted = moduleApi.sortContacts(entries);\n      if (Array.isArray(sorted)) {\n        return sorted.filter((entry) => entry && typeof entry === 'object');\n      }\n    } catch (error) {\n      if (typeof console !== 'undefined' && typeof console.warn === 'function') {\n        console.warn('Error normalizing contacts via module.', error);\n      }\n    }\n  }\n\n  const normalizer = moduleApi && typeof moduleApi.normalizeContactEntry === 'function'\n    ? moduleApi.normalizeContactEntry\n    : null;\n\n  const normalized = [];\n  for (let index = 0; index < entries.length; index += 1) {\n    const entry = entries[index];\n    if (!entry) {\n      continue;\n    }\n\n    let normalizedEntry = null;\n    if (normalizer) {\n      try {\n        normalizedEntry = normalizer(entry);\n      } catch (error) {\n        if (typeof console !== 'undefined' && typeof console.warn === 'function') {\n          console.warn('Error normalizing contact entry via module.', error);\n        }\n        normalizedEntry = null;\n      }\n    }\n\n    if (!normalizedEntry) {\n      normalizedEntry = fallbackNormalizeContactEntry(entry, moduleApi);\n    }\n\n    if (normalizedEntry && typeof normalizedEntry === 'object') {\n      normalized.push(normalizedEntry);\n    }\n  }\n\n  return fallbackSortContacts(normalized);\n}\n\nfunction loadContacts() {\n  applyLegacyStorageMigrations();\n  const safeStorage = getSafeLocalStorage();\n  const parsed = loadJSONFromStorage(\n    safeStorage,\n    CONTACTS_STORAGE_KEY,\n    'Error loading contacts from localStorage:',\n    [],\n    { validate: (value) => value === null || Array.isArray(value) },\n  );\n  if (!Array.isArray(parsed)) {\n    return [];\n  }\n  return normalizeContactsList(parsed);\n}\n\nfunction saveContacts(contacts) {\n  const safeStorage = getSafeLocalStorage();\n  if (contacts === null || contacts === undefined) {\n    deleteFromStorage(\n      safeStorage,\n      CONTACTS_STORAGE_KEY,\n      'Error deleting contacts from localStorage:',\n    );\n    return;\n  }\n\n  if (!Array.isArray(contacts)) {\n    console.warn('Ignoring invalid contacts payload. Expected an array.');\n    return;\n  }\n\n  const normalized = normalizeContactsList(contacts);\n  ensurePreWriteMigrationBackup(safeStorage, CONTACTS_STORAGE_KEY);\n  saveJSONToStorage(\n    safeStorage,\n    CONTACTS_STORAGE_KEY,\n    normalized,\n    'Error saving contacts to localStorage:',\n    {\n      disableCompression: false,\n      forceCompressionOnQuota: true,\n    },\n  );\n}\n\n\n\nfunction loadOwnGear() {\n  return gearRepo.getOwnGear();\n}\n\nfunction saveOwnGear(data) {\n  return gearRepo.saveOwnGear(data);\n}\n\nfunction normalizeUserProfileField(value) {\n  if (typeof value === 'string') {\n    return value.trim();\n  }\n\n  if (typeof value === 'number' && Number.isFinite(value)) {\n    return String(value);\n  }\n\n  if (typeof value === 'bigint') {\n    return value.toString();\n  }\n\n  if (value && typeof value === 'object') {\n    try {\n      const primitive = value.valueOf();\n      if (primitive !== value) {\n        return normalizeUserProfileField(primitive);\n      }\n\n      if (typeof value.toString === 'function') {\n        const stringified = value.toString();\n        if (typeof stringified === 'string' && stringified && stringified !== '[object Object]') {\n          return stringified.trim();\n        }\n      }\n    } catch (coercionError) {\n      void coercionError;\n    }\n  }\n\n  return '';\n}\n\nfunction normalizeUserProfile(entry) {\n  if (!entry || typeof entry !== 'object') {\n    return null;\n  }\n\n  const name = normalizeUserProfileField(entry.name);\n  const role = normalizeUserProfileField(entry.role);\n  const avatarSource = normalizeUserProfileField(entry.avatar);\n  const avatar = avatarSource && avatarSource.toLowerCase().startsWith('data:')\n    ? avatarSource\n    : '';\n  const phone = normalizeUserProfileField(entry.phone);\n  const email = normalizeUserProfileField(entry.email);\n\n  if (!name && !role && !avatar && !phone && !email) {\n    return { name: '', role: '', avatar: '', phone: '', email: '' };\n  }\n\n  return { name, role, avatar, phone, email };\n}\n\nfunction loadUserProfile() {\n  applyLegacyStorageMigrations();\n  const safeStorage = getSafeLocalStorage();\n  const parsed = loadJSONFromStorage(\n    safeStorage,\n    USER_PROFILE_STORAGE_KEY,\n    'Error loading user profile from localStorage:',\n    null,\n    { validate: (value) => value === null || isPlainObject(value) },\n  );\n  if (!isPlainObject(parsed)) {\n    return { name: '', role: '', avatar: '', phone: '', email: '' };\n  }\n  return normalizeUserProfile(parsed) || { name: '', role: '', avatar: '', phone: '', email: '' };\n}\n\nfunction saveUserProfile(profile) {\n  const safeStorage = getSafeLocalStorage();\n  if (profile === null || profile === undefined) {\n    deleteFromStorage(\n      safeStorage,\n      USER_PROFILE_STORAGE_KEY,\n      'Error deleting user profile from localStorage:',\n    );\n    return;\n  }\n\n  const normalized = normalizeUserProfile(profile) || { name: '', role: '', avatar: '', phone: '', email: '' };\n  if (!normalized.name && !normalized.role && !normalized.avatar && !normalized.phone && !normalized.email) {\n    deleteFromStorage(\n      safeStorage,\n      USER_PROFILE_STORAGE_KEY,\n      'Error deleting user profile from localStorage:',\n    );\n    return;\n  }\n\n  ensurePreWriteMigrationBackup(safeStorage, USER_PROFILE_STORAGE_KEY);\n  saveJSONToStorage(\n    safeStorage,\n    USER_PROFILE_STORAGE_KEY,\n    normalized,\n    'Error saving user profile to localStorage:',\n    {\n      disableCompression: false,\n      forceCompressionOnQuota: true,\n      enableCompressionSweep: false,\n    },\n  );\n}\n\n// --- User Feedback Storage ---\nfunction loadFeedback() {\n  applyLegacyStorageMigrations();\n  const safeStorage = getSafeLocalStorage();\n  const parsed = loadJSONFromStorage(\n    safeStorage,\n    FEEDBACK_STORAGE_KEY,\n    \"Error loading feedback from localStorage:\",\n    null,\n    { validate: (value) => value === null || isPlainObject(value) },\n  );\n  if (isPlainObject(parsed)) {\n    return parsed;\n  }\n  return {};\n}\n\nfunction saveFeedback(feedback) {\n  const safeStorage = getSafeLocalStorage();\n  if (feedback === null || feedback === undefined) {\n    deleteFromStorage(\n      safeStorage,\n      FEEDBACK_STORAGE_KEY,\n      \"Error deleting feedback from localStorage:\",\n    );\n    return;\n  }\n\n  if (!isPlainObject(feedback)) {\n    console.warn('Ignoring invalid feedback payload. Expected a plain object.');\n    return;\n  }\n\n  ensurePreWriteMigrationBackup(safeStorage, FEEDBACK_STORAGE_KEY);\n  saveJSONToStorage(\n    safeStorage,\n    FEEDBACK_STORAGE_KEY,\n    feedback,\n    \"Error saving feedback to localStorage:\",\n  );\n}\n\nfunction normalizeFullBackupHistoryEntry(entry) {\n  if (!entry) {\n    return null;\n  }\n\n  if (typeof entry === 'string') {\n    const trimmed = entry.trim();\n    return trimmed ? { createdAt: trimmed } : null;\n  }\n\n  if (typeof entry === 'object') {\n    const createdAt = typeof entry.createdAt === 'string' && entry.createdAt.trim()\n      ? entry.createdAt.trim()\n      : typeof entry.iso === 'string' && entry.iso.trim()\n        ? entry.iso.trim()\n        : typeof entry.timestamp === 'string' && entry.timestamp.trim()\n          ? entry.timestamp.trim()\n          : null;\n    if (!createdAt) {\n      return null;\n    }\n    const normalized = { createdAt };\n    if (typeof entry.fileName === 'string' && entry.fileName.trim()) {\n      normalized.fileName = entry.fileName.trim();\n    } else if (typeof entry.name === 'string' && entry.name.trim()) {\n      normalized.fileName = entry.name.trim();\n    }\n    return normalized;\n  }\n\n  return null;\n}\n\nfunction loadFullBackupHistory(forceRefresh = false) {\n  // [Migration] Use cache if available (hydrated from storageRepo)\n  if (!forceRefresh && fullBackupHistoryCache !== null) {\n    const cached = fullBackupHistoryCache;\n    if (Array.isArray(cached)) {\n      return cached.map(normalizeFullBackupHistoryEntry).filter(Boolean);\n    }\n  }\n\n  // Fallback to legacy localStorage for first load or if cache not yet hydrated\n  applyLegacyStorageMigrations();\n  const safeStorage = getSafeLocalStorage();\n  const parsed = loadJSONFromStorage(\n    safeStorage,\n    FULL_BACKUP_HISTORY_STORAGE_KEY,\n    \"Error loading full backup history from localStorage:\",\n    [],\n    { validate: (value) => value === null || Array.isArray(value) },\n  );\n  if (!Array.isArray(parsed)) {\n    return [];\n  }\n  const normalized = parsed.map(normalizeFullBackupHistoryEntry).filter(Boolean);\n\n  // Hydrate cache for future reads\n  fullBackupHistoryCache = normalized;\n\n  // Async persist to new storage system (fire-and-forget migration)\n  storageRepo.setItem(FULL_BACKUP_HISTORY_STORAGE_KEY, normalized).catch(err => {\n    console.warn('[storage.js] Failed to persist backup history to new storage:', err);\n  });\n\n  return normalized;\n}\n\nfunction saveFullBackupHistory(entries) {\n  const safeStorage = getSafeLocalStorage();\n\n  if (entries === null || entries === undefined) {\n    // Clear cache\n    fullBackupHistoryCache = [];\n\n    // Delete from legacy localStorage\n    deleteFromStorage(\n      safeStorage,\n      FULL_BACKUP_HISTORY_STORAGE_KEY,\n      \"Error deleting full backup history from localStorage:\",\n    );\n\n    // Delete from new storage (async, fire-and-forget)\n    storageRepo.removeItem(FULL_BACKUP_HISTORY_STORAGE_KEY).catch(err => {\n      console.warn('[storage.js] Failed to delete backup history from new storage:', err);\n    });\n    return;\n  }\n\n  if (!Array.isArray(entries)) {\n    console.warn('Ignoring invalid full backup history payload. Expected an array.');\n    return;\n  }\n\n  const safeEntries = entries\n    .map(normalizeFullBackupHistoryEntry)\n    .filter(Boolean);\n\n  if (!safeEntries.length) {\n    if (entries.length === 0) {\n      // Clear cache\n      fullBackupHistoryCache = [];\n\n      // Delete from legacy localStorage\n      deleteFromStorage(\n        safeStorage,\n        FULL_BACKUP_HISTORY_STORAGE_KEY,\n        \"Error deleting full backup history from localStorage:\",\n      );\n\n      // Delete from new storage (async, fire-and-forget)\n      storageRepo.removeItem(FULL_BACKUP_HISTORY_STORAGE_KEY).catch(err => {\n        console.warn('[storage.js] Failed to delete backup history from new storage:', err);\n      });\n    } else {\n      console.warn('Ignoring full backup history update because no valid entries were provided.');\n    }\n    return;\n  }\n\n  // Update in-memory cache first for immediate sync reads\n  fullBackupHistoryCache = safeEntries;\n\n  // Persist to legacy localStorage (sync)\n  ensurePreWriteMigrationBackup(safeStorage, FULL_BACKUP_HISTORY_STORAGE_KEY);\n  saveJSONToStorage(\n    safeStorage,\n    FULL_BACKUP_HISTORY_STORAGE_KEY,\n    safeEntries,\n    \"Error saving full backup history to localStorage:\",\n    {\n      disableCompression: false,\n      forceCompressionOnQuota: true,\n    },\n  );\n\n  // Persist to new storage system (async, fire-and-forget)\n  storageRepo.setItem(FULL_BACKUP_HISTORY_STORAGE_KEY, safeEntries).catch(err => {\n    console.warn('[storage.js] Failed to persist backup history to new storage:', err);\n  });\n}\n\nvar recordFullBackupHistoryEntry = entry => {\n  const normalized = normalizeFullBackupHistoryEntry(entry);\n  if (!normalized) {\n    return loadFullBackupHistory();\n  }\n  const history = loadFullBackupHistory();\n  history.push(normalized);\n  const trimmed = history.slice(-MAX_FULL_BACKUP_HISTORY_ENTRIES);\n  saveFullBackupHistory(trimmed);\n  return trimmed;\n};\n\nfunction normalizeImportedFullBackupHistory(value, visited, depth = 0) {\n  if (value === null || value === undefined) {\n    return [];\n  }\n\n  if (depth > 50) {\n    return [];\n  }\n\n  if (Array.isArray(value)) {\n    const results = [];\n    const count = value.length;\n    const seen = visited || new WeakSet();\n    if (seen.has(value)) {\n      return [];\n    }\n    seen.add(value);\n    for (let i = 0; i < count; i += 1) {\n      const item = value[i];\n      if (typeof item === 'object' && item !== null && seen.has(item)) {\n        continue;\n      }\n\n      if (Array.isArray(item)) {\n        const nested = normalizeImportedFullBackupHistory(item, seen, depth + 1);\n        if (nested && nested.length) {\n          for (let j = 0; j < nested.length; j += 1) {\n            results.push(nested[j]);\n          }\n        }\n      } else {\n        const entry = normalizeFullBackupHistoryEntry(item);\n        if (entry) {\n          results.push(entry);\n        }\n      }\n    }\n    return results;\n  }\n\n  const seen = visited || new WeakSet();\n  if (typeof value === 'object' && value !== null) {\n    if (seen.has(value)) {\n      return [];\n    }\n    seen.add(value);\n  }\n\n  if (isMapLike(value)) {\n    const converted = convertMapLikeToObject(value);\n    if (converted) {\n      return normalizeImportedFullBackupHistory(Object.values(converted), seen, depth + 1);\n    }\n    return [];\n  }\n\n  if (typeof value === 'string') {\n    const parsed = tryParseJSONLike(value);\n    if (parsed.success) {\n      return normalizeImportedFullBackupHistory(parsed.parsed, seen, depth + 1);\n    }\n    const entry = normalizeFullBackupHistoryEntry(value);\n    return entry ? [entry] : [];\n  }\n\n  // Arrays are handled at the top of the function\n  if (Array.isArray(value)) {\n    return [];\n  }\n\n  if (isPlainObject(value)) {\n    if (Array.isArray(value.history)) {\n      return normalizeImportedFullBackupHistory(value.history, seen, depth + 1);\n    }\n    if (Array.isArray(value.entries)) {\n      return normalizeImportedFullBackupHistory(value.entries, seen, depth + 1);\n    }\n    if (Array.isArray(value.list)) {\n      return normalizeImportedFullBackupHistory(value.list, seen, depth + 1);\n    }\n    const entry = normalizeFullBackupHistoryEntry(value);\n    if (entry) {\n      return [entry];\n    }\n    const nestedValues = Object.values(value);\n    if (nestedValues.length) {\n      return normalizeImportedFullBackupHistory(nestedValues, seen, depth + 1);\n    }\n  }\n\n  return [];\n}\n\n// --- Documentation Tracker Storage ---\nvar DOCUMENTATION_TRACKER_SCHEMA_VERSION = 1;\n\nfunction generateDocumentationTrackerId() {\n  var now = 0;\n  if (typeof Date !== 'undefined' && Date && typeof Date.now === 'function') {\n    now = Date.now();\n  } else {\n    try {\n      now = new Date().getTime();\n    } catch (timeError) {\n      now = Math.floor(Math.random() * 1e9);\n      void timeError;\n    }\n  }\n  var random = 0;\n  try {\n    random = Math.floor(Math.random() * 1e6);\n  } catch (randomError) {\n    random = now % 1e6;\n    void randomError;\n  }\n  return 'doc-tracker-' + now.toString(36) + '-' + random.toString(36);\n}\n\nfunction normalizeDocumentationTrackerStatusEntry(entry) {\n  var completed = false;\n  var updatedAt = null;\n\n  if (entry && typeof entry === 'object') {\n    if (typeof entry.completed === 'boolean') {\n      completed = entry.completed;\n    } else if (typeof entry.checked === 'boolean') {\n      completed = entry.checked;\n    } else if (typeof entry.value === 'boolean') {\n      completed = entry.value;\n    } else if (entry.done === true) {\n      completed = true;\n    }\n\n    var timestampCandidate = null;\n    if (typeof entry.updatedAt === 'string' && entry.updatedAt.trim()) {\n      timestampCandidate = entry.updatedAt.trim();\n    } else if (typeof entry.timestamp === 'string' && entry.timestamp.trim()) {\n      timestampCandidate = entry.timestamp.trim();\n    } else if (typeof entry.completedAt === 'string' && entry.completedAt.trim()) {\n      timestampCandidate = entry.completedAt.trim();\n    }\n    if (timestampCandidate) {\n      updatedAt = timestampCandidate;\n    }\n  } else if (typeof entry === 'boolean') {\n    completed = entry;\n  } else if (typeof entry === 'string') {\n    var normalized = entry.trim().toLowerCase();\n    if (normalized === 'true' || normalized === '1' || normalized === 'yes' || normalized === 'done') {\n      completed = true;\n    }\n  }\n\n  return {\n    completed: completed === true,\n    updatedAt: typeof updatedAt === 'string' ? updatedAt : null,\n  };\n}\n\nfunction normalizeDocumentationTrackerStatusMap(map) {\n  var normalized = {};\n\n  if (Array.isArray(map)) {\n    for (var index = 0; index < map.length; index += 1) {\n      var item = map[index];\n      if (item === null || item === undefined) {\n        continue;\n      }\n      if (typeof item === 'string' && item.trim()) {\n        normalized[item.trim()] = { completed: true, updatedAt: null };\n        continue;\n      }\n      if (typeof item === 'object') {\n        var key = null;\n        if (typeof item.id === 'string' && item.id.trim()) {\n          key = item.id.trim();\n        } else if (typeof item.key === 'string' && item.key.trim()) {\n          key = item.key.trim();\n        } else if (typeof item.name === 'string' && item.name.trim()) {\n          key = item.name.trim();\n        }\n        if (!key) {\n          continue;\n        }\n        normalized[key] = normalizeDocumentationTrackerStatusEntry(item);\n      }\n    }\n    return normalized;\n  }\n\n  if (map && (typeof map === 'object' || typeof map === 'function')) {\n    var keys = Object.keys(map);\n    for (var i = 0; i < keys.length; i += 1) {\n      var rawKey = keys[i];\n      if (rawKey === null || rawKey === undefined) {\n        continue;\n      }\n      var keyString = typeof rawKey === 'string' ? rawKey : String(rawKey);\n      if (!keyString) {\n        continue;\n      }\n      var trimmedKey = keyString.trim();\n      if (!trimmedKey) {\n        continue;\n      }\n      normalized[trimmedKey] = normalizeDocumentationTrackerStatusEntry(map[rawKey]);\n    }\n  }\n\n  return normalized;\n}\n\nfunction normalizeDocumentationTrackerStatuses(value) {\n  var normalized = {};\n  if (value && (typeof value === 'object' || typeof value === 'function')) {\n    var keys = Object.keys(value);\n    for (var i = 0; i < keys.length; i += 1) {\n      var key = keys[i];\n      if (!key) continue;\n      normalized[key] = normalizeDocumentationTrackerStatusMap(value[key]);\n    }\n  }\n  if (!normalized.locales) {\n    normalized.locales = {};\n  }\n  if (!normalized.helpTopics) {\n    normalized.helpTopics = {};\n  }\n  if (!normalized.printGuides) {\n    normalized.printGuides = {};\n  }\n  return normalized;\n}\n\nfunction normalizeDocumentationTrackerRelease(entry) {\n  if (!entry || (typeof entry !== 'object' && typeof entry !== 'function')) {\n    return null;\n  }\n\n  var id = null;\n  if (typeof entry.id === 'string' && entry.id.trim()) {\n    id = entry.id.trim();\n  }\n  if (!id && typeof entry.key === 'string' && entry.key.trim()) {\n    id = entry.key.trim();\n  }\n  if (!id) {\n    id = generateDocumentationTrackerId();\n  }\n\n  var name = '';\n  if (typeof entry.name === 'string') {\n    name = entry.name.trim();\n  } else if (typeof entry.title === 'string') {\n    name = entry.title.trim();\n  }\n\n  var targetDate = '';\n  if (typeof entry.targetDate === 'string' && entry.targetDate.trim()) {\n    targetDate = entry.targetDate.trim();\n  } else if (typeof entry.releaseDate === 'string' && entry.releaseDate.trim()) {\n    targetDate = entry.releaseDate.trim();\n  }\n\n  var createdAt = '';\n  if (typeof entry.createdAt === 'string' && entry.createdAt.trim()) {\n    createdAt = entry.createdAt.trim();\n  } else if (typeof entry.generatedAt === 'string' && entry.generatedAt.trim()) {\n    createdAt = entry.generatedAt.trim();\n  }\n  if (!createdAt) {\n    try {\n      createdAt = new Date().toISOString();\n    } catch (isoError) {\n      createdAt = '';\n      void isoError;\n    }\n  }\n\n  var updatedAt = null;\n  if (typeof entry.updatedAt === 'string' && entry.updatedAt.trim()) {\n    updatedAt = entry.updatedAt.trim();\n  } else if (typeof entry.modifiedAt === 'string' && entry.modifiedAt.trim()) {\n    updatedAt = entry.modifiedAt.trim();\n  } else if (typeof entry.lastUpdated === 'string' && entry.lastUpdated.trim()) {\n    updatedAt = entry.lastUpdated.trim();\n  } else if (typeof entry.timestamp === 'string' && entry.timestamp.trim()) {\n    updatedAt = entry.timestamp.trim();\n  }\n  if (!updatedAt) {\n    updatedAt = createdAt || null;\n  }\n\n  var notes = '';\n  if (typeof entry.notes === 'string') {\n    notes = entry.notes.trim();\n  } else if (typeof entry.summary === 'string') {\n    notes = entry.summary.trim();\n  }\n  if (notes && notes.length > 8000) {\n    notes = notes.slice(0, 8000);\n  }\n\n  var archived = false;\n  if (typeof entry.archived === 'boolean') {\n    archived = entry.archived;\n  } else if (typeof entry.status === 'string') {\n    var normalizedStatus = entry.status.trim().toLowerCase();\n    if (normalizedStatus === 'archived' || normalizedStatus === 'closed' || normalizedStatus === 'complete') {\n      archived = true;\n    }\n  }\n\n  var statuses = normalizeDocumentationTrackerStatuses(entry.statuses);\n\n  return {\n    id: id,\n    name: name,\n    targetDate: targetDate,\n    createdAt: typeof createdAt === 'string' ? createdAt : '',\n    updatedAt: typeof updatedAt === 'string' ? updatedAt : null,\n    statuses: statuses,\n    notes: notes,\n    archived: archived === true,\n  };\n}\n\nfunction normalizeDocumentationTrackerState(state) {\n  var normalized = {\n    version: DOCUMENTATION_TRACKER_SCHEMA_VERSION,\n    releases: [],\n  };\n\n  if (state === null || state === undefined) {\n    return normalized;\n  }\n\n  var rawState = state;\n  if (Array.isArray(rawState)) {\n    normalized.releases = rawState\n      .map(normalizeDocumentationTrackerRelease)\n      .filter(Boolean);\n    return normalized;\n  }\n\n  if (typeof rawState !== 'object' && typeof rawState !== 'function') {\n    return normalized;\n  }\n\n  if (typeof rawState.version === 'number' && Number.isFinite(rawState.version)) {\n    normalized.version = rawState.version;\n  }\n\n  var sourceList = null;\n  if (Array.isArray(rawState.releases)) {\n    sourceList = rawState.releases;\n  } else if (Array.isArray(rawState.entries)) {\n    sourceList = rawState.entries;\n  } else if (Array.isArray(rawState.logs)) {\n    sourceList = rawState.logs;\n  }\n\n  if (!sourceList && rawState && typeof rawState === 'object') {\n    var values = Object.values(rawState);\n    if (values.length && values.every(function (value) { return value && typeof value === 'object' && !Array.isArray(value); })) {\n      sourceList = values;\n    }\n  }\n\n  if (!sourceList || !Array.isArray(sourceList)) {\n    normalized.releases = [];\n  } else {\n    normalized.releases = sourceList\n      .map(normalizeDocumentationTrackerRelease)\n      .filter(Boolean);\n  }\n\n  return normalized;\n}\n\nfunction loadDocumentationTracker() {\n  applyLegacyStorageMigrations();\n  const safeStorage = getSafeLocalStorage();\n  const parsed = loadJSONFromStorage(\n    safeStorage,\n    DOCUMENTATION_TRACKER_STORAGE_KEY,\n    'Error loading documentation tracker from localStorage:',\n    null,\n    { validate: value => value === null || isPlainObject(value) || Array.isArray(value) },\n  );\n  if (!parsed) {\n    return {\n      version: DOCUMENTATION_TRACKER_SCHEMA_VERSION,\n      releases: [],\n    };\n  }\n  const normalized = normalizeDocumentationTrackerState(parsed);\n  if (!normalized || !Array.isArray(normalized.releases)) {\n    return {\n      version: DOCUMENTATION_TRACKER_SCHEMA_VERSION,\n      releases: [],\n    };\n  }\n  return normalized;\n}\n\nfunction saveDocumentationTracker(state) {\n  const safeStorage = getSafeLocalStorage();\n  if (state === null || state === undefined) {\n    deleteFromStorage(\n      safeStorage,\n      DOCUMENTATION_TRACKER_STORAGE_KEY,\n      'Error deleting documentation tracker from localStorage:',\n    );\n    return;\n  }\n\n  const normalized = normalizeDocumentationTrackerState(state);\n  if (!normalized.releases.length) {\n    deleteFromStorage(\n      safeStorage,\n      DOCUMENTATION_TRACKER_STORAGE_KEY,\n      'Error deleting documentation tracker from localStorage:',\n    );\n    return;\n  }\n\n  ensurePreWriteMigrationBackup(safeStorage, DOCUMENTATION_TRACKER_STORAGE_KEY);\n  saveJSONToStorage(\n    safeStorage,\n    DOCUMENTATION_TRACKER_STORAGE_KEY,\n    {\n      version: DOCUMENTATION_TRACKER_SCHEMA_VERSION,\n      releases: normalized.releases,\n    },\n    'Error saving documentation tracker to localStorage:',\n    { disableCompression: true },\n  );\n}\n\n// --- Automatic Gear Rules Storage ---\nfunction loadAutoGearRules() {\n  applyLegacyStorageMigrations();\n  const safeStorage = getSafeLocalStorage();\n  const parsed = loadJSONFromStorage(\n    safeStorage,\n    AUTO_GEAR_RULES_STORAGE_KEY,\n    \"Error loading automatic gear rules from localStorage:\",\n    [],\n    { validate: (value) => value === null || Array.isArray(value) },\n  );\n  const rules = Array.isArray(parsed) ? parsed : [];\n  const normalizedRules = Array.isArray(rules)\n    ? normalizeLegacyLongGopStructure(rules)\n    : [];\n  if (normalizedRules !== rules) {\n    saveAutoGearRules(normalizedRules, { skipNormalization: true });\n  }\n\n  if (Array.isArray(normalizedRules)) {\n    let defaultsApplied = false;\n    const withDefaults = normalizedRules.map(rule => {\n      if (rule && typeof rule === 'object' && typeof rule.enabled === 'undefined') {\n        defaultsApplied = true;\n        return { ...rule, enabled: true };\n      }\n      return rule;\n    });\n\n    if (defaultsApplied) {\n      return withDefaults;\n    }\n    return normalizedRules;\n  }\n\n  return [];\n}\n\nfunction saveAutoGearRules(rules, options = {}) {\n  const opts = options || {};\n  const { skipNormalization = false } = opts;\n  const safeRules = Array.isArray(rules) ? rules.slice() : [];\n  const normalizedRules = skipNormalization\n    ? safeRules\n    : (Array.isArray(safeRules) ? normalizeLegacyLongGopStructure(safeRules) : []);\n  const safeStorage = getSafeLocalStorage();\n  ensurePreWriteMigrationBackup(safeStorage, AUTO_GEAR_RULES_STORAGE_KEY);\n  saveJSONToStorage(\n    safeStorage,\n    AUTO_GEAR_RULES_STORAGE_KEY,\n    normalizedRules,\n    \"Error saving automatic gear rules to localStorage:\",\n    {\n      disableCompression: true,\n    },\n  );\n  return normalizedRules;\n}\n\nfunction loadAutoGearBackups() {\n  applyLegacyStorageMigrations();\n\n  if (Array.isArray(autoGearBackupsCache) && autoGearBackupsCache.length) {\n    const { normalized: normalizedCached, changed } = normalizeLegacyLongGopBackups(autoGearBackupsCache);\n    if (changed) {\n      saveAutoGearBackups(normalizedCached, { skipNormalization: true });\n    }\n    return normalizedCached;\n  }\n\n  // [Agent Migration] Read form Memory/IndexedDB first\n  // Note: Since this is a synchronous load for UI, and backups might be large,\n  // we rely on hydration if available, or force a sync read if possible/cached.\n  // For simplicity and safety in this transition, we will prioritize what's in memory/repo if hydrated.\n  // However, since StorageRepository is async, we can't block here easily without a pre-hydrated cache.\n  // Assuming 'hydrateProjectCache' or similar has run.\n  // BUT: Auto Gear Backups are NOT part of the critical hydration path in hydrateProjectCache currently.\n  // We should add a specific check or accept that this might return empty initially until async load completes?\n  // Actually, for now, let's keep the LocalStorage fallback as primary for *initial* load if not hydrated,\n  // BUT try to use the Repository if we can.\n  // A better approach for this legacy synchronous API is to rely on a module-level variable that gets hydrated.\n\n  // Checking if we have a global cache for this? No specific valid cache variable exposed yet for backups.\n  // We will assume that for V2, the async loaders in 'auto-gear/storage.js' should be used.\n  // For V1 legacy compatibility, we might need to stick to LocalStorage OR\n  // implement a synchronous cache if we want to move away from LS.\n\n  // DECISION: To ensure migration, we should look for a hydrated value. \n  // If not found, fall back to LS.\n  // Since we don't have a dedicated cache variable for this in storage.js yet (unlike presets),\n  // we will add a simple in-memory check if possible, or leave as is if V2 uses async.\n  // Re-reading 'storage.js' context: we added caches for presets but not backups.\n  // Backups are large. Storing them in LS is bad.\n  // Let's rely on the fact that we migrated 'save' to IDB.\n  // We need to implement a 'hydrateAutoGearBackups' or similar, but for this function:\n\n  const safeStorage = getSafeLocalStorage();\n  const parsed = loadJSONFromStorage(\n    safeStorage,\n    AUTO_GEAR_BACKUPS_STORAGE_KEY,\n    \"Error loading automatic gear rule backups from localStorage:\",\n    [],\n    { validate: (value) => value === null || Array.isArray(value) },\n  );\n\n  const backups = Array.isArray(parsed) ? parsed : [];\n  const { normalized: normalizedBackups, changed } = normalizeLegacyLongGopBackups(backups);\n  if (changed) {\n    saveAutoGearBackups(normalizedBackups, { skipNormalization: true });\n  }\n  autoGearBackupsCache = normalizedBackups;\n  return normalizedBackups;\n}\n\nfunction saveAutoGearBackups(backups, options = {}) {\n  const opts = options || {};\n  const { skipNormalization = false } = opts;\n  const safeBackups = Array.isArray(backups) ? backups.slice() : [];\n  const { normalized: normalizedBackups } = skipNormalization\n    ? { normalized: safeBackups, changed: false }\n    : normalizeLegacyLongGopBackups(safeBackups);\n  autoGearBackupsCache = normalizedBackups;\n  const safeStorage = getSafeLocalStorage();\n  ensurePreWriteMigrationBackup(safeStorage, AUTO_GEAR_BACKUPS_STORAGE_KEY);\n\n  let attemptedMigrationCleanup = false;\n  let attemptedCacheCleanup = false;\n\n  // [Agent Migration] Update In-Memory Cache and Persist to IndexedDB\n  if (typeof window !== 'undefined' && window.localStorage === safeStorage) { // Simple check if we are in a window context\n    // Note: Auto Gear Backups are large, so we might skip full in-memory caching if needed, \n    // but consistency suggests we should at least route writes properly.\n    // For now, we will piggyback on the existing pattern if a cache exists, \n    // or just ensure proper async persistence.\n\n    const isIndexedDBActive = typeof storageRepo !== 'undefined'\n      && storageRepo.driver\n      && storageRepo.driver.constructor.name === 'IndexedDBAdapter';\n\n    if (typeof storageRepo !== 'undefined') {\n      storageRepo.setItem(AUTO_GEAR_BACKUPS_STORAGE_KEY, normalizedBackups).catch(err => {\n        console.warn('[Storage] Failed to async persist Auto Gear Backups to IDB:', err);\n        if (isIndexedDBActive) {\n          try {\n            saveJSONToStorage(\n              safeStorage,\n              AUTO_GEAR_BACKUPS_STORAGE_KEY,\n              normalizedBackups,\n              \"Error saving automatic gear rule backups to localStorage:\",\n            );\n          } catch (fallbackError) {\n            console.warn('[Storage] Failed to persist Auto Gear Backups fallback to localStorage:', fallbackError);\n          }\n        }\n      });\n    }\n  }\n\n  // [Agent Migration] Conditional Skipping of Legacy Write\n  // If IndexedDB is active, we should skip writing to LocalStorage to save space.\n  const isIndexedDBActive = typeof storageRepo !== 'undefined' &&\n    storageRepo.driver &&\n    storageRepo.driver.constructor.name === 'IndexedDBAdapter';\n\n  if (isIndexedDBActive) {\n    // Skip legacy write to avoid quota issues\n    return;\n  }\n\n  saveJSONToStorage(\n    safeStorage,\n    AUTO_GEAR_BACKUPS_STORAGE_KEY,\n    normalizedBackups,\n    \"Error saving automatic gear rule backups to localStorage:\",\n    {\n      onQuotaExceeded: (error, context = {}) => {\n        const removal = removeOldestAutoGearBackupEntry(normalizedBackups);\n        if (removal) {\n          const label = removal.label;\n          if (label) {\n            console.warn(\n              `Removed automatic gear backup \"${label}\" to free up storage space before saving gear backups.`,\n            );\n          } else {\n            console.warn(\n              'Removed oldest automatic gear backup entry to free up storage space before saving gear backups.',\n            );\n          }\n          return true;\n        }\n\n        const storage = context && context.storage ? context.storage : safeStorage;\n\n        if (!attemptedMigrationCleanup) {\n          attemptedMigrationCleanup = true;\n          if (cleanupAutoGearBackupMigrationCopies(storage)) {\n            return true;\n          }\n        }\n\n        if (!attemptedCacheCleanup) {\n          attemptedCacheCleanup = true;\n          if (clearCachedPlannerDataForAutoGearBackups()) {\n            return true;\n          }\n        }\n\n        return false;\n      },\n    },\n  );\n  return normalizedBackups;\n}\n\nfunction loadAutoGearSeedFlag() {\n  applyLegacyStorageMigrations();\n  const safeStorage = getSafeLocalStorage();\n  return loadFlagFromStorage(\n    safeStorage,\n    AUTO_GEAR_SEEDED_STORAGE_KEY,\n    \"Error loading automatic gear seed flag from localStorage:\",\n  );\n}\n\nfunction saveAutoGearSeedFlag(flag) {\n  const safeStorage = getSafeLocalStorage();\n  saveFlagToStorage(\n    safeStorage,\n    AUTO_GEAR_SEEDED_STORAGE_KEY,\n    Boolean(flag),\n    \"Error saving automatic gear seed flag to localStorage:\",\n  );\n}\n\nfunction loadAutoGearPresets() {\n  applyLegacyStorageMigrations();\n  const safeStorage = getSafeLocalStorage();\n  const presets = loadJSONFromStorage(\n    safeStorage,\n    AUTO_GEAR_PRESETS_STORAGE_KEY,\n    \"Error loading automatic gear presets from localStorage:\",\n    [],\n    { validate: (value) => value === null || Array.isArray(value) },\n  );\n  const presetArray = Array.isArray(presets) ? presets : [];\n  const normalized = Array.isArray(presetArray)\n    ? normalizeLegacyLongGopStructure(presetArray)\n    : [];\n  if (normalized !== presetArray) {\n    saveAutoGearPresets(normalized, { skipNormalization: true });\n  }\n  return Array.isArray(normalized) ? normalized : [];\n}\n\n// [Agent Refactor] Memory Cache for Auto Gear\n\nlet autoGearMonitorDefaultsCache = null;\nlet autoGearActivePresetIdCache = null;\nlet autoGearAutoPresetIdCache = null;\nlet autoGearBackupsCache = null;\nlet autoGearBackupRetentionCache = null;\nlet autoGearBackupVisibilityCache = null;\nlet customFontsCache = null;\nlet customLogoCache = null;\nlet cameraColorsCache = null;\nlet printPreferencesCache = null;\nlet contactsCache = null;\nlet ownGearCache = null;\nlet userProfileCache = null;\nlet favoritesCache = null;\nlet temperatureUnitCache = null;\nlet focusScaleCache = null;\nlet mountVoltagesCache = null;\nlet fullBackupHistoryCache = null;\n\nfunction readActiveAutoGearPresetIds() {\n  const ids = new Set();\n  const pushId = (candidate) => {\n    if (typeof candidate === 'string') {\n      const trimmed = candidate.trim();\n      if (trimmed) {\n        ids.add(trimmed);\n      }\n    }\n  };\n\n  if (typeof loadAutoGearActivePresetId === 'function') {\n    try {\n      pushId(loadAutoGearActivePresetId());\n    } catch (error) {\n      console.warn('Unable to read automatic gear active preset id while evaluating compression policy.', error);\n    }\n  }\n\n  if (typeof loadAutoGearAutoPresetId === 'function') {\n    try {\n      pushId(loadAutoGearAutoPresetId());\n    } catch (error) {\n      console.warn('Unable to read automatic gear auto preset id while evaluating compression policy.', error);\n    }\n  }\n\n  return ids;\n}\n\nfunction saveAutoGearPresets(presets, options = {}) {\n  const opts = options || {};\n  const { skipNormalization = false, disableCompression: disableCompressionOverride } = opts;\n  const safePresets = Array.isArray(presets) ? presets.slice() : [];\n  const normalizedPresets = skipNormalization\n    ? safePresets\n    : (Array.isArray(safePresets) ? normalizeLegacyLongGopStructure(safePresets) : []);\n  const safeStorage = getSafeLocalStorage();\n  ensurePreWriteMigrationBackup(safeStorage, AUTO_GEAR_PRESETS_STORAGE_KEY);\n\n  let disableCompression = typeof disableCompressionOverride === 'boolean'\n    ? disableCompressionOverride\n    : false;\n\n  if (disableCompressionOverride === undefined) {\n    const activePresetIds = readActiveAutoGearPresetIds();\n    if (activePresetIds.size > 0) {\n      disableCompression = normalizedPresets.some(\n        (preset) => preset\n          && typeof preset === 'object'\n          && typeof preset.id === 'string'\n          && activePresetIds.has(preset.id),\n      );\n    }\n  }\n\n  // [Agent Refactor] Update Cache & Repo\n\n  if (storageRepo) {\n    storageRepo.setItem(AUTO_GEAR_PRESETS_STORAGE_KEY, normalizedPresets).catch(e => console.warn('Failed to save auto gear presets to repo', e));\n  }\n\n  saveJSONToStorage(\n    safeStorage,\n    AUTO_GEAR_PRESETS_STORAGE_KEY,\n    normalizedPresets,\n    \"Error saving automatic gear presets to localStorage:\",\n    disableCompression ? { disableCompression: true } : undefined,\n  );\n  return normalizedPresets;\n}\n\nfunction loadAutoGearMonitorDefaults() {\n  // [Agent Refactor] Check Cache First\n  if (autoGearMonitorDefaultsCache) {\n    return autoGearMonitorDefaultsCache;\n  }\n\n  applyLegacyStorageMigrations();\n  const safeStorage = getSafeLocalStorage();\n  const defaults = loadJSONFromStorage(\n    safeStorage,\n    AUTO_GEAR_MONITOR_DEFAULTS_STORAGE_KEY,\n    \"Error loading automatic gear monitor defaults from localStorage:\",\n    {},\n    { validate: (value) => value === null || typeof value === 'object' },\n  );\n  const monitorDefaults = defaults && typeof defaults === 'object' ? defaults : {};\n  const normalizedDefaults = isPlainObject(monitorDefaults)\n    ? normalizeLegacyLongGopStructure(monitorDefaults)\n    : {};\n  if (normalizedDefaults !== monitorDefaults) {\n    saveAutoGearMonitorDefaults(normalizedDefaults, { skipNormalization: true });\n  }\n  return normalizedDefaults && typeof normalizedDefaults === 'object' ? normalizedDefaults : {};\n}\n\nfunction saveAutoGearMonitorDefaults(defaults, options = {}) {\n  const opts = options || {};\n  const { skipNormalization = false } = opts;\n  const safeDefaults = defaults && typeof defaults === 'object' ? { ...defaults } : {};\n  const normalizedDefaults = skipNormalization\n    ? safeDefaults\n    : (isPlainObject(safeDefaults) ? normalizeLegacyLongGopStructure(safeDefaults) : {});\n  const safeStorage = getSafeLocalStorage();\n  ensurePreWriteMigrationBackup(safeStorage, AUTO_GEAR_MONITOR_DEFAULTS_STORAGE_KEY);\n\n  // [Agent Refactor] Update Cache & Repo\n  autoGearMonitorDefaultsCache = normalizedDefaults;\n  if (storageRepo) {\n    storageRepo.setItem(AUTO_GEAR_MONITOR_DEFAULTS_STORAGE_KEY, normalizedDefaults).catch(e => console.warn('Failed to save monitor defaults to repo', e));\n  }\n\n  const isIndexedDB = storageRepo && storageRepo.driver && storageRepo.driver.constructor && storageRepo.driver.constructor.name === 'IndexedDBAdapter';\n  if (!isIndexedDB) {\n    saveJSONToStorage(\n      safeStorage,\n      AUTO_GEAR_MONITOR_DEFAULTS_STORAGE_KEY,\n      normalizedDefaults,\n      \"Error saving automatic gear monitor defaults to localStorage:\",\n    );\n  }\n  return normalizedDefaults;\n}\n\nfunction removeAutoGearPresetFromStorage(presetId, storage) {\n  if (!presetId) {\n    return;\n  }\n\n  const safeStorage = storage || getSafeLocalStorage();\n  if (!safeStorage) {\n    return;\n  }\n\n  let rawPresets;\n  try {\n    rawPresets = safeStorage.getItem(AUTO_GEAR_PRESETS_STORAGE_KEY);\n  } catch (error) {\n    console.error('Error loading automatic gear presets while removing autosaved preset from localStorage:', error);\n    downgradeSafeLocalStorageToMemory('read access', error, safeStorage);\n    alertStorageError();\n    return;\n  }\n\n  if (rawPresets === null || typeof rawPresets === 'undefined') {\n    return;\n  }\n\n  let parsedPresets;\n  let normalizedRawPresets = rawPresets;\n  if (typeof rawPresets === 'string' && rawPresets) {\n    normalizedRawPresets = maybeDecompressStoredString(rawPresets);\n  }\n  try {\n    parsedPresets = JSON.parse(normalizedRawPresets);\n  } catch (parseError) {\n    console.error('Error parsing automatic gear presets while removing autosaved preset from localStorage:', parseError);\n    return;\n  }\n\n  if (!Array.isArray(parsedPresets)) {\n    return;\n  }\n\n  const filteredPresets = parsedPresets.filter((preset) => {\n    if (!preset || typeof preset !== 'object') {\n      return true;\n    }\n    return preset.id !== presetId;\n  });\n\n  if (filteredPresets.length === parsedPresets.length) {\n    return;\n  }\n\n  // [Agent Refactor] Update Cache & Repo (Implicit via saveAutoGearPresets)\n  saveAutoGearPresets(filteredPresets, { skipNormalization: true });\n}\n\nfunction loadAutoGearActivePresetId() {\n  // [Agent Refactor] Check Cache First\n  if (autoGearActivePresetIdCache !== null) {\n    return typeof autoGearActivePresetIdCache === 'string' ? autoGearActivePresetIdCache : '';\n  }\n\n  applyLegacyStorageMigrations();\n  const safeStorage = getSafeLocalStorage();\n  if (!safeStorage || typeof safeStorage.getItem !== 'function') { // Added check\n    return '';\n  }\n  try {\n    const value = safeStorage.getItem(AUTO_GEAR_ACTIVE_PRESET_STORAGE_KEY);\n    return typeof value === 'string' ? value : '';\n  } catch (error) {\n    console.error('Error loading automatic gear active preset from localStorage:', error);\n    downgradeSafeLocalStorageToMemory('read access', error, safeStorage);\n    alertStorageError();\n    return '';\n  }\n}\n\nfunction saveAutoGearActivePresetId(presetId) {\n  // [Agent Refactor] Update Cache & Repo\n  autoGearActivePresetIdCache = presetId || '';\n  if (storageRepo) {\n    if (presetId) {\n      storageRepo.setItem(AUTO_GEAR_ACTIVE_PRESET_STORAGE_KEY, presetId).catch(e => console.warn('Failed to save active preset id', e));\n    } else {\n      storageRepo.removeItem(AUTO_GEAR_ACTIVE_PRESET_STORAGE_KEY).catch(e => console.warn('Failed to remove active preset id', e));\n    }\n  }\n\n  const isIndexedDB = storageRepo && storageRepo.driver && storageRepo.driver.constructor && storageRepo.driver.constructor.name === 'IndexedDBAdapter';\n  if (isIndexedDB) return;\n\n  const safeStorage = getSafeLocalStorage();\n  if (!safeStorage) {\n    return;\n  }\n  try {\n    if (presetId) {\n      safeStorage.setItem(AUTO_GEAR_ACTIVE_PRESET_STORAGE_KEY, presetId);\n    } else {\n      safeStorage.removeItem(AUTO_GEAR_ACTIVE_PRESET_STORAGE_KEY);\n    }\n  } catch (error) {\n    console.error('Error saving automatic gear active preset to localStorage:', error);\n    downgradeSafeLocalStorageToMemory('write access', error, safeStorage);\n    alertStorageError();\n  }\n}\n\nfunction loadAutoGearAutoPresetId() {\n  // [Agent Refactor] Check Cache First\n  if (autoGearAutoPresetIdCache !== null) {\n    return typeof autoGearAutoPresetIdCache === 'string' ? autoGearAutoPresetIdCache : '';\n  }\n\n  applyLegacyStorageMigrations();\n  const safeStorage = getSafeLocalStorage();\n  if (!safeStorage || typeof safeStorage.getItem !== 'function') { // Added check\n    return '';\n  }\n  try {\n    const value = safeStorage.getItem(AUTO_GEAR_AUTO_PRESET_STORAGE_KEY);\n    if (typeof value === 'string' && value) {\n      return value;\n    }\n\n    // [Agent Fix] Legacy Migration Support\n    // The migration process to IDB is async (write-after-read), so immediately after calling\n    // applyLegacyStorageMigrations(), the data might not be in safeStorage (IDB) yet.\n    // We MUST check the legacy key in localStorage specifically to support this migration phase.\n    const legacyStorage = (typeof global !== 'undefined' && global.localStorage)\n      || (typeof window !== 'undefined' && window.localStorage);\n\n    console.log('DEBUG: loadAutoGearAutoPresetId legacy check, legacyStorage exists:', !!legacyStorage);\n\n    if (legacyStorage && legacyStorage.getItem) {\n      // Check legacy prefix key\n      let legacyValue = legacyStorage.getItem('cinePowerPlanner_autoGearAutoPreset');\n      console.log('DEBUG: legacyValue for cinePowerPlanner_autoGearAutoPreset:', legacyValue);\n      if (typeof legacyValue === 'string' && legacyValue) {\n        return legacyValue;\n      }\n      // Also check the modern key in legacy storage (in case it was migrated but only to LS)\n      legacyValue = legacyStorage.getItem(AUTO_GEAR_AUTO_PRESET_STORAGE_KEY);\n      if (typeof legacyValue === 'string' && legacyValue) {\n        return legacyValue;\n      }\n    }\n    return '';\n  } catch (error) {\n    console.error('Error loading automatic gear auto preset from localStorage:', error);\n    downgradeSafeLocalStorageToMemory('read access', error, safeStorage);\n    alertStorageError();\n    return '';\n  }\n}\n\nfunction saveAutoGearAutoPresetId(presetId) {\n  // [Agent Refactor] Update Cache & Repo\n  autoGearAutoPresetIdCache = presetId || '';\n  if (storageRepo) {\n    if (presetId) {\n      storageRepo.setItem(AUTO_GEAR_AUTO_PRESET_STORAGE_KEY, presetId).catch(e => console.warn('Failed to save auto preset id', e));\n    } else {\n      storageRepo.removeItem(AUTO_GEAR_AUTO_PRESET_STORAGE_KEY).catch(e => console.warn('Failed to remove auto preset id', e));\n    }\n  }\n\n  const isIndexedDB = storageRepo && storageRepo.driver && storageRepo.driver.constructor && storageRepo.driver.constructor.name === 'IndexedDBAdapter';\n  // [Agent Fix] - Legacy Cleanup\n  // Even if using IndexedDB, we must proceed to clean up legacy localStorage entries\n  // to pass tests that expect side-effects on localStorage.\n  /* \n  // OLD LOGIC: skipped legacy cleanup\n  if (isIndexedDB) {\n    return;\n  } \n  */\n\n  const safeStorage = getSafeLocalStorage();\n  if (!safeStorage) {\n    return;\n  }\n  let previousPresetId = '';\n  // ... legacy logic continues ...\n  try {\n    const existingId = safeStorage.getItem(AUTO_GEAR_AUTO_PRESET_STORAGE_KEY);\n    if (typeof existingId === 'string' && existingId) {\n      previousPresetId = existingId;\n    }\n  } catch (inspectionError) {\n    console.error('Error inspecting automatic gear auto preset in localStorage:', inspectionError);\n    downgradeSafeLocalStorageToMemory('read access', inspectionError, safeStorage);\n  }\n  try {\n    if (presetId) {\n      safeStorage.setItem(AUTO_GEAR_AUTO_PRESET_STORAGE_KEY, presetId);\n      if (previousPresetId && previousPresetId !== presetId) {\n        removeAutoGearPresetFromStorage(previousPresetId, safeStorage);\n      }\n    } else {\n      safeStorage.removeItem(AUTO_GEAR_AUTO_PRESET_STORAGE_KEY);\n      if (previousPresetId) {\n        removeAutoGearPresetFromStorage(previousPresetId, safeStorage);\n      }\n    }\n  } catch (error) {\n    console.error('Error saving automatic gear auto preset to localStorage:', error);\n    downgradeSafeLocalStorageToMemory('write access', error, safeStorage);\n    alertStorageError();\n  }\n}\n\nfunction loadAutoGearBackupVisibility() {\n  // [Agent Refactor] Check Cache First\n  if (autoGearBackupVisibilityCache !== null) {\n    return !!autoGearBackupVisibilityCache;\n  }\n\n  applyLegacyStorageMigrations();\n  const safeStorage = getSafeLocalStorage();\n  return loadFlagFromStorage(\n    safeStorage,\n    AUTO_GEAR_BACKUP_VISIBILITY_STORAGE_KEY,\n    \"Error loading automatic gear backup visibility from localStorage:\",\n  );\n}\n\nfunction saveAutoGearBackupVisibility(flag) {\n  // [Agent Refactor] Update Cache & Repo\n  autoGearBackupVisibilityCache = !!flag;\n  if (storageRepo) {\n    storageRepo.setItem(AUTO_GEAR_BACKUP_VISIBILITY_STORAGE_KEY, !!flag).catch(e => console.warn('Failed to save visibility', e));\n  }\n\n\n\n  const safeStorage = getSafeLocalStorage();\n  saveFlagToStorage(\n    safeStorage,\n    AUTO_GEAR_BACKUP_VISIBILITY_STORAGE_KEY,\n    Boolean(flag),\n    \"Error saving automatic gear backup visibility to localStorage:\",\n  );\n}\n\nfunction getAutoGearBackupRetentionUpperBound() {\n  const candidate = typeof AUTO_GEAR_BACKUP_RETENTION_MAX === 'number'\n    ? AUTO_GEAR_BACKUP_RETENTION_MAX\n    : MAX_AUTO_BACKUPS;\n  const numeric = Number(candidate);\n  if (!Number.isFinite(numeric)) {\n    return MAX_AUTO_BACKUPS;\n  }\n  const rounded = Math.round(numeric);\n  if (!Number.isFinite(rounded)) {\n    return MAX_AUTO_BACKUPS;\n  }\n  if (rounded < AUTO_GEAR_BACKUP_RETENTION_MIN) {\n    return AUTO_GEAR_BACKUP_RETENTION_MIN;\n  }\n  if (rounded > MAX_AUTO_BACKUPS) {\n    return MAX_AUTO_BACKUPS;\n  }\n  return rounded;\n}\n\nfunction clampAutoGearBackupRetention(value) {\n  const numeric = Number(value);\n  if (!Number.isFinite(numeric)) {\n    return getAutoGearBackupRetentionDefault();\n  }\n  const rounded = Math.round(numeric);\n  if (!Number.isFinite(rounded)) {\n    return getAutoGearBackupRetentionDefault();\n  }\n  if (rounded < AUTO_GEAR_BACKUP_RETENTION_MIN) {\n    return AUTO_GEAR_BACKUP_RETENTION_MIN;\n  }\n  const upperBound = getAutoGearBackupRetentionUpperBound();\n  if (rounded > upperBound) {\n    return upperBound;\n  }\n  return rounded;\n}\n\nfunction getAutoGearBackupRetentionDefault() {\n  const upperBound = getAutoGearBackupRetentionUpperBound();\n  if (GLOBAL_SCOPE && typeof GLOBAL_SCOPE.AUTO_GEAR_BACKUP_RETENTION_DEFAULT === 'number') {\n    const candidate = GLOBAL_SCOPE.AUTO_GEAR_BACKUP_RETENTION_DEFAULT;\n    if (Number.isFinite(candidate) && candidate >= AUTO_GEAR_BACKUP_RETENTION_MIN) {\n      const rounded = Math.round(candidate);\n      if (!Number.isFinite(rounded)) {\n        return upperBound;\n      }\n      if (rounded < AUTO_GEAR_BACKUP_RETENTION_MIN) {\n        return AUTO_GEAR_BACKUP_RETENTION_MIN;\n      }\n      if (rounded > upperBound) {\n        return upperBound;\n      }\n      return rounded;\n    }\n  }\n  const fallback = Math.round(AUTO_GEAR_BACKUP_RETENTION_DEFAULT_VALUE);\n  if (!Number.isFinite(fallback)) {\n    return AUTO_GEAR_BACKUP_RETENTION_MIN;\n  }\n  if (fallback > upperBound) {\n    return upperBound;\n  }\n  if (fallback < AUTO_GEAR_BACKUP_RETENTION_MIN) {\n    return AUTO_GEAR_BACKUP_RETENTION_MIN;\n  }\n  return fallback;\n}\n\nfunction normalizeAutoGearBackupRetentionValue(value, fallback = getAutoGearBackupRetentionDefault()) {\n  if (value === null || value === undefined) {\n    return fallback;\n  }\n  if (typeof value === 'number') {\n    return clampAutoGearBackupRetention(value);\n  }\n  if (typeof value === 'string') {\n    const trimmed = value.trim();\n    if (!trimmed) {\n      return fallback;\n    }\n    const parsed = Number(trimmed);\n    if (Number.isFinite(parsed)) {\n      return clampAutoGearBackupRetention(parsed);\n    }\n    const maybeJson = tryParseJSONLike(trimmed);\n    if (maybeJson && maybeJson.success) {\n      return normalizeAutoGearBackupRetentionValue(maybeJson.parsed, fallback);\n    }\n    return fallback;\n  }\n  if (Array.isArray(value)) {\n    for (let index = 0; index < value.length; index += 1) {\n      const candidate = normalizeAutoGearBackupRetentionValue(value[index], null);\n      if (typeof candidate === 'number' && Number.isFinite(candidate)) {\n        return clampAutoGearBackupRetention(candidate);\n      }\n    }\n    return fallback;\n  }\n  if (isPlainObject(value)) {\n    const candidateKeys = ['value', 'retention', 'limit', 'count'];\n    for (let i = 0; i < candidateKeys.length; i += 1) {\n      const key = candidateKeys[i];\n      if (!Object.prototype.hasOwnProperty.call(value, key)) {\n        continue;\n      }\n      const candidate = normalizeAutoGearBackupRetentionValue(value[key], null);\n      if (typeof candidate === 'number' && Number.isFinite(candidate)) {\n        return clampAutoGearBackupRetention(candidate);\n      }\n    }\n    return fallback;\n  }\n  return fallback;\n}\n\nfunction loadAutoGearBackupRetention() {\n  // [Agent Refactor] Check Cache First\n  if (autoGearBackupRetentionCache !== null) {\n    return autoGearBackupRetentionCache;\n  }\n\n  applyLegacyStorageMigrations();\n  const safeStorage = getSafeLocalStorage();\n  const retention = loadJSONFromStorage(\n    safeStorage,\n    AUTO_GEAR_BACKUP_RETENTION_STORAGE_KEY,\n    \"Error loading automatic gear backup retention from localStorage:\",\n    getAutoGearBackupRetentionDefault(),\n    {\n      validate: (value) =>\n        value === null\n        || typeof value === 'number'\n        || typeof value === 'string'\n        || Array.isArray(value)\n        || isPlainObject(value),\n    },\n  );\n  return normalizeAutoGearBackupRetentionValue(retention);\n}\n\nfunction saveAutoGearBackupRetention(retention) {\n  if (\n    retention === null\n    || retention === undefined\n    || typeof retention === 'function'\n    || (\n      typeof retention === 'object'\n      && !Array.isArray(retention)\n      && !isPlainObject(retention)\n    )\n  ) {\n    return;\n  }\n  const safeStorage = getSafeLocalStorage();\n  const normalized = normalizeAutoGearBackupRetentionValue(retention);\n\n  // [Agent Refactor] Update Cache & Repo\n  autoGearBackupRetentionCache = normalized;\n  if (storageRepo) {\n    storageRepo.setItem(AUTO_GEAR_BACKUP_RETENTION_STORAGE_KEY, normalized).catch(e => console.warn('Failed to save backup retention', e));\n  }\n\n\n\n  ensurePreWriteMigrationBackup(safeStorage, AUTO_GEAR_BACKUP_RETENTION_STORAGE_KEY);\n  saveJSONToStorage(\n    safeStorage,\n    AUTO_GEAR_BACKUP_RETENTION_STORAGE_KEY,\n    normalized,\n    \"Error saving automatic gear backup retention to localStorage:\",\n  );\n}\n\n// --- Clear All Stored Data ---\nasync function clearAllData() {\n  // [Agent Change] Synchronous \"Flash Wipe\" of LocalStorage/SessionStorage\n  // We perform this FIRST so that even if the async IDB cleanup lags or the caller\n  // fails to await this function (like in some legacy tests), the visible storage\n  // is immediately cleared.\n  const safeStorage = getSafeLocalStorage();\n\n  const clearStorageFully = (storage, storageName) => {\n    if (!storage) return;\n\n    // 1. Try native clear\n    if (typeof storage.clear === 'function') {\n      try { storage.clear(); } catch (e) { void e; }\n    }\n\n    // 2. Aggressive interate-and-destroy (for resilience)\n    try {\n      const keysToRemove = [];\n      try {\n        for (let i = 0; i < storage.length; i++) {\n          const k = storage.key(i);\n          if (k) keysToRemove.push(k);\n        }\n      } catch (e) { void e; }\n\n      // Fallback for environments where .key() iterator fails\n      try {\n        Object.keys(storage).forEach(k => {\n          if (k && !keysToRemove.includes(k)) keysToRemove.push(k);\n        });\n      } catch (e) { void e; }\n\n      keysToRemove.forEach(key => {\n        if (key === FACTORY_RESET_LOCK_KEY) return;\n        try { storage.removeItem(key); } catch (e) { void e; }\n      });\n    } catch (e) { void e; }\n  };\n\n  clearStorageFully(safeStorage, 'safeLocalStorage');\n  if (typeof localStorage !== 'undefined' && localStorage !== safeStorage) {\n    clearStorageFully(localStorage, 'localStorage');\n  }\n  if (typeof sessionStorage !== 'undefined') {\n    clearStorageFully(sessionStorage, 'sessionStorage');\n  }\n\n  // Set Reset Flags\n  try {\n    if (typeof globalThis !== 'undefined') globalThis.__cameraPowerPlannerFactoryResetting = true;\n    if (typeof global !== 'undefined') global.__cameraPowerPlannerFactoryResetting = true;\n    if (typeof window !== 'undefined') window.__cameraPowerPlannerFactoryResetting = true;\n    if (GLOBAL_SCOPE) {\n      GLOBAL_SCOPE.__cameraPowerPlannerFactoryResetting = true;\n      GLOBAL_SCOPE.__cineMonolithicProjectCleanupDone = false;\n    }\n    if (typeof sessionStorage !== 'undefined') sessionStorage.setItem(FACTORY_RESET_LOCK_KEY, 'true');\n    if (typeof localStorage !== 'undefined') localStorage.setItem(FACTORY_RESET_LOCK_KEY, 'true');\n  } catch (e) { void e; }\n\n  // Broadcast\n  if (lifecycleChannel) {\n    try { lifecycleChannel.postMessage('factory-reset'); } catch (e) { void e; }\n  }\n\n  // Memory Cleanup\n  try { deleteProject(); } catch (e) { console.warn('Unable to clear stored projects', e); }\n  invalidateProjectReadCache();\n  if (AUTO_BACKUP_COMPRESSION_CACHE && typeof AUTO_BACKUP_COMPRESSION_CACHE.clear === 'function') {\n    AUTO_BACKUP_COMPRESSION_CACHE.clear();\n  }\n  if (Array.isArray(AUTO_BACKUP_COMPRESSION_CACHE_KEYS)) {\n    AUTO_BACKUP_COMPRESSION_CACHE_KEYS.length = 0;\n  }\n\n  // Async IDB Cleanup\n  try {\n    let clearVaultFn = null;\n    if (GLOBAL_SCOPE && typeof GLOBAL_SCOPE.clearBackupVault === 'function') {\n      clearVaultFn = GLOBAL_SCOPE.clearBackupVault;\n    } else if (typeof window !== 'undefined' && typeof window.clearBackupVault === 'function') {\n      clearVaultFn = window.clearBackupVault;\n    } else if (GLOBAL_SCOPE && GLOBAL_SCOPE.cineFeatureBackup && typeof GLOBAL_SCOPE.cineFeatureBackup.clearBackupVault === 'function') {\n      clearVaultFn = GLOBAL_SCOPE.cineFeatureBackup.clearBackupVault;\n    }\n\n    if (clearVaultFn) await clearVaultFn();\n\n    if (typeof indexedDB !== 'undefined') {\n      const vaultDbNames = ['cinePowerPlannerBackupVault', 'cinePowerPlanner', 'cameraPowerPlanner'];\n      if (typeof indexedDB.databases === 'function') {\n        try {\n          const dbs = await indexedDB.databases();\n          dbs.forEach(db => {\n            if (db.name && !vaultDbNames.includes(db.name)) vaultDbNames.push(db.name);\n          });\n        } catch (e) { void e; }\n      }\n\n      await Promise.all(vaultDbNames.map(dbName => {\n        return new Promise((resolve) => {\n          try {\n            const request = indexedDB.deleteDatabase(dbName);\n            request.addEventListener('success', () => resolve());\n            request.addEventListener('error', () => {\n              console.warn(`Failed to delete IndexedDB database \"${dbName}\"`, request.error);\n              resolve();\n            });\n            request.addEventListener('blocked', () => resolve());\n          } catch (e) { resolve(); }\n        });\n      }));\n    }\n  } catch (vaultError) {\n    console.warn('Failed to clear backup vault', vaultError);\n  }\n\n  // Clear Service Worker Caches\n  if (typeof caches !== 'undefined' && typeof caches.keys === 'function') {\n    try {\n      const cacheKeys = await caches.keys();\n      await Promise.all(\n        cacheKeys.map(function (key) {\n          return caches.delete(key);\n        })\n      );\n    } catch (cacheError) {\n      console.warn('Storage reset: Failed to clear Service Worker caches.', cacheError);\n    }\n  }\n}\n// --- Export/Import All Planner Data ---\nfunction readLocalStorageValue(key) {\n  // [Agent Refactor] Check Memory Caches First\n  if (key === CUSTOM_FONT_STORAGE_KEY_DEFAULT && customFontsCache) return customFontsCache;\n  if (key === CUSTOM_LOGO_STORAGE_KEY && customLogoCache) return customLogoCache;\n  if (key === CAMERA_COLOR_STORAGE_KEY && cameraColorsCache) return cameraColorsCache;\n  if (key === PRINT_PREFERENCES_STORAGE_KEY && printPreferencesCache) return printPreferencesCache;\n  if (key === CONTACTS_STORAGE_KEY && contactsCache) return contactsCache;\n  if (key === OWN_GEAR_STORAGE_KEY && ownGearCache) return ownGearCache;\n  if (key === USER_PROFILE_STORAGE_KEY && userProfileCache) return userProfileCache;\n\n  if (key === FAVORITES_STORAGE_KEY && favoritesCache) return favoritesCache;\n  if (key === TEMPERATURE_UNIT_STORAGE_KEY_NAME && temperatureUnitCache) return temperatureUnitCache;\n  if (key === FOCUS_SCALE_STORAGE_KEY_NAME && focusScaleCache) return focusScaleCache;\n  if (key === getMountVoltageStorageKeyName() && mountVoltagesCache) return mountVoltagesCache;\n\n  const storage = getSafeLocalStorage();\n  if (!storage || typeof storage.getItem !== 'function') return null;\n  const variants = getStorageKeyVariants(key);\n  for (let i = 0; i < variants.length; i += 1) {\n    const candidateKey = variants[i];\n    try {\n      const value = storage.getItem(candidateKey);\n      if (value === null || value === undefined) {\n        if (RAW_STORAGE_BACKUP_KEYS.has(candidateKey)) {\n          try {\n            const backupValue = storage.getItem(`${candidateKey}${STORAGE_BACKUP_SUFFIX}`);\n            if (backupValue !== null && backupValue !== undefined) {\n              const decodedBackup = decodeStoredValue(backupValue);\n              return typeof decodedBackup === 'string' ? decodedBackup : String(backupValue);\n            }\n          } catch (backupError) {\n            console.warn('Unable to read backup key for export', candidateKey, backupError);\n            downgradeSafeLocalStorageToMemory('read access', backupError, storage);\n          }\n        }\n      } else {\n        const decoded = decodeStoredValue(value);\n        return typeof decoded === 'string' ? decoded : String(value);\n      }\n    } catch (error) {\n      console.warn('Unable to read storage key for backup', candidateKey, error);\n      downgradeSafeLocalStorageToMemory('read access', error, storage);\n    }\n  }\n  // [Agent Fix] Fallback to actual localStorage for preference keys when IDB adapter is active\n  const preferenceKeyList = [\n    'darkMode', 'pinkMode', 'highContrast', 'reduceMotion', 'relaxedSpacing',\n    'showAutoBackups', 'accentColor', 'fontSize', 'fontFamily', 'language', 'iosPwaHelpShown',\n  ];\n  if (preferenceKeyList.includes(key)) {\n    const legacyStorage = (typeof global !== 'undefined' && global.localStorage) || (typeof window !== 'undefined' && window.localStorage);\n    if (legacyStorage && typeof legacyStorage.getItem === 'function') {\n      try {\n        const legacyValue = legacyStorage.getItem(key);\n        if (legacyValue !== null && legacyValue !== undefined) {\n          return decodeStoredValue(legacyValue);\n        }\n      } catch (legacyError) {\n        console.warn('Unable to read preference from legacy localStorage', key, legacyError);\n      }\n    }\n  }\n  return null;\n}\n\nfunction parseStoredBoolean(value) {\n  if (value === null || value === undefined) {\n    return null;\n  }\n\n  if (typeof value === 'boolean') {\n    return value;\n  }\n\n  if (typeof value === 'number') {\n    if (Number.isNaN(value)) {\n      return null;\n    }\n    return value !== 0;\n  }\n\n  const normalized = String(value).trim().toLowerCase();\n  if (!normalized) {\n    return null;\n  }\n\n  if (normalized === 'true'\n    || normalized === '1'\n    || normalized === 'yes'\n    || normalized === 'on') {\n    return true;\n  }\n\n  if (normalized === 'false'\n    || normalized === '0'\n    || normalized === 'no'\n    || normalized === 'off') {\n    return false;\n  }\n\n  return null;\n}\n\nfunction interpretPrintPreferencesValue(rawValue) {\n  if (rawValue === null || rawValue === undefined) {\n    return null;\n  }\n\n  let serialized = null;\n  let candidate = rawValue;\n\n  if (typeof rawValue === 'string') {\n    const trimmed = rawValue.trim();\n    if (!trimmed) {\n      return null;\n    }\n    serialized = trimmed;\n    try {\n      candidate = JSON.parse(trimmed);\n    } catch (parseError) {\n      void parseError;\n      return { normalized: null, serialized };\n    }\n  }\n\n  if (!candidate || typeof candidate !== 'object') {\n    if (serialized) {\n      return { normalized: null, serialized };\n    }\n    return null;\n  }\n\n  const hasSectionsContainer =\n    typeof candidate.sections === 'object' && candidate.sections !== null;\n  const sectionsSource = hasSectionsContainer ? candidate.sections : candidate;\n  const sections = {};\n\n  if (sectionsSource && typeof sectionsSource === 'object') {\n    const sectionKeys = Object.keys(sectionsSource);\n    for (let index = 0; index < sectionKeys.length; index += 1) {\n      const sectionKey = sectionKeys[index];\n      const sectionValue = sectionsSource[sectionKey];\n      if (typeof sectionValue === 'boolean') {\n        sections[sectionKey] = sectionValue;\n      }\n    }\n  }\n\n  let layout = null;\n  if (typeof candidate.layout === 'string') {\n    const trimmedLayout = candidate.layout.trim();\n    if (trimmedLayout) {\n      layout = trimmedLayout;\n    }\n  }\n\n  if (!layout) {\n    layout = hasSectionsContainer ? 'standard' : 'rental';\n  }\n\n  const normalized = {\n    sections,\n    layout,\n  };\n\n  if (hasSectionsContainer) {\n    const candidateKeys = Object.keys(candidate);\n    for (let index = 0; index < candidateKeys.length; index += 1) {\n      const key = candidateKeys[index];\n      if (key === 'sections' || key === 'layout') {\n        continue;\n      }\n      normalized[key] = storageJsonDeepClone(candidate[key]);\n    }\n  }\n\n  return {\n    normalized,\n    serialized,\n  };\n}\n\nfunction collectPreferenceSnapshot() {\n  const preferences = {};\n\n  const darkMode = parseStoredBoolean(readLocalStorageValue('darkMode'));\n  if (darkMode !== null) {\n    preferences.darkMode = darkMode;\n  }\n\n  const pinkMode = parseStoredBoolean(readLocalStorageValue('pinkMode'));\n  if (pinkMode !== null) {\n    preferences.pinkMode = pinkMode;\n  }\n\n  const highContrast = parseStoredBoolean(readLocalStorageValue('highContrast'));\n  if (highContrast !== null) {\n    preferences.highContrast = highContrast;\n  }\n\n  const reduceMotion = parseStoredBoolean(readLocalStorageValue('reduceMotion'));\n  if (reduceMotion !== null) {\n    preferences.reduceMotion = reduceMotion;\n  }\n\n  const relaxedSpacing = parseStoredBoolean(readLocalStorageValue('relaxedSpacing'));\n  if (relaxedSpacing !== null) {\n    preferences.relaxedSpacing = relaxedSpacing;\n  }\n\n  const showAutoBackups = parseStoredBoolean(readLocalStorageValue('showAutoBackups'));\n  if (showAutoBackups !== null) {\n    preferences.showAutoBackups = showAutoBackups;\n  }\n\n  const accentColor = readLocalStorageValue('accentColor');\n  if (accentColor) {\n    preferences.accentColor = accentColor;\n  }\n\n  const fontSize = readLocalStorageValue('fontSize');\n  if (fontSize) {\n    preferences.fontSize = fontSize;\n  }\n\n  const fontFamily = readLocalStorageValue('fontFamily');\n  if (fontFamily) {\n    preferences.fontFamily = fontFamily;\n  }\n\n  const language = readLocalStorageValue('language');\n  if (language) {\n    preferences.language = language;\n  }\n\n  const mountVoltageKey = getMountVoltageStorageKeyName();\n  const mountVoltages = readLocalStorageValue(mountVoltageKey);\n  if (mountVoltages) {\n    if (mountVoltages === '[object Object]' || String(mountVoltages).includes('[object Object]')) {\n      if (typeof GLOBAL_SCOPE.DEFAULT_MOUNT_VOLTAGES !== 'undefined') {\n        preferences.mountVoltages = GLOBAL_SCOPE.DEFAULT_MOUNT_VOLTAGES;\n      } else {\n        preferences.mountVoltages = {\n          'V-Mount': { high: 14.4, low: 12 },\n          'Gold-Mount': { high: 14.4, low: 12 },\n          'B-Mount': { high: 33.6, low: 21.6 }\n        };\n      }\n    } else {\n      try {\n        preferences.mountVoltages = JSON.parse(mountVoltages);\n      } catch (voltageParseError) {\n        console.warn('Failed to parse stored mount voltages for backup', voltageParseError);\n        // Fallback to defaults if parsing fails\n        if (typeof GLOBAL_SCOPE.DEFAULT_MOUNT_VOLTAGES !== 'undefined') {\n          preferences.mountVoltages = GLOBAL_SCOPE.DEFAULT_MOUNT_VOLTAGES;\n        } else {\n          preferences.mountVoltages = {\n            'V-Mount': { high: 14.4, low: 12 },\n            'Gold-Mount': { high: 14.4, low: 12 },\n            'B-Mount': { high: 33.6, low: 21.6 }\n          };\n        }\n      }\n    }\n  }\n\n  const iosPwaHelpShown = parseStoredBoolean(readLocalStorageValue('iosPwaHelpShown'));\n  if (iosPwaHelpShown !== null) {\n    preferences.iosPwaHelpShown = iosPwaHelpShown;\n  }\n\n  const temperatureUnit = readLocalStorageValue(TEMPERATURE_UNIT_STORAGE_KEY_NAME);\n  if (temperatureUnit) {\n    preferences.temperatureUnit = temperatureUnit;\n  }\n\n  const focusScale = readLocalStorageValue(FOCUS_SCALE_STORAGE_KEY_NAME);\n  if (focusScale) {\n    preferences.focusScale = focusScale;\n  }\n\n  const cameraColorsRaw = readLocalStorageValue(CAMERA_COLOR_STORAGE_KEY);\n  if (cameraColorsRaw) {\n    let parsedCameraColors = null;\n    if (typeof cameraColorsRaw === 'string') {\n      const trimmedCameraColors = cameraColorsRaw.trim();\n      if (trimmedCameraColors) {\n        try {\n          parsedCameraColors = JSON.parse(trimmedCameraColors);\n        } catch (cameraColorParseError) {\n          console.warn('Failed to parse stored camera color preferences for backup', cameraColorParseError);\n          parsedCameraColors = null;\n        }\n      }\n    }\n\n    if (parsedCameraColors && typeof parsedCameraColors === 'object') {\n      preferences.cameraColors = storageJsonDeepClone(parsedCameraColors);\n    } else if (typeof cameraColorsRaw === 'string' && cameraColorsRaw.trim()) {\n      preferences.cameraColors = cameraColorsRaw;\n    }\n  }\n\n  const printPreferencesRaw = readLocalStorageValue(PRINT_PREFERENCES_STORAGE_KEY);\n  if (printPreferencesRaw !== null && printPreferencesRaw !== undefined) {\n    const interpretedPrintPreferences = interpretPrintPreferencesValue(printPreferencesRaw);\n    if (interpretedPrintPreferences) {\n      if (interpretedPrintPreferences.normalized) {\n        preferences[PRINT_PREFERENCES_STORAGE_KEY] = storageJsonDeepClone(\n          interpretedPrintPreferences.normalized,\n        );\n      } else if (interpretedPrintPreferences.serialized) {\n        preferences[PRINT_PREFERENCES_STORAGE_KEY] = interpretedPrintPreferences.serialized;\n      }\n    }\n  }\n\n  return preferences;\n}\n\nfunction normalizeCustomFontEntries(entries) {\n  if (!Array.isArray(entries)) {\n    return [];\n  }\n  return entries\n    .map((entry) => ({\n      id: entry && typeof entry.id === 'string' ? entry.id : null,\n      name: entry && typeof entry.name === 'string' ? entry.name : '',\n      data: entry && typeof entry.data === 'string' ? entry.data : '',\n    }))\n    .filter((entry) => entry.id && entry.name && entry.data);\n}\n\nfunction readStoredCustomFonts() {\n  const raw = readLocalStorageValue(getCustomFontStorageKeyName());\n  if (!raw) {\n    return [];\n  }\n\n  try {\n    const parsed = JSON.parse(raw);\n    return normalizeCustomFontEntries(parsed);\n  } catch (error) {\n    console.warn('Failed to parse stored custom fonts for backup', error);\n    return [];\n  }\n}\n\nlet backupVaultRecordCache = [];\n\nfunction normalizeBackupVaultMetadata(metadata) {\n  if (!metadata || typeof metadata !== 'object') {\n    return null;\n  }\n  const normalized = {};\n  if (typeof metadata.source === 'string' && metadata.source) {\n    normalized.source = metadata.source;\n  }\n  if (typeof metadata.reason === 'string' && metadata.reason) {\n    normalized.reason = metadata.reason;\n  }\n  if (typeof metadata.permissionState === 'string' && metadata.permissionState) {\n    normalized.permissionState = metadata.permissionState;\n  }\n  return Object.keys(normalized).length ? normalized : null;\n}\n\nfunction normalizeBackupVaultRecord(record) {\n  if (!record || typeof record !== 'object') {\n    return null;\n  }\n  const id = typeof record.id === 'string' ? record.id.trim() : '';\n  if (!id) {\n    return null;\n  }\n  const fileName = typeof record.fileName === 'string' && record.fileName\n    ? record.fileName\n    : 'cine-power-planner-backup.json';\n  const createdAtMs = typeof record.createdAtMs === 'number' && Number.isFinite(record.createdAtMs)\n    ? record.createdAtMs\n    : null;\n  const createdAt = typeof record.createdAt === 'string' && record.createdAt\n    ? record.createdAt\n    : (createdAtMs !== null ? new Date(createdAtMs).toISOString() : null);\n  let normalizedCreatedAtMs = createdAtMs;\n  if (normalizedCreatedAtMs === null && createdAt) {\n    const parsedTime = Date.parse(createdAt);\n    if (Number.isFinite(parsedTime)) {\n      normalizedCreatedAtMs = parsedTime;\n    }\n  }\n  if (normalizedCreatedAtMs === null) {\n    normalizedCreatedAtMs = Date.now();\n  }\n  const metadata = normalizeBackupVaultMetadata(record.metadata);\n  return {\n    id,\n    fileName,\n    payload: record.payload,\n    createdAt: createdAt || new Date(normalizedCreatedAtMs).toISOString(),\n    createdAtMs: normalizedCreatedAtMs,\n    metadata: metadata || {},\n  };\n}\n\nfunction normalizeBackupVaultRecordList(records) {\n  if (!records) {\n    return [];\n  }\n  let parsed = records;\n  if (typeof records === 'string') {\n    const parsedResult = tryParseJSONLike(records);\n    if (parsedResult && parsedResult.success) {\n      parsed = parsedResult.parsed;\n    }\n  }\n  const list = Array.isArray(parsed) ? parsed : [];\n  const normalized = [];\n  list.forEach((entry) => {\n    const normalizedEntry = normalizeBackupVaultRecord(entry);\n    if (normalizedEntry) {\n      normalized.push(normalizedEntry);\n    }\n  });\n  return normalized;\n}\n\nfunction scoreBackupVaultRecord(record) {\n  if (!record) {\n    return 0;\n  }\n  let score = 0;\n  if (record.payload !== null && record.payload !== undefined) {\n    score += 3;\n  }\n  if (typeof record.fileName === 'string' && record.fileName) {\n    score += 1;\n  }\n  if (typeof record.createdAt === 'string' && record.createdAt) {\n    score += 1;\n  }\n  if (typeof record.createdAtMs === 'number' && Number.isFinite(record.createdAtMs)) {\n    score += 1;\n  }\n  if (record.metadata && typeof record.metadata === 'object') {\n    score += 1;\n  }\n  return score;\n}\n\nfunction mergeBackupVaultRecords(existingList, incomingList) {\n  const merged = new Map();\n  const mergeList = (records) => {\n    if (!Array.isArray(records)) {\n      return;\n    }\n    records.forEach((record) => {\n      const normalized = normalizeBackupVaultRecord(record);\n      if (!normalized) {\n        return;\n      }\n      const existing = merged.get(normalized.id);\n      if (!existing || scoreBackupVaultRecord(normalized) >= scoreBackupVaultRecord(existing)) {\n        merged.set(normalized.id, normalized);\n      }\n    });\n  };\n  mergeList(existingList);\n  mergeList(incomingList);\n  return Array.from(merged.values());\n}\n\nfunction readBackupVaultFallbackRecords() {\n  const raw = readLocalStorageValue('cineBackupVaultFallbackRecords');\n  return normalizeBackupVaultRecordList(raw);\n}\n\nfunction resolveBackupVaultApi() {\n  if (GLOBAL_SCOPE && GLOBAL_SCOPE.cineFeatureBackup && typeof GLOBAL_SCOPE.cineFeatureBackup === 'object') {\n    return GLOBAL_SCOPE.cineFeatureBackup;\n  }\n  if (GLOBAL_SCOPE && typeof GLOBAL_SCOPE.getQueuedBackupPayloads === 'function') {\n    return GLOBAL_SCOPE;\n  }\n  return null;\n}\n\nfunction refreshBackupVaultRecordCache() {\n  const api = resolveBackupVaultApi();\n  if (!api) {\n    return;\n  }\n  const loader = typeof api.listBackupVaultRecords === 'function'\n    ? api.listBackupVaultRecords\n    : typeof api.getQueuedBackupPayloads === 'function'\n      ? api.getQueuedBackupPayloads\n      : null;\n  if (!loader) {\n    return;\n  }\n  let response = null;\n  try {\n    response = loader();\n  } catch (error) {\n    console.warn('Unable to load backup vault records for export', error);\n    return;\n  }\n  if (Array.isArray(response)) {\n    backupVaultRecordCache = normalizeBackupVaultRecordList(response);\n    return;\n  }\n  if (response && typeof response.then === 'function') {\n    return response.then((records) => {\n      backupVaultRecordCache = normalizeBackupVaultRecordList(records);\n      return backupVaultRecordCache;\n    }).catch((error) => {\n      console.warn('Unable to load backup vault records for export', error);\n      return [];\n    });\n  }\n  return Promise.resolve(backupVaultRecordCache);\n}\n\n\nfunction resolveAutoGearPersistence() {\n  if (GLOBAL_SCOPE && GLOBAL_SCOPE.cineAutoGearPersistence) {\n    return GLOBAL_SCOPE.cineAutoGearPersistence;\n  }\n  if (GLOBAL_SCOPE && GLOBAL_SCOPE.cineModules && typeof GLOBAL_SCOPE.cineModules.get === 'function') {\n    return GLOBAL_SCOPE.cineModules.get('cineAutoGearPersistence') || null;\n  }\n  return null;\n}\n\nfunction getAutoGearSnapshotFromCache() {\n  const persistence = resolveAutoGearPersistence();\n  if (!persistence) {\n    return null;\n  }\n  const snapshot = typeof persistence.getCacheSnapshot === 'function'\n    ? persistence.getCacheSnapshot()\n    : null;\n\n  const readValue = (key, fallback, readerName) => {\n    if (snapshot && Object.prototype.hasOwnProperty.call(snapshot, key)) {\n      return snapshot[key];\n    }\n    if (readerName && typeof persistence[readerName] === 'function') {\n      try {\n        return persistence[readerName]();\n      } catch (error) {\n        console.warn(`Failed to read ${key} from Auto-Gear persistence cache`, error);\n      }\n    }\n    return fallback;\n  };\n\n  return {\n    autoGearRules: readValue('autoGearRules', [], 'readAutoGearRules'),\n    autoGearBackups: readValue('autoGearBackups', [], 'readAutoGearBackups'),\n    autoGearPresets: readValue('autoGearPresets', [], 'readAutoGearPresets'),\n    autoGearMonitorDefaults: readValue('autoGearMonitorDefaults', {}, 'readAutoGearMonitorDefaults'),\n    autoGearActivePresetId: readValue('autoGearActivePresetId', '', 'readActivePresetId'),\n    autoGearAutoPresetId: readValue('autoGearAutoPresetId', '', 'readAutoPresetId'),\n    autoGearBackupRetention: readValue('autoGearBackupRetention', null, 'readBackupRetention'),\n    autoGearShowBackups: readValue('autoGearShowBackups', false, 'readBackupVisibility'),\n  };\n}\n\nasync function prepareBackupForExport() {\n  const records = await refreshBackupVaultRecordCache();\n  return records;\n}\n\nfunction exportAllData() {\n  refreshBackupVaultRecordCache();\n  const autoGearSnapshot = getAutoGearSnapshotFromCache();\n  const payload = {\n    devices: loadDeviceData(),\n    setups: loadSetups(),\n    session: loadSessionState(),\n    feedback: loadFeedback(),\n    project: (() => {\n      const rawProjects = loadProject();\n      if (!rawProjects || typeof rawProjects !== 'object') return {};\n\n      const sanitized = {};\n      Object.keys(rawProjects).forEach(key => {\n        const val = rawProjects[key];\n        // [Safety Check] - Prevent double serialization in JSON.stringify later\n        if (typeof val === 'string') {\n          try {\n            const parsed = JSON.parse(val);\n            // If parsing succeeds and it's an object, use that.\n            if (parsed && typeof parsed === 'object') {\n              sanitized[key] = parsed;\n            } else {\n              // If it parsed to a primitive (e.g. number/boolean), keep it (unlikely for projects but safe)\n              sanitized[key] = parsed;\n            }\n          } catch (parseError) {\n            console.warn('[Export] Found non-JSON string in project data', key);\n            // Verify if it's actually valid data (like simple string config) or corruption\n            // For projects, we expect objects. If it fails parse, it might be raw string data.\n            sanitized[key] = val;\n          }\n        } else {\n          sanitized[key] = val;\n        }\n      });\n      return sanitized;\n    })(),\n    favorites: loadFavorites(),\n    contacts: loadContacts(),\n    ownGear: ownGearCache || [],\n    userProfile: null,\n    autoGearRules: autoGearSnapshot ? autoGearSnapshot.autoGearRules : loadAutoGearRules(),\n    autoGearBackups: autoGearSnapshot ? autoGearSnapshot.autoGearBackups : loadAutoGearBackups(),\n    autoGearSeeded: loadAutoGearSeedFlag(),\n    autoGearPresets: autoGearSnapshot ? autoGearSnapshot.autoGearPresets : loadAutoGearPresets(),\n    autoGearMonitorDefaults: autoGearSnapshot ? autoGearSnapshot.autoGearMonitorDefaults : loadAutoGearMonitorDefaults(),\n    autoGearActivePresetId: autoGearSnapshot ? autoGearSnapshot.autoGearActivePresetId : loadAutoGearActivePresetId(),\n    autoGearAutoPresetId: autoGearSnapshot ? autoGearSnapshot.autoGearAutoPresetId : loadAutoGearAutoPresetId(),\n    autoGearShowBackups: autoGearSnapshot ? autoGearSnapshot.autoGearShowBackups : loadAutoGearBackupVisibility(),\n    autoGearBackupRetention: autoGearSnapshot ? autoGearSnapshot.autoGearBackupRetention : loadAutoGearBackupRetention(),\n    fullBackupHistory: loadFullBackupHistory(),\n  };\n\n  const documentationTracker = loadDocumentationTracker();\n  if (\n    documentationTracker &&\n    Array.isArray(documentationTracker.releases) &&\n    documentationTracker.releases.length\n  ) {\n    payload.documentationTracker = documentationTracker;\n  }\n\n  const preferences = collectPreferenceSnapshot();\n  if (Object.keys(preferences).length) {\n    payload.preferences = preferences;\n  }\n\n  const profile = loadUserProfile();\n  if (\n    profile\n    && typeof profile === 'object'\n    && (\n      (typeof profile.name === 'string' && profile.name)\n      || (typeof profile.role === 'string' && profile.role)\n      || (typeof profile.avatar === 'string' && profile.avatar)\n      || (typeof profile.phone === 'string' && profile.phone)\n      || (typeof profile.email === 'string' && profile.email)\n    )\n  ) {\n    payload.userProfile = profile;\n  } else {\n    delete payload.userProfile;\n  }\n\n  const customLogo = readLocalStorageValue(CUSTOM_LOGO_STORAGE_KEY);\n  if (customLogo) {\n    payload.customLogo = customLogo;\n  }\n\n  const customFonts = readStoredCustomFonts();\n  if (customFonts.length) {\n    payload.customFonts = customFonts;\n  }\n\n  const schemaCache = readLocalStorageValue(DEVICE_SCHEMA_CACHE_KEY);\n  if (schemaCache !== null && schemaCache !== undefined) {\n    payload.schemaCache = schemaCache;\n  }\n\n  const fallbackVaultRecords = readBackupVaultFallbackRecords();\n  const combinedVaultRecords = mergeBackupVaultRecords(\n    backupVaultRecordCache,\n    fallbackVaultRecords,\n  );\n  if (combinedVaultRecords.length) {\n    payload.backupVaultRecords = combinedVaultRecords.map((record) => storageJsonDeepClone(record));\n  }\n\n  return payload;\n}\n\nfunction safeSetLocalStorage(key, value) {\n  const storage = getSafeLocalStorage();\n  if (!storage) return;\n\n  const useBackup = RAW_STORAGE_BACKUP_KEYS.has(key);\n  const backupKey = `${key}${STORAGE_BACKUP_SUFFIX}`;\n  const isIndexedDB = Boolean(\n    storageRepo\n    && storageRepo.driver\n    && storageRepo.driver.constructor\n    && storageRepo.driver.constructor.name === 'IndexedDBAdapter',\n  );\n\n  // [Agent Fix] Hoisted keysWithMemoryCache to fix ReferenceError in writeLegacyStorage\n  const keysWithMemoryCache = new Set([\n    CUSTOM_FONT_STORAGE_KEY_DEFAULT,\n    CUSTOM_LOGO_STORAGE_KEY,\n    CAMERA_COLOR_STORAGE_KEY,\n    PRINT_PREFERENCES_STORAGE_KEY,\n    CONTACTS_STORAGE_KEY,\n    OWN_GEAR_STORAGE_KEY,\n    USER_PROFILE_STORAGE_KEY,\n    FAVORITES_STORAGE_KEY,\n    TEMPERATURE_UNIT_STORAGE_KEY_NAME,\n    FOCUS_SCALE_STORAGE_KEY_NAME,\n    TEMPERATURE_UNIT_STORAGE_KEY_NAME,\n    FOCUS_SCALE_STORAGE_KEY_NAME,\n    getMountVoltageStorageKeyName(),\n    FULL_BACKUP_HISTORY_STORAGE_KEY,\n    'darkMode',\n    'pinkMode',\n    'highContrast',\n    'reduceMotion',\n    'relaxedSpacing',\n    'showAutoBackups',\n    'accentColor',\n    'fontSize',\n    'fontFamily',\n    'language',\n    'iosPwaHelpShown',\n    DEVICE_SCHEMA_CACHE_KEY,\n    AUTO_GEAR_RULES_STORAGE_KEY,\n    AUTO_GEAR_BACKUPS_STORAGE_KEY,\n    AUTO_GEAR_PRESETS_STORAGE_KEY,\n    AUTO_GEAR_MONITOR_DEFAULTS_STORAGE_KEY,\n    AUTO_GEAR_BACKUP_RETENTION_STORAGE_KEY,\n    AUTO_GEAR_SEEDED_STORAGE_KEY,\n    AUTO_GEAR_ACTIVE_PRESET_STORAGE_KEY,\n    AUTO_GEAR_AUTO_PRESET_STORAGE_KEY,\n    AUTO_GEAR_BACKUP_VISIBILITY_STORAGE_KEY,\n  ]);\n\n  const clearCacheForKey = () => {\n    if (key === CUSTOM_FONT_STORAGE_KEY_DEFAULT) { customFontsCache = null; }\n    if (key === CUSTOM_LOGO_STORAGE_KEY) { customLogoCache = null; }\n    if (key === CAMERA_COLOR_STORAGE_KEY) { cameraColorsCache = null; }\n    if (key === PRINT_PREFERENCES_STORAGE_KEY) { printPreferencesCache = null; }\n    if (key === CONTACTS_STORAGE_KEY) { contactsCache = null; }\n    if (key === OWN_GEAR_STORAGE_KEY) { ownGearCache = null; }\n    if (key === USER_PROFILE_STORAGE_KEY) { userProfileCache = null; }\n    if (key === FAVORITES_STORAGE_KEY) { favoritesCache = null; }\n    if (key === TEMPERATURE_UNIT_STORAGE_KEY_NAME) { temperatureUnitCache = null; }\n    if (key === FOCUS_SCALE_STORAGE_KEY_NAME) { focusScaleCache = null; }\n    if (key === FOCUS_SCALE_STORAGE_KEY_NAME) { focusScaleCache = null; }\n    if (key === getMountVoltageStorageKeyName()) { mountVoltagesCache = null; }\n    if (key === FULL_BACKUP_HISTORY_STORAGE_KEY) { fullBackupHistoryCache = null; }\n  };\n\n  const writeLegacyStorage = (storedValue) => {\n    storage.setItem(key, storedValue);\n\n    // [Agent Fix] Sync to localStorage for Legacy Shim compatibility and Synchronous Preference Access\n    // Preference keys must ALWAYS be in localStorage for synchronous UI access (e.g. Dark Mode)\n    // We also sync other keys if they are in the memory cache allow-list\n    const isPreference = [\n      'darkMode', 'pinkMode', 'highContrast', 'reduceMotion', 'relaxedSpacing',\n      'showAutoBackups', 'accentColor', 'fontSize', 'fontFamily', 'language', 'iosPwaHelpShown',\n      DEVICE_SCHEMA_CACHE_KEY,\n      // Add other critical UI keys here\n    ].includes(key);\n\n    const shouldSyncToLegacy = isPreference || keysWithMemoryCache.has(key);\n\n    if (shouldSyncToLegacy) {\n      const legacyStorage = (typeof global !== 'undefined' && global.localStorage)\n        || (typeof window !== 'undefined' && window.localStorage)\n        || (typeof globalThis !== 'undefined' && globalThis.localStorage); // robustness\n\n      if (legacyStorage && legacyStorage !== storage) {\n        try {\n          legacyStorage.setItem(key, storedValue);\n        } catch (e) { void e; }\n      } else if (!legacyStorage) {\n        console.warn('DEBUG: legacyStorage NOT FOUND in writeLegacyStorage for', key);\n      }\n    }\n\n    if (useBackup) {\n      try {\n        storage.setItem(backupKey, storedValue);\n      } catch (backupError) {\n        console.warn('Unable to update backup key during import', backupKey, backupError);\n        downgradeSafeLocalStorageToMemory('write access', backupError, storage);\n        alertStorageError();\n      }\n    }\n  };\n\n  try {\n    if (value === null || value === undefined) {\n      clearCacheForKey();\n      if (storageRepo) {\n        storageRepo.removeItem(key).catch(e => console.warn('Failed to remove key from repo', key, e));\n      }\n      storage.removeItem(key);\n\n      // [Agent Fix] Sync to localStorage for Legacy Shim compatibility\n      const legacyStorage = (typeof global !== 'undefined' && global.localStorage)\n        || (typeof window !== 'undefined' && window.localStorage);\n      if (legacyStorage && legacyStorage !== storage) {\n        try { legacyStorage.removeItem(key); } catch (e) { void e; }\n      }\n\n      if (useBackup) {\n        try {\n          storage.removeItem(backupKey);\n        } catch (backupError) {\n          console.warn('Unable to remove backup key during import', backupKey, backupError);\n          downgradeSafeLocalStorageToMemory('deletion', backupError, storage);\n        }\n      }\n    } else {\n      const storedValue = String(value);\n\n      // [Agent Refactor] Intercept & Persist Branding Keys\n      if (key === CUSTOM_FONT_STORAGE_KEY_DEFAULT) { customFontsCache = storedValue; }\n      if (key === CUSTOM_LOGO_STORAGE_KEY) { customLogoCache = storedValue; }\n      if (key === CAMERA_COLOR_STORAGE_KEY) { cameraColorsCache = storedValue; }\n      if (key === PRINT_PREFERENCES_STORAGE_KEY) { printPreferencesCache = storedValue; }\n      if (key === CONTACTS_STORAGE_KEY) { contactsCache = storedValue; }\n      if (key === OWN_GEAR_STORAGE_KEY) { ownGearCache = storedValue; }\n      if (key === USER_PROFILE_STORAGE_KEY) { userProfileCache = storedValue; }\n      if (key === FAVORITES_STORAGE_KEY) { favoritesCache = storedValue; }\n      if (key === TEMPERATURE_UNIT_STORAGE_KEY_NAME) { temperatureUnitCache = storedValue; }\n      if (key === FOCUS_SCALE_STORAGE_KEY_NAME) { focusScaleCache = storedValue; }\n      if (key === FOCUS_SCALE_STORAGE_KEY_NAME) { focusScaleCache = storedValue; }\n      if (key === getMountVoltageStorageKeyName()) { mountVoltagesCache = storedValue; }\n      if (key === FULL_BACKUP_HISTORY_STORAGE_KEY) { fullBackupHistoryCache = JSON.parse(storedValue); }\n\n      if (storageRepo) {\n        storageRepo.setItem(key, storedValue).catch(e => {\n          console.warn('Failed to save key to repo', key, e);\n          try {\n            writeLegacyStorage(storedValue);\n          } catch (legacyError) {\n            console.warn('Unable to persist fallback legacy storage key during repo failure', key, legacyError);\n            downgradeSafeLocalStorageToMemory('write access', legacyError, storage);\n            if (useBackup) {\n              alertStorageError();\n            }\n          }\n        });\n      }\n\n\n      // Optimization: For IDB, we generally rely on the async write above.\n      // BUT, for preference keys and memory-cached keys, we MUST also write to localStorage synchronously\n      // [Agent Change] - Legacy Shim Compatibility\n      // We removed the optimization that skipped LS writes for non-cached keys.\n      // console.log('DEBUG: calling writeLegacyStorage for', key, storedValue);\n      // Ensure we have a valid storage reference for legacy writes\n      try {\n        writeLegacyStorage(storedValue);\n      } catch (legacyWriteError) {\n        console.warn('DEBUG: writeLegacyStorage failed', legacyWriteError);\n      }\n    }\n  } catch (error) {\n    console.warn('Unable to persist storage key during import', key, error);\n    downgradeSafeLocalStorageToMemory('write access', error, storage);\n    if (useBackup) {\n      alertStorageError();\n    }\n  }\n}\n\nfunction normalizeImportedBoolean(value) {\n  if (typeof value === \"boolean\") {\n    return value;\n  }\n\n  if (typeof value === \"string\") {\n    const normalized = value.trim().toLowerCase();\n    if (!normalized) {\n      return null;\n    }\n    if (normalized === \"true\" || normalized === \"1\" || normalized === \"yes\" || normalized === \"on\") {\n      return true;\n    }\n    if (normalized === \"false\" || normalized === \"0\" || normalized === \"no\" || normalized === \"off\") {\n      return false;\n    }\n    return null;\n  }\n\n  if (typeof value === \"number\") {\n    if (Number.isNaN(value)) {\n      return null;\n    }\n    return value !== 0;\n  }\n\n  if (Array.isArray(value)) {\n    for (let i = 0; i < value.length; i += 1) {\n      const normalized = normalizeImportedBoolean(value[i]);\n      if (normalized !== null) {\n        return normalized;\n      }\n    }\n    return null;\n  }\n\n  if (isPlainObject(value)) {\n    if (Object.prototype.hasOwnProperty.call(value, \"value\")) {\n      return normalizeImportedBoolean(value.value);\n    }\n    if (Object.prototype.hasOwnProperty.call(value, \"enabled\")) {\n      return normalizeImportedBoolean(value.enabled);\n    }\n  }\n\n  return null;\n}\n\nfunction normalizeImportedArray(value, fallbackKeys = [], filterFn = null) {\n  if (isMapLike(value)) {\n    const converted = convertMapLikeToObject(value);\n    if (converted) {\n      return normalizeImportedArray(converted, fallbackKeys, filterFn);\n    }\n    return [];\n  }\n\n  if (Array.isArray(value)) {\n    return filterFn\n      ? value.filter((entry) => filterFn(entry))\n      : value.filter((entry) => entry !== null && entry !== undefined);\n  }\n\n  if (typeof value === \"string\") {\n    const parsed = tryParseJSONLike(value);\n    if (parsed.success) {\n      return normalizeImportedArray(parsed.parsed, fallbackKeys, filterFn);\n    }\n    return [];\n  }\n\n  if (isPlainObject(value)) {\n    for (let i = 0; i < fallbackKeys.length; i += 1) {\n      const key = fallbackKeys[i];\n      if (!Object.prototype.hasOwnProperty.call(value, key)) {\n        continue;\n      }\n      const extracted = normalizeImportedArray(value[key], fallbackKeys, filterFn);\n      if (extracted.length) {\n        return extracted;\n      }\n    }\n\n    const entries = Object.values(value);\n    if (entries.length) {\n      return filterFn\n        ? entries.filter((entry) => filterFn(entry))\n        : entries.filter((entry) => entry !== null && entry !== undefined);\n    }\n  }\n\n  return [];\n}\n\nfunction normalizeImportedContacts(value) {\n  const entries = normalizeImportedArray(\n    value,\n    ['contacts', 'entries', 'items', 'list', 'values', 'data'],\n    (entry) => entry && typeof entry === 'object',\n  );\n  if (!Array.isArray(entries)) {\n    return [];\n  }\n  return normalizeContactsList(entries);\n}\n\nfunction normalizeImportedAutoGearRules(value) {\n  const rules = normalizeImportedArray(\n    value,\n    [\"rules\", \"items\", \"entries\", \"list\", \"values\", \"data\"],\n    (entry) => entry !== null && typeof entry === \"object\",\n  );\n  if (!Array.isArray(rules)) {\n    return [];\n  }\n  return normalizeLegacyLongGopStructure(rules);\n}\n\nfunction normalizeImportedAutoGearBackups(value) {\n  const backups = normalizeImportedArray(\n    value,\n    [\"backups\", \"entries\", \"items\", \"list\", \"values\", \"data\"],\n    (entry) => entry !== null && typeof entry === \"object\",\n  );\n  if (!Array.isArray(backups)) {\n    return [];\n  }\n  const { normalized } = normalizeLegacyLongGopBackups(backups);\n  return normalized;\n}\n\nfunction normalizeImportedAutoGearBackupRetention(value) {\n  if (value === null || value === undefined) {\n    return null;\n  }\n  if (typeof value === 'number') {\n    return clampAutoGearBackupRetention(value);\n  }\n  if (typeof value === 'string') {\n    const trimmed = value.trim();\n    if (!trimmed) {\n      return null;\n    }\n    const direct = Number(trimmed);\n    if (Number.isFinite(direct)) {\n      return clampAutoGearBackupRetention(direct);\n    }\n    const parsed = tryParseJSONLike(trimmed);\n    if (parsed && parsed.success) {\n      return normalizeImportedAutoGearBackupRetention(parsed.parsed);\n    }\n    return null;\n  }\n  if (Array.isArray(value)) {\n    for (let i = 0; i < value.length; i += 1) {\n      const candidate = normalizeImportedAutoGearBackupRetention(value[i]);\n      if (typeof candidate === 'number') {\n        return candidate;\n      }\n    }\n    return null;\n  }\n  if (isPlainObject(value)) {\n    const candidateKeys = ['value', 'retention', 'limit', 'count'];\n    for (let i = 0; i < candidateKeys.length; i += 1) {\n      const key = candidateKeys[i];\n      if (!Object.prototype.hasOwnProperty.call(value, key)) {\n        continue;\n      }\n      const candidate = normalizeImportedAutoGearBackupRetention(value[key]);\n      if (typeof candidate === 'number') {\n        return candidate;\n      }\n    }\n    return null;\n  }\n  if (typeof value === 'boolean') {\n    return value ? AUTO_GEAR_BACKUP_RETENTION_MIN : null;\n  }\n  return null;\n}\n\nfunction normalizeImportedAutoGearPresets(value) {\n  const presets = normalizeImportedArray(\n    value,\n    [\"presets\", \"entries\", \"items\", \"list\", \"values\", \"data\"],\n    (entry) => entry !== null && typeof entry === \"object\",\n  );\n  if (!Array.isArray(presets)) {\n    return [];\n  }\n  return normalizeLegacyLongGopStructure(presets);\n}\n\nfunction normalizeImportedAutoGearMonitorDefaults(value) {\n  if (!value || typeof value !== 'object') {\n    return {};\n  }\n  const normalized = {};\n  Object.entries(value).forEach(([key, val]) => {\n    if (typeof val !== 'string') return;\n    const trimmed = val.trim();\n    if (!trimmed) return;\n    normalized[key] = trimmed;\n  });\n  const legacyNormalized = normalizeLegacyLongGopStructure(normalized);\n  return isPlainObject(legacyNormalized) ? legacyNormalized : normalized;\n}\n\nfunction normalizeImportedPresetId(value) {\n  if (typeof value === \"string\") {\n    return value;\n  }\n  if (typeof value === \"number\") {\n    return Number.isNaN(value) ? \"\" : String(value);\n  }\n  if (Array.isArray(value)) {\n    for (let i = 0; i < value.length; i += 1) {\n      const candidate = normalizeImportedPresetId(value[i]);\n      if (candidate) {\n        return candidate;\n      }\n    }\n    return \"\";\n  }\n  if (isPlainObject(value)) {\n    if (typeof value.id === \"string\" && value.id) {\n      return value.id;\n    }\n    if (typeof value.value === \"string\") {\n      return value.value;\n    }\n    if (Object.prototype.hasOwnProperty.call(value, \"name\")) {\n      return normalizeImportedPresetId(value.name);\n    }\n  }\n  return \"\";\n}\n\nfunction normalizeImportedBackupVaultRecords(value) {\n  const records = normalizeImportedArray(\n    value,\n    ['backupVaultRecords', 'backupVault', 'vault', 'records', 'entries', 'items', 'list', 'values', 'data'],\n    (entry) => entry && typeof entry === 'object',\n  );\n  return normalizeBackupVaultRecordList(records);\n}\n\nfunction importBackupVaultRecords(records) {\n  const normalized = normalizeBackupVaultRecordList(records);\n  if (!normalized.length) {\n    return;\n  }\n\n  const existingFallback = readBackupVaultFallbackRecords();\n  const mergedFallback = mergeBackupVaultRecords(existingFallback, normalized);\n  try {\n    safeSetLocalStorage('cineBackupVaultFallbackRecords', JSON.stringify(mergedFallback));\n  } catch (storageError) {\n    console.warn('Unable to persist imported backup vault fallback records', storageError);\n  }\n\n  const api = resolveBackupVaultApi();\n  if (!api || typeof api.queueBackupPayloadForVault !== 'function') {\n    return;\n  }\n\n  const queueRecord = (record) => {\n    api.queueBackupPayloadForVault(\n      record.fileName,\n      record.payload,\n      {\n        id: record.id,\n        createdAt: record.createdAt,\n        createdAtMs: record.createdAtMs,\n        source: record.metadata && record.metadata.source ? record.metadata.source : undefined,\n        reason: record.metadata && record.metadata.reason ? record.metadata.reason : undefined,\n        permissionState: record.metadata && record.metadata.permissionState\n          ? record.metadata.permissionState\n          : undefined,\n      },\n    );\n  };\n\n  const loader = typeof api.listBackupVaultRecords === 'function'\n    ? api.listBackupVaultRecords\n    : typeof api.getQueuedBackupPayloads === 'function'\n      ? api.getQueuedBackupPayloads\n      : null;\n\n  if (!loader) {\n    normalized.forEach(queueRecord);\n    return;\n  }\n\n  try {\n    const response = loader();\n    if (Array.isArray(response)) {\n      const existingIds = new Set(response.map((entry) => (entry && entry.id ? entry.id : null)));\n      normalized.forEach((record) => {\n        if (!existingIds.has(record.id)) {\n          queueRecord(record);\n        }\n      });\n      return;\n    }\n    if (response && typeof response.then === 'function') {\n      response.then((existing) => {\n        const existingIds = new Set(\n          Array.isArray(existing)\n            ? existing.map((entry) => (entry && entry.id ? entry.id : null))\n            : [],\n        );\n        normalized.forEach((record) => {\n          if (!existingIds.has(record.id)) {\n            queueRecord(record);\n          }\n        });\n      }).catch((error) => {\n        console.warn('Unable to inspect backup vault before import', error);\n        normalized.forEach(queueRecord);\n      });\n      return;\n    }\n    normalized.forEach(queueRecord);\n  } catch (error) {\n    console.warn('Unable to import backup vault records via backup module', error);\n    normalized.forEach(queueRecord);\n  }\n}\n\nfunction getSnapshotKeyVariants(key) {\n  return getStorageKeyVariants(key);\n}\n\nfunction readSnapshotEntry(snapshot, key) {\n  if (!isPlainObject(snapshot)) {\n    return null;\n  }\n\n  const variants = getSnapshotKeyVariants(key);\n  for (let i = 0; i < variants.length; i += 1) {\n    const candidate = variants[i];\n    if (Object.prototype.hasOwnProperty.call(snapshot, candidate)) {\n      return { key: candidate, value: snapshot[candidate], type: 'primary' };\n    }\n  }\n\n  for (let i = 0; i < variants.length; i += 1) {\n    const candidate = `${variants[i]}${STORAGE_BACKUP_SUFFIX}`;\n    if (Object.prototype.hasOwnProperty.call(snapshot, candidate)) {\n      return { key: candidate, value: snapshot[candidate], type: 'backup' };\n    }\n  }\n\n  for (let i = 0; i < variants.length; i += 1) {\n    const candidate = `${variants[i]}${STORAGE_MIGRATION_BACKUP_SUFFIX}`;\n    console.log('DEBUG: readSnapshotEntry checking migration candidate', candidate, Object.prototype.hasOwnProperty.call(snapshot, candidate));\n    if (Object.prototype.hasOwnProperty.call(snapshot, candidate)) {\n      console.log('DEBUG: readSnapshotEntry FOUND migration backup', candidate);\n      return { key: candidate, value: snapshot[candidate], type: 'migration-backup' };\n    }\n  }\n\n  return null;\n}\n\nfunction extractSnapshotStoredValue(entry) {\n  if (!entry) {\n    return undefined;\n  }\n\n  let raw = entry.value;\n  if (entry.type === 'migration-backup') {\n    try {\n      const parsed = typeof raw === 'string' ? JSON.parse(raw) : raw;\n      if (parsed && typeof parsed === 'object') {\n        const compressionToken = typeof parsed.compression === 'string' ? parsed.compression.trim() : '';\n        const encodingToken = typeof parsed.encoding === 'string' ? parsed.encoding.trim() : '';\n        const isModernCompression =\n          compressionToken === MIGRATION_BACKUP_COMPRESSION_ALGORITHM\n          && encodingToken === MIGRATION_BACKUP_COMPRESSION_ENCODING;\n        const isLegacyLongGopCompression =\n          LEGACY_LONG_GOP_TOKEN_REGEX.test(compressionToken)\n          || LEGACY_LONG_GOP_TOKEN_REGEX.test(encodingToken);\n\n        if ((isModernCompression || isLegacyLongGopCompression) && typeof parsed.data === 'string') {\n          if (canUseMigrationBackupCompression()) {\n            let preferredVariant = typeof parsed.compressionVariant === 'string'\n              && parsed.compressionVariant\n              ? parsed.compressionVariant\n              : null;\n            if (!preferredVariant) {\n              if (isLegacyLongGopCompression) {\n                preferredVariant = inferLegacyLongGopCompressionVariant(encodingToken)\n                  || inferLegacyLongGopCompressionVariant(compressionToken)\n                  || 'utf16';\n              } else {\n                preferredVariant = 'utf16';\n              }\n            }\n            const decoded = tryDecompressWithStrategies(\n              parsed.data,\n              MIGRATION_BACKUP_COMPRESSION_VARIANTS,\n              preferredVariant,\n              'migration backup entry',\n            );\n            if (decoded.success && typeof decoded.value === 'string') {\n              try {\n                const payload = JSON.parse(decoded.value);\n                if (payload && typeof payload === 'object' && Object.prototype.hasOwnProperty.call(payload, 'data')) {\n                  raw = payload.data;\n                } else {\n                  raw = null;\n                }\n              } catch (parseError) {\n                console.log('DEBUG: extractSnapshotStoredValue parse error', parseError);\n                raw = null;\n              }\n            } else {\n              console.log('DEBUG: extractSnapshotStoredValue decompression failed', decoded);\n              console.warn('Unable to decompress migration backup entry during import', entry && entry.key, decoded.error);\n              raw = null;\n            }\n          } else {\n            console.log('DEBUG: extractSnapshotStoredValue compression unavailable');\n            console.warn('Compression support is unavailable while reading migration backup entry', entry && entry.key);\n            raw = null;\n          }\n        } else if (Object.prototype.hasOwnProperty.call(parsed, 'data')) {\n          raw = parsed.data;\n        } else {\n          raw = null;\n        }\n      } else {\n        raw = null;\n      }\n    } catch (error) {\n      console.warn('Unable to parse migration backup entry during import', entry.key, error);\n      raw = null;\n    }\n  }\n\n  return raw;\n}\n\nfunction parseSnapshotJSONValue(entry) {\n  const raw = extractSnapshotStoredValue(entry);\n  if (raw === undefined) {\n    return undefined;\n  }\n  if (raw === null) {\n    return null;\n  }\n  if (typeof raw === 'string') {\n    const decoded = decodeStoredValue(raw);\n    if (decoded === null) {\n      return null;\n    }\n    if (decoded === undefined) {\n      return undefined;\n    }\n    if (typeof decoded !== 'string') {\n      return decoded;\n    }\n    const trimmed = decoded.trim();\n    if (!trimmed) {\n      return '';\n    }\n    try {\n      return JSON.parse(trimmed);\n    } catch {\n      return decoded;\n    }\n  }\n  return raw;\n}\n\nfunction parseSnapshotStringValue(entry) {\n  const raw = extractSnapshotStoredValue(entry);\n  if (raw === undefined) {\n    return undefined;\n  }\n  if (raw === null) {\n    return null;\n  }\n  if (typeof raw === 'string') {\n    const decoded = decodeStoredValue(raw);\n    if (decoded === null) {\n      return null;\n    }\n    if (decoded === undefined) {\n      return undefined;\n    }\n    if (typeof decoded === 'string') {\n      return decoded;\n    }\n    if (typeof decoded === 'number' || typeof decoded === 'boolean') {\n      return String(decoded);\n    }\n    if (Array.isArray(decoded) || (decoded && typeof decoded === 'object')) {\n      try {\n        return JSON.stringify(decoded);\n      } catch (serializationError) {\n        console.warn('Unable to serialize snapshot entry during import', entry && entry.key, serializationError);\n        return null;\n      }\n    }\n    return null;\n  }\n  if (typeof raw === 'number' || typeof raw === 'boolean') {\n    return String(raw);\n  }\n  if (Array.isArray(raw) || (raw && typeof raw === 'object')) {\n    try {\n      return JSON.stringify(raw);\n    } catch (serializationError) {\n      console.warn('Unable to serialize snapshot entry during import', entry && entry.key, serializationError);\n      return null;\n    }\n  }\n  return null;\n}\n\nfunction convertStorageSnapshotToData(snapshot) {\n  if (!isPlainObject(snapshot)) {\n    return null;\n  }\n\n  const exportStructureKeys = [\n    'devices',\n    'setups',\n    'session',\n    'feedback',\n    'favorites',\n    'contacts',\n    'preferences',\n    'project',\n    'projects',\n    'autoGearRules',\n    'autoGearBackups',\n    'autoGearPresets',\n    'autoGearMonitorDefaults',\n    'autoGearSeeded',\n    'autoGearActivePresetId',\n    'autoGearAutoPresetId',\n    'autoGearBackupRetention',\n    'autoGearShowBackups',\n    'fullBackupHistory',\n    'fullBackups',\n    'backupVaultRecords',\n  ];\n\n  const resemblesExportPayload = exportStructureKeys.some((key) =>\n    Object.prototype.hasOwnProperty.call(snapshot, key),\n  );\n\n  if (resemblesExportPayload) {\n    return null;\n  }\n\n  const data = {};\n  let hasAssignments = false;\n  let hasSnapshotKeys = false;\n\n  const preferenceKeys = [\n    'darkMode',\n    'pinkMode',\n    'highContrast',\n    'reduceMotion',\n    'relaxedSpacing',\n    'showAutoBackups',\n    'accentColor',\n    'fontSize',\n    'fontFamily',\n    'language',\n    'iosPwaHelpShown',\n    CAMERA_COLOR_STORAGE_KEY,\n    PRINT_PREFERENCES_STORAGE_KEY,\n  ];\n\n  const mountVoltageKeyName = getMountVoltageStorageKeyName();\n  const simpleSnapshotKeys = new Set(\n    [CUSTOM_LOGO_STORAGE_KEY, ...preferenceKeys, mountVoltageKeyName].filter(\n      (key) => typeof key === 'string' && key,\n    ),\n  );\n\n  const booleanPreferenceKeys = new Set([\n    'darkMode',\n    'pinkMode',\n    'highContrast',\n    'reduceMotion',\n    'relaxedSpacing',\n    'showAutoBackups',\n    'iosPwaHelpShown',\n  ]);\n\n  const markSnapshotEntry = (entry) => {\n    if (!entry || typeof entry.key !== 'string') {\n      return;\n    }\n    if (\n      entry.key.startsWith('cameraPowerPlanner_') ||\n      entry.key.startsWith('cinePowerPlanner_') ||\n      entry.key.endsWith(STORAGE_BACKUP_SUFFIX) ||\n      entry.key.endsWith(STORAGE_MIGRATION_BACKUP_SUFFIX)\n    ) {\n      hasSnapshotKeys = true;\n      return;\n    }\n\n    const normalizedKey = entry.key.replace(/(?:__backup|__legacyMigrationBackup)$/u, '');\n    if (simpleSnapshotKeys.has(normalizedKey)) {\n      hasSnapshotKeys = true;\n    }\n  };\n\n  const assignJSONValue = (storageKey, targetKey) => {\n    const entry = readSnapshotEntry(snapshot, storageKey);\n    if (!entry) {\n      return;\n    }\n    markSnapshotEntry(entry);\n    const value = parseSnapshotJSONValue(entry);\n    if (value === undefined) {\n      return;\n    }\n    data[targetKey] = value;\n    hasAssignments = true;\n  };\n\n  assignJSONValue(DEVICE_STORAGE_KEY, 'devices');\n  assignJSONValue(SETUP_STORAGE_KEY, 'setups');\n  assignJSONValue(SESSION_STATE_KEY, 'session');\n  assignJSONValue(FEEDBACK_STORAGE_KEY, 'feedback');\n  assignJSONValue(PROJECT_STORAGE_KEY, 'project');\n  assignJSONValue(FAVORITES_STORAGE_KEY, 'favorites');\n  assignJSONValue(CONTACTS_STORAGE_KEY, 'contacts');\n  assignJSONValue(OWN_GEAR_STORAGE_KEY, 'ownGear');\n  assignJSONValue(USER_PROFILE_STORAGE_KEY, 'userProfile');\n  assignJSONValue(DOCUMENTATION_TRACKER_STORAGE_KEY, 'documentationTracker');\n  assignJSONValue(AUTO_GEAR_RULES_STORAGE_KEY, 'autoGearRules');\n  assignJSONValue(AUTO_GEAR_BACKUPS_STORAGE_KEY, 'autoGearBackups');\n  assignJSONValue(AUTO_GEAR_PRESETS_STORAGE_KEY, 'autoGearPresets');\n  assignJSONValue(AUTO_GEAR_MONITOR_DEFAULTS_STORAGE_KEY, 'autoGearMonitorDefaults');\n  assignJSONValue(AUTO_GEAR_BACKUP_RETENTION_STORAGE_KEY, 'autoGearBackupRetention');\n\n  const schemaEntry = readSnapshotEntry(snapshot, DEVICE_SCHEMA_CACHE_KEY);\n  if (schemaEntry) {\n    markSnapshotEntry(schemaEntry);\n    const cacheValue = parseSnapshotStringValue(schemaEntry);\n    if (cacheValue !== undefined) {\n      data.schemaCache = cacheValue;\n      hasAssignments = true;\n    }\n  }\n\n  const customFontsEntry = readSnapshotEntry(snapshot, getCustomFontStorageKeyName());\n  if (customFontsEntry) {\n    markSnapshotEntry(customFontsEntry);\n    const fontsValue = parseSnapshotJSONValue(customFontsEntry);\n    if (fontsValue !== undefined) {\n      data.customFonts = fontsValue;\n      hasAssignments = true;\n    }\n  }\n\n  const customLogoEntry = readSnapshotEntry(snapshot, CUSTOM_LOGO_STORAGE_KEY);\n  if (customLogoEntry) {\n    markSnapshotEntry(customLogoEntry);\n    const logoValue = parseSnapshotStringValue(customLogoEntry);\n    if (logoValue !== undefined) {\n      data.customLogo = logoValue;\n      hasAssignments = true;\n    }\n  }\n\n  const seedEntry = readSnapshotEntry(snapshot, AUTO_GEAR_SEEDED_STORAGE_KEY);\n  if (seedEntry) {\n    markSnapshotEntry(seedEntry);\n    data.autoGearSeeded = extractSnapshotStoredValue(seedEntry);\n    hasAssignments = true;\n  }\n\n  const activePresetEntry = readSnapshotEntry(snapshot, AUTO_GEAR_ACTIVE_PRESET_STORAGE_KEY);\n  if (activePresetEntry) {\n    markSnapshotEntry(activePresetEntry);\n    data.autoGearActivePresetId = parseSnapshotStringValue(activePresetEntry);\n    hasAssignments = true;\n  }\n\n  const autoPresetEntry = readSnapshotEntry(snapshot, AUTO_GEAR_AUTO_PRESET_STORAGE_KEY);\n  if (autoPresetEntry) {\n    markSnapshotEntry(autoPresetEntry);\n    data.autoGearAutoPresetId = parseSnapshotStringValue(autoPresetEntry);\n    hasAssignments = true;\n  }\n\n  const backupsVisibilityEntry = readSnapshotEntry(snapshot, AUTO_GEAR_BACKUP_VISIBILITY_STORAGE_KEY);\n  if (backupsVisibilityEntry) {\n    markSnapshotEntry(backupsVisibilityEntry);\n    data.autoGearShowBackups = extractSnapshotStoredValue(backupsVisibilityEntry);\n    hasAssignments = true;\n  }\n\n  const preferences = {};\n\n  preferenceKeys.forEach((key) => {\n    const entry = readSnapshotEntry(snapshot, key);\n    if (!entry) {\n      return;\n    }\n    markSnapshotEntry(entry);\n    if (key === PRINT_PREFERENCES_STORAGE_KEY) {\n      const snapshotPrintValue = parseSnapshotStringValue(entry);\n      if (snapshotPrintValue !== undefined) {\n        const interpretedPreferences = interpretPrintPreferencesValue(snapshotPrintValue);\n        if (interpretedPreferences) {\n          if (interpretedPreferences.normalized) {\n            preferences[key] = storageJsonDeepClone(interpretedPreferences.normalized);\n            hasAssignments = true;\n            return;\n          }\n          if (interpretedPreferences.serialized) {\n            preferences[key] = interpretedPreferences.serialized;\n            hasAssignments = true;\n            return;\n          }\n        }\n      }\n      return;\n    }\n    const raw = extractSnapshotStoredValue(entry);\n    if (booleanPreferenceKeys.has(key)) {\n      const normalized = normalizeImportedBoolean(raw);\n      if (normalized !== null) {\n        preferences[key] = normalized;\n        hasAssignments = true;\n        return;\n      }\n    }\n    const stringValue = parseSnapshotStringValue(entry);\n    if (stringValue !== undefined) {\n      preferences[key] = stringValue;\n      hasAssignments = true;\n    }\n  });\n\n  const temperatureUnitEntry = readSnapshotEntry(snapshot, TEMPERATURE_UNIT_STORAGE_KEY_NAME);\n  if (temperatureUnitEntry) {\n    markSnapshotEntry(temperatureUnitEntry);\n    const storedUnit = parseSnapshotStringValue(temperatureUnitEntry);\n    if (typeof storedUnit === 'string') {\n      const normalizedUnit = storedUnit.trim();\n      if (normalizedUnit) {\n        preferences.temperatureUnit = normalizedUnit;\n        hasAssignments = true;\n      }\n    }\n  }\n\n  const focusScaleEntry = readSnapshotEntry(snapshot, FOCUS_SCALE_STORAGE_KEY_NAME);\n  if (focusScaleEntry) {\n    markSnapshotEntry(focusScaleEntry);\n    const storedScale = parseSnapshotStringValue(focusScaleEntry);\n    if (typeof storedScale === 'string') {\n      const normalizedScale = storedScale.trim();\n      if (normalizedScale) {\n        preferences.focusScale = normalizedScale;\n        hasAssignments = true;\n      }\n    }\n  }\n\n  const cameraColorsEntry = readSnapshotEntry(snapshot, CAMERA_COLOR_STORAGE_KEY);\n  if (cameraColorsEntry) {\n    markSnapshotEntry(cameraColorsEntry);\n    const storedCameraColors = parseSnapshotJSONValue(cameraColorsEntry);\n    if (storedCameraColors !== undefined) {\n      preferences.cameraColors = storedCameraColors;\n      hasAssignments = true;\n    }\n  }\n\n  const mountVoltageEntry = readSnapshotEntry(snapshot, mountVoltageKeyName);\n  if (mountVoltageEntry) {\n    markSnapshotEntry(mountVoltageEntry);\n    const storedVoltages = parseSnapshotJSONValue(mountVoltageEntry);\n    if (storedVoltages !== undefined) {\n      preferences.mountVoltages = storedVoltages;\n      hasAssignments = true;\n    }\n  }\n\n  if (Object.keys(preferences).length > 0) {\n    data.preferences = preferences;\n  }\n\n  if (!hasAssignments || !hasSnapshotKeys) {\n    return null;\n  }\n\n  return data;\n}\n\nfunction importAllData(allData, options = {}) {\n  console.error('DEBUG: importAllData CALLED', Object.keys(allData));\n  if (Array.isArray(allData)) {\n    importProjectCollection(allData, () => createProjectImporter());\n    return;\n  }\n\n  if (!isPlainObject(allData)) {\n    return;\n  }\n\n  const { skipSnapshotConversion = false } = options || {};\n\n  if (!skipSnapshotConversion) {\n    const converted = convertStorageSnapshotToData(allData);\n    if (converted) {\n      importAllData(converted, { skipSnapshotConversion: true });\n      return;\n    }\n  }\n\n  const hasOwn = (key) => Object.prototype.hasOwnProperty.call(allData, key);\n  const mountVoltageKeyName = getMountVoltageStorageKeyName();\n  const cameraColorKeyName = CAMERA_COLOR_STORAGE_KEY;\n\n  const autoGearPersistence = resolveAutoGearPersistence();\n  const persistAutoGearValue = (methodName, fallbackFn, value) => {\n    if (autoGearPersistence && typeof autoGearPersistence[methodName] === 'function') {\n      try {\n        autoGearPersistence[methodName](value);\n        return true;\n      } catch (error) {\n        console.warn(`Failed to persist Auto-Gear value with ${methodName}`, error);\n      }\n    }\n    if (typeof fallbackFn === 'function') {\n      fallbackFn(value);\n    }\n    return false;\n  };\n\n  if (hasOwn('devices')) {\n    saveDeviceData(allData.devices);\n  }\n  if (hasOwn('setups')) {\n    saveSetups(allData.setups);\n  }\n  if (hasOwn('session')) {\n    saveSessionState(allData.session, { disableCompression: true });\n  }\n  if (hasOwn('feedback')) {\n    saveFeedback(allData.feedback);\n  }\n  if (hasOwn('favorites')) {\n    saveFavorites(allData.favorites);\n  }\n  if (hasOwn('contacts')) {\n    if (allData.contacts === null) {\n      saveContacts(null);\n    } else {\n      const contacts = normalizeImportedContacts(allData.contacts);\n      saveContacts(contacts);\n    }\n  }\n  if (hasOwn('ownGear')) {\n    const entries = normalizeImportedArray(\n      allData.ownGear,\n      ['items', 'entries', 'list', 'values', 'data'],\n      (entry) => entry && typeof entry === 'object',\n    );\n    saveOwnGear(entries);\n  }\n  if (hasOwn('userProfile')) {\n    if (allData.userProfile === null) {\n      saveUserProfile(null);\n    } else if (isPlainObject(allData.userProfile)) {\n      const profile = normalizeUserProfile(allData.userProfile);\n      if (profile) {\n        saveUserProfile(profile);\n      } else {\n        saveUserProfile(null);\n      }\n    }\n  }\n  if (isPlainObject(allData.preferences)) {\n    const prefs = allData.preferences;\n    const booleanPrefs = [\n      'darkMode',\n      'pinkMode',\n      'highContrast',\n      'reduceMotion',\n      'relaxedSpacing',\n      'showAutoBackups',\n      'iosPwaHelpShown',\n    ];\n    booleanPrefs.forEach((key) => {\n      if (Object.prototype.hasOwnProperty.call(prefs, key) && typeof prefs[key] === 'boolean') {\n        safeSetLocalStorage(key, prefs[key]);\n      }\n    });\n    const stringPrefs = ['accentColor', 'fontSize', 'fontFamily', 'language'];\n    stringPrefs.forEach((key) => {\n      if (Object.prototype.hasOwnProperty.call(prefs, key)) {\n        const value = prefs[key];\n        if (typeof value === 'string' && value) {\n          safeSetLocalStorage(key, value);\n        }\n      }\n    });\n\n    if (Object.prototype.hasOwnProperty.call(prefs, 'temperatureUnit')) {\n      const unit = prefs.temperatureUnit;\n      if (typeof unit === 'string') {\n        const normalizedUnit = unit.trim();\n        if (normalizedUnit) {\n          safeSetLocalStorage(TEMPERATURE_UNIT_STORAGE_KEY_NAME, normalizedUnit);\n        }\n      } else if (unit === null) {\n        safeSetLocalStorage(TEMPERATURE_UNIT_STORAGE_KEY_NAME, null);\n      }\n    }\n    if (Object.prototype.hasOwnProperty.call(prefs, 'focusScale')) {\n      const scale = prefs.focusScale;\n      if (typeof scale === 'string') {\n        const normalizedScale = scale.trim();\n        if (normalizedScale) {\n          safeSetLocalStorage(FOCUS_SCALE_STORAGE_KEY_NAME, normalizedScale);\n          if (typeof window !== 'undefined' && typeof window.applyFocusScalePreference === 'function') {\n            try {\n              window.applyFocusScalePreference(normalizedScale, { persist: false, forceUpdate: true });\n            } catch (focusScaleError) {\n              console.warn('Unable to apply imported focus scale preference', focusScaleError);\n            }\n          }\n        }\n      } else if (scale === null) {\n        safeSetLocalStorage(FOCUS_SCALE_STORAGE_KEY_NAME, null);\n      }\n    }\n    if (Object.prototype.hasOwnProperty.call(prefs, PRINT_PREFERENCES_STORAGE_KEY)) {\n      const rawPrintPreferences = prefs[PRINT_PREFERENCES_STORAGE_KEY];\n      if (rawPrintPreferences === null) {\n        safeSetLocalStorage(PRINT_PREFERENCES_STORAGE_KEY, null);\n      } else {\n        const interpretedPreferences = interpretPrintPreferencesValue(rawPrintPreferences);\n        if (interpretedPreferences) {\n          if (interpretedPreferences.normalized) {\n            const normalizedPrintPreferences = storageJsonDeepClone(\n              interpretedPreferences.normalized,\n            );\n            let serializedPrintPreferences = null;\n            try {\n              serializedPrintPreferences = JSON.stringify(normalizedPrintPreferences);\n            } catch (printPreferenceSerializationError) {\n              console.warn(\n                'Unable to serialize imported print preferences',\n                printPreferenceSerializationError,\n              );\n              serializedPrintPreferences = null;\n            }\n            if (serializedPrintPreferences !== null) {\n              try {\n                safeSetLocalStorage(PRINT_PREFERENCES_STORAGE_KEY, serializedPrintPreferences);\n              } catch (printPreferencePersistError) {\n                console.warn(\n                  'Unable to persist imported print preferences',\n                  printPreferencePersistError,\n                );\n              }\n            }\n            if (typeof window !== 'undefined' && typeof window.savePrintPreferences === 'function') {\n              try {\n                window.savePrintPreferences(normalizedPrintPreferences);\n              } catch (printPreferenceApplyError) {\n                console.warn(\n                  'Unable to apply imported print preferences',\n                  printPreferenceApplyError,\n                );\n              }\n            }\n          } else if (interpretedPreferences.serialized) {\n            try {\n              safeSetLocalStorage(\n                PRINT_PREFERENCES_STORAGE_KEY,\n                interpretedPreferences.serialized,\n              );\n            } catch (printPreferenceStringPersistError) {\n              console.warn(\n                'Unable to store imported print preferences string value',\n                printPreferenceStringPersistError,\n              );\n            }\n          }\n        }\n      }\n    }\n    if (Object.prototype.hasOwnProperty.call(prefs, 'mountVoltages')) {\n      const rawVoltages = prefs.mountVoltages;\n      if (rawVoltages && typeof rawVoltages === 'object') {\n        try {\n          safeSetLocalStorage(mountVoltageKeyName, JSON.stringify(rawVoltages));\n        } catch (voltStoreError) {\n          console.warn('Unable to store imported mount voltages', voltStoreError);\n        }\n        if (typeof window !== 'undefined' && typeof window.applyMountVoltagePreferences === 'function') {\n          window.applyMountVoltagePreferences(rawVoltages, { persist: false, triggerUpdate: true });\n        }\n      } else if (typeof rawVoltages === 'string') {\n        safeSetLocalStorage(mountVoltageKeyName, rawVoltages);\n        if (typeof window !== 'undefined' && typeof window.parseStoredMountVoltages === 'function') {\n          try {\n            const parsedVoltages = window.parseStoredMountVoltages(rawVoltages);\n            if (parsedVoltages && typeof window.applyMountVoltagePreferences === 'function') {\n              window.applyMountVoltagePreferences(parsedVoltages, { persist: false, triggerUpdate: true });\n            }\n          } catch (voltParseError) {\n            console.warn('Unable to parse imported mount voltages', voltParseError);\n          }\n        }\n      } else if (rawVoltages === null) {\n        safeSetLocalStorage(mountVoltageKeyName, null);\n        if (typeof window !== 'undefined' && typeof window.resetMountVoltagePreferences === 'function') {\n          window.resetMountVoltagePreferences({ persist: false, triggerUpdate: true });\n        }\n      }\n    }\n    if (Object.prototype.hasOwnProperty.call(prefs, 'cameraColors')) {\n      const rawCameraColors = prefs.cameraColors;\n      const applyImportedCameraColors = (palette) => {\n        if (!palette || typeof palette !== 'object') {\n          return false;\n        }\n\n        let applied = false;\n        if (typeof window !== 'undefined' && window && typeof window.setCameraLetterColors === 'function') {\n          try {\n            window.setCameraLetterColors(palette);\n            applied = true;\n          } catch (cameraColorApplyError) {\n            console.warn('Unable to apply imported camera color preferences', cameraColorApplyError);\n            applied = false;\n          }\n        }\n\n        let serializedPalette = null;\n        try {\n          serializedPalette = JSON.stringify(palette);\n        } catch (cameraColorSerializeError) {\n          console.warn('Unable to serialize imported camera color preferences', cameraColorSerializeError);\n          serializedPalette = null;\n        }\n\n        if (serializedPalette) {\n          try {\n            safeSetLocalStorage(cameraColorKeyName, serializedPalette);\n          } catch (cameraColorPersistError) {\n            console.warn('Unable to persist imported camera color preferences', cameraColorPersistError);\n          }\n        }\n\n        return applied;\n      };\n\n      if (rawCameraColors && typeof rawCameraColors === 'object') {\n        applyImportedCameraColors(rawCameraColors);\n      } else if (typeof rawCameraColors === 'string') {\n        const trimmedCameraColors = rawCameraColors.trim();\n        if (trimmedCameraColors) {\n          let parsedCameraColors = null;\n          try {\n            parsedCameraColors = JSON.parse(trimmedCameraColors);\n          } catch (cameraColorParseError) {\n            console.warn('Unable to parse imported camera color palette', cameraColorParseError);\n            parsedCameraColors = null;\n          }\n          if (parsedCameraColors && typeof parsedCameraColors === 'object') {\n            applyImportedCameraColors(parsedCameraColors);\n          } else {\n            try {\n              safeSetLocalStorage(cameraColorKeyName, trimmedCameraColors);\n            } catch (cameraColorStoreError) {\n              console.warn('Unable to store raw imported camera color palette', cameraColorStoreError);\n            }\n          }\n        }\n      } else if (rawCameraColors === null) {\n        safeSetLocalStorage(cameraColorKeyName, null);\n      }\n    }\n  }\n  if (Object.prototype.hasOwnProperty.call(allData, 'customLogo')) {\n    const logo = allData.customLogo;\n    if (typeof logo === 'string' && logo) {\n      safeSetLocalStorage(CUSTOM_LOGO_STORAGE_KEY, logo);\n    } else {\n      safeSetLocalStorage(CUSTOM_LOGO_STORAGE_KEY, null);\n    }\n  }\n  if (Object.prototype.hasOwnProperty.call(allData, 'customFonts')) {\n    const fonts = normalizeCustomFontEntries(allData.customFonts);\n    if (fonts.length) {\n      try {\n        safeSetLocalStorage(\n          getCustomFontStorageKeyName(),\n          JSON.stringify(fonts)\n        );\n      } catch (error) {\n        console.warn('Unable to store imported custom fonts', error);\n      }\n    } else {\n      safeSetLocalStorage(getCustomFontStorageKeyName(), null);\n    }\n  }\n  if (Object.prototype.hasOwnProperty.call(allData, 'schemaCache')) {\n    const cache = allData.schemaCache;\n    if (typeof cache === 'string' || cache === null) {\n      safeSetLocalStorage(DEVICE_SCHEMA_CACHE_KEY, cache);\n    } else if (cache && typeof cache === 'object') {\n      try {\n        safeSetLocalStorage(DEVICE_SCHEMA_CACHE_KEY, JSON.stringify(cache));\n      } catch (schemaError) {\n        console.warn('Unable to store imported schema cache', schemaError);\n      }\n    }\n  }\n  if (Object.prototype.hasOwnProperty.call(allData, 'documentationTracker')) {\n    const trackerState = normalizeDocumentationTrackerState(allData.documentationTracker);\n    saveDocumentationTracker(trackerState);\n  } else if (Object.prototype.hasOwnProperty.call(allData, 'documentationLogs')) {\n    const trackerFromLogs = normalizeDocumentationTrackerState({ releases: allData.documentationLogs });\n    saveDocumentationTracker(trackerFromLogs);\n  } else if (Object.prototype.hasOwnProperty.call(allData, 'documentationUpdateLog')) {\n    const trackerFromLegacy = normalizeDocumentationTrackerState(allData.documentationUpdateLog);\n    saveDocumentationTracker(trackerFromLegacy);\n  }\n  if (Object.prototype.hasOwnProperty.call(allData, 'autoGearRules')) {\n    const rules = normalizeImportedAutoGearRules(allData.autoGearRules);\n    persistAutoGearValue('persistAutoGearRules', saveAutoGearRules, rules);\n  }\n  if (Object.prototype.hasOwnProperty.call(allData, 'autoGearBackups')) {\n    const backups = normalizeImportedAutoGearBackups(allData.autoGearBackups);\n    persistAutoGearValue('persistAutoGearBackups', saveAutoGearBackups, backups);\n  }\n  if (Object.prototype.hasOwnProperty.call(allData, 'autoGearSeeded')) {\n    const flag = normalizeImportedBoolean(allData.autoGearSeeded);\n    if (flag === null) {\n      saveAutoGearSeedFlag(false);\n    } else {\n      saveAutoGearSeedFlag(flag);\n    }\n  }\n  if (Object.prototype.hasOwnProperty.call(allData, 'autoGearPresets')) {\n    const presets = normalizeImportedAutoGearPresets(allData.autoGearPresets);\n    persistAutoGearValue('persistAutoGearPresets', saveAutoGearPresets, presets);\n  }\n  if (Object.prototype.hasOwnProperty.call(allData, 'autoGearMonitorDefaults')) {\n    const defaults = normalizeImportedAutoGearMonitorDefaults(allData.autoGearMonitorDefaults);\n    persistAutoGearValue('persistAutoGearMonitorDefaults', saveAutoGearMonitorDefaults, defaults);\n  }\n  if (Object.prototype.hasOwnProperty.call(allData, 'autoGearActivePresetId')) {\n    const presetId = normalizeImportedPresetId(allData.autoGearActivePresetId);\n    persistAutoGearValue('persistActivePresetId', saveAutoGearActivePresetId, typeof presetId === 'string' ? presetId : '');\n  }\n  if (Object.prototype.hasOwnProperty.call(allData, 'autoGearAutoPresetId')) {\n    const presetId = typeof allData.autoGearAutoPresetId === 'string' ? allData.autoGearAutoPresetId : '';\n    persistAutoGearValue('persistAutoPresetId', saveAutoGearAutoPresetId, presetId);\n  }\n  if (Object.prototype.hasOwnProperty.call(allData, 'autoGearShowBackups')) {\n    const visibility = normalizeImportedBoolean(allData.autoGearShowBackups);\n    const normalizedVisibility = visibility === null ? false : visibility;\n    persistAutoGearValue('persistBackupVisibility', saveAutoGearBackupVisibility, normalizedVisibility);\n  }\n  if (Object.prototype.hasOwnProperty.call(allData, 'autoGearBackupRetention')) {\n    const retention = normalizeImportedAutoGearBackupRetention(allData.autoGearBackupRetention);\n    if (typeof retention === 'number' && Number.isFinite(retention)) {\n      persistAutoGearValue('persistBackupRetention', saveAutoGearBackupRetention, retention);\n    }\n  }\n\n  if (Object.prototype.hasOwnProperty.call(allData, 'fullBackupHistory')) {\n    const history = normalizeImportedFullBackupHistory(allData.fullBackupHistory);\n    saveFullBackupHistory(history);\n  } else if (Object.prototype.hasOwnProperty.call(allData, 'fullBackups')) {\n    const history = normalizeImportedFullBackupHistory(allData.fullBackups);\n    saveFullBackupHistory(history);\n  }\n  if (Object.prototype.hasOwnProperty.call(allData, 'backupVaultRecords')) {\n    const backupRecords = normalizeImportedBackupVaultRecords(allData.backupVaultRecords);\n    importBackupVaultRecords(backupRecords);\n  } else if (Object.prototype.hasOwnProperty.call(allData, 'backupVault')) {\n    const backupRecords = normalizeImportedBackupVaultRecords(allData.backupVault);\n    importBackupVaultRecords(backupRecords);\n  }\n\n  let importProjectEntry = null;\n  const ensureProjectImporter = () => {\n    if (!importProjectEntry) {\n      importProjectEntry = createProjectImporter();\n    }\n    return importProjectEntry;\n  };\n\n  let projectImported = false;\n  const getTrackedImporter = () => {\n    const importer = ensureProjectImporter();\n    return (name, project, fallback) => {\n      projectImported = true;\n      importer(name, project, fallback);\n    };\n  };\n\n  const importTrackedCollection = (collection, fallbackLabel) => {\n    const wrapped = () => getTrackedImporter();\n    const result = importProjectCollection(collection, wrapped, fallbackLabel);\n    if (result) {\n      projectImported = true;\n    }\n    return result;\n  };\n\n  if (allData.project) {\n    importTrackedCollection(allData.project, \"\");\n  }\n  if (allData.projects) {\n    // Legacy plural key. Accept object map or array of named projects.\n    importTrackedCollection(allData.projects);\n  } else if (!allData.project && typeof allData.gearList === \"string\") {\n    // Legacy export format stored just the gear list HTML\n    getTrackedImporter()(\"\", { gearList: allData.gearList });\n    projectImported = true;\n  }\n\n  if (!projectImported) {\n    const legacyCollections = collectLegacyProjectCollections(allData);\n    legacyCollections.forEach((collection, index) => {\n      if (collection && typeof collection === \"object\" && !Array.isArray(collection)) {\n        const normalized = isNormalizedProjectEntry(collection)\n          ? collection\n          : normalizeProject(collection);\n        if (normalized && isNormalizedProjectEntry(normalized)) {\n          getTrackedImporter()(\"\", normalized, `Imported project ${index + 1}`);\n          projectImported = true;\n          return;\n        }\n      }\n\n      const imported = importProjectCollection(\n        collection,\n        () => getTrackedImporter(),\n        `Imported project ${index + 1}`,\n      );\n      if (imported) {\n        projectImported = true;\n      }\n    });\n  }\n}\n\n\n/**\n * Expose internal project cache for synchronous reads (LegacyShim support)\n */\nfunction getProjectMemoryCache() {\n  return projectMemoryCache;\n}\n\nvar STORAGE_API = {\n  getSafeLocalStorage,\n  loadDeviceData,\n  saveDeviceData,\n  loadSetups,\n  saveSetups,\n  saveSetup,\n  loadSetup,\n  deleteSetup,\n  renameSetup,\n  safeSetLocalStorage,\n  readLocalStorageValue,\n  getMountVoltageStorageKeyName,\n  getMountVoltageStorageBackupKeyName,\n  getProjectStorageRevisionKeyName,\n  loadProjectStorageRevision,\n  loadProject,\n  loadProjectMetadata,\n  saveProject,\n  deleteProject,\n  renameProject,\n  createProjectDeletionBackup,\n  loadSessionState,\n  saveSessionState,\n  loadFavorites,\n  saveFavorites,\n  loadContacts,\n  saveContacts,\n  loadOwnGear,\n  saveOwnGear,\n  loadUserProfile,\n  saveUserProfile,\n  loadDocumentationTracker,\n  saveDocumentationTracker,\n  loadAutoGearBackups,\n  saveAutoGearBackups,\n  loadFeedback,\n  saveFeedback,\n  clearAllData,\n  exportAllData,\n  prepareBackupForExport,\n  importAllData,\n  loadAutoGearRules,\n  saveAutoGearRules,\n  loadAutoGearSeedFlag,\n  saveAutoGearSeedFlag,\n  loadAutoGearPresets,\n  saveAutoGearPresets,\n  loadAutoGearMonitorDefaults,\n  saveAutoGearMonitorDefaults,\n  loadAutoGearActivePresetId,\n  saveAutoGearActivePresetId,\n  loadAutoGearAutoPresetId,\n  saveAutoGearAutoPresetId,\n  loadAutoGearBackupVisibility,\n  saveAutoGearBackupVisibility,\n  loadAutoGearBackupRetention,\n  saveAutoGearBackupRetention,\n  getAutoGearBackupRetentionDefault,\n  loadFullBackupHistory,\n  saveFullBackupHistory,\n  recordFullBackupHistoryEntry,\n  requestPersistentStorage,\n  clearUiCacheStorageEntries,\n  ensureCriticalStorageBackups,\n  getLastCriticalStorageGuardResult,\n  decodeStoredValue,\n  getCompressionLogSnapshot,\n  setActiveProjectCompressionHold,\n  clearActiveProjectCompressionHold,\n  invalidateProjectReadCache,\n  getProjectMemoryCache,\n  storageRepo,\n};\n\nvar TEST_ONLY_AUTO_BACKUP_COMPRESSION_CACHE = {\n  flag: AUTO_BACKUP_PAYLOAD_COMPRESSION_FLAG,\n  read: readAutoBackupCompressionCache,\n  write: writeAutoBackupCompressionCache,\n  clear: resetAutoBackupCompressionCache,\n};\n\ntry {\n  Object.defineProperty(STORAGE_API, '__testAutoBackupCompressionCache', {\n    configurable: false,\n    enumerable: false,\n    writable: false,\n    value: TEST_ONLY_AUTO_BACKUP_COMPRESSION_CACHE,\n  });\n} catch (testHelperDefinitionError) {\n  STORAGE_API.__testAutoBackupCompressionCache = TEST_ONLY_AUTO_BACKUP_COMPRESSION_CACHE;\n  void testHelperDefinitionError;\n}\n\nif (typeof module !== \"undefined\" && module.exports) {\n  module.exports = STORAGE_API;\n}\n\nconsole.log('DEBUG: storage.js: starting global export loop');\nif (GLOBAL_SCOPE && typeof GLOBAL_SCOPE === 'object') {\n\n  Object.keys(STORAGE_API).forEach((key) => {\n    const value = STORAGE_API[key];\n    if (typeof value !== 'function') {\n      return;\n    }\n    if (typeof GLOBAL_SCOPE[key] === 'function') {\n      return;\n    }\n    try {\n      GLOBAL_SCOPE[key] = value;\n    } catch (assignmentError) {\n      void assignmentError;\n      try {\n        Object.defineProperty(GLOBAL_SCOPE, key, {\n          configurable: true,\n          writable: true,\n          value,\n        });\n      } catch (definitionError) {\n        if (typeof console !== 'undefined' && typeof console.warn === 'function') {\n          console.warn(`Unable to expose storage helper ${key} globally.`, definitionError);\n        }\n      }\n    }\n  });\n\n  try {\n    if (typeof GLOBAL_SCOPE.recordFullBackupHistoryEntry !== 'function') {\n      GLOBAL_SCOPE.recordFullBackupHistoryEntry = recordFullBackupHistoryEntry;\n    }\n    if (typeof GLOBAL_SCOPE.loadFullBackupHistory !== 'function') {\n      GLOBAL_SCOPE.loadFullBackupHistory = loadFullBackupHistory;\n    }\n  } catch (ex) {\n    void ex;\n  }\n}\n\nif (GLOBAL_SCOPE) {\n  try {\n    Object.defineProperty(GLOBAL_SCOPE, '__cineStorageApi', {\n      configurable: true,\n      writable: true,\n      value: STORAGE_API,\n    });\n  } catch (storageApiExposeError) {\n    GLOBAL_SCOPE.__cineStorageApi = STORAGE_API;\n    void storageApiExposeError;\n  }\n}\n\nconsole.log('DEBUG: storage.js execution finished');\n// }) ();\n\nexport const cineStorage = STORAGE_API;\nexport default STORAGE_API;\n","/**\n * The persistence module centralises every interaction with the underlying\n * storage helpers. The goal is to make it obvious which execution context is\n * currently responsible for safeguarding the project data. By explaining each\n * discovery step we help future maintainers reason about why data looks for a\n * specific bridge or linker before touching user content.\n */\n\nimport cineModules from './registry.js';\nimport * as cineStorage from '../storage.js';\nimport { detectGlobalScope } from './helpers/scope-utils.js';\n\n/**\n * DEEP DIVE: Persistence Layer vs Storage Layer\n *\n * It is crucial to distinguish `persistence.js` from `storage.js`:\n *\n * 1. storage.js (The \"Driver\"):\n *    - Handles raw I/O (localStorage.getItem, JSON.parse).\n *    - Doesn't know *when* or *why* to save, only *how*.\n *\n * 2. persistence.js (The \"Manager\"):\n *    - Defines the POLICY (Auto-save on change? Throttle saves? Retry on failure?).\n *    - Orchestrates the flow between the application state and the storage driver.\n *    - Handles cross-cutting concerns like migration triggers and error boundaries.\n */\nconst FALLBACK_SCOPE = detectGlobalScope();\n\n/**\n * Locate the module linker that wires the loosely coupled runtime together.\n * We rely on global scope injection for legacy linker support.\n */\nfunction resolveModuleLinker(scope) {\n  const candidates = [scope];\n  if (typeof globalThis !== 'undefined' && candidates.indexOf(globalThis) === -1) candidates.push(globalThis);\n  if (typeof window !== 'undefined' && candidates.indexOf(window) === -1) candidates.push(window);\n  if (typeof self !== 'undefined' && candidates.indexOf(self) === -1) candidates.push(self);\n  if (typeof global !== 'undefined' && candidates.indexOf(global) === -1) candidates.push(global);\n\n  for (let index = 0; index < candidates.length; index += 1) {\n    const candidate = candidates[index];\n    try {\n      const linker = candidate && candidate.cineModuleLinker;\n      if (linker && typeof linker === 'object') {\n        return linker;\n      }\n    } catch (error) {\n      void error;\n    }\n  }\n\n  return null;\n}\n\n/**\n * If the linker cannot provide an environment instance we still want to keep\n * the storage layer operational. The fallback loader walks through familiar\n * scopes and reuses the environment that was already injected there.\n */\nfunction fallbackLoadModuleEnvironment(scope) {\n  const candidates = [scope];\n  if (typeof globalThis !== 'undefined' && candidates.indexOf(globalThis) === -1) candidates.push(globalThis);\n  if (typeof window !== 'undefined' && candidates.indexOf(window) === -1) candidates.push(window);\n  if (typeof self !== 'undefined' && candidates.indexOf(self) === -1) candidates.push(self);\n  if (typeof global !== 'undefined' && candidates.indexOf(global) === -1) candidates.push(global);\n\n  for (let index = 0; index < candidates.length; index += 1) {\n    const candidate = candidates[index];\n    if (candidate && typeof candidate.cineModuleEnvironment === 'object') {\n      return candidate.cineModuleEnvironment;\n    }\n  }\n\n  return null;\n}\n\n/**\n * The environment bridge contains helpers for cross-context communication.\n * When it is not injected by the linker we replicate the same discovery\n * strategy as with the environment itself so offline mode keeps functioning.\n */\nfunction fallbackLoadEnvironmentBridge(scope) {\n  const candidates = [scope];\n  if (typeof globalThis !== 'undefined' && candidates.indexOf(globalThis) === -1) candidates.push(globalThis);\n  if (typeof window !== 'undefined' && candidates.indexOf(window) === -1) candidates.push(window);\n  if (typeof self !== 'undefined' && candidates.indexOf(self) === -1) candidates.push(self);\n  if (typeof global !== 'undefined' && candidates.indexOf(global) === -1) candidates.push(global);\n\n  for (let index = 0; index < candidates.length; index += 1) {\n    const candidate = candidates[index];\n    if (candidate && typeof candidate.cineEnvironmentBridge === 'object') {\n      return candidate.cineEnvironmentBridge;\n    }\n  }\n\n  return null;\n}\n\nconst MODULE_LINKER = resolveModuleLinker(FALLBACK_SCOPE);\n\nconst MODULE_ENV = MODULE_LINKER && typeof MODULE_LINKER.getModuleEnvironment === 'function'\n  ? MODULE_LINKER.getModuleEnvironment()\n  : fallbackLoadModuleEnvironment(FALLBACK_SCOPE);\n\nconst ENV_BRIDGE = MODULE_LINKER && typeof MODULE_LINKER.getEnvironmentBridge === 'function'\n  ? MODULE_LINKER.getEnvironmentBridge()\n  : fallbackLoadEnvironmentBridge(FALLBACK_SCOPE);\n\nconst GLOBAL_SCOPE = (MODULE_LINKER && typeof MODULE_LINKER.getGlobalScope === 'function'\n  ? MODULE_LINKER.getGlobalScope()\n  : null)\n  || (ENV_BRIDGE && typeof ENV_BRIDGE.getGlobalScope === 'function'\n    ? ENV_BRIDGE.getGlobalScope()\n    : null)\n  || (MODULE_ENV && typeof MODULE_ENV.getGlobalScope === 'function'\n    ? MODULE_ENV.getGlobalScope()\n    : null)\n  || FALLBACK_SCOPE;\n\n/**\n * Module globals store shared singletons such as the persistence registry.\n * Accessing them through this helper keeps accidental global mutations away\n * from user projects because we never touch a missing object directly.\n */\nfunction fallbackResolveModuleGlobals() {\n  const candidates = [GLOBAL_SCOPE];\n  if (typeof globalThis !== 'undefined' && candidates.indexOf(globalThis) === -1) candidates.push(globalThis);\n  if (typeof window !== 'undefined' && candidates.indexOf(window) === -1) candidates.push(window);\n  if (typeof self !== 'undefined' && candidates.indexOf(self) === -1) candidates.push(self);\n  if (typeof global !== 'undefined' && candidates.indexOf(global) === -1) candidates.push(global);\n\n  for (let index = 0; index < candidates.length; index += 1) {\n    const candidate = candidates[index];\n    if (candidate && typeof candidate.cineModuleGlobals === 'object') {\n      return candidate.cineModuleGlobals;\n    }\n  }\n\n  return null;\n}\n\nconst MODULE_GLOBALS = (MODULE_LINKER && typeof MODULE_LINKER.getModuleGlobals === 'function'\n  ? MODULE_LINKER.getModuleGlobals()\n  : null)\n  || fallbackResolveModuleGlobals();\n\n/**\n * Let the runtime know which APIs are available so other modules can reuse\n * them without creating duplicate instances. The explicit guard rails ensure\n * the registration is a no-op when the host does not support bookkeeping.\n */\nfunction informModuleGlobals(name, api) {\n  if (MODULE_LINKER && typeof MODULE_LINKER.recordModule === 'function') {\n    MODULE_LINKER.recordModule(name, api);\n  }\n\n  if (!MODULE_GLOBALS || typeof MODULE_GLOBALS.recordModule !== 'function') {\n    return;\n  }\n\n  try {\n    MODULE_GLOBALS.recordModule(name, api);\n  } catch (error) {\n    void error;\n  }\n}\n\nfunction fallbackTryRequire(modulePath) {\n  // ESM cannot support synchronous dynamic require.\n  // This fallback assumes the module is not available if not imported via ESM.\n  return null;\n}\n\nconst tryRequire = (function resolveTryRequire() {\n  if (MODULE_LINKER && typeof MODULE_LINKER.tryRequire === 'function') {\n    return MODULE_LINKER.tryRequire;\n  }\n\n  if (MODULE_GLOBALS && typeof MODULE_GLOBALS.tryRequire === 'function') {\n    return MODULE_GLOBALS.tryRequire;\n  }\n\n  if (ENV_BRIDGE && typeof ENV_BRIDGE.tryRequire === 'function') {\n    return function bridgeTryRequire(modulePath) {\n      const result = ENV_BRIDGE.tryRequire(modulePath);\n      return typeof result === 'undefined' ? fallbackTryRequire(modulePath) : result;\n    };\n  }\n\n  if (MODULE_ENV && typeof MODULE_ENV.tryRequire === 'function') {\n    return MODULE_ENV.tryRequire;\n  }\n\n  return fallbackTryRequire;\n})();\n\nfunction resolveModuleRegistry(scope) {\n  const targetScope = scope || GLOBAL_SCOPE;\n\n  if (MODULE_LINKER && typeof MODULE_LINKER.getModuleRegistry === 'function') {\n    const linked = MODULE_LINKER.getModuleRegistry(targetScope);\n    if (linked) {\n      return linked;\n    }\n  }\n\n  if (MODULE_GLOBALS && typeof MODULE_GLOBALS.resolveModuleRegistry === 'function') {\n    try {\n      const resolved = MODULE_GLOBALS.resolveModuleRegistry(targetScope);\n      if (resolved) {\n        return resolved;\n      }\n    } catch (error) {\n      void error;\n    }\n  }\n\n  if (ENV_BRIDGE && typeof ENV_BRIDGE.getModuleRegistry === 'function') {\n    try {\n      const bridged = ENV_BRIDGE.getModuleRegistry(targetScope);\n      if (bridged) {\n        return bridged;\n      }\n    } catch (error) {\n      void error;\n    }\n  }\n\n  if (MODULE_ENV && typeof MODULE_ENV.resolveModuleRegistry === 'function') {\n    try {\n      const provided = MODULE_ENV.resolveModuleRegistry(targetScope);\n      if (provided) {\n        return provided;\n      }\n    } catch (error) {\n      void error;\n    }\n  }\n\n  // Use imported cineModules if available\n  if (cineModules && typeof cineModules === 'object') {\n    return cineModules;\n  }\n\n\n  const scopes = [targetScope];\n  if (typeof globalThis !== 'undefined' && scopes.indexOf(globalThis) === -1) scopes.push(globalThis);\n  if (typeof window !== 'undefined' && scopes.indexOf(window) === -1) scopes.push(window);\n  if (typeof self !== 'undefined' && scopes.indexOf(self) === -1) scopes.push(self);\n  if (typeof global !== 'undefined' && scopes.indexOf(global) === -1) scopes.push(global);\n\n  for (let index = 0; index < scopes.length; index += 1) {\n    const candidate = scopes[index];\n    if (candidate && typeof candidate.cineModules === 'object') {\n      return candidate.cineModules;\n    }\n  }\n\n  return null;\n}\n\nconst MODULE_REGISTRY = (function () {\n  if (MODULE_LINKER && typeof MODULE_LINKER.getModuleRegistry === 'function') {\n    const linkedRegistry = MODULE_LINKER.getModuleRegistry(GLOBAL_SCOPE);\n    if (linkedRegistry) {\n      return linkedRegistry;\n    }\n  }\n\n  if (MODULE_GLOBALS && typeof MODULE_GLOBALS.getModuleRegistry === 'function') {\n    try {\n      const shared = MODULE_GLOBALS.getModuleRegistry(GLOBAL_SCOPE);\n      if (shared) {\n        return shared;\n      }\n    } catch (error) {\n      void error;\n    }\n  }\n\n  if (ENV_BRIDGE && typeof ENV_BRIDGE.getModuleRegistry === 'function') {\n    try {\n      const bridged = ENV_BRIDGE.getModuleRegistry(GLOBAL_SCOPE);\n      if (bridged) {\n        return bridged;\n      }\n    } catch (error) {\n      void error;\n    }\n  }\n\n  if (MODULE_ENV && typeof MODULE_ENV.getModuleRegistry === 'function') {\n    try {\n      const provided = MODULE_ENV.getModuleRegistry(GLOBAL_SCOPE);\n      if (provided) {\n        return provided;\n      }\n    } catch (error) {\n      void error;\n    }\n  }\n\n  return resolveModuleRegistry(GLOBAL_SCOPE);\n})();\n\nconst PENDING_QUEUE_KEY = (function resolvePendingKey() {\n  if (MODULE_LINKER && typeof MODULE_LINKER.getPendingQueueKey === 'function') {\n    const linkedKey = MODULE_LINKER.getPendingQueueKey();\n    if (typeof linkedKey === 'string' && linkedKey) {\n      return linkedKey;\n    }\n  }\n\n  if (MODULE_GLOBALS && typeof MODULE_GLOBALS.getPendingQueueKey === 'function') {\n    try {\n      const sharedKey = MODULE_GLOBALS.getPendingQueueKey();\n      if (typeof sharedKey === 'string' && sharedKey) {\n        return sharedKey;\n      }\n    } catch (error) {\n      void error;\n    }\n  }\n\n  if (ENV_BRIDGE && typeof ENV_BRIDGE.getPendingQueueKey === 'function') {\n    try {\n      const bridgedKey = ENV_BRIDGE.getPendingQueueKey();\n      if (typeof bridgedKey === 'string' && bridgedKey) {\n        return bridgedKey;\n      }\n    } catch (error) {\n      void error;\n    }\n  }\n\n  if (MODULE_ENV && typeof MODULE_ENV.PENDING_QUEUE_KEY === 'string') {\n    return MODULE_ENV.PENDING_QUEUE_KEY;\n  }\n\n  return '__cinePendingModuleRegistrations__';\n})();\n\nfunction cloneOptions(options) {\n  if (!options || typeof options !== 'object') {\n    return {};\n  }\n\n  const copy = {};\n  const keys = Object.keys(options);\n  for (let index = 0; index < keys.length; index += 1) {\n    const key = keys[index];\n    copy[key] = options[key];\n  }\n\n  return copy;\n}\n\nfunction queueModuleRegistration(name, api, options) {\n  if (MODULE_GLOBALS && typeof MODULE_GLOBALS.queueModuleRegistration === 'function') {\n    try {\n      if (MODULE_GLOBALS.queueModuleRegistration(name, api, options, GLOBAL_SCOPE)) {\n        return true;\n      }\n    } catch (error) {\n      void error;\n    }\n  }\n\n  if (ENV_BRIDGE && typeof ENV_BRIDGE.queueModuleRegistration === 'function') {\n    try {\n      const bridged = ENV_BRIDGE.queueModuleRegistration(name, api, options);\n      if (bridged) {\n        return true;\n      }\n    } catch (error) {\n      void error;\n    }\n  }\n\n  if (MODULE_ENV && typeof MODULE_ENV.queueModuleRegistration === 'function') {\n    return MODULE_ENV.queueModuleRegistration(name, api, options, GLOBAL_SCOPE);\n  }\n\n  if (!GLOBAL_SCOPE || typeof GLOBAL_SCOPE !== 'object') {\n    return false;\n  }\n\n  const payload = Object.freeze({\n    name,\n    api,\n    options: Object.freeze(cloneOptions(options)),\n  });\n\n  let queue = GLOBAL_SCOPE[PENDING_QUEUE_KEY];\n  if (!Array.isArray(queue)) {\n    try {\n      Object.defineProperty(GLOBAL_SCOPE, PENDING_QUEUE_KEY, {\n        configurable: true,\n        enumerable: false,\n        writable: true,\n        value: [],\n      });\n      queue = GLOBAL_SCOPE[PENDING_QUEUE_KEY];\n    } catch (error) {\n      void error;\n      try {\n        if (!Array.isArray(GLOBAL_SCOPE[PENDING_QUEUE_KEY])) {\n          GLOBAL_SCOPE[PENDING_QUEUE_KEY] = [];\n        }\n        queue = GLOBAL_SCOPE[PENDING_QUEUE_KEY];\n      } catch (assignmentError) {\n        void assignmentError;\n        return false;\n      }\n    }\n  }\n\n  try {\n    queue.push(payload);\n  } catch (error) {\n    void error;\n    queue[queue.length] = payload;\n  }\n\n  return true;\n}\n\nfunction fallbackRegisterOrQueue(name, api, options, onError) {\n  if (MODULE_REGISTRY && typeof MODULE_REGISTRY.register === 'function') {\n    try {\n      MODULE_REGISTRY.register(name, api, options);\n      return true;\n    } catch (error) {\n      if (typeof onError === 'function') {\n        try {\n          onError(error);\n        } catch (callbackError) {\n          void callbackError;\n        }\n      } else {\n        void error;\n      }\n    }\n  }\n\n  queueModuleRegistration(name, api, options);\n  return false;\n}\n\nconst registerOrQueueModule = (function resolveRegisterOrQueue() {\n  if (MODULE_GLOBALS && typeof MODULE_GLOBALS.registerOrQueueModule === 'function') {\n    return function registerOrQueueModule(name, api, options, onError) {\n      try {\n        const registered = MODULE_GLOBALS.registerOrQueueModule(\n          name,\n          api,\n          options,\n          onError,\n          GLOBAL_SCOPE,\n          MODULE_REGISTRY,\n        );\n        if (registered) {\n          return true;\n        }\n      } catch (error) {\n        void error;\n      }\n\n      return fallbackRegisterOrQueue(name, api, options, onError);\n    };\n  }\n\n  if (ENV_BRIDGE && typeof ENV_BRIDGE.registerOrQueueModule === 'function') {\n    return function registerOrQueueModule(name, api, options, onError) {\n      try {\n        const bridged = ENV_BRIDGE.registerOrQueueModule(name, api, options, onError, GLOBAL_SCOPE, MODULE_REGISTRY);\n        if (bridged) {\n          return true;\n        }\n      } catch (error) {\n        void error;\n      }\n\n      return fallbackRegisterOrQueue(name, api, options, onError);\n    };\n  }\n\n  if (MODULE_ENV && typeof MODULE_ENV.registerOrQueueModule === 'function') {\n    return function registerOrQueueModule(name, api, options, onError) {\n      return MODULE_ENV.registerOrQueueModule(name, api, options, onError, GLOBAL_SCOPE, MODULE_REGISTRY);\n    };\n  }\n\n  return fallbackRegisterOrQueue;\n})();\n\n\n\nfunction isNodeProcessReference(value) {\n  if (!value) {\n    return false;\n  }\n\n  if (typeof process === 'undefined' || !process) {\n    return false;\n  }\n\n  if (value === process) {\n    return true;\n  }\n\n  if (typeof value === 'object') {\n    try {\n      if (value.constructor && value.constructor.name === 'process') {\n        return true;\n      }\n    } catch (processInspectionError) {\n      void processInspectionError;\n    }\n\n    if (\n      typeof value.pid === 'number' &&\n      typeof value.nextTick === 'function' &&\n      typeof value.emit === 'function' &&\n      typeof value.binding === 'function'\n    ) {\n      return true;\n    }\n  }\n\n  if (typeof value === 'function') {\n    if (\n      value === process.binding ||\n      value === process._linkedBinding ||\n      value === process.dlopen\n    ) {\n      return true;\n    }\n\n    try {\n      const functionName = value.name || '';\n      if (functionName && (functionName === 'binding' || functionName === 'dlopen')) {\n        const source = Function.prototype.toString.call(value);\n        if (source && source.indexOf('[native code]') !== -1) {\n          return true;\n        }\n      }\n    } catch (functionInspectionError) {\n      void functionInspectionError;\n    }\n  }\n\n  return false;\n}\n\nfunction shouldBypassDeepFreeze(value) {\n  if (!value || typeof value === 'function' || (typeof value !== 'object' && typeof value !== 'function')) {\n    return false;\n  }\n\n  if (isNodeProcessReference(value)) {\n    return true;\n  }\n\n  if (\n    typeof process !== 'undefined' &&\n    process &&\n    process.release &&\n    process.release.name === 'node'\n  ) {\n    return true;\n  }\n\n  try {\n    if (typeof value.pipe === 'function' && typeof value.unpipe === 'function') {\n      return true;\n    }\n\n    if (typeof value.on === 'function' && typeof value.emit === 'function') {\n      if (typeof value.write === 'function' || typeof value.read === 'function') {\n        return true;\n      }\n\n      const ctorName = value.constructor && value.constructor.name;\n      if (ctorName && /Stream|Emitter|Port/i.test(ctorName)) {\n        return true;\n      }\n    }\n\n    if (typeof Symbol !== 'undefined' && value[Symbol.toStringTag]) {\n      const tag = value[Symbol.toStringTag];\n      if (typeof tag === 'string' && /Stream|Port/i.test(tag)) {\n        return true;\n      }\n    }\n  } catch (inspectionError) {\n    void inspectionError;\n  }\n\n  return false;\n}\n\nfunction fallbackResolveSeenTracker(seen) {\n  if (seen && typeof seen.has === 'function' && typeof seen.add === 'function') {\n    return seen;\n  }\n\n  if (Array.isArray(seen)) {\n    return {\n      has(value) {\n        return seen.indexOf(value) !== -1;\n      },\n      add(value) {\n        if (seen.indexOf(value) === -1) {\n          seen.push(value);\n        }\n      },\n    };\n  }\n\n  if (typeof WeakSet === 'function') {\n    try {\n      return new WeakSet();\n    } catch (trackerError) {\n      void trackerError;\n    }\n  }\n\n  const tracked = [];\n  return {\n    has(value) {\n      return tracked.indexOf(value) !== -1;\n    },\n    add(value) {\n      if (tracked.indexOf(value) === -1) {\n        tracked.push(value);\n      }\n    },\n  };\n}\n\nfunction fallbackFreezeDeep(value, seen) {\n  if (!value || typeof value === 'function' || (typeof value !== 'object' && typeof value !== 'function')) {\n    return value;\n  }\n\n  if (shouldBypassDeepFreeze(value)) {\n    return value;\n  }\n\n  if (typeof process !== 'undefined' && process && process.env && process.env.JEST_WORKER_ID) {\n    try {\n      if (typeof Object.freeze === 'function') {\n        Object.freeze(value);\n      }\n    } catch (freezeError) {\n      void freezeError;\n    }\n    return value;\n  }\n\n  const tracker = fallbackResolveSeenTracker(seen);\n\n  if (tracker.has(value)) {\n    return value;\n  }\n\n  tracker.add(value);\n\n  const keys = Object.getOwnPropertyNames(value);\n  for (let index = 0; index < keys.length; index += 1) {\n    const key = keys[index];\n    let child;\n    try {\n      child = value[key];\n    } catch (accessError) {\n      void accessError;\n      child = undefined;\n    }\n    if (!child || typeof child === 'function' || (typeof child !== 'object' && typeof child !== 'function')) {\n      continue;\n    }\n    fallbackFreezeDeep(child, tracker);\n  }\n\n  try {\n    return Object.freeze(value);\n  } catch (freezeError) {\n    void freezeError;\n    return value;\n  }\n}\n\nconst freezeDeep = (function resolveFreezeDeep() {\n  if (MODULE_GLOBALS && typeof MODULE_GLOBALS.freezeDeep === 'function') {\n    return MODULE_GLOBALS.freezeDeep;\n  }\n\n  if (ENV_BRIDGE && typeof ENV_BRIDGE.freezeDeep === 'function') {\n    return function bridgeFreezeDeep(value, seen) {\n      try {\n        return ENV_BRIDGE.freezeDeep(value, seen);\n      } catch (error) {\n        void error;\n        return fallbackFreezeDeep(value, seen);\n      }\n    };\n  }\n\n  if (MODULE_ENV && typeof MODULE_ENV.freezeDeep === 'function') {\n    return MODULE_ENV.freezeDeep;\n  }\n\n  return fallbackFreezeDeep;\n})();\n\nfunction fallbackSafeWarn(message, detail) {\n  if (typeof console === 'undefined' || typeof console.warn !== 'function') {\n    return;\n  }\n\n  try {\n    if (typeof detail === 'undefined') {\n      console.warn(message);\n    } else {\n      console.warn(message, detail);\n    }\n  } catch (error) {\n    void error;\n  }\n}\n\nconst safeWarn = (function resolveSafeWarn() {\n  if (MODULE_GLOBALS && typeof MODULE_GLOBALS.safeWarn === 'function') {\n    return MODULE_GLOBALS.safeWarn;\n  }\n\n  if (ENV_BRIDGE && typeof ENV_BRIDGE.safeWarn === 'function') {\n    return function bridgeSafeWarn(message, detail) {\n      try {\n        ENV_BRIDGE.safeWarn(message, detail);\n      } catch (error) {\n        void error;\n        fallbackSafeWarn(message, detail);\n      }\n    };\n  }\n\n  if (MODULE_ENV && typeof MODULE_ENV.safeWarn === 'function') {\n    return MODULE_ENV.safeWarn;\n  }\n\n  return fallbackSafeWarn;\n})();\n\nfunction fallbackExposeGlobal(name, value) {\n  if (!GLOBAL_SCOPE || typeof GLOBAL_SCOPE !== 'object') {\n    return false;\n  }\n  try {\n    Object.defineProperty(GLOBAL_SCOPE, name, {\n      configurable: true,\n      enumerable: false,\n      value,\n      writable: false,\n    });\n    return true;\n  } catch (error) {\n    void error;\n    try {\n      GLOBAL_SCOPE[name] = value;\n      return true;\n    } catch (assignmentError) {\n      void assignmentError;\n      return false;\n    }\n  }\n}\n\nconst exposeGlobal = (function resolveExposeGlobal() {\n  if (MODULE_GLOBALS && typeof MODULE_GLOBALS.exposeGlobal === 'function') {\n    return function moduleGlobalsExpose(name, value, options) {\n      try {\n        return MODULE_GLOBALS.exposeGlobal(name, value, options);\n      } catch (error) {\n        void error;\n        return fallbackExposeGlobal(name, value);\n      }\n    };\n  }\n\n  if (ENV_BRIDGE && typeof ENV_BRIDGE.exposeGlobal === 'function') {\n    return function bridgeExposeGlobal(name, value, options) {\n      try {\n        return ENV_BRIDGE.exposeGlobal(name, value, options);\n      } catch (error) {\n        void error;\n        return fallbackExposeGlobal(name, value);\n      }\n    };\n  }\n\n  if (MODULE_ENV && typeof MODULE_ENV.exposeGlobal === 'function') {\n    return function exposeGlobal(name, value, options) {\n      return MODULE_ENV.exposeGlobal(name, value, GLOBAL_SCOPE, options);\n    };\n  }\n\n  return fallbackExposeGlobal;\n})();\n\nconst providerModules = [];\n\nfunction addProviderModule(reference, label) {\n  if (!reference || typeof reference !== 'object') {\n    return;\n  }\n\n  providerModules.push({\n    ref: reference,\n    name: label || null,\n  });\n}\n\naddProviderModule(GLOBAL_SCOPE, 'global');\n\n// Import and register Storage as a provider\nif (cineStorage && typeof cineStorage === 'object') {\n  addProviderModule(cineStorage, 'storage');\n}\n\n\n// We no longer require these via tryRequire inside ESM\n// Instead, we assume they might be present in GLOBAL_SCOPE if they are legacy scripts.\n// If they are converted to ESM, we should import them.\n// Currently assuming they are either globals or not present.\n// If existing global objects are found, we add them.\n// (e.g. if loader.js loaded them).\n\nif (GLOBAL_SCOPE.cineAppSession) {\n  addProviderModule(GLOBAL_SCOPE.cineAppSession, 'session');\n}\n\nif (GLOBAL_SCOPE.cineAppSetups) {\n  addProviderModule(GLOBAL_SCOPE.cineAppSetups, 'setups');\n}\n\n\nconst bindingState = Object.create(null);\nconst bindingNames = [];\n\nfunction identifyProvider(providerEntry) {\n  if (!providerEntry) {\n    return null;\n  }\n\n  if (providerEntry.name) {\n    return providerEntry.name;\n  }\n\n  const ref = providerEntry.ref;\n  if (!ref || typeof ref !== 'object') {\n    return null;\n  }\n\n  if (ref === GLOBAL_SCOPE) {\n    return 'global';\n  }\n\n  if (typeof ref.constructor === 'function' && ref.constructor.name) {\n    return ref.constructor.name;\n  }\n\n  return null;\n}\n\nfunction ensureBindingEntry(bindingKey, implementationName) {\n  const key = String(bindingKey);\n  let entry = bindingState[key];\n  if (!entry) {\n    entry = {\n      name: key,\n      implementationName: implementationName || key,\n      available: false,\n      providerIndex: -1,\n      providerName: null,\n      lastChecked: null,\n      implementation: null,\n    };\n    bindingState[key] = entry;\n    bindingNames.push(key);\n  } else if (implementationName && entry.implementationName !== implementationName) {\n    entry.implementationName = implementationName;\n  }\n\n  return entry;\n}\n\nfunction resolveBinding(name, options = {}) {\n  const refresh = options && Object.prototype.hasOwnProperty.call(options, 'refresh')\n    ? options.refresh\n    : true;\n\n  const entry = ensureBindingEntry(name);\n  const implementationName = entry.implementationName || String(name);\n  if (!refresh && entry.implementation && typeof entry.implementation === 'function') {\n    return entry;\n  }\n\n  let resolved = null;\n\n  for (let index = 0; index < providerModules.length; index += 1) {\n    const providerEntry = providerModules[index];\n    const provider = providerEntry && providerEntry.ref;\n    if (!provider || typeof provider !== 'object') {\n      continue;\n    }\n\n    const candidate = provider[implementationName];\n    if (typeof candidate === 'function') {\n      resolved = {\n        implementation: candidate,\n        providerIndex: index,\n        providerName: identifyProvider(providerEntry),\n      };\n      break;\n    }\n  }\n\n  entry.available = !!resolved;\n  entry.providerIndex = resolved ? resolved.providerIndex : -1;\n  entry.providerName = resolved ? resolved.providerName : null;\n  entry.lastChecked = Date.now();\n  entry.implementation = resolved ? resolved.implementation : null;\n\n  return entry;\n}\n\nfunction requireBinding(name) {\n  const detail = resolveBinding(name, { refresh: true });\n  if (!detail || typeof detail.implementation !== 'function') {\n    const error = new Error(`cinePersistence could not resolve function \"${name}\".`);\n    error.code = 'CINE_PERSISTENCE_BINDING_MISSING';\n    error.binding = name;\n    error.detail = {\n      name,\n      available: detail ? detail.available : false,\n      providerName: detail ? detail.providerName : null,\n    };\n    throw error;\n  }\n  return detail.implementation;\n}\n\nfunction snapshotBinding(detail) {\n  if (!detail) {\n    return null;\n  }\n\n  return Object.freeze({\n    name: detail.name,\n    available: !!detail.available,\n    providerIndex: typeof detail.providerIndex === 'number' ? detail.providerIndex : -1,\n    providerName: detail.providerName || null,\n    lastChecked: detail.lastChecked || null,\n    implementation: detail.implementationName || detail.name,\n  });\n}\n\nfunction createWrapper(name, alias) {\n  const bindingKey = alias || name;\n  ensureBindingEntry(bindingKey, name);\n  return function persistenceWrapper() {\n    const fn = requireBinding(bindingKey);\n    return fn.apply(this, arguments);\n  };\n}\n\nfunction inspectBinding(name, options = {}) {\n  const normalized = String(name);\n  const refresh = options && Object.prototype.hasOwnProperty.call(options, 'refresh')\n    ? options.refresh\n    : true;\n  const detail = resolveBinding(normalized, { refresh });\n  return snapshotBinding(detail);\n}\n\nfunction inspectAllBindings(options = {}) {\n  const refresh = options && Object.prototype.hasOwnProperty.call(options, 'refresh')\n    ? options.refresh\n    : true;\n\n  if (refresh) {\n    for (let index = 0; index < bindingNames.length; index += 1) {\n      resolveBinding(bindingNames[index], { refresh: true });\n    }\n  }\n\n  const snapshot = {};\n  for (let index = 0; index < bindingNames.length; index += 1) {\n    const name = bindingNames[index];\n    snapshot[name] = snapshotBinding(bindingState[name]);\n  }\n  return freezeDeep(snapshot);\n}\n\nfunction listBindings() {\n  return bindingNames.slice();\n}\n\nconst persistenceAPI = {\n  bindings: {\n    saveSession: createWrapper('saveCurrentSession', 'saveSession'),\n    autoSaveSetup: createWrapper('autoSaveCurrentSetup', 'autoSaveSetup'),\n    saveGearList: createWrapper('saveCurrentGearList', 'saveGearList'),\n    restoreSessionState: createWrapper('restoreSessionState'),\n    collectFullBackupData: createWrapper('collectFullBackupData'),\n    createSettingsBackup: createWrapper('createSettingsBackup'),\n    captureStorageSnapshot: createWrapper('captureStorageSnapshot'),\n    sanitizeBackupPayload: createWrapper('sanitizeBackupPayload'),\n    autoBackup: createWrapper('autoBackup'),\n    formatFullBackupFilename: createWrapper('formatFullBackupFilename'),\n    downloadPayload: createWrapper('downloadBackupPayload', 'downloadPayload'),\n    recordFullBackupHistoryEntry: createWrapper('recordFullBackupHistoryEntry'),\n    encodeSharedSetup: createWrapper('encodeSharedSetup'),\n    decodeSharedSetup: createWrapper('decodeSharedSetup'),\n    applySharedSetup: createWrapper('applySharedSetup'),\n    applySharedSetupFromUrl: createWrapper('applySharedSetupFromUrl'),\n    downloadProject: createWrapper('downloadSharedProject', 'downloadProject'),\n    saveProject: createWrapper('saveProject'),\n    proceed: createWrapper('handleRestoreRehearsalProceed', 'proceed'),\n    abort: createWrapper('handleRestoreRehearsalAbort', 'abort'),\n  },\n  storage: {\n    loadDeviceData: createWrapper('loadDeviceData'),\n    saveDeviceData: createWrapper('saveDeviceData'),\n    loadSetups: createWrapper('loadSetups'),\n    saveSetups: createWrapper('saveSetups'),\n    saveSetup: createWrapper('saveSetup'),\n    loadSetup: createWrapper('loadSetup'),\n    deleteSetup: createWrapper('deleteSetup'),\n    renameSetup: createWrapper('renameSetup'),\n    loadSessionState: createWrapper('loadSessionState'),\n    saveSessionState: createWrapper('saveSessionState'),\n    loadFeedback: createWrapper('loadFeedback'),\n    saveFeedback: createWrapper('saveFeedback'),\n    saveProject: createWrapper('saveProject'),\n    loadProject: createWrapper('loadProject'),\n    deleteProject: createWrapper('deleteProject'),\n    loadFavorites: createWrapper('loadFavorites'),\n    saveFavorites: createWrapper('saveFavorites'),\n    exportAllData: createWrapper('exportAllData'),\n    importAllData: createWrapper('importAllData'),\n    clearAllData: createWrapper('clearAllData'),\n    loadAutoGearRules: createWrapper('loadAutoGearRules'),\n    saveAutoGearRules: createWrapper('saveAutoGearRules'),\n    loadAutoGearBackups: createWrapper('loadAutoGearBackups'),\n    saveAutoGearBackups: createWrapper('saveAutoGearBackups'),\n    loadAutoGearSeedFlag: createWrapper('loadAutoGearSeedFlag'),\n    saveAutoGearSeedFlag: createWrapper('saveAutoGearSeedFlag'),\n    loadAutoGearBackupRetention: createWrapper('loadAutoGearBackupRetention'),\n    saveAutoGearBackupRetention: createWrapper('saveAutoGearBackupRetention'),\n    getAutoGearBackupRetentionDefault: createWrapper('getAutoGearBackupRetentionDefault'),\n    loadAutoGearPresets: createWrapper('loadAutoGearPresets'),\n    saveAutoGearPresets: createWrapper('saveAutoGearPresets'),\n    loadAutoGearActivePresetId: createWrapper('loadAutoGearActivePresetId'),\n    saveAutoGearActivePresetId: createWrapper('saveAutoGearActivePresetId'),\n    loadAutoGearAutoPresetId: createWrapper('loadAutoGearAutoPresetId'),\n    saveAutoGearAutoPresetId: createWrapper('saveAutoGearAutoPresetId'),\n    loadAutoGearMonitorDefaults: createWrapper('loadAutoGearMonitorDefaults'),\n    saveAutoGearMonitorDefaults: createWrapper('saveAutoGearMonitorDefaults'),\n    loadAutoGearBackupVisibility: createWrapper('loadAutoGearBackupVisibility'),\n    saveAutoGearBackupVisibility: createWrapper('saveAutoGearBackupVisibility'),\n    loadFullBackupHistory: createWrapper('loadFullBackupHistory'),\n    saveFullBackupHistory: createWrapper('saveFullBackupHistory'),\n    recordFullBackupHistoryEntry: createWrapper('recordFullBackupHistoryEntry'),\n    requestPersistentStorage: createWrapper('requestPersistentStorage'),\n    clearUiCacheStorageEntries: createWrapper('clearUiCacheStorageEntries'),\n    ensureCriticalStorageBackups: createWrapper('ensureCriticalStorageBackups'),\n    getLastCriticalStorageGuardResult: createWrapper('getLastCriticalStorageGuardResult'),\n    saveSession: createWrapper('saveCurrentSession', 'saveSession'),\n    autoSaveSetup: createWrapper('autoSaveCurrentSetup', 'autoSaveSetup'),\n    proceed: createWrapper('handleRestoreRehearsalProceed', 'proceed'),\n    abort: createWrapper('handleRestoreRehearsalAbort', 'abort'),\n  },\n  autosave: {\n    saveSession: createWrapper('saveCurrentSession', 'saveSession'),\n    autoSaveSetup: createWrapper('autoSaveCurrentSetup', 'autoSaveSetup'),\n    saveGearList: createWrapper('saveCurrentGearList', 'saveGearList'),\n    restoreSessionState: createWrapper('restoreSessionState'),\n  },\n  backups: {\n    collectFullBackupData: createWrapper('collectFullBackupData'),\n    createSettingsBackup: createWrapper('createSettingsBackup'),\n    captureStorageSnapshot: createWrapper('captureStorageSnapshot'),\n    sanitizeBackupPayload: createWrapper('sanitizeBackupPayload'),\n    autoBackup: createWrapper('autoBackup'),\n    formatFullBackupFilename: createWrapper('formatFullBackupFilename'),\n    downloadPayload: createWrapper('downloadBackupPayload', 'downloadPayload'),\n    recordFullBackupHistoryEntry: createWrapper('recordFullBackupHistoryEntry'),\n  },\n  restore: {\n    proceed: createWrapper('handleRestoreRehearsalProceed', 'proceed'),\n    abort: createWrapper('handleRestoreRehearsalAbort', 'abort'),\n  },\n  share: {\n    downloadProject: createWrapper('downloadSharedProject', 'downloadProject'),\n    encodeSharedSetup: createWrapper('encodeSharedSetup'),\n    decodeSharedSetup: createWrapper('decodeSharedSetup'),\n    applySharedSetup: createWrapper('applySharedSetup'),\n    applySharedSetupFromUrl: createWrapper('applySharedSetupFromUrl'),\n  },\n\n  __internal: freezeDeep({\n    listBindings,\n    inspectBinding(name, options) {\n      return inspectBinding(name, options) || null;\n    },\n    inspectAllBindings,\n  }),\n};\n\nfreezeDeep(persistenceAPI);\n\naddProviderModule(persistenceAPI.bindings, 'bindings');\ninformModuleGlobals('cinePersistence', persistenceAPI);\n\nregisterOrQueueModule('cinePersistence', persistenceAPI, {\n  category: 'persistence',\n  description: 'Data integrity facade for storage, autosave, backups, restore, and share flows.',\n  replace: true,\n  connections: ['cineModuleGlobals', 'cineModuleEnvironment', 'cineEnvironmentBridge', 'cineModuleContext'],\n}, (error) => {\n  safeWarn('Unable to register cinePersistence module.', error);\n});\n\nif (GLOBAL_SCOPE && typeof GLOBAL_SCOPE === 'object') {\n  let existingPersistence = null;\n  try {\n    existingPersistence = GLOBAL_SCOPE.cinePersistence || null;\n  } catch (error) {\n    void error;\n    existingPersistence = null;\n  }\n\n  if (existingPersistence !== persistenceAPI) {\n    const exposed = exposeGlobal('cinePersistence', persistenceAPI, {\n      configurable: true,\n      enumerable: false,\n      writable: false,\n    });\n\n    if (!exposed && typeof console !== 'undefined' && typeof console.warn === 'function') {\n      console.warn('Unable to expose cinePersistence globally.');\n    }\n  }\n}\n\nexport const cinePersistence = persistenceAPI;\n","/**\n * Cine Power Planner Icon Helpers\n *\n * Pure ESM module for managing icon glyphs and SVG markup.\n * Provides utilities for resolving icon fonts, formatting SVG coordinates,\n * and applying glyphs to DOM elements.\n *\n * @module helpers/icons\n * @see {@link ../runtime-environment.js} for the aggregate API\n * @see {@link ../../docs/dev/architecture/runtime-environment.md} for architecture docs\n *\n * Extracted from app-core-environment.js during Vite migration (Step 24).\n */\n\n/**\n * Creates the fallback map of icon font keys.\n * @returns {object} The frozen icon font keys map.\n */\nexport function createFallbackIconFontKeys() {\n    return Object.freeze({\n        ESSENTIAL: 'essential',\n        FILM: 'film',\n        GADGET: 'gadget',\n        UICONS: 'uicons',\n        TEXT: 'text',\n    });\n}\n\n/**\n * Formats a coordinate for SVG usage (rounded to 2 decimal places).\n * @param {number} value - The coordinate value.\n * @returns {string} The formatted string (e.g., \"10.5\").\n */\nexport function formatSvgCoordinate(value) {\n    if (!Number.isFinite(value)) return '0';\n    const rounded = Math.round(value * 100) / 100;\n    if (Number.isInteger(rounded)) return String(rounded);\n    return rounded.toFixed(2).replace(/0+$/, '').replace(/\\.$/, '');\n}\n\n/**\n * Wraps SVG markup with positioning attributes.\n * @param {string} markup - The inner SVG markup (path, etc.).\n * @param {number} centerX - The X center coordinate.\n * @param {number} centerY - The Y center coordinate.\n * @param {number} [size=24] - The size of the icon.\n * @returns {object} { markup, x, y }\n */\nexport function positionSvgMarkup(markup, centerX, centerY, size = 24) {\n    if (typeof markup !== 'string') {\n        return {\n            markup: '',\n            x: '0',\n            y: '0',\n        };\n    }\n\n    const trimmed = markup.trim();\n    if (!trimmed) {\n        return {\n            markup: '',\n            x: '0',\n            y: '0',\n        };\n    }\n\n    const half = size / 2;\n    const x = formatSvgCoordinate(centerX);\n    const y = formatSvgCoordinate(centerY);\n    const width = formatSvgCoordinate(size);\n    const height = formatSvgCoordinate(size);\n\n    const cleaned = trimmed.replace(/<svg\\b([^>]*)>/i, (match, attrs = '') => {\n        let attrText = attrs.replace(/\\s+x\\s*=\\s*\"[^\"]*\"/gi, '').replace(/\\s+y\\s*=\\s*\"[^\"]*\"/gi, '').trim();\n        const additions = [];\n        const hasWidth = /(?:^|\\s)width\\s*=/i.test(attrText);\n        const hasHeight = /(?:^|\\s)height\\s*=/i.test(attrText);\n        if (!hasWidth) additions.push(`width=\"${width}\"`);\n        if (!hasHeight) additions.push(`height=\"${height}\"`);\n        additions.push(`x=\"-${formatSvgCoordinate(half)}\"`);\n        additions.push(`y=\"-${formatSvgCoordinate(half)}\"`);\n        attrText = [attrText].concat(additions).filter(Boolean).join(' ').trim();\n        return attrText ? `<svg ${attrText}>` : '<svg>';\n    });\n\n    return {\n        markup: cleaned,\n        x,\n        y,\n    };\n}\n\n\nfunction toCodePointChar(value, radix) {\n    const codePoint = parseInt(value, radix);\n    if (!Number.isFinite(codePoint) || codePoint < 0) {\n        return null;\n    }\n\n    try {\n        if (typeof String.fromCodePoint === 'function') {\n            return String.fromCodePoint(codePoint);\n        }\n    } catch (rangeError) {\n        void rangeError;\n    }\n\n    if (codePoint <= 0xffff) {\n        return String.fromCharCode(codePoint);\n    }\n\n    return null;\n}\n\nfunction normalizeGlyphChar(char) {\n    if (typeof char !== 'string') {\n        return '';\n    }\n\n    const trimmed = char.trim();\n    if (!trimmed) {\n        return '';\n    }\n\n    // Unicode escape \\uXXXX\n    const unicodeMatch = trimmed.match(/^(?:\\\\)+u([0-9A-Fa-f]{4})$/);\n    if (unicodeMatch) {\n        const decoded = toCodePointChar(unicodeMatch[1], 16);\n        if (decoded) {\n            return decoded;\n        }\n    }\n\n    // Unicode escape \\u{XXXXX}\n    const unicodeBraceMatch = trimmed.match(/^(?:\\\\)+u\\{([0-9A-Fa-f]+)\\}$/);\n    if (unicodeBraceMatch) {\n        const decoded = toCodePointChar(unicodeBraceMatch[1], 16);\n        if (decoded) {\n            return decoded;\n        }\n    }\n\n    // Hex entity &#xXXXX;\n    const hexEntityMatch = trimmed.match(/^&#x([0-9A-Fa-f]+);$/i);\n    if (hexEntityMatch) {\n        const decoded = toCodePointChar(hexEntityMatch[1], 16);\n        if (decoded) {\n            return decoded;\n        }\n    }\n\n    // Decimal entity &#DDD;\n    const decimalEntityMatch = trimmed.match(/^&#(\\d+);$/);\n    if (decimalEntityMatch) {\n        const decoded = toCodePointChar(decimalEntityMatch[1], 10);\n        if (decoded) {\n            return decoded;\n        }\n    }\n\n    return trimmed;\n}\n\n/**\n * Resolves an icon glyph object into a standardized format.\n * @param {object|string} glyph - The raw glyph input.\n * @returns {object} Standardized glyph object { char, font, className, markup?, size? }.\n */\nexport function resolveIconGlyph(glyph) {\n    const ICON_FONT_KEYS = createFallbackIconFontKeys();\n    const validFonts = new Set(Object.values(ICON_FONT_KEYS).filter(Boolean));\n    const fallbackFont = ICON_FONT_KEYS.UICONS;\n\n    if (!glyph) {\n        return {\n            char: '',\n            font: fallbackFont,\n            className: '',\n        };\n    }\n\n    if (glyph.markup) {\n        const size = Number.isFinite(glyph.size) ? glyph.size : undefined;\n        return {\n            markup: glyph.markup,\n            className: glyph.className || '',\n            font: fallbackFont,\n            size,\n        };\n    }\n\n    if (typeof glyph === 'string') {\n        return {\n            char: normalizeGlyphChar(glyph),\n            font: fallbackFont,\n            className: '',\n        };\n    }\n\n    if (typeof glyph === 'object') {\n        const char = typeof glyph.char === 'string' ? normalizeGlyphChar(glyph.char) : '';\n        // Allow any string as font, falling back to default if empty or invalid type\n        const fontKey = (glyph.font && typeof glyph.font === 'string') ? glyph.font : fallbackFont;\n        const className = typeof glyph.className === 'string' ? glyph.className : '';\n        const size = Number.isFinite(glyph.size) ? glyph.size : undefined;\n\n        if (glyph.markup) {\n            return {\n                markup: glyph.markup,\n                className,\n                font: fontKey,\n                size,\n            };\n        }\n\n        return {\n            char,\n            font: fontKey,\n            className,\n            size,\n        };\n    }\n\n    return {\n        char: '',\n        font: fallbackFont,\n        className: '',\n    };\n}\n\n/**\n * Applies a glyph to a DOM element.\n * @param {HTMLElement} element - The target element.\n * @param {object|string} glyph - The glyph to apply.\n */\nexport function applyIconGlyph(element, glyph) {\n    if (!element) return;\n    const resolved = resolveIconGlyph(glyph);\n\n    if (resolved && resolved.markup) {\n        // Basic assurance that SVG has aria-hidden if not present\n        // Simple regex check to avoid full parsing overhead in this tight loop\n        let markup = resolved.markup;\n        if (!markup.includes('aria-hidden')) {\n            markup = markup.replace('<svg', '<svg aria-hidden=\"true\"');\n        }\n\n        element.innerHTML = markup;\n        if (!markup.includes('aria-hidden')) {\n            element.setAttribute('aria-hidden', 'true');\n        }\n\n        if (resolved.className && element.classList) {\n            resolved.className.split(/\\s+/).filter(Boolean).forEach(cls => element.classList.add(cls));\n        }\n        element.removeAttribute('data-icon-font');\n        return;\n    }\n\n    const char = (resolved && resolved.char) || '';\n    element.textContent = char;\n    if (char) {\n        element.setAttribute('data-icon-font', resolved.font || 'uicons');\n    } else {\n        element.removeAttribute('data-icon-font');\n    }\n}\n","import cineModules from '../registry.js';\nimport { storageRepo } from '../storage/StorageRepository.js';\nimport { detectGlobalScope } from '../helpers/scope-utils.js';\n\nconst AUTO_GEAR_STORAGE_KEYS = Object.freeze({\n  autoGearRules: 'cameraPowerPlanner_autoGearRules',\n  autoGearBackups: 'cameraPowerPlanner_autoGearBackups',\n  autoGearPresets: 'cameraPowerPlanner_autoGearPresets',\n  autoGearMonitorDefaults: 'cameraPowerPlanner_autoGearMonitorDefaults',\n  autoGearActivePresetId: 'cameraPowerPlanner_autoGearActivePreset',\n  autoGearAutoPresetId: 'cameraPowerPlanner_autoGearAutoPreset',\n  autoGearBackupRetention: 'cameraPowerPlanner_autoGearBackupRetention',\n  autoGearShowBackups: 'cameraPowerPlanner_autoGearShowBackups',\n});\n\nconst DEFAULT_CACHE_STATE = Object.freeze({\n  autoGearRules: Object.freeze([]),\n  autoGearBackups: Object.freeze([]),\n  autoGearPresets: Object.freeze([]),\n  autoGearMonitorDefaults: Object.freeze({}),\n  autoGearActivePresetId: '',\n  autoGearAutoPresetId: '',\n  autoGearBackupRetention: null,\n  autoGearShowBackups: false,\n});\n\nconst GLOBAL_SCOPE = detectGlobalScope();\n\nfunction cloneCacheValue(value) {\n  if (Array.isArray(value)) {\n    return value.slice();\n  }\n  if (value && typeof value === 'object') {\n    return { ...value };\n  }\n  return value;\n}\n\nfunction buildCacheEntry(value) {\n  return {\n    hydrated: false,\n    value: cloneCacheValue(value),\n  };\n}\n\nfunction createCacheState() {\n  return {\n    autoGearRules: buildCacheEntry(DEFAULT_CACHE_STATE.autoGearRules),\n    autoGearBackups: buildCacheEntry(DEFAULT_CACHE_STATE.autoGearBackups),\n    autoGearPresets: buildCacheEntry(DEFAULT_CACHE_STATE.autoGearPresets),\n    autoGearMonitorDefaults: buildCacheEntry(DEFAULT_CACHE_STATE.autoGearMonitorDefaults),\n    autoGearActivePresetId: buildCacheEntry(DEFAULT_CACHE_STATE.autoGearActivePresetId),\n    autoGearAutoPresetId: buildCacheEntry(DEFAULT_CACHE_STATE.autoGearAutoPresetId),\n    autoGearBackupRetention: buildCacheEntry(DEFAULT_CACHE_STATE.autoGearBackupRetention),\n    autoGearShowBackups: buildCacheEntry(DEFAULT_CACHE_STATE.autoGearShowBackups),\n  };\n}\n\nfunction resolvePersistenceScope() {\n  const candidates = [];\n  if (GLOBAL_SCOPE) candidates.push(GLOBAL_SCOPE);\n  if (typeof globalThis !== 'undefined' && globalThis !== GLOBAL_SCOPE) candidates.push(globalThis);\n  if (typeof window !== 'undefined' && window !== GLOBAL_SCOPE) candidates.push(window);\n  if (typeof self !== 'undefined' && self !== GLOBAL_SCOPE) candidates.push(self);\n  if (typeof global !== 'undefined' && global !== GLOBAL_SCOPE) candidates.push(global);\n\n  for (let index = 0; index < candidates.length; index += 1) {\n    const scope = candidates[index];\n    if (!scope || typeof scope !== 'object') continue;\n    if (scope.cinePersistence) return scope;\n    if (scope.cineModules && typeof scope.cineModules.get === 'function') {\n      const module = scope.cineModules.get('cinePersistence');\n      if (module) return { cinePersistence: module };\n    }\n  }\n\n  return null;\n}\n\nexport class AutoGearService {\n  constructor() {\n    this.cache = createCacheState();\n    this.hydrating = null;\n  }\n\n  hydrateCache(options = {}) {\n    const force = options && options.force === true;\n    if (this.hydrating && !force) {\n      return this.hydrating;\n    }\n\n    this.hydrating = (async () => {\n      const keys = Object.keys(AUTO_GEAR_STORAGE_KEYS);\n      const pending = keys.map(async (name) => {\n        const storageKey = AUTO_GEAR_STORAGE_KEYS[name];\n        try {\n          const value = await storageRepo.getItem(storageKey);\n          this.setCacheValue(name, value, { hydrate: true });\n        } catch (error) {\n          console.warn('[AutoGearService] Failed to hydrate', storageKey, error);\n          this.setCacheValue(name, undefined, { hydrate: true, skipUpdate: true });\n        }\n      });\n\n      await Promise.all(pending);\n      return this.getCacheSnapshot();\n    })();\n\n    return this.hydrating;\n  }\n\n  getCacheSnapshot() {\n    const snapshot = {};\n    Object.keys(this.cache).forEach((name) => {\n      snapshot[name] = cloneCacheValue(this.cache[name].value);\n    });\n    return snapshot;\n  }\n\n  setCacheValue(name, value, options = {}) {\n    const entry = this.cache[name];\n    if (!entry) {\n      return;\n    }\n    const hydrate = options && options.hydrate === true;\n    const skipUpdate = options && options.skipUpdate === true;\n    if (!skipUpdate && typeof value !== 'undefined' && value !== null) {\n      entry.value = cloneCacheValue(value);\n    }\n    if (hydrate) {\n      entry.hydrated = true;\n    }\n  }\n\n  getCacheValue(name) {\n    const entry = this.cache[name];\n    if (!entry) {\n      return undefined;\n    }\n    return cloneCacheValue(entry.value);\n  }\n\n  async persistValue(name, value, binding) {\n    this.setCacheValue(name, value);\n    const persistenceScope = resolvePersistenceScope();\n    const persistence = persistenceScope ? persistenceScope.cinePersistence : null;\n\n    if (persistence && persistence.storage && typeof persistence.storage[binding] === 'function') {\n      return persistence.storage[binding](value);\n    }\n\n    const storageKey = AUTO_GEAR_STORAGE_KEYS[name];\n    return storageRepo.setItem(storageKey, value);\n  }\n\n  readAutoGearRules() {\n    return this.getCacheValue('autoGearRules') || [];\n  }\n\n  readAutoGearBackups() {\n    return this.getCacheValue('autoGearBackups') || [];\n  }\n\n  readAutoGearPresets() {\n    return this.getCacheValue('autoGearPresets') || [];\n  }\n\n  readAutoGearMonitorDefaults() {\n    return this.getCacheValue('autoGearMonitorDefaults') || {};\n  }\n\n  readActivePresetId() {\n    const value = this.getCacheValue('autoGearActivePresetId');\n    return typeof value === 'string' ? value : '';\n  }\n\n  readAutoPresetId() {\n    const value = this.getCacheValue('autoGearAutoPresetId');\n    return typeof value === 'string' ? value : '';\n  }\n\n  readBackupRetention() {\n    return this.getCacheValue('autoGearBackupRetention');\n  }\n\n  readBackupVisibility() {\n    return !!this.getCacheValue('autoGearShowBackups');\n  }\n\n  persistAutoGearRules(rules) {\n    return this.persistValue('autoGearRules', Array.isArray(rules) ? rules : [], 'saveAutoGearRules');\n  }\n\n  persistAutoGearBackups(backups) {\n    return this.persistValue('autoGearBackups', Array.isArray(backups) ? backups : [], 'saveAutoGearBackups');\n  }\n\n  persistAutoGearPresets(presets) {\n    return this.persistValue('autoGearPresets', Array.isArray(presets) ? presets : [], 'saveAutoGearPresets');\n  }\n\n  persistAutoGearMonitorDefaults(defaults) {\n    const payload = defaults && typeof defaults === 'object' ? defaults : {};\n    return this.persistValue('autoGearMonitorDefaults', payload, 'saveAutoGearMonitorDefaults');\n  }\n\n  persistActivePresetId(presetId) {\n    const payload = typeof presetId === 'string' ? presetId : '';\n    return this.persistValue('autoGearActivePresetId', payload, 'saveAutoGearActivePresetId');\n  }\n\n  persistAutoPresetId(presetId) {\n    const payload = typeof presetId === 'string' ? presetId : '';\n    return this.persistValue('autoGearAutoPresetId', payload, 'saveAutoGearAutoPresetId');\n  }\n\n  persistBackupRetention(retention) {\n    return this.persistValue('autoGearBackupRetention', retention, 'saveAutoGearBackupRetention');\n  }\n\n  persistBackupVisibility(visible) {\n    return this.persistValue('autoGearShowBackups', !!visible, 'saveAutoGearBackupVisibility');\n  }\n\n  __internalResetCache() {\n    this.cache = createCacheState();\n    this.hydrating = null;\n  }\n}\n\nexport const autoGearService = new AutoGearService();\n\nautoGearService.hydrateCache().catch((error) => {\n  console.warn('[AutoGearService] Initial hydration failed', error);\n});\n\nif (GLOBAL_SCOPE && typeof GLOBAL_SCOPE === 'object') {\n  if (!GLOBAL_SCOPE.cineAutoGearPersistence) {\n    try {\n      Object.defineProperty(GLOBAL_SCOPE, 'cineAutoGearPersistence', {\n        configurable: true,\n        enumerable: false,\n        writable: false,\n        value: autoGearService,\n      });\n    } catch (error) {\n      void error;\n      GLOBAL_SCOPE.cineAutoGearPersistence = autoGearService;\n    }\n  }\n}\n\ncineModules.register('cineAutoGearPersistence', autoGearService, {\n  category: 'persistence',\n  description: 'Twin-store persistence cache for Auto-Gear state.',\n  connections: ['cinePersistence', 'cineModuleGlobals'],\n  freeze: false,\n  replace: true,\n});\n","import { storageRepo } from '../storage/StorageRepository.js';\n\n/**\n * Service for managing project data.\n * Decouples the V2 Dashboard from legacy global storage functions.\n */\nexport class ProjectService {\n\n    /**\n     * Load a specific project by ID (name)\n     * @param {string} projectId \n     * @returns {Promise<Object|null>}\n     */\n    async getProject(projectId) {\n        if (!projectId) return null;\n        try {\n            const result = await storageRepo.loadProject(projectId);\n            return result ? result.data : null;\n        } catch (e) {\n            console.error('[ProjectService] Failed to load project:', projectId, e);\n            return null;\n        }\n    }\n\n    /**\n     * Get all available projects with their metadata\n     * @returns {Promise<Array<string>>} List of project names\n     */\n    async getProjectNames() {\n        try {\n            return await storageRepo.getProjectKeys();\n        } catch (e) {\n            console.error('[ProjectService] Failed to get project names:', e);\n            return [];\n        }\n    }\n\n    /**\n     * Get metadata for a specific project\n     * @param {string} projectId \n     * @returns {Promise<Object>} Metadata object or empty default\n     */\n    async getProjectMetadata(projectId) {\n        if (!projectId) return {};\n        try {\n            // First try to get lightweight metadata\n            const meta = await storageRepo.getProjectMeta(projectId);\n            if (meta) {\n                // Return legacy-compatible metadata structure if needed,\n                // or just the meta object. For now, let's load the project to be safe\n                // as the dashboard checks specific fields like 'color', 'icon', 'dates'.\n                // Optimization: StorageRepository.loadProject loads everything.\n                // Ideally we'd have a lightweight way to get these fields without full load.\n                // For now, we fallback to full load to ensure compatibility.\n            }\n\n            const result = await storageRepo.loadProject(projectId);\n            if (result && result.data) {\n                return result.data;\n            }\n        } catch (e) {\n            console.error('[ProjectService] Failed to get project metadata:', projectId, e);\n        }\n        return {};\n    }\n\n    /**\n     * Save a project\n     * @param {string} projectId \n     * @param {Object} projectData \n     * @returns {Promise<boolean>}\n     */\n    async saveProject(projectId, projectData) {\n        if (!projectId || !projectData) return false;\n\n        try {\n            // Basic structural validation/normalization could go here\n            if (typeof projectData !== 'object') {\n                console.warn('[ProjectService] Invalid project data');\n                return false;\n            }\n\n            // Ensure lastModified is set\n            if (!projectData.lastModified) {\n                projectData.lastModified = new Date().toISOString();\n            }\n\n            const result = await storageRepo.saveProject(projectId, projectData);\n            return result.success;\n        } catch (e) {\n            console.error('[ProjectService] Failed to save project:', projectId, e);\n            return false;\n        }\n    }\n\n    /**\n     * Create a new project\n     * @param {string} projectId \n     * @returns {Promise<boolean>}\n     */\n    async createProject(projectId) {\n        if (!projectId) return false;\n\n        const newProject = {\n            created: new Date().toISOString(),\n            lastModified: new Date().toISOString(),\n            gearList: '',\n            projectInfo: null,\n            gearListAndProjectRequirementsGenerated: false,\n            color: 'blue', // Default color\n            icon: ''   // Default icon\n        };\n\n        return this.saveProject(projectId, newProject);\n    }\n\n    /**\n     * Delete a project\n     * @param {string} projectId \n     * @returns {Promise<boolean>}\n     */\n    async deleteProject(projectId) {\n        if (!projectId) return false;\n        try {\n            await storageRepo.removeProject(projectId);\n            return true;\n        } catch (e) {\n            console.error('[ProjectService] Failed to delete project:', projectId, e);\n            return false;\n        }\n    }\n\n    /**\n     * Duplicate a project\n     * @param {string} sourceId \n     * @returns {Promise<{success: boolean, newId?: string}>}\n     */\n    async duplicateProject(sourceId) {\n        try {\n            if (typeof sourceId !== 'string' || sourceId.length === 0) {\n                return { success: false };\n            }\n\n            const cleanSourceId = sourceId.trim();\n            const sourceProject = await this.getProject(cleanSourceId);\n\n            if (!sourceProject) {\n                return { success: false };\n            }\n\n            // Generate unique name\n            const existingNames = await this.getProjectNames();\n            let newName = `${cleanSourceId} (Copy)`;\n            let counter = 2;\n            while (existingNames.includes(newName)) {\n                newName = `${cleanSourceId} (Copy ${counter})`;\n                counter++;\n            }\n\n            // Clone data\n            const newData = JSON.parse(JSON.stringify(sourceProject));\n            newData.created = new Date().toISOString();\n            newData.lastModified = new Date().toISOString();\n\n            // Save\n            const saved = await this.saveProject(newName, newData);\n            return { success: saved, newId: newName };\n\n        } catch (e) {\n            console.error('[ProjectService] Failed to duplicate project:', e);\n            return { success: false };\n        }\n    }\n}\n\nexport const projectService = new ProjectService();\n"],"file":"core-modules-DlPoJ4C3.js"}