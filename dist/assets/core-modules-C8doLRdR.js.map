{"version":3,"mappings":"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CA,kBACA,kBACA,iBACA,mBAEF,wBAAyB,CACvB,8BACA,4BACA,6BACA,iCACA,+BAEF,mBAAoB,CAClB,uBACA,mBACA,2BACA,yBACA,+BAEF,6BAA8B,CAC5B,mCACA,6BACA,sCACA,yCACA,2CAEF,WAAY,CACV,cACA,cACA,eACA,iBACA,oBAEF,qBAAsB,CACpB,0BACA,wBACA,0BACA,iCACA,gCAEF,sBAAuB,CACrB,2BACA,6BACA,4BACA,sCACA,uBAEF,OAAQ,CAAC,SAAU,YAAa,WAAY,UAAW,WAAW,EAClE,kBAAmB,CACjB,qBACA,gBACA,mBACA,wBACA,qBAEF,aAAc,CACZ,gBACA,mBACA,iBACA,uBACA,mBAEF,oBAAqB,CACnB,uBACA,sBACA,mBACA,qBACA,mBAEF,0BAA2B,CACzB,+BACA,4BACA,6BACA,6BACA,uBAEF,SAAU,CAAC,WAAY,YAAa,YAAa,YAAa,WAAW,EACzE,OAAQ,CACN,SACA,sBACA,uBACA,uBACA,yBAEF,kBAAmB,CACjB,qBACA,kBACA,qBACA,wBACA,uBAEF,kBAAmB,CACjB,qBACA,qBACA,wBACA,4BACA,yBAEF,wBAAyB,CACvB,2BACA,2BACA,8BACA,kCACA,+BAEF,aAAc,CACZ,gBACA,eACA,iBACA,kBACA,iBAEF,mBAAoB,CAClB,+BACA,0BACA,oCACA,2CACA,yBAEF,kBAAmB,CACjB,sBACA,iBACA,+BACA,kCACA,gBAEF,sBAAuB,CACrB,0BACA,iBACA,+BACA,+BACA,gBAEF,gBAAiB,CACf,oBACA,YACA,oBACA,qBACA,qBAEF,WAAY,CACV,cACA,aACA,cACA,eACA,gBAEF,YAAa,CACX,eACA,cACA,mBACA,mBACA,qBAEF,eAAgB,CACd,kBACA,kBACA,mBACA,qBACA,oBAEF,WAAY,CACV,cACA,gBACA,cACA,kBACA,eAEF,QAAS,CACP,wBACA,yBACA,+BACA,2BACA,6BAEJ,EAEIC,GAAiC,CACnC,2BACA,0BACA,2BACA,wBACA,0BACA,8BACA,0BACF,EAEA,SAASC,GAA2BtnB,EAAO,CACzC,OAAI,OAAOA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","names":["globalScope","VALID_ICON_FONTS","keys","fonts","font","toCodePointChar","value","radix","codePoint","normalizeGlyphChar","char","trimmed","unicodeMatch","decoded","unicodeBraceMatch","hexEntityMatch","decimalEntityMatch","iconGlyph","defaultFont","requestedFont","normalizedFont","glyph","resolveIconGlyph","size","fontKey","className","ensureSvgHasAriaHidden","markup","applyIconGlyph","element","resolved","cls","iconMarkup","parts","finalClass","svg","fontAttr","formatSvgCoordinate","rounded","positionSvgMarkup","centerX","centerY","half","x","y","width","height","match","attrs","attrText","additions","STAR_ICON_SVG","ICON_GLYPHS","detectGlobalScope","isObjectLike","freezeArray","array","cloneArray","clone","index","createPrimaryCache","getPrimaryCacheEntry","cache","primary","entry","key","pushUnique","target","BASE_SCOPES","scopes","EMPTY_EXTRAS","SUPPORTS_WEAKMAP","DETECT_CACHE","sanitizeExtras","extras","sanitized","computeCandidateScopes","detectFn","extrasList","detected","getExtrasCache","detectEntry","extrasEntry","getDetectEntry","collectInternal","cacheEntry","primaryEntry","computed","computedFallback","createCollector","options","collectCandidateScopes","getBaseScopes","GLOBAL_SCOPE","DEFAULT_PENDING_QUEUE_KEY","fallbackDetectGlobalScope","installSafeConsoleGuards","scope","targetScope","consoleRef","methods","originals","method","candidate","guarded","createScopeCollector","DEFAULT_EXTRAS_KEY","HELPER_COLLECTOR_CACHE","BASE_SCOPE_EXTRAS_CACHE","resolveExtrasForBaseScope","baseScope","resolveHelperCollector","extrasKey","collector","fallbackCollectCandidateScopes","resolvedBaseScope","pushScope","fallbackTryRequire","modulePath","fallbackDefineHiddenProperty","name","fallbackEnsureQueue","queueKey","queue","BUILTIN_IMMUTABILITY","registryKey","isEthereumProviderCandidate","PRIMARY_SCOPE","inspectionError","ctorName","isNodeProcessReference","functionName","source","shouldBypassDeepFreeze","tag","fallbackResolveSeenTracker","seen","tracked","fallbackFreezeDeep","tracker","descriptor","child","fallbackSafeWarn","message","detail","fallbackResolveModuleRegistry","fallbackQueueModuleRegistration","api","payload","createFallbackKernel","primaryScope","resolveArchitectureKernel","LOCAL_SCOPE","RESOLVED_KERNEL","ACTIVE_KERNEL","scoped","PENDING_QUEUE_KEY","collected","baseTryRequire","result","baseResolveModuleRegistry","required","cachedModuleRegistry","hasResolvedRegistry","getModuleRegistry","ensureQueue","queueModuleRegistration","baseRegisterOrQueueModule","registry","onError","error","baseFreezeDeep","baseSafeWarn","exposeGlobal","baseApi","moduleRegistry","ensureConsoleMethodsWritable","QUEUE_FLUSH_TIMER_KEY","moduleMap","metadataMap","registryReference","resolveImmutability","createFallbackImmutability","shouldBypass","freeze","FALLBACK_IMMUTABILITY","activeImmutability","getImmutability","freezeDeep","provider","normalizeName","normalizeConnections","entries","normalized","raw","register","moduleApi","normalizedName","existing","get","has","list","describe","meta","normalizeNameCollection","normalizeCategoryCollection","describeAll","normalizedNames","normalizedCategories","namesFilter","categoryFilter","snapshot","sourceNames","left","right","assertRegistered","names","missing","present","resetForTests","getTimerDescriptor","assignHidden","cancelPendingFlush","clearTimer","schedulePendingFlush","scheduleFromScope","clearFromScope","timerId","flushPendingRegistrations","pending","collectQueueScopes","preferredScope","readQueueFromScope","ensureQueueOnScope","resolveQueueDescriptor","queueRegistrationPayload","record","queueScope","createBlueprint","normalizedCategory","normalizedDescription","freezeByDefault","normalizedConnections","factory","staticApi","metadata","cachedApi","instantiated","instantiateError","buildRegistrationOptions","overrides","base","instantiate","context","produced","invocationContext","frozenContext","registerBlueprint","resolvedRegistry","registrationOptions","deferOnError","targetRegistry","blueprint","baseDetectGlobalScope","FALLBACK_SCOPE","safeAssign","detect","append","tryRequire","resolveFromScopes","propertyName","settings","predicate","candidates","getCachedGlobalValue","VIDEO_OUTPUT_TYPES","NORMALIZED_FLAG_KEY","memoizeNormalization","fn","str","VIDEO_TYPE_PATTERNS","normalizeVideoType","_","needles","n","FIZ_CONNECTOR_MAP","createMapNormalizer","map","normalizeFizConnectorType","VIEWFINDER_TYPE_MAP","normalizeViewfinderType","POWER_PORT_TYPE_MAP","mapPowerPortOne","normalizePowerPortType","type","toArray","val","piece","ensureList","defaults","item","fixPowerInput","dev","input","normalizeEntry","it","pType","tType","rest","typeField","applyFixPowerInput","collection","hasNormalizedDevicesMarker","bundle","markDevicesNormalized","unifyDevices","devicesData","cam","m","mount","notes","vo","count","norm","parsedCount","num","fc","vf","lm","idx","arr","o","lens","normalizeMountEntry","status","existingMountOptions","normalizedOptions","pushNormalizedEntry","mountType","dedupedOptions","opt","mountState","safeMountOptions","mountOptions","primaryType","fizGroups","c","p","normalizeDevicesForPersistence","loggingResolveStructuredClone","loggingJsonDeepClone","LOGGING_DEEP_CLONE","structuredCloneImpl","fallbackLoadModuleEnvironment","fallbackLoadEnvironmentBridge","fallbackResolveModuleGlobals","MODULE_ENV","ENV_BRIDGE","MODULE_GLOBALS","structuredCloneCandidates","addCandidate","cachedStructuredCloneCandidate","tryStructuredCloneValue","cloned","resolveModuleRegistry","bridged","cineModules","MODULE_REGISTRY","shared","provided","registerOrQueueModule","registered","ctor","visited","define_process_env_default","freezeError","safeWarn","CONSOLE_METHODS","CONSOLE_PROXY_FLAG","ORIGINAL_CONSOLE_FUNCTIONS","store","consoleProxyInstalled","consoleProxyInstallationAttempted","consoleProxyInstallationFailed","lastConsoleCaptureState","consoleProxyWarningIssued","consoleProxyGuardDepth","informModuleGlobals","LOG_LEVEL_MAP","LOG_LEVELS","LEVEL_COUNTER_KEYS","createLevelCounters","counters","resetLevelCounters","resolveLevelKey","level","getCounterValue","applyLevelCounterDelta","delta","next","applyLevelCounterDeltaForEntries","summariseEntriesByLevel","summary","accumulateLevelSummary","increment","current","cloneLevelSummary","freezeLevelSummary","HISTORY_MIN_LIMIT","HISTORY_ABSOLUTE_MIN_LIMIT","HISTORY_MAX_LIMIT","HISTORY_STORAGE_KEY","CONFIG_STORAGE_KEY","ERROR_EVENT_FLAG","DEFAULT_CONFIG_VALUES","DEFAULT_CONFIG","SERVICE_WORKER_LOG_CHANNEL","SERVICE_WORKER_LOG_ENTRY_TYPE","SERVICE_WORKER_LOG_STATE_REQUEST","SERVICE_WORKER_LOG_STATE_RESPONSE","SERVICE_WORKER_LOG_REQUEST_TIMEOUT","SERVICE_WORKER_LOG_POLL_INTERVAL","SERVICE_WORKER_LOG_HISTORY_LIMIT","cloneDefaultConfig","activeConfig","logHistory","logSubscribers","configSubscribers","attachedErrorTargets","runtimeEntryCount","emittedLevelCounters","retainedLevelCounters","droppedLevelCounters","totalEntriesDropped","lastHistoryDrop","serviceWorkerBridgeState","normalizeLevel","fallbackLevel","fallback","getLevelPriority","booleanFromValue","clampHistoryLimit","effectiveMinimum","absolute","parsed","coerceMessage","sanitizeForLog","depth","nextDepth","valueType","errorOutput","collectedErrors","truncatedErrors","appendErrorDetail","rawErrors","iterator","symbolIterator","maxPreview","length","preview","previewLength","mapCtor","mapValue","mapKey","setCtor","items","urlParamsCtor","params","truncated","pair","len","output","maxKeys","symbols","symbolLength","symbolKey","symbolName","structuredCloneResult","normaliseStackTrace","stackValue","maxLength","charTruncated","limitedStack","rawLines","frameLimit","frames","frameTruncated","line","normaliseOriginSnapshot","origin","stackSummary","frame","getSessionStorage","storage","clearStoredHistory","persistConfigSafe","persistHistorySafe","getEffectiveHistoryLimit","recordHistoryDrop","removedEntries","limit","removedSummary","oldestEntry","newestEntry","dropTimestamp","dropIsoTimestamp","enforceHistoryLimit","overflow","shouldRecord","shouldOutputToConsole","getLevelState","normalizedLevel","consoleEnabled","historyEnabled","isLevelEnabled","state","checkConsole","checkHistory","createEntryId","timestamp","pushEntryToHistory","appendEntry","notifyLogSubscribers","listeners","listener","getHistorySnapshot","effectiveLimit","start","slice","notifyConfigSubscribers","arrayFromArrayLike","safeArrayPush","getConsoleLevelForMethod","getStoredConsoleFunction","stored","invokeConsoleMethod","args","receiver","finalArgs","recordConsoleMessage","rawArgs","messageParts","sanitizedArguments","detailPayload","errorEntries","sanitizedArray","rawValue","sanitizedValue","isErrorInstance","hasSanitizedErrorShape","valueClone","coercedMessage","rawType","contextMeta","metaKeys","errorIndices","errorEntry","primaryError","forceStackCapture","contextOptions","logInternal","installConsoleProxies","installedAny","proxy","argsArray","firstArg","recordError","removeConsoleProxies","restoredAny","original","syncConsoleCaptureState","buildConsoleCaptureDetail","isConsoleCaptureActive","overrideKeys","enableConsoleCapture","setConfig","disableConsoleCapture","shouldCaptureOrigin","override","captureLogOrigin","stackSource","detailStack","stackMessage","captureError","isoTimestamp","captureContext","namespace","sanitizedDetail","internalOptions","methodName","prefixParts","consoleArgs","debug","info","warn","getConfigSnapshot","getHistory","cloneLastDropSnapshot","getStats","clearHistory","subscribe","subscribeConfig","mergeMeta","baseMeta","merged","baseKeys","createLogger","normalizedNamespace","logWithNamespace","mergedMeta","optionOverrides","markEventHandled","event","flag","handleGlobalError","handleUnhandledRejection","markTargetAttached","attachGlobalErrorListeners","applyConfig","changed","captureChanged","limitChanged","consoleCaptureChanged","nextPersistSession","nextLevel","nextHistoryLevel","nextLimit","nextConsole","nextCapture","nextConsoleCapture","nextStackTraces","previousCapture","previousConsoleCapture","resolveConfigPresetFromScopes","scopeIndex","keyIndex","applyConfigFromStorage","applyConfigFromQuery","search","updates","hasUpdates","assignUpdate","part","eqIndex","normaliseStoredEntry","normalizedMessage","normalizedId","getGlobalNavigator","getNavigatorServiceWorker","nav","markServiceWorkerEntrySeen","id","mergeServiceWorkerEntryMeta","snapshotMeta","channel","importServiceWorkerLogEntries","rawEntry","entryId","finalizeServiceWorkerLogRequest","requestId","scheduleServiceWorkerLogPoll","requestServiceWorkerLogSnapshot","ensureServiceWorkerBroadcastChannel","handleServiceWorkerLogMessage","data","reason","serviceWorker","closeMessageChannel","readyPromise","registration","worker","controller","targetWorker","settled","finalize","finalizeWithPoll","handleResponse","handleChannelError","postWithoutChannel","setupServiceWorkerLogBridge","loadPersistedHistory","initialiseConfig","preset","loggingAPI","baseConsole","consoleDescriptor","requestedMethods","unique","i","methodNames","property","resolveModuleBase","MODULE_BASE","push","resolveLoggingFromScope","logging","resolveLogging","cloneMeta","resolveConsoleMethod","fallbackWarningIssued","createConsoleFallbackLogger","consoleMethod","resolveLogger","logger","resolverApi","queueError","CONTACTS_STORAGE_KEY","resolveLocalStorage","generateContactId","sanitizeContactValue","primitive","stringified","normalizeContactEntry","role","phone","email","website","avatar","createdAt","updatedAt","sortContacts","a","b","nameA","nameB","loadStoredContacts","storageKey","saveContactsToStorage","contacts","exposedViaModuleBase","StorageInterface","LocalStorageAdapter","e","UserContext","uuid","deviceId","userContext","SYNC_METADATA_VERSION","SyncStatus","LockStatus","nowISO","generateDocId","prefix","random","createSyncMetadata","identity","now","updateSyncMetadata","existingMeta","markAsSynced","serverTimestamp","markAsConflict","errorMessage","wrapWithMetadata","unwrapMetadata","wrapped","hasMetadata","LOCK_CHANNEL_NAME","HEARTBEAT_INTERVAL_MS","LOCK_TIMEOUT_MS","LOCK_STORAGE_PREFIX","LockEvent","ProjectLockService","err","projectId","existingLock","lock","callback","intervalId","oldLock","projectLockService","StorageRepository","newDriver","scopedKey","deletionPromises","k","allKeys","projectKey","projectData","lockInfo","__vitePreload","dataVault","DataVault$1","projects","storageRepo","IndexedDBAdapter","compressed","decompressed","LZString","set","del","clear","MIGRATION_FLAG_KEY","StorageMigrationService","keysToMigrate","UserContext$1","importError","itemError","migrationService","OWN_GEAR_KEY","GearRepository","query","q","gearRepo","DataVault","filename","safeFilename","writable","files","handle","text","file","projectMemoryCache","isProjectCacheHydrated","hydrateProjectCache","monolithKey","loadMonolith","shardKeys","PROJECT_INDEX_KEY","projectIndexCache","AUTO_GEAR_MONITOR_DEFAULTS_STORAGE_KEY","autoGearMonitorDefaultsCache","AUTO_GEAR_ACTIVE_PRESET_STORAGE_KEY","autoGearActivePresetIdCache","AUTO_GEAR_AUTO_PRESET_STORAGE_KEY","autoGearAutoPresetIdCache","AUTO_GEAR_BACKUP_RETENTION_STORAGE_KEY","autoGearBackupRetentionCache","AUTO_GEAR_BACKUP_VISIBILITY_STORAGE_KEY","autoGearBackupVisibilityCache","CUSTOM_FONT_STORAGE_KEY_DEFAULT","customFontsCache","CUSTOM_LOGO_STORAGE_KEY","customLogoCache","CAMERA_COLOR_STORAGE_KEY","cameraColorsCache","PRINT_PREFERENCES_STORAGE_KEY","printPreferencesCache","contactsCache","OWN_GEAR_STORAGE_KEY","ownGearCache","USER_PROFILE_STORAGE_KEY","userProfileCache","FAVORITES_STORAGE_KEY","favoritesCache","TEMPERATURE_UNIT_STORAGE_KEY_NAME","temperatureUnitCache","FOCUS_SCALE_STORAGE_KEY_NAME","focusScaleCache","getMountVoltageStorageKeyName","mountVoltagesCache","FULL_BACKUP_HISTORY_STORAGE_KEY","fullBackupHistoryCache","monoErr","shardPromises","shardErr","FORCE_STORAGE_REINITIALIZE","FACTORY_RESET_LOCK_KEY","LIFECYCLE_CHANNEL_NAME","lifecycleChannel","isJestWorker","lockError","lockValue","invalidateProjectReadCache","scopeList","justReset","s","migrationError","closeStorageLifecycle","storageManualDeepClone","references","referenceStore","clonedDate","timeValue","storageJsonDeepClone","storageResolveStructuredClone","storageCreateResilientDeepClone","STORAGE_DEEP_CLONE","knownSessionStorages","registerKnownSessionStorage","resolveSessionStorageFromScope","resolveLocalStorageFromScope","collectLocalStorageCandidates","isFactoryResetActive","readFlag","fallbackScopes","DEVICE_STORAGE_KEY","DEVICE_STORAGE_KEY_VARIANTS","SETUP_STORAGE_KEY","SESSION_STATE_KEY","FEEDBACK_STORAGE_KEY","PROJECT_STORAGE_KEY","PROJECT_STORAGE_REV_KEY","DOCUMENTATION_TRACKER_STORAGE_KEY","DEVICE_SCHEMA_CACHE_KEY","LEGACY_SCHEMA_CACHE_KEY","MOUNT_VOLTAGE_STORAGE_KEY_FALLBACK","MOUNT_VOLTAGE_STORAGE_KEY_SYMBOL","PROJECT_STORAGE_READ_CACHE","STORAGE_CACHE_SYMBOL","PROJECT_SHARD_PREFIX","STORAGE_STATE_CACHE_WEAKMAP","CONTACTS_MODULE_API","CONTACTS_MODULE_RESOLUTION_ATTEMPTED","COMPRESSION_STRATEGY_CACHE","COMPRESSION_STRATEGY_CACHE_KEYS","COMPRESSION_STRATEGY_CACHE_LIMIT","COMPRESSION_CANDIDATE_CACHE_MISS","STORAGE_COMPRESSION_CANDIDATE_CACHE","createCompressionCandidateCache","MIGRATION_BACKUP_COMPRESSION_CANDIDATE_CACHE","AUTO_BACKUP_COMPRESSION_CACHE","AUTO_BACKUP_COMPRESSION_CACHE_KEYS","AUTO_BACKUP_COMPRESSION_CACHE_LIMIT","cloneAutoBackupCompressionValue","readAutoBackupCompressionCache","signature","cached","writeAutoBackupCompressionCache","compression","isCompressedAutoBackupSnapshotPayload","existingIndex","oldest","resetAutoBackupCompressionCache","COMPRESSION_WARNING_LIMIT","COMPRESSION_WARNING_BATCH_SIZE","COMPRESSION_LOG_SUMMARY_WINDOW_MS","compressionWarningRegistry","storageLoggingResolverCache","storageLoggerCache","storageLoggerResolutionAttempted","consoleHelpersImport","consoleHelpersImport.ensureConsoleMethodsWritable","ACTIVE_PROJECT_COMPRESSION_HOLD_KEY","ACTIVE_PROJECT_COMPRESSION_HOLD_ENABLED","collectStorageLoggingScopes","enqueue","resolveStorageLoggingResolver","loggingResolverImport","resolver","resolveStorageLogger","sanitizeStorageError","getActiveStorageType","safeLocalStorageInfo","logStorageEvent","consoleCallback","handled","resolvedMeta","metaIndex","metaKey","getCompressionLogTimestamp","logCompressionSavingsEvent","kind","identifier","savings","percent","entryKey","keyLabel","consoleLogger","shouldSummarize","getCompressionLogSnapshot","getCompressionStrategyCacheKey","variants","segments","variant","compressName","decompressName","readCompressionStrategyCache","cacheKey","lzReference","pruneCompressionStrategyCache","oldestKey","writeCompressionStrategyCache","strategies","computeStorageCompressionWrapperBaseLength","skeleton","STORAGE_COMPRESSION_FLAG_KEY","STORAGE_COMPRESSION_VERSION","STORAGE_COMPRESSION_ALGORITHM","STORAGE_COMPRESSION_NAMESPACE","serialized","emptyLiteralLength","numericLimit","cloneCompressionCandidate","touchCompressionCandidateCacheKey","readCompressionCandidateCacheEntry","writeCompressionCandidateCacheEntry","getStorageStateCacheMap","createIfMissing","assigned","getCachedStorageEntry","clearCachedStorageEntry","cloneValueForCache","cloneCachedEntryValue","cloneLookupMap","copy","cloneProjectLookupSnapshotForReturn","lookup","captureProjectLookupSnapshotForCache","freezeProjectSnapshotProjects","isPlainObject","frozen","setProjectReadCacheSnapshot","getProjectReadCacheClone","safeStorage","getSafeLocalStorage","currentRaw","forMutation","normalizeProjectStorageRevisionValue","getProjectStorageRevisionKeyName","loadProjectStorageRevision","storageOverride","loadJSONFromStorage","bumpProjectStorageRevision","saveJSONToStorage","cacheStorageValue","normalizedValue","cachedValue","tryGetCachedStorageValue","primaryRaw","rawStored","readGlobalStringValue","directValue","symbolValue","exposeGlobalStringValue","symbolAssigned","resolveMountVoltageStorageKeyName","exposed","MOUNT_VOLTAGE_STORAGE_KEY_NAME","refreshMountVoltageStorageKeyName","RAW_STORAGE_BACKUP_KEYS","getStorageKeyVariants","getMountVoltageStorageBackupKeyName","ensureCustomFontStorageKeyName","existingName","getCustomFontStorageKeyName","TEMPERATURE_UNIT_STORAGE_KEY_DEFAULT","FOCUS_SCALE_STORAGE_KEY_DEFAULT","resolveTemperatureUnitStorageKey","assignError","defineError","AUTO_GEAR_RULES_STORAGE_KEY","AUTO_GEAR_SEEDED_STORAGE_KEY","AUTO_GEAR_BACKUPS_STORAGE_KEY","AUTO_GEAR_PRESETS_STORAGE_KEY","STORAGE_AUTO_BACKUP_NAME_PREFIX","STORAGE_AUTO_BACKUP_DELETION_PREFIX","STORAGE_AUTO_BACKUP_RENAMED_FLAG","AUTO_BACKUP_METADATA_PROPERTY","AUTO_BACKUP_SNAPSHOT_PROPERTY","AUTO_BACKUP_SNAPSHOT_VERSION","AUTO_BACKUP_PAYLOAD_COMPRESSION_FLAG","AUTO_BACKUP_CYCLE_PLACEHOLDER","projectActivityTimestamps","forcedCompressedProjectKeys","AUTO_BACKUP_PAYLOAD_COMPRESSION_MIN_LENGTH","isAutoBackupStorageKey","MAX_AUTO_BACKUPS","MAX_DELETION_BACKUPS","AUTO_GEAR_BACKUP_RETENTION_DEFAULT_VALUE","AUTO_GEAR_BACKUP_RETENTION_MIN","AUTO_GEAR_BACKUP_RETENTION_MAX","ensureGlobalAutoGearBackupDefaults","cloneAutoBackupMetadata","cloneAutoBackupValue","defineAutoBackupMetadata","clonedMetadata","getAutoBackupMetadata","copyAutoBackupMetadata","opts","cloneState","handleCircularClone","compute","cloneAutoBackupValueWithLegacyNormalization","normalizeLegacyLongGopStructure","prepareAutoBackupSnapshotPayloadForStorage","contextName","shouldReport","computedSignature","createStableValueSignature","signatureError","existingSignature","reusedPayload","reusedCompression","decodedExisting","decodeCompressedJsonStorageValue","resolvedSignature","createCompressedJsonStorageCandidate","compressedPayload","compressionInfo","label","restoreAutoBackupSnapshotPayload","rawPayload","details","deriveAutoBackupCreatedAt","fallbackDate","parseAutoBackupKey","sourceDate","detectCyclicAutoBackupReference","path","maxSteps","steps","currentName","currentMetadata","baseName","baseEntry","promoteAutoBackupMetadataToFull","expandAutoBackupEntries","container","isAutoBackupKey","filter","shouldIncludeEntry","include","resolve","stack","restored","restoreCompressedProjectEntry","clonedValue","fallbackPayload","payloadKeys","payloadSignature","payloadInfo","cycleSignatureError","cyclePayloadError","snapshotType","baseValue","payloadError","changedKeys","removedKeys","expanded","payloadSignatureError","computeAutoBackupDiff","currentValue","currentKeys","hasCurrent","hasBase","currentEntry","currentSignature","baseSignature","serializeAutoBackupEntries","entryNames","latestAutoBackupNames","groups","parsedKey","groupKey","disableCompressionForName","prepared","normalizedBase","diff","SETUP_STORAGE_KEY_VARIANTS","getDeviceStorageKeyVariants","isDeviceStorageKeyVariant","shouldAllowCriticalSweepPrimaryInspection","inspectSetupStorageForQuotaRecovery","skipKeysSet","skipSet","STORAGE_BACKUP_SUFFIX","MAX_SAVE_ATTEMPTS","MAX_QUOTA_RECOVERY_STEPS","STORAGE_MIGRATION_BACKUP_SUFFIX","CRITICAL_BACKUP_KEY_PROVIDERS","readAllProjectsFromStorage","createCriticalStorageEntry","backupKey","resolvedBackupKey","gatherCriticalStorageEntries","pushEntry","expectedBaseBackupKey","variantKey","variantEntry","storageId","providerError","providerDetail","lastCriticalStorageGuardResult","registerCriticalStorageGuardResult","ensureCriticalStorageBackups","guardError","guardDetail","targetStorage","primaryValue","readError","primaryReadDetail","backupValue","backupReadError","backupReadDetail","stringPrimaryValue","tryStoreBackup","mirrorDetail","shouldAttemptCompression","candidateValue","writeResult","isQuotaExceededError","compressedCandidate","skipKeys","shouldInspectPrimaryDuringSweep","sweepResult","attemptStorageCompressionSweep","alertStorageError","ensuredDetail","mirroredDetails","errorDetail","getLastCriticalStorageGuardResult","MAX_MIGRATION_BACKUP_CLEANUP_STEPS","MIGRATION_BACKUP_COMPRESSION_ALGORITHM","MIGRATION_BACKUP_COMPRESSION_ENCODING","MIGRATION_BACKUP_COMPRESSION_VARIANTS","LEGACY_STORAGE_COMPRESSION_ALGORITHM","STORAGE_COMPRESSION_VARIANTS","STORAGE_COMPRESSION_ALGORITHM_LITERAL","STORAGE_COMPRESSION_NAMESPACE_LITERAL","STORAGE_COMPRESSION_WRAPPER_BASE_LENGTH","storageCompressionPatchedStorages","STORAGE_COMPRESSION_SWEEP_LIMIT","STORAGE_COMPRESSION_SWEEP_MIN_SAVINGS","STORAGE_RAW_GET_ITEM_PROPERTY","STORAGE_PROACTIVE_COMPRESSION_MIN_LENGTH","STORAGE_PROACTIVE_COMPRESSION_MIN_SAVINGS","STORAGE_PROACTIVE_COMPRESSION_MIN_RATIO","getAvailableLZStringCompressionStrategies","cachedStrategies","available","compressFn","decompressFn","variantLiteral","variantLiteralLength","tryDecompressWithStrategies","preferredVariant","contextLabel","attempts","preferred","j","lastError","strategy","canUseMigrationBackupCompression","tryCreateCompressedMigrationBackupCandidate","serializedPayload","bestCandidate","compressionError","serializedCompressedPayload","serializationError","parseMigrationBackupMetadata","MIGRATION_BACKUP_LEGACY_CREATED_AT_KEYS","canUseJsonValueCompression","baseWrapperLength","best","bestSerialized","bestCompressedLiteral","bestVariantLiteral","originalLengthDigits","compressedLiteral","compressedLiteralError","candidateSerialized","candidateLength","compressedLengthDigits","legacyWrapper","finalVariantLiteral","serializedWrapper","parseError","markProjectActivity","recordTime","normalizeProjectStorageKey","markProjectCollectionActivity","removeProjectActivity","normalizeForcedProjectCompressionKey","isForcedProjectCompressionLocked","ensureProjectEntryUncompressed","ensureProjectEntriesUncompressed","registerActiveSetupStorageSkipKeys","keysToSkip","registerProtectedCompressionSkipKeys","keysToProtect","variantIndex","maybeDecompressStoredString","isSessionStorageInstance","minSavings","minSavingsThreshold","total","upperLimit","compressedCount","freedCharacters","decodeStoredValue","patchIndividualStorageGetItem","originalGetItem","rawGetItem","patchedGetItem","suppressDefineWarning","suppressAssignWarning","patchStorageGetItemForCompression","prototype","patchError","getRawStorageGetter","direct","readRawStorageValue","rawGetterOverride","getter","collectMigrationBackupEntriesForCleanup","excludeKey","snapshotStorageEntries","pruneMigrationBackupEntriesForCleanup","attemptMigrationBackupQuotaRecovery","tryWrite","removedBackups","attemptWrite","clearUiCacheStorageEntries","cleared","clearError","retryAfterClear","attempt","removed","retry","ensurePreWriteMigrationBackup","parsedValue","normalizedRawValue","createStorageMigrationBackup","MIGRATION_BACKUP_LEGACY_DATA_KEYS","trySerializeMigrationBackupValue","normalizeLegacyMigrationBackupCreatedAt","fallbackIso","numeric","iso","time","normalizeLegacyMigrationBackupValue","listChanged","normalizedList","hasData","itemCreatedAt","normalizedDate","dateChanged","usedKey","rawCreatedAt","createdAtSourceKey","createdAtChanged","upgradeLegacyMigrationBackupEntry","originalValue","hasExistingBackup","fallbackCreatedAt","existingRaw","existingData","jsonError","newEntry","MAX_BACKUP_HISTORY","tryStoreList","candidateList","recovery","appendError","tryStoreSerialized","logCompression","storedLength","rawSavings","standardCandidate","standardResult","handleFailure","runRecoveryWith","fallbackError","errorToReport","compressedResult","PRIMARY_STORAGE_KEYS","SIMPLE_STORAGE_KEYS","STORAGE_ALERT_FLAG_NAME","SESSION_FALLBACK_ALERT_FLAG_NAME","storageErrorAlertShown","sessionFallbackAlertShown","DEVICE_COLLECTION_KEYS","FIZ_COLLECTION_KEYS","ACCESSORY_COLLECTION_KEYS","getStorageManager","STORAGE_TEST_KEY","QUOTA_ERROR_NAMES","QUOTA_ERROR_CODES","QUOTA_ERROR_NUMBERS","hasStoredEntries","lengthError","candidateKey","iterationError","verifyStorage","cleanupError","createMemoryStorage","memoryStore","initializeSafeLocalStorage","localCandidates","lastFailedUpgradeCandidate","alertSessionFallback","migrateSnapshotToStorage","migratedKeys","failedKeys","existingRead","writeError","clearMigratedKeys","keysToRemove","rollbackMigratedKeys","suppressAlerts","captureKey","updateGlobalSafeLocalStorageReference","downgradeSafeLocalStorageToMemory","failingStorage","activeStorage","snapshotError","fallbackStorage","fallbackType","sessionScopes","verified","sessionError","copyError","fallbackDescription","attemptLocalStorageUpgrade","currentStorage","selectedCandidate","verifiedStorage","verificationError","persistentStorageRequestPromise","requestPersistentStorage","storageManager","trackedPromise","alreadyGranted","supportsPersistedCheck","persistedError","granted","verifyError","isMapLike","convertMapLikeKey","json","convertMapLikeToObject","mapLike","assignEntry","rawKey","iterated","step","LEGACY_LONG_GOP_TOKEN_REGEX","inferLegacyLongGopCompressionVariant","lower","normalizeLegacyLongGopString","normalizeLegacyLongGopKey","normalizedArray","normalizedItem","normalizedObject","normalizedKey","normalizeLegacyLongGopBackups","backups","normalizedEntry","parseWithPrefix","yearPart","monthPart","dayPart","hourPart","minutePart","year","month","day","hour","minute","includeSeconds","seconds","labelStartIndex","secondsCandidate","collectAutoBackupEntries","markAutoBackupValueAsRenamed","isAutoBackupValueRenamed","isRenamedAutoBackupEntry","getAutoBackupLabelKey","getAutoBackupEntrySignature","preparedValue","cloneForSignature","signatureState","seenSet","handleCircularSignature","signatureParseError","removeSingleDuplicateAutoBackupEntry","seenSignaturesByLabel","labelKey","labelSignatures","removeDuplicateAutoBackupEntries","removedKey","pruneAutoBackupEntries","duplicateBuckets","bucketKey","removable","indexes","enforceAutoBackupLimits","autoBackups","deletionBackups","removeOldestAutoBackupEntry","force","removeFromEntries","respectRename","hasValue","duplicateAutoBackupKey","duplicateDeletionBackupKey","oldestDeletionBackupKey","oldestAutoBackupKey","describeAutoGearBackupEntry","trimmedNote","trimmedTimestamp","removeOldestAutoGearBackupEntry","removeAt","cleanupAutoGearBackupMigrationCopies","migrationBackupKey","pruned","clearCachedPlannerDataForAutoGearBackups","shouldDisplayStorageAlert","msg","texts","currentLang","lang","getWindowStorage","collectUniqueStorages","storages","migrateKeyBetweenStorages","legacyKey","modernKey","keepLegacy","legacyValue","destination","removeError","migrateKeyInStorages","preferredTarget","migrated","migrateLegacyStorageKeys","localStorages","sessionStorages","legacyPrefix","legacy","modern","includeSession","updateFontKey","migratedLocal","applyLegacyStorageMigrations","safeLocal","defaultValue","disableBackup","validate","restoreIfMissing","alertOnFailure","fallbackKey","useBackup","skipBackupRecovery","allowBackupRecovery","allowMigrationBackupRecovery","migrationBackupCandidates","pushCandidate","rawGetter","rawStoredValue","shouldAlert","parseRawValue","normalizedRaw","cachedPrimary","normalizedForCache","rawForCache","missingPrimary","attemptMigrationBackupRecovery","migrationRaw","migrationRawStored","migrationReadError","rawSource","extracted","extractSnapshotStoredValue","serializedCandidate","restoredRawValue","shouldEscalate","payloadToStore","recompressed","restoreError","shouldAttemptBackup","backupRaw","backupRawStored","backup","recompressSource","normalizedBackup","fallbackRawForCache","shouldAttemptMigrationBackup","migrationRecovery","cleanupKey","cleanupErr","onQuotaExceeded","enableCompressionSweep","disableCompression","forceCompressionOnQuota","sessionScopedStorage","compressionBlocked","allowQuotaCompression","loadRawValue","targetKey","standardSerializedCache","standardSerializationComputed","compressionCandidate","useCompressedSerialization","compressionAttempted","compressionLogged","resetSerializationState","computeStandardSerialized","computeCompressedSerialized","baseline","getSerializedForAttempt","standard","tryEnableCompression","forcing","logCompressionIfNeeded","originalLength","wrappedLength","maybeEnableProactiveCompression","rawExisting","preservedBackupValue","hasPreservedBackup","removedBackupDuringRetry","quotaRecoverySteps","quotaRecoveryFailed","compressionSweepAttempted","registerQuotaRecoveryStep","attemptStorageCleanup","freed","cleaned","attemptHandleQuota","handlerError","skipKeysCleanup","cleanupResult","normalizedSerialized","normalizedString","skipPrimaryWrite","existingBackupValue","existingBackupRaw","observedPrimaryRawValue","observedBackupRawValue","existingValue","existingRawValue","inspectError","backupCandidates","standardSerialized","preferredBackupCandidate","backupMatchesPreferred","backupRawForCache","backupResult","backupError","backupRemovedForRetry","lastCandidate","tryStoreCandidate","normalizedForBackup","deleteFromStorage","disableMigrationCleanup","UI_CACHE_STORAGE_KEYS","UI_CACHE_STORAGE_ACCESS_WARNINGS","collectUiCacheStorages","seenScopes","readProperty","inspectScope","nested","loadFlagFromStorage","saveFlagToStorage","loadWithMigration","primaryLoadMsg","fallbackLoadMsg","saveMsg","deleteMsg","loadOptions","fallbackOptions","generateUniqueName","usedNames","trimmedBase","suffix","ensureImportedProjectBaseName","rawName","importedMatch","resolveImportedProjectNamingContext","parsedSuffix","suffixStart","generateImportedProjectName","normalizedCandidate","ensureUpdatedProjectBaseName","generateUpdatedProjectName","collectStringValues","arraysEqual","normalizeDiagramPositions","positions","diagramPositionsEqual","keysA","keysB","valueA","valueB","normalizeSessionStatePayload","normalizeStringField","mergeArrayField","legacyKeys","values","hadLegacyData","hasTargetKey","normalizedPositions","normalizedState","loadSessionState","saveSessionState","saveOptions","loadAutoGearBackups","normalizeDeviceDataPayload","rawData","ensureObject","loadDeviceData","parsedData","saveDeviceData","deviceData","normalizedDeviceData","dataToPersist","normalizeSetups","obj","used","loadSetups","setups","saveSetups","normalizedSetups","serializedSetups","updateSetups","saveSetup","setup","loadSetup","deleteSetup","renameSetup","oldName","newName","movedValue","wasAutoBackup","targetIsAutoBackup","REQUIREMENT_FIELDS_KEEP_NEWLINES","LEGACY_PROJECT_FIELD_LABELS","PRODUCTION_COMPANY_FIELD_ORDER","normalizeProjectFieldLabel","getProductionCompanyLabelSets","projectLabels","labelSets","textsObj","fallbackProjectLabels","addLabel","legacyLabels","expandCombinedProductionCompanyInfo","rawText","normalizedText","segment","firstLine","metadataLines","collectedFromMetadata","fields","field","streetParts","secondary","streetTwo","joinCollected","combined","activeField","normalizedLine","matchedField","streetLines","LEGACY_PROJECT_LABEL_FIELD_MAP","normalize","labels","HTML_ENTITY_MAP","decodeHtmlEntities","entity","code","mapped","stripHtmlTags","previous","normalizeRequirementValueFromHtml","rawHtml","fieldName","normalizedBreaks","extractRequirementValueMetadata","spanRegex","lines","content","fieldsAttrMatch","singleFieldMatch","rawFields","mapLegacyRequirementLabel","labelText","extractProjectInfoFromHtml","html","gridOpenMatch","gridStartIndex","headingMatch","projectName","gridHtml","boxRegex","globalLang","boxHtml","fieldMatch","labelMatch","valueMatch","rawField","valueToStore","expandedField","expandedValue","cloneProjectData","cloneProjectInfo","projectInfo","sanitizeImportedCrewEntries","sanitizeImportedValue","note","sanitizeImportedProjectInfo","fallbackLensNames","fallbackLensNameSet","addFallbackLensName","registerFallbackLensNames","converted","deriveLensSelectionsFromNameMap","selection","normalizeProjectLensNameCandidate","extractLensNamesFromSource","crew","normalizeProjectLensNamesField","normalizeProjectLensSelectionsFromSources","derived","cloneAutoGearRules","rules","cloneDiagramPositionsForStorage","PROJECT_FILTER_DEFAULT_SIZE","normalizeImportedFilterValues","tryParseJSONLike","normalizeImportedFilterEntry","typePart","sizePart","rawValues","typeCandidate","sizeCandidate","valuesCandidate","hasExplicitValues","typeKeys","sizeKeys","valueKeys","serializeNormalizedFilterEntry","token","normalizeImportedFilterValue","singleEntry","normalizeImportedProjectFilters","normalizedFilter","cloneProjectGearSelectors","selectors","cloneSelectorValue","nestedValue","clonedNestedValue","normalizeProjectPowerSelection","normalizeString","cloneProjectPowerSelection","LEGACY_LENS_SELECTION_META_KEYS","isLikelyLensNameKey","deriveLensNameKeysFromObject","nameCandidates","keyDerivedNames","nestedName","nestedEntries","keyNames","isNormalized","normalizeProjectLensSelectionEntry","mountValue","mountCandidates","trimmedMount","directNameCandidates","mountFields","sources","fallbackNames","sourceList","seenNames","addSelection","entryChanged","processSourceValue","mappedSelections","fallbackName","normalizeProject","projectContainer","projectInfoSource","normalizedProjectInfo","parsedInfo","nestedProjectInfo","parsedProjectInfo","normalizedAutoGearRules","assignAutoGearRules","convertedRules","parsedRules","gearListSource","convertedGearList","normalizedGearList","normalizedGearSelectors","gearSelectorsSource","parsedSelectors","powerSelectionSource","normalizedPowerSelection","parsedGear","diagramSource","normalizedDiagramPositions","nestedDiagramSource","htmlSources","nestedSelectorsSource","nestedPowerSelection","recovered","recoveredClone","normalizedClone","lensSelectionSources","lensSelectionResult","derivedGenerationFlag","normalizedInfo","normalizedRules","normalizedSelectors","normalizedDiagram","normalizedPower","parsedProject","LEGACY_PROJECT_ROOT_KEYS","NORMALIZED_PROJECT_KEYS","isNormalizedProjectEntry","gearList","powerSelection","setActiveProjectCompressionHold","clearActiveProjectCompressionHold","resolveProjectKey","rawMap","normalizedMap","exact","firstExisting","forceRefresh","skipMigrations","skipAutoBackupExpansion","storageRaw","combinedRawEntries","rawVal","parsedVal","inputForExpansion","expandOptions","expandedParsed","usedProjectNames","normalizedProjectNames","markProjectNameUsed","rawKeyLookup","normalizedKeyLookup","registerLookupKey","storedKey","effectiveKey","createLookupSnapshot","suggestedName","updatedName","trimmedKey","originalEntry","needsUpgrade","requiresContentUpdate","normalizedSignature","originalSignature","finalKey","innerName","pruneOrphanProjectShards","projectKeys","keysToDelete","cleanupMonolithicProjectStorage","persistProjectShard","project","skipCompression","shardKey","victimKey","persistAllProjects","updateProjectIndex","indexError","readProjectIndex","isIndexedDB","loadProject","resolvedKey","mutableProjects","loadProjectMetadata","cachedIndex","loaded","sanitizeProjectNameForBackup","collapsed","formatAutoBackupTimestamp","date","pad","generateDeletionBackupMetadata","sanitizedName","cloneProjectEntryForBackup","maybeCreateProjectDeletionBackup","backupName","createProjectDeletionBackup","backupOutcome","generateOverwriteBackupMetadata","maybeCreateProjectOverwriteBackup","backupSource","saveProject","skipOverwriteBackup","requestedKey","preferredKey","initialSnapshot","initialProjects","initialResolvedKey","initialExistingEntry","initialExistingSignature","latestSnapshot","renamedFromKey","existingKey","hasExistingEntry","existingEntry","nextSignature","shouldDelete","manualRenamedFrom","resolvedOld","shardSuccess","deleteProject","storagesToPrune","backupSuffix","uiCacheError","currentSafeStorage","potentialShardKey","renameProject","targetName","createProjectImporter","defaultName","normalizedProject","uniqueName","firstChar","lastChar","expectedClosing","importProjectCollection","ensureImporter","fallbackLabel","proj","importProject","collectLegacyProjectCollections","collections","addCollection","plannerData","loadFavorites","saveFavorites","favs","resolveContactsModuleApi","contactsModuleImport","moduleBase","fallbackSanitizeContactValue","fallbackGenerateContactId","generated","fallbackNormalizeContactEntry","sanitize","avatarSource","fallbackSortContacts","createdA","createdB","normalizeContactsList","sorted","normalizer","loadContacts","saveContacts","loadOwnGear","saveOwnGear","normalizeUserProfileField","normalizeUserProfile","loadUserProfile","saveUserProfile","profile","loadFeedback","saveFeedback","feedback","normalizeFullBackupHistoryEntry","loadFullBackupHistory","saveFullBackupHistory","safeEntries","recordFullBackupHistoryEntry","history","normalizeImportedFullBackupHistory","results","nestedValues","DOCUMENTATION_TRACKER_SCHEMA_VERSION","generateDocumentationTrackerId","normalizeDocumentationTrackerStatusEntry","completed","timestampCandidate","normalizeDocumentationTrackerStatusMap","keyString","normalizeDocumentationTrackerStatuses","normalizeDocumentationTrackerRelease","targetDate","archived","normalizedStatus","statuses","normalizeDocumentationTrackerState","rawState","loadDocumentationTracker","saveDocumentationTracker","loadAutoGearRules","saveAutoGearRules","defaultsApplied","withDefaults","rule","skipNormalization","safeRules","normalizedBackups","saveAutoGearBackups","safeBackups","attemptedMigrationCleanup","attemptedCacheCleanup","removal","loadAutoGearSeedFlag","saveAutoGearSeedFlag","loadAutoGearPresets","presets","presetArray","saveAutoGearPresets","readActiveAutoGearPresetIds","ids","pushId","loadAutoGearActivePresetId","loadAutoGearAutoPresetId","disableCompressionOverride","safePresets","normalizedPresets","activePresetIds","loadAutoGearMonitorDefaults","monitorDefaults","normalizedDefaults","saveAutoGearMonitorDefaults","safeDefaults","removeAutoGearPresetFromStorage","presetId","rawPresets","parsedPresets","normalizedRawPresets","filteredPresets","saveAutoGearActivePresetId","saveAutoGearAutoPresetId","previousPresetId","existingId","loadAutoGearBackupVisibility","saveAutoGearBackupVisibility","getAutoGearBackupRetentionUpperBound","clampAutoGearBackupRetention","getAutoGearBackupRetentionDefault","upperBound","normalizeAutoGearBackupRetentionValue","maybeJson","candidateKeys","loadAutoGearBackupRetention","retention","saveAutoGearBackupRetention","clearAllData","clearVaultFn","vaultDbNames","db","listError","dbName","request","deleteError","vaultError","clearStorageFully","storageName","objectKeys","objKeysError","iterateError","sessionCacheKeys","ensureStoragePruned","cacheKeys","cacheError","onboardingStorageKeys","clearOnboardingTutorialState","storageCandidates","sessionCandidates","loggingError","windowNameError","registrations","swError","readLocalStorageValue","decodedBackup","parseStoredBoolean","interpretPrintPreferencesValue","hasSectionsContainer","sectionsSource","sections","sectionKeys","sectionKey","sectionValue","layout","trimmedLayout","collectPreferenceSnapshot","preferences","darkMode","pinkMode","highContrast","reduceMotion","relaxedSpacing","showAutoBackups","accentColor","fontSize","fontFamily","language","mountVoltageKey","mountVoltages","voltageParseError","iosPwaHelpShown","temperatureUnit","focusScale","cameraColorsRaw","parsedCameraColors","trimmedCameraColors","cameraColorParseError","printPreferencesRaw","interpretedPrintPreferences","normalizeCustomFontEntries","readStoredCustomFonts","backupVaultRecordCache","normalizeBackupVaultMetadata","normalizeBackupVaultRecord","fileName","createdAtMs","normalizedCreatedAtMs","parsedTime","normalizeBackupVaultRecordList","records","parsedResult","scoreBackupVaultRecord","score","mergeBackupVaultRecords","existingList","incomingList","mergeList","readBackupVaultFallbackRecords","resolveBackupVaultApi","refreshBackupVaultRecordCache","loader","response","prepareBackupForExport","exportAllData","documentationTracker","customLogo","customFonts","schemaCache","fallbackVaultRecords","combinedVaultRecords","safeSetLocalStorage","storedValue","normalizeImportedBoolean","normalizeImportedArray","fallbackKeys","filterFn","normalizeImportedContacts","normalizeImportedAutoGearRules","normalizeImportedAutoGearBackups","normalizeImportedAutoGearBackupRetention","normalizeImportedAutoGearPresets","normalizeImportedAutoGearMonitorDefaults","legacyNormalized","normalizeImportedPresetId","normalizeImportedBackupVaultRecords","importBackupVaultRecords","existingFallback","mergedFallback","storageError","queueRecord","existingIds","getSnapshotKeyVariants","readSnapshotEntry","compressionToken","encodingToken","isModernCompression","isLegacyLongGopCompression","parseSnapshotJSONValue","parseSnapshotStringValue","convertStorageSnapshotToData","hasAssignments","hasSnapshotKeys","preferenceKeys","mountVoltageKeyName","simpleSnapshotKeys","booleanPreferenceKeys","markSnapshotEntry","assignJSONValue","schemaEntry","cacheValue","customFontsEntry","fontsValue","customLogoEntry","logoValue","seedEntry","activePresetEntry","autoPresetEntry","backupsVisibilityEntry","snapshotPrintValue","interpretedPreferences","stringValue","temperatureUnitEntry","storedUnit","normalizedUnit","focusScaleEntry","storedScale","normalizedScale","cameraColorsEntry","storedCameraColors","mountVoltageEntry","storedVoltages","importAllData","allData","skipSnapshotConversion","hasOwn","cameraColorKeyName","prefs","unit","scale","focusScaleError","rawPrintPreferences","normalizedPrintPreferences","serializedPrintPreferences","printPreferenceSerializationError","printPreferencePersistError","printPreferenceApplyError","printPreferenceStringPersistError","rawVoltages","voltStoreError","parsedVoltages","voltParseError","rawCameraColors","applyImportedCameraColors","palette","applied","cameraColorApplyError","serializedPalette","cameraColorSerializeError","cameraColorPersistError","cameraColorStoreError","logo","schemaError","trackerState","trackerFromLogs","trackerFromLegacy","visibility","backupRecords","importProjectEntry","ensureProjectImporter","projectImported","getTrackedImporter","importer","importTrackedCollection","STORAGE_API","TEST_ONLY_AUTO_BACKUP_COMPRESSION_CACHE","definitionError","cineStorage","resolveModuleLinker","linker","MODULE_LINKER","linked","linkedRegistry","linkedKey","sharedKey","bridgedKey","cloneOptions","fallbackRegisterOrQueue","fallbackExposeGlobal","providerModules","addProviderModule","reference","bindingState","bindingNames","identifyProvider","providerEntry","ref","ensureBindingEntry","bindingKey","implementationName","resolveBinding","refresh","requireBinding","snapshotBinding","createWrapper","alias","inspectBinding","inspectAllBindings","listBindings","persistenceAPI","existingPersistence"],"ignoreList":[],"sources":["../../src/scripts/modules/icons.js","../../src/scripts/modules/helpers/scope-collector.js","../../src/scripts/modules/base.js","../../src/scripts/modules/registry.js","../../src/scripts/modules/helpers/scope-utils.js","../../src/scripts/modules/device-normalization.js","../../src/scripts/modules/logging.js","../../src/scripts/console-helpers.js","../../src/scripts/modules/logging-resolver.js","../../src/scripts/modules/features/contacts.js","../../src/scripts/modules/storage/StorageInterface.js","../../src/scripts/modules/storage/drivers/LocalStorageAdapter.js","../../src/scripts/modules/core/UserContext.js","../../src/scripts/modules/storage/SyncMetadata.js","../../src/scripts/modules/storage/ProjectLockService.js","../../src/scripts/modules/storage/StorageRepository.js","../../src/scripts/modules/storage/drivers/IndexedDBAdapter.js","../../src/scripts/modules/storage/StorageMigrationService.js","../../src/scripts/modules/gear/GearRepository.js","../../src/scripts/modules/storage/DataVault.js","../../src/scripts/storage.js","../../src/scripts/modules/persistence.js"],"sourcesContent":["/* global ICON_FONT_KEYS */\n// Removed IIFE wrapper for ES Module conversion\n// (function createCineIconsModule() {\n\nconst globalScope =\n    (typeof globalThis !== 'undefined' && globalThis) ||\n    (typeof window !== 'undefined' && window) ||\n    (typeof self !== 'undefined' && self) ||\n    (typeof global !== 'undefined' && global) ||\n    {};\n\nconst VALID_ICON_FONTS = (function createValidIconFontSet() {\n    // Ensure ICON_FONT_KEYS is available\n    const keys = globalScope.ICON_FONT_KEYS || (typeof ICON_FONT_KEYS !== 'undefined' ? ICON_FONT_KEYS : null);\n\n    if (typeof keys !== 'object' || !keys) {\n        return new Set();\n    }\n    const fonts = Object.values(keys).filter(\n        font => typeof font === 'string' && font,\n    );\n    return new Set(fonts);\n})();\n\nfunction toCodePointChar(value, radix) {\n    const codePoint = parseInt(value, radix);\n    if (!Number.isFinite(codePoint) || codePoint < 0) {\n        return '';\n    }\n    if (typeof String.fromCodePoint === 'function') {\n        try {\n            return String.fromCodePoint(codePoint);\n        } catch (rangeError) {\n            void rangeError;\n        }\n    }\n    if (codePoint <= 0xffff) {\n        return String.fromCharCode(codePoint);\n    }\n    return '';\n}\n\nfunction normalizeGlyphChar(char) {\n    if (typeof char !== 'string') {\n        return '';\n    }\n    const trimmed = char.trim();\n    if (!trimmed) {\n        return '';\n    }\n    const unicodeMatch = trimmed.match(/^(?:\\\\)+u([0-9A-Fa-f]{4})$/);\n    if (unicodeMatch) {\n        const decoded = toCodePointChar(unicodeMatch[1], 16);\n        if (decoded) {\n            return decoded;\n        }\n    }\n    const unicodeBraceMatch = trimmed.match(/^(?:\\\\)+u\\{([0-9A-Fa-f]+)\\}$/);\n    if (unicodeBraceMatch) {\n        const decoded = toCodePointChar(unicodeBraceMatch[1], 16);\n        if (decoded) {\n            return decoded;\n        }\n    }\n    const hexEntityMatch = trimmed.match(/^&#x([0-9A-Fa-f]+);$/i);\n    if (hexEntityMatch) {\n        const decoded = toCodePointChar(hexEntityMatch[1], 16);\n        if (decoded) {\n            return decoded;\n        }\n    }\n    const decimalEntityMatch = trimmed.match(/^&#(\\d+);$/);\n    if (decimalEntityMatch) {\n        const decoded = toCodePointChar(decimalEntityMatch[1], 10);\n        if (decoded) {\n            return decoded;\n        }\n    }\n    return trimmed;\n}\n\nfunction iconGlyph(char, font) {\n    // Resolve font keys dynamically to handle load order\n    const keys = globalScope.ICON_FONT_KEYS || (typeof ICON_FONT_KEYS !== 'undefined' ? ICON_FONT_KEYS : { UICONS: 'uicons' });\n    const defaultFont = keys.UICONS || 'uicons';\n    const requestedFont = font || defaultFont;\n\n    const normalizedFont = VALID_ICON_FONTS.has(requestedFont) ? requestedFont : defaultFont;\n    const normalizedChar = normalizeGlyphChar(char);\n    const glyph = {\n        char: normalizedChar,\n        font: normalizedFont,\n    };\n    return typeof Object.freeze === 'function' ? Object.freeze(glyph) : glyph;\n}\n\nfunction resolveIconGlyph(glyph) {\n    const keys = globalScope.ICON_FONT_KEYS || (typeof ICON_FONT_KEYS !== 'undefined' ? ICON_FONT_KEYS : { UICONS: 'uicons' });\n    const defaultFont = keys.UICONS || 'uicons';\n\n    if (!glyph) {\n        return {\n            char: '',\n            font: defaultFont,\n            className: '',\n            size: undefined,\n        };\n    }\n    if (glyph.markup) {\n        const size = Number.isFinite(glyph.size) ? glyph.size : undefined;\n        return {\n            markup: glyph.markup,\n            className: glyph.className || '',\n            font: defaultFont,\n            size,\n        };\n    }\n    if (typeof glyph === 'string') {\n        return {\n            char: normalizeGlyphChar(glyph),\n            font: defaultFont,\n            className: '',\n            size: undefined,\n        };\n    }\n    if (typeof glyph === 'object') {\n        const char = typeof glyph.char === 'string' ? normalizeGlyphChar(glyph.char) : '';\n        const fontKey = glyph.font && VALID_ICON_FONTS.has(glyph.font) ? glyph.font : defaultFont;\n        const className = typeof glyph.className === 'string' ? glyph.className : '';\n        const size = Number.isFinite(glyph.size) ? glyph.size : undefined;\n        if (glyph.markup) {\n            return {\n                markup: glyph.markup,\n                className,\n                font: fontKey,\n                size,\n            };\n        }\n        return {\n            char,\n            font: fontKey,\n            className,\n            size,\n        };\n    }\n    return {\n        char: '',\n        font: defaultFont,\n        className: '',\n        size: undefined,\n    };\n}\n\nfunction ensureSvgHasAriaHidden(markup) {\n    if (typeof markup !== 'string') return '';\n    if (markup.indexOf('aria-hidden=\"true\"') !== -1) return markup;\n    return markup.replace('<svg', '<svg aria-hidden=\"true\"');\n}\n\nfunction applyIconGlyph(element, glyph) {\n    if (!element) return;\n    const resolved = resolveIconGlyph(glyph);\n    if (resolved.markup) {\n        element.innerHTML = ensureSvgHasAriaHidden(resolved.markup);\n        element.setAttribute('aria-hidden', 'true');\n        if (resolved.className) {\n            resolved.className\n                .split(/\\s+/)\n                .filter(Boolean)\n                .forEach(cls => element.classList.add(cls));\n        }\n        element.removeAttribute('data-icon-font');\n        return;\n    }\n    const char = resolved.char || '';\n    element.textContent = char;\n    if (char) {\n        element.setAttribute('data-icon-font', resolved.font);\n    } else {\n        element.removeAttribute('data-icon-font');\n    }\n}\n\nfunction iconMarkup(glyph, className) {\n    const resolved = resolveIconGlyph(glyph);\n    const parts = [];\n    if (resolved.className) parts.push(resolved.className);\n    if (className) parts.push(className);\n    const finalClass = parts.join(' ');\n\n    if (resolved.markup) {\n        let svg = ensureSvgHasAriaHidden(resolved.markup);\n        if (finalClass) {\n            if (svg.indexOf('class=\"') !== -1) {\n                svg = svg.replace('class=\"', `class=\"${finalClass} `);\n            } else {\n                svg = svg.replace('<svg', `<svg class=\"${finalClass}\"`);\n            }\n        }\n        return svg;\n    }\n\n    const fontAttr = resolved.char ? `data-icon-font=\"${resolved.font}\"` : '';\n    return `<span class=\"icon-glyph ${finalClass}\" aria-hidden=\"true\" ${fontAttr}>${resolved.char}</span>`;\n}\n\nfunction formatSvgCoordinate(value) {\n    if (!Number.isFinite(value)) return '0';\n    const rounded = Math.round(value * 100) / 100;\n    if (Number.isInteger(rounded)) return String(rounded);\n    return rounded.toFixed(2).replace(/0+$/, '').replace(/\\.$/, '');\n}\n\nfunction positionSvgMarkup(markup, centerX, centerY, size = 24) {\n    if (typeof markup !== 'string') {\n        return { markup: '', x: '0', y: '0' };\n    }\n    const trimmed = markup.trim();\n    if (!trimmed) {\n        return { markup: '', x: '0', y: '0' };\n    }\n    const half = size / 2;\n    const x = formatSvgCoordinate(centerX);\n    const y = formatSvgCoordinate(centerY);\n    const width = formatSvgCoordinate(size);\n    const height = formatSvgCoordinate(size);\n    const cleaned = trimmed.replace(/<svg\\b([^>]*)>/i, (match, attrs = '') => {\n        let attrText = attrs\n            .replace(/\\s+x\\s*=\\s*\"[^\"]*\"/gi, '')\n            .replace(/\\s+y\\s*=\\s*\"[^\"]*\"/gi, '')\n            .trim();\n        const additions = [];\n        if (!/(?:^|\\s)width\\s*=/i.test(attrText)) additions.push(`width=\"${width}\"`);\n        if (!/(?:^|\\s)height\\s*=/i.test(attrText)) additions.push(`height=\"${height}\"`);\n        additions.push(`x=\"-${formatSvgCoordinate(half)}\"`);\n        additions.push(`y=\"-${formatSvgCoordinate(half)}\"`);\n        attrText = [attrText].concat(additions).filter(Boolean).join(' ').trim();\n        return attrText ? `<svg ${attrText}>` : '<svg>';\n    });\n    return { markup: cleaned, x, y };\n}\n\nconst STAR_ICON_SVG = `\n<svg viewBox=\"0 0 24 24\" xmlns=\"http://www.w3.org/2000/svg\">\n  <path\n    d=\"M12 17.25 6.545 20.2 7.9 13.975 3 9.45l6.272-.7L12 3l2.728 5.75L21 9.45l-4.9 4.525 1.355 6.225Z\"\n    fill=\"currentColor\"\n    stroke=\"currentColor\"\n    stroke-width=\"0\"\n  />\n</svg>\n`.trim();\n\n// We need to access ICON_FONT_KEYS from the global scope or where it's defined\nconst keys = globalScope.ICON_FONT_KEYS || (typeof ICON_FONT_KEYS !== 'undefined' ? ICON_FONT_KEYS : {\n    UICONS: 'uicons',\n    ESSENTIAL: 'essential',\n    GADGET: 'gadget',\n    FILM: 'film',\n    TEXT: 'text'\n});\n\nconst ICON_GLYPHS = Object.freeze({\n    batteryBolt: iconGlyph('\\uE1A6', keys.UICONS),\n    batteryFull: iconGlyph('\\uE1A9', keys.UICONS),\n    bolt: iconGlyph('\\uF1F8', keys.ESSENTIAL),\n    plug: iconGlyph('\\uEE75', keys.UICONS),\n    sliders: iconGlyph('\\uF143', keys.ESSENTIAL),\n    screen: iconGlyph('\\uF11D', keys.GADGET),\n    brightness: iconGlyph('\\uE2B3', keys.UICONS),\n    wifi: iconGlyph('\\uF4AC', keys.UICONS),\n    gears: iconGlyph('\\uE8AF', keys.UICONS),\n    controller: iconGlyph('\\uF117', keys.GADGET),\n    distance: iconGlyph('\\uEFB9', keys.UICONS),\n    sensor: iconGlyph('\\uEC2B', keys.UICONS),\n    viewfinder: iconGlyph('\\uF114', keys.FILM),\n    camera: iconGlyph('\\uE333', keys.UICONS),\n    trash: iconGlyph('\\uF254', keys.ESSENTIAL),\n    reload: iconGlyph('\\uF202', keys.ESSENTIAL),\n    load: iconGlyph('\\uE0E0', keys.UICONS),\n    installApp: iconGlyph('\\uE9D4', keys.UICONS),\n    add: Object.freeze({ char: '+', font: keys.TEXT, className: 'icon-text' }),\n    minus: Object.freeze({ char: '', font: keys.TEXT, className: 'icon-text' }),\n    arrowLeft: Object.freeze({ char: '', font: keys.TEXT, className: 'icon-text' }),\n    check: iconGlyph('\\uE3D8', keys.UICONS),\n    fileExport: iconGlyph('\\uE7AB', keys.UICONS),\n    fileImport: iconGlyph('\\uE7C7', keys.UICONS),\n    save: iconGlyph('\\uF207', keys.ESSENTIAL),\n    share: iconGlyph('\\uF219', keys.ESSENTIAL),\n    paperPlane: iconGlyph('\\uED67', keys.UICONS),\n    magnet: iconGlyph('\\uF1B5', keys.ESSENTIAL),\n    codec: iconGlyph('\\uE4CD', keys.UICONS),\n    timecode: iconGlyph('\\uF10E', keys.FILM),\n    audioIn: iconGlyph('\\uF1C3', keys.ESSENTIAL),\n    audioOut: iconGlyph('\\uF22F', keys.ESSENTIAL),\n    note: iconGlyph('\\uF13E', keys.ESSENTIAL),\n    overview: iconGlyph('\\uF1F5', keys.UICONS),\n    gearList: iconGlyph('\\uE467', keys.UICONS),\n    contacts: iconGlyph('\\uF404', keys.UICONS),\n    feedback: iconGlyph('\\uE791', keys.UICONS),\n    resetView: iconGlyph('\\uEB6D', keys.UICONS),\n    pin: iconGlyph('\\uF1EF', keys.ESSENTIAL),\n    sun: iconGlyph('\\uF1FE', keys.UICONS),\n    moon: iconGlyph('\\uEC7E', keys.UICONS),\n    circleX: iconGlyph('\\uF131', keys.ESSENTIAL),\n    settingsGeneral: iconGlyph('\\uE5A3', keys.UICONS),\n    settingsAutoGear: iconGlyph('\\uE8AF', keys.UICONS),\n    settingsAccessibility: iconGlyph('\\uF392', keys.UICONS),\n    settingsBackup: iconGlyph('\\uE5BD', keys.UICONS),\n    settingsData: iconGlyph('\\uE5C7', keys.UICONS),\n    settingsAbout: iconGlyph('\\uEA4F', keys.UICONS),\n    star: Object.freeze({ markup: STAR_ICON_SVG, className: 'icon-svg favorite-star-icon' }),\n    warning: iconGlyph('\\uF26F', keys.ESSENTIAL),\n});\n\n// Expose to global scope for legacy compatibility\nglobalScope.cineIcons = {\n    VALID_ICON_FONTS,\n    toCodePointChar,\n    normalizeGlyphChar,\n    iconGlyph,\n    resolveIconGlyph,\n    applyIconGlyph,\n    iconMarkup,\n    formatSvgCoordinate,\n    positionSvgMarkup,\n    STAR_ICON_SVG,\n    ICON_GLYPHS,\n};\n\n// Expose individual functions for backward compatibility if needed, \n// or just use cineIcons namespace. \n// Based on app-core-new-1.js usage, these seem to be expected in the scope.\nglobalScope.iconGlyph = iconGlyph;\nglobalScope.resolveIconGlyph = resolveIconGlyph;\nglobalScope.applyIconGlyph = applyIconGlyph;\nglobalScope.iconMarkup = iconMarkup;\nglobalScope.formatSvgCoordinate = formatSvgCoordinate;\nglobalScope.positionSvgMarkup = positionSvgMarkup;\nglobalScope.STAR_ICON_SVG = STAR_ICON_SVG;\nglobalScope.ICON_GLYPHS = ICON_GLYPHS;\n\n// Export as ES Module\nexport const cineIcons = globalScope.cineIcons;\nexport {\n    VALID_ICON_FONTS,\n    toCodePointChar,\n    normalizeGlyphChar,\n    iconGlyph,\n    resolveIconGlyph,\n    applyIconGlyph,\n    iconMarkup,\n    formatSvgCoordinate,\n    positionSvgMarkup,\n    STAR_ICON_SVG,\n    ICON_GLYPHS,\n};\n","function detectGlobalScope() {\n  if (typeof globalThis !== 'undefined') {\n    return globalThis;\n  }\n  if (typeof window !== 'undefined') {\n    return window;\n  }\n  if (typeof self !== 'undefined') {\n    return self;\n  }\n  if (typeof global !== 'undefined') {\n    return global;\n  }\n  return {};\n}\n\nfunction isObjectLike(value) {\n  return !!value && (typeof value === 'object' || typeof value === 'function');\n}\n\nfunction freezeArray(array) {\n  if (typeof Object.freeze === 'function') {\n    try {\n      return Object.freeze(array);\n    } catch (error) {\n      void error;\n    }\n  }\n  return array;\n}\n\nfunction cloneArray(array) {\n  if (!array) {\n    return [];\n  }\n  try {\n    return Array.prototype.slice.call(array);\n  } catch (error) {\n    void error;\n  }\n  const clone = [];\n  for (let index = 0; index < array.length; index += 1) {\n    clone[index] = array[index];\n  }\n  return clone;\n}\n\nfunction createPrimaryCache() {\n  return {\n    objects: typeof WeakMap === 'function' ? new WeakMap() : null,\n    primitives: Object.create(null),\n    empty: null,\n  };\n}\n\nfunction getPrimaryCacheEntry(cache, primary) {\n  if (!cache) {\n    return null;\n  }\n\n  if (isObjectLike(primary)) {\n    if (!cache.objects) {\n      return null;\n    }\n    let entry = cache.objects.get(primary);\n    if (!entry) {\n      entry = { cached: false, value: null };\n      cache.objects.set(primary, entry);\n    }\n    return entry;\n  }\n\n  const key = typeof primary + ':' + String(primary);\n  let entry = cache.primitives[key];\n  if (!entry) {\n    entry = { cached: false, value: null };\n    cache.primitives[key] = entry;\n  }\n  return entry;\n}\n\nfunction pushUnique(target, value) {\n  if (!isObjectLike(value)) {\n    return;\n  }\n  if (target.indexOf(value) === -1) {\n    target.push(value);\n  }\n}\n\nconst BASE_SCOPES = (function buildBaseScopes() {\n  const scopes = [];\n  pushUnique(scopes, typeof globalThis !== 'undefined' ? globalThis : null);\n  pushUnique(scopes, typeof window !== 'undefined' ? window : null);\n  pushUnique(scopes, typeof self !== 'undefined' ? self : null);\n  pushUnique(scopes, typeof global !== 'undefined' ? global : null);\n  return freezeArray(scopes);\n})();\n\nconst EMPTY_EXTRAS = freezeArray([]);\nconst SUPPORTS_WEAKMAP = typeof WeakMap === 'function';\nconst DETECT_CACHE = SUPPORTS_WEAKMAP ? new WeakMap() : null;\n\nfunction sanitizeExtras(extras) {\n  if (!Array.isArray(extras) || extras.length === 0) {\n    return EMPTY_EXTRAS;\n  }\n\n  const sanitized = [];\n  for (let index = 0; index < extras.length; index += 1) {\n    pushUnique(sanitized, extras[index]);\n  }\n\n  if (sanitized.length === 0) {\n    return EMPTY_EXTRAS;\n  }\n\n  return freezeArray(sanitized);\n}\n\nfunction computeCandidateScopes(primary, detectFn, extrasList) {\n  const scopes = [];\n  pushUnique(scopes, primary);\n\n  let detected = null;\n  if (typeof detectFn === 'function') {\n    try {\n      detected = detectFn();\n    } catch (error) {\n      void error;\n      detected = null;\n    }\n  }\n  pushUnique(scopes, detected);\n\n  for (let index = 0; index < BASE_SCOPES.length; index += 1) {\n    pushUnique(scopes, BASE_SCOPES[index]);\n  }\n\n  if (Array.isArray(extrasList)) {\n    for (let index = 0; index < extrasList.length; index += 1) {\n      pushUnique(scopes, extrasList[index]);\n    }\n  }\n\n  return freezeArray(scopes);\n}\n\nfunction getExtrasCache(detectEntry, extrasList) {\n  if (!detectEntry) {\n    return null;\n  }\n\n  if (extrasList === EMPTY_EXTRAS) {\n    if (!detectEntry.empty) {\n      detectEntry.empty = createPrimaryCache();\n    }\n    return detectEntry.empty;\n  }\n\n  if (!detectEntry.extras) {\n    if (!SUPPORTS_WEAKMAP) {\n      return null;\n    }\n    detectEntry.extras = new WeakMap();\n  }\n\n  let extrasEntry = detectEntry.extras.get(extrasList);\n  if (!extrasEntry) {\n    extrasEntry = createPrimaryCache();\n    detectEntry.extras.set(extrasList, extrasEntry);\n  }\n  return extrasEntry;\n}\n\nfunction getDetectEntry(detectFn) {\n  if (!DETECT_CACHE) {\n    return null;\n  }\n\n  let entry = DETECT_CACHE.get(detectFn);\n  if (!entry) {\n    entry = { empty: null, extras: null };\n    DETECT_CACHE.set(detectFn, entry);\n  }\n  return entry;\n}\n\nfunction collectInternal(primary, detectFn, extrasList, cacheEntry) {\n  if (cacheEntry) {\n    const primaryEntry = getPrimaryCacheEntry(cacheEntry, primary);\n    if (primaryEntry) {\n      if (primaryEntry.cached) {\n        return cloneArray(primaryEntry.value);\n      }\n      const computed = computeCandidateScopes(primary, detectFn, extrasList);\n      primaryEntry.value = computed;\n      primaryEntry.cached = true;\n      return cloneArray(computed);\n    }\n  }\n\n  const computedFallback = computeCandidateScopes(primary, detectFn, extrasList);\n  return cloneArray(computedFallback);\n}\n\nexport function createCollector(options) {\n  const detectFn = options && typeof options.detectGlobalScope === 'function'\n    ? options.detectGlobalScope\n    : detectGlobalScope;\n  const extrasList = sanitizeExtras(options && options.additionalScopes);\n  const detectEntry = getDetectEntry(detectFn);\n  const cacheEntry = getExtrasCache(detectEntry, extrasList);\n\n  return function collectWithPreset(primary) {\n    return collectInternal(primary, detectFn, extrasList, cacheEntry);\n  };\n}\n\nexport function collectCandidateScopes(primary, options) {\n  const collector = createCollector(options || {});\n  return collector(primary);\n}\n\nexport function getBaseScopes() {\n  return cloneArray(BASE_SCOPES);\n}\n\n// Global Assignment for Legacy Compatibility\nconst GLOBAL_SCOPE = detectGlobalScope();\n\nif (GLOBAL_SCOPE && !GLOBAL_SCOPE.__cineScopeCollector) {\n  GLOBAL_SCOPE.__cineScopeCollector = {\n    collectCandidateScopes,\n    createCollector,\n    getBaseScopes,\n  };\n}\n","import { createCollector } from './helpers/scope-collector.js';\n\nconst DEFAULT_PENDING_QUEUE_KEY = '__cinePendingModuleRegistrations__';\n\nfunction fallbackDetectGlobalScope() {\n  if (typeof globalThis !== 'undefined') {\n    return globalThis;\n  }\n  if (typeof window !== 'undefined') {\n    return window;\n  }\n  if (typeof self !== 'undefined') {\n    return self;\n  }\n  if (typeof global !== 'undefined') {\n    return global;\n  }\n  return {};\n}\n\nfunction installSafeConsoleGuards(scope) {\n  const targetScope = scope || fallbackDetectGlobalScope();\n  if (!targetScope || (typeof targetScope !== 'object' && typeof targetScope !== 'function')) {\n    return;\n  }\n\n  let consoleRef = null;\n  try {\n    consoleRef = targetScope.console || null;\n  } catch (error) {\n    consoleRef = null;\n    void error;\n  }\n\n  if (!consoleRef || (typeof consoleRef !== 'object' && typeof consoleRef !== 'function')) {\n    return;\n  }\n\n  const methods = ['log', 'warn', 'error', 'info', 'debug'];\n  let originals = null;\n\n  try {\n    originals = consoleRef.__cineSafeConsoleOriginals || null;\n  } catch (error) {\n    originals = null;\n    void error;\n  }\n\n  if (!originals || typeof originals !== 'object') {\n    originals = {};\n    try {\n      Object.defineProperty(consoleRef, '__cineSafeConsoleOriginals', {\n        configurable: true,\n        enumerable: false,\n        writable: true,\n        value: originals,\n      });\n    } catch (defineError) {\n      try {\n        consoleRef.__cineSafeConsoleOriginals = originals;\n      } catch (assignError) {\n        void assignError;\n      }\n      void defineError;\n    }\n  }\n\n  for (let index = 0; index < methods.length; index += 1) {\n    const method = methods[index];\n    let candidate = null;\n    try {\n      candidate = consoleRef[method];\n    } catch (error) {\n      candidate = null;\n      void error;\n    }\n\n    if (typeof candidate !== 'function') {\n      continue;\n    }\n\n    if (candidate && candidate.__cineSafeConsoleGuard) {\n      continue;\n    }\n\n    if (!Object.prototype.hasOwnProperty.call(originals, method)) {\n      originals[method] = candidate;\n    }\n\n    const guarded = function cineSafeConsoleGuard() {\n      try {\n        return candidate.apply(consoleRef, arguments);\n      } catch (error) {\n        void error;\n      }\n      return undefined;\n    };\n\n    try {\n      Object.defineProperty(guarded, '__cineSafeConsoleGuard', {\n        configurable: true,\n        enumerable: false,\n        writable: false,\n        value: true,\n      });\n    } catch (defineError) {\n      guarded.__cineSafeConsoleGuard = true;\n      void defineError;\n    }\n\n    try {\n      consoleRef[method] = guarded;\n    } catch (error) {\n      void error;\n    }\n  }\n}\n\nconst createScopeCollector = createCollector;\n\nconst DEFAULT_EXTRAS_KEY = { key: 'defaultExtras' };\nconst HELPER_COLLECTOR_CACHE = [];\nconst BASE_SCOPE_EXTRAS_CACHE = typeof WeakMap === 'function' ? new WeakMap() : [];\n\nfunction resolveExtrasForBaseScope(baseScope) {\n  if (!baseScope || (typeof baseScope !== 'object' && typeof baseScope !== 'function')) {\n    return undefined;\n  }\n\n  if (BASE_SCOPE_EXTRAS_CACHE && typeof BASE_SCOPE_EXTRAS_CACHE.get === 'function') {\n    let extras = BASE_SCOPE_EXTRAS_CACHE.get(baseScope);\n    if (!extras) {\n      extras = [baseScope];\n      BASE_SCOPE_EXTRAS_CACHE.set(baseScope, extras);\n    }\n    return extras;\n  }\n\n  for (let index = 0; index < BASE_SCOPE_EXTRAS_CACHE.length; index += 1) {\n    const entry = BASE_SCOPE_EXTRAS_CACHE[index];\n    if (entry.scope === baseScope) {\n      return entry.extras;\n    }\n  }\n\n  const extras = [baseScope];\n  BASE_SCOPE_EXTRAS_CACHE.push({ scope: baseScope, extras });\n  return extras;\n}\n\nfunction resolveHelperCollector(detectFn, extras) {\n  if (!createScopeCollector) {\n    return null;\n  }\n\n  const extrasKey = Array.isArray(extras) ? extras : DEFAULT_EXTRAS_KEY;\n\n  for (let index = 0; index < HELPER_COLLECTOR_CACHE.length; index += 1) {\n    const entry = HELPER_COLLECTOR_CACHE[index];\n    if (entry.detect === detectFn && entry.extras === extrasKey) {\n      return entry.collector;\n    }\n  }\n\n  const collector = createScopeCollector({\n    detectGlobalScope: detectFn,\n    additionalScopes: Array.isArray(extras) ? extras : undefined,\n  });\n\n  if (collector) {\n    HELPER_COLLECTOR_CACHE.push({ detect: detectFn, extras: extrasKey, collector });\n    return collector;\n  }\n\n  return null;\n}\n\nfunction fallbackCollectCandidateScopes(primary, baseScope) {\n  const resolvedBaseScope = baseScope || fallbackDetectGlobalScope();\n  const extras = resolveExtrasForBaseScope(resolvedBaseScope);\n  const collector = resolveHelperCollector(fallbackDetectGlobalScope, extras);\n  if (collector) {\n    return collector(primary || resolvedBaseScope);\n  }\n\n  const scopes = [];\n\n  function pushScope(scope) {\n    if (!scope || (typeof scope !== 'object' && typeof scope !== 'function')) {\n      return;\n    }\n    if (scopes.indexOf(scope) === -1) {\n      scopes.push(scope);\n    }\n  }\n\n  pushScope(primary || resolvedBaseScope);\n  if (typeof globalThis !== 'undefined') pushScope(globalThis);\n  if (typeof window !== 'undefined') pushScope(window);\n  if (typeof self !== 'undefined') pushScope(self);\n  if (typeof global !== 'undefined') pushScope(global);\n\n  return scopes;\n}\n\nfunction fallbackTryRequire(modulePath) {\n  // In ESM build, require is not available dynamically in the same way.\n  // We return null to fallback to global resolution.\n  return null;\n}\n\nfunction fallbackDefineHiddenProperty(target, name, value) {\n  if (!target || (typeof target !== 'object' && typeof target !== 'function')) {\n    return false;\n  }\n\n  try {\n    Object.defineProperty(target, name, {\n      configurable: true,\n      enumerable: false,\n      writable: true,\n      value,\n    });\n    return true;\n  } catch (error) {\n    void error;\n  }\n\n  try {\n    target[name] = value;\n    return true;\n  } catch (assignmentError) {\n    void assignmentError;\n  }\n\n  return false;\n}\n\nfunction fallbackEnsureQueue(scope, key, baseScope) {\n  const targetScope = scope || baseScope;\n  const queueKey = typeof key === 'string' && key ? key : DEFAULT_PENDING_QUEUE_KEY;\n\n  if (!targetScope || typeof targetScope !== 'object') {\n    return null;\n  }\n\n  let queue = targetScope[queueKey];\n  if (Array.isArray(queue)) {\n    return queue;\n  }\n\n  if (!fallbackDefineHiddenProperty(targetScope, queueKey, [])) {\n    return null;\n  }\n\n  queue = targetScope[queueKey];\n  if (!Array.isArray(queue)) {\n    return null;\n  }\n\n  return queue;\n}\n\nconst BUILTIN_IMMUTABILITY = (function resolveBuiltinImmutability() {\n  const registryKey = '__cineBuiltinImmutabilityGuards__';\n  const scopes = fallbackCollectCandidateScopes(null, fallbackDetectGlobalScope());\n\n  // Require removed for ESM conversion\n\n  for (let index = 0; index < scopes.length; index += 1) {\n    const scope = scopes[index];\n    if (!scope || (typeof scope !== 'object' && typeof scope !== 'function')) {\n      continue;\n    }\n\n    try {\n      const candidate = scope[registryKey];\n      if (candidate && typeof candidate === 'object') {\n        return candidate;\n      }\n    } catch (error) {\n      void error;\n    }\n  }\n\n  return null;\n})();\n\nfunction isEthereumProviderCandidate(value) {\n  if (!value || typeof value === 'function' || (typeof value !== 'object' && typeof value !== 'function')) {\n    return false;\n  }\n\n  if (PRIMARY_SCOPE && typeof PRIMARY_SCOPE === 'object') {\n    try {\n      if (value === PRIMARY_SCOPE.ethereum) {\n        return true;\n      }\n    } catch (error) {\n      void error;\n      return true;\n    }\n  }\n\n  try {\n    if (value.isMetaMask === true) {\n      return true;\n    }\n  } catch (inspectionError) {\n    if (inspectionError && typeof inspectionError.message === 'string' && /metamask/i.test(inspectionError.message)) {\n      return true;\n    }\n  }\n\n  try {\n    if (typeof value.request === 'function' && typeof value.on === 'function') {\n      if (typeof value.removeListener === 'function' || typeof value.removeEventListener === 'function') {\n        return true;\n      }\n\n      const ctorName = value.constructor && value.constructor.name;\n      if (ctorName && /Ethereum|MetaMask|Provider/i.test(ctorName)) {\n        return true;\n      }\n    }\n  } catch (accessError) {\n    void accessError;\n    return true;\n  }\n\n  return false;\n}\n\nfunction isNodeProcessReference(value) {\n  if (!value) {\n    return false;\n  }\n\n  if (typeof process === 'undefined' || !process) {\n    return false;\n  }\n\n  if (value === process) {\n    return true;\n  }\n\n  if (typeof value === 'object') {\n    try {\n      if (value.constructor && value.constructor.name === 'process') {\n        return true;\n      }\n    } catch (processInspectionError) {\n      void processInspectionError;\n    }\n\n    if (\n      typeof value.pid === 'number' &&\n      typeof value.nextTick === 'function' &&\n      typeof value.emit === 'function' &&\n      typeof value.binding === 'function'\n    ) {\n      return true;\n    }\n  }\n\n  if (typeof value === 'function') {\n    if (\n      value === process.binding ||\n      value === process._linkedBinding ||\n      value === process.dlopen\n    ) {\n      return true;\n    }\n\n    try {\n      const functionName = value.name || '';\n      if (functionName && (functionName === 'binding' || functionName === 'dlopen')) {\n        const source = Function.prototype.toString.call(value);\n        if (source && source.indexOf('[native code]') !== -1) {\n          return true;\n        }\n      }\n    } catch (functionInspectionError) {\n      void functionInspectionError;\n    }\n  }\n\n  return false;\n}\n\nfunction shouldBypassDeepFreeze(value) {\n  if (!value || typeof value === 'function' || (typeof value !== 'object' && typeof value !== 'function')) {\n    return false;\n  }\n\n  if (isNodeProcessReference(value)) {\n    return true;\n  }\n\n  if (\n    typeof value === 'object' &&\n    value &&\n    typeof value.id === 'string' &&\n    typeof value.filename === 'string' &&\n    (typeof value.loaded === 'boolean' || Array.isArray(value.children))\n  ) {\n    return true;\n  }\n\n  if (\n    typeof process !== 'undefined' &&\n    process &&\n    process.release &&\n    process.release.name === 'node'\n  ) {\n    return true;\n  }\n\n  try {\n    if (\n      BUILTIN_IMMUTABILITY &&\n      typeof BUILTIN_IMMUTABILITY.isImmutableBuiltin === 'function' &&\n      BUILTIN_IMMUTABILITY.isImmutableBuiltin(value)\n    ) {\n      return true;\n    }\n\n    if (typeof value.pipe === 'function' && typeof value.unpipe === 'function') {\n      return true;\n    }\n\n    if (typeof value.on === 'function' && typeof value.emit === 'function') {\n      if (typeof value.write === 'function' || typeof value.read === 'function') {\n        return true;\n      }\n\n      const ctorName = value.constructor && value.constructor.name;\n      if (ctorName && /Stream|Emitter|Port/i.test(ctorName)) {\n        return true;\n      }\n    }\n\n    if (typeof Symbol !== 'undefined' && value[Symbol.toStringTag]) {\n      const tag = value[Symbol.toStringTag];\n      if (typeof tag === 'string' && /Stream|Port/i.test(tag)) {\n        return true;\n      }\n    }\n  } catch (inspectionError) {\n    void inspectionError;\n  }\n\n  return false;\n}\n\nfunction fallbackResolveSeenTracker(seen) {\n  if (seen && typeof seen.has === 'function' && typeof seen.add === 'function') {\n    return seen;\n  }\n\n  if (Array.isArray(seen)) {\n    return {\n      has(value) {\n        return seen.indexOf(value) !== -1;\n      },\n      add(value) {\n        if (seen.indexOf(value) === -1) {\n          seen.push(value);\n        }\n      },\n    };\n  }\n\n  if (typeof WeakSet === 'function') {\n    try {\n      return new WeakSet();\n    } catch (trackerError) {\n      void trackerError;\n    }\n  }\n\n  const tracked = [];\n  return {\n    has(value) {\n      return tracked.indexOf(value) !== -1;\n    },\n    add(value) {\n      if (tracked.indexOf(value) === -1) {\n        tracked.push(value);\n      }\n    },\n  };\n}\n\nfunction fallbackFreezeDeep(value, seen) {\n  if (!value || typeof value === 'function' || (typeof value !== 'object' && typeof value !== 'function')) {\n    return value;\n  }\n\n  if (shouldBypassDeepFreeze(value) || isEthereumProviderCandidate(value)) {\n    return value;\n  }\n\n  if (typeof value === 'function') {\n    try {\n      return Object.freeze(value);\n    } catch (freezeError) {\n      void freezeError;\n      return value;\n    }\n  }\n\n  const tracker = fallbackResolveSeenTracker(seen);\n\n  if (tracker.has(value)) {\n    return value;\n  }\n\n  tracker.add(value);\n\n  let keys;\n  try {\n    keys = Object.getOwnPropertyNames(value);\n  } catch (error) {\n    void error;\n    return value;\n  }\n  for (let index = 0; index < keys.length; index += 1) {\n    const key = keys[index];\n\n    let descriptor;\n    try {\n      descriptor = Object.getOwnPropertyDescriptor(value, key);\n    } catch (descriptorError) {\n      void descriptorError;\n      descriptor = null;\n    }\n\n    if (\n      descriptor &&\n      (typeof descriptor.get === 'function' || typeof descriptor.set === 'function')\n    ) {\n      continue;\n    }\n\n    let child;\n    try {\n      child = value[key];\n    } catch (accessError) {\n      void accessError;\n      child = undefined;\n    }\n    if (!child || typeof child === 'function' || (typeof child !== 'object' && typeof child !== 'function')) {\n      continue;\n    }\n\n    if (shouldBypassDeepFreeze(child) || isEthereumProviderCandidate(child)) {\n      continue;\n    }\n\n    fallbackFreezeDeep(child, tracker);\n  }\n\n  try {\n    return Object.freeze(value);\n  } catch (freezeError) {\n    void freezeError;\n    return value;\n  }\n}\n\nfunction fallbackSafeWarn(message, detail) {\n  if (typeof console === 'undefined' || typeof console.warn !== 'function') {\n    return;\n  }\n\n  try {\n    if (typeof detail === 'undefined') {\n      console.warn(message);\n    } else {\n      console.warn(message, detail);\n    }\n  } catch (error) {\n    void error;\n  }\n}\n\nfunction fallbackResolveModuleRegistry(scope, baseScope) {\n  const targetScope = scope || baseScope;\n\n  const required = fallbackTryRequire('./registry.js');\n  if (required && typeof required === 'object') {\n    return required;\n  }\n\n  const scopes = fallbackCollectCandidateScopes(targetScope, baseScope);\n  for (let index = 0; index < scopes.length; index += 1) {\n    const candidate = scopes[index];\n    if (candidate && typeof candidate.cineModules === 'object') {\n      return candidate.cineModules;\n    }\n  }\n\n  return null;\n}\n\nfunction fallbackQueueModuleRegistration(scope, name, api, options, baseScope) {\n  const targetScope = scope || baseScope;\n  const queue = fallbackEnsureQueue(targetScope, DEFAULT_PENDING_QUEUE_KEY, baseScope);\n  if (!queue) {\n    return false;\n  }\n\n  const payload = Object.freeze({\n    name,\n    api,\n    options: Object.freeze({ ...(options || {}) }),\n  });\n\n  try {\n    queue.push(payload);\n    return true;\n  } catch (error) {\n    void error;\n  }\n\n  try {\n    queue[queue.length] = payload;\n    return true;\n  } catch (assignmentError) {\n    void assignmentError;\n  }\n\n  return false;\n}\n\nfunction createFallbackKernel(primaryScope) {\n  const baseScope = primaryScope || fallbackDetectGlobalScope();\n\n  return {\n    detectGlobalScope: fallbackDetectGlobalScope,\n    getGlobalScope() {\n      return baseScope;\n    },\n    collectCandidateScopes(primary) {\n      return fallbackCollectCandidateScopes(primary || baseScope, baseScope);\n    },\n    tryRequire: fallbackTryRequire,\n    defineHiddenProperty: fallbackDefineHiddenProperty,\n    ensureQueue(scope, key) {\n      return fallbackEnsureQueue(scope || baseScope, key, baseScope);\n    },\n    freezeDeep: fallbackFreezeDeep,\n    safeWarn: fallbackSafeWarn,\n    resolveModuleRegistry(scope) {\n      return fallbackResolveModuleRegistry(scope || baseScope, baseScope);\n    },\n    queueModuleRegistration(scope, name, api, options) {\n      return fallbackQueueModuleRegistration(scope || baseScope, name, api, options, baseScope);\n    },\n    getPendingQueueKey() {\n      return DEFAULT_PENDING_QUEUE_KEY;\n    },\n  };\n}\n\nfunction resolveArchitectureKernel(scope) {\n  const targetScope = scope || fallbackDetectGlobalScope();\n\n  // Require removed for ESM conversion\n\n  if (targetScope && typeof targetScope.cineModuleArchitectureKernel === 'object') {\n    return targetScope.cineModuleArchitectureKernel;\n  }\n\n  return null;\n}\n\nconst LOCAL_SCOPE = fallbackDetectGlobalScope();\ninstallSafeConsoleGuards(LOCAL_SCOPE);\nconst RESOLVED_KERNEL = resolveArchitectureKernel(LOCAL_SCOPE);\nconst ACTIVE_KERNEL = RESOLVED_KERNEL || createFallbackKernel(LOCAL_SCOPE);\n\nfunction detectGlobalScope() {\n  if (ACTIVE_KERNEL && typeof ACTIVE_KERNEL.detectGlobalScope === 'function') {\n    try {\n      const detected = ACTIVE_KERNEL.detectGlobalScope();\n      if (detected) {\n        return detected;\n      }\n    } catch (error) {\n      void error;\n    }\n  }\n  return fallbackDetectGlobalScope();\n}\n\nconst PRIMARY_SCOPE =\n  ACTIVE_KERNEL && typeof ACTIVE_KERNEL.getGlobalScope === 'function'\n    ? (function resolvePrimaryScope() {\n      try {\n        const scoped = ACTIVE_KERNEL.getGlobalScope();\n        if (scoped) {\n          return scoped;\n        }\n      } catch (error) {\n        void error;\n      }\n      return detectGlobalScope();\n    })()\n    : detectGlobalScope();\n\nconst PENDING_QUEUE_KEY =\n  ACTIVE_KERNEL && typeof ACTIVE_KERNEL.getPendingQueueKey === 'function'\n    ? ACTIVE_KERNEL.getPendingQueueKey()\n    : DEFAULT_PENDING_QUEUE_KEY;\n\nfunction collectCandidateScopes(primary) {\n  if (ACTIVE_KERNEL && typeof ACTIVE_KERNEL.collectCandidateScopes === 'function') {\n    try {\n      const collected = ACTIVE_KERNEL.collectCandidateScopes(primary || PRIMARY_SCOPE);\n      if (Array.isArray(collected) && collected.length > 0) {\n        return collected;\n      }\n    } catch (error) {\n      void error;\n    }\n  }\n  return fallbackCollectCandidateScopes(primary || PRIMARY_SCOPE, PRIMARY_SCOPE);\n}\n\nfunction baseTryRequire(modulePath) {\n  if (ACTIVE_KERNEL && typeof ACTIVE_KERNEL.tryRequire === 'function') {\n    try {\n      const result = ACTIVE_KERNEL.tryRequire(modulePath);\n      if (typeof result !== 'undefined') {\n        return result;\n      }\n    } catch (error) {\n      void error;\n    }\n  }\n\n  return fallbackTryRequire(modulePath);\n}\n\nfunction baseResolveModuleRegistry(scope) {\n  const targetScope = scope || PRIMARY_SCOPE;\n\n  if (ACTIVE_KERNEL && typeof ACTIVE_KERNEL.resolveModuleRegistry === 'function') {\n    try {\n      const resolved = ACTIVE_KERNEL.resolveModuleRegistry(targetScope);\n      if (resolved && typeof resolved === 'object') {\n        return resolved;\n      }\n    } catch (error) {\n      void error;\n    }\n  }\n\n  const required = baseTryRequire('./registry.js');\n  if (required && typeof required === 'object') {\n    return required;\n  }\n\n  const scopes = collectCandidateScopes(targetScope);\n  for (let index = 0; index < scopes.length; index += 1) {\n    const candidate = scopes[index];\n    if (candidate && typeof candidate.cineModules === 'object') {\n      return candidate.cineModules;\n    }\n  }\n\n  return null;\n}\n\nlet cachedModuleRegistry = null;\nlet hasResolvedRegistry = false;\n\nfunction getModuleRegistry(scope) {\n  if (!hasResolvedRegistry || (scope && scope !== PRIMARY_SCOPE)) {\n    const resolved = baseResolveModuleRegistry(scope);\n    if (scope && scope !== PRIMARY_SCOPE) {\n      return resolved;\n    }\n    cachedModuleRegistry = resolved;\n    hasResolvedRegistry = true;\n  }\n\n  return cachedModuleRegistry;\n}\n\nfunction ensureQueue(scope) {\n  const targetScope = scope || PRIMARY_SCOPE;\n\n  if (ACTIVE_KERNEL && typeof ACTIVE_KERNEL.ensureQueue === 'function') {\n    try {\n      const queue = ACTIVE_KERNEL.ensureQueue(targetScope, PENDING_QUEUE_KEY);\n      if (Array.isArray(queue)) {\n        return queue;\n      }\n    } catch (error) {\n      void error;\n    }\n  }\n\n  return fallbackEnsureQueue(targetScope, PENDING_QUEUE_KEY, PRIMARY_SCOPE);\n}\n\nfunction queueModuleRegistration(scope, name, api, options) {\n  const targetScope = scope || PRIMARY_SCOPE;\n\n  if (ACTIVE_KERNEL && typeof ACTIVE_KERNEL.queueModuleRegistration === 'function') {\n    try {\n      if (ACTIVE_KERNEL.queueModuleRegistration(targetScope, name, api, options)) {\n        return true;\n      }\n    } catch (error) {\n      void error;\n    }\n  }\n\n  const queue = ensureQueue(targetScope);\n  if (!queue) {\n    return false;\n  }\n\n  const payload = Object.freeze({\n    name,\n    api,\n    options: Object.freeze({ ...(options || {}) }),\n  });\n\n  try {\n    queue.push(payload);\n  } catch (error) {\n    void error;\n    queue[queue.length] = payload;\n  }\n\n  return true;\n}\n\nfunction baseRegisterOrQueueModule(scope, registry, name, api, options, onError) {\n  if (registry && typeof registry.register === 'function') {\n    try {\n      registry.register(name, api, options);\n      return true;\n    } catch (error) {\n      if (typeof onError === 'function') {\n        onError(error);\n      } else {\n        void error;\n      }\n    }\n  }\n\n  queueModuleRegistration(scope, name, api, options);\n  return false;\n}\n\nfunction baseFreezeDeep(value) {\n  if (!value || typeof value === 'function' || (typeof value !== 'object' && typeof value !== 'function')) {\n    return value;\n  }\n\n  if (shouldBypassDeepFreeze(value) || isEthereumProviderCandidate(value)) {\n    return value;\n  }\n\n  if (ACTIVE_KERNEL && typeof ACTIVE_KERNEL.freezeDeep === 'function') {\n    try {\n      return ACTIVE_KERNEL.freezeDeep(value);\n    } catch (error) {\n      void error;\n    }\n  }\n\n  return fallbackFreezeDeep(value);\n}\n\nfunction baseSafeWarn(message, detail) {\n  if (ACTIVE_KERNEL && typeof ACTIVE_KERNEL.safeWarn === 'function') {\n    try {\n      ACTIVE_KERNEL.safeWarn(message, detail);\n      return;\n    } catch (error) {\n      void error;\n    }\n  }\n\n  fallbackSafeWarn(message, detail);\n}\n\nfunction exposeGlobal(name, value, scope, options = {}) {\n  const targetScope = scope || PRIMARY_SCOPE;\n  if (!targetScope || typeof targetScope !== 'object') {\n    return false;\n  }\n\n  const descriptor = {\n    configurable: options.configurable !== false,\n    enumerable: !!options.enumerable,\n    value,\n    writable: options.writable === true,\n  };\n\n  try {\n    Object.defineProperty(targetScope, name, descriptor);\n    return true;\n  } catch (error) {\n    void error;\n    try {\n      targetScope[name] = value;\n      return true;\n    } catch (assignmentError) {\n      void assignmentError;\n      return false;\n    }\n  }\n}\n\nconst baseApi = baseFreezeDeep({\n  getGlobalScope() {\n    return PRIMARY_SCOPE;\n  },\n  collectCandidateScopes,\n  tryRequire: baseTryRequire,\n  resolveModuleRegistry: baseResolveModuleRegistry,\n  getModuleRegistry,\n  queueModuleRegistration(name, api, options, scope) {\n    return queueModuleRegistration(scope || PRIMARY_SCOPE, name, api, options);\n  },\n  registerOrQueueModule(name, api, options, onError, scope, registry) {\n    const targetScope = scope || PRIMARY_SCOPE;\n    const moduleRegistry = registry || getModuleRegistry(targetScope);\n    return baseRegisterOrQueueModule(targetScope, moduleRegistry, name, api, options, onError);\n  },\n  freezeDeep: baseFreezeDeep,\n  safeWarn: baseSafeWarn,\n  exposeGlobal,\n  PENDING_QUEUE_KEY,\n});\n\nconst registry = getModuleRegistry();\nbaseRegisterOrQueueModule(\n  PRIMARY_SCOPE,\n  registry,\n  'cineModuleBase',\n  baseApi,\n  {\n    category: 'infrastructure',\n    description: 'Shared helpers for module registration, freezing and safe global exposure.',\n    replace: true,\n    connections: ['cineModuleArchitectureKernel', 'cineModuleArchitectureHelpers'],\n  },\n  (error) => {\n    baseSafeWarn('Unable to register cineModuleBase.', error);\n  },\n);\n\nexposeGlobal('cineModuleBase', baseApi, PRIMARY_SCOPE, { configurable: true, enumerable: false, writable: false });\n\nexport default baseApi;\nexport { baseApi as cineModuleBase };\n","/**\n * The registry is the shared phone book for every module that bootstraps the\n * planner. Comments throughout the file explain why we cache the lookups and\n * which safeguards keep user data utilities from being redefined by accident.\n */\nconst GLOBAL_SCOPE =\n  typeof globalThis !== 'undefined'\n    ? globalThis\n    : typeof window !== 'undefined'\n      ? window\n      : typeof self !== 'undefined'\n        ? self\n        : typeof global !== 'undefined'\n          ? global\n          : {};\n\nlet ensureConsoleMethodsWritable = null;\n\nif (\n  !ensureConsoleMethodsWritable\n  && GLOBAL_SCOPE\n  && typeof GLOBAL_SCOPE.__cineEnsureConsoleMethodsWritable === 'function'\n) {\n  ensureConsoleMethodsWritable = GLOBAL_SCOPE.__cineEnsureConsoleMethodsWritable;\n}\n\nif (typeof ensureConsoleMethodsWritable === 'function') {\n  ensureConsoleMethodsWritable(['warn', 'info']);\n}\n\nconst PENDING_QUEUE_KEY = '__cinePendingModuleRegistrations__';\nconst QUEUE_FLUSH_TIMER_KEY = '__cinePendingModuleRegistrationsTimer__';\n\nlet moduleMap = Object.create(null);\nlet metadataMap = Object.create(null);\nlet registryReference = null;\n\n/**\n * Discover the immutability helpers that freeze exported APIs. We perform the\n * same guarded probing used across the codebase so the registry works in\n * browsers, workers and tests without assuming a specific runtime.\n */\nfunction resolveImmutability(scope) {\n  const targetScope = scope || GLOBAL_SCOPE;\n\n  const scopes = [targetScope];\n  if (typeof globalThis !== 'undefined' && scopes.indexOf(globalThis) === -1) scopes.push(globalThis);\n  if (typeof window !== 'undefined' && scopes.indexOf(window) === -1) scopes.push(window);\n  if (typeof self !== 'undefined' && scopes.indexOf(self) === -1) scopes.push(self);\n  if (typeof global !== 'undefined' && scopes.indexOf(global) === -1) scopes.push(global);\n\n  for (let index = 0; index < scopes.length; index += 1) {\n    const candidate = scopes[index];\n    if (candidate && typeof candidate.cineModuleImmutability === 'object') {\n      return candidate.cineModuleImmutability;\n    }\n  }\n\n  return null;\n}\n\nconst BUILTIN_IMMUTABILITY = (function resolveBuiltinImmutability() {\n  // Built-in guards are cached on the global scope because they are reused by\n  // multiple modules. Documenting this avoids confusion when debugging deep\n  // freeze issues across different bundles.\n  const registryKey = '__cineBuiltinImmutabilityGuards__';\n  const scopes = [GLOBAL_SCOPE];\n  if (typeof globalThis !== 'undefined' && globalThis !== GLOBAL_SCOPE) scopes.push(globalThis);\n  if (typeof window !== 'undefined') scopes.push(window);\n  if (typeof self !== 'undefined') scopes.push(self);\n  if (typeof global !== 'undefined') scopes.push(global);\n\n  for (let index = 0; index < scopes.length; index += 1) {\n    const scope = scopes[index];\n    if (!scope || (typeof scope !== 'object' && typeof scope !== 'function')) {\n      continue;\n    }\n\n    try {\n      const candidate = scope[registryKey];\n      if (candidate && typeof candidate === 'object') {\n        return candidate;\n      }\n    } catch (error) {\n      void error;\n    }\n  }\n\n  return null;\n})();\n\nfunction createFallbackImmutability() {\n  // The fallback freeze logic imitates the helper shipped with the modern\n  // runtime. extensive inline comments make it clear why certain objects such\n  // as streams are excluded from freezing: mutating them is necessary for\n  // Node-based tooling and does not impact project persistence.\n  function shouldBypass(value) {\n    if (!value || typeof value === 'function' || (typeof value !== 'object' && typeof value !== 'function')) {\n      return false;\n    }\n\n    try {\n      if (\n        BUILTIN_IMMUTABILITY &&\n        typeof BUILTIN_IMMUTABILITY.isImmutableBuiltin === 'function' &&\n        BUILTIN_IMMUTABILITY.isImmutableBuiltin(value)\n      ) {\n        return true;\n      }\n\n      if (typeof value.pipe === 'function' && typeof value.unpipe === 'function') {\n        return true;\n      }\n\n      if (typeof value.on === 'function' && typeof value.emit === 'function') {\n        if (typeof value.write === 'function' || typeof value.read === 'function') {\n          return true;\n        }\n\n        const ctorName = value.constructor && value.constructor.name;\n        if (ctorName && /Stream|Emitter|Port/i.test(ctorName)) {\n          return true;\n        }\n      }\n\n      if (typeof Symbol !== 'undefined' && value[Symbol.toStringTag]) {\n        const tag = value[Symbol.toStringTag];\n        if (typeof tag === 'string' && /Stream|Port/i.test(tag)) {\n          return true;\n        }\n      }\n    } catch (inspectionError) {\n      void inspectionError;\n    }\n\n    return false;\n  }\n\n  function freeze(value, seen = new WeakSet()) {\n    if (!value || typeof value === 'function' || (typeof value !== 'object' && typeof value !== 'function')) {\n      return value;\n    }\n\n    if (shouldBypass(value)) {\n      return value;\n    }\n\n    if (seen.has(value)) {\n      return value;\n    }\n\n    seen.add(value);\n\n    const keys = Object.getOwnPropertyNames(value);\n    for (let index = 0; index < keys.length; index += 1) {\n      const key = keys[index];\n      let child;\n      try {\n        child = value[key];\n      } catch (accessError) {\n        void accessError;\n        child = undefined;\n      }\n      if (!child || typeof child === 'function' || (typeof child !== 'object' && typeof child !== 'function')) {\n        continue;\n      }\n      freeze(child, seen);\n    }\n\n    try {\n      return Object.freeze(value);\n    } catch (freezeError) {\n      void freezeError;\n      return value;\n    }\n  }\n\n  return {\n    shouldBypassDeepFreeze: shouldBypass,\n    freezeDeep: freeze,\n  };\n}\n\nconst FALLBACK_IMMUTABILITY = createFallbackImmutability();\nlet activeImmutability = resolveImmutability(GLOBAL_SCOPE) || FALLBACK_IMMUTABILITY;\n\nfunction getImmutability() {\n  if (activeImmutability !== FALLBACK_IMMUTABILITY) {\n    return activeImmutability;\n  }\n\n  const resolved = resolveImmutability(GLOBAL_SCOPE);\n  if (resolved && resolved !== activeImmutability) {\n    activeImmutability = resolved;\n  }\n\n  return activeImmutability;\n}\n\nfunction freezeDeep(value, seen) {\n  const provider = getImmutability();\n\n  try {\n    return provider.freezeDeep(value, seen);\n  } catch (error) {\n    void error;\n  }\n\n  return FALLBACK_IMMUTABILITY.freezeDeep(value, seen);\n}\n\nfunction normalizeName(name) {\n  if (typeof name === 'string') {\n    const trimmed = name.trim();\n    if (trimmed) {\n      return trimmed;\n    }\n  }\n  throw new TypeError('cineModules.register expected a non-empty string name.');\n}\n\nfunction normalizeConnections(value) {\n  if (value == null) {\n    return [];\n  }\n\n  const entries = Array.isArray(value)\n    ? value\n    : typeof value === 'string'\n      ? [value]\n      : typeof value[Symbol.iterator] === 'function'\n        ? Array.from(value)\n        : [value];\n\n  const seen = new Set();\n  const normalized = [];\n\n  for (let index = 0; index < entries.length; index += 1) {\n    const entry = entries[index];\n    let raw = null;\n\n    if (typeof entry === 'string') {\n      raw = entry;\n    } else if (entry && typeof entry.name === 'string') {\n      raw = entry.name;\n    }\n\n    if (!raw) {\n      continue;\n    }\n\n    const trimmed = raw.trim();\n    if (!trimmed || seen.has(trimmed)) {\n      continue;\n    }\n\n    seen.add(trimmed);\n    normalized.push(trimmed);\n  }\n\n  return normalized;\n}\n\n\n/**\n * Register a Module\n *\n * Publishes a module API to the central registry, making it available to `get()` callers.\n *\n * Mechanisms:\n * 1. NORMALIZATION: \"My Module \" becomes \"My Module\".\n * 2. IMMUTABILITY: By default, the API object is Deep Frozen to prevent other modules from accidentally mutating it.\n * 3. CONFLICT CHECK: Throws if a module with the same name exists (unless `replace: true` is specified), ensuring consistency.\n * 4. METADATA: Stores descriptive metadata (category, description, connections) separately from the runtime logic.\n *\n * @param {string} name - Unique identifier for the module.\n * @param {object} moduleApi - The public interface of the module.\n * @param {object} [options] - Configuration (freeze, replace, description, etc).\n * @returns {object} - The (potentially frozen) module API.\n */\nfunction register(name, moduleApi, options = {}) {\n  const normalizedName = normalizeName(name);\n\n  if (!moduleApi || (typeof moduleApi !== 'object' && typeof moduleApi !== 'function')) {\n    throw new TypeError(`cineModules.register(\"${normalizedName}\") expected an object or function.`);\n  }\n\n  const freeze = options.freeze !== false;\n  const descriptor = freeze && !Object.isFrozen(moduleApi)\n    ? freezeDeep(moduleApi)\n    : moduleApi;\n\n  if (Object.prototype.hasOwnProperty.call(moduleMap, normalizedName)) {\n    const existing = moduleMap[normalizedName];\n    if (existing === descriptor) {\n      return existing;\n    }\n\n    if (!options.replace) {\n      throw new Error(`cineModules: Module \"${normalizedName}\" is already registered. Use { replace: true } to overwrite.`);\n    }\n  }\n\n  moduleMap[normalizedName] = descriptor;\n  metadataMap[normalizedName] = {\n    description: typeof options.description === 'string' ? options.description.trim() : '',\n    category: typeof options.category === 'string' ? options.category.trim() : '',\n    registeredAt: Date.now(),\n    frozen: freeze,\n    connections: freezeDeep(normalizeConnections(\n      options.connections || options.links || options.dependencies || null,\n    )),\n  };\n\n  return descriptor;\n}\n\n/**\n * Retrieve a Registered Module\n *\n * This is the primary lookup method for inter-module dependencies.\n * - It normalizes names to prevent case/whitespace confusing bugs.\n * - It is O(1) via a hash map lookup (`moduleMap`).\n * - Ideally, consumers should cache the result if used in a hot loop, though the lookup itself is fast.\n *\n * @param {string} name - The name of the module to retrieve.\n * @returns {object|null} - The module API object if found, or null.\n */\nfunction get(name) {\n  const normalizedName = normalizeName(name);\n  return Object.prototype.hasOwnProperty.call(moduleMap, normalizedName)\n    ? moduleMap[normalizedName]\n    : null;\n}\n\nfunction has(name) {\n  const normalizedName = normalizeName(name);\n  return Object.prototype.hasOwnProperty.call(moduleMap, normalizedName);\n}\n\nfunction list() {\n  return Object.freeze(Object.keys(moduleMap).sort());\n}\n\nfunction describe(name) {\n  const normalizedName = normalizeName(name);\n  const meta = metadataMap[normalizedName];\n  if (!meta) {\n    return null;\n  }\n  return Object.freeze({\n    name: normalizedName,\n    description: meta.description,\n    category: meta.category,\n    registeredAt: meta.registeredAt,\n    frozen: meta.frozen,\n    connections: meta.connections || freezeDeep([]),\n  });\n}\n\nfunction normalizeNameCollection(value) {\n  if (value == null) {\n    return null;\n  }\n\n  const entries = Array.isArray(value)\n    ? value\n    : typeof value === 'string'\n      ? [value]\n      : typeof value[Symbol.iterator] === 'function'\n        ? Array.from(value)\n        : [value];\n\n  const normalized = [];\n  const seen = new Set();\n\n  for (let index = 0; index < entries.length; index += 1) {\n    const entry = entries[index];\n\n    try {\n      const normalizedName = normalizeName(entry);\n      if (!seen.has(normalizedName)) {\n        seen.add(normalizedName);\n        normalized.push(normalizedName);\n      }\n    } catch (error) {\n      void error;\n    }\n  }\n\n  return normalized.length > 0 ? normalized : null;\n}\n\nfunction normalizeCategoryCollection(value) {\n  if (value == null) {\n    return null;\n  }\n\n  const entries = Array.isArray(value)\n    ? value\n    : typeof value === 'string'\n      ? [value]\n      : typeof value[Symbol.iterator] === 'function'\n        ? Array.from(value)\n        : [value];\n\n  const normalized = [];\n  const seen = new Set();\n\n  for (let index = 0; index < entries.length; index += 1) {\n    const entry = entries[index];\n    if (typeof entry !== 'string') {\n      continue;\n    }\n\n    const trimmed = entry.trim();\n    if (!trimmed || seen.has(trimmed)) {\n      continue;\n    }\n\n    seen.add(trimmed);\n    normalized.push(trimmed);\n  }\n\n  return normalized.length > 0 ? normalized : null;\n}\n\nfunction describeAll(options = {}) {\n  const normalizedNames = normalizeNameCollection(options && options.names);\n  const normalizedCategories = normalizeCategoryCollection(\n    options && (options.categories || options.category || null),\n  );\n\n  const namesFilter = normalizedNames ? new Set(normalizedNames) : null;\n  const categoryFilter = normalizedCategories ? new Set(normalizedCategories) : null;\n\n  const snapshot = [];\n\n  const sourceNames = namesFilter ? normalizedNames : Object.keys(metadataMap);\n\n  for (let index = 0; index < sourceNames.length; index += 1) {\n    const name = sourceNames[index];\n    const meta = metadataMap[name];\n    if (!meta) {\n      continue;\n    }\n\n    if (categoryFilter && !categoryFilter.has(meta.category)) {\n      continue;\n    }\n\n    snapshot.push({\n      name,\n      description: meta.description,\n      category: meta.category,\n      registeredAt: meta.registeredAt,\n      frozen: meta.frozen,\n      connections: meta.connections || freezeDeep([]),\n    });\n  }\n\n  if (!namesFilter) {\n    const shouldSort = !options || options.sort !== false;\n    if (shouldSort) {\n      snapshot.sort((left, right) => left.name.localeCompare(right.name));\n    }\n  }\n\n  return freezeDeep(snapshot);\n}\n\nfunction assertRegistered(names) {\n  const entries = Array.isArray(names) ? names.slice() : [names];\n  const detail = {};\n  const missing = [];\n\n  for (let index = 0; index < entries.length; index += 1) {\n    const name = normalizeName(entries[index]);\n    const present = has(name);\n    detail[name] = present;\n    if (!present) {\n      missing.push(name);\n    }\n  }\n\n  return Object.freeze({\n    ok: missing.length === 0,\n    missing: Object.freeze(missing),\n    detail: Object.freeze(detail),\n  });\n}\n\nfunction resetForTests(options = {}) {\n  const isTestEnvironment =\n    typeof process !== 'undefined' &&\n    process &&\n    process.env &&\n    process.env.NODE_ENV === 'test';\n\n  if (!isTestEnvironment) {\n    throw new Error('cineModules.__internalResetForTests() is restricted to test environments.');\n  }\n\n  if (!options || options.force !== true) {\n    throw new Error('cineModules.__internalResetForTests() requires { force: true }.');\n  }\n\n  moduleMap = Object.create(null);\n  metadataMap = Object.create(null);\n\n  // Cancel any pending flushes and plain the queue\n  const scopes = [GLOBAL_SCOPE];\n  if (typeof globalThis !== 'undefined' && globalThis !== GLOBAL_SCOPE) scopes.push(globalThis);\n  if (typeof window !== 'undefined' && scopes.indexOf(window) === -1) scopes.push(window);\n  if (typeof self !== 'undefined' && scopes.indexOf(self) === -1) scopes.push(self);\n  if (typeof global !== 'undefined' && scopes.indexOf(global) === -1) scopes.push(global);\n\n  for (const scope of scopes) {\n    if (scope) {\n      cancelPendingFlush(scope);\n      if (Array.isArray(scope[PENDING_QUEUE_KEY])) {\n        scope[PENDING_QUEUE_KEY].length = 0;\n      }\n    }\n  }\n\n  return true;\n}\n\nfunction getTimerDescriptor(scope) {\n  if (!scope || typeof scope !== 'object') {\n    return null;\n  }\n\n  const descriptor = scope[QUEUE_FLUSH_TIMER_KEY];\n  return descriptor && typeof descriptor === 'object' ? descriptor : null;\n}\n\nfunction assignHidden(scope, key, value) {\n  if (!scope || (typeof scope !== 'object' && typeof scope !== 'function')) {\n    return false;\n  }\n\n  try {\n    Object.defineProperty(scope, key, {\n      configurable: true,\n      enumerable: false,\n      writable: true,\n      value,\n    });\n    return true;\n  } catch (error) {\n    void error;\n  }\n\n  try {\n    scope[key] = value;\n    return true;\n  } catch (assignmentError) {\n    void assignmentError;\n  }\n\n  return false;\n}\n\nfunction cancelPendingFlush(scope) {\n  const descriptor = getTimerDescriptor(scope);\n  if (!descriptor) {\n    return;\n  }\n\n  const clearTimer = descriptor && typeof descriptor.clear === 'function' ? descriptor.clear : null;\n  if (clearTimer && Object.prototype.hasOwnProperty.call(descriptor, 'id')) {\n    try {\n      clearTimer(descriptor.id);\n    } catch (error) {\n      void error;\n    }\n  }\n\n  assignHidden(scope, QUEUE_FLUSH_TIMER_KEY, null);\n}\n\nfunction schedulePendingFlush(scope) {\n  if (!scope || typeof scope !== 'object') {\n    return;\n  }\n\n  const queue = scope[PENDING_QUEUE_KEY];\n  if (!Array.isArray(queue) || queue.length === 0) {\n    cancelPendingFlush(scope);\n    return;\n  }\n\n  if (getTimerDescriptor(scope)) {\n    return;\n  }\n\n  const scheduleFromScope =\n    (typeof scope.setTimeout === 'function' && scope.setTimeout.bind(scope)) ||\n    (typeof GLOBAL_SCOPE.setTimeout === 'function' && GLOBAL_SCOPE.setTimeout.bind(GLOBAL_SCOPE)) ||\n    (typeof setTimeout === 'function' ? setTimeout : null);\n\n  if (typeof scheduleFromScope !== 'function') {\n    return;\n  }\n\n  const clearFromScope =\n    (typeof scope.clearTimeout === 'function' && scope.clearTimeout.bind(scope)) ||\n    (typeof GLOBAL_SCOPE.clearTimeout === 'function' && GLOBAL_SCOPE.clearTimeout.bind(GLOBAL_SCOPE)) ||\n    (typeof clearTimeout === 'function' ? clearTimeout : null);\n\n  const timerId = scheduleFromScope(function retryFlush() {\n    cancelPendingFlush(scope);\n    flushPendingRegistrations(scope);\n  }, 0);\n\n  assignHidden(scope, QUEUE_FLUSH_TIMER_KEY, {\n    id: timerId,\n    clear: typeof clearFromScope === 'function' ? clearFromScope : null,\n  });\n}\n\nfunction flushPendingRegistrations(scope) {\n  if (!scope || typeof scope !== 'object') {\n    return;\n  }\n\n  const queue = scope[PENDING_QUEUE_KEY];\n  if (!Array.isArray(queue) || queue.length === 0) {\n    cancelPendingFlush(scope);\n    return;\n  }\n\n  const pending = queue.slice();\n  queue.length = 0;\n\n  let requiresReschedule = false;\n\n  for (let index = 0; index < pending.length; index += 1) {\n    const entry = pending[index];\n    if (!entry || typeof entry !== 'object') {\n      continue;\n    }\n\n    const name = entry.name;\n    const api = entry.api;\n    const options = entry.options || {};\n\n    try {\n      registry.register(name, api, options);\n    } catch (error) {\n      // If the module fails to register, we log a warning and discard the pending entry.\n      // Retrying blindly causes infinite loops if the error is permanent (e.g. invalid name, conflict, etc).\n      if (typeof console !== 'undefined' && typeof console.warn === 'function') {\n        console.warn(`cineModules: discard pending registration for \"${name}\" due to error:`, error);\n      }\n      continue;\n    }\n  }\n\n  if (requiresReschedule || queue.length > 0) {\n    schedulePendingFlush(scope);\n  } else {\n    cancelPendingFlush(scope);\n  }\n}\n\nfunction collectQueueScopes(preferredScope) {\n  const scopes = [];\n\n  function pushScope(candidate) {\n    if (!candidate || (typeof candidate !== 'object' && typeof candidate !== 'function')) {\n      return;\n    }\n    if (scopes.indexOf(candidate) === -1) {\n      scopes.push(candidate);\n    }\n  }\n\n  pushScope(preferredScope);\n  pushScope(GLOBAL_SCOPE);\n  if (typeof globalThis !== 'undefined') pushScope(globalThis);\n  if (typeof window !== 'undefined') pushScope(window);\n  if (typeof self !== 'undefined') pushScope(self);\n  if (typeof global !== 'undefined') pushScope(global);\n\n  return scopes;\n}\n\nfunction readQueueFromScope(scope) {\n  if (!scope || (typeof scope !== 'object' && typeof scope !== 'function')) {\n    return null;\n  }\n\n  try {\n    const queue = scope[PENDING_QUEUE_KEY];\n    return Array.isArray(queue) ? queue : null;\n  } catch (error) {\n    void error;\n    return null;\n  }\n}\n\nfunction ensureQueueOnScope(scope) {\n  if (!scope || (typeof scope !== 'object' && typeof scope !== 'function')) {\n    return null;\n  }\n\n  let queue = readQueueFromScope(scope);\n  if (queue) {\n    return queue;\n  }\n\n  if (assignHidden(scope, PENDING_QUEUE_KEY, [])) {\n    queue = readQueueFromScope(scope);\n    if (queue) {\n      return queue;\n    }\n  }\n\n  try {\n    scope[PENDING_QUEUE_KEY] = [];\n    queue = readQueueFromScope(scope);\n    if (queue) {\n      return queue;\n    }\n  } catch (error) {\n    void error;\n  }\n\n  return null;\n}\n\nfunction resolveQueueDescriptor(preferredScope) {\n  const scopes = collectQueueScopes(preferredScope);\n\n  for (let index = 0; index < scopes.length; index += 1) {\n    const candidate = scopes[index];\n    const queue = ensureQueueOnScope(candidate);\n    if (queue) {\n      return { queue, scope: candidate };\n    }\n  }\n\n  return null;\n}\n\nfunction queueRegistrationPayload(scope, payload) {\n  const descriptor = resolveQueueDescriptor(scope || GLOBAL_SCOPE);\n  if (!descriptor || !descriptor.queue) {\n    return false;\n  }\n\n  const record = freezeDeep({\n    name: payload && payload.name ? normalizeName(payload.name) : null,\n    api: payload ? payload.api : null,\n    options: Object.freeze({ ...(payload && payload.options ? payload.options : {}) }),\n  });\n\n  const { queue, scope: queueScope } = descriptor;\n\n  try {\n    queue.push(record);\n  } catch (error) {\n    void error;\n    queue[queue.length] = record;\n  }\n\n  try {\n    schedulePendingFlush(queueScope);\n  } catch (error) {\n    void error;\n  }\n\n  return true;\n}\n\nfunction createBlueprint(options = {}) {\n  const normalizedName = normalizeName(options.name);\n  const normalizedCategory = typeof options.category === 'string' ? options.category.trim() : '';\n  if (!normalizedCategory) {\n    throw new TypeError(`cineModules.createBlueprint(\"${normalizedName}\") expected a non-empty category string.`);\n  }\n\n  const normalizedDescription = typeof options.description === 'string' ? options.description.trim() : '';\n  if (!normalizedDescription) {\n    throw new TypeError(`cineModules.createBlueprint(\"${normalizedName}\") expected a non-empty description.`);\n  }\n\n  const freezeByDefault = options.freeze !== false;\n  const normalizedConnections = freezeDeep(normalizeConnections(options.connections));\n\n  const factory = typeof options.factory === 'function' ? options.factory : null;\n  const staticApi = factory ? null : options.api;\n\n  if (!factory && (!staticApi || (typeof staticApi !== 'object' && typeof staticApi !== 'function'))) {\n    throw new TypeError(\n      `cineModules.createBlueprint(\"${normalizedName}\") expected an object API or factory function.`,\n    );\n  }\n\n  const metadata = Object.freeze({\n    name: normalizedName,\n    category: normalizedCategory,\n    description: normalizedDescription,\n    connections: normalizedConnections,\n    freeze: freezeByDefault,\n  });\n\n  let cachedApi = null;\n  let instantiated = false;\n  let instantiateError = null;\n\n  function buildRegistrationOptions(overrides) {\n    const base = {\n      category: metadata.category,\n      description: metadata.description,\n      connections: metadata.connections,\n      freeze: metadata.freeze,\n    };\n\n    if (!overrides || typeof overrides !== 'object') {\n      return Object.freeze({ ...base });\n    }\n\n    const normalized = { ...base };\n\n    if (Object.prototype.hasOwnProperty.call(overrides, 'category')) {\n      const candidate = typeof overrides.category === 'string' ? overrides.category.trim() : '';\n      if (candidate) {\n        normalized.category = candidate;\n      }\n    }\n\n    if (Object.prototype.hasOwnProperty.call(overrides, 'description')) {\n      const candidate = typeof overrides.description === 'string' ? overrides.description.trim() : '';\n      if (candidate) {\n        normalized.description = candidate;\n      }\n    }\n\n    if (Object.prototype.hasOwnProperty.call(overrides, 'connections')) {\n      normalized.connections = freezeDeep(normalizeConnections(overrides.connections));\n    }\n\n    if (Object.prototype.hasOwnProperty.call(overrides, 'freeze')) {\n      normalized.freeze = overrides.freeze !== false;\n    }\n\n    return Object.freeze(normalized);\n  }\n\n  function instantiate(context) {\n    if (instantiated) {\n      if (instantiateError) {\n        throw instantiateError;\n      }\n      return cachedApi;\n    }\n\n    instantiated = true;\n\n    let produced = staticApi;\n    if (factory) {\n      const invocationContext = context && typeof context === 'object' ? { ...context } : {};\n      const frozenContext = Object.freeze({\n        registry: registryReference || null,\n        metadata,\n        context: invocationContext,\n        freezeDeep,\n        normalizeConnections,\n      });\n\n      try {\n        produced = factory(frozenContext);\n      } catch (error) {\n        instantiateError = error instanceof Error ? error : new Error(String(error));\n        throw instantiateError;\n      }\n    }\n\n    if (!produced || (typeof produced !== 'object' && typeof produced !== 'function')) {\n      const error = new TypeError(\n        `cineModules.createBlueprint(\"${normalizedName}\") factory expected an object or function return value.`,\n      );\n      instantiateError = error;\n      throw error;\n    }\n\n    cachedApi = freezeByDefault && !Object.isFrozen(produced) ? freezeDeep(produced) : produced;\n    return cachedApi;\n  }\n\n  function registerBlueprint(options = {}) {\n    const resolvedRegistry =\n      options && typeof options.registry === 'object' && options.registry\n        ? options.registry\n        : registryReference;\n\n    const registrationOptions = buildRegistrationOptions(options && options.options);\n    const scope = options && options.scope ? options.scope : GLOBAL_SCOPE;\n    const deferOnError = options && Object.prototype.hasOwnProperty.call(options, 'defer') ? options.defer !== false : true;\n    const onError = options && typeof options.onError === 'function' ? options.onError : null;\n\n    const api = instantiate(options && options.context);\n\n    const targetRegistry =\n      resolvedRegistry && typeof resolvedRegistry.register === 'function' ? resolvedRegistry : registryReference;\n\n    if (!targetRegistry || typeof targetRegistry.register !== 'function') {\n      throw new TypeError('cineModules.createBlueprint register() requires a registry with a register() function.');\n    }\n\n    try {\n      return targetRegistry.register(metadata.name, api, registrationOptions);\n    } catch (error) {\n      if (deferOnError) {\n        queueRegistrationPayload(scope, {\n          name: metadata.name,\n          api,\n          options: registrationOptions,\n        });\n      }\n\n      if (onError) {\n        try {\n          onError(error);\n        } catch (handlerError) {\n          void handlerError;\n        }\n      }\n\n      throw error;\n    }\n  }\n\n  const blueprint = {\n    name: metadata.name,\n    category: metadata.category,\n    description: metadata.description,\n    connections: metadata.connections,\n    freeze: metadata.freeze,\n    instantiate,\n    register: registerBlueprint,\n    getMetadata() {\n      return metadata;\n    },\n    createRegistrationOptions: buildRegistrationOptions,\n    toJSON() {\n      return metadata;\n    },\n  };\n\n  return Object.freeze(blueprint);\n}\n\nconst registry = {};\nregistry.register = register;\nregistry.get = get;\nregistry.has = has;\nregistry.list = list;\nregistry.describe = describe;\nregistry.describeAll = describeAll;\nregistry.assertRegistered = assertRegistered;\nregistry.createBlueprint = createBlueprint;\nregistry.__internalResetForTests = resetForTests;\n\nregistryReference = registry;\n\nconst scopes = [GLOBAL_SCOPE];\nif (typeof globalThis !== 'undefined' && globalThis !== GLOBAL_SCOPE) scopes.push(globalThis);\nif (typeof window !== 'undefined' && scopes.indexOf(window) === -1) scopes.push(window);\nif (typeof self !== 'undefined' && scopes.indexOf(self) === -1) scopes.push(self);\nif (typeof global !== 'undefined' && scopes.indexOf(global) === -1) scopes.push(global);\n\nfor (let index = 0; index < scopes.length; index += 1) {\n  const scope = scopes[index];\n  if (!scope || typeof scope !== 'object') {\n    continue;\n  }\n\n  const existing = scope.cineModules;\n  if (existing !== registry) {\n    try {\n      Object.defineProperty(scope, 'cineModules', {\n        configurable: true,\n        enumerable: false,\n        value: registry,\n        writable: true,\n      });\n    } catch (error) {\n      void error;\n      try {\n        scope.cineModules = registry;\n      } catch (assignmentError) {\n        void assignmentError;\n      }\n    }\n  }\n\n  flushPendingRegistrations(scope);\n}\n\nexport default registry;\nexport const cineModules = registry;\n","function baseDetectGlobalScope() {\n  if (typeof globalThis !== 'undefined') {\n    return globalThis;\n  }\n  if (typeof window !== 'undefined') {\n    return window;\n  }\n  if (typeof self !== 'undefined') {\n    return self;\n  }\n  if (typeof global !== 'undefined') {\n    return global;\n  }\n  return {};\n}\n\nconst FALLBACK_SCOPE = baseDetectGlobalScope();\nconst DETECT_CACHE = { value: null, time: 0 };\n\nfunction safeAssign(target, key, value) {\n  if (!target || (typeof target !== 'object' && typeof target !== 'function')) {\n    return false;\n  }\n\n  try {\n    Object.defineProperty(target, key, {\n      configurable: true,\n      enumerable: false,\n      writable: true,\n      value,\n    });\n    return true;\n  } catch (defineError) {\n    void defineError;\n  }\n\n  try {\n    target[key] = value;\n    return true;\n  } catch (assignmentError) {\n    void assignmentError;\n  }\n\n  return false;\n}\n\nexport function detectGlobalScope() {\n  if (DETECT_CACHE.value && typeof DETECT_CACHE.value === 'object') {\n    return DETECT_CACHE.value;\n  }\n\n  try {\n    const detected = baseDetectGlobalScope();\n    if (detected && (typeof detected === 'object' || typeof detected === 'function')) {\n      DETECT_CACHE.value = detected;\n      DETECT_CACHE.time = Date.now();\n      return detected;\n    }\n  } catch (detectionError) {\n    void detectionError;\n  }\n\n  return FALLBACK_SCOPE;\n}\n\nexport function collectCandidateScopes(primary, extras, detect) {\n  const seen = [];\n  const append = (scope) => {\n    if (!scope || (typeof scope !== 'object' && typeof scope !== 'function')) {\n      return;\n    }\n    if (seen.indexOf(scope) === -1) {\n      seen.push(scope);\n    }\n  };\n\n  append(primary);\n\n  const detectFn = typeof detect === 'function' ? detect : detectGlobalScope;\n\n  try {\n    append(detectFn());\n  } catch (detectError) {\n    void detectError;\n  }\n\n  if (Array.isArray(extras)) {\n    for (let index = 0; index < extras.length; index += 1) {\n      append(extras[index]);\n    }\n  }\n\n  if (typeof globalThis !== 'undefined') append(globalThis);\n  if (typeof window !== 'undefined') append(window);\n  if (typeof self !== 'undefined') append(self);\n  if (typeof global !== 'undefined') append(global);\n\n  append(FALLBACK_SCOPE);\n\n  return seen.slice();\n}\n\nexport function tryRequire(modulePath) {\n  if (typeof require !== 'function') {\n    return null;\n  }\n\n  try {\n    return require(modulePath);\n  } catch (error) {\n    void error;\n    return null;\n  }\n}\n\nexport function resolveFromScopes(propertyName, options) {\n  const settings = options || {};\n  const predicate = typeof settings.predicate === 'function' ? settings.predicate : null;\n  const scoped = Array.isArray(settings.scopes) ? settings.scopes.slice() : [];\n  const candidates = collectCandidateScopes(\n    settings.primaryScope,\n    settings.additionalScopes,\n    settings.detect\n  );\n\n  for (let index = 0; index < candidates.length; index += 1) {\n    if (scoped.indexOf(candidates[index]) === -1) {\n      scoped.push(candidates[index]);\n    }\n  }\n\n  for (let index = 0; index < scoped.length; index += 1) {\n    const scope = scoped[index];\n    if (!scope || (typeof scope !== 'object' && typeof scope !== 'function')) {\n      continue;\n    }\n\n    if (predicate) {\n      try {\n        if (predicate(scope, propertyName)) {\n          return scope;\n        }\n      } catch (predicateError) {\n        void predicateError;\n      }\n    }\n\n    try {\n      if (propertyName in scope) {\n        return scope;\n      }\n    } catch (accessError) {\n      void accessError;\n    }\n  }\n\n  return null;\n}\n\nexport function getCachedGlobalValue(key, factory) {\n  if (!key) {\n    return typeof factory === 'function' ? factory() : factory;\n  }\n\n  const scope = detectGlobalScope();\n  if (scope && typeof scope === 'object') {\n    if (Object.prototype.hasOwnProperty.call(scope, key)) {\n      return scope[key];\n    }\n\n    const value = typeof factory === 'function' ? factory() : factory;\n    if (safeAssign(scope, key, value)) {\n      try {\n        return scope[key];\n      } catch (error) {\n        void error;\n      }\n    }\n    return value;\n  }\n\n  return typeof factory === 'function' ? factory() : factory;\n}\n\nconst api = {\n  baseDetectGlobalScope, // Exported as member of API object but generic\n  detectGlobalScope,\n  collectCandidateScopes,\n  tryRequire,\n  defineHiddenProperty: safeAssign,\n  resolveFromScopes,\n  getCachedGlobalValue,\n};\n\n// Global Assignment\nconst GLOBAL_SCOPE = detectGlobalScope();\n\nif (GLOBAL_SCOPE && !GLOBAL_SCOPE.cineScopeUtils) {\n  safeAssign(GLOBAL_SCOPE, 'cineScopeUtils', api);\n}\n\nexport {\n  baseDetectGlobalScope,\n  safeAssign as defineHiddenProperty,\n  api as cineScopeUtils\n};\n","const globalScope =\n    (typeof globalThis !== 'undefined' && globalThis) ||\n    (typeof window !== 'undefined' && window) ||\n    (typeof self !== 'undefined' && self) ||\n    (typeof global !== 'undefined' && global) ||\n    {};\n\n// Use a Set for O(1) lookups when validating video output types\nconst VIDEO_OUTPUT_TYPES = new Set([\n    '3G-SDI',\n    '6G-SDI',\n    '12G-SDI',\n    'Mini BNC',\n    'HDMI',\n    'Mini HDMI',\n    'Micro HDMI',\n    'DisplayPort'\n]);\n\nconst NORMALIZED_FLAG_KEY = '__normalized';\n\n/**\n * Memoize a normalisation function for repeated lookups.\n *\n * The provided function receives both the original trimmed string and a\n * lowercase key. Results are cached to avoid recomputing normalisations for\n * the same input.\n *\n * @param {(value: string, key: string) => string} fn - Function that performs\n *   normalisation.\n * @returns {(value: string) => string} Wrapped function with memoisation and\n *   empty-string fallback for falsy inputs.\n */\nfunction memoizeNormalization(fn) {\n    const cache = new Map();\n    return value => {\n        if (!value) return '';\n        const str = String(value)\n            .replace(/[]/g, '')\n            .trim();\n        const key = str.toLowerCase();\n        if (!cache.has(key)) cache.set(key, fn(str, key));\n        return cache.get(key);\n    };\n}\n\nconst VIDEO_TYPE_PATTERNS = [\n    { needles: ['12g'], value: '12G-SDI' },\n    { needles: ['6g'], value: '6G-SDI' },\n    { needles: ['3g'], value: '3G-SDI' },\n    // Accept both \"HD-SDI\" and \"HD SDI\" spellings\n    { needles: ['hd', 'sdi'], value: '3G-SDI' },\n    { needles: ['mini', 'bnc'], value: 'Mini BNC' },\n    { needles: ['micro', 'hdmi'], value: 'Micro HDMI' },\n    { needles: ['mini', 'hdmi'], value: 'Mini HDMI' },\n    { needles: ['hdmi'], value: 'HDMI' },\n    { needles: ['displayport'], value: 'DisplayPort' },\n    { needles: ['display', 'port'], value: 'DisplayPort' },\n    { needles: ['dp'], value: 'DisplayPort' }\n];\n\nconst normalizeVideoType = memoizeNormalization((_, key) => {\n    const match = VIDEO_TYPE_PATTERNS.find(({ needles }) =>\n        needles.every(n => key.includes(n))\n    );\n    return match ? match.value : '';\n});\n\nconst FIZ_CONNECTOR_MAP = {\n    'lemo 4-pin (lbus)': 'LBUS (LEMO 4-pin)',\n    'lbus (lemo 4-pin)': 'LBUS (LEMO 4-pin)',\n    'lbus (4-pin lemo)': 'LBUS (LEMO 4-pin)',\n    'lbus (4-pin lemo for motors)': 'LBUS (LEMO 4-pin)',\n    '4-pin lemo (lbus)': 'LBUS (LEMO 4-pin)',\n    'lemo 4-pin': 'LEMO 4-pin',\n    '4-pin lemo': 'LEMO 4-pin',\n    'lemo 7-pin': 'LEMO 7-pin',\n    'lemo 7-pin 1b': 'LEMO 7-pin',\n    '7-pin lemo': 'LEMO 7-pin',\n    '7-pin lemo (lcs)': 'LEMO 7-pin (LCS)',\n    '7-pin lemo (cam)': 'LEMO 7-pin (CAM)',\n    'ext (lemo 7-pin)': 'EXT LEMO 7-pin',\n    'hirose 12pin': 'Hirose 12-pin',\n    '12-pin hirose': 'Hirose 12-pin',\n    '12pin broadcast connector': 'Hirose 12-pin',\n    'lens 12 pin': 'Hirose 12-pin',\n    'lens terminal 12-pin': 'Hirose 12-pin',\n    'lens terminal 12-pin jack': 'Hirose 12-pin',\n    'lens terminal': 'Hirose 12-pin',\n    'usb type-c': 'USB-C',\n    'usb-c': 'USB-C',\n    'usb-c (usb 3.2 / 3.1 gen 1)': 'USB-C',\n    'usb-c / gigabit ethernet (via adapter)': 'USB-C',\n    'active ef mount': 'Active EF mount',\n    'lanc (2.5mm stereo mini jack)': 'LANC',\n    '2.5 mm sub-mini (lanc)': 'LANC',\n    'remote a (2.5mm)': 'REMOTE A connector',\n    'remote control terminal': 'REMOTE A connector',\n    'remote 8 pin': 'REMOTE B connector'\n};\n\nfunction createMapNormalizer(map) {\n    return memoizeNormalization((str, key) => map[key] || str);\n}\n\nconst normalizeFizConnectorType = createMapNormalizer(FIZ_CONNECTOR_MAP);\n\nconst VIEWFINDER_TYPE_MAP = {\n    'dsmc3 red touch 7\" lcd (optional)': 'RED Touch 7\" LCD (Optional)',\n    'red touch 7.0\" lcd (optional)': 'RED Touch 7\" LCD (Optional)',\n    'lcd touch panel': 'LCD touchscreen',\n    'lcd touchscreen': 'LCD touchscreen',\n    'native lcd capacitive touchscreen': 'LCD touchscreen',\n    'integrated touchscreen lcd': 'LCD touchscreen',\n    'free-angle lcd': 'Vari-angle LCD',\n    'lcd monitor (native)': 'Integrated LCD monitor',\n    'native lcd viewfinder': 'Integrated LCD monitor',\n    'lcd monitor lm-v2 (supplied)': 'LCD Monitor LM-V2',\n    'integrated main monitor': 'Integrated LCD monitor',\n    'optional evf-v70 viewfinder': 'EVF-V70 (Optional)',\n    'optional evf-v50': 'EVF-V50 (Optional)',\n    'optional oled viewfinder': 'OLED EVF (Optional)',\n    'blackmagic pocket cinema camera pro evf (optional)': 'Blackmagic Pro EVF (Optional)',\n    'external backlit lcd status display': 'LCD status display',\n    'built-in fold-out lcd': 'Fold-out LCD',\n    'oled lvf (live view finder)': 'OLED EVF',\n    'lcd capacitive touchscreen': 'LCD touchscreen',\n    'lemo 26 pin': 'LEMO 26-pin port'\n};\n\nconst normalizeViewfinderType = createMapNormalizer(VIEWFINDER_TYPE_MAP);\n\nconst POWER_PORT_TYPE_MAP = {\n    'lemo 8-pin (dc in / bat)': 'Bat LEMO 8-pin',\n    'lemo 8-pin (bat)': 'Bat LEMO 8-pin',\n    'bat (lemo 8-pin)': 'Bat LEMO 8-pin',\n    'lemo 8-pin': 'Bat LEMO 8-pin',\n    '2-pin dc-input': '2-pin DC-IN',\n    'dc-': 'DC IN',\n    'dc': 'DC IN',\n    '2-pin xlr': 'XLR 2-pin',\n    '2-pin locking connector': 'LEMO 2-pin',\n    '2-pin locking connector / 2-pin lemo': 'LEMO 2-pin',\n    '4-pin xlr / dc in 12v': 'XLR 4-pin',\n    '4-pin xlr / v-lock': 'XLR 4-pin',\n    'xlr 4-pin jack': 'XLR 4-pin',\n    'xlr 4-pin (main input)': 'XLR 4-pin',\n    'xlr-type 4 pin (male) / square-shaped 5 pin connector (battery)': 'XLR 4-pin / Square 5-pin',\n    '12-pin molex connector (at battery plate rear) / 4-pin xlr (external power)': 'Molex 12-pin / XLR 4-pin',\n    'battery slot': 'Battery Slot',\n    'usb-c': 'USB-C',\n    'usb type-c': 'USB-C',\n    'usb-c pd': 'USB-C PD',\n    'usb-c (power delivery)': 'USB-C PD',\n    'usb-c pd,dc coupler': 'USB-C PD / DC Coupler',\n    'dc coupler': 'DC Coupler',\n    'dc coupler (dr-e6c)': 'DC Coupler',\n    'dc input': 'DC IN',\n    'dc barrel': 'DC Barrel',\n    'dc (barrel)': 'DC Barrel',\n    'locking dc barrel': 'DC Barrel',\n    'dc 24v terminal': 'DC Barrel',\n    'weipu sf610/s2 (12vdc) input': 'Weipu SF610/S2',\n    '6-pin 1b dc-in / tb50 battery mount': '6-pin 1B DC-IN',\n    '6-pin 1b dc-,tb50': '6-pin 1B DC-IN'\n};\n\nconst mapPowerPortOne = createMapNormalizer(POWER_PORT_TYPE_MAP);\n\nfunction normalizePowerPortType(type) {\n    if (!type) return [];\n    const toArray = val => {\n        const normalized = mapPowerPortOne(val);\n        if (!normalized) return [];\n        return normalized\n            .split(/[/,]/)\n            .map(piece => mapPowerPortOne(piece.trim()))\n            .map(piece => (piece && piece.trim()) || '')\n            .filter(Boolean);\n    };\n    return Array.isArray(type) ? type.flatMap(toArray) : toArray(type);\n}\n\nfunction ensureList(list, defaults) {\n    if (!Array.isArray(list)) return [];\n    return list.map(item =>\n        typeof item === 'string'\n            ? { ...defaults, type: item }\n            : { ...defaults, ...(item || {}) }\n    );\n}\n\nfunction fixPowerInput(dev) {\n    if (!dev) return;\n    if (dev.powerInput && !dev.power?.input) {\n        dev.power = { ...(dev.power || {}), input: { type: normalizePowerPortType(dev.powerInput) } };\n        delete dev.powerInput;\n    }\n    const input = dev.power?.input;\n    if (!input) return;\n    const normalizeEntry = it => {\n        if (typeof it === 'string') {\n            return { type: normalizePowerPortType(it) };\n        }\n        if (it) {\n            const { portType: pType, type: tType, ...rest } = it;\n            const typeField = (!tType && pType) ? pType : tType;\n            return { ...rest, type: typeField ? normalizePowerPortType(typeField) : [] };\n        }\n        return { type: [] };\n    };\n    dev.power.input = Array.isArray(input) ? input.map(normalizeEntry) : normalizeEntry(input);\n}\n\nfunction applyFixPowerInput(collection) {\n    if (!collection || typeof collection !== 'object') return;\n    Object.values(collection).forEach(fixPowerInput);\n}\n\n\nfunction hasNormalizedDevicesMarker(bundle) {\n    return Boolean(\n        bundle &&\n        Object.prototype.hasOwnProperty.call(bundle, NORMALIZED_FLAG_KEY) &&\n        bundle[NORMALIZED_FLAG_KEY]\n    );\n}\n\nfunction markDevicesNormalized(bundle) {\n    if (!bundle || typeof bundle !== 'object') {\n        return bundle;\n    }\n    try {\n        Object.defineProperty(bundle, NORMALIZED_FLAG_KEY, {\n            configurable: true,\n            enumerable: false,\n            value: true,\n            writable: true\n        });\n    } catch (defineNormalizedError) {\n        void defineNormalizedError;\n        bundle[NORMALIZED_FLAG_KEY] = true;\n    }\n    return bundle;\n}\n\n\n// Normalize various camera properties so downstream logic works with\n// consistent structures and value formats.\nfunction unifyDevices(devicesData, options) {\n    if (!devicesData || typeof devicesData !== 'object') return devicesData;\n    const force = Boolean(options && options.force);\n    if (!force && hasNormalizedDevicesMarker(devicesData)) {\n        return devicesData;\n    }\n    Object.values(devicesData.cameras || {}).forEach(cam => {\n        if (cam.power?.input && cam.power.input.powerDrawWatts !== undefined) {\n            delete cam.power.input.powerDrawWatts;\n        }\n        fixPowerInput(cam);\n        if (Array.isArray(cam.power?.batteryPlateSupport)) {\n            cam.power.batteryPlateSupport = cam.power.batteryPlateSupport.map(it => {\n                if (typeof it === 'string') {\n                    const m = it.match(/([^()]+)(?:\\(([^)]+)\\))?(?:\\s*-\\s*(.*))?/);\n                    const type = m ? m[1].trim() : it;\n                    let mount = m && m[2] ? m[2].trim().toLowerCase() : '';\n                    if (!mount) {\n                        mount = /adapted|via adapter/i.test(it) ? 'adapted' : 'native';\n                    } else if (/via adapter/i.test(mount)) {\n                        mount = 'adapted';\n                    }\n                    const notes = m && m[3] ? m[3].trim() : (/via adapter/i.test(it) ? 'via adapter' : '');\n                    return { type, mount, notes };\n                }\n                return {\n                    type: it.type || '',\n                    mount: (it.mount ? it.mount : (it.native ? 'native' : (it.adapted ? 'adapted' : 'native'))).toLowerCase(),\n                    notes: it.notes || ''\n                };\n            });\n        }\n        if (cam.power) {\n            cam.power.powerDistributionOutputs = ensureList(cam.power.powerDistributionOutputs, {\n                type: '',\n                voltage: '',\n                current: '',\n                wattage: null,\n                notes: ''\n            });\n        }\n        cam.videoOutputs = ensureList(cam.videoOutputs, { type: '', notes: '' }).flatMap(vo => {\n            const { count, ...rest } = vo || {};\n            const norm = normalizeVideoType(rest.type);\n            if (!VIDEO_OUTPUT_TYPES.has(norm)) return [];\n            const parsedCount = parseInt(count, 10);\n            const num = Number.isFinite(parsedCount) && parsedCount > 0 ? parsedCount : 1;\n            const base = { ...rest, type: norm, notes: rest.notes || '' };\n            return Array.from({ length: num }, () => ({ ...base }));\n        });\n        cam.fizConnectors = ensureList(cam.fizConnectors, { type: '', notes: '' }).map(fc => {\n            const { type, ...rest } = fc || {};\n            return { ...rest, type: normalizeFizConnectorType(type) };\n        });\n        cam.viewfinder = ensureList(cam.viewfinder, { type: '', resolution: '', connector: '', notes: '' }).map(vf => {\n            const { type, ...rest } = vf || {};\n            return {\n                ...rest,\n                type: normalizeViewfinderType(type)\n            };\n        });\n        cam.recordingMedia = ensureList(cam.recordingMedia, { type: '', notes: '' }).map(m => {\n            let { type = '', notes = '' } = m || {};\n            const match = type.match(/^(.*?)(?:\\((.*)\\))?$/);\n            if (match) {\n                type = match[1].trim();\n                notes = notes || (match[2] ? match[2].trim() : '');\n            }\n            if (/^SD UHS-II$/i.test(type)) {\n                type = 'SD Card';\n                notes = notes ? `${notes}; UHS-II` : 'UHS-II';\n            } else if (/^SD \\(UHS-II\\/UHS-I\\)$/i.test(type)) {\n                type = 'SD Card';\n                notes = 'UHS-II/UHS-I';\n            } else if (type === 'CFast 2.0 card slots') {\n                type = 'CFast 2.0';\n                notes = notes || 'Dual Slots';\n            } else if (type === 'CFexpress Type B (Dual Slots)') {\n                type = 'CFexpress Type B';\n                notes = notes || 'Dual Slots';\n            } else if (type === 'CFexpress Type B (via adapter)') {\n                type = 'CFexpress Type B';\n                notes = notes || 'via adapter';\n            } else if (/^SD UHS-II \\(Dual Slots\\)$/i.test(type)) {\n                type = 'SD Card';\n                notes = notes ? `${notes}; UHS-II (Dual Slots)` : 'UHS-II (Dual Slots)';\n            } else if (type === 'SD Card (Dual Slots)') {\n                type = 'SD Card';\n                notes = notes || 'Dual Slots';\n            } else if (type === 'SD card slot (for proxy/backup)') {\n                type = 'SD Card';\n                notes = notes || 'for proxy/backup';\n            }\n            return { type, notes };\n        });\n        cam.timecode = ensureList(cam.timecode, { type: '', notes: '' });\n        cam.lensMount = ensureList(cam.lensMount, { type: '', mount: 'native', notes: '' })\n            .map(lm => ({\n                type: lm.type,\n                mount: (lm.mount ? lm.mount.toLowerCase() : 'native'),\n                notes: lm.notes || ''\n            }))\n            .filter((lm, idx, arr) =>\n                idx === arr.findIndex(o => o.type === lm.type && o.mount === lm.mount && o.notes === lm.notes)\n            );\n    });\n\n    Object.values(devicesData.lenses || {}).forEach(lens => {\n        if (!lens || typeof lens !== 'object') return;\n        const normalizeMountEntry = (entry) => {\n            if (!entry) return null;\n            if (typeof entry === 'string') {\n                const trimmed = entry.trim();\n                if (!trimmed) return null;\n                return { type: trimmed, mount: 'native' };\n            }\n            const type = typeof entry.type === 'string' ? entry.type.trim() : '';\n            if (!type) return null;\n            const status = typeof entry.mount === 'string' ? entry.mount.trim().toLowerCase() : '';\n            return { type, mount: status === 'adapted' ? 'adapted' : 'native' };\n        };\n\n        const existingMountOptions = lens.mountOptions;\n        const normalizedOptions = [];\n\n        const pushNormalizedEntry = (entry) => {\n            const normalized = normalizeMountEntry(entry);\n            if (normalized) {\n                normalizedOptions.push(normalized);\n            }\n        };\n\n        if (Array.isArray(existingMountOptions)) {\n            existingMountOptions.forEach(pushNormalizedEntry);\n        } else if (existingMountOptions && typeof existingMountOptions === 'object') {\n            pushNormalizedEntry(existingMountOptions);\n        }\n\n        if (!normalizedOptions.length && Array.isArray(lens.lensMount)) {\n            lens.lensMount.forEach(pushNormalizedEntry);\n            delete lens.lensMount;\n        }\n\n        if (!normalizedOptions.length) {\n            const mountType = typeof lens.mount === 'string' ? lens.mount.trim() : '';\n            if (mountType) {\n                pushNormalizedEntry({ type: mountType, mount: 'native' });\n            }\n        }\n\n        const dedupedOptions = [];\n        normalizedOptions.forEach(opt => {\n            if (!opt || !opt.type) return;\n            const mountState = opt.mount === 'adapted' ? 'adapted' : 'native';\n            const alreadyPresent = dedupedOptions.some(existing => (\n                existing.type === opt.type && existing.mount === mountState\n            ));\n            if (!alreadyPresent) {\n                dedupedOptions.push({ type: opt.type, mount: mountState });\n            }\n        });\n\n        const safeMountOptions = Array.isArray(dedupedOptions) ? dedupedOptions : [];\n        lens.mountOptions = safeMountOptions;\n\n        const mountOptions = Array.isArray(lens.mountOptions) ? lens.mountOptions : [];\n\n        if (mountOptions.length) {\n            const primary = mountOptions.find(opt => opt && opt.mount === 'native' && opt.type)\n                || mountOptions[0];\n            const primaryType = primary && primary.type ? primary.type : '';\n            if (primaryType) {\n                lens.mount = primaryType;\n            } else if (typeof lens.mount === 'string') {\n                lens.mount = lens.mount.trim();\n            }\n        } else if (typeof lens.mount === 'string') {\n            lens.mount = lens.mount.trim();\n            if (!lens.mount) {\n                delete lens.mount;\n            }\n        }\n    });\n\n    ['monitors', 'video', 'viewfinders'].forEach(key => {\n        applyFixPowerInput(devicesData[key]);\n    });\n\n    const fizGroups = devicesData.fiz || {};\n    ['motors', 'controllers', 'distance'].forEach(key => {\n        applyFixPowerInput(fizGroups[key]);\n    });\n\n    // Normalize FIZ motors\n    Object.values(devicesData.fiz?.motors || {}).forEach(m => {\n        if (!m) return;\n        if (m.connector && !m.fizConnector) {\n            m.fizConnector = m.connector;\n            delete m.connector;\n        }\n        if (m.fizConnector) {\n            m.fizConnector = normalizeFizConnectorType(m.fizConnector);\n        }\n    });\n\n    // Normalize FIZ controllers\n    Object.values(devicesData.fiz?.controllers || {}).forEach(c => {\n        if (!c) return;\n        if (c.FIZ_connector && !c.fizConnector && !c.fizConnectors) {\n            c.fizConnector = c.FIZ_connector;\n            delete c.FIZ_connector;\n        }\n        if (Array.isArray(c.fizConnectors)) {\n            c.fizConnectors = c.fizConnectors.map(fc => {\n                if (!fc) return { type: '' };\n                const type = normalizeFizConnectorType(fc.type || fc);\n                const notes = fc.notes || undefined;\n                return notes ? { type, notes } : { type };\n            });\n        } else if (c.fizConnector) {\n            const parts = String(c.fizConnector)\n                .split(',')\n                .map(s => s.trim())\n                .filter(Boolean);\n            c.fizConnectors = parts.map(p => ({ type: normalizeFizConnectorType(p) }));\n            delete c.fizConnector;\n        } else {\n            c.fizConnectors = [];\n        }\n    });\n\n    markDevicesNormalized(devicesData);\n    return devicesData;\n}\n\nfunction normalizeDevicesForPersistence(devicesData) {\n    return unifyDevices(devicesData, { force: true });\n}\n\n// Expose to global scope for legacy compatibility\nglobalScope.cineDeviceNormalization = {\n    unifyDevices,\n    normalizeDevicesForPersistence,\n    markDevicesNormalized,\n    hasNormalizedDevicesMarker,\n    fixPowerInput,\n    normalizeVideoType,\n    normalizeFizConnectorType,\n    normalizeViewfinderType,\n    normalizePowerPortType,\n    ensureList\n};\n\n// Expose individual functions for backward compatibility if needed\nglobalScope.unifyDevices = unifyDevices;\nglobalScope.normalizeDevicesForPersistence = normalizeDevicesForPersistence;\nglobalScope.markDevicesNormalized = markDevicesNormalized;\n\nexport const cineDeviceNormalization = globalScope.cineDeviceNormalization;\nexport {\n    unifyDevices,\n    normalizeDevicesForPersistence,\n    markDevicesNormalized,\n    hasNormalizedDevicesMarker,\n    fixPowerInput,\n    normalizeVideoType,\n    normalizeFizConnectorType,\n    normalizeViewfinderType,\n    normalizePowerPortType,\n    ensureList\n};\n","import cineModules from './registry.js';\n// (function () {\n\nfunction fallbackDetectGlobalScope() {\n  if (typeof globalThis !== 'undefined') {\n    return globalThis;\n  }\n  if (typeof window !== 'undefined') {\n    return window;\n  }\n  if (typeof self !== 'undefined') {\n    return self;\n  }\n  if (typeof global !== 'undefined') {\n    return global;\n  }\n  return {};\n}\n\nfunction fallbackCollectCandidateScopes(primary) {\n  const scopes = [];\n\n  function pushScope(scope) {\n    if (!scope || (typeof scope !== 'object' && typeof scope !== 'function')) {\n      return;\n    }\n    if (scopes.indexOf(scope) === -1) {\n      scopes.push(scope);\n    }\n  }\n\n  pushScope(primary);\n  if (typeof globalThis !== 'undefined') pushScope(globalThis);\n  if (typeof window !== 'undefined') pushScope(window);\n  if (typeof self !== 'undefined') pushScope(self);\n  if (typeof global !== 'undefined') pushScope(global);\n\n  return scopes;\n}\n\nfunction loggingResolveStructuredClone(scope) {\n  if (typeof structuredClone === 'function') {\n    return structuredClone;\n  }\n\n  if (scope && typeof scope.structuredClone === 'function') {\n    try {\n      return scope.structuredClone.bind(scope);\n    } catch (bindError) {\n      void bindError;\n    }\n  }\n\n  /* Node require removed for ESM conversion */\n\n  return null;\n}\n\nfunction loggingJsonDeepClone(value) {\n  if (value === null || typeof value !== 'object') {\n    return value;\n  }\n\n  try {\n    return JSON.parse(JSON.stringify(value));\n  } catch (jsonCloneError) {\n    void jsonCloneError;\n  }\n\n  return value;\n}\n\n/**\n * DEEP DIVE: Structured Clone Resolution\n *\n * Secure, deep copying of complex objects (Sets, Maps, etc.) is vital for logging\n * state without mutations affecting the live app.\n *\n * Strategy:\n * 1. Try Native `structuredClone`.\n * 2. Try Node.js `util.structuredClone` (if running in tests).\n * 3. Fallback to `JSON.parse(JSON.stringify(x))` (lossy but safe).\n *\n * This singleton pattern ensures we only pay the resolution cost once at startup.\n */\nconst LOGGING_DEEP_CLONE = (function resolveLoggingDeepClone() {\n  const scope = fallbackDetectGlobalScope();\n  if (scope && typeof scope.__cineDeepClone === 'function') {\n    return scope.__cineDeepClone;\n  }\n\n  const structuredCloneImpl = loggingResolveStructuredClone(scope);\n  if (!structuredCloneImpl) {\n    return loggingJsonDeepClone;\n  }\n\n  return function loggingResilientDeepClone(value) {\n    if (value === null || typeof value !== 'object') {\n      return value;\n    }\n\n    try {\n      return structuredCloneImpl(value);\n    } catch (structuredCloneError) {\n      void structuredCloneError;\n    }\n\n    return loggingJsonDeepClone(value);\n  };\n})();\n\nfunction fallbackLoadModuleEnvironment(scope) {\n  /* Require removed */\n\n  const candidates = fallbackCollectCandidateScopes(scope);\n\n  for (let index = 0; index < candidates.length; index += 1) {\n    const candidate = candidates[index];\n    if (candidate && typeof candidate.cineModuleEnvironment === 'object') {\n      return candidate.cineModuleEnvironment;\n    }\n  }\n\n  return null;\n}\n\nfunction fallbackLoadEnvironmentBridge(scope) {\n  /* Require removed */\n\n  const candidates = fallbackCollectCandidateScopes(scope);\n\n  for (let index = 0; index < candidates.length; index += 1) {\n    const candidate = candidates[index];\n    if (candidate && typeof candidate.cineEnvironmentBridge === 'object') {\n      return candidate.cineEnvironmentBridge;\n    }\n  }\n\n  return null;\n}\n\nfunction fallbackResolveModuleGlobals(scope) {\n  /* Require removed */\n\n  const candidates = fallbackCollectCandidateScopes(scope);\n\n  for (let index = 0; index < candidates.length; index += 1) {\n    const candidate = candidates[index];\n    if (candidate && typeof candidate.cineModuleGlobals === 'object') {\n      return candidate.cineModuleGlobals;\n    }\n  }\n\n  return null;\n}\n\nfunction fallbackTryRequire(modulePath) {\n  return null;\n}\n\nconst LOCAL_SCOPE = fallbackDetectGlobalScope();\nconst MODULE_ENV = fallbackLoadModuleEnvironment(LOCAL_SCOPE);\nconst ENV_BRIDGE = fallbackLoadEnvironmentBridge(LOCAL_SCOPE);\nconst MODULE_GLOBALS = fallbackResolveModuleGlobals(LOCAL_SCOPE);\nconst GLOBAL_SCOPE =\n  (ENV_BRIDGE && typeof ENV_BRIDGE.getGlobalScope === 'function'\n    ? ENV_BRIDGE.getGlobalScope()\n    : null)\n  || (MODULE_ENV && typeof MODULE_ENV.getGlobalScope === 'function'\n    ? MODULE_ENV.getGlobalScope()\n    : null)\n  || LOCAL_SCOPE;\n\nconst tryRequire = (function resolveTryRequire() {\n  if (MODULE_GLOBALS && typeof MODULE_GLOBALS.tryRequire === 'function') {\n    return MODULE_GLOBALS.tryRequire;\n  }\n\n  if (ENV_BRIDGE && typeof ENV_BRIDGE.tryRequire === 'function') {\n    return function bridgeTryRequire(modulePath) {\n      const result = ENV_BRIDGE.tryRequire(modulePath);\n      return typeof result === 'undefined' ? fallbackTryRequire(modulePath) : result;\n    };\n  }\n\n  if (MODULE_ENV && typeof MODULE_ENV.tryRequire === 'function') {\n    return MODULE_ENV.tryRequire;\n  }\n\n  return fallbackTryRequire;\n})();\n\nconst structuredCloneCandidates = (function collectStructuredCloneCandidates() {\n  const candidates = [];\n\n  function addCandidate(fn, scope) {\n    if (typeof fn !== 'function') {\n      return;\n    }\n    const alreadyPresent = candidates.some(candidate => candidate && candidate.fn === fn);\n    if (!alreadyPresent) {\n      candidates.push({ fn, scope: scope || null });\n    }\n  }\n\n  if (MODULE_GLOBALS) {\n    if (typeof MODULE_GLOBALS.structuredClone === 'function') {\n      addCandidate(MODULE_GLOBALS.structuredClone, MODULE_GLOBALS);\n    }\n    if (typeof MODULE_GLOBALS.getStructuredClone === 'function') {\n      try {\n        const resolved = MODULE_GLOBALS.getStructuredClone();\n        addCandidate(resolved, MODULE_GLOBALS);\n      } catch (error) {\n        void error;\n      }\n    }\n  }\n\n  if (ENV_BRIDGE) {\n    if (typeof ENV_BRIDGE.structuredClone === 'function') {\n      addCandidate(ENV_BRIDGE.structuredClone, ENV_BRIDGE);\n    }\n    if (typeof ENV_BRIDGE.getStructuredClone === 'function') {\n      try {\n        const resolved = ENV_BRIDGE.getStructuredClone();\n        addCandidate(resolved, ENV_BRIDGE);\n      } catch (error) {\n        void error;\n      }\n    }\n  }\n\n  if (MODULE_ENV) {\n    if (typeof MODULE_ENV.structuredClone === 'function') {\n      addCandidate(MODULE_ENV.structuredClone, MODULE_ENV);\n    }\n    if (typeof MODULE_ENV.getStructuredClone === 'function') {\n      try {\n        const resolved = MODULE_ENV.getStructuredClone();\n        addCandidate(resolved, MODULE_ENV);\n      } catch (error) {\n        void error;\n      }\n    }\n  }\n\n  const scopes = fallbackCollectCandidateScopes(GLOBAL_SCOPE);\n  for (let index = 0; index < scopes.length; index += 1) {\n    const scope = scopes[index];\n    if (!scope || (typeof scope !== 'object' && typeof scope !== 'function')) {\n      continue;\n    }\n    const candidate = scope.structuredClone;\n    if (typeof candidate === 'function') {\n      addCandidate(candidate, scope);\n    }\n  }\n\n  return candidates;\n})();\n\nlet cachedStructuredCloneCandidate = null;\n\nfunction tryStructuredCloneValue(value) {\n  if (cachedStructuredCloneCandidate) {\n    try {\n      const candidate = cachedStructuredCloneCandidate;\n      return {\n        success: true,\n        value: candidate.scope ? candidate.fn.call(candidate.scope, value) : candidate.fn(value),\n      };\n    } catch (error) {\n      void error;\n      cachedStructuredCloneCandidate = null;\n    }\n  }\n\n  for (let index = 0; index < structuredCloneCandidates.length; index += 1) {\n    const candidate = structuredCloneCandidates[index];\n    if (!candidate || typeof candidate.fn !== 'function') {\n      continue;\n    }\n    try {\n      const cloned = candidate.scope ? candidate.fn.call(candidate.scope, value) : candidate.fn(value);\n      cachedStructuredCloneCandidate = candidate;\n      return { success: true, value: cloned };\n    } catch (error) {\n      void error;\n    }\n  }\n\n  return { success: false, value: null };\n}\n\nfunction resolveModuleRegistry(scope) {\n  if (MODULE_GLOBALS && typeof MODULE_GLOBALS.resolveModuleRegistry === 'function') {\n    try {\n      const resolved = MODULE_GLOBALS.resolveModuleRegistry(scope || GLOBAL_SCOPE);\n      if (resolved) {\n        return resolved;\n      }\n    } catch (error) {\n      void error;\n    }\n  }\n\n  if (ENV_BRIDGE && typeof ENV_BRIDGE.getModuleRegistry === 'function') {\n    try {\n      const bridged = ENV_BRIDGE.getModuleRegistry(scope || GLOBAL_SCOPE);\n      if (bridged) {\n        return bridged;\n      }\n    } catch (error) {\n      void error;\n    }\n  }\n\n  if (MODULE_ENV && typeof MODULE_ENV.resolveModuleRegistry === 'function') {\n    try {\n      return MODULE_ENV.resolveModuleRegistry(scope || GLOBAL_SCOPE);\n    } catch (error) {\n      void error;\n    }\n  }\n\n  // Use imported cineModules if available\n  if (cineModules && typeof cineModules === 'object') {\n    return cineModules;\n  }\n\n  const scopes = fallbackCollectCandidateScopes(scope || GLOBAL_SCOPE);\n\n  for (let index = 0; index < scopes.length; index += 1) {\n    const candidate = scopes[index];\n    if (candidate && typeof candidate.cineModules === 'object') {\n      return candidate.cineModules;\n    }\n  }\n\n  return null;\n}\n\nconst MODULE_REGISTRY = (function resolveRegistry() {\n  if (MODULE_GLOBALS && typeof MODULE_GLOBALS.getModuleRegistry === 'function') {\n    try {\n      const shared = MODULE_GLOBALS.getModuleRegistry(GLOBAL_SCOPE);\n      if (shared) {\n        return shared;\n      }\n    } catch (error) {\n      void error;\n    }\n  }\n\n  if (ENV_BRIDGE && typeof ENV_BRIDGE.getModuleRegistry === 'function') {\n    try {\n      const bridged = ENV_BRIDGE.getModuleRegistry(GLOBAL_SCOPE);\n      if (bridged) {\n        return bridged;\n      }\n    } catch (error) {\n      void error;\n    }\n  }\n\n  if (MODULE_ENV && typeof MODULE_ENV.getModuleRegistry === 'function') {\n    try {\n      const provided = MODULE_ENV.getModuleRegistry(GLOBAL_SCOPE);\n      if (provided) {\n        return provided;\n      }\n    } catch (error) {\n      void error;\n    }\n  }\n\n  return resolveModuleRegistry();\n})();\n\nconst queueModuleRegistration = (function resolveQueueModuleRegistration() {\n  if (MODULE_GLOBALS && typeof MODULE_GLOBALS.queueModuleRegistration === 'function') {\n    return function queueModuleRegistration(name, api, options, scope) {\n      try {\n        return MODULE_GLOBALS.queueModuleRegistration(name, api, options, scope || GLOBAL_SCOPE);\n      } catch (error) {\n        void error;\n        return false;\n      }\n    };\n  }\n\n  if (ENV_BRIDGE && typeof ENV_BRIDGE.queueModuleRegistration === 'function') {\n    return function bridgeQueueModuleRegistration(name, api, options) {\n      try {\n        const bridged = ENV_BRIDGE.queueModuleRegistration(name, api, options);\n        return typeof bridged === 'undefined' ? false : bridged;\n      } catch (error) {\n        void error;\n        return false;\n      }\n    };\n  }\n\n  if (MODULE_ENV && typeof MODULE_ENV.queueModuleRegistration === 'function') {\n    return function envQueueModuleRegistration(name, api, options, scope) {\n      try {\n        return MODULE_ENV.queueModuleRegistration(name, api, options, scope || GLOBAL_SCOPE);\n      } catch (error) {\n        void error;\n        return false;\n      }\n    };\n  }\n\n  return function fallbackQueueModuleRegistration() {\n    return false;\n  };\n})();\n\nconst registerOrQueueModule = (function resolveRegisterOrQueue() {\n  if (MODULE_GLOBALS && typeof MODULE_GLOBALS.registerOrQueueModule === 'function') {\n    return function registerOrQueueModule(name, api, options, onError, scope, registry) {\n      try {\n        const registered = MODULE_GLOBALS.registerOrQueueModule(\n          name,\n          api,\n          options,\n          onError,\n          scope || GLOBAL_SCOPE,\n          registry || MODULE_REGISTRY,\n        );\n        return typeof registered === 'undefined' ? false : registered;\n      } catch (error) {\n        void error;\n        return false;\n      }\n    };\n  }\n\n  if (ENV_BRIDGE && typeof ENV_BRIDGE.registerOrQueueModule === 'function') {\n    return function bridgeRegisterOrQueueModule(name, api, options, onError, scope, registry) {\n      try {\n        const bridged = ENV_BRIDGE.registerOrQueueModule(\n          name,\n          api,\n          options,\n          onError,\n          scope || GLOBAL_SCOPE,\n          registry || MODULE_REGISTRY,\n        );\n        return typeof bridged === 'undefined' ? false : bridged;\n      } catch (error) {\n        void error;\n        return false;\n      }\n    };\n  }\n\n  if (MODULE_ENV && typeof MODULE_ENV.registerOrQueueModule === 'function') {\n    return function envRegisterOrQueueModule(name, api, options, onError, scope, registry) {\n      try {\n        return MODULE_ENV.registerOrQueueModule(\n          name,\n          api,\n          options,\n          onError,\n          scope || GLOBAL_SCOPE,\n          registry || MODULE_REGISTRY,\n        );\n      } catch (error) {\n        void error;\n        return false;\n      }\n    };\n  }\n\n  return function fallbackRegisterOrQueueModule(name, api, options, onError) {\n    if (typeof onError === 'function') {\n      try {\n        // Attempt global registry fallback\n        if (typeof window !== 'undefined' && window.cineModuleRegistry && typeof window.cineModuleRegistry.register === 'function') {\n          window.cineModuleRegistry.register(name, api, options);\n          return true;\n        }\n        // Instead of throwing (\"onError(new Error...\"), just warn to console.\n        // Identify that we are in a fallback state but don't crash.\n        console.warn('Logging module registration deferred - queue unavailable.');\n      } catch (error) {\n        void error;\n      }\n    }\n    void name;\n    void api;\n    void options;\n    return false;\n  };\n})();\n\n\n\nfunction isNodeProcessReference(value) {\n  if (!value) {\n    return false;\n  }\n\n  if (typeof process === 'undefined' || !process) {\n    return false;\n  }\n\n  if (value === process) {\n    return true;\n  }\n\n  if (typeof value === 'object') {\n    try {\n      if (value.constructor && value.constructor.name === 'process') {\n        return true;\n      }\n    } catch (processInspectionError) {\n      void processInspectionError;\n    }\n\n    if (\n      typeof value.pid === 'number' &&\n      typeof value.nextTick === 'function' &&\n      typeof value.emit === 'function' &&\n      typeof value.binding === 'function'\n    ) {\n      return true;\n    }\n  }\n\n  if (typeof value === 'function') {\n    if (\n      value === process.binding ||\n      value === process._linkedBinding ||\n      value === process.dlopen\n    ) {\n      return true;\n    }\n\n    try {\n      const functionName = value.name || '';\n      if (functionName && (functionName === 'binding' || functionName === 'dlopen')) {\n        const source = Function.prototype.toString.call(value);\n        if (source && source.indexOf('[native code]') !== -1) {\n          return true;\n        }\n      }\n    } catch (functionInspectionError) {\n      void functionInspectionError;\n    }\n  }\n\n  return false;\n}\n\nfunction shouldBypassDeepFreeze(value) {\n  if (!value || typeof value !== 'object') {\n    return true;\n  }\n\n  if (isNodeProcessReference(value)) {\n    return true;\n  }\n\n  if (\n    typeof process !== 'undefined' &&\n    process &&\n    process.release &&\n    process.release.name === 'node'\n  ) {\n    return true;\n  }\n\n\n  const ctor = value.constructor;\n  if (!ctor) {\n    return false;\n  }\n\n  if (\n    ctor === Number\n    || ctor === String\n    || ctor === Boolean\n    || ctor === Date\n    || ctor === RegExp\n    || ctor === Promise\n    || ctor === WeakMap\n    || ctor === WeakSet\n    || ctor === Map\n    || ctor === Set\n  ) {\n    return true;\n  }\n\n  const ctorName = typeof ctor.name === 'string' ? ctor.name : '';\n  if (ctorName && /Error|Event|Response|Request|Headers|Node|Element|Window|Document/.test(ctorName)) {\n    return true;\n  }\n\n  try {\n    if (typeof value.then === 'function' || typeof value.catch === 'function') {\n      return true;\n    }\n    if (typeof value.pipe === 'function' || typeof value.on === 'function') {\n      return true;\n    }\n    if (typeof value.write === 'function' || typeof value.read === 'function') {\n      return true;\n    }\n    if (typeof value.getReader === 'function' || typeof value.getWriter === 'function') {\n      return true;\n    }\n    if (typeof value[Symbol.iterator] === 'function' && !Array.isArray(value)) {\n      return true;\n    }\n    if (typeof Symbol !== 'undefined' && value[Symbol.toStringTag]) {\n      const tag = value[Symbol.toStringTag];\n      if (typeof tag === 'string' && /Stream|Port|Process/.test(tag)) {\n        return true;\n      }\n    }\n  } catch (inspectionError) {\n    void inspectionError;\n  }\n\n  return false;\n}\n\nfunction fallbackFreezeDeep(value, seen) {\n  const visited = seen || (typeof WeakSet === 'function' ? new WeakSet() : {\n    add() { },\n    has() {\n      return false;\n    },\n  });\n\n  if (!value || typeof value !== 'object') {\n    return value;\n  }\n\n  if (shouldBypassDeepFreeze(value)) {\n    return value;\n  }\n\n  if (typeof process !== 'undefined' && process && process.env && process.env.JEST_WORKER_ID) {\n    try {\n      if (typeof Object.freeze === 'function') {\n        Object.freeze(value);\n      }\n    } catch (freezeError) {\n      void freezeError;\n    }\n    return value;\n  }\n\n  if (typeof visited.has === 'function' && visited.has(value)) {\n    return value;\n  }\n\n  if (typeof visited.add === 'function') {\n    visited.add(value);\n  }\n\n  const keys = Object.getOwnPropertyNames(value);\n  for (let index = 0; index < keys.length; index += 1) {\n    const key = keys[index];\n    let child;\n    try {\n      child = value[key];\n    } catch (accessError) {\n      void accessError;\n      child = undefined;\n    }\n    if (!child || typeof child === 'function' || (typeof child !== 'object' && typeof child !== 'function')) {\n      continue;\n    }\n    fallbackFreezeDeep(child, visited);\n  }\n\n  try {\n    try {\n      return Object.freeze(value);\n    } catch (freezeError) {\n      void freezeError;\n      return value;\n    }\n  } catch (freezeError) {\n    void freezeError;\n    return value;\n  }\n}\n\nconst freezeDeep = (function resolveFreezeDeep() {\n  if (MODULE_GLOBALS && typeof MODULE_GLOBALS.freezeDeep === 'function') {\n    return MODULE_GLOBALS.freezeDeep;\n  }\n\n  if (ENV_BRIDGE && typeof ENV_BRIDGE.freezeDeep === 'function') {\n    return function bridgeFreezeDeep(value, seen) {\n      try {\n        return ENV_BRIDGE.freezeDeep(value, seen);\n      } catch (error) {\n        void error;\n        return fallbackFreezeDeep(value, seen);\n      }\n    };\n  }\n\n  if (MODULE_ENV && typeof MODULE_ENV.freezeDeep === 'function') {\n    return MODULE_ENV.freezeDeep;\n  }\n\n  return fallbackFreezeDeep;\n})();\n\nfunction fallbackSafeWarn(message, detail) {\n  if (typeof console === 'undefined' || typeof console.warn !== 'function') {\n    return;\n  }\n\n  try {\n    if (typeof detail === 'undefined') {\n      console.warn(message);\n    } else {\n      console.warn(message, detail);\n    }\n  } catch (error) {\n    void error;\n  }\n}\n\nconst safeWarn = (function resolveSafeWarn() {\n  if (MODULE_GLOBALS && typeof MODULE_GLOBALS.safeWarn === 'function') {\n    return MODULE_GLOBALS.safeWarn;\n  }\n\n  if (ENV_BRIDGE && typeof ENV_BRIDGE.safeWarn === 'function') {\n    return function bridgeSafeWarn(message, detail) {\n      try {\n        ENV_BRIDGE.safeWarn(message, detail);\n      } catch (error) {\n        void error;\n        fallbackSafeWarn(message, detail);\n      }\n    };\n  }\n\n  if (MODULE_ENV && typeof MODULE_ENV.safeWarn === 'function') {\n    return MODULE_ENV.safeWarn;\n  }\n\n  return fallbackSafeWarn;\n})();\n\nconst CONSOLE_METHODS = ['debug', 'info', 'warn', 'error', 'log'];\nconst CONSOLE_PROXY_FLAG = typeof Symbol === 'function'\n  ? Symbol.for('cineLoggingConsoleProxyInstalled')\n  : '__cineLoggingConsoleProxyInstalled__';\n\n/**\n * DEEP DIVE: Console Proxying\n *\n * Why do we proxy `console` methods?\n * 1. Centralized Control: Users can \"silence\" logs via settings without code changes.\n * 2. Log Levels: We implement standard levels (DEBUG, INFO, WARN, ERROR) over the raw console.\n * 3. Remote Telemetry (Future): Allows hooking into logs to send them to a server/service.\n *\n * Safety First: We capture the *original* console functions first so we never create infinite loops.\n */\nconst ORIGINAL_CONSOLE_FUNCTIONS = (function captureOriginalConsoleFunctions() {\n  const store = Object.create(null);\n  if (typeof console === 'undefined' || !console) {\n    return store;\n  }\n\n  for (let index = 0; index < CONSOLE_METHODS.length; index += 1) {\n    const method = CONSOLE_METHODS[index];\n    try {\n      const fn = console[method];\n      store[method] = typeof fn === 'function' ? fn : null;\n    } catch (error) {\n      store[method] = null;\n      void error;\n    }\n  }\n\n  return store;\n})();\n\nlet consoleProxyInstalled = false;\nlet consoleProxyInstallationAttempted = false;\nlet consoleProxyInstallationFailed = false;\nlet lastConsoleCaptureState = null;\nlet consoleProxyWarningIssued = false;\nlet consoleProxyGuardDepth = 0;\n\nconst exposeGlobal = (function resolveExposeGlobal() {\n  if (MODULE_GLOBALS && typeof MODULE_GLOBALS.exposeGlobal === 'function') {\n    return function exposeGlobal(name, value, options) {\n      try {\n        return MODULE_GLOBALS.exposeGlobal(name, value, options);\n      } catch (error) {\n        void error;\n        return false;\n      }\n    };\n  }\n\n  return function fallbackExposeGlobal(name, value) {\n    if (!GLOBAL_SCOPE || (typeof GLOBAL_SCOPE !== 'object' && typeof GLOBAL_SCOPE !== 'function')) {\n      return false;\n    }\n    try {\n      GLOBAL_SCOPE[name] = value;\n      return true;\n    } catch (error) {\n      void error;\n      return false;\n    }\n  };\n})();\n\nfunction informModuleGlobals(name, api) {\n  if (!MODULE_GLOBALS || typeof MODULE_GLOBALS.recordModule !== 'function') {\n    return;\n  }\n\n  try {\n    MODULE_GLOBALS.recordModule(name, api);\n  } catch (error) {\n    void error;\n  }\n}\n\nconst LOG_LEVEL_MAP = {\n  debug: { priority: 10, consoleMethod: 'debug' },\n  info: { priority: 20, consoleMethod: 'info' },\n  warn: { priority: 30, consoleMethod: 'warn' },\n  error: { priority: 40, consoleMethod: 'error' },\n};\n\nconst LOG_LEVELS = freezeDeep(LOG_LEVEL_MAP);\n\nconst LEVEL_COUNTER_KEYS = Object.freeze(Object.keys(LOG_LEVEL_MAP).concat(['other']));\n\nfunction createLevelCounters() {\n  const counters = Object.create(null);\n  for (let index = 0; index < LEVEL_COUNTER_KEYS.length; index += 1) {\n    const key = LEVEL_COUNTER_KEYS[index];\n    counters[key] = 0;\n  }\n  return counters;\n}\n\nfunction resetLevelCounters(counters) {\n  if (!counters || typeof counters !== 'object') {\n    return;\n  }\n\n  for (let index = 0; index < LEVEL_COUNTER_KEYS.length; index += 1) {\n    const key = LEVEL_COUNTER_KEYS[index];\n    counters[key] = 0;\n  }\n}\n\nfunction resolveLevelKey(level) {\n  if (typeof level === 'string' && level) {\n    if (Object.prototype.hasOwnProperty.call(LOG_LEVEL_MAP, level)) {\n      return level;\n    }\n    const trimmed = level.trim().toLowerCase();\n    if (Object.prototype.hasOwnProperty.call(LOG_LEVEL_MAP, trimmed)) {\n      return trimmed;\n    }\n  }\n  return 'other';\n}\n\nfunction getCounterValue(counters, key) {\n  if (!counters || typeof counters !== 'object') {\n    return 0;\n  }\n\n  const value = counters[key];\n  return typeof value === 'number' && Number.isFinite(value) && value > 0 ? value : 0;\n}\n\nfunction applyLevelCounterDelta(counters, level, delta) {\n  if (!counters || typeof counters !== 'object') {\n    return;\n  }\n\n  if (typeof delta !== 'number' || !Number.isFinite(delta) || delta === 0) {\n    return;\n  }\n\n  const key = resolveLevelKey(level);\n  const current = getCounterValue(counters, key);\n  const next = current + delta;\n  counters[key] = next > 0 ? next : 0;\n}\n\nfunction applyLevelCounterDeltaForEntries(counters, entries, delta) {\n  if (!Array.isArray(entries) || !entries.length) {\n    return;\n  }\n\n  if (typeof delta !== 'number' || !Number.isFinite(delta) || delta === 0) {\n    return;\n  }\n\n  for (let index = 0; index < entries.length; index += 1) {\n    const entry = entries[index];\n    const level = entry && entry.level;\n    applyLevelCounterDelta(counters, level, delta);\n  }\n}\n\nfunction summariseEntriesByLevel(entries) {\n  const summary = createLevelCounters();\n  applyLevelCounterDeltaForEntries(summary, entries, 1);\n  return summary;\n}\n\nfunction accumulateLevelSummary(target, summary) {\n  if (!target || typeof target !== 'object' || !summary || typeof summary !== 'object') {\n    return;\n  }\n\n  for (let index = 0; index < LEVEL_COUNTER_KEYS.length; index += 1) {\n    const key = LEVEL_COUNTER_KEYS[index];\n    const increment = getCounterValue(summary, key);\n    if (increment) {\n      const current = getCounterValue(target, key);\n      target[key] = current + increment;\n    }\n  }\n}\n\nfunction cloneLevelSummary(summary) {\n  const clone = createLevelCounters();\n  accumulateLevelSummary(clone, summary);\n  return clone;\n}\n\nfunction freezeLevelSummary(summary) {\n  return freezeDeep(cloneLevelSummary(summary));\n}\n\nconst HISTORY_MIN_LIMIT = 50;\nconst HISTORY_ABSOLUTE_MIN_LIMIT = 1;\nconst HISTORY_MAX_LIMIT = 5000;\nconst HISTORY_STORAGE_KEY = '__cineLoggingHistory';\nconst CONFIG_STORAGE_KEY = '__cineLoggingConfig';\nconst ERROR_EVENT_FLAG =\n  typeof Symbol === 'function' ? Symbol.for('cineLoggingHandled') : '__cineLoggingHandled__';\nconst DEFAULT_CONFIG_VALUES = {\n  level: 'warn',\n  historyLevel: 'info',\n  historyLimit: 1200,\n  consoleOutput: true,\n  persistSession: true,\n  captureGlobalErrors: true,\n  captureConsole: false,\n  stackTraces: true,\n};\n\nconst DEFAULT_CONFIG = freezeDeep(DEFAULT_CONFIG_VALUES);\n\nconst SERVICE_WORKER_LOG_CHANNEL = 'cine-sw-logs';\nconst SERVICE_WORKER_LOG_ENTRY_TYPE = 'cine-sw:log-entry';\nconst SERVICE_WORKER_LOG_STATE_REQUEST = 'cine-sw:log-state-request';\nconst SERVICE_WORKER_LOG_STATE_RESPONSE = 'cine-sw:log-state';\nconst SERVICE_WORKER_LOG_REQUEST_TIMEOUT = 5000;\nconst SERVICE_WORKER_LOG_POLL_INTERVAL = 60 * 1000;\nconst SERVICE_WORKER_LOG_HISTORY_LIMIT = 200;\n\nfunction cloneDefaultConfig() {\n  return {\n    level: DEFAULT_CONFIG_VALUES.level,\n    historyLevel: DEFAULT_CONFIG_VALUES.historyLevel,\n    historyLimit: DEFAULT_CONFIG_VALUES.historyLimit,\n    consoleOutput: DEFAULT_CONFIG_VALUES.consoleOutput,\n    persistSession: DEFAULT_CONFIG_VALUES.persistSession,\n    captureGlobalErrors: DEFAULT_CONFIG_VALUES.captureGlobalErrors,\n    captureConsole: DEFAULT_CONFIG_VALUES.captureConsole,\n    stackTraces: DEFAULT_CONFIG_VALUES.stackTraces,\n  };\n}\n\nlet activeConfig = cloneDefaultConfig();\nconst logHistory = [];\nconst logSubscribers = new Set();\nconst configSubscribers = new Set();\nconst attachedErrorTargets = typeof WeakSet === 'function' ? new WeakSet() : [];\nlet runtimeEntryCount = 0;\nconst emittedLevelCounters = createLevelCounters();\nconst retainedLevelCounters = createLevelCounters();\nconst droppedLevelCounters = createLevelCounters();\nlet totalEntriesDropped = 0;\nlet lastHistoryDrop = null;\nconst serviceWorkerBridgeState = {\n  initialised: false,\n  supported: false,\n  requestInFlight: false,\n  lastRequestId: null,\n  pollTimer: null,\n  requestTimer: null,\n  broadcastChannel: null,\n  broadcastFailed: false,\n  seenIds: typeof Set === 'function' ? new Set() : null,\n  fallbackSeenIds: typeof Set !== 'function' ? [] : null,\n  lastSnapshotMeta: null,\n};\n\nfunction normalizeLevel(value, fallbackLevel) {\n  const fallback = typeof fallbackLevel === 'string' ? fallbackLevel : activeConfig.level;\n\n  if (typeof value === 'string') {\n    const trimmed = value.trim().toLowerCase();\n    if (Object.prototype.hasOwnProperty.call(LOG_LEVEL_MAP, trimmed)) {\n      return trimmed;\n    }\n    if (trimmed === 'log' || trimmed === 'information') {\n      return 'info';\n    }\n    if (trimmed === 'warning') {\n      return 'warn';\n    }\n    if (trimmed === 'trace' || trimmed === 'verbose') {\n      return 'debug';\n    }\n    if (trimmed === 'fatal' || trimmed === 'critical') {\n      return 'error';\n    }\n  }\n\n  if (Object.prototype.hasOwnProperty.call(LOG_LEVEL_MAP, fallback)) {\n    return fallback;\n  }\n\n  return 'info';\n}\n\nfunction getLevelPriority(level) {\n  const normalized = normalizeLevel(level, 'info');\n  const descriptor = LOG_LEVEL_MAP[normalized];\n  return descriptor ? descriptor.priority : LOG_LEVEL_MAP.info.priority;\n}\n\nfunction booleanFromValue(value, fallback) {\n  if (typeof value === 'boolean') {\n    return value;\n  }\n  if (typeof value === 'number') {\n    if (!Number.isFinite(value)) {\n      return Boolean(fallback);\n    }\n    if (value === 1) {\n      return true;\n    }\n    if (value === 0) {\n      return false;\n    }\n    return value > 0;\n  }\n  if (typeof value === 'string') {\n    const normalized = value.trim().toLowerCase();\n    if (normalized === 'true' || normalized === '1' || normalized === 'yes' || normalized === 'on') {\n      return true;\n    }\n    if (normalized === 'false' || normalized === '0' || normalized === 'no' || normalized === 'off') {\n      return false;\n    }\n  }\n  return typeof fallback === 'boolean' ? fallback : false;\n}\n\nfunction clampHistoryLimit(value, options) {\n  const allowReducedMinimum =\n    options && options.allowReducedMin === true ? true : false;\n  const effectiveMinimum = allowReducedMinimum ? HISTORY_ABSOLUTE_MIN_LIMIT : HISTORY_MIN_LIMIT;\n\n  if (typeof value === 'number' && Number.isFinite(value)) {\n    const absolute = Math.abs(Math.floor(value));\n    if (!absolute) {\n      return activeConfig.historyLimit;\n    }\n    return Math.max(effectiveMinimum, Math.min(HISTORY_MAX_LIMIT, absolute));\n  }\n\n  if (typeof value === 'string' && value) {\n    const parsed = Number(value);\n    if (Number.isFinite(parsed)) {\n      return clampHistoryLimit(parsed, options);\n    }\n  }\n\n  return activeConfig.historyLimit;\n}\n\nfunction coerceMessage(value) {\n  if (typeof value === 'string') {\n    return value;\n  }\n  if (value instanceof Error) {\n    return value.message || value.name || 'Error';\n  }\n  if (value && typeof value === 'object') {\n    if (typeof value.message === 'string') {\n      return value.message;\n    }\n    const ctorName = value.constructor && value.constructor.name;\n    if (ctorName) {\n      return ctorName;\n    }\n  }\n  if (typeof value === 'number' || typeof value === 'boolean') {\n    return String(value);\n  }\n  if (typeof value === 'undefined' || value === null) {\n    return '';\n  }\n  try {\n    return String(value);\n  } catch (error) {\n    void error;\n  }\n  return Object.prototype.toString.call(value);\n}\n\nfunction sanitizeForLog(value, depth, seen) {\n  const nextDepth = typeof depth === 'number' ? depth : 0;\n  const visited = seen || (typeof WeakSet === 'function' ? new WeakSet() : null);\n\n  if (value === null || typeof value === 'undefined') {\n    return null;\n  }\n\n  const valueType = typeof value;\n\n  if (valueType === 'string' || valueType === 'number' || valueType === 'boolean') {\n    return value;\n  }\n\n  if (valueType === 'bigint') {\n    try {\n      return value.toString();\n    } catch (error) {\n      void error;\n      return 'BigInt';\n    }\n  }\n\n  if (valueType === 'symbol') {\n    try {\n      return value.toString();\n    } catch (error) {\n      void error;\n      return 'Symbol';\n    }\n  }\n\n  if (valueType === 'function') {\n    const name = value.name ? ` ${value.name}` : '';\n    return `[Function${name}]`;\n  }\n\n  if (value instanceof Date) {\n    try {\n      return value.toISOString();\n    } catch (error) {\n      void error;\n      return value.toString();\n    }\n  }\n\n  if (typeof RegExp !== 'undefined' && value instanceof RegExp) {\n    try {\n      return value.toString();\n    } catch (error) {\n      void error;\n    }\n    return '[RegExp]';\n  }\n\n  if (value instanceof Error) {\n    const errorOutput = {\n      name: value.name,\n      message: value.message,\n    };\n    if (value.stack) {\n      errorOutput.stack = String(value.stack);\n    }\n    if (typeof value.code !== 'undefined') {\n      errorOutput.code = value.code;\n    }\n    if (typeof value.status !== 'undefined') {\n      errorOutput.status = value.status;\n    }\n    if (typeof value.cause !== 'undefined' && value.cause !== null) {\n      errorOutput.cause = sanitizeForLog(value.cause, nextDepth + 1, visited);\n    }\n    if (typeof value.details !== 'undefined') {\n      errorOutput.details = sanitizeForLog(value.details, nextDepth + 1, visited);\n    }\n    if (typeof value.errors !== 'undefined' && value.errors !== null) {\n      const collectedErrors = [];\n      const maxErrors = 10;\n      let truncatedErrors = 0;\n\n      const appendErrorDetail = function appendErrorDetail(candidate) {\n        if (collectedErrors.length >= maxErrors) {\n          truncatedErrors += 1;\n          return;\n        }\n        try {\n          collectedErrors.push(sanitizeForLog(candidate, nextDepth + 1, visited));\n        } catch (error) {\n          collectedErrors.push(\n            error && error.message ? `[Unserializable error: ${error.message}]` : '[Unserializable error]'\n          );\n        }\n      };\n\n      const rawErrors = value.errors;\n      if (Array.isArray(rawErrors)) {\n        for (let index = 0; index < rawErrors.length; index += 1) {\n          appendErrorDetail(rawErrors[index]);\n        }\n        if (rawErrors.length > collectedErrors.length) {\n          truncatedErrors += rawErrors.length - collectedErrors.length;\n        }\n      } else if (rawErrors && typeof rawErrors === 'object') {\n        let iterator = null;\n        try {\n          const symbolIterator = typeof Symbol === 'function' ? Symbol.iterator : null;\n          if (symbolIterator && typeof rawErrors[symbolIterator] === 'function') {\n            iterator = rawErrors[symbolIterator].call(rawErrors);\n          }\n        } catch (iteratorError) {\n          iterator = null;\n          void iteratorError;\n        }\n\n        if (iterator && typeof iterator.next === 'function') {\n          let result = iterator.next();\n          let count = 0;\n          while (!result.done) {\n            if (count < maxErrors) {\n              appendErrorDetail(result.value);\n            } else {\n              truncatedErrors += 1;\n            }\n            count += 1;\n            try {\n              result = iterator.next();\n            } catch (iterationError) {\n              truncatedErrors += 1;\n              void iterationError;\n              break;\n            }\n          }\n        } else {\n          appendErrorDetail(rawErrors);\n        }\n      } else {\n        appendErrorDetail(rawErrors);\n      }\n\n      if (collectedErrors.length) {\n        errorOutput.errors = collectedErrors;\n        if (truncatedErrors > 0) {\n          errorOutput.errorsTruncated = truncatedErrors;\n        }\n      }\n    }\n    return errorOutput;\n  }\n\n  if (valueType === 'object') {\n    if (visited) {\n      try {\n        if (visited.has(value)) {\n          return '[Circular]';\n        }\n        visited.add(value);\n      } catch (error) {\n        void error;\n      }\n    }\n\n    if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n      return {\n        __type: 'ArrayBuffer',\n        byteLength: value.byteLength,\n      };\n    }\n\n    if (typeof DataView !== 'undefined' && value instanceof DataView) {\n      return {\n        __type: 'DataView',\n        byteOffset: value.byteOffset,\n        byteLength: value.byteLength,\n      };\n    }\n\n    if (\n      typeof ArrayBuffer !== 'undefined'\n      && typeof ArrayBuffer.isView === 'function'\n      && ArrayBuffer.isView(value)\n    ) {\n      const ctorName = value.constructor && value.constructor.name;\n      const maxPreview = 32;\n      const length = typeof value.length === 'number' ? value.length : 0;\n      const preview = [];\n      const previewLength = Math.min(length, maxPreview);\n      for (let index = 0; index < previewLength; index += 1) {\n        preview.push(value[index]);\n      }\n      const summary = {\n        __type: ctorName || 'TypedArray',\n        length,\n        byteOffset: typeof value.byteOffset === 'number' ? value.byteOffset : 0,\n        byteLength: typeof value.byteLength === 'number' ? value.byteLength : 0,\n      };\n      if (preview.length) {\n        summary.preview = preview;\n      }\n      if (length > maxPreview) {\n        summary.__truncatedItems = length - maxPreview;\n      }\n      return summary;\n    }\n\n    const mapCtor = typeof Map === 'function' ? Map : null;\n    if (mapCtor && value instanceof mapCtor) {\n      const entries = [];\n      const maxEntries = 30;\n      let index = 0;\n      value.forEach((mapValue, mapKey) => {\n        if (index < maxEntries) {\n          entries.push({\n            key: sanitizeForLog(mapKey, nextDepth + 1, visited),\n            value: sanitizeForLog(mapValue, nextDepth + 1, visited),\n          });\n        }\n        index += 1;\n      });\n      const result = {\n        __type: 'Map',\n        size: typeof value.size === 'number' ? value.size : index,\n        entries,\n      };\n      if (index > maxEntries) {\n        result.__truncatedEntries = index - maxEntries;\n      }\n      return result;\n    }\n\n    const setCtor = typeof Set === 'function' ? Set : null;\n    if (setCtor && value instanceof setCtor) {\n      const items = [];\n      const maxItems = 30;\n      let index = 0;\n      value.forEach(item => {\n        if (index < maxItems) {\n          items.push(sanitizeForLog(item, nextDepth + 1, visited));\n        }\n        index += 1;\n      });\n      const result = {\n        __type: 'Set',\n        size: typeof value.size === 'number' ? value.size : index,\n        values: items,\n      };\n      if (index > maxItems) {\n        result.__truncatedValues = index - maxItems;\n      }\n      return result;\n    }\n\n    const urlParamsCtor = typeof URLSearchParams === 'function' ? URLSearchParams : null;\n    if (urlParamsCtor && value instanceof urlParamsCtor) {\n      const params = [];\n      const iterator = typeof value.entries === 'function' ? value.entries() : null;\n      let truncated = 0;\n      if (iterator && typeof iterator.next === 'function') {\n        const maxPairs = 40;\n        let count = 0;\n        let next = iterator.next();\n        while (!next.done) {\n          if (count < maxPairs) {\n            const pair = next.value || [];\n            params.push({\n              key: sanitizeForLog(pair[0], nextDepth + 1, visited),\n              value: sanitizeForLog(pair[1], nextDepth + 1, visited),\n            });\n          }\n          count += 1;\n          next = iterator.next();\n        }\n        if (count > params.length) {\n          truncated = count - params.length;\n        }\n      }\n      const result = {\n        __type: 'URLSearchParams',\n        entries: params,\n      };\n      if (truncated > 0) {\n        result.__truncatedEntries = truncated;\n      }\n      return result;\n    }\n\n    if (typeof URL === 'function' && value instanceof URL) {\n      try {\n        return value.toString();\n      } catch (error) {\n        void error;\n      }\n    }\n\n    if (nextDepth >= 4) {\n      const ctorName = value.constructor && value.constructor.name;\n      return ctorName ? `[${ctorName}]` : Object.prototype.toString.call(value);\n    }\n\n    if (Array.isArray(value)) {\n      const maxItems = 20;\n      const result = [];\n      const len = Math.min(value.length, maxItems);\n      for (let index = 0; index < len; index += 1) {\n        result.push(sanitizeForLog(value[index], nextDepth + 1, visited));\n      }\n      if (value.length > maxItems) {\n        result.push(` (${value.length - maxItems} more)`);\n      }\n      return result;\n    }\n\n    const output = {};\n    const keys = Object.keys(value);\n    const maxKeys = 30;\n    const length = Math.min(keys.length, maxKeys);\n    for (let index = 0; index < length; index += 1) {\n      const key = keys[index];\n      try {\n        output[key] = sanitizeForLog(value[key], nextDepth + 1, visited);\n      } catch (error) {\n        output[key] = `[Threw: ${error && error.message ? error.message : 'error'}]`;\n      }\n    }\n    if (keys.length > maxKeys) {\n      output.__truncatedKeys = keys.length - maxKeys;\n    }\n\n    if (typeof Object.getOwnPropertySymbols === 'function') {\n      const symbols = Object.getOwnPropertySymbols(value);\n      const symbolLength = Math.min(symbols.length, 5);\n      for (let index = 0; index < symbolLength; index += 1) {\n        const symbolKey = symbols[index];\n        const symbolName = typeof symbolKey === 'symbol' ? symbolKey.toString() : String(symbolKey);\n        try {\n          output[symbolName] = sanitizeForLog(value[symbolKey], nextDepth + 1, visited);\n        } catch (error) {\n          output[symbolName] = `[Threw: ${error && error.message ? error.message : 'error'}]`;\n        }\n      }\n    }\n\n    if (!keys.length) {\n      const ctorName = value.constructor && value.constructor.name;\n      if (ctorName) {\n        output.__className = ctorName;\n      }\n    }\n\n    return output;\n  }\n\n  const structuredCloneResult = tryStructuredCloneValue(value);\n  if (structuredCloneResult.success) {\n    return structuredCloneResult.value;\n  }\n\n  try {\n    return LOGGING_DEEP_CLONE(value);\n  } catch (error) {\n    void error;\n  }\n\n  try {\n    return String(value);\n  } catch (stringifyError) {\n    void stringifyError;\n  }\n\n  return null;\n}\n\nfunction normaliseStackTrace(stackValue) {\n  if (typeof stackValue !== 'string') {\n    return null;\n  }\n\n  const trimmed = stackValue.replace(/\\r\\n?/g, '\\n').trim();\n  if (!trimmed) {\n    return null;\n  }\n\n  const maxLength = 5000;\n  const charTruncated = trimmed.length > maxLength;\n  const limitedStack = charTruncated ? trimmed.slice(0, maxLength) : trimmed;\n\n  const rawLines = trimmed.split('\\n');\n  const frameLimit = 40;\n  const frames = [];\n  let frameTruncated = false;\n  for (let index = 0; index < rawLines.length; index += 1) {\n    const line = rawLines[index].trim();\n    if (!line) {\n      continue;\n    }\n    if (frames.length < frameLimit) {\n      frames.push(line.length > 500 ? `${line.slice(0, 500)}\\u2026` : line);\n    } else {\n      frameTruncated = true;\n      break;\n    }\n  }\n\n  return {\n    stack: limitedStack,\n    frames,\n    truncated: charTruncated || frameTruncated,\n  };\n}\n\nfunction normaliseOriginSnapshot(origin) {\n  if (!origin || typeof origin !== 'object') {\n    return null;\n  }\n\n  const source = typeof origin.source === 'string' && origin.source\n    ? origin.source\n    : 'unknown';\n\n  let stackSummary = null;\n  if (typeof origin.stack === 'string' && origin.stack) {\n    stackSummary = normaliseStackTrace(origin.stack);\n  }\n\n  const frames = [];\n  if (Array.isArray(origin.frames)) {\n    for (let index = 0; index < origin.frames.length && frames.length < 40; index += 1) {\n      const frame = origin.frames[index];\n      if (typeof frame === 'string' && frame) {\n        frames.push(frame);\n      } else if (frame !== null && typeof frame !== 'undefined') {\n        frames.push(coerceMessage(frame));\n      }\n    }\n  } else if (stackSummary && Array.isArray(stackSummary.frames)) {\n    for (let index = 0; index < stackSummary.frames.length; index += 1) {\n      frames.push(stackSummary.frames[index]);\n    }\n  }\n\n  const truncated = origin.truncated === true\n    || (stackSummary ? stackSummary.truncated === true : false)\n    || (frames.length > 0 && frames.length >= 40);\n\n  const snapshot = {\n    source,\n    truncated,\n  };\n\n  if (stackSummary && stackSummary.stack) {\n    snapshot.stack = stackSummary.stack;\n  } else if (typeof origin.stack === 'string' && origin.stack) {\n    snapshot.stack = origin.stack;\n  } else {\n    snapshot.stack = null;\n  }\n\n  if (frames.length) {\n    snapshot.frames = frames;\n  }\n\n  if (!snapshot.stack && (!snapshot.frames || !snapshot.frames.length)) {\n    return null;\n  }\n\n  return freezeDeep(snapshot);\n}\n\nfunction getSessionStorage() {\n  const scopes = fallbackCollectCandidateScopes(GLOBAL_SCOPE);\n  for (let index = 0; index < scopes.length; index += 1) {\n    const scope = scopes[index];\n    if (!scope || (typeof scope !== 'object' && typeof scope !== 'function')) {\n      continue;\n    }\n    try {\n      const storage = scope.sessionStorage;\n      if (storage && typeof storage.getItem === 'function' && typeof storage.setItem === 'function') {\n        return storage;\n      }\n    } catch (error) {\n      void error;\n    }\n  }\n  return null;\n}\n\nfunction clearStoredHistory() {\n  const storage = getSessionStorage();\n  if (!storage) {\n    return;\n  }\n  try {\n    storage.removeItem(HISTORY_STORAGE_KEY);\n  } catch (error) {\n    void error;\n  }\n}\n\nfunction persistConfigSafe() {\n  const storage = getSessionStorage();\n  if (!storage) {\n    return;\n  }\n\n  if (!activeConfig.persistSession) {\n    try {\n      storage.removeItem(CONFIG_STORAGE_KEY);\n    } catch (error) {\n      void error;\n    }\n    return;\n  }\n\n  try {\n    storage.setItem(\n      CONFIG_STORAGE_KEY,\n      JSON.stringify({\n        level: activeConfig.level,\n        historyLevel: activeConfig.historyLevel,\n        historyLimit: activeConfig.historyLimit,\n        consoleOutput: activeConfig.consoleOutput,\n        persistSession: activeConfig.persistSession,\n        captureGlobalErrors: activeConfig.captureGlobalErrors,\n        captureConsole: activeConfig.captureConsole,\n        stackTraces: activeConfig.stackTraces,\n      }),\n    );\n  } catch (error) {\n    console.warn('cineLogging: Unable to persist logging config', error);\n  }\n}\n\nfunction persistHistorySafe() {\n  if (!activeConfig.persistSession) {\n    clearStoredHistory();\n    return;\n  }\n\n  const storage = getSessionStorage();\n  if (!storage) {\n    return;\n  }\n\n  try {\n    storage.setItem(HISTORY_STORAGE_KEY, JSON.stringify(logHistory));\n  } catch (error) {\n    if (error && (error.name === 'QuotaExceededError' || error.name === 'NS_ERROR_DOM_QUOTA_REACHED')) {\n      // Disable persistence for this session to prevent loop\n      activeConfig.persistSession = false;\n      try {\n        storage.removeItem(HISTORY_STORAGE_KEY);\n      } catch (e) { void e; }\n      // Do NOT log a warning here, as it might trigger the proxy and cause a loop\n      return;\n    }\n    console.warn('cineLogging: Unable to persist log history', error);\n  }\n}\n\nfunction getEffectiveHistoryLimit() {\n  const effectiveMinimum = activeConfig.persistSession === false\n    ? HISTORY_ABSOLUTE_MIN_LIMIT\n    : HISTORY_MIN_LIMIT;\n\n  return Math.max(\n    effectiveMinimum,\n    Math.min(HISTORY_MAX_LIMIT, Math.floor(activeConfig.historyLimit)),\n  );\n}\n\nfunction recordHistoryDrop(removedEntries, limit, options) {\n  if (!Array.isArray(removedEntries) || removedEntries.length === 0) {\n    return null;\n  }\n\n  totalEntriesDropped += removedEntries.length;\n  const removedSummary = summariseEntriesByLevel(removedEntries);\n\n  const source = options && typeof options.source === 'string' && options.source.trim()\n    ? options.source.trim()\n    : 'enforce';\n\n  const oldestEntry = removedEntries[0] || null;\n  const newestEntry = removedEntries[removedEntries.length - 1] || null;\n\n  const dropTimestamp = Date.now();\n  let dropIsoTimestamp = '';\n  try {\n    dropIsoTimestamp = new Date(dropTimestamp).toISOString();\n  } catch (error) {\n    void error;\n    dropIsoTimestamp = String(dropTimestamp);\n  }\n\n  lastHistoryDrop = freezeDeep({\n    count: removedEntries.length,\n    limit,\n    source,\n    timestamp: dropTimestamp,\n    isoTimestamp: dropIsoTimestamp,\n    oldestEntryId:\n      oldestEntry && typeof oldestEntry.id === 'string' ? oldestEntry.id : null,\n    oldestEntryTimestamp:\n      oldestEntry && typeof oldestEntry.timestamp === 'number'\n        ? oldestEntry.timestamp\n        : null,\n    oldestEntryIsoTimestamp:\n      oldestEntry && typeof oldestEntry.isoTimestamp === 'string'\n        ? oldestEntry.isoTimestamp\n        : null,\n    newestEntryId:\n      newestEntry && typeof newestEntry.id === 'string' ? newestEntry.id : null,\n    newestEntryTimestamp:\n      newestEntry && typeof newestEntry.timestamp === 'number'\n        ? newestEntry.timestamp\n        : null,\n    newestEntryIsoTimestamp:\n      newestEntry && typeof newestEntry.isoTimestamp === 'string'\n        ? newestEntry.isoTimestamp\n        : null,\n    levels: freezeLevelSummary(removedSummary),\n  });\n\n  if (ORIGINAL_CONSOLE_FUNCTIONS && typeof ORIGINAL_CONSOLE_FUNCTIONS.warn === 'function') {\n    try {\n      ORIGINAL_CONSOLE_FUNCTIONS.warn('cineLogging: history trimmed to enforce retention limit', {\n        limit,\n        removed: removedEntries.length,\n        source,\n        levels: cloneLevelSummary(removedSummary),\n      });\n    } catch (warnError) {\n      void warnError;\n    }\n  } else {\n    // Fallback if original console is somehow missing or we are in a weird state\n    // We purposefully avoid safeWarn here to prevent recursion\n    try {\n      if (typeof console !== 'undefined' && typeof console.warn === 'function') {\n        // If console.warn IS the proxy, we can't easily detect it without checking equality to the proxy function\n        // But avoiding safeWarn wrapper helps if safeWarn adds extra logic. \n        // Ideally we just stop if we can't find the original.\n      }\n    } catch (e) { void e; }\n  }\n\n  return removedSummary;\n}\n\nfunction enforceHistoryLimit(options) {\n  const limit = getEffectiveHistoryLimit();\n  if (logHistory.length <= limit) {\n    return 0;\n  }\n\n  const overflow = logHistory.length - limit;\n  const removedEntries = logHistory.splice(0, overflow);\n  applyLevelCounterDeltaForEntries(retainedLevelCounters, removedEntries, -1);\n  const removedSummary = recordHistoryDrop(removedEntries, limit, options);\n  if (removedSummary) {\n    accumulateLevelSummary(droppedLevelCounters, removedSummary);\n  }\n  return overflow;\n}\n\nfunction shouldRecord(level) {\n  return getLevelPriority(level) >= getLevelPriority(activeConfig.historyLevel);\n}\n\nfunction shouldOutputToConsole(level) {\n  if (!activeConfig.consoleOutput) {\n    return false;\n  }\n  return getLevelPriority(level) >= getLevelPriority(activeConfig.level);\n}\n\nfunction getLevelState(level) {\n  const normalizedLevel = normalizeLevel(level, 'info');\n  const consoleEnabled = shouldOutputToConsole(normalizedLevel);\n  const historyEnabled = shouldRecord(normalizedLevel);\n\n  return freezeDeep({\n    level: normalizedLevel,\n    enabled: consoleEnabled || historyEnabled,\n    console: consoleEnabled,\n    history: historyEnabled,\n    thresholds: freezeDeep({\n      console: normalizeLevel(activeConfig.level, DEFAULT_CONFIG_VALUES.level),\n      history: normalizeLevel(activeConfig.historyLevel, DEFAULT_CONFIG_VALUES.historyLevel),\n    }),\n  });\n}\n\nfunction isLevelEnabled(level, options) {\n  const state = getLevelState(level);\n\n  if (!options || typeof options !== 'object') {\n    return state.enabled;\n  }\n\n  const checkConsole = options.console !== false;\n  const checkHistory = options.history !== false;\n\n  if (!checkConsole && !checkHistory) {\n    return false;\n  }\n\n  if (options.requireAll === true) {\n    if (checkConsole && !state.console) {\n      return false;\n    }\n    if (checkHistory && !state.history) {\n      return false;\n    }\n    return true;\n  }\n\n  if (checkConsole && state.console) {\n    return true;\n  }\n\n  if (checkHistory && state.history) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction createEntryId(timestamp) {\n  return `log-${timestamp}-${Math.random().toString(36).slice(2, 10)}`;\n}\n\nfunction pushEntryToHistory(entry) {\n  if (!entry) {\n    return;\n  }\n\n  try {\n    logHistory.push(entry);\n  } catch (pushError) {\n    // If the history array is somehow frozen or non-extensible, we silently drop the entry\n    // to avoid crashing the entire application.\n    void pushError;\n    return;\n  }\n  applyLevelCounterDelta(retainedLevelCounters, entry.level, 1);\n}\n\nfunction appendEntry(entry) {\n  pushEntryToHistory(entry);\n  runtimeEntryCount += 1;\n  enforceHistoryLimit({ source: 'append' });\n  persistHistorySafe();\n  notifyLogSubscribers(entry);\n}\n\nfunction notifyLogSubscribers(entry) {\n  if (!logSubscribers.size) {\n    return;\n  }\n  const listeners = Array.from(logSubscribers);\n  for (let index = 0; index < listeners.length; index += 1) {\n    const listener = listeners[index];\n    if (typeof listener !== 'function') {\n      continue;\n    }\n    try {\n      listener(entry);\n    } catch (error) {\n      safeWarn('cineLogging listener execution failed', error);\n    }\n  }\n}\n\nfunction getHistorySnapshot(limit) {\n  const effectiveLimit = typeof limit === 'number' && Number.isFinite(limit)\n    ? Math.max(0, Math.floor(limit))\n    : logHistory.length;\n  if (!effectiveLimit) {\n    return Object.freeze([]);\n  }\n  const start = Math.max(0, logHistory.length - effectiveLimit);\n  const slice = logHistory.slice(start);\n  return Object.freeze(slice.slice());\n}\n\nfunction notifyConfigSubscribers(snapshot) {\n  if (!configSubscribers.size) {\n    return;\n  }\n  const listeners = Array.from(configSubscribers);\n  for (let index = 0; index < listeners.length; index += 1) {\n    const listener = listeners[index];\n    if (typeof listener !== 'function') {\n      continue;\n    }\n    try {\n      listener(snapshot);\n    } catch (error) {\n      safeWarn('cineLogging config listener failed', error);\n    }\n  }\n}\n\nfunction arrayFromArrayLike(value) {\n  if (!value || typeof value.length !== 'number') {\n    return [];\n  }\n\n  const length = value.length;\n  const result = new Array(length);\n  for (let index = 0; index < length; index += 1) {\n    result[index] = value[index];\n  }\n\n  return result;\n}\n\nfunction safeArrayPush(target, value) {\n  if (!Array.isArray(target)) {\n    return false;\n  }\n  try {\n    if (typeof Object.isExtensible === 'function' && !Object.isExtensible(target)) {\n      return false;\n    }\n    target.push(value);\n    return true;\n  } catch (error) {\n    void error;\n  }\n  return false;\n}\n\nfunction getConsoleLevelForMethod(method) {\n  if (method === 'error') {\n    return 'error';\n  }\n  if (method === 'warn') {\n    return 'warn';\n  }\n  if (method === 'info') {\n    return 'info';\n  }\n  return 'debug';\n}\n\nfunction getStoredConsoleFunction(method) {\n  if (typeof method !== 'string' || !method) {\n    return null;\n  }\n\n  if (Object.prototype.hasOwnProperty.call(ORIGINAL_CONSOLE_FUNCTIONS, method)) {\n    const stored = ORIGINAL_CONSOLE_FUNCTIONS[method];\n    if (typeof stored === 'function') {\n      return stored;\n    }\n  }\n\n  if (typeof console !== 'undefined' && console) {\n    let candidate = null;\n    try {\n      candidate = console[method];\n    } catch (error) {\n      candidate = null;\n      void error;\n    }\n    if (typeof candidate === 'function' && (!candidate || !candidate[CONSOLE_PROXY_FLAG])) {\n      return candidate;\n    }\n  }\n\n  if ((method === 'debug' || method === 'log') && typeof ORIGINAL_CONSOLE_FUNCTIONS.log === 'function') {\n    return ORIGINAL_CONSOLE_FUNCTIONS.log;\n  }\n\n  if (method === 'info') {\n    if (typeof ORIGINAL_CONSOLE_FUNCTIONS.info === 'function') {\n      return ORIGINAL_CONSOLE_FUNCTIONS.info;\n    }\n    if (typeof ORIGINAL_CONSOLE_FUNCTIONS.log === 'function') {\n      return ORIGINAL_CONSOLE_FUNCTIONS.log;\n    }\n  }\n\n  if (method === 'warn') {\n    if (typeof ORIGINAL_CONSOLE_FUNCTIONS.warn === 'function') {\n      return ORIGINAL_CONSOLE_FUNCTIONS.warn;\n    }\n    if (typeof ORIGINAL_CONSOLE_FUNCTIONS.error === 'function') {\n      return ORIGINAL_CONSOLE_FUNCTIONS.error;\n    }\n  }\n\n  if (method === 'error' && typeof ORIGINAL_CONSOLE_FUNCTIONS.error === 'function') {\n    return ORIGINAL_CONSOLE_FUNCTIONS.error;\n  }\n\n  return null;\n}\n\nfunction invokeConsoleMethod(method, args) {\n  const fn = getStoredConsoleFunction(method);\n  if (typeof fn !== 'function') {\n    return undefined;\n  }\n\n  const receiver = typeof console !== 'undefined' && console\n    ? console\n    : GLOBAL_SCOPE && GLOBAL_SCOPE.console\n      ? GLOBAL_SCOPE.console\n      : null;\n  const finalArgs = Array.isArray(args) ? args : arrayFromArrayLike(args);\n\n  try {\n    return fn.apply(receiver, finalArgs);\n  } catch (applyError) {\n    void applyError;\n    try {\n      return Function.prototype.apply.call(fn, receiver, finalArgs);\n    } catch (callError) {\n      void callError;\n    }\n  }\n\n  return undefined;\n}\n\nfunction recordConsoleMessage(method, args, meta) {\n  const level = getConsoleLevelForMethod(method);\n  const rawArgs = Array.isArray(args) ? args : arrayFromArrayLike(args);\n  const messageParts = [];\n\n  for (let index = 0; index < rawArgs.length; index += 1) {\n    const value = rawArgs[index];\n    const valueType = typeof value;\n    if (valueType === 'string') {\n      safeArrayPush(messageParts, value);\n    } else if (valueType === 'number' || valueType === 'boolean') {\n      safeArrayPush(messageParts, String(value));\n    } else if (valueType === 'symbol') {\n      try {\n        safeArrayPush(messageParts, value.toString());\n      } catch (symbolError) {\n        void symbolError;\n      }\n    }\n  }\n\n  let message = messageParts.join(' ').trim();\n  if (!message) {\n    message = `[console.${method || level}]`;\n  }\n\n  let sanitizedArguments = null;\n  let detailPayload = null;\n  if (rawArgs.length) {\n    try {\n      sanitizedArguments = sanitizeForLog(rawArgs);\n      detailPayload = { arguments: sanitizedArguments };\n    } catch (detailError) {\n      detailPayload = { arguments: rawArgs.slice() };\n      void detailError;\n    }\n  }\n\n  const errorEntries = [];\n  const sanitizedArray = Array.isArray(sanitizedArguments) ? sanitizedArguments : null;\n\n  for (let index = 0; index < rawArgs.length; index += 1) {\n    const rawValue = rawArgs[index];\n    const sanitizedValue = sanitizedArray ? sanitizedArray[index] : null;\n    const isErrorInstance = rawValue instanceof Error;\n\n    const hasSanitizedErrorShape =\n      sanitizedValue && typeof sanitizedValue === 'object' && sanitizedValue !== null\n        ? Boolean(\n          typeof sanitizedValue.stack === 'string'\n          || typeof sanitizedValue.message === 'string'\n          || typeof sanitizedValue.name === 'string'\n        )\n        : false;\n\n    if (!isErrorInstance && !hasSanitizedErrorShape) {\n      continue;\n    }\n\n    let snapshot = hasSanitizedErrorShape ? sanitizedValue : null;\n\n    if (!snapshot) {\n      try {\n        snapshot = sanitizeForLog(rawValue);\n      } catch (argumentSanitizeError) {\n        snapshot = null;\n        void argumentSanitizeError;\n      }\n    }\n\n    if (!snapshot && isErrorInstance) {\n      snapshot = {\n        name: rawValue.name || null,\n        message: rawValue.message || coerceMessage(rawValue) || null,\n      };\n      if (typeof rawValue.code !== 'undefined') {\n        snapshot.code = rawValue.code;\n      }\n      if (typeof rawValue.status !== 'undefined') {\n        snapshot.status = rawValue.status;\n      }\n      if (typeof rawValue.stack === 'string' && rawValue.stack) {\n        snapshot.stack = rawValue.stack;\n      }\n    }\n\n    let valueClone = snapshot;\n    if (valueClone && typeof valueClone === 'object') {\n      try {\n        valueClone = LOGGING_DEEP_CLONE(valueClone);\n      } catch (cloneError) {\n        void cloneError;\n        try {\n          valueClone = Object.assign({}, valueClone);\n        } catch (assignError) {\n          valueClone = snapshot;\n          void assignError;\n        }\n      }\n    }\n\n    const entry = { index };\n    if (valueClone && typeof valueClone === 'object') {\n      entry.value = valueClone;\n      if (typeof valueClone.name === 'string' && valueClone.name) {\n        entry.name = valueClone.name;\n      }\n      if (typeof valueClone.message === 'string' && valueClone.message) {\n        entry.message = valueClone.message;\n      }\n      if (typeof valueClone.code !== 'undefined') {\n        entry.code = valueClone.code;\n      }\n      if (typeof valueClone.status !== 'undefined') {\n        entry.status = valueClone.status;\n      }\n    } else if (typeof valueClone !== 'undefined') {\n      entry.value = valueClone;\n      const coercedMessage = coerceMessage(valueClone);\n      if (coercedMessage) {\n        entry.message = coercedMessage;\n      }\n    } else {\n      entry.value = null;\n    }\n\n    const rawType = rawValue === null ? 'null' : typeof rawValue;\n    if (rawType === 'object' || rawType === 'function') {\n      const ctorName = rawValue && rawValue.constructor && rawValue.constructor.name;\n      entry.argumentType = typeof ctorName === 'string' && ctorName ? ctorName : rawType;\n    } else {\n      entry.argumentType = rawType;\n    }\n\n    const stackSummary = isErrorInstance && typeof rawValue.stack === 'string' && rawValue.stack\n      ? normaliseStackTrace(rawValue.stack)\n      : valueClone && typeof valueClone === 'object' && typeof valueClone.stack === 'string'\n        ? normaliseStackTrace(valueClone.stack)\n        : null;\n\n    if (stackSummary) {\n      if (typeof stackSummary.stack === 'string') {\n        entry.stack = stackSummary.stack;\n      }\n      if (Array.isArray(stackSummary.frames) && stackSummary.frames.length) {\n        entry.frames = stackSummary.frames;\n      }\n      if (stackSummary.truncated) {\n        entry.stackTruncated = true;\n      }\n    }\n\n    safeArrayPush(errorEntries, entry);\n  }\n\n  const contextMeta = { channel: 'console', method: method || 'log' };\n  if (meta && typeof meta === 'object') {\n    const metaKeys = Object.keys(meta);\n    for (let index = 0; index < metaKeys.length; index += 1) {\n      const key = metaKeys[index];\n      try {\n        contextMeta[key] = sanitizeForLog(meta[key]);\n      } catch (metaError) {\n        contextMeta[key] = meta[key];\n        void metaError;\n      }\n    }\n  }\n\n  if (errorEntries.length) {\n    detailPayload = detailPayload || {};\n    const errorIndices = [];\n    for (let index = 0; index < errorEntries.length; index += 1) {\n      const errorEntry = errorEntries[index];\n      errorIndices.push(errorEntry.index);\n    }\n    detailPayload.errors = errorEntries;\n    detailPayload.errorCount = errorEntries.length;\n    detailPayload.errorIndices = errorIndices;\n    detailPayload.primaryError = errorEntries[0];\n\n    contextMeta.errorCount = errorEntries.length;\n    contextMeta.errorIndices = errorIndices;\n\n    const primaryError = errorEntries[0];\n    if (primaryError) {\n      if (typeof primaryError.name === 'string' && primaryError.name) {\n        contextMeta.primaryErrorName = primaryError.name;\n      }\n      if (typeof primaryError.message === 'string' && primaryError.message) {\n        contextMeta.primaryErrorMessage = primaryError.message;\n      }\n      if (typeof primaryError.code !== 'undefined') {\n        contextMeta.primaryErrorCode = primaryError.code;\n      }\n      if (typeof primaryError.status !== 'undefined') {\n        contextMeta.primaryErrorStatus = primaryError.status;\n      }\n      if (primaryError.stack) {\n        contextMeta.primaryErrorHasStack = true;\n      }\n    }\n  }\n\n  const forceStackCapture = method === 'error' || errorEntries.length > 0;\n  const contextOptions = { namespace: 'console', meta: contextMeta };\n  if (forceStackCapture) {\n    contextOptions.captureStack = true;\n  }\n\n  return logInternal(\n    level,\n    message,\n    detailPayload,\n    contextOptions,\n    { silentConsole: true },\n  );\n}\n\nfunction installConsoleProxies() {\n  if (consoleProxyInstalled) {\n    return true;\n  }\n\n  consoleProxyInstallationAttempted = true;\n\n  if (typeof console === 'undefined' || !console) {\n    consoleProxyInstallationFailed = true;\n    return false;\n  }\n\n  try {\n    if (console[CONSOLE_PROXY_FLAG]) {\n      consoleProxyInstalled = true;\n      consoleProxyInstallationFailed = false;\n      return true;\n    }\n  } catch (flagReadError) {\n    void flagReadError;\n  }\n\n  let installedAny = false;\n\n  for (let index = 0; index < CONSOLE_METHODS.length; index += 1) {\n    const method = CONSOLE_METHODS[index];\n    let base = getStoredConsoleFunction(method);\n\n    if (typeof base !== 'function') {\n      try {\n        const candidate = console[method];\n        if (typeof candidate === 'function' && (!candidate || !candidate[CONSOLE_PROXY_FLAG])) {\n          base = candidate;\n        }\n      } catch (resolveError) {\n        base = null;\n        void resolveError;\n      }\n    }\n\n    if (!Object.prototype.hasOwnProperty.call(ORIGINAL_CONSOLE_FUNCTIONS, method) || ORIGINAL_CONSOLE_FUNCTIONS[method] === null) {\n      ORIGINAL_CONSOLE_FUNCTIONS[method] = typeof base === 'function' ? base : ORIGINAL_CONSOLE_FUNCTIONS[method];\n    }\n\n    if (typeof base !== 'function') {\n      continue;\n    }\n\n    const proxy = function consoleProxy() {\n      const argsArray = arrayFromArrayLike(arguments);\n      consoleProxyGuardDepth += 1;\n      try {\n        if (consoleProxyGuardDepth === 1) {\n          const firstArg = argsArray.length ? argsArray[0] : null;\n          const skipCapture = typeof firstArg === 'string' && firstArg.indexOf('cineLogging:') === 0;\n          if (!skipCapture) {\n            try {\n              recordConsoleMessage(method, argsArray, { captured: true });\n            } catch (recordError) {\n              void recordError;\n            }\n          }\n        }\n        return invokeConsoleMethod(method, argsArray);\n      } finally {\n        consoleProxyGuardDepth -= 1;\n        if (consoleProxyGuardDepth < 0) {\n          consoleProxyGuardDepth = 0;\n        }\n      }\n    };\n\n    try {\n      Object.defineProperty(proxy, CONSOLE_PROXY_FLAG, {\n        configurable: true,\n        enumerable: false,\n        writable: false,\n        value: true,\n      });\n    } catch (defineError) {\n      proxy[CONSOLE_PROXY_FLAG] = true;\n      void defineError;\n    }\n\n    try {\n      console[method] = proxy;\n      installedAny = true;\n    } catch (assignError) {\n      void assignError;\n    }\n  }\n\n  if (installedAny) {\n    consoleProxyInstalled = true;\n    consoleProxyInstallationFailed = false;\n    try {\n      Object.defineProperty(console, CONSOLE_PROXY_FLAG, {\n        configurable: true,\n        enumerable: false,\n        writable: false,\n        value: true,\n      });\n    } catch (flagError) {\n      try {\n        console[CONSOLE_PROXY_FLAG] = true;\n      } catch (assignFlagError) {\n        void assignFlagError;\n      }\n      void flagError;\n    }\n  } else {\n    consoleProxyInstallationFailed = true;\n  }\n\n  return consoleProxyInstalled;\n}\n\nfunction removeConsoleProxies() {\n  if (!consoleProxyInstalled) {\n    return false;\n  }\n\n  if (typeof console === 'undefined' || !console) {\n    consoleProxyInstalled = false;\n    return false;\n  }\n\n  let restoredAny = false;\n\n  for (let index = 0; index < CONSOLE_METHODS.length; index += 1) {\n    const method = CONSOLE_METHODS[index];\n    const original = ORIGINAL_CONSOLE_FUNCTIONS[method];\n    try {\n      if (typeof original === 'function') {\n        console[method] = original;\n        restoredAny = true;\n      } else if (method !== 'log' && method !== 'info') {\n        delete console[method];\n      }\n    } catch (restoreError) {\n      void restoreError;\n    }\n  }\n\n  try {\n    if (console && console[CONSOLE_PROXY_FLAG]) {\n      if (typeof Object.defineProperty === 'function') {\n        Object.defineProperty(console, CONSOLE_PROXY_FLAG, {\n          configurable: true,\n          enumerable: false,\n          writable: true,\n          value: false,\n        });\n      } else {\n        console[CONSOLE_PROXY_FLAG] = false;\n      }\n    }\n  } catch (flagError) {\n    void flagError;\n  }\n\n  consoleProxyInstalled = false;\n  return restoredAny;\n}\n\nfunction syncConsoleCaptureState() {\n  if (!activeConfig.captureConsole) {\n    if (consoleProxyInstalled) {\n      removeConsoleProxies();\n    }\n    if (lastConsoleCaptureState !== 'disabled') {\n      logInternal(\n        'info',\n        'Console output capture disabled',\n        buildConsoleCaptureDetail({ status: 'disabled' }),\n        { namespace: 'logging', meta: { channel: 'console', lifecycle: 'sync' } },\n        { silentConsole: true },\n      );\n      lastConsoleCaptureState = 'disabled';\n    }\n    consoleProxyWarningIssued = false;\n    consoleProxyInstallationFailed = false;\n    return true;\n  }\n\n  const installed = installConsoleProxies();\n  if (!installed) {\n    if (!consoleProxyWarningIssued) {\n      const reason = typeof console === 'undefined' || !console\n        ? 'console-unavailable'\n        : 'installation-failed';\n      logInternal(\n        'warn',\n        'Console output capture failed',\n        buildConsoleCaptureDetail({ status: 'failed', reason }),\n        { namespace: 'logging', meta: { channel: 'console', lifecycle: 'sync' } },\n        { silentConsole: true },\n      );\n      safeWarn('cineLogging: Unable to capture console output for diagnostics.');\n      consoleProxyWarningIssued = true;\n    }\n    lastConsoleCaptureState = 'failed';\n    return false;\n  }\n\n  consoleProxyWarningIssued = false;\n\n  if (lastConsoleCaptureState !== 'enabled') {\n    logInternal(\n      'info',\n      'Console output capture enabled',\n      buildConsoleCaptureDetail({ status: 'enabled' }),\n      { namespace: 'logging', meta: { channel: 'console', lifecycle: 'sync' } },\n      { silentConsole: true },\n    );\n    lastConsoleCaptureState = 'enabled';\n  }\n\n  return true;\n}\n\nfunction isConsoleCaptureActive() {\n  return Boolean(activeConfig.captureConsole) && consoleProxyInstalled === true;\n}\n\nfunction buildConsoleCaptureDetail(overrides) {\n  const detail = {\n    configured: activeConfig.captureConsole === true,\n    installed: consoleProxyInstalled === true,\n    attempted: consoleProxyInstallationAttempted === true,\n    failed: consoleProxyInstallationFailed === true,\n  };\n\n  if (typeof console === 'undefined' || !console) {\n    detail.consoleAvailable = false;\n  }\n\n  if (overrides && typeof overrides === 'object') {\n    const overrideKeys = Object.keys(overrides);\n    for (let index = 0; index < overrideKeys.length; index += 1) {\n      const key = overrideKeys[index];\n      detail[key] = overrides[key];\n    }\n  }\n\n  return detail;\n}\n\nfunction enableConsoleCapture(options) {\n  const setOptions = options && typeof options === 'object' ? options : null;\n  setConfig({ captureConsole: true }, setOptions || undefined);\n  return isConsoleCaptureActive();\n}\n\nfunction disableConsoleCapture(options) {\n  const setOptions = options && typeof options === 'object' ? options : null;\n  setConfig({ captureConsole: false }, setOptions || undefined);\n  return isConsoleCaptureActive();\n}\n\nfunction shouldCaptureOrigin(level, detail, context) {\n  const override = context && Object.prototype.hasOwnProperty.call(context, 'captureStack')\n    ? context.captureStack\n    : null;\n\n  if (override === true) {\n    return true;\n  }\n\n  if (override === false) {\n    return false;\n  }\n\n  if (activeConfig.stackTraces !== true) {\n    return false;\n  }\n\n  if (detail instanceof Error) {\n    return true;\n  }\n\n  return getLevelPriority(level) >= getLevelPriority('warn');\n}\n\nfunction captureLogOrigin(level, message, detail, context) {\n  if (!shouldCaptureOrigin(level, detail, context)) {\n    return null;\n  }\n\n  let stackSource = 'generated';\n  let stackValue = '';\n\n  if (detail instanceof Error) {\n    const detailStack = detail.stack;\n    if (typeof detailStack === 'string' && detailStack) {\n      stackSource = 'detail';\n      stackValue = detailStack;\n    }\n  }\n\n  if (!stackValue) {\n    try {\n      const stackMessage = typeof message === 'string' && message\n        ? message\n        : `Log ${level}`;\n      const captureError = new Error(stackMessage);\n      if (typeof Error.captureStackTrace === 'function') {\n        Error.captureStackTrace(captureError, captureLogOrigin);\n      }\n      if (typeof captureError.stack === 'string' && captureError.stack) {\n        stackValue = captureError.stack;\n      }\n    } catch (stackError) {\n      void stackError;\n    }\n  }\n\n  const summary = normaliseStackTrace(stackValue);\n  if (!summary) {\n    return null;\n  }\n\n  const origin = {\n    source: stackSource,\n    stack: summary.stack,\n    truncated: summary.truncated,\n  };\n\n  if (Array.isArray(summary.frames) && summary.frames.length) {\n    origin.frames = summary.frames;\n  }\n\n  return freezeDeep(origin);\n}\n\nfunction logInternal(level, message, detail, context, options) {\n  const normalizedLevel = normalizeLevel(level, 'info');\n  const timestamp = Date.now();\n  let isoTimestamp = '';\n  try {\n    isoTimestamp = new Date(timestamp).toISOString();\n  } catch (error) {\n    void error;\n    isoTimestamp = String(timestamp);\n  }\n\n  const captureContext = context && typeof context === 'object' ? context : null;\n  const origin = captureLogOrigin(normalizedLevel, message, detail, captureContext);\n\n  const namespace = captureContext && typeof captureContext.namespace === 'string' && captureContext.namespace\n    ? context.namespace\n    : null;\n\n  const meta = captureContext && typeof captureContext.meta !== 'undefined'\n    ? sanitizeForLog(captureContext.meta)\n    : null;\n\n  const sanitizedDetail = typeof detail === 'undefined'\n    ? null\n    : sanitizeForLog(detail);\n\n  const entry = freezeDeep({\n    id: createEntryId(timestamp),\n    level: normalizedLevel,\n    message: coerceMessage(message),\n    namespace,\n    detail: sanitizedDetail,\n    meta,\n    timestamp,\n    isoTimestamp,\n    origin,\n  });\n\n  applyLevelCounterDelta(emittedLevelCounters, normalizedLevel, 1);\n\n  if (shouldRecord(normalizedLevel)) {\n    appendEntry(entry);\n  }\n\n  const internalOptions = options && typeof options === 'object' ? options : null;\n\n  if (shouldOutputToConsole(normalizedLevel) && (!internalOptions || internalOptions.silentConsole !== true)) {\n    const descriptor = LOG_LEVEL_MAP[normalizedLevel] || LOG_LEVEL_MAP.info;\n    const methodName = descriptor.consoleMethod;\n    const prefixParts = ['[cine]'];\n    if (namespace) {\n      prefixParts.push(`[${namespace}]`);\n    }\n    prefixParts.push(entry.isoTimestamp);\n    const prefix = prefixParts.join(' ');\n    const consoleArgs = [`${prefix} ${entry.message}`];\n    if (detail !== undefined) {\n      safeArrayPush(consoleArgs, detail);\n    } else if (entry.detail !== null) {\n      safeArrayPush(consoleArgs, entry.detail);\n    }\n    if (entry.meta !== null) {\n      safeArrayPush(consoleArgs, { meta: entry.meta });\n    }\n    if (origin) {\n      safeArrayPush(consoleArgs, { origin });\n    }\n    invokeConsoleMethod(methodName, consoleArgs);\n  }\n\n  return entry;\n}\n\nfunction debug(message, detail, context) {\n  return logInternal('debug', message, detail, context);\n}\n\nfunction info(message, detail, context) {\n  return logInternal('info', message, detail, context);\n}\n\nfunction warn(message, detail, context) {\n  return logInternal('warn', message, detail, context);\n}\n\nfunction error(message, detail, context) {\n  return logInternal('error', message, detail, context);\n}\n\nfunction getConfigSnapshot() {\n  return freezeDeep({\n    level: activeConfig.level,\n    historyLevel: activeConfig.historyLevel,\n    historyLimit: activeConfig.historyLimit,\n    consoleOutput: activeConfig.consoleOutput,\n    persistSession: activeConfig.persistSession,\n    captureGlobalErrors: activeConfig.captureGlobalErrors,\n    captureConsole: activeConfig.captureConsole,\n    stackTraces: activeConfig.stackTraces,\n  });\n}\n\nfunction getHistory(options) {\n  const limit = options && typeof options.limit !== 'undefined' ? options.limit : undefined;\n  return getHistorySnapshot(limit);\n}\n\nfunction cloneLastDropSnapshot() {\n  if (!lastHistoryDrop) {\n    return null;\n  }\n\n  return freezeDeep({\n    count: typeof lastHistoryDrop.count === 'number' ? lastHistoryDrop.count : 0,\n    limit: typeof lastHistoryDrop.limit === 'number'\n      ? lastHistoryDrop.limit\n      : getEffectiveHistoryLimit(),\n    source: typeof lastHistoryDrop.source === 'string' ? lastHistoryDrop.source : 'enforce',\n    timestamp:\n      typeof lastHistoryDrop.timestamp === 'number'\n        ? lastHistoryDrop.timestamp\n        : null,\n    isoTimestamp: typeof lastHistoryDrop.isoTimestamp === 'string'\n      ? lastHistoryDrop.isoTimestamp\n      : null,\n    oldestEntryId: typeof lastHistoryDrop.oldestEntryId === 'string'\n      ? lastHistoryDrop.oldestEntryId\n      : null,\n    oldestEntryTimestamp: typeof lastHistoryDrop.oldestEntryTimestamp === 'number'\n      ? lastHistoryDrop.oldestEntryTimestamp\n      : null,\n    oldestEntryIsoTimestamp: typeof lastHistoryDrop.oldestEntryIsoTimestamp === 'string'\n      ? lastHistoryDrop.oldestEntryIsoTimestamp\n      : null,\n    newestEntryId: typeof lastHistoryDrop.newestEntryId === 'string'\n      ? lastHistoryDrop.newestEntryId\n      : null,\n    newestEntryTimestamp: typeof lastHistoryDrop.newestEntryTimestamp === 'number'\n      ? lastHistoryDrop.newestEntryTimestamp\n      : null,\n    newestEntryIsoTimestamp: typeof lastHistoryDrop.newestEntryIsoTimestamp === 'string'\n      ? lastHistoryDrop.newestEntryIsoTimestamp\n      : null,\n    levels: lastHistoryDrop.levels\n      ? freezeLevelSummary(lastHistoryDrop.levels)\n      : freezeLevelSummary(createLevelCounters()),\n  });\n}\n\nfunction getStats() {\n  return freezeDeep({\n    runtimeEntries: runtimeEntryCount,\n    retainedEntries: logHistory.length,\n    droppedEntries: totalEntriesDropped,\n    historyLimit: getEffectiveHistoryLimit(),\n    lastDrop: cloneLastDropSnapshot(),\n    levels: freezeDeep({\n      emitted: freezeLevelSummary(emittedLevelCounters),\n      retained: freezeLevelSummary(retainedLevelCounters),\n      dropped: freezeLevelSummary(droppedLevelCounters),\n    }),\n    consoleCapture: freezeDeep({\n      configured: activeConfig.captureConsole === true,\n      installed: consoleProxyInstalled,\n      attempted: consoleProxyInstallationAttempted,\n      failed: consoleProxyInstallationFailed,\n    }),\n  });\n}\n\nfunction clearHistory(options) {\n  logHistory.length = 0;\n  resetLevelCounters(retainedLevelCounters);\n  if (!options || options.persist !== false) {\n    persistHistorySafe();\n  }\n  return true;\n}\n\nfunction subscribe(listener) {\n  if (typeof listener !== 'function') {\n    return function unsubscribeNoop() {\n      return false;\n    };\n  }\n  logSubscribers.add(listener);\n  return function unsubscribe() {\n    logSubscribers.delete(listener);\n    return true;\n  };\n}\n\nfunction subscribeConfig(listener) {\n  if (typeof listener !== 'function') {\n    return function unsubscribeConfigNoop() {\n      return false;\n    };\n  }\n  configSubscribers.add(listener);\n  return function unsubscribeConfig() {\n    configSubscribers.delete(listener);\n    return true;\n  };\n}\n\nfunction mergeMeta(baseMeta, meta) {\n  if (!baseMeta && !meta) {\n    return null;\n  }\n\n  if (!baseMeta) {\n    return sanitizeForLog(meta);\n  }\n\n  if (!meta) {\n    return baseMeta;\n  }\n\n  if (typeof baseMeta !== 'object' || typeof meta !== 'object') {\n    return sanitizeForLog(meta);\n  }\n\n  const merged = {};\n  const baseKeys = Object.keys(baseMeta);\n  for (let index = 0; index < baseKeys.length; index += 1) {\n    const key = baseKeys[index];\n    merged[key] = baseMeta[key];\n  }\n  const metaKeys = Object.keys(meta);\n  for (let index = 0; index < metaKeys.length; index += 1) {\n    const key = metaKeys[index];\n    merged[key] = sanitizeForLog(meta[key]);\n  }\n  return merged;\n}\n\nfunction createLogger(namespace, options) {\n  const normalizedNamespace = typeof namespace === 'string' && namespace.trim()\n    ? namespace.trim()\n    : 'app';\n\n  const baseMeta = options && typeof options.meta !== 'undefined'\n    ? sanitizeForLog(options.meta)\n    : null;\n\n  function logWithNamespace(level, message, detail, meta) {\n    const mergedMeta = mergeMeta(baseMeta, meta);\n    return logInternal(level, message, detail, {\n      namespace: normalizedNamespace,\n      meta: mergedMeta,\n    });\n  }\n\n  return freezeDeep({\n    namespace: normalizedNamespace,\n    log(level, message, detail, meta) {\n      return logWithNamespace(level, message, detail, meta);\n    },\n    debug(message, detail, meta) {\n      return logWithNamespace('debug', message, detail, meta);\n    },\n    info(message, detail, meta) {\n      return logWithNamespace('info', message, detail, meta);\n    },\n    warn(message, detail, meta) {\n      return logWithNamespace('warn', message, detail, meta);\n    },\n    error(message, detail, meta) {\n      return logWithNamespace('error', message, detail, meta);\n    },\n    getConfig: getConfigSnapshot,\n    isLevelEnabled(level, optionOverrides) {\n      return isLevelEnabled(level, optionOverrides);\n    },\n    getLevelState(level) {\n      return getLevelState(level);\n    },\n  });\n}\n\nfunction markEventHandled(event) {\n  if (!event || (typeof event !== 'object' && typeof event !== 'function')) {\n    return false;\n  }\n\n  const flag = ERROR_EVENT_FLAG;\n\n  try {\n    if (typeof flag === 'symbol') {\n      if (event[flag]) {\n        return true;\n      }\n      event[flag] = true;\n      return false;\n    }\n\n    if (Object.prototype.hasOwnProperty.call(event, flag) && event[flag]) {\n      return true;\n    }\n\n    Object.defineProperty(event, flag, {\n      configurable: true,\n      enumerable: false,\n      writable: true,\n      value: true,\n    });\n    return false;\n  } catch (error) {\n    void error;\n  }\n\n  return false;\n}\n\nfunction handleGlobalError(event) {\n  if (!activeConfig.captureGlobalErrors) {\n    return;\n  }\n\n  if (markEventHandled(event)) {\n    return;\n  }\n\n  const detail = {\n    message: event && typeof event.message === 'string' ? event.message : '',\n    filename: event ? event.filename || event.fileName || null : null,\n    lineno: event ? event.lineno || event.lineNumber || null : null,\n    colno: event ? event.colno || event.columnNumber || null : null,\n    error: event && event.error ? sanitizeForLog(event.error) : null,\n  };\n\n  if (event && typeof event.preventDefault === 'function' && event.defaultPrevented) {\n    detail.defaultPrevented = true;\n  }\n\n  logInternal('error', 'Global error captured', detail, { namespace: 'global' });\n}\n\nfunction handleUnhandledRejection(event) {\n  if (!activeConfig.captureGlobalErrors) {\n    return;\n  }\n\n  if (markEventHandled(event)) {\n    return;\n  }\n\n  const detail = {\n    reason: event ? sanitizeForLog(event.reason) : null,\n  };\n\n  if (event && event.promise) {\n    detail.promiseState = '[Promise]';\n  }\n\n  if (event && typeof event.preventDefault === 'function' && event.defaultPrevented) {\n    detail.defaultPrevented = true;\n  }\n\n  logInternal('error', 'Unhandled promise rejection captured', detail, { namespace: 'global' });\n}\n\nfunction markTargetAttached(target) {\n  if (!target || (typeof target !== 'object' && typeof target !== 'function')) {\n    return false;\n  }\n\n  if (attachedErrorTargets instanceof WeakSet) {\n    if (attachedErrorTargets.has(target)) {\n      return true;\n    }\n    attachedErrorTargets.add(target);\n    return false;\n  }\n\n  const list = attachedErrorTargets;\n  const index = list.indexOf(target);\n  if (index !== -1) {\n    return true;\n  }\n  list.push(target);\n  return false;\n}\n\nfunction attachGlobalErrorListeners() {\n  if (!activeConfig.captureGlobalErrors) {\n    return;\n  }\n\n  const scopes = fallbackCollectCandidateScopes(GLOBAL_SCOPE);\n  for (let index = 0; index < scopes.length; index += 1) {\n    const scope = scopes[index];\n    if (!scope || typeof scope.addEventListener !== 'function') {\n      continue;\n    }\n\n    if (markTargetAttached(scope)) {\n      continue;\n    }\n\n    try {\n      scope.addEventListener('error', handleGlobalError, true);\n    } catch (error) {\n      void error;\n    }\n\n    try {\n      scope.addEventListener('unhandledrejection', handleUnhandledRejection, true);\n    } catch (error) {\n      void error;\n    }\n  }\n}\n\nfunction applyConfig(overrides) {\n  if (!overrides || typeof overrides !== 'object') {\n    return { changed: false, captureChanged: false, limitChanged: false };\n  }\n\n  let changed = false;\n  let captureChanged = false;\n  let limitChanged = false;\n  let consoleCaptureChanged = false;\n\n  const nextPersistSession = Object.prototype.hasOwnProperty.call(overrides, 'persistSession')\n    ? booleanFromValue(overrides.persistSession, activeConfig.persistSession)\n    : activeConfig.persistSession;\n\n  if (Object.prototype.hasOwnProperty.call(overrides, 'level')) {\n    const nextLevel = normalizeLevel(overrides.level, activeConfig.level);\n    if (nextLevel !== activeConfig.level) {\n      activeConfig.level = nextLevel;\n      changed = true;\n    }\n  }\n\n  if (Object.prototype.hasOwnProperty.call(overrides, 'historyLevel')) {\n    const nextHistoryLevel = normalizeLevel(overrides.historyLevel, activeConfig.historyLevel);\n    if (nextHistoryLevel !== activeConfig.historyLevel) {\n      activeConfig.historyLevel = nextHistoryLevel;\n      changed = true;\n    }\n  }\n\n  if (Object.prototype.hasOwnProperty.call(overrides, 'historyLimit')) {\n    const nextLimit = clampHistoryLimit(overrides.historyLimit, {\n      allowReducedMin: nextPersistSession === false,\n    });\n    if (nextLimit !== activeConfig.historyLimit) {\n      activeConfig.historyLimit = nextLimit;\n      changed = true;\n      limitChanged = true;\n    }\n  }\n\n  if (Object.prototype.hasOwnProperty.call(overrides, 'consoleOutput')) {\n    const nextConsole = booleanFromValue(overrides.consoleOutput, activeConfig.consoleOutput);\n    if (nextConsole !== activeConfig.consoleOutput) {\n      activeConfig.consoleOutput = nextConsole;\n      changed = true;\n    }\n  }\n\n  if (Object.prototype.hasOwnProperty.call(overrides, 'persistSession')) {\n    if (nextPersistSession !== activeConfig.persistSession) {\n      activeConfig.persistSession = nextPersistSession;\n      changed = true;\n    }\n  }\n\n  if (activeConfig.persistSession && activeConfig.historyLimit < HISTORY_MIN_LIMIT) {\n    activeConfig.historyLimit = HISTORY_MIN_LIMIT;\n    changed = true;\n    limitChanged = true;\n  }\n\n  if (Object.prototype.hasOwnProperty.call(overrides, 'captureGlobalErrors')) {\n    const nextCapture = booleanFromValue(overrides.captureGlobalErrors, activeConfig.captureGlobalErrors);\n    if (nextCapture !== activeConfig.captureGlobalErrors) {\n      activeConfig.captureGlobalErrors = nextCapture;\n      changed = true;\n      captureChanged = true;\n    }\n  }\n\n  if (Object.prototype.hasOwnProperty.call(overrides, 'captureConsole')) {\n    const nextConsoleCapture = booleanFromValue(overrides.captureConsole, activeConfig.captureConsole);\n    if (nextConsoleCapture !== activeConfig.captureConsole) {\n      activeConfig.captureConsole = nextConsoleCapture;\n      changed = true;\n      consoleCaptureChanged = true;\n    }\n  }\n\n  if (Object.prototype.hasOwnProperty.call(overrides, 'stackTraces')) {\n    const nextStackTraces = booleanFromValue(overrides.stackTraces, activeConfig.stackTraces);\n    if (nextStackTraces !== activeConfig.stackTraces) {\n      activeConfig.stackTraces = nextStackTraces;\n      changed = true;\n    }\n  }\n\n  return { changed, captureChanged, limitChanged, consoleCaptureChanged };\n}\n\nfunction setConfig(overrides, options) {\n  const previousCapture = activeConfig.captureGlobalErrors;\n  const previousConsoleCapture = activeConfig.captureConsole;\n  const result = applyConfig(overrides);\n\n  if (result.limitChanged) {\n    enforceHistoryLimit({ source: 'config' });\n  }\n\n  if (result.changed && (!options || options.persist !== false)) {\n    persistConfigSafe();\n    persistHistorySafe();\n  }\n\n  if (!activeConfig.persistSession) {\n    clearStoredHistory();\n  }\n\n  if (!previousCapture && activeConfig.captureGlobalErrors) {\n    attachGlobalErrorListeners();\n  }\n\n  if (result.consoleCaptureChanged || previousConsoleCapture !== activeConfig.captureConsole) {\n    syncConsoleCaptureState();\n  }\n\n  if (result.changed) {\n    notifyConfigSubscribers(getConfigSnapshot());\n  }\n\n  return getConfigSnapshot();\n}\n\nfunction resolveConfigPresetFromScopes() {\n  const scopes = fallbackCollectCandidateScopes(GLOBAL_SCOPE);\n  const keys = ['__cineLoggingConfig', '__CINE_LOGGING_CONFIG', 'cineLoggingConfig'];\n\n  for (let scopeIndex = 0; scopeIndex < scopes.length; scopeIndex += 1) {\n    const scope = scopes[scopeIndex];\n    if (!scope || (typeof scope !== 'object' && typeof scope !== 'function')) {\n      continue;\n    }\n\n    for (let keyIndex = 0; keyIndex < keys.length; keyIndex += 1) {\n      const key = keys[keyIndex];\n      let value;\n      try {\n        value = scope[key];\n      } catch (error) {\n        void error;\n        value = null;\n      }\n      if (value && typeof value === 'object') {\n        return value;\n      }\n    }\n  }\n\n  return null;\n}\n\nfunction applyConfigFromStorage() {\n  const storage = getSessionStorage();\n  if (!storage) {\n    return;\n  }\n\n  let raw = '';\n  try {\n    raw = storage.getItem(CONFIG_STORAGE_KEY) || '';\n  } catch (error) {\n    void error;\n    return;\n  }\n\n  if (!raw) {\n    return;\n  }\n\n  try {\n    const parsed = JSON.parse(raw);\n    applyConfig(parsed);\n  } catch (error) {\n    safeWarn('cineLogging: Unable to restore logging config from storage', error);\n  }\n}\n\nfunction applyConfigFromQuery() {\n  if (!GLOBAL_SCOPE || !GLOBAL_SCOPE.location) {\n    return;\n  }\n\n  let search = '';\n  try {\n    search = GLOBAL_SCOPE.location.search || '';\n  } catch (error) {\n    void error;\n    return;\n  }\n\n  if (typeof search !== 'string' || !search) {\n    return;\n  }\n\n  let params = null;\n  if (typeof URLSearchParams === 'function') {\n    try {\n      params = new URLSearchParams(search);\n    } catch (error) {\n      void error;\n    }\n  }\n\n  const updates = {};\n  let hasUpdates = false;\n\n  function assignUpdate(key, value) {\n    updates[key] = value;\n    hasUpdates = true;\n  }\n\n  if (params) {\n    if (params.has('cineLogLevel')) {\n      assignUpdate('level', params.get('cineLogLevel'));\n    }\n    if (params.has('cineLogHistoryLevel')) {\n      assignUpdate('historyLevel', params.get('cineLogHistoryLevel'));\n    }\n    if (params.has('cineLogLimit')) {\n      assignUpdate('historyLimit', params.get('cineLogLimit'));\n    }\n    if (params.has('cineLogConsole')) {\n      assignUpdate('consoleOutput', params.get('cineLogConsole'));\n    }\n    if (params.has('cineLogPersist')) {\n      assignUpdate('persistSession', params.get('cineLogPersist'));\n    }\n    if (params.has('cineLogCapture')) {\n      assignUpdate('captureGlobalErrors', params.get('cineLogCapture'));\n    }\n    if (params.has('cineLogConsoleCapture')) {\n      assignUpdate('captureConsole', params.get('cineLogConsoleCapture'));\n    }\n    if (params.has('cineLogStackTraces')) {\n      assignUpdate('stackTraces', params.get('cineLogStackTraces'));\n    }\n  } else {\n    const query = search.charAt(0) === '?' ? search.slice(1) : search;\n    const parts = query.split('&');\n    for (let index = 0; index < parts.length; index += 1) {\n      const part = parts[index];\n      if (!part) {\n        continue;\n      }\n      const eqIndex = part.indexOf('=');\n      const key = eqIndex === -1 ? decodeURIComponent(part) : decodeURIComponent(part.slice(0, eqIndex));\n      const value = eqIndex === -1 ? '' : decodeURIComponent(part.slice(eqIndex + 1));\n      if (key === 'cineLogLevel') {\n        assignUpdate('level', value);\n      } else if (key === 'cineLogHistoryLevel') {\n        assignUpdate('historyLevel', value);\n      } else if (key === 'cineLogLimit') {\n        assignUpdate('historyLimit', value);\n      } else if (key === 'cineLogConsole') {\n        assignUpdate('consoleOutput', value);\n      } else if (key === 'cineLogPersist') {\n        assignUpdate('persistSession', value);\n      } else if (key === 'cineLogCapture') {\n        assignUpdate('captureGlobalErrors', value);\n      } else if (key === 'cineLogConsoleCapture') {\n        assignUpdate('captureConsole', value);\n      } else if (key === 'cineLogStackTraces') {\n        assignUpdate('stackTraces', value);\n      }\n    }\n  }\n\n  if (hasUpdates) {\n    applyConfig(updates);\n  }\n}\n\nfunction normaliseStoredEntry(entry) {\n  if (!entry || typeof entry !== 'object') {\n    return null;\n  }\n\n  const normalizedLevel = normalizeLevel(entry.level, 'info');\n  const timestamp = typeof entry.timestamp === 'number' && Number.isFinite(entry.timestamp)\n    ? entry.timestamp\n    : Date.now();\n\n  let isoTimestamp = '';\n  if (typeof entry.isoTimestamp === 'string' && entry.isoTimestamp) {\n    isoTimestamp = entry.isoTimestamp;\n  } else {\n    try {\n      isoTimestamp = new Date(timestamp).toISOString();\n    } catch (error) {\n      void error;\n      isoTimestamp = String(timestamp);\n    }\n  }\n\n  const normalizedMessage = typeof entry.message === 'string'\n    ? entry.message\n    : coerceMessage(entry.message);\n\n  const normalizedNamespace = typeof entry.namespace === 'string' && entry.namespace\n    ? entry.namespace\n    : null;\n\n  const normalizedId = typeof entry.id === 'string' && entry.id\n    ? entry.id\n    : createEntryId(timestamp);\n\n  return freezeDeep({\n    id: normalizedId,\n    level: normalizedLevel,\n    message: normalizedMessage,\n    namespace: normalizedNamespace,\n    detail: typeof entry.detail === 'undefined' ? null : sanitizeForLog(entry.detail),\n    meta: typeof entry.meta === 'undefined' ? null : sanitizeForLog(entry.meta),\n    timestamp,\n    isoTimestamp,\n    origin: typeof entry.origin === 'undefined' ? null : normaliseOriginSnapshot(entry.origin),\n  });\n}\n\nfunction getGlobalNavigator() {\n  if (GLOBAL_SCOPE && typeof GLOBAL_SCOPE.navigator === 'object' && GLOBAL_SCOPE.navigator) {\n    return GLOBAL_SCOPE.navigator;\n  }\n  if (typeof navigator !== 'undefined' && navigator) {\n    return navigator;\n  }\n  if (typeof globalThis !== 'undefined' && globalThis && typeof globalThis.navigator === 'object') {\n    return globalThis.navigator;\n  }\n  return null;\n}\n\nfunction getNavigatorServiceWorker() {\n  const nav = getGlobalNavigator();\n  if (!nav || typeof nav !== 'object') {\n    return null;\n  }\n  if (!nav.serviceWorker) {\n    return null;\n  }\n  return nav.serviceWorker;\n}\n\nfunction markServiceWorkerEntrySeen(id) {\n  if (!id) {\n    return true;\n  }\n\n  if (serviceWorkerBridgeState.seenIds) {\n    if (serviceWorkerBridgeState.seenIds.has(id)) {\n      return false;\n    }\n    serviceWorkerBridgeState.seenIds.add(id);\n    return true;\n  }\n\n  if (Array.isArray(serviceWorkerBridgeState.fallbackSeenIds)) {\n    if (serviceWorkerBridgeState.fallbackSeenIds.indexOf(id) !== -1) {\n      return false;\n    }\n    serviceWorkerBridgeState.fallbackSeenIds.push(id);\n    return true;\n  }\n\n  return true;\n}\n\nfunction mergeServiceWorkerEntryMeta(entry, snapshotMeta) {\n  const merged = {};\n\n  if (entry && typeof entry.meta !== 'undefined') {\n    if (entry.meta && typeof entry.meta === 'object') {\n      for (const key in entry.meta) {\n        if (Object.prototype.hasOwnProperty.call(entry.meta, key)) {\n          merged[key] = entry.meta[key];\n        }\n      }\n    } else {\n      merged.value = entry.meta;\n    }\n  }\n\n  const channel = entry && typeof entry.channel === 'string' && entry.channel\n    ? entry.channel\n    : merged.channel;\n  if (channel) {\n    merged.channel = channel;\n  } else {\n    merged.channel = 'service-worker';\n  }\n\n  if (snapshotMeta && typeof snapshotMeta === 'object') {\n    if (snapshotMeta.cacheName && !merged.cacheName) {\n      merged.cacheName = snapshotMeta.cacheName;\n    }\n    if (snapshotMeta.cacheVersion && !merged.cacheVersion) {\n      merged.cacheVersion = snapshotMeta.cacheVersion;\n    }\n    if (typeof snapshotMeta.generatedAt === 'number' && Number.isFinite(snapshotMeta.generatedAt)) {\n      if (!merged.snapshotTimestamp) {\n        merged.snapshotTimestamp = snapshotMeta.generatedAt;\n      }\n    }\n    if (typeof snapshotMeta.historyLength === 'number' && Number.isFinite(snapshotMeta.historyLength)) {\n      if (!merged.snapshotSize) {\n        merged.snapshotSize = snapshotMeta.historyLength;\n      }\n    }\n  }\n\n  return merged;\n}\n\nfunction importServiceWorkerLogEntries(entries, snapshotMeta) {\n  if (!Array.isArray(entries) || !entries.length) {\n    return;\n  }\n\n  for (let index = 0; index < entries.length; index += 1) {\n    const rawEntry = entries[index];\n    if (!rawEntry || typeof rawEntry !== 'object') {\n      continue;\n    }\n\n    const entryId = typeof rawEntry.id === 'string' && rawEntry.id ? rawEntry.id : null;\n    if (!markServiceWorkerEntrySeen(entryId)) {\n      continue;\n    }\n\n    const origin = rawEntry.origin && typeof rawEntry.origin === 'object'\n      ? rawEntry.origin\n      : { runtime: 'service-worker' };\n\n    const normalized = normaliseStoredEntry({\n      id: entryId || undefined,\n      level: rawEntry.level,\n      message: rawEntry.message,\n      namespace: typeof rawEntry.namespace === 'string' && rawEntry.namespace\n        ? rawEntry.namespace\n        : 'service-worker',\n      detail: typeof rawEntry.detail === 'undefined' ? null : rawEntry.detail,\n      meta: mergeServiceWorkerEntryMeta(rawEntry, snapshotMeta),\n      timestamp: rawEntry.timestamp,\n      isoTimestamp: rawEntry.isoTimestamp,\n      origin,\n    });\n\n    if (normalized) {\n      appendEntry(normalized);\n    }\n  }\n}\n\nfunction finalizeServiceWorkerLogRequest(requestId) {\n  if (!serviceWorkerBridgeState.requestInFlight) {\n    return;\n  }\n\n  if (requestId && serviceWorkerBridgeState.lastRequestId && requestId !== serviceWorkerBridgeState.lastRequestId) {\n    return;\n  }\n\n  serviceWorkerBridgeState.requestInFlight = false;\n  serviceWorkerBridgeState.lastRequestId = null;\n\n  if (serviceWorkerBridgeState.requestTimer && typeof clearTimeout === 'function') {\n    try {\n      clearTimeout(serviceWorkerBridgeState.requestTimer);\n    } catch (error) {\n      void error;\n    }\n  }\n\n  serviceWorkerBridgeState.requestTimer = null;\n}\n\nfunction scheduleServiceWorkerLogPoll() {\n  if (serviceWorkerBridgeState.broadcastChannel || serviceWorkerBridgeState.broadcastFailed) {\n    return;\n  }\n\n  if (serviceWorkerBridgeState.pollTimer || typeof setTimeout !== 'function') {\n    return;\n  }\n\n  try {\n    serviceWorkerBridgeState.pollTimer = setTimeout(() => {\n      serviceWorkerBridgeState.pollTimer = null;\n      requestServiceWorkerLogSnapshot('poll');\n    }, SERVICE_WORKER_LOG_POLL_INTERVAL);\n  } catch (error) {\n    void error;\n  }\n}\n\nfunction ensureServiceWorkerBroadcastChannel() {\n  if (serviceWorkerBridgeState.broadcastFailed) {\n    return null;\n  }\n\n  if (serviceWorkerBridgeState.broadcastChannel) {\n    return serviceWorkerBridgeState.broadcastChannel;\n  }\n\n  if (typeof BroadcastChannel !== 'function') {\n    serviceWorkerBridgeState.broadcastFailed = true;\n    return null;\n  }\n\n  try {\n    const channel = new BroadcastChannel(SERVICE_WORKER_LOG_CHANNEL);\n    channel.addEventListener('message', handleServiceWorkerLogMessage);\n    serviceWorkerBridgeState.broadcastChannel = channel;\n    if (serviceWorkerBridgeState.pollTimer && typeof clearTimeout === 'function') {\n      try {\n        clearTimeout(serviceWorkerBridgeState.pollTimer);\n      } catch (error) {\n        void error;\n      }\n      serviceWorkerBridgeState.pollTimer = null;\n    }\n    return channel;\n  } catch (error) {\n    serviceWorkerBridgeState.broadcastFailed = true;\n    safeWarn('cineLogging: Unable to open service worker diagnostics channel', error);\n    return null;\n  }\n}\n\nfunction handleServiceWorkerLogMessage(event) {\n  if (!event) {\n    return;\n  }\n\n  let data = null;\n  try {\n    data = event.data || null;\n  } catch (error) {\n    void error;\n    data = null;\n  }\n\n  if (!data || typeof data !== 'object') {\n    return;\n  }\n\n  if (data.type === SERVICE_WORKER_LOG_ENTRY_TYPE) {\n    importServiceWorkerLogEntries([data.entry], serviceWorkerBridgeState.lastSnapshotMeta);\n    scheduleServiceWorkerLogPoll();\n    return;\n  }\n\n  if (data.type === SERVICE_WORKER_LOG_STATE_RESPONSE) {\n    finalizeServiceWorkerLogRequest(data.requestId || null);\n\n    const state = data.state && typeof data.state === 'object' ? data.state : null;\n    if (!state) {\n      scheduleServiceWorkerLogPoll();\n      return;\n    }\n\n    serviceWorkerBridgeState.lastSnapshotMeta = {\n      cacheName: typeof state.cacheName === 'string' && state.cacheName ? state.cacheName : null,\n      cacheVersion: state.cacheVersion || null,\n      generatedAt: typeof state.generatedAt === 'number' && Number.isFinite(state.generatedAt)\n        ? state.generatedAt\n        : Date.now(),\n      historyLength: typeof state.historyLength === 'number' && Number.isFinite(state.historyLength)\n        ? state.historyLength\n        : null,\n    };\n\n    importServiceWorkerLogEntries(state.history, serviceWorkerBridgeState.lastSnapshotMeta);\n    scheduleServiceWorkerLogPoll();\n  }\n}\n\nfunction requestServiceWorkerLogSnapshot(reason) {\n  if (serviceWorkerBridgeState.requestInFlight) {\n    return;\n  }\n\n  const serviceWorker = getNavigatorServiceWorker();\n  if (!serviceWorker) {\n    return;\n  }\n\n  serviceWorkerBridgeState.supported = true;\n\n  const requestId = `sw-log-${Date.now()}-${Math.random().toString(36).slice(2, 10)}`;\n  serviceWorkerBridgeState.requestInFlight = true;\n  serviceWorkerBridgeState.lastRequestId = requestId;\n\n  const message = {\n    type: SERVICE_WORKER_LOG_STATE_REQUEST,\n    limit: SERVICE_WORKER_LOG_HISTORY_LIMIT,\n    reason: typeof reason === 'string' && reason ? reason : 'sync',\n    requestId,\n  };\n\n  const closeMessageChannel = channel => {\n    if (!channel) {\n      return;\n    }\n\n    try {\n      channel.port1.onmessage = null;\n    } catch (clearHandlerError) {\n      void clearHandlerError;\n    }\n\n    if (typeof channel.port1.onmessageerror !== 'undefined') {\n      try {\n        channel.port1.onmessageerror = null;\n      } catch (clearErrorHandlerError) {\n        void clearErrorHandlerError;\n      }\n    }\n\n    try {\n      channel.port1.close();\n    } catch (closePort1Error) {\n      void closePort1Error;\n    }\n\n    try {\n      channel.port2.close();\n    } catch (closePort2Error) {\n      void closePort2Error;\n    }\n  };\n\n  const readyPromise = serviceWorker.ready && typeof serviceWorker.ready.then === 'function'\n    ? serviceWorker.ready.then(registration => (registration && registration.active) || serviceWorker.controller || null)\n    : Promise.resolve(serviceWorker.controller || null);\n\n  Promise.resolve(readyPromise)\n    .then(worker => {\n      const controller = serviceWorker.controller || null;\n      const targetWorker = worker || controller;\n\n      if (!targetWorker || typeof targetWorker.postMessage !== 'function') {\n        finalizeServiceWorkerLogRequest(requestId);\n        scheduleServiceWorkerLogPoll();\n        return;\n      }\n\n      let settled = false;\n      let channel = null;\n\n      const finalize = () => {\n        if (settled) {\n          return;\n        }\n        settled = true;\n        closeMessageChannel(channel);\n        finalizeServiceWorkerLogRequest(requestId);\n      };\n\n      const finalizeWithPoll = () => {\n        finalize();\n        scheduleServiceWorkerLogPoll();\n      };\n\n      const handleResponse = event => {\n        finalize();\n        handleServiceWorkerLogMessage(event);\n      };\n\n      const handleChannelError = () => {\n        safeWarn('cineLogging: Service worker diagnostics channel closed before a response was received', { requestId });\n        finalizeWithPoll();\n      };\n\n      const postWithoutChannel = () => {\n        try {\n          targetWorker.postMessage(message);\n        } catch (error) {\n          safeWarn('cineLogging: Unable to post service worker diagnostics request', error);\n          finalizeWithPoll();\n          return;\n        }\n\n        if (typeof setTimeout === 'function') {\n          try {\n            serviceWorkerBridgeState.requestTimer = setTimeout(() => {\n              if (settled) {\n                return;\n              }\n              finalizeWithPoll();\n            }, SERVICE_WORKER_LOG_REQUEST_TIMEOUT);\n          } catch (error) {\n            void error;\n          }\n        }\n      };\n\n      const shouldUseMessageChannel = () => {\n        if (typeof MessageChannel !== 'function') {\n          return false;\n        }\n\n        if (!controller) {\n          return false;\n        }\n\n        return targetWorker === controller;\n      };\n\n      if (!shouldUseMessageChannel()) {\n        postWithoutChannel();\n        return;\n      }\n\n      channel = new MessageChannel();\n      channel.port1.onmessage = handleResponse;\n\n      if (typeof channel.port1.onmessageerror !== 'undefined') {\n        channel.port1.onmessageerror = handleChannelError;\n      }\n\n      if (typeof channel.port1.start === 'function') {\n        try {\n          channel.port1.start();\n        } catch (startError) {\n          void startError;\n        }\n      }\n\n      try {\n        targetWorker.postMessage(message, [channel.port2]);\n      } catch (error) {\n        closeMessageChannel(channel);\n        channel = null;\n        safeWarn('cineLogging: Unable to request service worker diagnostics', error);\n        postWithoutChannel();\n        return;\n      }\n\n      if (typeof setTimeout === 'function') {\n        try {\n          serviceWorkerBridgeState.requestTimer = setTimeout(() => {\n            if (settled) {\n              return;\n            }\n            handleChannelError();\n          }, SERVICE_WORKER_LOG_REQUEST_TIMEOUT);\n        } catch (error) {\n          void error;\n        }\n      }\n    })\n    .catch(error => {\n      finalizeServiceWorkerLogRequest(requestId);\n      safeWarn('cineLogging: Unable to await service worker for diagnostics', error);\n      scheduleServiceWorkerLogPoll();\n    });\n}\n\nfunction setupServiceWorkerLogBridge() {\n  if (serviceWorkerBridgeState.initialised) {\n    return;\n  }\n\n  serviceWorkerBridgeState.initialised = true;\n\n  const serviceWorker = getNavigatorServiceWorker();\n  if (!serviceWorker) {\n    return;\n  }\n\n  serviceWorkerBridgeState.supported = true;\n\n  ensureServiceWorkerBroadcastChannel();\n\n  if (typeof serviceWorker.addEventListener === 'function') {\n    try {\n      serviceWorker.addEventListener('message', handleServiceWorkerLogMessage);\n    } catch (error) {\n      safeWarn('cineLogging: Unable to attach service worker diagnostics listener', error);\n    }\n  } else if (typeof serviceWorker.onmessage === 'undefined') {\n    try {\n      serviceWorker.onmessage = handleServiceWorkerLogMessage;\n    } catch (error) {\n      void error;\n    }\n  }\n\n  requestServiceWorkerLogSnapshot('initial-sync');\n  if (!serviceWorkerBridgeState.broadcastChannel) {\n    scheduleServiceWorkerLogPoll();\n  }\n}\n\nfunction loadPersistedHistory() {\n  if (!activeConfig.persistSession) {\n    return;\n  }\n\n  const storage = getSessionStorage();\n  if (!storage) {\n    return;\n  }\n\n  let raw = '';\n  try {\n    raw = storage.getItem(HISTORY_STORAGE_KEY) || '';\n  } catch (error) {\n    void error;\n    return;\n  }\n\n  if (!raw) {\n    return;\n  }\n\n  try {\n    const parsed = JSON.parse(raw);\n    if (!Array.isArray(parsed)) {\n      return;\n    }\n    for (let index = 0; index < parsed.length; index += 1) {\n      const entry = normaliseStoredEntry(parsed[index]);\n      if (entry) {\n        pushEntryToHistory(entry);\n      }\n    }\n    enforceHistoryLimit({ source: 'restore' });\n  } catch (error) {\n    safeWarn('cineLogging: Unable to restore log history from storage', error);\n  }\n}\n\nfunction initialiseConfig() {\n  activeConfig = cloneDefaultConfig();\n\n  const preset = resolveConfigPresetFromScopes();\n  if (preset) {\n    applyConfig(preset);\n  }\n\n  applyConfigFromStorage();\n  applyConfigFromQuery();\n}\n\ninitialiseConfig();\nloadPersistedHistory();\nsetupServiceWorkerLogBridge();\n\nsyncConsoleCaptureState();\n\nif (activeConfig.captureGlobalErrors) {\n  attachGlobalErrorListeners();\n}\n\ndebug(\n  'cineLogging initialized',\n  { config: getConfigSnapshot(), stats: getStats() },\n  { namespace: 'logging', meta: { lifecycle: 'init' } },\n);\n\nconst loggingAPI = freezeDeep({\n  log: logInternal,\n  debug,\n  info,\n  warn,\n  error,\n  createLogger,\n  getHistory,\n  getStats,\n  clearHistory,\n  getConfig: getConfigSnapshot,\n  setConfig,\n  getLevelState,\n  isLevelEnabled,\n  subscribe,\n  subscribeConfig,\n  enableConsoleCapture,\n  disableConsoleCapture,\n  syncConsoleCapture: syncConsoleCaptureState,\n  isConsoleCaptureActive,\n  constants: freezeDeep({\n    LOG_LEVELS,\n    DEFAULT_CONFIG,\n  }),\n});\n\ninformModuleGlobals('cineLogging', loggingAPI);\n\nconst registrationOptions = {\n  category: 'diagnostics',\n  description: 'Structured logging utilities for debugging and diagnostics.',\n  replace: true,\n  connections: ['cineModuleGlobals', 'cineModuleEnvironment', 'cineEnvironmentBridge', 'cineModuleContext'],\n};\n\nconst registered = registerOrQueueModule(\n  'cineLogging',\n  loggingAPI,\n  registrationOptions,\n  function (error) {\n    safeWarn('Unable to register cineLogging module.', error);\n  },\n  GLOBAL_SCOPE,\n  MODULE_REGISTRY,\n);\n\nif (!registered) {\n  queueModuleRegistration('cineLogging', loggingAPI, registrationOptions, GLOBAL_SCOPE);\n}\n\nif (!exposeGlobal('cineLogging', loggingAPI, {\n  configurable: true,\n  enumerable: false,\n  writable: false,\n})) {\n  safeWarn('Unable to expose cineLogging globally.');\n}\n\n// if (typeof module !== 'undefined' && module && module.exports) {\n//   module.exports = loggingAPI;\n// }\n// }) ();\n\nexport const cineLogging = loggingAPI;\n\n","// console-helpers.js - Ensures console methods stay writable for diagnostics tooling.\nconst GLOBAL_SCOPE =\n  typeof globalThis !== 'undefined'\n    ? globalThis\n    : typeof window !== 'undefined'\n      ? window\n      : typeof self !== 'undefined'\n        ? self\n        : typeof global !== 'undefined'\n          ? global\n          : null;\n\nfunction ensureConsoleMethodsWritable(methods) {\n  const scope =\n    (GLOBAL_SCOPE && typeof GLOBAL_SCOPE === 'object' ? GLOBAL_SCOPE : null)\n    || (typeof globalThis !== 'undefined' ? globalThis : null);\n  if (!scope) {\n    return null;\n  }\n\n  let baseConsole;\n  let consoleDescriptor = null;\n  try {\n    baseConsole = scope.console;\n    consoleDescriptor = Object.getOwnPropertyDescriptor(scope, 'console');\n  } catch (consoleReadError) {\n    baseConsole = typeof console !== 'undefined' ? console : null;\n    void consoleReadError;\n  }\n\n  if (!baseConsole || typeof baseConsole !== 'object') {\n    return null;\n  }\n\n  let requestedMethods = [];\n  if (Array.isArray(methods)) {\n    requestedMethods = methods;\n  } else if (typeof methods === 'string' && methods) {\n    requestedMethods = [methods];\n  } else {\n    requestedMethods = ['warn', 'info'];\n  }\n\n  const unique = Object.create(null);\n  for (let i = 0; i < requestedMethods.length; i += 1) {\n    const methodName = requestedMethods[i];\n    if (typeof methodName === 'string' && methodName) {\n      unique[methodName] = true;\n    }\n  }\n\n  const methodNames = Object.keys(unique);\n  if (!methodNames.length) {\n    return baseConsole;\n  }\n\n  const storage = Object.create(null);\n  for (let i = 0; i < methodNames.length; i += 1) {\n    const methodName = methodNames[i];\n    let value = baseConsole[methodName];\n    try {\n      const descriptor = Object.getOwnPropertyDescriptor(baseConsole, methodName);\n      if (descriptor && Object.prototype.hasOwnProperty.call(descriptor, 'value')) {\n        value = descriptor.value;\n      }\n    } catch (descriptorError) {\n      void descriptorError;\n    }\n    if (typeof value === 'function') {\n      try {\n        storage[methodName] = value.bind(baseConsole);\n      } catch (bindError) {\n        storage[methodName] = value;\n        void bindError;\n      }\n    } else {\n      storage[methodName] = value;\n    }\n  }\n\n  const proxy = new Proxy(baseConsole, {\n    get(target, property, receiver) {\n      if (Object.prototype.hasOwnProperty.call(storage, property)) {\n        return storage[property];\n      }\n      return Reflect.get(target, property, receiver);\n    },\n    set(target, property, value, receiver) {\n      if (Object.prototype.hasOwnProperty.call(storage, property)) {\n        storage[property] = value;\n        return true;\n      }\n      try {\n        Reflect.set(target, property, value, receiver);\n        return true;\n      } catch (setError) {\n        void setError;\n      }\n      return false;\n    },\n    defineProperty(target, property, descriptor) {\n      if (Object.prototype.hasOwnProperty.call(storage, property)) {\n        if (descriptor && Object.prototype.hasOwnProperty.call(descriptor, 'value')) {\n          storage[property] = descriptor.value;\n        }\n        return true;\n      }\n      return Reflect.defineProperty(target, property, descriptor);\n    },\n    getOwnPropertyDescriptor(target, property) {\n      if (Object.prototype.hasOwnProperty.call(storage, property)) {\n        return {\n          configurable: true,\n          enumerable: true,\n          writable: true,\n          value: storage[property],\n        };\n      }\n      return Reflect.getOwnPropertyDescriptor(target, property);\n    },\n    ownKeys(target) {\n      const keys = Reflect.ownKeys(target);\n      for (let i = 0; i < methodNames.length; i += 1) {\n        if (keys.indexOf(methodNames[i]) === -1) {\n          keys.push(methodNames[i]);\n        }\n      }\n      return keys;\n    },\n  });\n\n  try {\n    Object.defineProperty(scope, 'console', {\n      configurable: true,\n      enumerable: consoleDescriptor ? consoleDescriptor.enumerable !== false : true,\n      writable: true,\n      value: proxy,\n    });\n  } catch (defineError) {\n    scope.console = proxy;\n    void defineError;\n  }\n\n  return proxy;\n}\n\nexport { ensureConsoleMethodsWritable };\n\nif (GLOBAL_SCOPE && typeof GLOBAL_SCOPE === 'object') {\n  try {\n    if (typeof GLOBAL_SCOPE.__cineEnsureConsoleMethodsWritable !== 'function') {\n      GLOBAL_SCOPE.__cineEnsureConsoleMethodsWritable = ensureConsoleMethodsWritable;\n    }\n  } catch (exposeError) {\n    void exposeError;\n  }\n}\n","import './base.js';\nimport './logging.js';\n\n/* global cineModuleBase */\n\n// ESM Wrapper replacement\n// (function () {\nfunction detectGlobalScope() {\n  if (typeof globalThis !== 'undefined') {\n    return globalThis;\n  }\n  if (typeof window !== 'undefined') {\n    return window;\n  }\n  if (typeof self !== 'undefined') {\n    return self;\n  }\n  if (typeof global !== 'undefined') {\n    return global;\n  }\n  return {};\n}\n\nconst GLOBAL_SCOPE = detectGlobalScope();\n\nfunction resolveModuleBase(scope) {\n  // if (baseApi) return baseApi;\n\n  if (typeof cineModuleBase === 'object' && cineModuleBase) {\n    return cineModuleBase;\n  }\n\n  if (scope && typeof scope.cineModuleBase === 'object') {\n    return scope.cineModuleBase;\n  }\n\n  return null;\n}\n\nconst MODULE_BASE = resolveModuleBase(GLOBAL_SCOPE);\n\nconst baseFreezeDeep = MODULE_BASE && typeof MODULE_BASE.freezeDeep === 'function'\n  ? MODULE_BASE.freezeDeep\n  : function identity(value) {\n    return value;\n  };\n\nconst freezeDeep = value => {\n  try {\n    return baseFreezeDeep(value);\n  } catch (error) {\n    void error;\n    return value;\n  }\n};\n\nfunction fallbackCollectCandidateScopes(primary) {\n  const scopes = [];\n\n  function push(scope) {\n    if (!scope || (typeof scope !== 'object' && typeof scope !== 'function')) {\n      return;\n    }\n    if (scopes.indexOf(scope) === -1) {\n      scopes.push(scope);\n    }\n  }\n\n  if (primary) push(primary);\n  if (typeof globalThis !== 'undefined') push(globalThis);\n  if (typeof window !== 'undefined') push(window);\n  if (typeof self !== 'undefined') push(self);\n  if (typeof global !== 'undefined') push(global);\n\n  return scopes;\n}\n\nconst collectCandidateScopes = MODULE_BASE && typeof MODULE_BASE.collectCandidateScopes === 'function'\n  ? function collect(primary) {\n    try {\n      const result = MODULE_BASE.collectCandidateScopes(primary, GLOBAL_SCOPE);\n      if (Array.isArray(result) && result.length) {\n        return result;\n      }\n    } catch (error) {\n      void error;\n    }\n    return fallbackCollectCandidateScopes(primary || GLOBAL_SCOPE);\n  }\n  : fallbackCollectCandidateScopes;\n\nfunction fallbackSafeWarn(message, detail) {\n  if (typeof console === 'undefined' || typeof console.warn !== 'function') {\n    return;\n  }\n\n  try {\n    if (typeof detail === 'undefined') {\n      console.warn(message);\n    } else {\n      console.warn(message, detail);\n    }\n  } catch (error) {\n    void error;\n  }\n}\n\nconst safeWarn = MODULE_BASE && typeof MODULE_BASE.safeWarn === 'function'\n  ? MODULE_BASE.safeWarn\n  : fallbackSafeWarn;\n\nfunction resolveLoggingFromScope(scope) {\n  if (!scope || (typeof scope !== 'object' && typeof scope !== 'function')) {\n    return null;\n  }\n\n  let logging = null;\n  try {\n    logging = scope.cineLogging || null;\n  } catch (error) {\n    void error;\n    logging = null;\n  }\n\n  if (logging && typeof logging === 'object') {\n    return logging;\n  }\n\n  return null;\n}\n\nfunction tryRequireLogging() {\n  // if (loggingApi && typeof loggingApi === 'object') {\n  //   return loggingApi;\n  // }\n  return null;\n}\n\nfunction resolveLogging(options = {}) {\n  const baseScope = options.baseScope || GLOBAL_SCOPE;\n  const allowRequire = options.allowRequire !== false;\n\n  if (allowRequire) {\n    const required = tryRequireLogging();\n    if (required) {\n      return required;\n    }\n  }\n\n  const scopes = collectCandidateScopes(baseScope);\n  for (let index = 0; index < scopes.length; index += 1) {\n    const logging = resolveLoggingFromScope(scopes[index]);\n    if (logging) {\n      return logging;\n    }\n  }\n\n  return null;\n}\n\nfunction cloneMeta(value, seen = new WeakMap()) {\n  if (value === null || typeof value !== 'object') {\n    return value;\n  }\n\n  if (seen.has(value)) {\n    return seen.get(value);\n  }\n\n  if (Array.isArray(value)) {\n    const clone = [];\n    seen.set(value, clone);\n    for (let index = 0; index < value.length; index += 1) {\n      clone[index] = cloneMeta(value[index], seen);\n    }\n    return clone;\n  }\n\n  const clone = {};\n  seen.set(value, clone);\n  const keys = Object.keys(value);\n  for (let index = 0; index < keys.length; index += 1) {\n    const key = keys[index];\n    clone[key] = cloneMeta(value[key], seen);\n  }\n  return clone;\n}\n\nfunction mergeMeta(baseMeta, meta) {\n  if (!baseMeta && !meta) {\n    return null;\n  }\n\n  if (!baseMeta) {\n    return cloneMeta(meta);\n  }\n\n  if (!meta) {\n    return cloneMeta(baseMeta);\n  }\n\n  if (typeof baseMeta !== 'object' || typeof meta !== 'object') {\n    return cloneMeta(meta);\n  }\n\n  const merged = cloneMeta(baseMeta);\n  const keys = Object.keys(meta);\n  for (let index = 0; index < keys.length; index += 1) {\n    const key = keys[index];\n    merged[key] = cloneMeta(meta[key]);\n  }\n  return merged;\n}\n\nfunction resolveConsoleMethod(level) {\n  if (typeof console === 'undefined' || !console) {\n    return null;\n  }\n\n  const normalized = typeof level === 'string' ? level.toLowerCase() : '';\n\n  if (normalized === 'error' && typeof console.error === 'function') {\n    return console.error.bind(console);\n  }\n  if (normalized === 'warn' && typeof console.warn === 'function') {\n    return console.warn.bind(console);\n  }\n  if (normalized === 'info' && typeof console.info === 'function') {\n    return console.info.bind(console);\n  }\n  if (normalized === 'debug' && typeof console.debug === 'function') {\n    return console.debug.bind(console);\n  }\n  if (typeof console.log === 'function') {\n    return console.log.bind(console);\n  }\n\n  return null;\n}\n\nlet fallbackWarningIssued = false;\n\nfunction createConsoleFallbackLogger(namespace, options = {}) {\n  const normalizedNamespace = typeof namespace === 'string' && namespace.trim()\n    ? namespace.trim()\n    : 'app';\n\n  const baseMeta = options && typeof options.meta !== 'undefined'\n    ? cloneMeta(options.meta)\n    : null;\n\n  function output(level, message, detail, meta) {\n    const consoleMethod = resolveConsoleMethod(level);\n    if (!consoleMethod) {\n      return null;\n    }\n\n    const prefixParts = ['[cine-fallback]'];\n    if (normalizedNamespace) {\n      prefixParts.push(`[${normalizedNamespace}]`);\n    }\n\n    const timestamp = new Date();\n    try {\n      prefixParts.push(timestamp.toISOString());\n    } catch (error) {\n      void error;\n      prefixParts.push(String(timestamp.getTime()));\n    }\n\n    const prefix = prefixParts.join(' ');\n    const resolvedMessage = typeof message === 'string' && message\n      ? message\n      : 'Log entry';\n\n    const args = [`${prefix} ${resolvedMessage}`];\n\n    if (typeof detail !== 'undefined') {\n      args.push(detail);\n    }\n\n    const mergedMeta = mergeMeta(baseMeta, meta);\n    if (mergedMeta) {\n      args.push({ meta: mergedMeta, source: 'console-fallback' });\n    }\n\n    try {\n      consoleMethod(...args);\n    } catch (error) {\n      void error;\n    }\n\n    if (!fallbackWarningIssued && typeof console !== 'undefined' && typeof console.warn === 'function') {\n      fallbackWarningIssued = true;\n      try {\n        console.warn('[cine-fallback] Structured logging unavailable, using console logger.');\n      } catch (warnError) {\n        void warnError;\n      }\n    }\n\n    return null;\n  }\n\n  const logger = {\n    namespace: normalizedNamespace,\n    log(level, message, detail, meta) {\n      return output(level, message, detail, meta);\n    },\n    debug(message, detail, meta) {\n      return output('debug', message, detail, meta);\n    },\n    info(message, detail, meta) {\n      return output('info', message, detail, meta);\n    },\n    warn(message, detail, meta) {\n      return output('warn', message, detail, meta);\n    },\n    error(message, detail, meta) {\n      return output('error', message, detail, meta);\n    },\n    getConfig() {\n      return null;\n    },\n    isLevelEnabled() {\n      return true;\n    },\n    getLevelState(level) {\n      return {\n        level: typeof level === 'string' && level ? level : 'all',\n        enabled: true,\n        source: 'console-fallback',\n      };\n    },\n    __cineLoggingFallback: true,\n  };\n\n  return freezeDeep(logger);\n}\n\nfunction resolveLogger(namespace, options = {}) {\n  const logging = resolveLogging(options);\n  const meta = options && typeof options.meta !== 'undefined' ? options.meta : undefined;\n\n  if (logging && typeof logging.createLogger === 'function') {\n    try {\n      const logger = logging.createLogger(namespace, typeof meta !== 'undefined' ? { meta } : undefined);\n      if (logger) {\n        return logger;\n      }\n    } catch (error) {\n      safeWarn('cineLoggingResolver: createLogger failed, falling back to console.', error);\n    }\n  }\n\n  if (options.allowConsoleFallback === false) {\n    return null;\n  }\n\n  return createConsoleFallbackLogger(namespace, { meta });\n}\n\nconst resolverApi = freezeDeep({\n  resolveLogging,\n  resolveLogger,\n  createConsoleFallbackLogger,\n});\n\nconst registry = MODULE_BASE && typeof MODULE_BASE.resolveModuleRegistry === 'function'\n  ? MODULE_BASE.resolveModuleRegistry(GLOBAL_SCOPE)\n  : null;\n\nif (MODULE_BASE && typeof MODULE_BASE.registerOrQueueModule === 'function') {\n  const registered = MODULE_BASE.registerOrQueueModule(\n    'cineLoggingResolver',\n    resolverApi,\n    {\n      category: 'diagnostics',\n      description: 'Helpers to resolve cineLogging instances and console fallbacks across runtimes.',\n      replace: true,\n      connections: ['cineLogging', 'cineModuleBase', 'cineEnvironmentBridge'],\n    },\n    (error) => {\n      safeWarn('Unable to register cineLoggingResolver module.', error);\n    },\n    GLOBAL_SCOPE,\n    registry,\n  );\n\n  if (!registered && typeof MODULE_BASE.queueModuleRegistration === 'function') {\n    try {\n      MODULE_BASE.queueModuleRegistration(\n        'cineLoggingResolver',\n        resolverApi,\n        {\n          category: 'diagnostics',\n          description: 'Helpers to resolve cineLogging instances and console fallbacks across runtimes.',\n          replace: true,\n        },\n        GLOBAL_SCOPE,\n      );\n    } catch (queueError) {\n      safeWarn('Unable to queue cineLoggingResolver registration.', queueError);\n    }\n  }\n}\n\nif (MODULE_BASE && typeof MODULE_BASE.exposeGlobal === 'function') {\n  MODULE_BASE.exposeGlobal('cineLoggingResolver', resolverApi, GLOBAL_SCOPE, {\n    configurable: true,\n    enumerable: false,\n    writable: false,\n  });\n} else {\n  try {\n    GLOBAL_SCOPE.cineLoggingResolver = resolverApi;\n  } catch (error) {\n    void error;\n  }\n}\n\n/*\nif (typeof module !== 'undefined' && module && module.exports) {\n  module.exports = resolverApi;\n}\n*/\n// ESM Export\nexport { resolverApi as cineLoggingResolver };\nexport default resolverApi;\n\n","/* global cineModuleBase */\n\n// ---------------------------------------------------------------------------\n// Contacts feature module\n// ---------------------------------------------------------------------------\n// The contacts helper keeps personal crew information alongside the power\n// planner project data. Because these records can include critical call sheet\n// notes we keep the implementation intentionally small and well documented.\n// The additional comments below explain how each helper works so that future\n// maintainers understand the user data safeguards without having to reverse\n// engineer the storage flow.\n\n// ESM Version\nfunction detectGlobalScope() {\n  if (typeof globalThis !== 'undefined') {\n    return globalThis;\n  }\n  if (typeof window !== 'undefined') {\n    return window;\n  }\n  if (typeof self !== 'undefined') {\n    return self;\n  }\n  if (typeof global !== 'undefined') {\n    return global;\n  }\n  return {};\n}\n\nconst GLOBAL_SCOPE = detectGlobalScope();\n\nconst MODULE_BASE =\n  (typeof cineModuleBase === 'object' && cineModuleBase)\n  || (GLOBAL_SCOPE && typeof GLOBAL_SCOPE.cineModuleBase === 'object' ? GLOBAL_SCOPE.cineModuleBase : null);\n\n// Prefer the runtime provided logging facade so that diagnostics remain\n// consistent across the application. Falling back to console.warn keeps the\n// module functional inside tests and legacy entry points.\nconst safeWarn = MODULE_BASE && typeof MODULE_BASE.safeWarn === 'function'\n  ? MODULE_BASE.safeWarn\n  : function fallbackWarn(message, error) {\n    if (typeof console === 'undefined' || !console || typeof console.warn !== 'function') {\n      return;\n    }\n    try {\n      if (typeof error === 'undefined') {\n        console.warn(message);\n      } else {\n        console.warn(message, error);\n      }\n    } catch (consoleError) {\n      void consoleError;\n    }\n  };\n\n// Contacts live under a dedicated storage key to avoid colliding with other\n// project level metadata. The name mirrors the legacy implementation so\n// existing backups import cleanly.\nconst CONTACTS_STORAGE_KEY = 'cameraPowerPlanner_contacts';\n\nfunction resolveLocalStorage(scope) {\n  // The helper intentionally accepts an optional scope so that callers can\n  // inject mocked storage instances during tests. When no override is\n  // provided we fall back to the detected global scope.\n  const target = scope || GLOBAL_SCOPE;\n  try {\n    if (target && typeof target.localStorage !== 'undefined') {\n      return target.localStorage;\n    }\n  } catch (error) {\n    safeWarn('cine.features.contacts could not access localStorage.', error);\n  }\n  return null;\n}\n\nfunction generateContactId() {\n  // Persisting a random suffix avoids accidental collisions when multiple\n  // contacts are created in quick succession before the autosave triggers.\n  return `contact-${Date.now().toString(36)}-${Math.random().toString(36).slice(2, 8)}`;\n}\n\nfunction sanitizeContactValue(value) {\n  // Every field in the contact form is stored as a trimmed string so backup\n  // exports stay compact and predictable. Numeric and boolean values from\n  // older backups are coerced to strings instead of being dropped so that no\n  // contact information is lost during migrations.\n  if (typeof value === 'string') {\n    return value.trim();\n  }\n\n  if (typeof value === 'number') {\n    if (!Number.isFinite(value)) {\n      return '';\n    }\n    return String(value).trim();\n  }\n\n  if (typeof value === 'bigint') {\n    try {\n      return value.toString();\n    } catch (bigintError) {\n      void bigintError;\n    }\n    return '';\n  }\n\n  if (typeof value === 'boolean') {\n    return value ? 'true' : 'false';\n  }\n\n  if (value && typeof value === 'object') {\n    try {\n      const primitive = value.valueOf();\n      if (primitive !== value) {\n        return sanitizeContactValue(primitive);\n      }\n\n      if (typeof value.toString === 'function') {\n        const stringified = value.toString();\n        if (typeof stringified === 'string' && stringified && stringified !== '[object Object]') {\n          return stringified.trim();\n        }\n      }\n    } catch (coercionError) {\n      void coercionError;\n    }\n  }\n\n  return '';\n}\n\nfunction normalizeContactEntry(entry) {\n  // The normalisation step ensures that manually constructed contacts (for\n  // example when importing older backups) adopt the latest schema without\n  // mutating the original payload. This is critical for preserving user data\n  // across application upgrades.\n  if (!entry || typeof entry !== 'object') {\n    return null;\n  }\n\n  const id = sanitizeContactValue(entry.id) || generateContactId();\n  const name = sanitizeContactValue(entry.name);\n  const role = sanitizeContactValue(entry.role);\n  const phone = sanitizeContactValue(entry.phone);\n  const email = sanitizeContactValue(entry.email);\n  const website = sanitizeContactValue(entry.website || entry.url);\n  const notes = sanitizeContactValue(entry.notes || entry.note || entry.text);\n  const avatar = typeof entry.avatar === 'string' && entry.avatar.startsWith('data:')\n    ? entry.avatar\n    : '';\n  const createdAt = Number.isFinite(entry.createdAt) ? entry.createdAt : Date.now();\n  const updatedAt = Number.isFinite(entry.updatedAt) ? entry.updatedAt : createdAt;\n\n  const normalized = { id, name, role, phone, email, website, notes, createdAt, updatedAt };\n  if (avatar) {\n    normalized.avatar = avatar;\n  }\n\n  return normalized;\n}\n\nfunction sortContacts(list) {\n  // Contacts are sorted alphabetically so that the UI provides a predictable\n  // reading order. When names are missing we fall back to creation time which\n  // keeps imported records stable.\n  return (Array.isArray(list) ? list.filter(Boolean) : [])\n    .map(normalizeContactEntry)\n    .filter(Boolean)\n    .sort((a, b) => {\n      const nameA = (a && a.name ? a.name : '').toLowerCase();\n      const nameB = (b && b.name ? b.name : '').toLowerCase();\n      if (nameA && nameB && nameA !== nameB) {\n        try {\n          return nameA.localeCompare(nameB);\n        } catch (error) {\n          safeWarn('cine.features.contacts could not sort contacts by locale.', error);\n        }\n      }\n      if (nameA && !nameB) {\n        return -1;\n      }\n      if (!nameA && nameB) {\n        return 1;\n      }\n      return (a && a.createdAt ? a.createdAt : 0) - (b && b.createdAt ? b.createdAt : 0);\n    });\n}\n\nfunction loadStoredContacts(options = {}) {\n  // The load helper wraps JSON.parse inside a try/catch so that a single\n  // corrupted entry never risks crashing the surrounding autosave recovery.\n  const storage = resolveLocalStorage(options.scope);\n  if (!storage || typeof storage.getItem !== 'function') {\n    return [];\n  }\n  const storageKey = typeof options.storageKey === 'string' && options.storageKey\n    ? options.storageKey\n    : CONTACTS_STORAGE_KEY;\n\n  try {\n    const raw = storage.getItem(storageKey);\n    if (!raw) {\n      return [];\n    }\n    const parsed = JSON.parse(raw);\n    if (!Array.isArray(parsed)) {\n      return [];\n    }\n    return sortContacts(parsed);\n  } catch (error) {\n    safeWarn('cine.features.contacts could not load contacts from storage.', error);\n    return [];\n  }\n}\n\nfunction saveContactsToStorage(contacts, options = {}) {\n  // We serialise the entire contact list in one go to avoid partial writes.\n  // This keeps backups and offline snapshots coherent even if the browser\n  // crashes mid-operation.\n  const storage = resolveLocalStorage(options.scope);\n  if (!storage || typeof storage.setItem !== 'function') {\n    return false;\n  }\n  const storageKey = typeof options.storageKey === 'string' && options.storageKey\n    ? options.storageKey\n    : CONTACTS_STORAGE_KEY;\n\n  try {\n    storage.setItem(storageKey, JSON.stringify(Array.isArray(contacts) ? contacts : []));\n    return true;\n  } catch (error) {\n    safeWarn('cine.features.contacts could not save contacts to storage.', error);\n    return false;\n  }\n}\n\nconst moduleApi = Object.freeze({\n  CONTACTS_STORAGE_KEY,\n  generateContactId,\n  sanitizeContactValue,\n  normalizeContactEntry,\n  sortContacts,\n  loadStoredContacts,\n  saveContactsToStorage,\n});\n\nif (MODULE_BASE && typeof MODULE_BASE.registerOrQueueModule === 'function') {\n  try {\n    MODULE_BASE.registerOrQueueModule(\n      'cine.features.contacts',\n      moduleApi,\n      {\n        category: 'features',\n        description: 'Shared helpers for contacts management.',\n        replace: true,\n        connections: ['cineModuleBase', 'cineModuleGlobals', 'cinePersistence'],\n      },\n      (error) => safeWarn('Unable to register cine.features.contacts module.', error),\n      GLOBAL_SCOPE,\n      MODULE_BASE.getModuleRegistry && MODULE_BASE.getModuleRegistry(GLOBAL_SCOPE),\n    );\n  } catch (error) {\n    safeWarn('cine.features.contacts registration failed.', error);\n  }\n}\n\nlet exposedViaModuleBase = false;\nif (MODULE_BASE && typeof MODULE_BASE.exposeGlobal === 'function') {\n  try {\n    MODULE_BASE.exposeGlobal('cineFeaturesContacts', moduleApi, GLOBAL_SCOPE, {\n      configurable: true,\n      enumerable: false,\n      writable: false,\n    });\n    exposedViaModuleBase = true;\n  } catch (error) {\n    safeWarn('cine.features.contacts could not expose global api.', error);\n  }\n}\n\nif (!exposedViaModuleBase) {\n  try {\n    GLOBAL_SCOPE.cineFeaturesContacts = moduleApi;\n  } catch (error) {\n    safeWarn('cine.features.contacts could not assign global api.', error);\n  }\n}\n\n// ESM Export\nexport default moduleApi;\n","/**\n * @interface StorageInterface\n * Defines the standard contract for all storage drivers (LocalStorage, IndexedDB, etc.).\n * All methods must return Promises to ensure future compatibility with asynchronous engines.\n */\nexport default class StorageInterface {\n    /**\n     * Initialize the storage driver\n     * @returns {Promise<void>}\n     */\n    async init() {\n        throw new Error('Method \"init()\" must be implemented.');\n    }\n\n    /**\n     * Retrieve an item by key\n     * @param {string} key \n     * @returns {Promise<any>} The parsed value or null\n     */\n    async getItem(key) {\n        throw new Error('Method \"getItem()\" must be implemented.');\n    }\n\n    /**\n     * Save an item by key\n     * @param {string} key \n     * @param {any} value \n     * @returns {Promise<void>}\n     */\n    async setItem(key, value) {\n        throw new Error('Method \"setItem()\" must be implemented.');\n    }\n\n    /**\n     * Remove an item by key\n     * @param {string} key \n     * @returns {Promise<void>}\n     */\n    async removeItem(key) {\n        throw new Error('Method \"removeItem()\" must be implemented.');\n    }\n\n    /**\n     * Clear all keys managed by this driver context\n     * @returns {Promise<void>}\n     */\n    async clear() {\n        throw new Error('Method \"clear()\" must be implemented.');\n    }\n\n    /**\n     * Get all keys stored by this driver\n     * @returns {Promise<string[]>}\n     */\n    async getKeys() {\n        throw new Error('Method \"getKeys()\" must be implemented.');\n    }\n}\n","import StorageInterface from '../StorageInterface.js';\n\n/**\n * @class LocalStorageAdapter\n * Adapts specific localStorage operations to the standard asynchronous StorageInterface.\n * Acts as a backward-compatibility layer.\n */\nexport default class LocalStorageAdapter extends StorageInterface {\n    constructor() {\n        super();\n        this.storage = window.localStorage;\n    }\n\n    /** @override */\n    async init() {\n        // LocalStorage is synchronous and always ready (if available)\n        if (!this.storage) {\n            throw new Error('LocalStorage is not supported in this environment.');\n        }\n        return Promise.resolve();\n    }\n\n    /** @override */\n    async getItem(key) {\n        try {\n            const raw = this.storage.getItem(key);\n            if (raw === null) return null;\n            // Attempt generic JSON parse, fallback to raw string if it's not JSON\n            try {\n                return JSON.parse(raw);\n            } catch {\n                return raw;\n            }\n        } catch (e) {\n            console.warn(`[LocalStorageAdapter] Failed to get item: ${key}`, e);\n            return null;\n        }\n    }\n\n    /** @override */\n    async setItem(key, value) {\n        try {\n            // Store strings directly, object/arrays as JSON\n            const payload = typeof value === 'string' ? value : JSON.stringify(value);\n            this.storage.setItem(key, payload);\n        } catch (e) {\n            console.error(`[LocalStorageAdapter] Failed to save item: ${key}`, e);\n            throw e; // Propagate error (e.g., QuotaExceededError)\n        }\n    }\n\n    /** @override */\n    async removeItem(key) {\n        try {\n            this.storage.removeItem(key);\n        } catch (e) {\n            console.warn(`[LocalStorageAdapter] Failed to remove item: ${key}`, e);\n        }\n    }\n\n    /** @override */\n    async clear() {\n        try {\n            this.storage.clear();\n        } catch (e) {\n            console.warn('[LocalStorageAdapter] Failed to clear storage', e);\n        }\n    }\n\n    /** @override */\n    async getKeys() {\n        return Object.keys(this.storage);\n    }\n}\n","/**\n * @class UserContext\n * Manages the current user identity (UUID) and device identity for sync/locks.\n * - userId: Persistent anonymous identifier for the user (survives factory reset on same device)\n * - deviceId: Per-browser-profile identifier for lock management\n * - sessionId: Per-tab identifier for fine-grained lock tracking\n */\nexport class UserContext {\n    constructor() {\n        this.userId = null;\n        this.deviceId = null;\n        this.sessionId = null;\n        this.storageKey = 'cine_user_uuid';\n        this.deviceStorageKey = 'cine_device_uuid';\n    }\n\n    /**\n     * Generates a cryptographically random UUID or fallback.\n     * @returns {string}\n     */\n    generateUUID() {\n        if (typeof crypto !== 'undefined' && crypto.randomUUID) {\n            return crypto.randomUUID();\n        }\n        // Fallback for older environments\n        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {\n            const r = (Math.random() * 16) | 0;\n            const v = c === 'x' ? r : (r & 0x3) | 0x8;\n            return v.toString(16);\n        });\n    }\n\n    /**\n     * Initializes the user context.\n     * Checks localStorage for existing UUID, otherwise generates one.\n     */\n    init() {\n        if (this.userId && this.deviceId && this.sessionId) return this.userId;\n\n        // User ID (persistent across sessions)\n        let uuid = localStorage.getItem(this.storageKey);\n        if (!uuid) {\n            uuid = this.generateUUID();\n            localStorage.setItem(this.storageKey, uuid);\n            console.log('[UserContext] Generated new User UUID:', uuid);\n        } else {\n            console.log('[UserContext] Loaded User UUID:', uuid);\n        }\n        this.userId = uuid;\n\n        // Device ID (persistent per browser profile, for cross-tab coordination)\n        let deviceId = localStorage.getItem(this.deviceStorageKey);\n        if (!deviceId) {\n            deviceId = this.generateUUID();\n            localStorage.setItem(this.deviceStorageKey, deviceId);\n            console.log('[UserContext] Generated new Device UUID:', deviceId);\n        }\n        this.deviceId = deviceId;\n\n        // Session ID (unique per tab, for lock granularity)\n        this.sessionId = this.generateUUID();\n        console.log('[UserContext] Session UUID:', this.sessionId);\n\n        return uuid;\n    }\n\n    getUserId() {\n        if (!this.userId) return this.init();\n        return this.userId;\n    }\n\n    /**\n     * Returns the device UUID (unique per browser profile).\n     * Used for cross-device lock detection via cloud sync.\n     */\n    getDeviceId() {\n        if (!this.deviceId) this.init();\n        return this.deviceId;\n    }\n\n    /**\n     * Returns the session UUID (unique per tab).\n     * Used for same-device, cross-tab lock coordination.\n     */\n    getSessionId() {\n        if (!this.sessionId) this.init();\n        return this.sessionId;\n    }\n\n    /**\n     * Scopes a storage key with the current user ID.\n     * @param {string} key \n     */\n    getScopedKey(key) {\n        const uuid = this.getUserId();\n        return `user_${uuid}_${key}`;\n    }\n\n    /**\n     * Returns a full identity object for sync metadata.\n     */\n    getIdentity() {\n        return {\n            userId: this.getUserId(),\n            deviceId: this.getDeviceId(),\n            sessionId: this.getSessionId(),\n        };\n    }\n\n    /**\n     * Clears the user identity (Factory Reset).\n     * Note: Does NOT clear deviceId to maintain device tracking.\n     */\n    reset() {\n        localStorage.removeItem(this.storageKey);\n        this.userId = null;\n        this.sessionId = null;\n    }\n}\n\nexport const userContext = new UserContext();\n\n","import { userContext } from '../core/UserContext.js';\n\n/**\n * @module SyncMetadata\n * \n * Provides metadata wrappers for all stored data to enable:\n * - Offline-first sync with Firebase\n * - Conflict detection and resolution\n * - Lock management timestamps\n * - Change tracking at document level\n * \n * All data stored through the sync-aware API gets wrapped with _meta.\n */\n\n// Schema version for future migrations\nconst SYNC_METADATA_VERSION = 1;\n\n// Sync status constants\nexport const SyncStatus = Object.freeze({\n    /** Data has been synced to cloud */\n    SYNCED: 'synced',\n    /** Data has local changes not yet synced */\n    PENDING: 'pending',\n    /** Data has conflicts that need resolution */\n    CONFLICT: 'conflict',\n    /** Data is being synced right now */\n    SYNCING: 'syncing',\n    /** Data has never been synced (new) */\n    LOCAL_ONLY: 'local_only',\n});\n\n// Lock status constants\nexport const LockStatus = Object.freeze({\n    /** No lock held */\n    UNLOCKED: 'unlocked',\n    /** Locked by current session */\n    LOCKED_BY_SELF: 'locked_by_self',\n    /** Locked by another session on same device */\n    LOCKED_BY_OTHER_TAB: 'locked_by_other_tab',\n    /** Locked by another device */\n    LOCKED_BY_OTHER_DEVICE: 'locked_by_other_device',\n});\n\n/**\n * Generates an ISO timestamp string.\n * @returns {string}\n */\nfunction nowISO() {\n    return new Date().toISOString();\n}\n\n/**\n * Generates a unique document ID.\n * @param {string} [prefix] - Optional prefix for the ID\n * @returns {string}\n */\nexport function generateDocId(prefix = 'doc') {\n    const timestamp = Date.now().toString(36);\n    const random = Math.random().toString(36).substring(2, 10);\n    return `${prefix}_${timestamp}_${random}`;\n}\n\n/**\n * Creates fresh sync metadata for a new document.\n * @param {Object} options - Options for metadata creation\n * @param {string} [options.docId] - Document ID (generated if not provided)\n * @param {string} [options.docType] - Type of document (e.g., 'project', 'settings')\n * @returns {Object} Fresh metadata object\n */\nexport function createSyncMetadata(options = {}) {\n    const identity = userContext.getIdentity();\n    const now = nowISO();\n\n    return {\n        version: SYNC_METADATA_VERSION,\n        docId: options.docId || generateDocId(options.docType || 'doc'),\n        docType: options.docType || 'unknown',\n\n        // Ownership\n        ownerId: identity.userId,\n\n        // Timestamps\n        createdAt: now,\n        updatedAt: now,\n\n        // Sync state\n        syncStatus: SyncStatus.LOCAL_ONLY,\n        syncedAt: null,\n        syncError: null,\n\n        // Change tracking\n        changeCount: 1,\n        lastChangeBy: identity.userId,\n        lastChangeDevice: identity.deviceId,\n        lastChangeSession: identity.sessionId,\n\n        // Lock state (for active editing)\n        lock: null, // Will be { deviceId, sessionId, acquiredAt, heartbeat } when locked\n\n        // Collaboration (future)\n        sharedWith: [], // Array of user IDs\n        permissions: {}, // { userId: 'read' | 'write' | 'admin' }\n    };\n}\n\n/**\n * Updates sync metadata when data is modified.\n * @param {Object} existingMeta - Current metadata\n * @returns {Object} Updated metadata\n */\nexport function updateSyncMetadata(existingMeta) {\n    if (!existingMeta || typeof existingMeta !== 'object') {\n        return createSyncMetadata();\n    }\n\n    const identity = userContext.getIdentity();\n    const now = nowISO();\n\n    return {\n        ...existingMeta,\n        version: SYNC_METADATA_VERSION,\n        updatedAt: now,\n        syncStatus: existingMeta.syncStatus === SyncStatus.SYNCED\n            ? SyncStatus.PENDING\n            : existingMeta.syncStatus,\n        changeCount: (existingMeta.changeCount || 0) + 1,\n        lastChangeBy: identity.userId,\n        lastChangeDevice: identity.deviceId,\n        lastChangeSession: identity.sessionId,\n    };\n}\n\n/**\n * Marks metadata as successfully synced.\n * @param {Object} existingMeta - Current metadata\n * @param {string} [serverTimestamp] - Server timestamp if available\n * @returns {Object} Updated metadata\n */\nexport function markAsSynced(existingMeta, serverTimestamp = null) {\n    if (!existingMeta || typeof existingMeta !== 'object') {\n        console.warn('[SyncMetadata] Cannot mark null metadata as synced');\n        return existingMeta;\n    }\n\n    return {\n        ...existingMeta,\n        syncStatus: SyncStatus.SYNCED,\n        syncedAt: serverTimestamp || nowISO(),\n        syncError: null,\n    };\n}\n\n/**\n * Marks metadata as having a sync conflict.\n * @param {Object} existingMeta - Current metadata\n * @param {string} errorMessage - Conflict description\n * @returns {Object} Updated metadata\n */\nexport function markAsConflict(existingMeta, errorMessage) {\n    if (!existingMeta || typeof existingMeta !== 'object') {\n        return existingMeta;\n    }\n\n    return {\n        ...existingMeta,\n        syncStatus: SyncStatus.CONFLICT,\n        syncError: errorMessage,\n    };\n}\n\n/**\n * Wraps raw data with sync metadata.\n * @param {any} data - The actual data to store\n * @param {Object} [existingMeta] - Existing metadata to update, or null for new\n * @param {Object} [options] - Options for new metadata\n * @returns {Object} Wrapped data with _meta\n */\nexport function wrapWithMetadata(data, existingMeta = null, options = {}) {\n    const meta = existingMeta\n        ? updateSyncMetadata(existingMeta)\n        : createSyncMetadata(options);\n\n    return {\n        _meta: meta,\n        data: data,\n    };\n}\n\n/**\n * Unwraps data from metadata wrapper.\n * @param {Object} wrapped - Data with _meta wrapper\n * @returns {{ data: any, meta: Object }} Separated data and metadata\n */\nexport function unwrapMetadata(wrapped) {\n    if (!wrapped || typeof wrapped !== 'object') {\n        return { data: wrapped, meta: null };\n    }\n\n    // Check if this is wrapped data\n    if (wrapped._meta && 'data' in wrapped) {\n        return { data: wrapped.data, meta: wrapped._meta };\n    }\n\n    // Legacy data without metadata wrapper\n    return { data: wrapped, meta: null };\n}\n\n/**\n * Checks if data has sync metadata.\n * @param {any} data - Data to check\n * @returns {boolean}\n */\nexport function hasMetadata(data) {\n    return data && typeof data === 'object' && '_meta' in data && 'data' in data;\n}\n\n/**\n * Determines the lock status of a document relative to current session.\n * @param {Object} meta - Document metadata\n * @returns {string} One of LockStatus values\n */\nexport function getLockStatus(meta) {\n    if (!meta || !meta.lock) {\n        return LockStatus.UNLOCKED;\n    }\n\n    const identity = userContext.getIdentity();\n    const lock = meta.lock;\n\n    // Check if lock has expired (30 second heartbeat timeout)\n    const lockAge = Date.now() - new Date(lock.heartbeat || lock.acquiredAt).getTime();\n    if (lockAge > 30000) {\n        return LockStatus.UNLOCKED; // Lock expired\n    }\n\n    // Check session ownership\n    if (lock.sessionId === identity.sessionId) {\n        return LockStatus.LOCKED_BY_SELF;\n    }\n\n    // Check device ownership\n    if (lock.deviceId === identity.deviceId) {\n        return LockStatus.LOCKED_BY_OTHER_TAB;\n    }\n\n    return LockStatus.LOCKED_BY_OTHER_DEVICE;\n}\n\n/**\n * Creates a lock object for the current session.\n * @returns {Object} Lock object\n */\nexport function createLock() {\n    const identity = userContext.getIdentity();\n    const now = nowISO();\n\n    return {\n        userId: identity.userId,\n        deviceId: identity.deviceId,\n        sessionId: identity.sessionId,\n        acquiredAt: now,\n        heartbeat: now,\n    };\n}\n\n/**\n * Updates the heartbeat timestamp of an existing lock.\n * @param {Object} lock - Existing lock object\n * @returns {Object} Updated lock object\n */\nexport function updateLockHeartbeat(lock) {\n    if (!lock) return createLock();\n\n    return {\n        ...lock,\n        heartbeat: nowISO(),\n    };\n}\n\n/**\n * Gets items that need syncing from an array of wrapped items.\n * @param {Array} items - Array of wrapped data items\n * @returns {Array} Items with pending sync status\n */\nexport function getPendingSyncItems(items) {\n    if (!Array.isArray(items)) return [];\n\n    return items.filter(item => {\n        if (!hasMetadata(item)) return false;\n        const { meta } = unwrapMetadata(item);\n        return meta && (\n            meta.syncStatus === SyncStatus.PENDING ||\n            meta.syncStatus === SyncStatus.LOCAL_ONLY\n        );\n    });\n}\n\nexport default {\n    SyncStatus,\n    LockStatus,\n    generateDocId,\n    createSyncMetadata,\n    updateSyncMetadata,\n    markAsSynced,\n    markAsConflict,\n    wrapWithMetadata,\n    unwrapMetadata,\n    hasMetadata,\n    getLockStatus,\n    createLock,\n    updateLockHeartbeat,\n    getPendingSyncItems,\n};\n","import { userContext } from '../core/UserContext.js';\nimport {\n    createLock,\n    updateLockHeartbeat,\n    getLockStatus,\n    LockStatus\n} from './SyncMetadata.js';\n\n/**\n * @class ProjectLockService\n * \n * Manages project edit locks to prevent simultaneous editing across:\n * - Multiple browser tabs (same device)\n * - Multiple devices (via cloud sync)\n * \n * Lock Strategy:\n * 1. BroadcastChannel for instant cross-tab coordination (same browser)\n * 2. localStorage/IndexedDB heartbeats for persistence (survives page refresh)\n * 3. Cloud lock document for cross-device coordination (future Firebase)\n * \n * Lock Lifecycle:\n * - Acquire: Check if unlocked  Set lock  Start heartbeat\n * - Heartbeat: Update timestamp every 5s to prove \"still alive\"\n * - Release: Clear lock on page unload or explicit release\n * - Takeover: Force acquire when user confirms takeover prompt\n * \n * Timeout: Lock expires if heartbeat not updated for 30 seconds\n */\n\nconst LOCK_CHANNEL_NAME = 'cine-project-locks';\nconst HEARTBEAT_INTERVAL_MS = 5000; // 5 seconds\nconst LOCK_TIMEOUT_MS = 30000; // 30 seconds\nconst LOCK_STORAGE_PREFIX = 'cine_project_lock_';\n\n// Event types for BroadcastChannel\nconst LockEvent = Object.freeze({\n    LOCK_ACQUIRED: 'lock_acquired',\n    LOCK_RELEASED: 'lock_released',\n    LOCK_HEARTBEAT: 'lock_heartbeat',\n    LOCK_TAKEOVER: 'lock_takeover',\n    LOCK_QUERY: 'lock_query',\n    LOCK_STATUS: 'lock_status',\n});\n\n/**\n * @typedef {Object} Lock\n * @property {string} projectId - The project being locked\n * @property {string} userId - Owner of the lock\n * @property {string} deviceId - Device holding the lock\n * @property {string} sessionId - Tab/session holding the lock\n * @property {string} acquiredAt - ISO timestamp when lock was acquired\n * @property {string} heartbeat - ISO timestamp of last heartbeat\n */\n\nclass ProjectLockService {\n    constructor() {\n        /** @type {BroadcastChannel|null} */\n        this.channel = null;\n\n        /** @type {Map<string, Lock>} Project ID -> Lock */\n        this.localLocks = new Map();\n\n        /** @type {Map<string, number>} Project ID -> Interval ID */\n        this.heartbeatIntervals = new Map();\n\n        /** @type {Set<Function>} */\n        this.lockChangeListeners = new Set();\n\n        /** @type {boolean} */\n        this.initialized = false;\n    }\n\n    /**\n     * Initializes the lock service.\n     * Must be called before using any lock operations.\n     */\n    init() {\n        if (this.initialized) return;\n\n        // Ensure UserContext is initialized\n        userContext.init();\n\n        // Setup BroadcastChannel for cross-tab coordination\n        if (typeof BroadcastChannel !== 'undefined') {\n            try {\n                this.channel = new BroadcastChannel(LOCK_CHANNEL_NAME);\n                this.channel.onmessage = (event) => this._handleChannelMessage(event);\n                console.log('[ProjectLockService] BroadcastChannel initialized');\n            } catch (err) {\n                console.warn('[ProjectLockService] BroadcastChannel not available:', err);\n            }\n        }\n\n        // Restore locks from localStorage (for page refresh scenarios)\n        this._restoreLocksFromStorage();\n\n        // Setup page unload handler to release locks\n        if (typeof window !== 'undefined') {\n            window.addEventListener('beforeunload', () => this._handlePageUnload());\n            window.addEventListener('pagehide', () => this._handlePageUnload());\n        }\n\n        this.initialized = true;\n        console.log('[ProjectLockService] Initialized');\n    }\n\n    /**\n     * Attempts to acquire a lock on a project.\n     * @param {string} projectId - Project to lock\n     * @param {Object} [options] - Lock options\n     * @param {boolean} [options.force] - Force takeover even if locked by another\n     * @returns {Promise<{ success: boolean, status: string, lock: Lock|null }>}\n     */\n    async acquireLock(projectId, options = {}) {\n        this.init();\n\n        const existingLock = this._getStoredLock(projectId);\n        const status = this._getLockStatusForLock(existingLock);\n\n        // Already locked by current session\n        if (status === LockStatus.LOCKED_BY_SELF) {\n            return { success: true, status, lock: existingLock };\n        }\n\n        // Locked by another and not forcing takeover\n        if (status !== LockStatus.UNLOCKED && !options.force) {\n            return { success: false, status, lock: existingLock };\n        }\n\n        // If forcing takeover, notify the other session\n        if (options.force && existingLock) {\n            this._broadcastTakeover(projectId, existingLock);\n        }\n\n        // Create and store the lock\n        const lock = this._createLockObject(projectId);\n        this._storeLock(projectId, lock);\n        this.localLocks.set(projectId, lock);\n\n        // Start heartbeat\n        this._startHeartbeat(projectId);\n\n        // Notify other tabs\n        this._broadcastLockAcquired(projectId, lock);\n\n        // Notify local listeners\n        this._notifyListeners(projectId, LockStatus.LOCKED_BY_SELF, lock);\n\n        console.log('[ProjectLockService] Lock acquired:', projectId);\n        return { success: true, status: LockStatus.LOCKED_BY_SELF, lock };\n    }\n\n    /**\n     * Releases a lock on a project.\n     * @param {string} projectId - Project to unlock\n     * @returns {Promise<boolean>} Whether release was successful\n     */\n    async releaseLock(projectId) {\n        this.init();\n\n        const existingLock = this._getStoredLock(projectId);\n        const status = this._getLockStatusForLock(existingLock);\n\n        // Can only release own locks\n        if (status !== LockStatus.LOCKED_BY_SELF) {\n            console.warn('[ProjectLockService] Cannot release lock not owned by this session');\n            return false;\n        }\n\n        // Stop heartbeat\n        this._stopHeartbeat(projectId);\n\n        // Remove lock\n        this._clearStoredLock(projectId);\n        this.localLocks.delete(projectId);\n\n        // Notify other tabs\n        this._broadcastLockReleased(projectId);\n\n        // Notify local listeners\n        this._notifyListeners(projectId, LockStatus.UNLOCKED, null);\n\n        console.log('[ProjectLockService] Lock released:', projectId);\n        return true;\n    }\n\n    /**\n     * Gets the current lock status for a project.\n     * @param {string} projectId - Project to check\n     * @returns {{ status: string, lock: Lock|null, isEditable: boolean }}\n     */\n    getLockInfo(projectId) {\n        this.init();\n\n        const lock = this._getStoredLock(projectId);\n        const status = this._getLockStatusForLock(lock);\n\n        return {\n            status,\n            lock: lock,\n            isEditable: status === LockStatus.UNLOCKED || status === LockStatus.LOCKED_BY_SELF,\n        };\n    }\n\n    /**\n     * Subscribes to lock change events.\n     * @param {Function} callback - Called with (projectId, status, lock)\n     * @returns {Function} Unsubscribe function\n     */\n    subscribe(callback) {\n        this.lockChangeListeners.add(callback);\n        return () => this.lockChangeListeners.delete(callback);\n    }\n\n    /**\n     * Refreshes the heartbeat for a lock.\n     * Called automatically, but can be triggered manually.\n     * @param {string} projectId \n     */\n    refreshHeartbeat(projectId) {\n        const lock = this.localLocks.get(projectId);\n        if (!lock) return;\n\n        const identity = userContext.getIdentity();\n\n        // Verify we still own this lock\n        if (lock.sessionId !== identity.sessionId) {\n            this._stopHeartbeat(projectId);\n            return;\n        }\n\n        // Update heartbeat\n        lock.heartbeat = new Date().toISOString();\n        this._storeLock(projectId, lock);\n\n        // Notify other tabs\n        this._broadcastHeartbeat(projectId, lock);\n    }\n\n    // --- Private Methods ---\n\n    _createLockObject(projectId) {\n        const identity = userContext.getIdentity();\n        const now = new Date().toISOString();\n\n        return {\n            projectId,\n            userId: identity.userId,\n            deviceId: identity.deviceId,\n            sessionId: identity.sessionId,\n            acquiredAt: now,\n            heartbeat: now,\n        };\n    }\n\n    _getStorageKey(projectId) {\n        return LOCK_STORAGE_PREFIX + projectId;\n    }\n\n    _storeLock(projectId, lock) {\n        try {\n            localStorage.setItem(this._getStorageKey(projectId), JSON.stringify(lock));\n        } catch (err) {\n            console.warn('[ProjectLockService] Failed to store lock:', err);\n        }\n    }\n\n    _getStoredLock(projectId) {\n        try {\n            const data = localStorage.getItem(this._getStorageKey(projectId));\n            if (!data) return null;\n\n            const lock = JSON.parse(data);\n\n            // Check if lock has expired\n            if (this._isLockExpired(lock)) {\n                this._clearStoredLock(projectId);\n                return null;\n            }\n\n            return lock;\n        } catch (err) {\n            console.warn('[ProjectLockService] Failed to read lock:', err);\n            return null;\n        }\n    }\n\n    _clearStoredLock(projectId) {\n        try {\n            localStorage.removeItem(this._getStorageKey(projectId));\n        } catch (err) {\n            console.warn('[ProjectLockService] Failed to clear lock:', err);\n        }\n    }\n\n    _isLockExpired(lock) {\n        if (!lock || !lock.heartbeat) return true;\n        const age = Date.now() - new Date(lock.heartbeat).getTime();\n        return age > LOCK_TIMEOUT_MS;\n    }\n\n    _getLockStatusForLock(lock) {\n        if (!lock || this._isLockExpired(lock)) {\n            return LockStatus.UNLOCKED;\n        }\n\n        const identity = userContext.getIdentity();\n\n        if (lock.sessionId === identity.sessionId) {\n            return LockStatus.LOCKED_BY_SELF;\n        }\n\n        if (lock.deviceId === identity.deviceId) {\n            return LockStatus.LOCKED_BY_OTHER_TAB;\n        }\n\n        return LockStatus.LOCKED_BY_OTHER_DEVICE;\n    }\n\n    _startHeartbeat(projectId) {\n        this._stopHeartbeat(projectId); // Clear any existing\n\n        const intervalId = setInterval(() => {\n            this.refreshHeartbeat(projectId);\n        }, HEARTBEAT_INTERVAL_MS);\n\n        this.heartbeatIntervals.set(projectId, intervalId);\n    }\n\n    _stopHeartbeat(projectId) {\n        const intervalId = this.heartbeatIntervals.get(projectId);\n        if (intervalId) {\n            clearInterval(intervalId);\n            this.heartbeatIntervals.delete(projectId);\n        }\n    }\n\n    _restoreLocksFromStorage() {\n        const identity = userContext.getIdentity();\n\n        try {\n            for (let i = 0; i < localStorage.length; i++) {\n                const key = localStorage.key(i);\n                if (!key || !key.startsWith(LOCK_STORAGE_PREFIX)) continue;\n\n                const projectId = key.slice(LOCK_STORAGE_PREFIX.length);\n                const lock = this._getStoredLock(projectId);\n\n                // Only restore locks owned by this session\n                if (lock && lock.sessionId === identity.sessionId) {\n                    this.localLocks.set(projectId, lock);\n                    this._startHeartbeat(projectId);\n                    console.log('[ProjectLockService] Restored lock:', projectId);\n                }\n            }\n        } catch (err) {\n            console.warn('[ProjectLockService] Failed to restore locks:', err);\n        }\n    }\n\n    _handlePageUnload() {\n        // Release all locks held by this session\n        for (const projectId of this.localLocks.keys()) {\n            this._stopHeartbeat(projectId);\n            this._clearStoredLock(projectId);\n            this._broadcastLockReleased(projectId);\n        }\n        this.localLocks.clear();\n    }\n\n    _notifyListeners(projectId, status, lock) {\n        for (const callback of this.lockChangeListeners) {\n            try {\n                callback(projectId, status, lock);\n            } catch (err) {\n                console.warn('[ProjectLockService] Listener error:', err);\n            }\n        }\n    }\n\n    // --- BroadcastChannel Methods ---\n\n    _broadcast(type, data) {\n        if (!this.channel) return;\n        try {\n            this.channel.postMessage({ type, ...data });\n        } catch (err) {\n            console.warn('[ProjectLockService] Broadcast failed:', err);\n        }\n    }\n\n    _broadcastLockAcquired(projectId, lock) {\n        this._broadcast(LockEvent.LOCK_ACQUIRED, { projectId, lock });\n    }\n\n    _broadcastLockReleased(projectId) {\n        this._broadcast(LockEvent.LOCK_RELEASED, { projectId });\n    }\n\n    _broadcastHeartbeat(projectId, lock) {\n        this._broadcast(LockEvent.LOCK_HEARTBEAT, { projectId, lock });\n    }\n\n    _broadcastTakeover(projectId, oldLock) {\n        this._broadcast(LockEvent.LOCK_TAKEOVER, { projectId, oldLock });\n    }\n\n    _handleChannelMessage(event) {\n        const { type, projectId, lock, oldLock } = event.data || {};\n        if (!projectId) return;\n\n        const identity = userContext.getIdentity();\n\n        switch (type) {\n            case LockEvent.LOCK_ACQUIRED:\n                // Another tab acquired a lock\n                if (lock && lock.sessionId !== identity.sessionId) {\n                    this._notifyListeners(projectId, this._getLockStatusForLock(lock), lock);\n                }\n                break;\n\n            case LockEvent.LOCK_RELEASED:\n                // Another tab released a lock\n                this._notifyListeners(projectId, LockStatus.UNLOCKED, null);\n                break;\n\n            case LockEvent.LOCK_TAKEOVER:\n                // Another tab is taking over our lock\n                if (oldLock && oldLock.sessionId === identity.sessionId) {\n                    console.warn('[ProjectLockService] Lock taken over by another tab:', projectId);\n                    this._stopHeartbeat(projectId);\n                    this.localLocks.delete(projectId);\n                    this._notifyListeners(projectId, LockStatus.LOCKED_BY_OTHER_TAB, null);\n                }\n                break;\n\n            case LockEvent.LOCK_HEARTBEAT:\n                // Update our knowledge of external lock heartbeat\n                if (lock && lock.sessionId !== identity.sessionId) {\n                    this._storeLock(projectId, lock);\n                }\n                break;\n        }\n    }\n\n    /**\n     * Cleanup method for testing or shutdown.\n     */\n    destroy() {\n        // Stop all heartbeats\n        for (const projectId of this.heartbeatIntervals.keys()) {\n            this._stopHeartbeat(projectId);\n        }\n\n        // Close channel\n        if (this.channel) {\n            this.channel.close();\n            this.channel = null;\n        }\n\n        this.localLocks.clear();\n        this.lockChangeListeners.clear();\n        this.initialized = false;\n    }\n}\n\n// Export singleton instance\nexport const projectLockService = new ProjectLockService();\n\nexport default projectLockService;\n","import LocalStorageAdapter from './drivers/LocalStorageAdapter.js';\nimport { userContext } from '../core/UserContext.js';\nimport {\n    wrapWithMetadata,\n    unwrapMetadata,\n    hasMetadata,\n    markAsSynced,\n    markAsConflict,\n    SyncStatus,\n    LockStatus,\n    generateDocId,\n} from './SyncMetadata.js';\nimport { projectLockService } from './ProjectLockService.js';\n\n/**\n * @class StorageRepository\n * The main entry point for data persistence.\n * \n * Features:\n * - User-scoped storage via UserContext\n * - Sync metadata wrapping for cloud-ready data\n * - Project locking integration for concurrent edit prevention\n * - Driver swapping (LocalStorage  IndexedDB)\n */\nexport class StorageRepository {\n    constructor() {\n        this.driver = new LocalStorageAdapter();\n        this.initialized = false;\n    }\n\n    /**\n     * Initializes the active storage driver.\n     */\n    async init() {\n        if (this.initialized) return;\n\n        // Default to LocalStorage\n        await this.driver.init();\n        console.log('[StorageRepository] Initialized with default driver:', this.driver.constructor.name);\n        this.initialized = true;\n\n        // Initialize project lock service\n        projectLockService.init();\n    }\n\n    /**\n     * Switches the underlying driver at runtime.\n     * Useful after migration completes.\n     * @param {StorageInterface} newDriver \n     */\n    async switchDriver(newDriver) {\n        console.log('[StorageRepository] Switching driver to:', newDriver.constructor.name);\n        await newDriver.init();\n        this.driver = newDriver;\n    }\n\n    // --- Core Storage Methods ---\n\n    async getItem(key) {\n        if (!this.initialized) await this.init();\n        const scopedKey = userContext.getScopedKey(key);\n        return this.driver.getItem(scopedKey);\n    }\n\n    async setItem(key, value) {\n        if (!this.initialized) await this.init();\n        const scopedKey = userContext.getScopedKey(key);\n        return this.driver.setItem(scopedKey, value);\n    }\n\n    async removeItem(key) {\n        if (!this.initialized) await this.init();\n        const scopedKey = userContext.getScopedKey(key);\n        return this.driver.removeItem(scopedKey);\n    }\n\n    async clear() {\n        if (!this.initialized) await this.init();\n        const keys = await this.driver.getKeys();\n        const prefix = `user_${userContext.getUserId()}_`;\n        const deletionPromises = keys\n            .filter(k => k.startsWith(prefix))\n            .map(k => this.driver.removeItem(k));\n        await Promise.all(deletionPromises);\n    }\n\n    async getKeys() {\n        if (!this.initialized) await this.init();\n        const allKeys = await this.driver.getKeys();\n        const prefix = `user_${userContext.getUserId()}_`;\n        return allKeys\n            .filter(k => k.startsWith(prefix))\n            .map(k => k.slice(prefix.length));\n    }\n\n    // --- Sync-Aware Project Methods ---\n\n    /**\n     * Loads a project with its sync metadata.\n     * @param {string} projectKey \n     * @returns {Promise<{ data: any, meta: Object|null }>}\n     */\n    async loadProject(projectKey) {\n        const raw = await this.getItem(projectKey);\n        return unwrapMetadata(raw);\n    }\n\n    /**\n     * Loads raw project data without unwrapping (legacy compatibility).\n     * @param {string} projectKey \n     * @returns {Promise<any>}\n     */\n    async loadProjectRaw(projectKey) {\n        const result = await this.loadProject(projectKey);\n        return result.data;\n    }\n\n    /**\n     * Saves a project with sync metadata.\n     * @param {string} projectKey - Unique project identifier\n     * @param {Object} projectData - The actual project data\n     * @param {Object} [existingMeta] - Existing metadata to update\n     * @returns {Promise<{ success: boolean, meta: Object }>}\n     */\n    async saveProject(projectKey, projectData, existingMeta = null) {\n        if (!this.initialized) await this.init();\n\n        // Check lock status\n        const lockInfo = projectLockService.getLockInfo(projectKey);\n        if (!lockInfo.isEditable) {\n            console.warn('[StorageRepository] Cannot save - project is locked by another session');\n            return {\n                success: false,\n                error: 'PROJECT_LOCKED',\n                lockInfo\n            };\n        }\n\n        // Wrap with metadata\n        const wrapped = wrapWithMetadata(projectData, existingMeta, {\n            docType: 'project',\n            docId: projectKey,\n        });\n\n        // Save to storage\n        await this.setItem(projectKey, wrapped);\n\n        // Auto-backup to OPFS DataVault (fire & forget)\n        import('./DataVault.js').then(({ dataVault }) => {\n            if (dataVault) {\n                dataVault.saveSnapshot(projectKey, wrapped).catch(err =>\n                    console.warn('Auto-backup failed', err)\n                );\n            }\n        });\n\n        console.log('[StorageRepository] Project saved with metadata:', projectKey);\n        return { success: true, meta: wrapped._meta };\n    }\n\n    /**\n     * Gets only the sync metadata for a project without loading full data.\n     * Useful for sync status checks.\n     * @param {string} projectKey \n     * @returns {Promise<Object|null>}\n     */\n    async getProjectMeta(projectKey) {\n        const raw = await this.getItem(projectKey);\n        if (!hasMetadata(raw)) return null;\n        return raw._meta;\n    }\n\n    /**\n     * Marks a project as synced with the cloud.\n     * @param {string} projectKey \n     * @param {string} [serverTimestamp] - Timestamp from server\n     * @returns {Promise<boolean>}\n     */\n    async markProjectSynced(projectKey, serverTimestamp = null) {\n        const raw = await this.getItem(projectKey);\n        if (!hasMetadata(raw)) {\n            console.warn('[StorageRepository] Cannot mark as synced - no metadata');\n            return false;\n        }\n\n        raw._meta = markAsSynced(raw._meta, serverTimestamp);\n        await this.setItem(projectKey, raw);\n        return true;\n    }\n\n    /**\n     * Marks a project as having a sync conflict.\n     * @param {string} projectKey \n     * @param {string} errorMessage \n     * @returns {Promise<boolean>}\n     */\n    async markProjectConflict(projectKey, errorMessage) {\n        const raw = await this.getItem(projectKey);\n        if (!hasMetadata(raw)) return false;\n\n        raw._meta = markAsConflict(raw._meta, errorMessage);\n        await this.setItem(projectKey, raw);\n        return true;\n    }\n\n    /**\n     * Gets all projects that need syncing.\n     * @returns {Promise<Array<{ key: string, meta: Object }>>}\n     */\n    async getPendingSyncProjects() {\n        const keys = await this.getKeys();\n        const pending = [];\n\n        for (const key of keys) {\n            const meta = await this.getProjectMeta(key);\n            if (meta && (\n                meta.syncStatus === SyncStatus.PENDING ||\n                meta.syncStatus === SyncStatus.LOCAL_ONLY\n            )) {\n                pending.push({ key, meta });\n            }\n        }\n\n        return pending;\n    }\n\n    /**\n     * Lists all projects with their metadata.\n     * @returns {Promise<Array<{ key: string, data: any, meta: Object|null }>>}\n     */\n    async listProjects() {\n        const keys = await this.getKeys();\n        const projects = [];\n\n        for (const key of keys) {\n            const { data, meta } = await this.loadProject(key);\n            // Filter to only items that look like projects (have metadata with docType)\n            if (meta && meta.docType === 'project') {\n                projects.push({ key, data, meta });\n            }\n        }\n\n        return projects;\n    }\n\n    // --- Lock Management Pass-through ---\n\n    /**\n     * Attempts to acquire an edit lock on a project.\n     * @param {string} projectKey \n     * @param {Object} [options] - { force: boolean }\n     * @returns {Promise<{ success: boolean, status: string }>}\n     */\n    async acquireProjectLock(projectKey, options = {}) {\n        if (!this.initialized) await this.init();\n        return projectLockService.acquireLock(projectKey, options);\n    }\n\n    /**\n     * Releases an edit lock on a project.\n     * @param {string} projectKey \n     * @returns {Promise<boolean>}\n     */\n    async releaseProjectLock(projectKey) {\n        return projectLockService.releaseLock(projectKey);\n    }\n\n    /**\n     * Gets lock info for a project.\n     * @param {string} projectKey \n     * @returns {{ status: string, isEditable: boolean }}\n     */\n    getProjectLockInfo(projectKey) {\n        return projectLockService.getLockInfo(projectKey);\n    }\n\n    /**\n     * Subscribe to lock changes.\n     * @param {Function} callback - (projectKey, status, lock) => void\n     * @returns {Function} Unsubscribe function\n     */\n    onLockChange(callback) {\n        return projectLockService.subscribe(callback);\n    }\n}\n\n// Export a singleton instance\nexport const storageRepo = new StorageRepository();\n\n","import { get, set, del, clear, keys } from 'idb-keyval';\nimport LZString from 'lz-string';\nimport StorageInterface from '../StorageInterface.js';\n\n/**\n * @class IndexedDBAdapter\n * High-performance, asynchronous storage driver using IndexedDB.\n * Features transparent compression via LZ-String to maximize storage efficiency.\n */\nexport default class IndexedDBAdapter extends StorageInterface {\n    constructor() {\n        super();\n        this.name = 'IndexedDBAdapter';\n    }\n\n    /** @override */\n    async init() {\n        // IndexedDB/idb-keyval lazy-loads the DB connection on first request,\n        // so explicit init isn't strictly necessary but good for verification.\n        try {\n            if (typeof indexedDB === 'undefined') {\n                throw new Error('IndexedDB is not supported in this environment.');\n            }\n            return Promise.resolve();\n        } catch (e) {\n            console.warn('IndexedDB initialization failed:', e);\n            throw e;\n        }\n    }\n\n    /** @override */\n    async getItem(key) {\n        try {\n            const compressed = await get(key);\n            if (!compressed) return null;\n\n            // Detect if the data is actually compressed or legacy uncompressed (migration safety)\n            // LZ-String compressed strings usually don't look like JSON.\n            // We attempt decompression first.\n            let decompressed = LZString.decompressFromUTF16(compressed);\n\n            // If decompression returns null (invalid/empty input) but we had data,\n            // it might be raw data (though we ensure we always compress on write).\n            // Or it might be that LZString returns null on failure.\n\n            const payload = decompressed !== null ? decompressed : compressed;\n\n            try {\n                return JSON.parse(payload);\n            } catch {\n                // If it's not JSON, return raw string (rare case for us)\n                return payload;\n            }\n        } catch (e) {\n            console.warn(`[IndexedDBAdapter] Failed to get/decompress item: ${key}`, e);\n            return null;\n        }\n    }\n\n    /** @override */\n    async setItem(key, value) {\n        try {\n            const stringified = typeof value === 'string' ? value : JSON.stringify(value);\n            const compressed = LZString.compressToUTF16(stringified);\n            await set(key, compressed);\n        } catch (e) {\n            console.error(`[IndexedDBAdapter] Failed to compress/save item: ${key}`, e);\n            throw e;\n        }\n    }\n\n    /** @override */\n    async removeItem(key) {\n        return del(key);\n    }\n\n    /** @override */\n    async clear() {\n        return clear();\n    }\n\n    /** @override */\n    async getKeys() {\n        return keys();\n    }\n}\n","import { storageRepo } from './StorageRepository.js';\nimport LocalStorageAdapter from './drivers/LocalStorageAdapter.js';\nimport IndexedDBAdapter from './drivers/IndexedDBAdapter.js';\n\nconst MIGRATION_FLAG_KEY = 'cine_storage_migrated_v2';\n\n/**\n * Service to handle the one-time migration from LocalStorage to IndexedDB.\n */\nexport class StorageMigrationService {\n    constructor() {\n        this.localStorage = new LocalStorageAdapter();\n        this.indexedDB = new IndexedDBAdapter();\n    }\n\n    /**\n     * Checks if migration is needed and executes it.\n     * @returns {Promise<boolean>} True if migration occurred, False otherwise.\n     */\n    async runMigrationIfNeeded() {\n        try {\n            await this.localStorage.init();\n            await this.indexedDB.init();\n\n            const alreadyMigrated = await this.localStorage.getItem(MIGRATION_FLAG_KEY);\n            if (alreadyMigrated === 'true') {\n                console.log('[MigrationService] Storage already migrated to IndexedDB.');\n                return false;\n            }\n\n            console.log('[MigrationService] Starting storage migration...');\n\n            const keys = await this.localStorage.getKeys();\n            if (keys.length === 0) {\n                console.log('[MigrationService] No local storage data found. safe to skip.');\n                await this.markAsMigrated();\n                return false;\n            }\n\n            // Filter out internal flags that don't need migration\n            const keysToMigrate = keys.filter(k => k !== MIGRATION_FLAG_KEY && k !== 'cine_user_uuid');\n\n            // [Update] Get User Context to scope the new keys in IDB\n            // We perform the scoping manual here because we are writing directly to the IDB driver\n            // via StorageRepository (which now scopes), OR we use the adapter directly?\n            // Wait, StorageRepository.setItem NOW uses UserContext.\n            // But MigrationService has `new IndexedDBAdapter()`.\n            // If we use adapter directly, we must manually scope.\n            // Let's use the `userContext` helper.\n\n            let userContext;\n            try {\n                const module = await import('../core/UserContext.js');\n                userContext = module.userContext;\n                if (!userContext) {\n                    throw new Error('UserContext module loaded but userContext export is missing');\n                }\n                userContext.init(); // Ensure user ID exists\n            } catch (importError) {\n                console.error('[MigrationService] Failed to load UserContext for scoping. Aborting migration to prevent data loss.', importError);\n                // We must abort if we can't scope correctly, otherwise we write unscoped data to IDB which V2 won't see.\n                return false;\n            }\n\n            for (const key of keysToMigrate) {\n                try {\n                    const value = await this.localStorage.getItem(key);\n                    if (value !== null) {\n                        // Scope the key for the IDB destination\n                        const scopedKey = userContext.getScopedKey(key);\n                        await this.indexedDB.setItem(scopedKey, value);\n                        console.log(`[MigrationService] Migrated key: ${key} -> ${scopedKey}`);\n                    }\n                } catch (itemError) {\n                    console.error(`[MigrationService] Failed to migrate key: ${key}`, itemError);\n                    // We continue migration even if one key fails, but we should probably alert the user in a real app.\n                    // For now, robust logging is key.\n                }\n            }\n\n            await this.markAsMigrated();\n            console.log('[MigrationService] Migration complete. IndexedDB is now the primary storage.');\n            return true;\n\n        } catch (e) {\n            console.error('[MigrationService] Critical migration failure:', e);\n            return false; // Safely fail, app will continue using whatever repo is set (default LocalStorage)\n        }\n    }\n\n    async markAsMigrated() {\n        // We set the flag in BOTH storages for safety\n        await this.localStorage.setItem(MIGRATION_FLAG_KEY, 'true');\n        await this.indexedDB.setItem(MIGRATION_FLAG_KEY, 'true');\n    }\n}\n\nexport const migrationService = new StorageMigrationService();\n","import { storageRepo } from '../storage/StorageRepository.js';\n\nconst OWN_GEAR_KEY = 'cameraPowerPlanner_ownGear';\n\n/**\n * @class GearRepository\n * Unifies access to built-in device library and user's \"Own Gear\".\n * Migrates \"Own Gear\" to IndexedDB/StorageRepository.\n */\nclass GearRepository {\n    constructor() {\n        this.memoryCache = null;\n    }\n\n    /**\n     * Loads user-defined gear.\n     * Uses the central StorageRepository (which now uses IndexedDB).\n     * @returns {Promise<Array>}\n     */\n    async getOwnGear() {\n        if (this.memoryCache) return this.memoryCache;\n\n        try {\n            const data = await storageRepo.getItem(OWN_GEAR_KEY);\n\n            // Normalize data structure\n            // Format: { items: [...] } or [...]\n            if (!data) return [];\n\n            if (Array.isArray(data)) {\n                this.memoryCache = data;\n            } else if (data.items && Array.isArray(data.items)) {\n                this.memoryCache = data.items;\n            } else {\n                this.memoryCache = [];\n            }\n        } catch (e) {\n            console.warn('[GearRepository] Failed to load own gear:', e);\n            this.memoryCache = [];\n        }\n\n        return this.memoryCache;\n    }\n\n    /**\n     * Saves user-defined gear.\n     * @param {Array} items \n     */\n    async saveOwnGear(items) {\n        if (!Array.isArray(items)) {\n            console.error('[GearRepository] saveOwnGear expects an array');\n            return;\n        }\n\n        this.memoryCache = items;\n\n        // Wrap in object if needed or store as array.\n        // Legacy storage used { items: [...] } sometimes, but let's standardize.\n        // However, to keep compatibility with old JSON format, maybe stick to array if that's what was used.\n        // storage.js used to store it as entries directly or wrapped.\n        // Let's store as is.\n        await storageRepo.setItem(OWN_GEAR_KEY, items);\n    }\n\n    /**\n     * Add a single item to own gear.\n     * @param {Object} item \n     */\n    async addOwnGearItem(item) {\n        const items = await this.getOwnGear();\n        items.push(item);\n        await this.saveOwnGear(items);\n    }\n\n    /**\n   * Returns the static global device library.\n   * Assumes global object 'deviceLibrary' exists (loaded via script).\n   * @returns {Object}\n   */\n    getLibrary() {\n        if (typeof window !== 'undefined' && window.deviceLibrary) {\n            return window.deviceLibrary;\n        }\n        if (typeof globalThis !== 'undefined' && globalThis.deviceLibrary) {\n            return globalThis.deviceLibrary;\n        }\n        return {};\n    }\n\n    /**\n     * Unified search for gear.\n     * Searches both static library and own gear.\n     * @param {string} query \n     * @returns {Promise<Array>}\n     */\n    async searchGear(query) {\n        if (!query) return [];\n        const q = query.toLowerCase();\n\n        // 1. Search Own Gear\n        const ownGear = await this.getOwnGear();\n        const ownMatches = ownGear.filter(item =>\n            (item.name && item.name.toLowerCase().includes(q)) ||\n            (item.brand && item.brand.toLowerCase().includes(q))\n        );\n\n        // 2. Search Static Library\n        // This requires traversing the complex deviceLibrary object structure\n        // We'll skip deep traversal for now as V1 had specific search logic we might want to reuse.\n        // For now, returning ownMatches is a good start.\n\n        return ownMatches;\n    }\n}\n\nexport const gearRepo = new GearRepository();\n","/**\n * @class DataVault\n * Manages long-term file storage using the Origin Private File System (OPFS).\n * Provides a \"Vault\" for immutable checkpoints and backups.\n */\nexport class DataVault {\n    constructor() {\n        this.root = null;\n        this.initialized = false;\n    }\n\n    async init() {\n        if (this.initialized) return;\n        try {\n            if (!navigator.storage || !navigator.storage.getDirectory) {\n                console.warn('[DataVault] OPFS is not supported in this browser.');\n                return;\n            }\n            this.root = await navigator.storage.getDirectory();\n            this.initialized = true;\n        } catch (e) {\n            console.error('[DataVault] Failed to initialize OPFS:', e);\n        }\n    }\n\n    /**\n     * Saves a project snapshot to the vault.\n     * @param {string} filename \n     * @param {Object} data \n     */\n    async saveSnapshot(filename, data) {\n        if (!this.initialized) await this.init();\n        if (!this.root) throw new Error('OPFS not available');\n\n        try {\n            // Sanitize filename to strict alphanumeric + safe chars to avoid path separators\n            const safeFilename = filename.replace(/[^a-z0-9_\\-\\.\\s]/gi, '_');\n            const fileHandle = await this.root.getFileHandle(safeFilename + '.json', { create: true });\n\n            // Create a writable stream\n            const writable = await fileHandle.createWritable();\n\n            // Write data (JSON stringified)\n            await writable.write(JSON.stringify(data));\n\n            // Close the file\n            await writable.close();\n\n            console.log(`[DataVault] Saved snapshot: ${filename}`);\n            return true;\n        } catch (e) {\n            console.error(`[DataVault] Failed to save snapshot ${filename}:`, e);\n            throw e;\n        }\n    }\n\n    /**\n     * Lists all available snapshots in the vault.\n     * @returns {Promise<string[]>} List of filenames\n     */\n    async listSnapshots() {\n        if (!this.initialized) await this.init();\n        if (!this.root) return [];\n\n        const files = [];\n        try {\n            // Iterate over entries\n            // Note: OPFS iteration syntax varies slightly by browser, but standard is async iterator\n            for await (const [name, handle] of this.root.entries()) {\n                if (handle.kind === 'file' && name.endsWith('.json')) {\n                    files.push(name);\n                }\n            }\n        } catch (e) {\n            console.error('[DataVault] Failed to list snapshots:', e);\n        }\n        return files.sort().reverse(); // Newest first (assuming timestamped names)\n    }\n\n    /**\n     * Reads a snapshot from the vault.\n     * @param {string} filename \n     * @returns {Promise<Object>} The parsed data\n     */\n    async restoreSnapshot(filename) {\n        if (!this.initialized) await this.init();\n        if (!this.root) throw new Error('OPFS not available');\n\n        try {\n            const fileHandle = await this.root.getFileHandle(filename);\n            const file = await fileHandle.getFile();\n            const text = await file.text();\n            return JSON.parse(text);\n        } catch (e) {\n            console.error(`[DataVault] Failed to restore snapshot ${filename}:`, e);\n            throw e;\n        }\n    }\n\n    /**\n     * Deletes a snapshot.\n     * @param {string} filename \n     */\n    async deleteSnapshot(filename) {\n        if (!this.initialized) await this.init();\n        if (!this.root) return;\n\n        try {\n            await this.root.removeEntry(filename);\n            console.log(`[DataVault] Deleted snapshot: ${filename}`);\n        } catch (e) {\n            console.warn(`[DataVault] Failed to delete snapshot ${filename}:`, e);\n        }\n    }\n\n    /**\n     * Wipes the entire vault (Factory Reset).\n     */\n    async clear() {\n        if (!this.initialized) await this.init();\n        if (!this.root) return;\n\n        try {\n            const files = await this.listSnapshots();\n            for (const file of files) {\n                await this.root.removeEntry(file);\n            }\n            console.log('[DataVault] All data wiped.');\n        } catch (e) {\n            console.error('[DataVault] Failed to wipe vault:', e);\n        }\n    }\n}\n\nexport const dataVault = new DataVault();\n","\n/**\n * Cine Power Planner - Storage Orchestration\n * \n * This module manages all persistence operations, project indexing, and data backups.\n * It implements a hybrid architecture:\n * 1. Synchronous Memory Cache: For near-instant reads and Auto-Gear compatibility.\n * 2. Asynchronous Storage Drivers: Leveraging LocalStorage (legacy) and IndexedDB (modern).\n * 3. Cross-Tab Coordination: synchronizing state across multiple open tabs via BroadcastChannel.\n * \n * The module also handles the critical migration path from monolithic LocalStorage \n * to granular IndexedDB shards to ensure no data loss during application updates.\n */\nconsole.log('DEBUG: storage.js execution started');\n// storage.js - Handles reading from and writing to localStorage.\nimport * as consoleHelpersImport from './console-helpers.js';\nimport loggingResolverImport from './modules/logging-resolver.js';\nimport contactsModuleImport from './modules/features/contacts.js';\nimport { storageRepo } from './modules/storage/StorageRepository.js';\nimport { migrationService } from './modules/storage/StorageMigrationService.js';\nimport IndexedDBAdapter from './modules/storage/drivers/IndexedDBAdapter.js';\nimport { gearRepo } from './modules/gear/GearRepository.js';\nimport { userContext } from './modules/core/UserContext.js';\nimport { dataVault } from './modules/storage/DataVault.js';\n\nimport LZString from 'lz-string';\n\n// [Refactor] In-Memory Cache for Synchronous Read Capability (Hybrid IDB)\nlet projectMemoryCache = {};\nlet isProjectCacheHydrated = false;\n\n// Helper to hydrate cache from StorageRepository\n/**\n * Synchronous Project Cache Hydration\n * \n * RATIONALE: Certain application features (like Auto-Gear) require synchronous \n * access to project data. Since modern storage (IndexedDB) is inherently asynchronous, \n * we hydrate an in-memory cache on startup to provide the necessary performance \n * and compatibility guarantees.\n */\nasync function hydrateProjectCache() {\n  if (isProjectCacheHydrated) return;\n  console.log('[storage.js] Hydrating project cache from storage...');\n\n  try {\n    const keys = await storageRepo.getKeys();\n    // Filter for project keys (assuming prefix or heuristic)\n    // Legacy storage used a monolithic PROJECT_STORAGE_KEY or individual keys?\n    // V2 likely uses individual keys or we assumed so.\n    // Wait, `saveProject` implementation in legacy: `safeSetLocalStorage(PROJECT_STORAGE_KEY + name)` ?\n    // No, legacy was often monolithic `cameraPowerPlanner_setups`.\n    // But `saveProject` we just refactored calls `storageRepo.saveProject(name, project)`.\n\n    // If we migrated from `cameraPowerPlanner_setups` (monolith) to individual keys in IDB (scoped),\n    // we need to know how they are stored.\n    // If we follow `saveProject` -> `storageRepo.setItem(name, project)`, then keys are just names.\n    // But generic keys also exist (settings, etc.).\n\n    // We need a Project Index or Filter.\n    // For now, let's load EVERYTHING and filter by shape? Or assume a prefix logic.\n    // Since we didn't implement a prefix in `saveProject`, it's just `setItem(name, val)`.\n    // This is risky for name collisions with settings.\n    // WE SHOULD HAVE USED A PREFIX.\n\n    // RETROACTIVE FIX: We should probably prefix projects with 'project_' in `saveProject`.\n    // But for now, let's assume we can filter by looking at the content or if we have a known list.\n\n    // Actually, `LocalStorageAdapter` just mimics `localStorage` interface.\n    // `storageRepo` wraps it.\n\n    // Let's iterate all keys.\n    // [Agent Implementation] Actual Hydration Logic with Deterministic Ordering (Monolith First -> Shards Overwrite)\n    const monolithKey = 'cameraPowerPlanner_project';\n    let loadMonolith = false;\n    const shardKeys = [];\n\n    for (const key of keys) {\n      if (key.startsWith('cine_') || key.startsWith('user_')) continue;\n\n      // [Agent] Hydrate Project Index Cache\n      if (key === PROJECT_INDEX_KEY) { // 'cameraPowerPlanner_project_index'\n        storageRepo.getItem(key).then(val => {\n          if (val) projectIndexCache = val;\n        });\n        continue;\n      }\n\n      // [Agent Refactor] Memory Cache for Auto Gear (Synchronous Read Support)\n\n      if (key === AUTO_GEAR_MONITOR_DEFAULTS_STORAGE_KEY) {\n        storageRepo.getItem(key).then(val => { if (val) autoGearMonitorDefaultsCache = val; });\n        continue;\n      }\n      if (key === AUTO_GEAR_ACTIVE_PRESET_STORAGE_KEY) {\n        storageRepo.getItem(key).then(val => { if (val) autoGearActivePresetIdCache = val; });\n        continue;\n      }\n      if (key === AUTO_GEAR_AUTO_PRESET_STORAGE_KEY) {\n        storageRepo.getItem(key).then(val => { if (val) autoGearAutoPresetIdCache = val; });\n        continue;\n      }\n      if (key === AUTO_GEAR_BACKUP_RETENTION_STORAGE_KEY) {\n        storageRepo.getItem(key).then(val => { if (val) autoGearBackupRetentionCache = val; });\n        continue;\n      }\n      if (key === AUTO_GEAR_BACKUP_VISIBILITY_STORAGE_KEY) {\n        storageRepo.getItem(key).then(val => { if (val) autoGearBackupVisibilityCache = val; });\n        continue;\n      }\n      if (key === CUSTOM_FONT_STORAGE_KEY_DEFAULT) {\n        storageRepo.getItem(key).then(val => { if (val) customFontsCache = val; });\n        continue;\n      }\n      if (key === CUSTOM_LOGO_STORAGE_KEY) {\n        storageRepo.getItem(key).then(val => { if (val) customLogoCache = val; });\n        continue;\n      }\n      if (key === CAMERA_COLOR_STORAGE_KEY) {\n        storageRepo.getItem(key).then(val => { if (val) cameraColorsCache = val; });\n        continue;\n      }\n      if (key === PRINT_PREFERENCES_STORAGE_KEY) {\n        storageRepo.getItem(key).then(val => { if (val) printPreferencesCache = val; });\n        continue;\n      }\n      if (key === CONTACTS_STORAGE_KEY) {\n        storageRepo.getItem(key).then(val => { if (val) contactsCache = val; });\n        continue;\n      }\n      if (key === OWN_GEAR_STORAGE_KEY) {\n        storageRepo.getItem(key).then(val => { if (val) ownGearCache = val; });\n        continue;\n      }\n      if (key === USER_PROFILE_STORAGE_KEY) {\n        storageRepo.getItem(key).then(val => { if (val) userProfileCache = val; });\n        continue;\n      }\n      if (key === FAVORITES_STORAGE_KEY) {\n        storageRepo.getItem(key).then(val => { if (val) favoritesCache = val; });\n        continue;\n      }\n      if (key === TEMPERATURE_UNIT_STORAGE_KEY_NAME) {\n        storageRepo.getItem(key).then(val => { if (val) temperatureUnitCache = val; });\n        continue;\n      }\n      if (key === FOCUS_SCALE_STORAGE_KEY_NAME) {\n        storageRepo.getItem(key).then(val => { if (val) focusScaleCache = val; });\n        continue;\n      }\n      if (key === getMountVoltageStorageKeyName()) {\n        storageRepo.getItem(key).then(val => { if (val) mountVoltagesCache = val; });\n        continue;\n      }\n      if (key === FULL_BACKUP_HISTORY_STORAGE_KEY) {\n        storageRepo.getItem(key).then(val => { if (val) fullBackupHistoryCache = val; });\n        continue;\n      }\n\n      if (key === monolithKey) {\n        loadMonolith = true;\n      } else {\n        shardKeys.push(key);\n      }\n    }\n\n    // 1. Load Monolith (if exists)\n    if (loadMonolith) {\n      try {\n        const val = await storageRepo.getItem(monolithKey);\n        if (val && typeof val === 'object') {\n          Object.assign(projectMemoryCache, val);\n        }\n      } catch (monoErr) {\n        console.warn('[hydrate] Failed to load monolith', monoErr);\n      }\n    }\n\n    // 2. Load Shards (Parallel) - Overwrites monolith entries if collision\n    const shardPromises = shardKeys.map(async (key) => {\n      try {\n        const val = await storageRepo.getItem(key);\n        if (val) {\n          projectMemoryCache[key] = val;\n        }\n      } catch (shardErr) {\n        console.warn('[hydrate] Failed to load shard', key, shardErr);\n      }\n    });\n\n    await Promise.all(shardPromises);\n    isProjectCacheHydrated = true;\n    console.log('[storage.js] Project cache hydrated. Keys:', Object.keys(projectMemoryCache).length);\n  } catch (e) {\n    console.warn('Cache hydration failed', e);\n  }\n}\n\n// (function initializeStorageModule() {\n\nconst GLOBAL_SCOPE =\n\n\n  typeof globalThis !== 'undefined'\n    ? globalThis\n    : typeof window !== 'undefined'\n      ? window\n      : typeof global !== 'undefined'\n        ? global\n        : typeof self !== 'undefined'\n          ? self\n          : null;\n\n// Test suites and certain recovery tools need a way to force the storage\n// module to rebuild itself. This flag lets those callers opt-in without\n// impacting normal user sessions.\nconst FORCE_STORAGE_REINITIALIZE =\n  typeof process !== 'undefined' &&\n  process &&\n  process.env &&\n  (process.env.JEST_WORKER_ID || process.env.CINE_FORCE_STORAGE_REINIT);\n\n\n\nconst FACTORY_RESET_LOCK_KEY = 'cine_factory_reset_lock';\n\n\nif (GLOBAL_SCOPE && GLOBAL_SCOPE.__cineStorageInitialized) {\n  if (FORCE_STORAGE_REINITIALIZE) {\n    try {\n      delete GLOBAL_SCOPE.__cineStorageInitialized;\n    } catch (resetInitFlagError) {\n      GLOBAL_SCOPE.__cineStorageInitialized = false;\n      void resetInitFlagError;\n    }\n\n    try {\n      delete GLOBAL_SCOPE.__cineStorageApi;\n    } catch (resetApiError) {\n      GLOBAL_SCOPE.__cineStorageApi = null;\n      void resetApiError;\n    }\n\n    try {\n      delete GLOBAL_SCOPE.__cineMonolithicProjectCleanupDone;\n    } catch (resetCleanupFlagError) {\n      GLOBAL_SCOPE.__cineMonolithicProjectCleanupDone = false;\n      void resetCleanupFlagError;\n    }\n  } else {\n    if (\n      typeof module !== 'undefined' &&\n      module.exports &&\n      GLOBAL_SCOPE.__cineStorageApi &&\n      typeof GLOBAL_SCOPE.__cineStorageApi === 'object'\n    ) {\n      module.exports = GLOBAL_SCOPE.__cineStorageApi;\n    }\n    // ESM: Cannot use top-level return, so we set a flag to skip main logic\n\n  }\n}\n\n// [Added by Agent] Lifecycle channel for cross-tab coordination\n/**\n * Lifecycle Channel (Cross-Tab Coordination)\n * \n * RATIONALE: To ensure a consistent user experience when multiple tabs are open, \n * this channel broadcasts critical events like factory resets or project changes. \n * This prevents data corruption and ensures that all instances of the app \n * reflect the same underlying state.\n */\nconst LIFECYCLE_CHANNEL_NAME = 'cine-power-planner-lifecycle';\nlet lifecycleChannel = null;\nconst isJestWorker = typeof process !== 'undefined' && process && process.env && process.env.JEST_WORKER_ID;\nif (typeof BroadcastChannel !== 'undefined' && !isJestWorker) {\n  try {\n    lifecycleChannel = new BroadcastChannel(LIFECYCLE_CHANNEL_NAME);\n    if (lifecycleChannel) {\n      lifecycleChannel.onmessage = (event) => {\n        if (event && event.data === 'factory-reset') {\n          if (GLOBAL_SCOPE) {\n            GLOBAL_SCOPE.__cameraPowerPlannerFactoryResetting = true;\n            try {\n              if (typeof sessionStorage !== 'undefined') {\n                sessionStorage.setItem(FACTORY_RESET_LOCK_KEY, 'true');\n              }\n              if (typeof localStorage !== 'undefined') {\n                localStorage.setItem(FACTORY_RESET_LOCK_KEY, 'true');\n              }\n            } catch (lockError) {\n              void lockError;\n            }\n            // Clear session storage locally before reload to ensure it doesn't survive\n            // since page reload alone might preserve it in some browsers.\n            if (typeof sessionStorage !== 'undefined' && typeof sessionStorage.clear === 'function') {\n              try {\n                // We must preserve the lock key if we just set it\n                const lockValue = sessionStorage.getItem(FACTORY_RESET_LOCK_KEY);\n                sessionStorage.clear();\n                if (lockValue) {\n                  sessionStorage.setItem(FACTORY_RESET_LOCK_KEY, lockValue);\n                }\n              } catch (e) {\n                void e;\n              }\n            }\n            if (typeof GLOBAL_SCOPE.location !== 'undefined' && typeof GLOBAL_SCOPE.location.reload === 'function') {\n              GLOBAL_SCOPE.location.reload();\n            }\n          }\n        } else if (event.data === 'project-shards-changed') {\n          invalidateProjectReadCache();\n        }\n      };\n    }\n  } catch (channelError) {\n    // BroadcastChannel might be restricted in some environments\n    void channelError;\n  }\n}\n\nif (GLOBAL_SCOPE) {\n  try {\n    // Clear any lingering factory reset lock on initialization\n    const scopeList = [\n      typeof window !== 'undefined' ? window : null,\n      typeof sessionStorage !== 'undefined' ? sessionStorage : null,\n      typeof localStorage !== 'undefined' ? localStorage : null\n    ];\n\n    // [Agent Change] Check if we are freshly returning from a factory reset.\n    // We set a flag so that loadJSONFromStorage knows to skip backup recovery\n    // for this session, allowing a clean slate.\n    let justReset = false;\n    scopeList.forEach(s => {\n      if (s && typeof s.getItem === 'function') {\n        try {\n          if (s.getItem(FACTORY_RESET_LOCK_KEY)) justReset = true;\n        } catch (e) { void e; }\n      }\n    });\n    if (justReset) {\n      GLOBAL_SCOPE.__cineJustFactoryReset = true;\n    }\n\n    scopeList.forEach(s => {\n      if (s && typeof s.removeItem === 'function') {\n        try { s.removeItem(FACTORY_RESET_LOCK_KEY); } catch (e) { void e; }\n      }\n    });\n\n    Object.defineProperty(GLOBAL_SCOPE, '__cineStorageInitialized', {\n      configurable: true,\n      writable: true,\n      value: true,\n    });\n\n    /**\n     * Storage Migration and Driver Initialization\n     * \n     * RATIONALE: We fire the migration asynchronously to avoid blocking the main \n     * thread during UI boot. The StorageRepository defaults to LocalStorage \n     * for immediate availability, then upgrades to IndexedDB once the migration \n     * (the \"sharding\" process) is safely completed.\n     */\n    (async () => {\n      try {\n        if (migrationService && typeof migrationService.runMigrationIfNeeded === 'function') {\n          const migrated = await migrationService.runMigrationIfNeeded();\n          if (migrated) {\n            console.log('[storage.js] Migration successful. Switching to IndexedDB.');\n            await storageRepo.switchDriver(new IndexedDBAdapter());\n            await hydrateProjectCache();\n          }\n        } else if (migrationService && typeof migrationService.init === 'function') {\n          // Fallback for V2 init method\n          const migrated = await migrationService.init();\n          if (migrated) {\n            await storageRepo.switchDriver(new IndexedDBAdapter());\n            await hydrateProjectCache();\n          }\n        }\n      } catch (migrationError) {\n        console.warn('[storage.js] Migration service failed:', migrationError);\n      }\n    })();\n\n  } catch (storageInitFlagError) {\n    GLOBAL_SCOPE.__cineStorageInitialized = true;\n    void storageInitFlagError;\n  }\n}\n\n// [Added by Agent] Expose a teardown method for tests to close the channel\n// and allow the process to exit cleanly.\nfunction closeStorageLifecycle() {\n  if (lifecycleChannel) {\n    try {\n      lifecycleChannel.close();\n    } catch (closeError) {\n      void closeError;\n    }\n    lifecycleChannel = null;\n  }\n}\n// Export it if we are in a testing environment (implied by module.exports existence)\nif (typeof module !== 'undefined' && module.exports) {\n  module.exports.closeStorageLifecycle = closeStorageLifecycle;\n}\n\n// Perform a defensive deep clone that keeps us safe even when the runtime\n// does not provide a structured clone implementation. JSON serialization is\n// attempted first, but this manual path is the resilient safety net that\n// prevents backup/restore data from being mutated when serialization fails.\nfunction storageManualDeepClone(value, references) {\n  if (value === null || typeof value !== 'object') {\n    return value;\n  }\n\n  let referenceStore = references;\n  if (!referenceStore) {\n    referenceStore =\n      typeof WeakMap === 'function'\n        ? new WeakMap()\n        : [];\n  }\n\n  if (typeof referenceStore.has === 'function' && typeof referenceStore.get === 'function') {\n    if (referenceStore.has(value)) {\n      return referenceStore.get(value);\n    }\n  } else if (Array.isArray(referenceStore)) {\n    for (let index = 0; index < referenceStore.length; index += 1) {\n      const entry = referenceStore[index];\n      if (entry && entry[0] === value) {\n        return entry[1];\n      }\n    }\n  }\n\n  const valueTag = Object.prototype.toString.call(value);\n  if (valueTag === '[object Date]') {\n    let clonedDate;\n    try {\n      const timeValue = typeof value.getTime === 'function' ? value.getTime() : value.valueOf();\n      clonedDate = new Date(timeValue);\n    } catch (dateCloneError) {\n      clonedDate = new Date(value);\n      void dateCloneError;\n    }\n\n    if (typeof referenceStore.set === 'function') {\n      referenceStore.set(value, clonedDate);\n    } else if (Array.isArray(referenceStore)) {\n      referenceStore.push([value, clonedDate]);\n    }\n\n    return clonedDate;\n  }\n\n  const clone = Array.isArray(value) ? [] : {};\n\n  if (typeof referenceStore.set === 'function') {\n    referenceStore.set(value, clone);\n  } else if (Array.isArray(referenceStore)) {\n    referenceStore.push([value, clone]);\n  }\n\n  if (Array.isArray(value)) {\n    for (let index = 0; index < value.length; index += 1) {\n      clone[index] = storageManualDeepClone(value[index], referenceStore);\n    }\n  } else {\n    const keys = Object.keys(value);\n    for (let index = 0; index < keys.length; index += 1) {\n      const key = keys[index];\n      clone[key] = storageManualDeepClone(value[key], referenceStore);\n    }\n  }\n\n  return clone;\n}\n\n// Try to clone via JSON first so we get predictable behaviour when the data\n// is serializable. If that throws, we fall back to the manual deep clone to\n// keep user backups and restore payloads protected from mutation.\nfunction storageJsonDeepClone(value) {\n  if (value === null || typeof value !== 'object') {\n    return value;\n  }\n\n  try {\n    return JSON.parse(JSON.stringify(value));\n  } catch (jsonCloneError) {\n    void jsonCloneError;\n  }\n\n  return storageManualDeepClone(value, null);\n}\n\n// Try to locate a built-in structuredClone implementation on whichever\n// runtime we are executing in. This is intentionally exhaustive because the\n// application must behave identically in browsers, service workers and\n// automated test environments.\nfunction storageResolveStructuredClone(scope) {\n  if (typeof structuredClone === 'function') {\n    return structuredClone;\n  }\n\n  if (scope && typeof scope.structuredClone === 'function') {\n    try {\n      return scope.structuredClone.bind(scope);\n    } catch (bindError) {\n      void bindError;\n    }\n  }\n\n  /* REMOVED node:util require for ESM\n  if (typeof require === 'function') {\n    try {\n      const nodeUtil = require('node:util');\n      if (nodeUtil && typeof nodeUtil.structuredClone === 'function') {\n        return nodeUtil.structuredClone.bind(nodeUtil);\n      }\n    } catch (nodeUtilError) {\n      void nodeUtilError;\n    }\n \n    try {\n      const legacyUtil = require('util');\n      if (legacyUtil && typeof legacyUtil.structuredClone === 'function') {\n        return legacyUtil.structuredClone.bind(legacyUtil);\n      }\n    } catch (legacyUtilError) {\n      void legacyUtilError;\n    }\n  }\n  */\n\n  return null;\n}\n\n// Wrap the structuredClone implementation in a safety net. If the platform\n// throws (for example because of cloning functions), we gracefully fall back\n// to the JSON based strategy so that persistence keeps working.\nfunction storageCreateResilientDeepClone(scope) {\n  const structuredCloneImpl = storageResolveStructuredClone(scope);\n\n  if (!structuredCloneImpl) {\n    return storageJsonDeepClone;\n  }\n\n  /**\n   * Resilient Deep Clone Strategy\n   * \n   * RATIONALE: Persistence operations frequently involve creating snapshots of large \n   * project objects. To prevent accidental mutations of shared state, we use a \n   * resilient cloning strategy that prioritizes native structuredClone, \n   * falls back to JSON serialization, and finally uses a manual deep clone for \n   * complex objects that cannot be normally serialized.\n   */\n  return function storageResilientDeepClone(value) {\n    if (value === null || typeof value !== 'object') {\n      return value;\n    }\n\n    try {\n      return structuredCloneImpl(value);\n    } catch (structuredCloneError) {\n      void structuredCloneError;\n    }\n\n    return storageJsonDeepClone(value);\n  };\n}\n\nconst STORAGE_DEEP_CLONE =\n  GLOBAL_SCOPE && typeof GLOBAL_SCOPE.__cineDeepClone === 'function'\n    ? GLOBAL_SCOPE.__cineDeepClone\n    : storageCreateResilientDeepClone(GLOBAL_SCOPE);\n\n// Track sessionStorage instances we have already vetted. This allows us to\n// reuse safe handles even when multiple windows or execution contexts are\n// interacting with the planner simultaneously.\nconst knownSessionStorages =\n  typeof WeakSet === 'function' ? new WeakSet() : null;\n\n// Register a sessionStorage reference that we know is safe to use. The\n// WeakSet ensures we do not keep windows alive longer than necessary.\nfunction registerKnownSessionStorage(storage) {\n  if (\n    !knownSessionStorages\n    || typeof knownSessionStorages.add !== 'function'\n    || !storage\n  ) {\n    return;\n  }\n\n  try {\n    knownSessionStorages.add(storage);\n  } catch (error) {\n    void error;\n  }\n}\n\n// Resolve the sessionStorage object from a candidate scope while silently\n// handling cross-origin access errors. We prefer returning null over\n// throwing so that autosave logic can continue without interruption.\nfunction resolveSessionStorageFromScope(scope) {\n  if (!scope || (typeof scope !== 'object' && typeof scope !== 'function')) {\n    return null;\n  }\n\n  try {\n    const candidate = scope.sessionStorage;\n    if (candidate && typeof candidate.getItem === 'function') {\n      return candidate;\n    }\n  } catch (error) {\n    void error;\n  }\n\n  return null;\n}\n\n// Attempt to discover sessionStorage references across all known scopes once\n// during module initialisation. This keeps read/write operations snappy later\n// on and avoids repeated try/catch cost when autosave is active.\n(function primeSessionStorageCandidates() {\n  const scopes = [\n    GLOBAL_SCOPE,\n    GLOBAL_SCOPE && GLOBAL_SCOPE.window ? GLOBAL_SCOPE.window : null,\n    GLOBAL_SCOPE && GLOBAL_SCOPE.__cineGlobal\n      ? GLOBAL_SCOPE.__cineGlobal\n      : null,\n    typeof window !== 'undefined' ? window : null,\n    typeof self !== 'undefined' ? self : null,\n    typeof global !== 'undefined' ? global : null,\n  ];\n\n  for (let index = 0; index < scopes.length; index += 1) {\n    const candidate = resolveSessionStorageFromScope(scopes[index]);\n    if (candidate) {\n      registerKnownSessionStorage(candidate);\n    }\n  }\n\n  if (typeof sessionStorage !== 'undefined') {\n    try {\n      registerKnownSessionStorage(sessionStorage);\n    } catch (error) {\n      void error;\n    }\n  }\n})();\n\nfunction resolveLocalStorageFromScope(scope) {\n  if (!scope || (typeof scope !== 'object' && typeof scope !== 'function')) {\n    return null;\n  }\n\n  try {\n    const candidate = scope.localStorage;\n    if (candidate && typeof candidate.getItem === 'function') {\n      return candidate;\n    }\n  } catch (error) {\n    void error;\n  }\n\n  return null;\n}\n\nfunction collectLocalStorageCandidates() {\n  const scopes = [\n    GLOBAL_SCOPE,\n    GLOBAL_SCOPE && GLOBAL_SCOPE.window ? GLOBAL_SCOPE.window : null,\n    GLOBAL_SCOPE && GLOBAL_SCOPE.__cineGlobal ? GLOBAL_SCOPE.__cineGlobal : null,\n    typeof window !== 'undefined' ? window : null,\n    typeof globalThis !== 'undefined' ? globalThis : null,\n    typeof self !== 'undefined' ? self : null,\n    typeof global !== 'undefined' ? global : null,\n  ];\n\n  const candidates = [];\n  const seen = typeof WeakSet === 'function' ? new WeakSet() : null;\n\n  for (let index = 0; index < scopes.length; index += 1) {\n    const candidate = resolveLocalStorageFromScope(scopes[index]);\n    if (!candidate) {\n      continue;\n    }\n\n    if (seen) {\n      try {\n        if (seen.has(candidate)) {\n          continue;\n        }\n        seen.add(candidate);\n      } catch (error) {\n        void error;\n      }\n    } else if (candidates.indexOf(candidate) !== -1) {\n      continue;\n    }\n\n    candidates.push(candidate);\n  }\n\n  return candidates;\n}\n\nif (GLOBAL_SCOPE && typeof GLOBAL_SCOPE.__cineDeepClone !== 'function') {\n  try {\n    GLOBAL_SCOPE.__cineDeepClone = STORAGE_DEEP_CLONE;\n  } catch (storageDeepCloneError) {\n    void storageDeepCloneError;\n  }\n}\n\nfunction isFactoryResetActive() {\n  const readFlag = (scope) => {\n    if (!scope || (typeof scope !== 'object' && typeof scope !== 'function')) {\n      return false;\n    }\n    try {\n      return scope.__cameraPowerPlannerFactoryResetting === true;\n    } catch (error) {\n      void error;\n      return false;\n    }\n  };\n\n  if (readFlag(GLOBAL_SCOPE)) {\n    return true;\n  }\n\n  const fallbackScopes = [\n    typeof window !== 'undefined' ? window : null,\n    typeof self !== 'undefined' ? self : null,\n    typeof global !== 'undefined' ? global : null,\n  ];\n\n  for (let index = 0; index < fallbackScopes.length; index += 1) {\n    const scope = fallbackScopes[index];\n    if (scope && scope !== GLOBAL_SCOPE && readFlag(scope)) {\n      return true;\n    }\n  }\n\n  try {\n    if (\n      (typeof sessionStorage !== 'undefined' && sessionStorage.getItem(FACTORY_RESET_LOCK_KEY)) ||\n      (typeof localStorage !== 'undefined' && localStorage.getItem(FACTORY_RESET_LOCK_KEY))\n    ) {\n      return true;\n    }\n  } catch (storageError) {\n    void storageError;\n  }\n\n  return false;\n}\n\nvar DEVICE_STORAGE_KEY = 'cameraPowerPlanner_devices';\nvar DEVICE_STORAGE_KEY_VARIANTS = null;\nvar SETUP_STORAGE_KEY = 'cameraPowerPlanner_setups';\nvar SESSION_STATE_KEY = 'cameraPowerPlanner_session';\nvar FEEDBACK_STORAGE_KEY = 'cameraPowerPlanner_feedback';\nvar PROJECT_STORAGE_KEY = 'cameraPowerPlanner_project';\nvar PROJECT_STORAGE_REV_KEY = 'cameraPowerPlanner_project_rev';\nvar FAVORITES_STORAGE_KEY = 'cameraPowerPlanner_favorites';\nvar CONTACTS_STORAGE_KEY = 'cameraPowerPlanner_contacts';\nvar OWN_GEAR_STORAGE_KEY = 'cameraPowerPlanner_ownGear';\nvar USER_PROFILE_STORAGE_KEY = 'cameraPowerPlanner_userProfile';\nvar DOCUMENTATION_TRACKER_STORAGE_KEY = 'cameraPowerPlanner_documentationTracker';\nvar DEVICE_SCHEMA_CACHE_KEY = 'cameraPowerPlanner_schemaCache';\nvar LEGACY_SCHEMA_CACHE_KEY = 'cinePowerPlanner_schemaCache';\nvar CUSTOM_FONT_STORAGE_KEY_DEFAULT = 'cameraPowerPlanner_customFonts';\nvar MOUNT_VOLTAGE_STORAGE_KEY_FALLBACK = 'cameraPowerPlanner_mountVoltages';\nvar CAMERA_COLOR_STORAGE_KEY = 'cameraPowerPlanner_cameraColors';\nvar PRINT_PREFERENCES_STORAGE_KEY = 'cineRentalPrintSections';\nvar PROJECT_INDEX_KEY = 'cameraPowerPlanner_projectIndex';\nvar MOUNT_VOLTAGE_STORAGE_KEY_SYMBOL =\n  typeof Symbol === 'function'\n    ? Symbol.for('cinePowerPlanner.mountVoltageKey')\n    : null;\n\nvar PROJECT_STORAGE_READ_CACHE = null;\n\nvar STORAGE_CACHE_SYMBOL =\n  typeof Symbol === 'function'\n    ? Symbol.for('cinePowerPlanner.storageCache')\n    : '__cineStorageStateCache';\n\nvar PROJECT_SHARD_PREFIX = 'cameraPowerPlanner_prj_';\n\nvar STORAGE_STATE_CACHE_WEAKMAP =\n  typeof WeakMap === 'function' && typeof Map === 'function'\n    ? new WeakMap()\n    : null;\n\nvar CONTACTS_MODULE_API = null;\nvar CONTACTS_MODULE_RESOLUTION_ATTEMPTED = false;\n\nvar COMPRESSION_STRATEGY_CACHE =\n  typeof Map === 'function'\n    ? new Map()\n    : null;\nvar COMPRESSION_STRATEGY_CACHE_KEYS = [];\nvar COMPRESSION_STRATEGY_CACHE_LIMIT = 6;\nvar COMPRESSION_CANDIDATE_CACHE_MISS =\n  typeof Object.freeze === 'function'\n    ? Object.freeze({ __cineCompressionMiss: true })\n    : { __cineCompressionMiss: true };\nvar STORAGE_COMPRESSION_CANDIDATE_CACHE = createCompressionCandidateCache(8);\nvar MIGRATION_BACKUP_COMPRESSION_CANDIDATE_CACHE = createCompressionCandidateCache(6);\n\nvar AUTO_BACKUP_COMPRESSION_CACHE =\n  typeof Map === 'function'\n    ? new Map()\n    : null;\nvar AUTO_BACKUP_COMPRESSION_CACHE_KEYS = [];\nvar AUTO_BACKUP_COMPRESSION_CACHE_LIMIT = 16;\n\n// Compression payloads are reused frequently while we keep the UI responsive.\n// We clone objects before storing them so that later mutations never corrupt\n// previous snapshots.\nfunction cloneAutoBackupCompressionValue(value) {\n  if (!value || typeof value !== 'object') {\n    return value;\n  }\n\n  if (Array.isArray(value)) {\n    return value.slice();\n  }\n\n  var clone = {};\n  var keys = Object.keys(value);\n  for (var index = 0; index < keys.length; index += 1) {\n    var key = keys[index];\n    var original = value[key];\n    clone[key] = Array.isArray(original) ? original.slice() : original;\n  }\n\n  return clone;\n}\n\n// Retrieve a previously cached compression payload. Returning a shallow clone\n// protects the caller from mutating the cache entry by accident.\nfunction readAutoBackupCompressionCache(signature) {\n  if (!AUTO_BACKUP_COMPRESSION_CACHE || typeof signature !== 'string' || !signature) {\n    return null;\n  }\n\n  var cached;\n  try {\n    cached = AUTO_BACKUP_COMPRESSION_CACHE.get(signature);\n  } catch (cacheReadError) {\n    cached = null;\n    void cacheReadError;\n  }\n\n  if (!cached || !cached.payload) {\n    return null;\n  }\n\n  return {\n    payload: cloneAutoBackupCompressionValue(cached.payload),\n    compression: cached.compression\n      ? cloneAutoBackupCompressionValue(cached.compression)\n      : null,\n  };\n}\n\n// Store compression metadata for automatic backups. The cache is intentionally\n// size-limited to keep memory predictable during long offline sessions.\nfunction writeAutoBackupCompressionCache(signature, payload, compression) {\n  if (\n    !AUTO_BACKUP_COMPRESSION_CACHE\n    || typeof signature !== 'string'\n    || !signature\n    || !isCompressedAutoBackupSnapshotPayload(payload)\n  ) {\n    return;\n  }\n\n  var entry = {\n    payload: cloneAutoBackupCompressionValue(payload),\n    compression: compression ? cloneAutoBackupCompressionValue(compression) : null,\n  };\n\n  try {\n    AUTO_BACKUP_COMPRESSION_CACHE.set(signature, entry);\n  } catch (cacheStoreError) {\n    void cacheStoreError;\n    return;\n  }\n\n  var existingIndex = AUTO_BACKUP_COMPRESSION_CACHE_KEYS.indexOf(signature);\n  if (existingIndex !== -1) {\n    AUTO_BACKUP_COMPRESSION_CACHE_KEYS.splice(existingIndex, 1);\n  }\n\n  AUTO_BACKUP_COMPRESSION_CACHE_KEYS.push(signature);\n\n  while (AUTO_BACKUP_COMPRESSION_CACHE_KEYS.length > AUTO_BACKUP_COMPRESSION_CACHE_LIMIT) {\n    var oldest = AUTO_BACKUP_COMPRESSION_CACHE_KEYS.shift();\n    if (!oldest || oldest === signature) {\n      continue;\n    }\n\n    try {\n      AUTO_BACKUP_COMPRESSION_CACHE.delete(oldest);\n    } catch (cacheDeleteError) {\n      void cacheDeleteError;\n    }\n  }\n}\n\nfunction resetAutoBackupCompressionCache() {\n  if (AUTO_BACKUP_COMPRESSION_CACHE && typeof AUTO_BACKUP_COMPRESSION_CACHE.clear === 'function') {\n    try {\n      AUTO_BACKUP_COMPRESSION_CACHE.clear();\n    } catch (cacheClearError) {\n      void cacheClearError;\n    }\n  }\n\n  AUTO_BACKUP_COMPRESSION_CACHE_KEYS.length = 0;\n}\n\n// Allow unlimited compression warnings so diagnostics are never suppressed.\nvar COMPRESSION_WARNING_LIMIT = Number.POSITIVE_INFINITY;\nvar COMPRESSION_WARNING_BATCH_SIZE = 8;\nvar COMPRESSION_LOG_SUMMARY_WINDOW_MS = 60 * 1000;\nvar compressionWarningRegistry = {\n  entries: Object.create(null),\n  totalWarnings: 0,\n  suppressionNoticeShown: false,\n};\nvar ensureConsoleMethodsWritable = null;\nvar storageLoggingResolverCache = null;\nvar storageLoggerCache = null;\nvar storageLoggerResolutionAttempted = false;\nif (consoleHelpersImport && typeof consoleHelpersImport.ensureConsoleMethodsWritable === 'function') {\n  ensureConsoleMethodsWritable = consoleHelpersImport.ensureConsoleMethodsWritable;\n}\n\nvar ACTIVE_PROJECT_COMPRESSION_HOLD_KEY = '';\nvar ACTIVE_PROJECT_COMPRESSION_HOLD_ENABLED = false;\n\nif (\n  !ensureConsoleMethodsWritable\n  && GLOBAL_SCOPE\n  && typeof GLOBAL_SCOPE.__cineEnsureConsoleMethodsWritable === 'function'\n) {\n  ensureConsoleMethodsWritable = GLOBAL_SCOPE.__cineEnsureConsoleMethodsWritable;\n}\n\nif (typeof ensureConsoleMethodsWritable === 'function') {\n  ensureConsoleMethodsWritable(['warn', 'info']);\n}\n\nfunction collectStorageLoggingScopes() {\n  var scopes = [];\n\n  var enqueue = function enqueue(scope) {\n    if (!scope || (typeof scope !== 'object' && typeof scope !== 'function')) {\n      return;\n    }\n    if (scopes.indexOf(scope) === -1) {\n      scopes.push(scope);\n    }\n  };\n\n  enqueue(GLOBAL_SCOPE);\n  enqueue(typeof globalThis !== 'undefined' ? globalThis : null);\n  enqueue(typeof window !== 'undefined' ? window : null);\n  enqueue(typeof self !== 'undefined' ? self : null);\n  enqueue(typeof global !== 'undefined' ? global : null);\n\n  return scopes;\n}\n\nfunction resolveStorageLoggingResolver() {\n  if (storageLoggingResolverCache) {\n    return storageLoggingResolverCache;\n  }\n\n  if (loggingResolverImport && typeof loggingResolverImport.resolveLogger === 'function') {\n    storageLoggingResolverCache = loggingResolverImport;\n    return storageLoggingResolverCache;\n  }\n\n  var scopes = collectStorageLoggingScopes();\n  for (var index = 0; index < scopes.length; index += 1) {\n    var scope = scopes[index];\n    if (!scope || (typeof scope !== 'object' && typeof scope !== 'function')) {\n      continue;\n    }\n\n    try {\n      var resolver = scope.cineLoggingResolver;\n      if (resolver && typeof resolver.resolveLogger === 'function') {\n        storageLoggingResolverCache = resolver;\n        return storageLoggingResolverCache;\n      }\n    } catch (scopeResolverError) {\n      void scopeResolverError;\n    }\n  }\n\n  storageLoggingResolverCache = null;\n  return storageLoggingResolverCache;\n}\n\nfunction resolveStorageLogger() {\n  if (storageLoggerCache || storageLoggerResolutionAttempted) {\n    return storageLoggerCache;\n  }\n\n  storageLoggerResolutionAttempted = true;\n\n  var resolver = resolveStorageLoggingResolver();\n  if (resolver && typeof resolver.resolveLogger === 'function') {\n    try {\n      var logger = resolver.resolveLogger('storage', { meta: { source: 'storage-module' } });\n      if (logger) {\n        storageLoggerCache = logger;\n        return storageLoggerCache;\n      }\n    } catch (resolverError) {\n      void resolverError;\n    }\n  }\n\n  storageLoggerCache = null;\n  return storageLoggerCache;\n}\n\nfunction sanitizeStorageError(error) {\n  if (!error) {\n    return null;\n  }\n\n  if (typeof error === 'string') {\n    return { message: error };\n  }\n\n  var result = {};\n  if (typeof error.name === 'string' && error.name) {\n    result.name = error.name;\n  }\n  if (typeof error.message === 'string' && error.message) {\n    result.message = error.message;\n  }\n  if (typeof error.stack === 'string' && error.stack) {\n    result.stack = error.stack;\n  }\n\n  if (!Object.keys(result).length) {\n    try {\n      result.message = String(error);\n    } catch (stringifyError) {\n      void stringifyError;\n      return null;\n    }\n  }\n\n  return result;\n}\n\nfunction getActiveStorageType(storage) {\n  if (storage && typeof safeLocalStorageInfo !== 'undefined' && safeLocalStorageInfo && safeLocalStorageInfo.storage === storage) {\n    return safeLocalStorageInfo && typeof safeLocalStorageInfo.type === 'string'\n      ? safeLocalStorageInfo.type\n      : 'unknown';\n  }\n\n  if (storage && GLOBAL_SCOPE) {\n    try {\n      if (GLOBAL_SCOPE.localStorage && storage === GLOBAL_SCOPE.localStorage) {\n        return 'local';\n      }\n    } catch (localStorageCompareError) {\n      void localStorageCompareError;\n    }\n    try {\n      if (GLOBAL_SCOPE.sessionStorage && storage === GLOBAL_SCOPE.sessionStorage) {\n        return 'session';\n      }\n    } catch (sessionStorageCompareError) {\n      void sessionStorageCompareError;\n    }\n  }\n\n  if (typeof safeLocalStorageInfo !== 'undefined' && safeLocalStorageInfo && typeof safeLocalStorageInfo.type === 'string') {\n    return safeLocalStorageInfo.type;\n  }\n\n  return 'unknown';\n}\n\nfunction logStorageEvent(level, message, detail, meta, consoleCallback) {\n  var normalizedLevel = typeof level === 'string' && level ? level.toLowerCase() : 'info';\n  var normalizedMessage = typeof message === 'string' && message ? message : 'Storage event';\n  var logger = resolveStorageLogger();\n  var handled = false;\n  var resolvedMeta = { module: 'storage' };\n\n  if (meta && typeof meta === 'object') {\n    resolvedMeta = { module: 'storage' };\n    var metaKeys = Object.keys(meta);\n    for (var metaIndex = 0; metaIndex < metaKeys.length; metaIndex += 1) {\n      var metaKey = metaKeys[metaIndex];\n      resolvedMeta[metaKey] = meta[metaKey];\n    }\n  }\n\n  if (logger) {\n    if (typeof logger[normalizedLevel] === 'function') {\n      try {\n        logger[normalizedLevel](normalizedMessage, detail, resolvedMeta);\n        handled = true;\n      } catch (loggingError) {\n        handled = false;\n        void loggingError;\n      }\n    } else if (typeof logger.log === 'function') {\n      try {\n        logger.log(normalizedLevel, normalizedMessage, detail, resolvedMeta);\n        handled = true;\n      } catch (loggerLogError) {\n        handled = false;\n        void loggerLogError;\n      }\n    }\n  }\n\n  if (typeof consoleCallback === 'function') {\n    try {\n      consoleCallback();\n    } catch (consoleCallbackError) {\n      void consoleCallbackError;\n    }\n    return handled;\n  }\n\n  if (typeof console === 'undefined' || !console) {\n    return handled;\n  }\n\n  var fallback = null;\n  if (normalizedLevel === 'error' && typeof console.error === 'function') {\n    fallback = console.error;\n  } else if (normalizedLevel === 'warn' && typeof console.warn === 'function') {\n    fallback = console.warn;\n  } else if (normalizedLevel === 'info' && typeof console.info === 'function') {\n    fallback = console.info;\n  } else if (normalizedLevel === 'debug' && typeof console.debug === 'function') {\n    fallback = console.debug;\n  } else if (typeof console.log === 'function') {\n    fallback = console.log;\n  }\n\n  if (typeof fallback === 'function') {\n    try {\n      fallback.call(console, normalizedMessage, detail || null);\n    } catch (fallbackError) {\n      void fallbackError;\n    }\n  }\n\n  return handled;\n}\n\nfunction getCompressionLogTimestamp() {\n  if (typeof Date === 'undefined') {\n    return null;\n  }\n\n  if (typeof Date.now === 'function') {\n    return Date.now();\n  }\n\n  try {\n    return new Date().getTime();\n  } catch (timestampError) {\n    void timestampError;\n  }\n\n  return null;\n}\n\nfunction logCompressionSavingsEvent(kind, identifier, message, savings, percent) {\n  var entryKey = typeof kind === 'string' && kind ? kind : 'generic';\n  var keyLabel = null;\n  if (typeof identifier === 'string' && identifier) {\n    keyLabel = identifier;\n  } else if (identifier !== null && identifier !== undefined) {\n    try {\n      keyLabel = String(identifier);\n    } catch (stringifyError) {\n      keyLabel = null;\n      void stringifyError;\n    }\n  }\n\n  var detail = {\n    event: 'compression-savings',\n    kind: entryKey,\n    key: keyLabel,\n    storageType: getActiveStorageType(),\n  };\n  if (typeof savings === 'number' && Number.isFinite(savings)) {\n    detail.savings = savings;\n  }\n  if (typeof percent === 'number' && Number.isFinite(percent)) {\n    detail.percent = percent;\n  }\n\n  var consoleLogger = function logCompressionToConsole() {\n    if (typeof console === 'undefined') {\n      return;\n    }\n\n    var registry = compressionWarningRegistry;\n    var entry = registry.entries[entryKey];\n    var now = getCompressionLogTimestamp();\n\n    if (!entry) {\n      entry = {\n        kind: entryKey,\n        occurrences: 0,\n        totalSavings: 0,\n        lastPercent: null,\n        lastKey: null,\n        uniqueKeys: Object.create(null),\n        uniqueKeyCount: 0,\n        firstLoggedAt: now,\n        lastLoggedAt: now,\n        lastSummaryAt: null,\n        suppressedTotal: 0,\n        suppressedSinceSummary: 0,\n      };\n      registry.entries[entryKey] = entry;\n    }\n\n    entry.occurrences += 1;\n    entry.lastLoggedAt = now;\n    if (keyLabel) {\n      entry.lastKey = keyLabel;\n      if (!entry.uniqueKeys[keyLabel]) {\n        entry.uniqueKeys[keyLabel] = true;\n        entry.uniqueKeyCount += 1;\n      }\n    }\n\n    if (typeof savings === 'number' && Number.isFinite(savings)) {\n      entry.totalSavings += savings;\n    }\n    if (typeof percent === 'number' && Number.isFinite(percent)) {\n      entry.lastPercent = percent;\n    }\n\n    if (registry.totalWarnings < COMPRESSION_WARNING_LIMIT) {\n      if (typeof ensureConsoleMethodsWritable === 'function') {\n        ensureConsoleMethodsWritable('warn');\n      }\n      if (typeof console.warn === 'function' && message) {\n        console.warn(message);\n      }\n      registry.totalWarnings += 1;\n      return;\n    }\n\n    entry.suppressedTotal += 1;\n    entry.suppressedSinceSummary += 1;\n\n    if (!registry.suppressionNoticeShown && typeof console.info === 'function') {\n      if (typeof ensureConsoleMethodsWritable === 'function') {\n        ensureConsoleMethodsWritable('info');\n      }\n      console.info(\n        'Additional storage compression warnings are being batched to keep diagnostics readable.',\n        {\n          limit: COMPRESSION_WARNING_LIMIT,\n          batchSize: COMPRESSION_WARNING_BATCH_SIZE,\n        },\n      );\n      registry.suppressionNoticeShown = true;\n    }\n\n    var shouldSummarize = false;\n    if (!entry.lastSummaryAt) {\n      shouldSummarize = true;\n    } else if (entry.suppressedSinceSummary >= COMPRESSION_WARNING_BATCH_SIZE) {\n      shouldSummarize = true;\n    } else if (\n      now !== null &&\n      entry.lastSummaryAt !== null &&\n      entry.suppressedSinceSummary > 0 &&\n      now - entry.lastSummaryAt >= COMPRESSION_LOG_SUMMARY_WINDOW_MS\n    ) {\n      shouldSummarize = true;\n    }\n\n    if (shouldSummarize && typeof console.info === 'function') {\n      if (typeof ensureConsoleMethodsWritable === 'function') {\n        ensureConsoleMethodsWritable('info');\n      }\n      console.info('Suppressed repeated storage compression warnings.', {\n        kind: entry.kind,\n        mostRecentKey: entry.lastKey,\n        suppressedSinceSummary: entry.suppressedSinceSummary,\n        suppressedTotal: entry.suppressedTotal,\n        totalOccurrences: entry.occurrences,\n        totalSavings: entry.totalSavings,\n        lastPercent: entry.lastPercent,\n        uniqueKeys: entry.uniqueKeyCount,\n      });\n      entry.lastSummaryAt = now;\n      entry.suppressedSinceSummary = 0;\n    }\n  };\n\n  logStorageEvent('info', message, detail, { event: 'compression-savings', kind: entryKey }, consoleLogger);\n}\n\nfunction getCompressionLogSnapshot() {\n  var entries = {};\n  var keys = Object.keys(compressionWarningRegistry.entries);\n\n  for (var i = 0; i < keys.length; i += 1) {\n    var key = keys[i];\n    var source = compressionWarningRegistry.entries[key];\n    if (!source) {\n      continue;\n    }\n\n    entries[key] = {\n      kind: source.kind,\n      occurrences: source.occurrences,\n      totalSavings: source.totalSavings,\n      lastPercent: source.lastPercent,\n      lastKey: source.lastKey,\n      uniqueKeyCount: source.uniqueKeyCount,\n      firstLoggedAt: source.firstLoggedAt,\n      lastLoggedAt: source.lastLoggedAt,\n      lastSummaryAt: source.lastSummaryAt,\n      suppressedTotal: source.suppressedTotal,\n    };\n  }\n\n  return {\n    limit: COMPRESSION_WARNING_LIMIT,\n    batchSize: COMPRESSION_WARNING_BATCH_SIZE,\n    summaryWindowMs: COMPRESSION_LOG_SUMMARY_WINDOW_MS,\n    totalWarnings: compressionWarningRegistry.totalWarnings,\n    suppressionNoticeShown: compressionWarningRegistry.suppressionNoticeShown,\n    entries: entries,\n  };\n}\n\nfunction getCompressionStrategyCacheKey(variants) {\n  if (!Array.isArray(variants) || !variants.length) {\n    return null;\n  }\n\n  var segments = [];\n  for (var i = 0; i < variants.length; i += 1) {\n    var variant = variants[i] || {};\n    var name = typeof variant.variant === 'string' ? variant.variant : '';\n    var compressName = typeof variant.compress === 'string' ? variant.compress : '';\n    var decompressName = typeof variant.decompress === 'string' ? variant.decompress : '';\n    segments.push(name + ':' + compressName + ':' + decompressName);\n  }\n\n  return segments.join('|');\n}\n\nfunction readCompressionStrategyCache(cacheKey, lzReference) {\n  if (!COMPRESSION_STRATEGY_CACHE || !cacheKey) {\n    return null;\n  }\n\n  var cached;\n  try {\n    cached = COMPRESSION_STRATEGY_CACHE.get(cacheKey);\n  } catch (cacheReadError) {\n    cached = null;\n    void cacheReadError;\n  }\n\n  if (!cached || cached.lz !== lzReference) {\n    return null;\n  }\n\n  if (!Array.isArray(cached.strategies) || !cached.strategies.length) {\n    return Array.isArray(cached.strategies) ? [] : null;\n  }\n\n  return cached.strategies.slice();\n}\n\nfunction pruneCompressionStrategyCache(cacheKey) {\n  if (!COMPRESSION_STRATEGY_CACHE || !cacheKey) {\n    return;\n  }\n\n  var existingIndex = COMPRESSION_STRATEGY_CACHE_KEYS.indexOf(cacheKey);\n  if (existingIndex !== -1) {\n    COMPRESSION_STRATEGY_CACHE_KEYS.splice(existingIndex, 1);\n  }\n\n  COMPRESSION_STRATEGY_CACHE_KEYS.push(cacheKey);\n\n  while (COMPRESSION_STRATEGY_CACHE_KEYS.length > COMPRESSION_STRATEGY_CACHE_LIMIT) {\n    var oldestKey = COMPRESSION_STRATEGY_CACHE_KEYS.shift();\n    if (typeof COMPRESSION_STRATEGY_CACHE.delete === 'function') {\n      try {\n        COMPRESSION_STRATEGY_CACHE.delete(oldestKey);\n      } catch (cacheDeleteError) {\n        void cacheDeleteError;\n      }\n    }\n  }\n}\n\nfunction writeCompressionStrategyCache(cacheKey, lzReference, strategies) {\n  if (!COMPRESSION_STRATEGY_CACHE || !cacheKey) {\n    return;\n  }\n\n  var payload = {\n    lz: lzReference,\n    strategies: Array.isArray(strategies) ? strategies.slice() : [],\n  };\n\n  try {\n    COMPRESSION_STRATEGY_CACHE.set(cacheKey, payload);\n    pruneCompressionStrategyCache(cacheKey);\n  } catch (cacheStoreError) {\n    void cacheStoreError;\n  }\n}\n\nfunction computeStorageCompressionWrapperBaseLength() {\n  if (typeof JSON === 'undefined' || !JSON || typeof JSON.stringify !== 'function') {\n    return 0;\n  }\n\n  try {\n    var skeleton = {\n      [STORAGE_COMPRESSION_FLAG_KEY]: true,\n      version: STORAGE_COMPRESSION_VERSION,\n      algorithm: STORAGE_COMPRESSION_ALGORITHM,\n      namespace: STORAGE_COMPRESSION_NAMESPACE,\n      data: '',\n      originalLength: 0,\n      compressedPayloadLength: 0,\n      compressionVariant: '',\n    };\n\n    var serialized = JSON.stringify(skeleton);\n    if (typeof serialized !== 'string' || !serialized) {\n      return 0;\n    }\n\n    var emptyLiteralLength = JSON.stringify('').length;\n    if (!(emptyLiteralLength > 0)) {\n      return 0;\n    }\n\n    return serialized.length - emptyLiteralLength * 2 - String(0).length * 2;\n  } catch (wrapperLengthError) {\n    void wrapperLengthError;\n  }\n\n  return 0;\n}\n\nfunction createCompressionCandidateCache(limit) {\n  if (typeof Map !== 'function') {\n    return null;\n  }\n\n  var numericLimit = Number(limit);\n  if (!(numericLimit > 0)) {\n    return null;\n  }\n\n  return {\n    map: new Map(),\n    keys: [],\n    limit: Math.floor(numericLimit),\n  };\n}\n\nfunction cloneCompressionCandidate(candidate) {\n  if (!candidate || typeof candidate !== 'object') {\n    return null;\n  }\n\n  var clone = {};\n  var keys = Object.keys(candidate);\n  for (var i = 0; i < keys.length; i += 1) {\n    clone[keys[i]] = candidate[keys[i]];\n  }\n\n  return clone;\n}\n\nfunction touchCompressionCandidateCacheKey(cache, key) {\n  if (!cache || !Array.isArray(cache.keys)) {\n    return;\n  }\n\n  var existingIndex = cache.keys.indexOf(key);\n  if (existingIndex !== -1) {\n    cache.keys.splice(existingIndex, 1);\n  }\n\n  cache.keys.push(key);\n}\n\nfunction readCompressionCandidateCacheEntry(cache, key) {\n  if (!cache || !cache.map || typeof cache.map.get !== 'function') {\n    return { hit: false };\n  }\n\n  if (typeof key !== 'string' || !key) {\n    return { hit: false };\n  }\n\n  var entry;\n  try {\n    entry = cache.map.get(key);\n  } catch (cacheReadError) {\n    void cacheReadError;\n    return { hit: false };\n  }\n\n  if (entry === undefined) {\n    return { hit: false };\n  }\n\n  touchCompressionCandidateCacheKey(cache, key);\n\n  if (entry === COMPRESSION_CANDIDATE_CACHE_MISS) {\n    return { hit: true, candidate: null };\n  }\n\n  var cloned = cloneCompressionCandidate(entry);\n  if (!cloned) {\n    return { hit: true, candidate: null };\n  }\n\n  return { hit: true, candidate: cloned };\n}\n\nfunction writeCompressionCandidateCacheEntry(cache, key, candidate) {\n  if (!cache || !cache.map || typeof cache.map.set !== 'function') {\n    return;\n  }\n\n  if (typeof key !== 'string' || !key) {\n    return;\n  }\n\n  if (!cache.limit || cache.limit <= 0) {\n    return;\n  }\n\n  var entry = candidate && typeof candidate === 'object'\n    ? cloneCompressionCandidate(candidate)\n    : COMPRESSION_CANDIDATE_CACHE_MISS;\n\n  try {\n    cache.map.set(key, entry);\n  } catch (cacheStoreError) {\n    void cacheStoreError;\n    return;\n  }\n\n  touchCompressionCandidateCacheKey(cache, key);\n\n  while (cache.keys.length > cache.limit) {\n    var oldestKey = cache.keys.shift();\n    if (typeof oldestKey !== 'string' || oldestKey === key) {\n      continue;\n    }\n\n    try {\n      cache.map.delete(oldestKey);\n    } catch (cacheDeleteError) {\n      void cacheDeleteError;\n    }\n  }\n}\n\nfunction getStorageStateCacheMap(storage, createIfMissing) {\n  if (!storage || (typeof storage !== 'object' && typeof storage !== 'function')) {\n    return null;\n  }\n\n  let existing = null;\n  if (STORAGE_CACHE_SYMBOL) {\n    try {\n      existing = storage[STORAGE_CACHE_SYMBOL];\n    } catch (readError) {\n      existing = null;\n      void readError;\n    }\n  }\n\n  if (!existing && STORAGE_STATE_CACHE_WEAKMAP) {\n    try {\n      existing = STORAGE_STATE_CACHE_WEAKMAP.get(storage) || null;\n    } catch (weakMapReadError) {\n      existing = null;\n      void weakMapReadError;\n    }\n  }\n\n  if (existing || !createIfMissing) {\n    return existing || null;\n  }\n\n  const map = new Map();\n  let assigned = false;\n\n  if (STORAGE_CACHE_SYMBOL) {\n    try {\n      Object.defineProperty(storage, STORAGE_CACHE_SYMBOL, {\n        configurable: true,\n        writable: true,\n        value: map,\n      });\n      assigned = true;\n    } catch (defineError) {\n      void defineError;\n      try {\n        storage[STORAGE_CACHE_SYMBOL] = map;\n        assigned = true;\n      } catch (assignError) {\n        assigned = false;\n        void assignError;\n      }\n    }\n  }\n\n  if (!assigned && STORAGE_STATE_CACHE_WEAKMAP) {\n    try {\n      STORAGE_STATE_CACHE_WEAKMAP.set(storage, map);\n      assigned = true;\n    } catch (weakMapStoreError) {\n      assigned = false;\n      void weakMapStoreError;\n    }\n  }\n\n  return assigned ? map : null;\n}\n\nfunction getCachedStorageEntry(storage, key) {\n  const map = getStorageStateCacheMap(storage, false);\n  if (!map || typeof key !== 'string' || !key) {\n    return null;\n  }\n  return map.get(key) || null;\n}\n\nfunction clearCachedStorageEntry(storage, key) {\n  const map = getStorageStateCacheMap(storage, false);\n  if (!map || typeof key !== 'string' || !key) {\n    return;\n  }\n\n  if (typeof map.delete === 'function') {\n    map.delete(key);\n  }\n\n  if (map.size === 0) {\n    if (STORAGE_CACHE_SYMBOL) {\n      try {\n        if (storage && (typeof storage === 'object' || typeof storage === 'function')) {\n          if (Object.prototype.hasOwnProperty.call(storage, STORAGE_CACHE_SYMBOL)) {\n            delete storage[STORAGE_CACHE_SYMBOL];\n          }\n        }\n      } catch (clearError) {\n        void clearError;\n      }\n    }\n    if (STORAGE_STATE_CACHE_WEAKMAP) {\n      try {\n        STORAGE_STATE_CACHE_WEAKMAP.delete(storage);\n      } catch (weakMapDeleteError) {\n        void weakMapDeleteError;\n      }\n    }\n  }\n}\n\nfunction cloneValueForCache(value) {\n  if (value === null || typeof value !== 'object') {\n    return value;\n  }\n\n  try {\n    return STORAGE_DEEP_CLONE(value);\n  } catch (cloneError) {\n    void cloneError;\n  }\n\n  return value;\n}\n\nfunction cloneCachedEntryValue(entry) {\n  if (!entry) {\n    return undefined;\n  }\n\n  const { value } = entry;\n  if (value === null || typeof value !== 'object') {\n    return value;\n  }\n\n  return cloneValueForCache(value);\n}\n\nfunction cloneLookupMap(source, options) {\n  const map = new Map();\n  if (!source || typeof source.forEach !== 'function') {\n    return map;\n  }\n\n  const { freezeArray = false } = options || {};\n\n  source.forEach((value, key) => {\n    if (Array.isArray(value)) {\n      const copy = value.slice();\n      if (freezeArray) {\n        try {\n          Object.freeze(copy);\n        } catch (freezeError) {\n          void freezeError;\n        }\n      }\n      map.set(key, copy);\n    } else {\n      map.set(key, value);\n    }\n  });\n\n  return map;\n}\n\nfunction cloneProjectLookupSnapshotForReturn(lookup) {\n  if (!lookup || typeof lookup !== 'object') {\n    return { raw: new Map(), normalized: new Map() };\n  }\n\n  return {\n    raw: cloneLookupMap(lookup.raw),\n    normalized: cloneLookupMap(lookup.normalized),\n  };\n}\n\nfunction captureProjectLookupSnapshotForCache(lookup) {\n  if (!lookup || typeof lookup !== 'object') {\n    return { raw: new Map(), normalized: new Map() };\n  }\n\n  return {\n    raw: cloneLookupMap(lookup.raw),\n    normalized: cloneLookupMap(lookup.normalized, { freezeArray: true }),\n  };\n}\n\nfunction freezeProjectSnapshotProjects(projects) {\n  if (!isPlainObject(projects)) {\n    return {};\n  }\n\n  const frozen = {};\n  const keys = Object.keys(projects);\n  for (let index = 0; index < keys.length; index += 1) {\n    const key = keys[index];\n    const entry = projects[key];\n    if (entry && typeof entry === 'object') {\n      try {\n        Object.freeze(entry);\n      } catch (freezeError) {\n        void freezeError;\n      }\n    }\n    frozen[key] = entry;\n  }\n\n  try {\n    Object.freeze(frozen);\n  } catch (freezeRootError) {\n    void freezeRootError;\n  }\n\n  return frozen;\n}\n\nfunction setProjectReadCacheSnapshot(snapshot) {\n  if (!snapshot || typeof snapshot !== 'object') {\n    PROJECT_STORAGE_READ_CACHE = null;\n    return;\n  }\n\n  PROJECT_STORAGE_READ_CACHE = {\n    projects: freezeProjectSnapshotProjects(snapshot.projects),\n    changed: Boolean(snapshot.changed),\n    originalValue: snapshot.originalValue,\n    lookup: captureProjectLookupSnapshotForCache(snapshot.lookup),\n    rawValue: snapshot.rawValue === undefined ? undefined : snapshot.rawValue,\n  };\n}\n\nfunction getProjectReadCacheClone(options) {\n  if (!PROJECT_STORAGE_READ_CACHE) {\n    return null;\n  }\n\n  const safeStorage = getSafeLocalStorage();\n  let currentRaw = null;\n  if (safeStorage && typeof safeStorage.getItem === 'function') {\n    try {\n      currentRaw = safeStorage.getItem(PROJECT_STORAGE_KEY);\n    } catch (storageReadError) {\n      currentRaw = null;\n      void storageReadError;\n    }\n  }\n\n  if (\n    PROJECT_STORAGE_READ_CACHE.rawValue !== undefined\n    && PROJECT_STORAGE_READ_CACHE.rawValue !== currentRaw\n  ) {\n    PROJECT_STORAGE_READ_CACHE = null;\n    return null;\n  }\n\n  const { forMutation = false } = options || {};\n  const projects = forMutation\n    ? STORAGE_DEEP_CLONE(PROJECT_STORAGE_READ_CACHE.projects)\n    : PROJECT_STORAGE_READ_CACHE.projects;\n\n  return {\n    projects,\n    changed: PROJECT_STORAGE_READ_CACHE.changed,\n    originalValue: PROJECT_STORAGE_READ_CACHE.originalValue,\n    lookup: cloneProjectLookupSnapshotForReturn(PROJECT_STORAGE_READ_CACHE.lookup),\n  };\n}\n\nfunction invalidateProjectReadCache() {\n  PROJECT_STORAGE_READ_CACHE = null;\n}\n\nfunction normalizeProjectStorageRevisionValue(value) {\n  if (typeof value === 'number' && Number.isFinite(value)) {\n    return Math.max(0, Math.floor(value));\n  }\n  if (typeof value === 'string') {\n    const trimmed = value.trim();\n    if (!trimmed) {\n      return null;\n    }\n    const parsed = Number(trimmed);\n    if (Number.isFinite(parsed)) {\n      return Math.max(0, Math.floor(parsed));\n    }\n  }\n  return null;\n}\n\nfunction getProjectStorageRevisionKeyName() {\n  return PROJECT_STORAGE_REV_KEY;\n}\n\nfunction loadProjectStorageRevision(storageOverride) {\n  const storage = storageOverride || getSafeLocalStorage();\n  if (!storage || typeof storage.getItem !== 'function') {\n    return null;\n  }\n  const parsed = loadJSONFromStorage(\n    storage,\n    PROJECT_STORAGE_REV_KEY,\n    'Error reading project storage revision from localStorage:',\n    null,\n    { validate: (value) => value === null || typeof value === 'number' || typeof value === 'string' },\n  );\n  return normalizeProjectStorageRevisionValue(parsed);\n}\n\nfunction bumpProjectStorageRevision(storageOverride) {\n  const storage = storageOverride || getSafeLocalStorage();\n  if (!storage || typeof storage.setItem !== 'function') {\n    return null;\n  }\n  const current = loadProjectStorageRevision(storage);\n  const next = Number.isFinite(current) ? current + 1 : 1;\n  saveJSONToStorage(\n    storage,\n    PROJECT_STORAGE_REV_KEY,\n    next,\n    'Error saving project storage revision to localStorage:',\n    { disableCompression: true, enableCompressionSweep: false },\n  );\n  return next;\n}\n\nfunction cacheStorageValue(storage, key, rawValue, normalizedValue, value) {\n  if (typeof key !== 'string' || !key) {\n    return;\n  }\n\n  if (!storage || (typeof storage !== 'object' && typeof storage !== 'function')) {\n    return;\n  }\n\n  const map = getStorageStateCacheMap(storage, true);\n  if (!map) {\n    return;\n  }\n\n  const cachedValue = cloneValueForCache(value);\n  const normalized = typeof normalizedValue === 'string' && normalizedValue\n    ? normalizedValue\n    : typeof rawValue === 'string' && rawValue\n      ? rawValue\n      : null;\n\n  const cacheEntry = {\n    raw: typeof rawValue === 'string' && rawValue ? rawValue : null,\n    normalizedRaw: normalized,\n    value: cachedValue,\n  };\n\n  map.set(key, cacheEntry);\n}\n\nfunction tryGetCachedStorageValue(storage, key, primaryRaw, rawStored) {\n  const entry = getCachedStorageEntry(storage, key);\n  if (!entry) {\n    return { hit: false };\n  }\n\n  if (typeof rawStored === 'string' && rawStored) {\n    if (entry.raw && entry.raw === rawStored) {\n      return { hit: true, value: cloneCachedEntryValue(entry) };\n    }\n  }\n\n  if (typeof primaryRaw === 'string' && primaryRaw) {\n    if (entry.normalizedRaw && entry.normalizedRaw === primaryRaw) {\n      return { hit: true, value: cloneCachedEntryValue(entry) };\n    }\n    if (entry.raw && entry.raw === primaryRaw) {\n      return { hit: true, value: cloneCachedEntryValue(entry) };\n    }\n  }\n\n  return { hit: false };\n}\n\nfunction readGlobalStringValue(scope, key) {\n  if (!scope || typeof scope !== 'object') {\n    return '';\n  }\n\n  var descriptor;\n  try {\n    descriptor = Object.getOwnPropertyDescriptor(scope, key);\n  } catch (descriptorError) {\n    descriptor = null;\n    void descriptorError;\n  }\n\n  if (\n    descriptor &&\n    Object.prototype.hasOwnProperty.call(descriptor, 'value') &&\n    typeof descriptor.value === 'string' &&\n    descriptor.value\n  ) {\n    return descriptor.value;\n  }\n\n  var directValue;\n  try {\n    directValue = scope[key];\n  } catch (readError) {\n    directValue = '';\n    void readError;\n  }\n\n  if (typeof directValue === 'string' && directValue) {\n    return directValue;\n  }\n\n  if (key === 'MOUNT_VOLTAGE_STORAGE_KEY' && MOUNT_VOLTAGE_STORAGE_KEY_SYMBOL) {\n    try {\n      const symbolValue = scope[MOUNT_VOLTAGE_STORAGE_KEY_SYMBOL];\n      if (typeof symbolValue === 'string' && symbolValue) {\n        return symbolValue;\n      }\n    } catch (symbolReadError) {\n      void symbolReadError;\n    }\n  }\n\n  return '';\n}\n\nfunction exposeGlobalStringValue(scope, key, value) {\n  if (!scope || typeof scope !== 'object') {\n    return '';\n  }\n\n  if (key === 'MOUNT_VOLTAGE_STORAGE_KEY' && MOUNT_VOLTAGE_STORAGE_KEY_SYMBOL) {\n    try {\n      scope[MOUNT_VOLTAGE_STORAGE_KEY_SYMBOL] = value;\n      const symbolAssigned = scope[MOUNT_VOLTAGE_STORAGE_KEY_SYMBOL];\n      if (typeof symbolAssigned === 'string' && symbolAssigned) {\n        return symbolAssigned;\n      }\n    } catch (symbolExposeError) {\n      void symbolExposeError;\n    }\n  }\n\n  var descriptor;\n  try {\n    descriptor = Object.getOwnPropertyDescriptor(scope, key);\n  } catch (descriptorError) {\n    descriptor = null;\n    void descriptorError;\n  }\n\n  if (\n    descriptor &&\n    Object.prototype.hasOwnProperty.call(descriptor, 'value') &&\n    typeof descriptor.value === 'string' &&\n    descriptor.value\n  ) {\n    return descriptor.value;\n  }\n\n  if (descriptor && descriptor.configurable === false && descriptor.writable === false) {\n    return '';\n  }\n\n  var assigned = '';\n\n  try {\n    scope[key] = value;\n    assigned = scope[key];\n  } catch (assignError) {\n    assigned = '';\n    void assignError;\n  }\n\n  if (typeof assigned === 'string' && assigned) {\n    return assigned;\n  }\n\n  if (\n    key === 'MOUNT_VOLTAGE_STORAGE_KEY' &&\n    typeof console !== 'undefined' &&\n    typeof console.warn === 'function'\n  ) {\n    console.warn(\n      'Unable to expose mount voltage storage key globally. Using fallback only.'\n    );\n  }\n\n  return '';\n}\n\nfunction resolveMountVoltageStorageKeyName() {\n  if (!GLOBAL_SCOPE || typeof GLOBAL_SCOPE !== 'object') {\n    return MOUNT_VOLTAGE_STORAGE_KEY_FALLBACK;\n  }\n\n  var existing = readGlobalStringValue(GLOBAL_SCOPE, 'MOUNT_VOLTAGE_STORAGE_KEY');\n  if (existing) {\n    return existing;\n  }\n\n  var exposed = exposeGlobalStringValue(\n    GLOBAL_SCOPE,\n    'MOUNT_VOLTAGE_STORAGE_KEY',\n    MOUNT_VOLTAGE_STORAGE_KEY_FALLBACK\n  );\n  if (exposed) {\n    return exposed;\n  }\n\n  return MOUNT_VOLTAGE_STORAGE_KEY_FALLBACK;\n}\n\nvar MOUNT_VOLTAGE_STORAGE_KEY_NAME = resolveMountVoltageStorageKeyName();\n\nfunction refreshMountVoltageStorageKeyName() {\n  const resolved = resolveMountVoltageStorageKeyName();\n  if (resolved && resolved !== MOUNT_VOLTAGE_STORAGE_KEY_NAME) {\n    MOUNT_VOLTAGE_STORAGE_KEY_NAME = resolved;\n    if (GLOBAL_SCOPE) {\n      exposeGlobalStringValue(\n        GLOBAL_SCOPE,\n        'MOUNT_VOLTAGE_STORAGE_KEY',\n        resolved,\n      );\n    }\n    if (typeof RAW_STORAGE_BACKUP_KEYS !== 'undefined' && RAW_STORAGE_BACKUP_KEYS && typeof RAW_STORAGE_BACKUP_KEYS.add === 'function') {\n      RAW_STORAGE_BACKUP_KEYS.add(resolved);\n      const variants = getStorageKeyVariants(resolved);\n      for (let i = 0; i < variants.length; i += 1) {\n        const variant = variants[i];\n        if (typeof variant === 'string' && variant) {\n          RAW_STORAGE_BACKUP_KEYS.add(variant);\n        }\n      }\n    }\n  }\n  return MOUNT_VOLTAGE_STORAGE_KEY_NAME;\n}\n\nfunction getMountVoltageStorageKeyName() {\n  return refreshMountVoltageStorageKeyName();\n}\n\nfunction getMountVoltageStorageBackupKeyName() {\n  const key = refreshMountVoltageStorageKeyName();\n  return key ? `${key}__backup` : `${MOUNT_VOLTAGE_STORAGE_KEY_FALLBACK}__backup`;\n}\n\nfunction ensureCustomFontStorageKeyName() {\n  if (!GLOBAL_SCOPE) {\n    return CUSTOM_FONT_STORAGE_KEY_DEFAULT;\n  }\n\n  const existingName =\n    typeof GLOBAL_SCOPE.CUSTOM_FONT_STORAGE_KEY_NAME === 'string'\n      ? GLOBAL_SCOPE.CUSTOM_FONT_STORAGE_KEY_NAME\n      : typeof GLOBAL_SCOPE.CUSTOM_FONT_STORAGE_KEY === 'string'\n        ? GLOBAL_SCOPE.CUSTOM_FONT_STORAGE_KEY\n        : CUSTOM_FONT_STORAGE_KEY_DEFAULT;\n\n  let normalizedName = existingName;\n  if (existingName === 'cinePowerPlanner_customFonts') {\n    normalizedName = CUSTOM_FONT_STORAGE_KEY_DEFAULT;\n  }\n\n  if (GLOBAL_SCOPE.CUSTOM_FONT_STORAGE_KEY !== normalizedName) {\n    GLOBAL_SCOPE.CUSTOM_FONT_STORAGE_KEY = normalizedName;\n  }\n\n  if (GLOBAL_SCOPE.CUSTOM_FONT_STORAGE_KEY_NAME !== normalizedName) {\n    GLOBAL_SCOPE.CUSTOM_FONT_STORAGE_KEY_NAME = normalizedName;\n  }\n\n  return normalizedName;\n}\n\nfunction getCustomFontStorageKeyName() {\n  if (GLOBAL_SCOPE &&\n    typeof GLOBAL_SCOPE.CUSTOM_FONT_STORAGE_KEY_NAME === 'string') {\n    return GLOBAL_SCOPE.CUSTOM_FONT_STORAGE_KEY_NAME;\n  }\n\n  return ensureCustomFontStorageKeyName();\n}\n\nensureCustomFontStorageKeyName();\n\nvar CUSTOM_LOGO_STORAGE_KEY = 'customLogo';\nvar TEMPERATURE_UNIT_STORAGE_KEY_DEFAULT = 'cameraPowerPlanner_temperatureUnit';\nvar FOCUS_SCALE_STORAGE_KEY_DEFAULT = 'cameraPowerPlanner_focusScale';\n\nfunction resolveTemperatureUnitStorageKey() {\n  if (!GLOBAL_SCOPE) {\n    return TEMPERATURE_UNIT_STORAGE_KEY_DEFAULT;\n  }\n\n  const existing =\n    typeof GLOBAL_SCOPE.TEMPERATURE_UNIT_STORAGE_KEY === 'string'\n      ? GLOBAL_SCOPE.TEMPERATURE_UNIT_STORAGE_KEY\n      : TEMPERATURE_UNIT_STORAGE_KEY_DEFAULT;\n\n  if (GLOBAL_SCOPE.TEMPERATURE_UNIT_STORAGE_KEY !== existing) {\n    try {\n      GLOBAL_SCOPE.TEMPERATURE_UNIT_STORAGE_KEY = existing;\n    } catch (assignError) {\n      if (typeof console !== 'undefined' && typeof console.warn === 'function') {\n        console.warn('Unable to assign temperature unit storage key globally.', assignError);\n      }\n      try {\n        Object.defineProperty(GLOBAL_SCOPE, 'TEMPERATURE_UNIT_STORAGE_KEY', {\n          configurable: true,\n          writable: true,\n          value: existing,\n        });\n      } catch (defineError) {\n        if (typeof console !== 'undefined' && typeof console.warn === 'function') {\n          console.warn('Unable to expose temperature unit storage key globally.', defineError);\n        }\n      }\n    }\n  }\n\n  return existing;\n}\n\nvar TEMPERATURE_UNIT_STORAGE_KEY_NAME = resolveTemperatureUnitStorageKey();\nvar FOCUS_SCALE_STORAGE_KEY_NAME = (function resolveFocusScaleStorageKey() {\n  if (!GLOBAL_SCOPE) {\n    return FOCUS_SCALE_STORAGE_KEY_DEFAULT;\n  }\n\n  const existing =\n    typeof GLOBAL_SCOPE.FOCUS_SCALE_STORAGE_KEY === 'string'\n      ? GLOBAL_SCOPE.FOCUS_SCALE_STORAGE_KEY\n      : FOCUS_SCALE_STORAGE_KEY_DEFAULT;\n\n  if (GLOBAL_SCOPE.FOCUS_SCALE_STORAGE_KEY !== existing) {\n    try {\n      GLOBAL_SCOPE.FOCUS_SCALE_STORAGE_KEY = existing;\n    } catch (assignError) {\n      if (typeof console !== 'undefined' && typeof console.warn === 'function') {\n        console.warn('Unable to assign focus scale storage key globally.', assignError);\n      }\n    }\n  }\n\n  if (GLOBAL_SCOPE.FOCUS_SCALE_STORAGE_KEY_NAME !== existing) {\n    try {\n      GLOBAL_SCOPE.FOCUS_SCALE_STORAGE_KEY_NAME = existing;\n    } catch (defineError) {\n      if (typeof console !== 'undefined' && typeof console.warn === 'function') {\n        console.warn('Unable to expose focus scale storage key globally.', defineError);\n      }\n    }\n  }\n\n  return existing;\n})();\nvar AUTO_GEAR_RULES_STORAGE_KEY = 'cameraPowerPlanner_autoGearRules';\nvar AUTO_GEAR_SEEDED_STORAGE_KEY = 'cameraPowerPlanner_autoGearSeeded';\nvar AUTO_GEAR_BACKUPS_STORAGE_KEY = 'cameraPowerPlanner_autoGearBackups';\nvar AUTO_GEAR_PRESETS_STORAGE_KEY = 'cameraPowerPlanner_autoGearPresets';\nvar AUTO_GEAR_MONITOR_DEFAULTS_STORAGE_KEY = 'cameraPowerPlanner_autoGearMonitorDefaults';\nvar AUTO_GEAR_ACTIVE_PRESET_STORAGE_KEY = 'cameraPowerPlanner_autoGearActivePreset';\nvar AUTO_GEAR_AUTO_PRESET_STORAGE_KEY = 'cameraPowerPlanner_autoGearAutoPreset';\nvar AUTO_GEAR_BACKUP_VISIBILITY_STORAGE_KEY = 'cameraPowerPlanner_autoGearShowBackups';\nvar AUTO_GEAR_BACKUP_RETENTION_STORAGE_KEY = 'cameraPowerPlanner_autoGearBackupRetention';\nvar FULL_BACKUP_HISTORY_STORAGE_KEY = 'cameraPowerPlanner_fullBackups';\nvar STORAGE_AUTO_BACKUP_NAME_PREFIX = 'auto-backup-';\nvar STORAGE_AUTO_BACKUP_DELETION_PREFIX = 'auto-backup-before-delete-';\nvar STORAGE_AUTO_BACKUP_RENAMED_FLAG = '__cineAutoBackupRenamed';\nvar AUTO_BACKUP_METADATA_PROPERTY = '__cineAutoBackupMetadata';\nvar AUTO_BACKUP_SNAPSHOT_PROPERTY = '__cineAutoBackupSnapshot';\nvar AUTO_BACKUP_SNAPSHOT_VERSION = 1;\nvar AUTO_BACKUP_PAYLOAD_COMPRESSION_FLAG = '__cineAutoBackupCompressedPayload';\nvar AUTO_BACKUP_CYCLE_PLACEHOLDER = '__cineCircular__';\n\nvar projectActivityTimestamps = new Map();\nvar forcedCompressedProjectKeys = typeof Set === 'function' ? new Set() : null;\nvar AUTO_BACKUP_PAYLOAD_COMPRESSION_MIN_LENGTH = 2048;\n\nfunction isAutoBackupStorageKey(name) {\n  return typeof name === 'string'\n    && (name.startsWith(STORAGE_AUTO_BACKUP_NAME_PREFIX)\n      || name.startsWith(STORAGE_AUTO_BACKUP_DELETION_PREFIX));\n}\n\nif (GLOBAL_SCOPE && typeof GLOBAL_SCOPE === 'object') {\n  try {\n    if (!Object.prototype.hasOwnProperty.call(GLOBAL_SCOPE, '__CINE_AUTO_BACKUP_RENAMED_FLAG')) {\n      Object.defineProperty(GLOBAL_SCOPE, '__CINE_AUTO_BACKUP_RENAMED_FLAG', {\n        configurable: true,\n        writable: false,\n        value: STORAGE_AUTO_BACKUP_RENAMED_FLAG,\n      });\n    }\n  } catch (error) {\n    void error;\n    try {\n      GLOBAL_SCOPE.__CINE_AUTO_BACKUP_RENAMED_FLAG = STORAGE_AUTO_BACKUP_RENAMED_FLAG;\n    } catch (assignmentError) {\n      void assignmentError;\n    }\n  }\n}\nvar MAX_AUTO_BACKUPS = 240;\nvar MAX_DELETION_BACKUPS = 20;\nvar MAX_FULL_BACKUP_HISTORY_ENTRIES = 200;\nvar AUTO_GEAR_BACKUP_RETENTION_DEFAULT_VALUE = 36;\nvar AUTO_GEAR_BACKUP_RETENTION_MIN = 1;\nvar AUTO_GEAR_BACKUP_RETENTION_MAX = 120;\n\nfunction ensureGlobalAutoGearBackupDefaults() {\n  if (!GLOBAL_SCOPE || typeof GLOBAL_SCOPE !== 'object') {\n    return;\n  }\n\n  if (typeof GLOBAL_SCOPE.AUTO_GEAR_BACKUP_RETENTION_DEFAULT !== 'number') {\n    try {\n      GLOBAL_SCOPE.AUTO_GEAR_BACKUP_RETENTION_DEFAULT = AUTO_GEAR_BACKUP_RETENTION_DEFAULT_VALUE;\n    } catch (error) {\n      if (typeof console !== 'undefined' && typeof console.warn === 'function') {\n        console.warn('Unable to expose auto gear backup retention default globally.', error);\n      }\n    }\n  }\n\n  if (typeof GLOBAL_SCOPE.AUTO_GEAR_BACKUP_RETENTION_MIN !== 'number') {\n    try {\n      GLOBAL_SCOPE.AUTO_GEAR_BACKUP_RETENTION_MIN = AUTO_GEAR_BACKUP_RETENTION_MIN;\n    } catch (error) {\n      if (typeof console !== 'undefined' && typeof console.warn === 'function') {\n        console.warn('Unable to expose auto gear backup retention minimum globally.', error);\n      }\n    }\n  }\n}\n\nensureGlobalAutoGearBackupDefaults();\n\nfunction cloneAutoBackupMetadata(metadata) {\n  if (!metadata || typeof metadata !== 'object') {\n    return null;\n  }\n\n  return {\n    version: Number.isFinite(metadata.version) ? metadata.version : AUTO_BACKUP_SNAPSHOT_VERSION,\n    snapshotType: metadata.snapshotType === 'delta' ? 'delta' : 'full',\n    base: typeof metadata.base === 'string' ? metadata.base : null,\n    sequence: Number.isFinite(metadata.sequence) ? metadata.sequence : (metadata.snapshotType === 'delta' ? 1 : 0),\n    createdAt: typeof metadata.createdAt === 'string' ? metadata.createdAt : null,\n    changedKeys: Array.isArray(metadata.changedKeys) ? metadata.changedKeys.slice() : [],\n    removedKeys: Array.isArray(metadata.removedKeys) ? metadata.removedKeys.slice() : [],\n    payloadSignature: typeof metadata.payloadSignature === 'string'\n      ? metadata.payloadSignature\n      : null,\n    payloadCompression: isPlainObject(metadata.payloadCompression)\n      ? { ...metadata.payloadCompression }\n      : null,\n    compressedPayload: isPlainObject(metadata.compressedPayload)\n      ? cloneAutoBackupValue(metadata.compressedPayload, { stripMetadata: true })\n      : metadata.compressedPayload && typeof metadata.compressedPayload === 'string'\n        ? metadata.compressedPayload\n        : null,\n  };\n}\n\nfunction defineAutoBackupMetadata(target, metadata) {\n  if (!target || typeof target !== 'object') {\n    return;\n  }\n\n  const clonedMetadata = cloneAutoBackupMetadata(metadata);\n\n  try {\n    Object.defineProperty(target, AUTO_BACKUP_METADATA_PROPERTY, {\n      configurable: true,\n      enumerable: false,\n      writable: true,\n      value: clonedMetadata,\n    });\n  } catch (error) {\n    void error;\n    try {\n      target[AUTO_BACKUP_METADATA_PROPERTY] = clonedMetadata;\n    } catch (assignmentError) {\n      void assignmentError;\n    }\n  }\n}\n\nfunction getAutoBackupMetadata(value) {\n  if (!value || typeof value !== 'object') {\n    return null;\n  }\n\n  const metadata = value[AUTO_BACKUP_METADATA_PROPERTY];\n  if (!metadata || typeof metadata !== 'object') {\n    return null;\n  }\n\n  return metadata;\n}\n\nfunction copyAutoBackupMetadata(source, target) {\n  if (!target || typeof target !== 'object') {\n    return;\n  }\n\n  const metadata = getAutoBackupMetadata(source);\n  if (metadata) {\n    defineAutoBackupMetadata(target, metadata);\n  }\n}\n\nfunction cloneAutoBackupValue(value, options, state) {\n  const opts = options || {};\n  const cloneState = state || (typeof WeakSet === 'function'\n    ? { stack: new WeakSet(), reportedCycle: false }\n    : null);\n\n  const handleCircularClone = (input, compute) => {\n    if (!cloneState || !cloneState.stack) {\n      return compute();\n    }\n    if (cloneState.stack.has(input)) {\n      if (!cloneState.reportedCycle\n        && typeof console !== 'undefined'\n        && console\n        && typeof console.warn === 'function') {\n        try {\n          console.warn(\n            'Detected circular reference while cloning automatic backup data. Using a placeholder to keep serialization stable.',\n          );\n        } catch (e) {\n          void e;\n          // Ignore warning errors during recursion\n        }\n      }\n      if (cloneState) {\n        cloneState.reportedCycle = true;\n      }\n      return AUTO_BACKUP_CYCLE_PLACEHOLDER;\n    }\n    cloneState.stack.add(input);\n    try {\n      return compute();\n    } finally {\n      cloneState.stack.delete(input);\n    }\n  };\n\n  if (value === null || typeof value !== 'object') {\n    return value;\n  }\n\n  if (value instanceof Date) {\n    return new Date(value.getTime());\n  }\n\n  if (Array.isArray(value)) {\n    return handleCircularClone(value, () => value.map((item) => cloneAutoBackupValue(item, opts, cloneState)));\n  }\n\n  return handleCircularClone(value, () => {\n    const clone = {};\n    Object.keys(value).forEach((key) => {\n      if (opts.stripMetadata && key === AUTO_BACKUP_METADATA_PROPERTY) {\n        return;\n      }\n      clone[key] = cloneAutoBackupValue(value[key], opts, cloneState);\n    });\n\n    if (!opts.stripMetadata) {\n      const metadata = getAutoBackupMetadata(value);\n      if (metadata) {\n        defineAutoBackupMetadata(clone, metadata);\n      }\n    }\n\n    return clone;\n  });\n}\n\nfunction cloneAutoBackupValueWithLegacyNormalization(value, options) {\n  const cloneState = typeof WeakSet === 'function'\n    ? { stack: new WeakSet(), reportedCycle: false }\n    : null;\n  const cloned = cloneAutoBackupValue(value, options, cloneState);\n  const normalized = normalizeLegacyLongGopStructure(cloned);\n  return normalized !== cloned ? normalized : cloned;\n}\n\nfunction isCompressedAutoBackupSnapshotPayload(payload) {\n  if (!isPlainObject(payload)) {\n    return false;\n  }\n  if (payload[AUTO_BACKUP_PAYLOAD_COMPRESSION_FLAG] !== true) {\n    return false;\n  }\n  return typeof payload.data === 'string' && payload.data;\n}\n\nfunction prepareAutoBackupSnapshotPayloadForStorage(payload, contextName, options) {\n  if (!payload || typeof payload !== 'object') {\n    return {\n      payload,\n      compression: null,\n      compressed: false,\n      reused: false,\n      payloadSignature: null,\n    };\n  }\n\n  const opts = options || {};\n  if (opts.disableCompression) {\n    return {\n      payload,\n      compression: null,\n      compressed: false,\n      reused: false,\n      payloadSignature: typeof opts.payloadSignature === 'string'\n        ? opts.payloadSignature\n        : null,\n    };\n  }\n\n  const shouldReport = opts.reportCompression !== false;\n\n  let computedSignature = null;\n  try {\n    computedSignature = typeof opts.payloadSignature === 'string'\n      ? opts.payloadSignature\n      : createStableValueSignature(payload);\n  } catch (signatureError) {\n    computedSignature = null;\n    console.warn(\n      'Unable to compute stable signature for automatic backup payload before compression',\n      signatureError,\n    );\n  }\n\n  const existingSignature = typeof opts.existingPayloadSignature === 'string'\n    ? opts.existingPayloadSignature\n    : null;\n\n  if (\n    existingSignature\n    && computedSignature\n    && existingSignature === computedSignature\n    && isCompressedAutoBackupSnapshotPayload(opts.existingCompressedPayload)\n  ) {\n    const reusedPayload = cloneAutoBackupValue(opts.existingCompressedPayload, { stripMetadata: true });\n    const reusedCompression = isPlainObject(opts.existingPayloadCompression)\n      ? { ...opts.existingPayloadCompression }\n      : null;\n    if (\n      !opts.disableCompression\n      && typeof computedSignature === 'string'\n      && computedSignature\n    ) {\n      writeAutoBackupCompressionCache(computedSignature, reusedPayload, reusedCompression);\n    }\n    return {\n      payload: reusedPayload,\n      compression: reusedCompression,\n      compressed: true,\n      reused: true,\n      payloadSignature: computedSignature,\n    };\n  }\n\n  if (\n    !opts.disableCompression\n    && typeof computedSignature === 'string'\n    && computedSignature\n  ) {\n    const cached = readAutoBackupCompressionCache(computedSignature);\n    if (cached && cached.payload) {\n      return {\n        payload: cached.payload,\n        compression: cached.compression,\n        compressed: true,\n        reused: true,\n        payloadSignature: computedSignature,\n      };\n    }\n  }\n\n  let serialized;\n  try {\n    serialized = JSON.stringify(payload);\n  } catch (error) {\n    console.warn('Unable to serialize auto backup payload before compression', error);\n    return {\n      payload,\n      compression: null,\n      compressed: false,\n      reused: false,\n      payloadSignature: computedSignature,\n    };\n  }\n\n  if (typeof serialized !== 'string' || serialized.length < AUTO_BACKUP_PAYLOAD_COMPRESSION_MIN_LENGTH) {\n    return {\n      payload,\n      compression: null,\n      compressed: false,\n      reused: false,\n      payloadSignature: computedSignature,\n    };\n  }\n\n  if (\n    !opts.disableCompression\n    && isCompressedAutoBackupSnapshotPayload(opts.existingCompressedPayload)\n  ) {\n    const decodedExisting = decodeCompressedJsonStorageValue(\n      opts.existingCompressedPayload.data,\n    );\n    if (decodedExisting.success && typeof decodedExisting.value === 'string') {\n      if (decodedExisting.value === serialized) {\n        const reusedPayload = cloneAutoBackupValue(opts.existingCompressedPayload, {\n          stripMetadata: true,\n        });\n        const reusedCompression = isPlainObject(opts.existingPayloadCompression)\n          ? { ...opts.existingPayloadCompression }\n          : null;\n        const resolvedSignature = typeof computedSignature === 'string'\n          && computedSignature\n          ? computedSignature\n          : (typeof existingSignature === 'string' && existingSignature\n            ? existingSignature\n            : null);\n        if (resolvedSignature) {\n          writeAutoBackupCompressionCache(\n            resolvedSignature,\n            reusedPayload,\n            reusedCompression,\n          );\n        }\n        return {\n          payload: reusedPayload,\n          compression: reusedCompression,\n          compressed: true,\n          reused: true,\n          payloadSignature: resolvedSignature,\n        };\n      }\n    }\n  }\n\n  const candidate = createCompressedJsonStorageCandidate(serialized);\n  if (!candidate || typeof candidate.serialized !== 'string') {\n    return {\n      payload,\n      compression: null,\n      compressed: false,\n      reused: false,\n      payloadSignature: computedSignature,\n    };\n  }\n\n  const savings = candidate.originalLength - candidate.wrappedLength;\n  const compressedPayload = {\n    [AUTO_BACKUP_PAYLOAD_COMPRESSION_FLAG]: true,\n    data: candidate.serialized,\n    originalLength: candidate.originalLength,\n    compressedLength: candidate.wrappedLength,\n    compressionVariant: candidate.compressionVariant || null,\n  };\n\n  const compressionInfo =\n    typeof candidate.originalLength === 'number'\n      && Number.isFinite(candidate.originalLength)\n      && typeof candidate.wrappedLength === 'number'\n      && Number.isFinite(candidate.wrappedLength)\n      ? {\n        originalLength: candidate.originalLength,\n        compressedLength: candidate.wrappedLength,\n        compressionVariant: candidate.compressionVariant || null,\n      }\n      : null;\n\n  if (\n    !opts.disableCompression\n    && typeof computedSignature === 'string'\n    && computedSignature\n  ) {\n    writeAutoBackupCompressionCache(\n      computedSignature,\n      compressedPayload,\n      compressionInfo,\n    );\n  }\n\n  if (\n    shouldReport\n    && typeof console !== 'undefined'\n    && typeof console.warn === 'function'\n    && savings > 0\n  ) {\n    const label = typeof contextName === 'string' && contextName\n      ? `\"${contextName}\"`\n      : 'an automatic backup';\n    const percent = candidate.originalLength > 0\n      ? Math.round((savings / candidate.originalLength) * 100)\n      : 0;\n    const message = `Stored compressed payload for ${label} snapshot to reduce storage usage by ${savings} characters (${percent}%).`;\n    logCompressionSavingsEvent('auto-backup', contextName || label, message, savings, percent);\n  }\n\n  return {\n    payload: compressedPayload,\n    compression: {\n      originalLength: candidate.originalLength,\n      compressedLength: candidate.wrappedLength,\n      compressionVariant: candidate.compressionVariant || null,\n    },\n    compressed: true,\n    reused: false,\n    payloadSignature: computedSignature,\n  };\n}\n\nfunction restoreAutoBackupSnapshotPayload(snapshot, contextName) {\n  if (!snapshot || typeof snapshot !== 'object') {\n    return { payload: snapshot, compressed: false };\n  }\n\n  const rawPayload = snapshot.payload;\n  if (!isCompressedAutoBackupSnapshotPayload(rawPayload)) {\n    return { payload: rawPayload, compressed: false };\n  }\n\n  const decoded = decodeCompressedJsonStorageValue(rawPayload.data);\n  if (!decoded.success || typeof decoded.value !== 'string') {\n    const details = decoded && decoded.error ? decoded.error : null;\n    console.warn('Unable to decompress automatic backup payload.', contextName, details);\n    throw new Error('Failed to decompress automatic backup payload');\n  }\n\n  try {\n    const parsed = JSON.parse(decoded.value);\n    return { payload: parsed, compressed: true };\n  } catch (error) {\n    console.warn('Unable to parse decompressed automatic backup payload.', contextName, error);\n    throw error;\n  }\n}\n\nfunction deriveAutoBackupCreatedAt(name, fallbackDate) {\n  const info = parseAutoBackupKey(name);\n  if (info && Number.isFinite(info.timestamp) && info.timestamp > 0) {\n    try {\n      return new Date(info.timestamp).toISOString();\n    } catch (error) {\n      void error;\n    }\n  }\n\n  const sourceDate = fallbackDate instanceof Date ? fallbackDate : new Date();\n  try {\n    return sourceDate.toISOString();\n  } catch (error) {\n    void error;\n    return new Date().toISOString();\n  }\n}\n\nfunction detectCyclicAutoBackupReference(entries, name, metadata) {\n  if (!isPlainObject(entries) || !metadata || metadata.snapshotType !== 'delta') {\n    return { cycle: false, path: [] };\n  }\n\n  const visited = new Set();\n  const path = [];\n  const maxSteps = Math.max(10, Object.keys(entries).length + 5);\n  let steps = 0;\n  let currentName = name;\n  let currentMetadata = metadata;\n\n  while (currentMetadata && currentMetadata.snapshotType === 'delta') {\n    if (steps > maxSteps) {\n      return { cycle: true, path };\n    }\n\n    const baseName = typeof currentMetadata.base === 'string' ? currentMetadata.base : null;\n    if (!baseName) {\n      return { cycle: false, path };\n    }\n\n    if (!isAutoBackupStorageKey(baseName)) {\n      return { cycle: false, path };\n    }\n\n    if (visited.has(baseName)) {\n      path.push(baseName);\n      return { cycle: true, path };\n    }\n\n    visited.add(currentName);\n    path.push(currentName);\n\n    const baseEntry = Object.prototype.hasOwnProperty.call(entries, baseName)\n      ? entries[baseName]\n      : null;\n    if (!isPlainObject(baseEntry)) {\n      return { cycle: false, path };\n    }\n\n    currentName = baseName;\n    currentMetadata = getAutoBackupMetadata(baseEntry);\n    if (!currentMetadata) {\n      return { cycle: false, path };\n    }\n\n    steps += 1;\n  }\n\n  return { cycle: false, path };\n}\n\nfunction promoteAutoBackupMetadataToFull(metadata, name, value) {\n  if (!metadata || typeof metadata !== 'object') {\n    return;\n  }\n\n  metadata.snapshotType = 'full';\n  metadata.base = null;\n  metadata.sequence = 0;\n  metadata.removedKeys = [];\n\n  const keys = isPlainObject(value) ? Object.keys(value) : [];\n  metadata.changedKeys = keys.slice();\n\n  if (typeof metadata.createdAt !== 'string' || !metadata.createdAt) {\n    metadata.createdAt = deriveAutoBackupCreatedAt(name);\n  }\n}\n\nfunction expandAutoBackupEntries(container, options) {\n  if (!isPlainObject(container)) {\n    return container;\n  }\n\n  const result = {};\n  const cache = new Map();\n  const opts = options || {};\n  const isAutoBackupKey = typeof opts.isAutoBackupKey === 'function'\n    ? opts.isAutoBackupKey\n    : isAutoBackupStorageKey;\n  const filter = typeof opts.filter === 'function' ? opts.filter : null;\n\n  const shouldIncludeEntry = filter\n    ? (name) => {\n      let include = false;\n      try {\n        include = filter(name);\n      } catch (filterError) {\n        include = false;\n        void filterError;\n      }\n      return include;\n    }\n    : () => true;\n\n  const resolve = (name, stack) => {\n    if (cache.has(name)) {\n      return cache.get(name);\n    }\n\n    const rawValue = container[name];\n    const restored = restoreCompressedProjectEntry(rawValue, name);\n    const value = restored.restored ? restored.value : rawValue;\n    if (!isPlainObject(value)) {\n      const clonedValue = cloneAutoBackupValue(value);\n      cache.set(name, clonedValue);\n      return clonedValue;\n    }\n\n    const snapshot = value[AUTO_BACKUP_SNAPSHOT_PROPERTY];\n    if (snapshot && typeof snapshot === 'object') {\n      if (stack.has(name)) {\n        console.warn('Detected cyclic auto-backup reference while expanding snapshot', name);\n        let fallbackPayload = {};\n        let payloadKeys = [];\n        let payloadSignature = null;\n\n        try {\n          const payloadInfo = restoreAutoBackupSnapshotPayload(snapshot, name);\n          if (payloadInfo && isPlainObject(payloadInfo.payload)) {\n            fallbackPayload = cloneAutoBackupValue(payloadInfo.payload);\n            payloadKeys = Object.keys(payloadInfo.payload);\n            try {\n              payloadSignature = createStableValueSignature(payloadInfo.payload);\n            } catch (cycleSignatureError) {\n              payloadSignature = null;\n              console.warn(\n                'Unable to compute stable signature for automatic backup payload after detecting a cycle',\n                cycleSignatureError,\n              );\n            }\n          }\n        } catch (cyclePayloadError) {\n          console.warn(\n            'Failed to restore automatic backup payload after detecting a cyclic reference',\n            name,\n            cyclePayloadError,\n          );\n        }\n\n        const metadata = {\n          version: Number.isFinite(snapshot.version) ? snapshot.version : AUTO_BACKUP_SNAPSHOT_VERSION,\n          snapshotType: 'full',\n          base: null,\n          sequence: Number.isFinite(snapshot.sequence) ? snapshot.sequence : 0,\n          createdAt: typeof snapshot.createdAt === 'string'\n            ? snapshot.createdAt\n            : deriveAutoBackupCreatedAt(name),\n          changedKeys: payloadKeys.slice(),\n          removedKeys: [],\n          payloadSignature,\n        };\n\n        if (isCompressedAutoBackupSnapshotPayload(snapshot.payload)) {\n          metadata.compressedPayload = cloneAutoBackupValue(snapshot.payload, { stripMetadata: true });\n          metadata.payloadCompression = isPlainObject(snapshot.payloadCompression)\n            ? { ...snapshot.payloadCompression }\n            : null;\n        } else {\n          metadata.compressedPayload = null;\n          metadata.payloadCompression = null;\n        }\n\n        defineAutoBackupMetadata(fallbackPayload, metadata);\n        cache.set(name, fallbackPayload);\n        return fallbackPayload;\n      }\n\n      stack.add(name);\n\n      const snapshotType = snapshot.snapshotType === 'delta' ? 'delta' : 'full';\n      const baseName = snapshotType === 'delta' && typeof snapshot.base === 'string'\n        ? snapshot.base\n        : null;\n      const baseValue = baseName ? cloneAutoBackupValue(resolve(baseName, stack)) : {};\n      let payloadInfo;\n      try {\n        payloadInfo = restoreAutoBackupSnapshotPayload(snapshot, name);\n      } catch (payloadError) {\n        console.warn('Failed to restore automatic backup payload while expanding snapshot', name, payloadError);\n        throw payloadError;\n      }\n      const payload = isPlainObject(payloadInfo.payload) ? payloadInfo.payload : {};\n      const changedKeys = Array.isArray(snapshot.changedKeys) && snapshot.changedKeys.length\n        ? snapshot.changedKeys\n        : Object.keys(payload);\n      const removedKeys = Array.isArray(snapshot.removedKeys) ? snapshot.removedKeys : [];\n\n      const expanded = cloneAutoBackupValue(baseValue);\n\n      changedKeys.forEach((key) => {\n        if (Object.prototype.hasOwnProperty.call(payload, key)) {\n          if (expanded) {\n            expanded[key] = cloneAutoBackupValue(payload[key]);\n          }\n        }\n      });\n\n      removedKeys.forEach((key) => {\n        if (Object.prototype.hasOwnProperty.call(expanded, key)) {\n          delete expanded[key];\n        }\n      });\n\n      const metadata = {\n        version: Number.isFinite(snapshot.version) ? snapshot.version : AUTO_BACKUP_SNAPSHOT_VERSION,\n        snapshotType,\n        base: snapshotType === 'delta' ? baseName : null,\n        sequence: Number.isFinite(snapshot.sequence)\n          ? snapshot.sequence\n          : (snapshotType === 'delta' ? 1 : 0),\n        createdAt: typeof snapshot.createdAt === 'string'\n          ? snapshot.createdAt\n          : deriveAutoBackupCreatedAt(name),\n        changedKeys: changedKeys.slice(),\n        removedKeys: removedKeys.slice(),\n      };\n\n      try {\n        metadata.payloadSignature = createStableValueSignature(payload);\n      } catch (payloadSignatureError) {\n        metadata.payloadSignature = null;\n        console.warn(\n          'Unable to compute stable signature for automatic backup payload during expansion',\n          payloadSignatureError,\n        );\n      }\n\n      if (isCompressedAutoBackupSnapshotPayload(snapshot.payload)) {\n        metadata.compressedPayload = cloneAutoBackupValue(snapshot.payload, { stripMetadata: true });\n        metadata.payloadCompression = isPlainObject(snapshot.payloadCompression)\n          ? { ...snapshot.payloadCompression }\n          : null;\n      } else {\n        metadata.compressedPayload = null;\n        metadata.payloadCompression = null;\n      }\n\n      defineAutoBackupMetadata(expanded, metadata);\n      cache.set(name, expanded);\n      stack.delete(name);\n      return expanded;\n    }\n\n    const cloned = cloneAutoBackupValue(value);\n    if (isAutoBackupKey(name)) {\n      const metadata = {\n        version: AUTO_BACKUP_SNAPSHOT_VERSION,\n        snapshotType: 'full',\n        base: null,\n        sequence: 0,\n        createdAt: deriveAutoBackupCreatedAt(name),\n        changedKeys: Object.keys(cloned),\n        removedKeys: [],\n      };\n      defineAutoBackupMetadata(cloned, metadata);\n    }\n    cache.set(name, cloned);\n    return cloned;\n  };\n\n  Object.keys(container).forEach((name) => {\n    if (!shouldIncludeEntry(name)) {\n      return;\n    }\n    if (!isAutoBackupKey(name)) {\n      const value = container[name];\n      result[name] = isPlainObject(value)\n        ? cloneAutoBackupValue(value)\n        : value;\n      return;\n    }\n\n    result[name] = resolve(name, new Set());\n  });\n\n  return result;\n}\n\nfunction computeAutoBackupDiff(currentValue, baseValue) {\n  const payload = {};\n  const changedKeys = [];\n  const removedKeys = [];\n\n  const baseKeys = isPlainObject(baseValue) ? Object.keys(baseValue) : [];\n  const currentKeys = isPlainObject(currentValue) ? Object.keys(currentValue) : [];\n  const allKeys = new Set([...baseKeys, ...currentKeys]);\n\n  allKeys.forEach((key) => {\n    if (key === AUTO_BACKUP_METADATA_PROPERTY) {\n      return;\n    }\n\n    const hasCurrent = Object.prototype.hasOwnProperty.call(currentValue || {}, key);\n    const hasBase = Object.prototype.hasOwnProperty.call(baseValue || {}, key);\n\n    if (!hasCurrent && hasBase) {\n      removedKeys.push(key);\n      return;\n    }\n\n    if (!hasCurrent) {\n      return;\n    }\n\n    const currentEntry = currentValue ? currentValue[key] : undefined;\n    const baseEntry = hasBase ? baseValue[key] : undefined;\n\n    const currentSignature = createStableValueSignature(currentEntry);\n    const baseSignature = createStableValueSignature(baseEntry);\n\n    if (currentSignature !== baseSignature) {\n      changedKeys.push(key);\n      payload[key] = cloneAutoBackupValue(currentEntry, { stripMetadata: true });\n    }\n  });\n\n  return { payload, changedKeys, removedKeys };\n}\n\nfunction serializeAutoBackupEntries(entries, options) {\n  if (!isPlainObject(entries)) {\n    return entries;\n  }\n\n  const opts = options || {};\n  const isAutoBackupKey = typeof opts.isAutoBackupKey === 'function'\n    ? opts.isAutoBackupKey\n    : isAutoBackupStorageKey;\n\n  const serialized = {};\n  const entryNames = Object.keys(entries);\n\n  const latestAutoBackupNames = (() => {\n    const groups = new Map();\n    entryNames.forEach((name) => {\n      if (!isAutoBackupKey(name)) {\n        return;\n      }\n      const value = entries[name];\n      const metadata = getAutoBackupMetadata(value);\n      let timestamp = Number.NEGATIVE_INFINITY;\n      if (metadata && typeof metadata.createdAt === 'string') {\n        const parsed = Date.parse(metadata.createdAt);\n        if (!Number.isNaN(parsed)) {\n          timestamp = parsed;\n        }\n      }\n      if (!Number.isFinite(timestamp)) {\n        const parsedKey = parseAutoBackupKey(name);\n        if (parsedKey && Number.isFinite(parsedKey.timestamp)) {\n          timestamp = parsedKey.timestamp;\n        }\n      }\n      const groupKey = name.startsWith(STORAGE_AUTO_BACKUP_DELETION_PREFIX)\n        ? STORAGE_AUTO_BACKUP_DELETION_PREFIX\n        : STORAGE_AUTO_BACKUP_NAME_PREFIX;\n      const current = groups.get(groupKey);\n      if (\n        !current\n        || timestamp > current.timestamp\n        || (timestamp === current.timestamp && name.localeCompare(current.name) > 0)\n      ) {\n        groups.set(groupKey, { name, timestamp });\n      }\n    });\n    const result = new Set();\n    groups.forEach(({ name }) => {\n      if (typeof name === 'string' && name) {\n        result.add(name);\n      }\n    });\n    return result;\n  })();\n\n  entryNames.forEach((name) => {\n    const value = entries[name];\n    const normalizedValue = cloneAutoBackupValueWithLegacyNormalization(value, { stripMetadata: true });\n\n    if (!isAutoBackupKey(name) || !isPlainObject(normalizedValue)) {\n      serialized[name] = normalizedValue;\n      return;\n    }\n\n    const disableCompressionForName = latestAutoBackupNames.has(name);\n    const metadata = getAutoBackupMetadata(value);\n    if (metadata && metadata.snapshotType === 'delta') {\n      const cycleInfo = detectCyclicAutoBackupReference(entries, name, metadata);\n      if (cycleInfo.cycle) {\n        if (typeof console !== 'undefined' && typeof console.warn === 'function') {\n          console.warn(\n            'Detected cyclic automatic backup chain during serialization. Promoting to full snapshot.',\n            name,\n          );\n        }\n        promoteAutoBackupMetadataToFull(metadata, name, normalizedValue);\n      }\n    }\n    const createdAt = metadata && typeof metadata.createdAt === 'string'\n      ? metadata.createdAt\n      : deriveAutoBackupCreatedAt(name);\n\n    if (!metadata || metadata.snapshotType !== 'delta') {\n      serialized[name] = {};\n      const snapshot = {\n        version: AUTO_BACKUP_SNAPSHOT_VERSION,\n        snapshotType: 'full',\n        base: null,\n        sequence: 0,\n        createdAt,\n        changedKeys: Object.keys(normalizedValue || {}),\n        removedKeys: [],\n      };\n      let payloadSignature;\n      try {\n        payloadSignature = createStableValueSignature(normalizedValue);\n      } catch (signatureError) {\n        payloadSignature = null;\n        console.warn(\n          'Unable to compute stable signature for automatic backup payload before serialization',\n          signatureError,\n        );\n      }\n      const prepared = prepareAutoBackupSnapshotPayloadForStorage(normalizedValue, name, {\n        disableCompression: disableCompressionForName,\n        payloadSignature,\n        existingCompressedPayload: metadata ? metadata.compressedPayload : null,\n        existingPayloadCompression: metadata ? metadata.payloadCompression : null,\n        existingPayloadSignature: metadata ? metadata.payloadSignature : null,\n      });\n      snapshot.payload = prepared.payload;\n      if (prepared.compression) {\n        snapshot.payloadCompression = prepared.compression;\n      }\n      if (metadata) {\n        const resolvedSignature = typeof prepared.payloadSignature === 'string'\n          ? prepared.payloadSignature\n          : payloadSignature;\n        metadata.payloadSignature = resolvedSignature || null;\n        if (prepared.compressed) {\n          metadata.compressedPayload = cloneAutoBackupValue(prepared.payload, { stripMetadata: true });\n          metadata.payloadCompression = prepared.compression\n            ? { ...prepared.compression }\n            : null;\n        } else {\n          metadata.compressedPayload = null;\n          metadata.payloadCompression = null;\n        }\n      }\n      serialized[name][AUTO_BACKUP_SNAPSHOT_PROPERTY] = snapshot;\n      return;\n    }\n\n    const baseName = typeof metadata.base === 'string' ? metadata.base : null;\n    const baseValue = baseName && Object.prototype.hasOwnProperty.call(entries, baseName)\n      ? entries[baseName]\n      : null;\n\n    if (!baseValue || !isPlainObject(baseValue)) {\n      serialized[name] = {};\n      const snapshot = {\n        version: AUTO_BACKUP_SNAPSHOT_VERSION,\n        snapshotType: 'full',\n        base: null,\n        sequence: 0,\n        createdAt,\n        changedKeys: Object.keys(normalizedValue || {}),\n        removedKeys: [],\n      };\n      let payloadSignature;\n      try {\n        payloadSignature = createStableValueSignature(normalizedValue);\n      } catch (signatureError) {\n        payloadSignature = null;\n        console.warn(\n          'Unable to compute stable signature for automatic backup payload before serialization',\n          signatureError,\n        );\n      }\n      const prepared = prepareAutoBackupSnapshotPayloadForStorage(normalizedValue, name, {\n        disableCompression: disableCompressionForName,\n        payloadSignature,\n        existingCompressedPayload: metadata ? metadata.compressedPayload : null,\n        existingPayloadCompression: metadata ? metadata.payloadCompression : null,\n        existingPayloadSignature: metadata ? metadata.payloadSignature : null,\n      });\n      snapshot.payload = prepared.payload;\n      if (prepared.compression) {\n        snapshot.payloadCompression = prepared.compression;\n      }\n      if (metadata) {\n        const resolvedSignature = typeof prepared.payloadSignature === 'string'\n          ? prepared.payloadSignature\n          : payloadSignature;\n        metadata.payloadSignature = resolvedSignature || null;\n        if (prepared.compressed) {\n          metadata.compressedPayload = cloneAutoBackupValue(prepared.payload, { stripMetadata: true });\n          metadata.payloadCompression = prepared.compression\n            ? { ...prepared.compression }\n            : null;\n        } else {\n          metadata.compressedPayload = null;\n          metadata.payloadCompression = null;\n        }\n      }\n      serialized[name][AUTO_BACKUP_SNAPSHOT_PROPERTY] = snapshot;\n      return;\n    }\n\n    const normalizedBase = cloneAutoBackupValueWithLegacyNormalization(baseValue, { stripMetadata: true });\n    const diff = computeAutoBackupDiff(normalizedValue, normalizedBase);\n\n    serialized[name] = {};\n    const snapshot = {\n      version: Number.isFinite(metadata.version) ? metadata.version : AUTO_BACKUP_SNAPSHOT_VERSION,\n      snapshotType: 'delta',\n      base: baseName,\n      sequence: Number.isFinite(metadata.sequence) ? metadata.sequence : 1,\n      createdAt,\n      changedKeys: diff.changedKeys,\n      removedKeys: diff.removedKeys,\n    };\n    let payloadSignature;\n    try {\n      payloadSignature = createStableValueSignature(diff.payload);\n    } catch (signatureError) {\n      payloadSignature = null;\n      console.warn(\n        'Unable to compute stable signature for automatic backup delta payload before serialization',\n        signatureError,\n      );\n    }\n    const prepared = prepareAutoBackupSnapshotPayloadForStorage(diff.payload, name, {\n      disableCompression: disableCompressionForName,\n      payloadSignature,\n      existingCompressedPayload: metadata ? metadata.compressedPayload : null,\n      existingPayloadCompression: metadata ? metadata.payloadCompression : null,\n      existingPayloadSignature: metadata ? metadata.payloadSignature : null,\n    });\n    snapshot.payload = prepared.payload;\n    if (prepared.compression) {\n      snapshot.payloadCompression = prepared.compression;\n    }\n    if (metadata) {\n      const resolvedSignature = typeof prepared.payloadSignature === 'string'\n        ? prepared.payloadSignature\n        : payloadSignature;\n      metadata.payloadSignature = resolvedSignature || null;\n      if (prepared.compressed) {\n        metadata.compressedPayload = cloneAutoBackupValue(prepared.payload, { stripMetadata: true });\n        metadata.payloadCompression = prepared.compression\n          ? { ...prepared.compression }\n          : null;\n      } else {\n        metadata.compressedPayload = null;\n        metadata.payloadCompression = null;\n      }\n    }\n    serialized[name][AUTO_BACKUP_SNAPSHOT_PROPERTY] = snapshot;\n  });\n\n  return serialized;\n}\n\nfunction getStorageKeyVariants(key) {\n  if (typeof key !== 'string' || !key) {\n    return [key];\n  }\n\n  const variants = new Set([key]);\n\n  if (key.startsWith('cameraPowerPlanner_')) {\n    variants.add(`cinePowerPlanner_${key.slice('cameraPowerPlanner_'.length)}`);\n  } else if (key.startsWith('cinePowerPlanner_')) {\n    variants.add(`cameraPowerPlanner_${key.slice('cinePowerPlanner_'.length)}`);\n  }\n\n  return Array.from(variants);\n}\n\nvar SETUP_STORAGE_KEY_VARIANTS = new Set(getStorageKeyVariants(SETUP_STORAGE_KEY));\n\nfunction getDeviceStorageKeyVariants() {\n  if (\n    !DEVICE_STORAGE_KEY_VARIANTS\n    || typeof DEVICE_STORAGE_KEY_VARIANTS.has !== 'function'\n  ) {\n    DEVICE_STORAGE_KEY_VARIANTS = new Set(getStorageKeyVariants(DEVICE_STORAGE_KEY));\n  }\n  return DEVICE_STORAGE_KEY_VARIANTS;\n}\n\nfunction isDeviceStorageKeyVariant(key) {\n  if (typeof key !== 'string' || !key) {\n    return false;\n  }\n\n  const variants = getDeviceStorageKeyVariants();\n  if (variants && typeof variants.has === 'function') {\n    return variants.has(key);\n  }\n\n  return key === DEVICE_STORAGE_KEY;\n}\n\nfunction shouldAllowCriticalSweepPrimaryInspection(key) {\n  if (typeof key !== 'string' || !key) {\n    return false;\n  }\n\n  if (!SETUP_STORAGE_KEY_VARIANTS || typeof SETUP_STORAGE_KEY_VARIANTS.has !== 'function') {\n    return false;\n  }\n\n  if (!SETUP_STORAGE_KEY_VARIANTS.has(key)) {\n    return false;\n  }\n\n  if (ACTIVE_PROJECT_COMPRESSION_HOLD_ENABLED) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction inspectSetupStorageForQuotaRecovery(storage, skipKeysSet) {\n  if (!storage || typeof storage.getItem !== 'function') {\n    return;\n  }\n\n  if (!SETUP_STORAGE_KEY_VARIANTS || typeof SETUP_STORAGE_KEY_VARIANTS.forEach !== 'function') {\n    return;\n  }\n\n  const visited = new Set();\n  const skipSet = skipKeysSet && typeof skipKeysSet.has === 'function' ? skipKeysSet : null;\n\n  SETUP_STORAGE_KEY_VARIANTS.forEach((key) => {\n    if (typeof key !== 'string' || !key || visited.has(key)) {\n      return;\n    }\n\n    visited.add(key);\n\n    if (skipSet && skipSet.has(key)) {\n      return;\n    }\n\n    try {\n      storage.getItem(key);\n    } catch (inspectionError) {\n      void inspectionError;\n    }\n  });\n}\n\nvar STORAGE_BACKUP_SUFFIX = '__backup';\nvar MAX_SAVE_ATTEMPTS = 3;\nvar MAX_QUOTA_RECOVERY_STEPS = 100;\nvar STORAGE_MIGRATION_BACKUP_SUFFIX = '__legacyMigrationBackup';\nvar RAW_STORAGE_BACKUP_KEYS = new Set([\n  getCustomFontStorageKeyName(),\n  CUSTOM_LOGO_STORAGE_KEY,\n  DEVICE_SCHEMA_CACHE_KEY,\n  CONTACTS_STORAGE_KEY,\n  OWN_GEAR_STORAGE_KEY,\n  DOCUMENTATION_TRACKER_STORAGE_KEY,\n  MOUNT_VOLTAGE_STORAGE_KEY_NAME,\n  FOCUS_SCALE_STORAGE_KEY_NAME,\n  PRINT_PREFERENCES_STORAGE_KEY,\n]);\n\nArray.from(RAW_STORAGE_BACKUP_KEYS).forEach((key) => {\n  getStorageKeyVariants(key).forEach((variant) => {\n    if (typeof variant === 'string' && variant) {\n      RAW_STORAGE_BACKUP_KEYS.add(variant);\n    }\n  });\n});\n\nvar CRITICAL_BACKUP_KEY_PROVIDERS = [\n  () => ({ key: DEVICE_STORAGE_KEY }),\n  () => ({ key: SETUP_STORAGE_KEY }),\n  () => ({ key: SESSION_STATE_KEY }),\n  () => ({ key: FEEDBACK_STORAGE_KEY }),\n  () => ({\n    key: PROJECT_STORAGE_KEY,\n    valueProvider: () => {\n      // Since we sharded projects, the main PROJECT_STORAGE_KEY is likely empty or gone.\n      // We want to reconstruct the monolithic object so that the backup file contains\n      // all projects, acting as a \"full backup\" safety net.\n      if (typeof readAllProjectsFromStorage === 'function') {\n        try {\n          const { projects } = readAllProjectsFromStorage({ forMutation: false });\n          if (projects && typeof projects === 'object') {\n            // Serialize manually to string as ensureCriticalStorageBackups expects string-ish values\n            return JSON.stringify(projects);\n          }\n        } catch (e) {\n          if (typeof console !== 'undefined' && console.warn) {\n            console.warn('Failed to reconstruct monolithic project backup', e);\n          }\n        }\n      }\n      return null;\n    }\n  }),\n  () => ({ key: FAVORITES_STORAGE_KEY }),\n  () => ({ key: CONTACTS_STORAGE_KEY }),\n  () => ({ key: OWN_GEAR_STORAGE_KEY }),\n  () => ({ key: DOCUMENTATION_TRACKER_STORAGE_KEY }),\n  () => ({ key: DEVICE_SCHEMA_CACHE_KEY }),\n  () => ({ key: AUTO_GEAR_RULES_STORAGE_KEY }),\n  () => ({ key: AUTO_GEAR_SEEDED_STORAGE_KEY }),\n  () => ({ key: AUTO_GEAR_BACKUPS_STORAGE_KEY }),\n  () => ({ key: AUTO_GEAR_PRESETS_STORAGE_KEY }),\n  () => ({ key: AUTO_GEAR_ACTIVE_PRESET_STORAGE_KEY }),\n  () => ({ key: AUTO_GEAR_AUTO_PRESET_STORAGE_KEY }),\n  () => ({ key: AUTO_GEAR_BACKUP_VISIBILITY_STORAGE_KEY }),\n  () => ({ key: AUTO_GEAR_BACKUP_RETENTION_STORAGE_KEY }),\n  () => ({ key: AUTO_GEAR_MONITOR_DEFAULTS_STORAGE_KEY }),\n  () => ({ key: FULL_BACKUP_HISTORY_STORAGE_KEY }),\n  () => ({ key: CUSTOM_LOGO_STORAGE_KEY }),\n  () => ({ key: getCustomFontStorageKeyName() }),\n  () => ({ key: 'darkMode' }),\n  () => ({ key: 'pinkMode' }),\n  () => ({ key: 'highContrast' }),\n  () => ({ key: 'reduceMotion' }),\n  () => ({ key: 'relaxedSpacing' }),\n  () => ({ key: 'showAutoBackups' }),\n  () => ({ key: 'accentColor' }),\n  () => ({ key: 'fontSize' }),\n  () => ({ key: 'fontFamily' }),\n  () => ({ key: 'language' }),\n  () => ({ key: 'iosPwaHelpShown' }),\n  () => ({ key: PRINT_PREFERENCES_STORAGE_KEY }),\n  () => ({ key: TEMPERATURE_UNIT_STORAGE_KEY_NAME }),\n  () => ({ key: getMountVoltageStorageKeyName(), backupKey: getMountVoltageStorageBackupKeyName() }),\n];\n\nfunction createCriticalStorageEntry(candidate, options = {}) {\n  if (!candidate || typeof candidate !== 'object') {\n    return null;\n  }\n\n  const { key, backupKey, storage = null } = candidate;\n  if (typeof key !== 'string' || !key) {\n    return null;\n  }\n\n  const resolvedBackupKey = typeof backupKey === 'string' && backupKey\n    ? backupKey\n    : `${key}${STORAGE_BACKUP_SUFFIX}`;\n\n  return {\n    key,\n    backupKey: resolvedBackupKey,\n    storage,\n    label: typeof options.label === 'string' ? options.label : key,\n    valueProvider: typeof candidate.valueProvider === 'function' ? candidate.valueProvider : null,\n  };\n}\n\nfunction gatherCriticalStorageEntries(options = {}) {\n  const entries = [];\n  const seen = new Set();\n\n  const pushEntry = (entry) => {\n    if (!entry) {\n      return;\n    }\n\n    const variants = getStorageKeyVariants(entry.key);\n    const expectedBaseBackupKey = `${entry.key}${STORAGE_BACKUP_SUFFIX}`;\n\n    for (let index = 0; index < variants.length; index += 1) {\n      const variantKey = variants[index];\n      if (typeof variantKey !== 'string' || !variantKey) {\n        continue;\n      }\n\n      let resolvedBackupKey = entry.backupKey;\n      if (variantKey !== entry.key) {\n        if (entry.backupKey === expectedBaseBackupKey) {\n          resolvedBackupKey = `${variantKey}${STORAGE_BACKUP_SUFFIX}`;\n        }\n      }\n\n      const variantEntry = variantKey === entry.key\n        ? entry\n        : {\n          ...entry,\n          key: variantKey,\n          backupKey: resolvedBackupKey,\n        };\n\n      const storageId = variantEntry.storage || null;\n      const id = `${variantEntry.key}__${storageId ? String(storageId) : 'default'}`;\n      if (seen.has(id)) {\n        continue;\n      }\n\n      seen.add(id);\n      entries.push(variantEntry);\n    }\n  };\n\n  for (let i = 0; i < CRITICAL_BACKUP_KEY_PROVIDERS.length; i += 1) {\n    const provider = CRITICAL_BACKUP_KEY_PROVIDERS[i];\n    if (typeof provider !== 'function') {\n      continue;\n    }\n    let result;\n    try {\n      result = provider(options);\n    } catch (providerError) {\n      var providerDetail = {\n        event: 'critical-storage',\n        action: 'collect-keys',\n        reason: 'provider-error',\n        storageType: getActiveStorageType(options && options.storage ? options.storage : null),\n        error: sanitizeStorageError(providerError),\n      };\n      logStorageEvent(\n        'warn',\n        'Critical storage key provider failed',\n        providerDetail,\n        { event: 'critical-storage', stage: 'gather' },\n        function logProviderErrorToConsole() {\n          if (typeof console !== 'undefined' && typeof console.warn === 'function') {\n            console.warn('Critical storage key provider failed', providerError);\n          }\n        },\n      );\n      continue;\n    }\n    const entry = createCriticalStorageEntry(result, options);\n    if (entry) {\n      pushEntry(entry);\n    }\n  }\n\n  return entries;\n}\n\nlet lastCriticalStorageGuardResult = null;\n\nfunction registerCriticalStorageGuardResult(result) {\n  lastCriticalStorageGuardResult = result;\n  if (!GLOBAL_SCOPE || typeof GLOBAL_SCOPE !== 'object') {\n    return;\n  }\n\n  try {\n    GLOBAL_SCOPE.__cineCriticalStorageGuard = result;\n  } catch (exposeError) {\n    void exposeError;\n    try {\n      Object.defineProperty(GLOBAL_SCOPE, '__cineCriticalStorageGuard', {\n        configurable: true,\n        writable: true,\n        value: result,\n      });\n    } catch (definitionError) {\n      void definitionError;\n    }\n  }\n}\n\nfunction ensureCriticalStorageBackups(options = {}) {\n  let safeStorage = options && options.storage ? options.storage : null;\n  if (!safeStorage) {\n    try {\n      safeStorage = getSafeLocalStorage();\n    } catch (guardError) {\n      var guardDetail = {\n        event: 'critical-storage',\n        action: 'resolve-storage',\n        reason: 'resolve-failed',\n        storageType: getActiveStorageType(options && options.storage ? options.storage : null),\n        error: sanitizeStorageError(guardError),\n      };\n      logStorageEvent(\n        'warn',\n        'Unable to resolve safe storage while ensuring backups',\n        guardDetail,\n        { event: 'critical-storage', stage: 'ensure' },\n        function logGuardErrorToConsole() {\n          if (typeof console !== 'undefined' && typeof console.warn === 'function') {\n            console.warn('Unable to resolve safe storage while ensuring backups', guardError);\n          }\n        },\n      );\n      safeStorage = null;\n    }\n  }\n\n  const summary = {\n    ensured: [],\n    skipped: [],\n    errors: [],\n    timestamp: new Date().toISOString(),\n    storageType: safeLocalStorageInfo && safeLocalStorageInfo.type ? safeLocalStorageInfo.type : 'unknown',\n  };\n\n  const entries = gatherCriticalStorageEntries(options);\n  const targetStorage = safeStorage && typeof safeStorage.getItem === 'function'\n    ? safeStorage\n    : null;\n\n  for (let index = 0; index < entries.length; index += 1) {\n    const entry = entries[index];\n    const storage = entry.storage && typeof entry.storage.getItem === 'function'\n      ? entry.storage\n      : targetStorage;\n\n    if (!storage || typeof storage.getItem !== 'function' || typeof storage.setItem !== 'function') {\n      summary.skipped.push({ key: entry.key, reason: 'unavailable-storage' });\n      continue;\n    }\n\n    let primaryValue;\n    try {\n      if (entry.valueProvider) {\n        primaryValue = entry.valueProvider();\n      } else {\n        primaryValue = storage.getItem(entry.key);\n      }\n    } catch (readError) {\n      summary.errors.push({ key: entry.key, reason: 'read-failed', error: readError });\n      var primaryReadDetail = {\n        event: 'critical-storage',\n        action: 'inspect-primary',\n        key: entry.key,\n        storageType: getActiveStorageType(storage),\n        reason: 'read-failed',\n        error: sanitizeStorageError(readError),\n      };\n      logStorageEvent(\n        'warn',\n        'Critical storage guard could not inspect ' + entry.key,\n        primaryReadDetail,\n        { event: 'critical-storage', stage: 'ensure' },\n        function logPrimaryReadFailureToConsole() {\n          if (typeof console !== 'undefined' && typeof console.warn === 'function') {\n            console.warn('Critical storage guard could not inspect ' + entry.key, readError);\n          }\n        },\n      );\n      continue;\n    }\n\n    if (primaryValue === null || primaryValue === undefined) {\n      summary.skipped.push({ key: entry.key, reason: 'missing' });\n      continue;\n    }\n\n    let backupValue;\n    try {\n      backupValue = storage.getItem(entry.backupKey);\n    } catch (backupReadError) {\n      summary.errors.push({ key: entry.key, reason: 'backup-read-failed', error: backupReadError });\n      var backupReadDetail = {\n        event: 'critical-storage',\n        action: 'inspect-backup',\n        key: entry.key,\n        backupKey: entry.backupKey,\n        storageType: getActiveStorageType(storage),\n        reason: 'backup-read-failed',\n        error: sanitizeStorageError(backupReadError),\n      };\n      logStorageEvent(\n        'warn',\n        'Critical storage guard could not read backup for ' + entry.key,\n        backupReadDetail,\n        { event: 'critical-storage', stage: 'ensure' },\n        function logBackupReadFailureToConsole() {\n          if (typeof console !== 'undefined' && typeof console.warn === 'function') {\n            console.warn('Critical storage guard could not read backup for ' + entry.key, backupReadError);\n          }\n        },\n      );\n      continue;\n    }\n\n    if (typeof backupValue === 'string') {\n      summary.skipped.push({ key: entry.key, reason: 'exists' });\n      continue;\n    }\n\n    const stringPrimaryValue = typeof primaryValue === 'string'\n      ? primaryValue\n      : primaryValue === null || primaryValue === undefined\n        ? ''\n        : String(primaryValue);\n\n    const tryStoreBackup = (candidate) => {\n      try {\n        storage.setItem(entry.backupKey, candidate);\n        return { success: true, error: null };\n      } catch (error) {\n        return { success: false, error };\n      }\n    };\n\n    const recordError = (error, reason = 'backup-write-failed') => {\n      summary.errors.push({ key: entry.key, reason, error });\n      var mirrorDetail = {\n        event: 'critical-storage',\n        action: 'mirror-backup',\n        key: entry.key,\n        backupKey: entry.backupKey,\n        storageType: getActiveStorageType(storage),\n        reason: reason,\n        error: sanitizeStorageError(error),\n      };\n      if (compressionInfo) {\n        mirrorDetail.compressed = true;\n      }\n      logStorageEvent(\n        'error',\n        'Critical storage guard could not mirror ' + entry.key,\n        mirrorDetail,\n        { event: 'critical-storage', stage: 'ensure' },\n        function logMirrorErrorToConsole() {\n          if (typeof console !== 'undefined' && typeof console.error === 'function') {\n            console.error('Critical storage guard could not mirror ' + entry.key, error);\n          }\n        },\n      );\n    };\n\n    const shouldAttemptCompression = typeof stringPrimaryValue === 'string'\n      && stringPrimaryValue\n      && !stringPrimaryValue.includes(`\"${STORAGE_COMPRESSION_FLAG_KEY}\":true`)\n      && !isDeviceStorageKeyVariant(entry.key);\n\n    let candidateValue = stringPrimaryValue;\n    let compressionInfo = null;\n    let writeResult = tryStoreBackup(candidateValue);\n\n    if (!writeResult.success && writeResult.error) {\n      if (!isQuotaExceededError(writeResult.error)) {\n        recordError(writeResult.error);\n        continue;\n      }\n\n      if (shouldAttemptCompression) {\n        const compressedCandidate = createCompressedJsonStorageCandidate(stringPrimaryValue);\n        if (compressedCandidate && typeof compressedCandidate.serialized === 'string' && compressedCandidate.serialized) {\n          candidateValue = compressedCandidate.serialized;\n          compressionInfo = compressedCandidate;\n          writeResult = tryStoreBackup(candidateValue);\n        }\n      }\n\n      if (!writeResult.success && writeResult.error && isQuotaExceededError(writeResult.error)) {\n        const skipKeys = new Set();\n\n        if (typeof entry.backupKey === 'string' && entry.backupKey) {\n          skipKeys.add(entry.backupKey);\n        }\n\n        const shouldInspectPrimaryDuringSweep = shouldAllowCriticalSweepPrimaryInspection(entry.key);\n        if (!shouldInspectPrimaryDuringSweep && typeof entry.key === 'string' && entry.key) {\n          skipKeys.add(entry.key);\n        }\n\n        if (!shouldInspectPrimaryDuringSweep && !ACTIVE_PROJECT_COMPRESSION_HOLD_ENABLED) {\n          inspectSetupStorageForQuotaRecovery(storage, skipKeys);\n        }\n\n        const sweepResult = attemptStorageCompressionSweep(storage, { skipKeys: Array.from(skipKeys) });\n        if (sweepResult && sweepResult.success) {\n          writeResult = tryStoreBackup(candidateValue);\n        }\n      }\n\n      if (!writeResult.success) {\n        recordError(writeResult.error, isQuotaExceededError(writeResult.error) ? 'backup-quota-exceeded' : 'backup-write-failed');\n        if (isQuotaExceededError(writeResult.error)) {\n          alertStorageError('critical-backup-quota');\n        }\n        continue;\n      }\n    }\n\n    summary.ensured.push({\n      key: entry.key,\n      backupKey: entry.backupKey,\n      compressed: Boolean(compressionInfo),\n    });\n\n    if (\n      compressionInfo\n      && typeof compressionInfo.originalLength === 'number'\n      && typeof compressionInfo.wrappedLength === 'number'\n    ) {\n      const savings = compressionInfo.originalLength - compressionInfo.wrappedLength;\n      const percent = compressionInfo.originalLength > 0\n        ? Math.round((savings / compressionInfo.originalLength) * 100)\n        : 0;\n      const message = `Stored compressed critical backup for ${entry.key}, reducing storage usage by ${savings} characters (${percent}%).`;\n      logCompressionSavingsEvent('critical-backup', entry.key, message, savings, percent);\n    }\n  }\n\n  registerCriticalStorageGuardResult(summary);\n\n  if (summary.ensured.length) {\n    var ensuredDetail = {\n      event: 'critical-storage',\n      action: 'mirror-summary',\n      storageType: summary.storageType || getActiveStorageType(),\n      count: summary.ensured.length,\n      timestamp: summary.timestamp,\n      entries: summary.ensured.map(function mapEnsured(entry) {\n        return {\n          key: entry.key,\n          backupKey: entry.backupKey,\n          compressed: Boolean(entry.compressed),\n        };\n      }),\n    };\n    logStorageEvent(\n      'info',\n      'Critical storage guard mirrored backup copies',\n      ensuredDetail,\n      { event: 'critical-storage', stage: 'ensure' },\n      function logEnsuredSummaryToConsole() {\n        if (typeof console !== 'undefined' && typeof console.info === 'function') {\n          const mirroredDetails = summary.ensured.map((entry) => ({\n            key: entry.key,\n            backupKey: entry.backupKey,\n          }));\n          console.info('Critical storage guard mirrored backup copies', {\n            count: summary.ensured.length,\n            entries: mirroredDetails,\n          });\n        }\n      },\n    );\n  }\n\n  if (summary.errors.length) {\n    var errorDetail = {\n      event: 'critical-storage',\n      action: 'mirror-summary',\n      storageType: summary.storageType || getActiveStorageType(),\n      count: summary.errors.length,\n      timestamp: summary.timestamp,\n      reason: 'errors-detected',\n      entries: summary.errors.map(function mapErrors(entry) {\n        return {\n          key: entry && entry.key,\n          reason: entry && entry.reason,\n          error: sanitizeStorageError(entry && entry.error),\n        };\n      }),\n    };\n    logStorageEvent(\n      'warn',\n      'Critical storage guard encountered issues',\n      errorDetail,\n      { event: 'critical-storage', stage: 'ensure' },\n      function logErrorSummaryToConsole() {\n        if (typeof console !== 'undefined' && typeof console.warn === 'function') {\n          console.warn('Critical storage guard encountered issues', summary.errors);\n        }\n      },\n    );\n  }\n\n  return summary;\n}\n\nfunction getLastCriticalStorageGuardResult() {\n  return lastCriticalStorageGuardResult;\n}\n\nvar MAX_MIGRATION_BACKUP_CLEANUP_STEPS = 10;\nvar MIGRATION_BACKUP_COMPRESSION_ALGORITHM = 'lz-string';\nvar MIGRATION_BACKUP_COMPRESSION_ENCODING = 'json-string';\nvar MIGRATION_BACKUP_COMPRESSION_VARIANTS = [\n  { variant: 'utf16', compress: 'compressToUTF16', decompress: 'decompressFromUTF16' },\n  { variant: 'uri-component', compress: 'compressToEncodedURIComponent', decompress: 'decompressFromEncodedURIComponent' },\n  { variant: 'base64', compress: 'compressToBase64', decompress: 'decompressFromBase64' },\n];\n\nvar STORAGE_COMPRESSION_FLAG_KEY = '__cineStorageCompressed';\nvar STORAGE_COMPRESSION_VERSION = 1;\nvar STORAGE_COMPRESSION_ALGORITHM = 'lz-string';\nvar LEGACY_STORAGE_COMPRESSION_ALGORITHM = 'lz-string-utf16';\nvar STORAGE_COMPRESSION_VARIANTS = MIGRATION_BACKUP_COMPRESSION_VARIANTS;\nvar STORAGE_COMPRESSION_NAMESPACE = 'camera-power-planner:storage-compression';\nvar STORAGE_COMPRESSION_ALGORITHM_LITERAL =\n  typeof JSON !== 'undefined' && JSON && typeof JSON.stringify === 'function'\n    ? JSON.stringify(STORAGE_COMPRESSION_ALGORITHM)\n    : '\"'.concat(String(STORAGE_COMPRESSION_ALGORITHM || ''), '\"');\nvar STORAGE_COMPRESSION_NAMESPACE_LITERAL =\n  typeof JSON !== 'undefined' && JSON && typeof JSON.stringify === 'function'\n    ? JSON.stringify(STORAGE_COMPRESSION_NAMESPACE)\n    : '\"'.concat(String(STORAGE_COMPRESSION_NAMESPACE || ''), '\"');\nvar STORAGE_COMPRESSION_WRAPPER_BASE_LENGTH = computeStorageCompressionWrapperBaseLength();\nvar storageCompressionPatchedStorages = typeof WeakSet === 'function' ? new WeakSet() : null;\nvar STORAGE_COMPRESSION_SWEEP_LIMIT = 40;\nvar STORAGE_COMPRESSION_SWEEP_MIN_SAVINGS = 128;\nvar STORAGE_RAW_GET_ITEM_PROPERTY = '__cineRawGetItem';\nvar STORAGE_PROACTIVE_COMPRESSION_MIN_LENGTH = 1024;\nvar STORAGE_PROACTIVE_COMPRESSION_MIN_SAVINGS = 256;\nvar STORAGE_PROACTIVE_COMPRESSION_MIN_RATIO = 0.08;\n\nfunction getAvailableLZStringCompressionStrategies(variants) {\n  if (!Array.isArray(variants) || !variants.length) {\n    return [];\n  }\n\n  var lzReference = LZString;\n  if (!lzReference) {\n    return [];\n  }\n\n  var cacheKey = getCompressionStrategyCacheKey(variants);\n  var cachedStrategies = readCompressionStrategyCache(cacheKey, lzReference);\n  if (cachedStrategies !== null && cachedStrategies !== undefined) {\n    return cachedStrategies;\n  }\n\n  var available = [];\n  for (var i = 0; i < variants.length; i += 1) {\n    var variant = variants[i];\n    if (!variant) {\n      continue;\n    }\n\n    var compressFn = typeof lzReference[variant.compress] === 'function'\n      ? lzReference[variant.compress]\n      : null;\n    var decompressFn = typeof lzReference[variant.decompress] === 'function'\n      ? lzReference[variant.decompress]\n      : null;\n    var variantLiteral = null;\n    var variantLiteralLength = 0;\n    if (typeof JSON !== 'undefined' && JSON && typeof JSON.stringify === 'function') {\n      try {\n        variantLiteral = JSON.stringify(String(variant.variant || ''));\n        if (typeof variantLiteral === 'string' && variantLiteral) {\n          variantLiteralLength = variantLiteral.length;\n        } else {\n          variantLiteral = null;\n          variantLiteralLength = 0;\n        }\n      } catch (variantLiteralError) {\n        variantLiteral = null;\n        variantLiteralLength = 0;\n        void variantLiteralError;\n      }\n    }\n\n    if (compressFn && decompressFn) {\n      available.push({\n        variant: variant.variant,\n        compress: compressFn,\n        decompress: decompressFn,\n        variantLiteral: variantLiteralLength > 0 ? variantLiteral : null,\n        variantLiteralLength,\n      });\n    }\n  }\n\n  var result = available.length ? available.slice() : [];\n\n  if (cacheKey) {\n    writeCompressionStrategyCache(cacheKey, lzReference, result);\n  }\n\n  return result;\n}\n\nfunction tryDecompressWithStrategies(data, variants, preferredVariant, contextLabel) {\n  if (typeof data !== 'string' || !data) {\n    return { success: false };\n  }\n\n  var available = getAvailableLZStringCompressionStrategies(variants);\n  if (!available.length) {\n    return { success: false };\n  }\n\n  var attempts = [];\n  if (preferredVariant) {\n    var preferred = null;\n    for (var i = 0; i < available.length; i += 1) {\n      if (available[i].variant === preferredVariant) {\n        preferred = available[i];\n        break;\n      }\n    }\n    if (preferred) {\n      attempts.push(preferred);\n    } else if (typeof console !== 'undefined' && typeof console.warn === 'function') {\n      console.warn(\"Compression variant \"\n        .concat(preferredVariant, \" is unavailable while reading \"\n        ).concat(contextLabel || 'compressed payload', \".\"));\n    }\n  }\n\n  for (var j = 0; j < available.length; j += 1) {\n    if (!preferredVariant || available[j].variant !== preferredVariant) {\n      attempts.push(available[j]);\n    }\n  }\n\n  var lastError = null;\n  for (var k = 0; k < attempts.length; k += 1) {\n    var strategy = attempts[k];\n    try {\n      var decompressed = strategy.decompress(data);\n      if (typeof decompressed === 'string' && decompressed) {\n        return { success: true, value: decompressed, variant: strategy.variant };\n      }\n    } catch (error) {\n      lastError = error;\n      if (typeof console !== 'undefined' && typeof console.warn === 'function') {\n        console.warn(\"Unable to decompress \"\n          .concat(contextLabel || 'compressed payload', \" with \")\n          .concat(strategy.variant, \" variant\"), error);\n      }\n    }\n  }\n\n  return { success: false, error: lastError };\n}\n\nfunction canUseMigrationBackupCompression() {\n  return getAvailableLZStringCompressionStrategies(MIGRATION_BACKUP_COMPRESSION_VARIANTS).length > 0;\n}\n\nfunction tryCreateCompressedMigrationBackupCandidate(serializedPayload, createdAt) {\n  if (typeof serializedPayload !== 'string' || !serializedPayload) {\n    return null;\n  }\n  if (!canUseMigrationBackupCompression()) {\n    return null;\n  }\n\n  var cached = readCompressionCandidateCacheEntry(\n    MIGRATION_BACKUP_COMPRESSION_CANDIDATE_CACHE,\n    serializedPayload,\n  );\n  if (cached.hit) {\n    return cached.candidate;\n  }\n\n  var bestCandidate = null;\n  var strategies = getAvailableLZStringCompressionStrategies(MIGRATION_BACKUP_COMPRESSION_VARIANTS);\n\n  if (!strategies.length) {\n    return null;\n  }\n\n  for (var i = 0; i < strategies.length; i += 1) {\n    var strategy = strategies[i];\n    var compressed = null;\n    try {\n      compressed = strategy.compress(serializedPayload);\n    } catch (compressionError) {\n      console.warn(\"Unable to compress migration backup payload with \"\n        .concat(strategy.variant, \" variant\"), compressionError);\n      continue;\n    }\n\n    if (typeof compressed !== 'string' || !compressed || compressed.length >= serializedPayload.length) {\n      continue;\n    }\n\n    var record = {\n      createdAt: createdAt,\n      compression: MIGRATION_BACKUP_COMPRESSION_ALGORITHM,\n      compressionVariant: strategy.variant,\n      encoding: MIGRATION_BACKUP_COMPRESSION_ENCODING,\n      data: compressed,\n      originalSize: serializedPayload.length,\n      compressedSize: compressed.length,\n    };\n\n    var serializedCompressedPayload;\n    try {\n      serializedCompressedPayload = JSON.stringify(record);\n    } catch (serializationError) {\n      console.warn('Unable to serialize compressed migration backup payload', serializationError);\n      continue;\n    }\n\n    if (typeof serializedCompressedPayload !== 'string' || !serializedCompressedPayload) {\n      continue;\n    }\n\n    if (serializedCompressedPayload.length >= serializedPayload.length) {\n      continue;\n    }\n\n    if (!bestCandidate || serializedCompressedPayload.length < bestCandidate.serializedLength) {\n      bestCandidate = {\n        serialized: serializedCompressedPayload,\n        serializedLength: serializedCompressedPayload.length,\n        originalSize: serializedPayload.length,\n        compressedSize: compressed.length,\n        variant: strategy.variant,\n      };\n    }\n  }\n\n  writeCompressionCandidateCacheEntry(\n    MIGRATION_BACKUP_COMPRESSION_CANDIDATE_CACHE,\n    serializedPayload,\n    bestCandidate,\n  );\n\n  return bestCandidate;\n}\n\nfunction parseMigrationBackupMetadata(raw) {\n  if (typeof raw !== 'string' || !raw) {\n    return { createdAt: 0, size: typeof raw === 'string' ? raw.length : 0 };\n  }\n\n  const metadata = { createdAt: 0, size: raw.length };\n\n  try {\n    const parsed = JSON.parse(raw);\n    if (parsed && typeof parsed === 'object') {\n      let candidate = null;\n      if (typeof parsed.createdAt === 'string') {\n        candidate = parsed.createdAt.trim();\n      } else if (\n        typeof parsed.createdAt === 'number'\n        && Number.isFinite(parsed.createdAt)\n      ) {\n        metadata.createdAt = parsed.createdAt;\n      }\n\n      if (candidate) {\n        const timestamp = Date.parse(candidate);\n        if (!Number.isNaN(timestamp)) {\n          metadata.createdAt = timestamp;\n        }\n      } else {\n        for (let i = 0; i < MIGRATION_BACKUP_LEGACY_CREATED_AT_KEYS.length; i += 1) {\n          const key = MIGRATION_BACKUP_LEGACY_CREATED_AT_KEYS[i];\n          if (typeof parsed[key] === 'string') {\n            const trimmed = parsed[key].trim();\n            if (trimmed) {\n              const timestamp = Date.parse(trimmed);\n              if (!Number.isNaN(timestamp)) {\n                metadata.createdAt = timestamp;\n                break;\n              }\n            }\n          } else if (\n            typeof parsed[key] === 'number'\n            && Number.isFinite(parsed[key])\n          ) {\n            metadata.createdAt = parsed[key];\n            break;\n          }\n        }\n      }\n    }\n  } catch (error) {\n    void error;\n  }\n\n  return metadata;\n}\n\nfunction canUseJsonValueCompression() {\n  return canUseMigrationBackupCompression();\n}\n\nfunction createCompressedJsonStorageCandidate(serialized) {\n  if (typeof serialized !== 'string' || !serialized) {\n    return null;\n  }\n  if (!canUseJsonValueCompression()) {\n    return null;\n  }\n\n  var cached = readCompressionCandidateCacheEntry(STORAGE_COMPRESSION_CANDIDATE_CACHE, serialized);\n  if (cached.hit) {\n    return cached.candidate;\n  }\n\n  var strategies = getAvailableLZStringCompressionStrategies(STORAGE_COMPRESSION_VARIANTS);\n  if (!strategies.length) {\n    return null;\n  }\n\n  var baseWrapperLength =\n    typeof STORAGE_COMPRESSION_WRAPPER_BASE_LENGTH === 'number'\n      ? STORAGE_COMPRESSION_WRAPPER_BASE_LENGTH\n      : 0;\n  var best = null;\n  var bestSerialized = null;\n  var bestCompressedLiteral = null;\n  var bestVariantLiteral = null;\n  var originalLengthDigits = String(serialized.length).length;\n  for (var i = 0; i < strategies.length; i += 1) {\n    var strategy = strategies[i];\n    var compressed = null;\n    try {\n      compressed = strategy.compress(serialized);\n    } catch (compressionError) {\n      console.warn('Unable to compress storage payload with '\n        .concat(strategy.variant, ' variant'), compressionError);\n      continue;\n    }\n\n    if (typeof compressed !== 'string' || !compressed) {\n      continue;\n    }\n\n    var compressedLiteral;\n    try {\n      compressedLiteral = JSON.stringify(compressed);\n    } catch (compressedLiteralError) {\n      console.warn(\n        'Unable to serialize compressed storage payload candidate',\n        compressedLiteralError,\n      );\n      continue;\n    }\n\n    if (typeof compressedLiteral !== 'string' || !compressedLiteral) {\n      continue;\n    }\n\n    var variantLiteral =\n      typeof strategy.variantLiteral === 'string' && strategy.variantLiteral\n        ? strategy.variantLiteral\n        : null;\n    var variantLiteralLength =\n      typeof strategy.variantLiteralLength === 'number' && strategy.variantLiteralLength > 0\n        ? strategy.variantLiteralLength\n        : 0;\n    if (!variantLiteral) {\n      if (typeof JSON !== 'undefined' && JSON && typeof JSON.stringify === 'function') {\n        try {\n          variantLiteral = JSON.stringify(String(strategy.variant || ''));\n          variantLiteralLength =\n            typeof variantLiteral === 'string' && variantLiteral ? variantLiteral.length : 0;\n        } catch (variantLiteralError) {\n          variantLiteral = null;\n          variantLiteralLength = 0;\n          void variantLiteralError;\n        }\n      }\n    }\n\n    var candidateSerialized = null;\n    var candidateLength = Number.POSITIVE_INFINITY;\n\n    if (baseWrapperLength > 0 && variantLiteralLength > 0) {\n      var compressedLengthDigits = String(compressed.length).length;\n      candidateLength =\n        baseWrapperLength\n        + compressedLiteral.length\n        + originalLengthDigits\n        + compressedLengthDigits\n        + variantLiteralLength;\n    } else {\n      var legacyWrapper = {\n        [STORAGE_COMPRESSION_FLAG_KEY]: true,\n        version: STORAGE_COMPRESSION_VERSION,\n        algorithm: STORAGE_COMPRESSION_ALGORITHM,\n        namespace: STORAGE_COMPRESSION_NAMESPACE,\n        data: compressed,\n        originalLength: serialized.length,\n        compressedPayloadLength: compressed.length,\n        compressionVariant: strategy.variant,\n      };\n\n      try {\n        candidateSerialized = JSON.stringify(legacyWrapper);\n      } catch (serializationError) {\n        console.warn('Unable to serialize compressed storage payload wrapper', serializationError);\n        continue;\n      }\n\n      if (typeof candidateSerialized !== 'string' || !candidateSerialized) {\n        continue;\n      }\n\n      candidateLength = candidateSerialized.length;\n    }\n\n    if (!(candidateLength < serialized.length)) {\n      continue;\n    }\n\n    if (!best || candidateLength < best.wrappedLength) {\n      best = {\n        originalLength: serialized.length,\n        wrappedLength: candidateLength,\n        compressedPayloadLength: compressed.length,\n        compressionVariant: strategy.variant,\n      };\n      bestSerialized = candidateSerialized;\n      bestCompressedLiteral = compressedLiteral;\n      bestVariantLiteral = variantLiteral;\n    }\n  }\n\n  if (best && (!bestSerialized || typeof bestSerialized !== 'string')) {\n    if (typeof bestCompressedLiteral !== 'string' || !bestCompressedLiteral) {\n      best = null;\n    } else {\n      var finalVariantLiteral;\n      if (typeof bestVariantLiteral === 'string' && bestVariantLiteral) {\n        finalVariantLiteral = bestVariantLiteral;\n      } else if (typeof JSON !== 'undefined' && JSON && typeof JSON.stringify === 'function') {\n        try {\n          finalVariantLiteral = JSON.stringify(String(best.compressionVariant || ''));\n        } catch (variantLiteralError) {\n          finalVariantLiteral = null;\n          void variantLiteralError;\n        }\n      }\n\n      if (typeof finalVariantLiteral !== 'string' || !finalVariantLiteral) {\n        best = null;\n      } else {\n        var serializedWrapper =\n          '{\"'\n            .concat(STORAGE_COMPRESSION_FLAG_KEY, '\":true,\"version\":')\n            .concat(String(STORAGE_COMPRESSION_VERSION), ',\"algorithm\":')\n            .concat(STORAGE_COMPRESSION_ALGORITHM_LITERAL, ',\"namespace\":')\n            .concat(STORAGE_COMPRESSION_NAMESPACE_LITERAL, ',\"data\":')\n            .concat(bestCompressedLiteral, ',\"originalLength\":')\n            .concat(String(best.originalLength), ',\"compressedPayloadLength\":')\n            .concat(String(best.compressedPayloadLength), ',\"compressionVariant\":')\n            .concat(finalVariantLiteral, '}');\n\n        bestSerialized = serializedWrapper;\n      }\n    }\n  }\n\n  if (\n    best\n    && bestSerialized\n    && typeof bestSerialized === 'string'\n    && bestSerialized.length < best.originalLength\n  ) {\n    best.serialized = bestSerialized;\n    best.wrappedLength = bestSerialized.length;\n  } else {\n    best = null;\n  }\n\n  writeCompressionCandidateCacheEntry(STORAGE_COMPRESSION_CANDIDATE_CACHE, serialized, best);\n\n  return best;\n}\n\nfunction decodeCompressedJsonStorageValue(raw) {\n  if (typeof raw !== 'string') {\n    return { success: false };\n  }\n\n  if (!raw || raw.charCodeAt(0) !== 123) {\n    return { success: false };\n  }\n\n  if (\n    !raw.includes(`\"${STORAGE_COMPRESSION_FLAG_KEY}\":true`)\n    || !raw.includes(`\"namespace\":\"${STORAGE_COMPRESSION_NAMESPACE}`)\n  ) {\n    return { success: false };\n  }\n\n  let parsed;\n  try {\n    parsed = JSON.parse(raw);\n  } catch (parseError) {\n    return { success: false, error: parseError };\n  }\n\n  if (!parsed || parsed[STORAGE_COMPRESSION_FLAG_KEY] !== true) {\n    return { success: false };\n  }\n\n  if (parsed.namespace !== STORAGE_COMPRESSION_NAMESPACE) {\n    return { success: false };\n  }\n\n  if (parsed.version !== STORAGE_COMPRESSION_VERSION) {\n    console.warn('Unsupported storage compression version', parsed.version);\n    return { success: false };\n  }\n\n  if (\n    parsed.algorithm !== STORAGE_COMPRESSION_ALGORITHM\n    && parsed.algorithm !== LEGACY_STORAGE_COMPRESSION_ALGORITHM\n  ) {\n    console.warn('Unsupported storage compression algorithm', parsed.algorithm);\n    return { success: false };\n  }\n\n  if (typeof parsed.data !== 'string' || !parsed.data) {\n    return { success: false };\n  }\n\n  if (!canUseJsonValueCompression()) {\n    console.warn('Compressed storage payload detected but compression library is unavailable.');\n    return { success: false };\n  }\n\n  var preferredVariant = null;\n  if (typeof parsed.compressionVariant === 'string' && parsed.compressionVariant) {\n    preferredVariant = parsed.compressionVariant;\n  } else if (parsed.algorithm === LEGACY_STORAGE_COMPRESSION_ALGORITHM) {\n    preferredVariant = 'utf16';\n  }\n\n  var decoded = tryDecompressWithStrategies(parsed.data, STORAGE_COMPRESSION_VARIANTS, preferredVariant, 'storage payload');\n  if (!decoded.success) {\n    return { success: false, error: decoded.error };\n  }\n\n  if (!parsed.compressionVariant && decoded.variant) {\n    parsed.compressionVariant = decoded.variant;\n  }\n\n  return { success: true, value: decoded.value, metadata: parsed };\n}\n\nfunction restoreCompressedProjectEntry(value, contextName) {\n  if (typeof value === 'string') {\n    const decoded = decodeCompressedJsonStorageValue(value);\n    if (!decoded.success || typeof decoded.value !== 'string') {\n      return { restored: false, value };\n    }\n\n    try {\n      return { restored: true, value: JSON.parse(decoded.value) };\n    } catch (parseError) {\n      console.warn(\n        'Unable to parse decompressed project entry payload',\n        contextName || 'project entry',\n        parseError,\n      );\n      return { restored: false, value };\n    }\n  }\n\n  if (isPlainObject(value) && value[STORAGE_COMPRESSION_FLAG_KEY] === true) {\n    let serialized;\n    try {\n      serialized = JSON.stringify(value);\n    } catch (serializationError) {\n      console.warn(\n        'Unable to reserialize compressed project entry wrapper before restoration',\n        contextName || 'project entry',\n        serializationError,\n      );\n      return { restored: false, value };\n    }\n\n    if (typeof serialized === 'string' && serialized) {\n      return restoreCompressedProjectEntry(serialized, contextName);\n    }\n  }\n\n  return { restored: false, value };\n}\n\nfunction markProjectActivity(name, timestamp) {\n  if (typeof name !== 'string') {\n    return;\n  }\n\n  const recordTime = typeof timestamp === 'number' && Number.isFinite(timestamp)\n    ? timestamp\n    : Date.now();\n\n  const normalized = normalizeProjectStorageKey(name);\n  if (normalized) {\n    projectActivityTimestamps.set(normalized, recordTime);\n    if (normalized !== name) {\n      projectActivityTimestamps.set(name, recordTime);\n    }\n    return;\n  }\n\n  projectActivityTimestamps.set(name, recordTime);\n}\n\nfunction markProjectCollectionActivity(projects, timestamp) {\n  if (!projects || typeof projects !== 'object') {\n    return;\n  }\n\n  const recordTime = typeof timestamp === 'number' && Number.isFinite(timestamp)\n    ? timestamp\n    : Date.now();\n\n  Object.keys(projects).forEach((key) => {\n    if (typeof key !== 'string' || !key || isAutoBackupStorageKey(key)) {\n      return;\n    }\n\n    markProjectActivity(key, recordTime);\n  });\n}\n\nfunction removeProjectActivity(name) {\n  if (typeof name !== 'string') {\n    return;\n  }\n\n  const normalized = normalizeProjectStorageKey(name);\n  projectActivityTimestamps.delete(name);\n  if (normalized && normalized !== name) {\n    projectActivityTimestamps.delete(normalized);\n  }\n}\n\n\n\n\n\nfunction normalizeForcedProjectCompressionKey(name) {\n  if (typeof name !== 'string') {\n    return '';\n  }\n\n  const normalized = normalizeProjectStorageKey(name);\n  return typeof normalized === 'string' && normalized ? normalized : '';\n}\n\nfunction isForcedProjectCompressionLocked(name) {\n  if (!forcedCompressedProjectKeys || typeof forcedCompressedProjectKeys.has !== 'function') {\n    return false;\n  }\n\n  const normalized = normalizeForcedProjectCompressionKey(name);\n  if (!normalized) {\n    return false;\n  }\n\n  try {\n    return forcedCompressedProjectKeys.has(normalized);\n  } catch (error) {\n    void error;\n  }\n\n  return false;\n}\n\n\n\n\n\nfunction ensureProjectEntryUncompressed(value, contextName) {\n  const restored = restoreCompressedProjectEntry(value, contextName);\n  if (restored.restored) {\n    return restored.value;\n  }\n  return value;\n}\n\nfunction ensureProjectEntriesUncompressed(container) {\n  if (!isPlainObject(container)) {\n    return container;\n  }\n\n  Object.keys(container).forEach((key) => {\n    container[key] = ensureProjectEntryUncompressed(container[key], key);\n  });\n\n  return container;\n}\n\n\n\n\n\nfunction registerActiveSetupStorageSkipKeys(skipSet) {\n  if (!skipSet || typeof skipSet.add !== 'function') {\n    return;\n  }\n\n  const keysToSkip = [\n    PROJECT_STORAGE_KEY,\n    `${PROJECT_STORAGE_KEY}${STORAGE_BACKUP_SUFFIX}`,\n    SETUP_STORAGE_KEY,\n    `${SETUP_STORAGE_KEY}${STORAGE_BACKUP_SUFFIX}`,\n  ];\n\n  for (let i = 0; i < keysToSkip.length; i += 1) {\n    const key = keysToSkip[i];\n    if (typeof key === 'string' && key) {\n      skipSet.add(key);\n    }\n  }\n}\n\nfunction registerProtectedCompressionSkipKeys(skipSet) {\n  if (!skipSet || typeof skipSet.add !== 'function') {\n    return;\n  }\n\n  const keysToProtect = [\n    CONTACTS_STORAGE_KEY,\n    OWN_GEAR_STORAGE_KEY,\n    USER_PROFILE_STORAGE_KEY,\n    DEVICE_STORAGE_KEY,\n  ];\n\n  for (let index = 0; index < keysToProtect.length; index += 1) {\n    const key = keysToProtect[index];\n    if (typeof key !== 'string' || !key) {\n      continue;\n    }\n\n    const variants = getStorageKeyVariants(key);\n    for (let variantIndex = 0; variantIndex < variants.length; variantIndex += 1) {\n      const variant = variants[variantIndex];\n      if (typeof variant !== 'string' || !variant) {\n        continue;\n      }\n\n      skipSet.add(variant);\n\n      if (typeof STORAGE_BACKUP_SUFFIX === 'string' && STORAGE_BACKUP_SUFFIX) {\n        skipSet.add(`${variant}${STORAGE_BACKUP_SUFFIX}`);\n      }\n    }\n  }\n}\n\nfunction maybeDecompressStoredString(raw, options) {\n  if (typeof raw !== 'string') {\n    return raw;\n  }\n\n  const decoded = decodeCompressedJsonStorageValue(raw);\n  if (!decoded.success) {\n    return raw;\n  }\n\n  if (options && typeof options.onDecoded === 'function') {\n    try {\n      options.onDecoded(decoded);\n    } catch (callbackError) {\n      console.warn('Error while processing storage decompression callback', callbackError);\n    }\n  }\n\n  return decoded.value;\n}\n\nfunction attemptStorageCompressionSweep(storage, options) {\n  if (\n    !storage\n    || typeof storage.length !== 'number'\n    || typeof storage.key !== 'function'\n  ) {\n    return { success: false, compressed: 0, freed: 0 };\n  }\n\n  if (isSessionStorageInstance(storage)) {\n    // Session storage entries are intentionally left uncompressed to prioritize\n    // short-lived data integrity over quota recoveries. Compressing them risks\n    // losing user context during transient errors, so skip sweeps entirely.\n    return { success: false, compressed: 0, freed: 0 };\n  }\n\n  const { skipKeys = [], limit = STORAGE_COMPRESSION_SWEEP_LIMIT, minSavings = STORAGE_COMPRESSION_SWEEP_MIN_SAVINGS } = options || {};\n\n  const skipSet = new Set();\n  if (ACTIVE_PROJECT_COMPRESSION_HOLD_ENABLED && ACTIVE_PROJECT_COMPRESSION_HOLD_KEY) {\n    skipSet.add(ACTIVE_PROJECT_COMPRESSION_HOLD_KEY);\n  }\n  if (ACTIVE_PROJECT_COMPRESSION_HOLD_ENABLED) {\n    registerActiveSetupStorageSkipKeys(skipSet);\n  }\n  registerProtectedCompressionSkipKeys(skipSet);\n  if (Array.isArray(skipKeys)) {\n    for (let i = 0; i < skipKeys.length; i += 1) {\n      const key = skipKeys[i];\n      if (typeof key === 'string' && key) {\n        skipSet.add(key);\n      }\n    }\n  }\n\n  const minSavingsThreshold = typeof minSavings === 'number' && minSavings > 0 ? minSavings : 0;\n  const total = storage.length;\n  const candidates = [];\n\n  for (let index = 0; index < total; index += 1) {\n    let key;\n    try {\n      key = storage.key(index);\n    } catch (keyError) {\n      void keyError;\n      key = null;\n    }\n\n    if (typeof key !== 'string' || !key || skipSet.has(key)) {\n      continue;\n    }\n\n    let raw;\n    try {\n      raw = storage.getItem(key);\n    } catch (readError) {\n      void readError;\n      continue;\n    }\n\n    if (typeof raw !== 'string' || !raw) {\n      continue;\n    }\n\n    if (raw.includes(`\"${STORAGE_COMPRESSION_FLAG_KEY}\":true`)) {\n      continue;\n    }\n\n    const candidate = createCompressedJsonStorageCandidate(raw);\n    if (!candidate || typeof candidate.serialized !== 'string' || !candidate.serialized) {\n      continue;\n    }\n\n    const savings = typeof candidate.originalLength === 'number' && typeof candidate.wrappedLength === 'number'\n      ? candidate.originalLength - candidate.wrappedLength\n      : 0;\n    if (savings < minSavingsThreshold) {\n      continue;\n    }\n\n    candidates.push({\n      key,\n      serialized: candidate.serialized,\n      savings: savings > 0 ? savings : 0,\n      originalLength: typeof candidate.originalLength === 'number' ? candidate.originalLength : 0,\n    });\n  }\n\n  if (!candidates.length) {\n    return { success: false, compressed: 0, freed: 0 };\n  }\n\n  candidates.sort((a, b) => {\n    if (b.savings !== a.savings) {\n      return b.savings - a.savings;\n    }\n    return b.originalLength - a.originalLength;\n  });\n\n  const upperLimit = typeof limit === 'number' && limit > 0 ? Math.min(limit, candidates.length) : candidates.length;\n\n  let compressedCount = 0;\n  let freedCharacters = 0;\n\n  for (let index = 0; index < candidates.length && compressedCount < upperLimit; index += 1) {\n    const entry = candidates[index];\n    if (!entry || typeof entry.serialized !== 'string' || !entry.serialized) {\n      continue;\n    }\n\n    try {\n      storage.setItem(entry.key, entry.serialized);\n      compressedCount += 1;\n      freedCharacters += entry.savings;\n    } catch (writeError) {\n      void writeError;\n    }\n  }\n\n  if (compressedCount === 0) {\n    return { success: false, compressed: 0, freed: 0 };\n  }\n\n  if (typeof console !== 'undefined' && typeof console.warn === 'function') {\n    if (freedCharacters > 0) {\n      console.warn(\n        `Compressed ${compressedCount} stored entr${compressedCount === 1 ? 'y' : 'ies'} during quota recovery, freeing approximately ${freedCharacters} characters.`,\n      );\n    } else {\n      console.warn(`Compressed ${compressedCount} stored entr${compressedCount === 1 ? 'y' : 'ies'} during quota recovery.`);\n    }\n  }\n\n  return { success: true, compressed: compressedCount, freed: freedCharacters };\n}\n\nfunction decodeStoredValue(raw) {\n  if (raw === null || raw === undefined) {\n    return raw;\n  }\n  return maybeDecompressStoredString(raw);\n}\n\nfunction patchIndividualStorageGetItem(storage) {\n  if (!storage || typeof storage.getItem !== 'function') {\n    return;\n  }\n\n  if (\n    storageCompressionPatchedStorages\n    && typeof storageCompressionPatchedStorages.has === 'function'\n    && storageCompressionPatchedStorages.has(storage)\n  ) {\n    return;\n  }\n\n  const originalGetItem = storage.getItem;\n  const rawGetItem = typeof originalGetItem === 'function'\n    ? function rawStorageGetItem(key) {\n      return originalGetItem.call(this, key);\n    }\n    : null;\n  const patchedGetItem = function patchedStorageGetItem(key) {\n    const rawValue = rawGetItem ? rawGetItem.call(this, key) : undefined;\n    return maybeDecompressStoredString(rawValue);\n  };\n\n  try {\n    Object.defineProperty(storage, 'getItem', {\n      configurable: true,\n      writable: true,\n      value: patchedGetItem,\n    });\n  } catch (defineError) {\n    const suppressDefineWarning =\n      defineError\n      && typeof defineError.message === 'string'\n      && defineError.message.includes('Cannot redefine property');\n    if (!suppressDefineWarning) {\n      console.warn('Unable to redefine storage.getItem descriptor for compression support', defineError);\n    }\n    try {\n      storage.getItem = patchedGetItem;\n    } catch (assignError) {\n      const suppressAssignWarning =\n        assignError\n        && typeof assignError.message === 'string'\n        && assignError.message.includes('Cannot assign to read only property');\n      if (!suppressAssignWarning) {\n        console.warn('Unable to patch storage instance getItem for compression support', assignError);\n      }\n      if (suppressDefineWarning && suppressAssignWarning) {\n        return;\n      }\n      if (!suppressDefineWarning && !suppressAssignWarning) {\n        return;\n      }\n      return;\n    }\n  }\n\n  if (rawGetItem) {\n    try {\n      Object.defineProperty(storage, STORAGE_RAW_GET_ITEM_PROPERTY, {\n        configurable: true,\n        writable: true,\n        value: rawGetItem,\n      });\n    } catch (rawAssignError) {\n      try {\n        storage[STORAGE_RAW_GET_ITEM_PROPERTY] = rawGetItem;\n      } catch (rawStoreError) {\n        void rawStoreError;\n      }\n      void rawAssignError;\n    }\n  }\n\n  if (\n    storageCompressionPatchedStorages\n    && typeof storageCompressionPatchedStorages.add === 'function'\n  ) {\n    try {\n      storageCompressionPatchedStorages.add(storage);\n    } catch (trackError) {\n      void trackError;\n    }\n  }\n}\n\nfunction patchStorageGetItemForCompression() {\n  if (typeof Storage === 'undefined') {\n    const candidates = [];\n    if (GLOBAL_SCOPE && typeof GLOBAL_SCOPE === 'object') {\n      if (GLOBAL_SCOPE.localStorage) {\n        candidates.push(GLOBAL_SCOPE.localStorage);\n      }\n      if (GLOBAL_SCOPE.sessionStorage) {\n        candidates.push(GLOBAL_SCOPE.sessionStorage);\n      }\n    }\n    if (typeof global !== 'undefined' && global && global !== GLOBAL_SCOPE) {\n      if (global.localStorage) {\n        candidates.push(global.localStorage);\n      }\n      if (global.sessionStorage) {\n        candidates.push(global.sessionStorage);\n      }\n    }\n    candidates.forEach(patchIndividualStorageGetItem);\n    return;\n  }\n\n  const prototype = Storage.prototype;\n  if (!prototype || typeof prototype.getItem !== 'function') {\n    return;\n  }\n\n  if (prototype.__cineStorageCompressionPatched) {\n    return;\n  }\n\n  const originalGetItem = prototype.getItem;\n  const rawGetItem = function rawStorageGetItem(key) {\n    return originalGetItem.call(this, key);\n  };\n  const patchedGetItem = function patchedStorageGetItem(key) {\n    const rawValue = rawGetItem.call(this, key);\n    return maybeDecompressStoredString(rawValue);\n  };\n\n  try {\n    Object.defineProperty(prototype, 'getItem', {\n      configurable: true,\n      writable: true,\n      value: patchedGetItem,\n    });\n  } catch (patchError) {\n    console.warn('Unable to patch Storage.getItem for compression support', patchError);\n    return;\n  }\n\n  try {\n    Object.defineProperty(prototype, STORAGE_RAW_GET_ITEM_PROPERTY, {\n      configurable: true,\n      writable: false,\n      value: rawGetItem,\n    });\n  } catch (rawError) {\n    try {\n      prototype[STORAGE_RAW_GET_ITEM_PROPERTY] = rawGetItem;\n    } catch (assignError) {\n      void assignError;\n    }\n    void rawError;\n  }\n\n  try {\n    Object.defineProperty(prototype, '__cineStorageCompressionPatched', {\n      configurable: true,\n      writable: false,\n      value: true,\n    });\n  } catch (flagError) {\n    prototype.__cineStorageCompressionPatched = true;\n    void flagError;\n  }\n\n  const candidates = [];\n  if (GLOBAL_SCOPE && typeof GLOBAL_SCOPE === 'object') {\n    if (GLOBAL_SCOPE.localStorage) {\n      candidates.push(GLOBAL_SCOPE.localStorage);\n    }\n    if (GLOBAL_SCOPE.sessionStorage) {\n      candidates.push(GLOBAL_SCOPE.sessionStorage);\n    }\n  }\n  if (typeof global !== 'undefined' && global && global !== GLOBAL_SCOPE) {\n    if (global.localStorage) {\n      candidates.push(global.localStorage);\n    }\n    if (global.sessionStorage) {\n      candidates.push(global.sessionStorage);\n    }\n  }\n  candidates.forEach(patchIndividualStorageGetItem);\n}\n\nfunction getRawStorageGetter(storage) {\n  if (!storage || typeof storage !== 'object') {\n    return null;\n  }\n\n  const direct = storage[STORAGE_RAW_GET_ITEM_PROPERTY];\n  if (typeof direct === 'function') {\n    return direct;\n  }\n\n  const prototype = Object.getPrototypeOf(storage);\n  if (prototype && typeof prototype[STORAGE_RAW_GET_ITEM_PROPERTY] === 'function') {\n    return prototype[STORAGE_RAW_GET_ITEM_PROPERTY];\n  }\n\n  return null;\n}\n\nfunction readRawStorageValue(storage, key, rawGetterOverride) {\n  if (!storage || typeof key !== 'string' || !key) {\n    return null;\n  }\n\n  const getter = typeof rawGetterOverride === 'function'\n    ? rawGetterOverride\n    : getRawStorageGetter(storage);\n  if (typeof getter !== 'function') {\n    return null;\n  }\n\n  try {\n    return getter.call(storage, key);\n  } catch (error) {\n    void error;\n    return null;\n  }\n}\n\nfunction collectMigrationBackupEntriesForCleanup(storage, excludeKey) {\n  if (!storage) {\n    return [];\n  }\n\n  let snapshot;\n  try {\n    snapshot = snapshotStorageEntries(storage, { suppressAlerts: true });\n  } catch (error) {\n    console.warn('Unable to inspect storage while preparing migration backup cleanup', error);\n    return [];\n  }\n\n  if (!snapshot || typeof snapshot !== 'object') {\n    return [];\n  }\n\n  return Object.keys(snapshot)\n    .filter((candidate) => {\n      if (typeof candidate !== 'string' || !candidate) {\n        return false;\n      }\n      if (!candidate.endsWith(STORAGE_MIGRATION_BACKUP_SUFFIX)) {\n        return false;\n      }\n      if (excludeKey && candidate === excludeKey) {\n        return false;\n      }\n      return true;\n    })\n    .map((candidate) => {\n      const raw = snapshot[candidate];\n      const normalized = typeof raw === 'string' ? raw : raw === null || raw === undefined ? '' : String(raw);\n      const metadata = parseMigrationBackupMetadata(normalized);\n      return {\n        key: candidate,\n        createdAt: metadata.createdAt,\n        size: metadata.size,\n      };\n    })\n    .sort((a, b) => {\n      if (a.createdAt && b.createdAt && a.createdAt !== b.createdAt) {\n        return a.createdAt - b.createdAt;\n      }\n      if (a.createdAt && !b.createdAt) {\n        return -1;\n      }\n      if (!a.createdAt && b.createdAt) {\n        return 1;\n      }\n      if (a.size !== b.size) {\n        return b.size - a.size;\n      }\n      return a.key.localeCompare(b.key);\n    });\n}\n\nfunction pruneMigrationBackupEntriesForCleanup(storage, excludeKey) {\n  const entries = collectMigrationBackupEntriesForCleanup(storage, excludeKey);\n  if (!entries.length) {\n    return [];\n  }\n\n  const removedKeys = [];\n  const target = entries[0];\n  try {\n    storage.removeItem(target.key);\n    removedKeys.push(target.key);\n  } catch (error) {\n    console.warn(`Unable to remove migration backup ${target.key} during cleanup`, error);\n  }\n\n  return removedKeys;\n}\n\nfunction attemptMigrationBackupQuotaRecovery(storage, key, backupKey, tryWrite) {\n  if (!storage || typeof storage.setItem !== 'function') {\n    return { success: false, error: null };\n  }\n\n  const removedBackups = [];\n  let lastError = null;\n\n  if (typeof tryWrite !== 'function') {\n    return { success: false, error: null };\n  }\n\n  const attemptWrite = () => {\n    const result = tryWrite();\n    if (result && typeof result === 'object' && 'error' in result && result.error) {\n      lastError = result.error;\n    }\n    if (result && result.success) {\n      return { success: true, quota: false };\n    }\n    if (result && result.quota) {\n      return { success: false, quota: true, error: result.error || null };\n    }\n    return { success: false, quota: false, error: result && result.error ? result.error : null };\n  };\n\n  if (typeof clearUiCacheStorageEntries === 'function') {\n    let cleared = false;\n    try {\n      clearUiCacheStorageEntries();\n      cleared = true;\n    } catch (clearError) {\n      console.warn('Unable to clear cached UI storage entries before creating migration backup', clearError);\n    }\n\n    if (cleared) {\n      const retryAfterClear = attemptWrite();\n      if (retryAfterClear.success) {\n        console.warn(`Cleared cached planner data to free storage before creating migration backup for ${key}.`);\n        return { success: true, error: null };\n      }\n      if (!retryAfterClear.quota) {\n        return { success: false, error: retryAfterClear.error };\n      }\n    }\n  }\n\n  for (let attempt = 0; attempt < MAX_MIGRATION_BACKUP_CLEANUP_STEPS; attempt += 1) {\n    const removed = pruneMigrationBackupEntriesForCleanup(storage, backupKey);\n    if (!removed.length) {\n      break;\n    }\n    removedBackups.push(...removed);\n    const retry = attemptWrite();\n    if (retry.success) {\n      console.warn(\n        `Removed ${removedBackups.length} older migration backup${removedBackups.length > 1 ? 's' : ''} to free up storage before creating migration backup for ${key}.`,\n        removedBackups,\n      );\n      return { success: true, error: null };\n    }\n    if (!retry.quota) {\n      return { success: false, error: retry.error };\n    }\n  }\n\n  if (removedBackups.length > 0) {\n    console.warn(\n      `Removed ${removedBackups.length} older migration backup${removedBackups.length > 1 ? 's' : ''} while attempting to create migration backup for ${key}, but storage quota is still exceeded.`,\n      removedBackups,\n    );\n  }\n\n  return { success: false, error: lastError };\n}\n\nfunction ensurePreWriteMigrationBackup(storage, key) {\n  if (!storage || typeof storage.getItem !== 'function' || !key) {\n    return null;\n  }\n\n  let rawValue = null;\n  try {\n    rawValue = storage.getItem(key);\n  } catch (inspectionError) {\n    console.warn(`Unable to inspect existing value for ${key} before creating migration backup`, inspectionError);\n    return null;\n  }\n\n  if (rawValue === null || rawValue === undefined) {\n    return null;\n  }\n\n  let parsedValue = rawValue;\n  let normalizedRawValue = rawValue;\n  if (typeof rawValue === 'string' && rawValue) {\n    normalizedRawValue = maybeDecompressStoredString(rawValue);\n    if (typeof normalizedRawValue === 'string' && normalizedRawValue) {\n      try {\n        parsedValue = JSON.parse(normalizedRawValue);\n      } catch (parseError) {\n        void parseError;\n      }\n    } else {\n      parsedValue = normalizedRawValue;\n    }\n  }\n\n  if (\n    parsedValue &&\n    typeof parsedValue === 'object' &&\n    ((Array.isArray(parsedValue) && parsedValue.length === 0) ||\n      (!Array.isArray(parsedValue) && Object.keys(parsedValue).length === 0))\n  ) {\n    return parsedValue;\n  }\n\n  createStorageMigrationBackup(storage, key, parsedValue);\n  return parsedValue;\n}\n\nvar MIGRATION_BACKUP_LEGACY_DATA_KEYS = [\n  'payload',\n  'value',\n  'content',\n  'entries',\n  'snapshot',\n  'state',\n  'record',\n];\n\nvar MIGRATION_BACKUP_LEGACY_CREATED_AT_KEYS = ['iso', 'timestamp', 'time'];\n\nfunction trySerializeMigrationBackupValue(value) {\n  try {\n    return JSON.stringify(value);\n  } catch (serializationError) {\n    console.warn('Unable to serialize normalized migration backup payload', serializationError);\n    return null;\n  }\n}\n\nfunction normalizeLegacyMigrationBackupCreatedAt(value, fallbackIso) {\n  const fallback = typeof fallbackIso === 'string' && fallbackIso\n    ? fallbackIso\n    : null;\n\n  if (typeof value === 'string') {\n    const trimmed = value.trim();\n    if (!trimmed) {\n      return { value: fallback || new Date().toISOString(), changed: true };\n    }\n    const numeric = Number(trimmed);\n    if (!Number.isNaN(numeric) && Number.isFinite(numeric) && String(numeric) === trimmed) {\n      try {\n        return { value: new Date(numeric).toISOString(), changed: true };\n      } catch (error) {\n        void error;\n        return { value: fallback || new Date().toISOString(), changed: true };\n      }\n    }\n    const timestamp = Date.parse(trimmed);\n    if (!Number.isNaN(timestamp)) {\n      try {\n        const iso = new Date(timestamp).toISOString();\n        return { value: iso, changed: iso !== trimmed };\n      } catch (error) {\n        void error;\n        return { value: fallback || new Date().toISOString(), changed: true };\n      }\n    }\n    return { value: trimmed, changed: trimmed !== value };\n  }\n\n  if (typeof value === 'number' && Number.isFinite(value)) {\n    try {\n      return { value: new Date(value).toISOString(), changed: true };\n    } catch (error) {\n      void error;\n      return { value: fallback || new Date().toISOString(), changed: true };\n    }\n  }\n\n  if (value instanceof Date) {\n    const time = value.getTime();\n    if (Number.isFinite(time)) {\n      try {\n        return { value: value.toISOString(), changed: true };\n      } catch (error) {\n        void error;\n        return { value: fallback || new Date().toISOString(), changed: true };\n      }\n    }\n  }\n\n  if (fallback) {\n    return { value: fallback, changed: true };\n  }\n\n  const generated = new Date().toISOString();\n  return { value: generated, changed: true };\n}\n\nfunction normalizeLegacyMigrationBackupValue(rawValue, fallbackIso) {\n  if (typeof rawValue !== 'string' || !rawValue) {\n    return null;\n  }\n\n  const fallback = typeof fallbackIso === 'string' && fallbackIso\n    ? fallbackIso\n    : new Date().toISOString();\n\n  let parsed;\n  try {\n    parsed = JSON.parse(rawValue);\n  } catch (parseError) {\n    void parseError;\n    return trySerializeMigrationBackupValue({ createdAt: fallback, data: rawValue });\n  }\n\n  // If parsed is null/undefined or not object, wrap it\n  if (!parsed || typeof parsed !== 'object') {\n    const dataValue = parsed === undefined ? rawValue : parsed;\n    return trySerializeMigrationBackupValue({ createdAt: fallback, data: dataValue });\n  }\n\n  // If it's an array of backup entries, check if it is already in modern format\n  // If it's an array of backup entries, it's a valid modern format for history.\n  if (Array.isArray(parsed)) {\n    let listChanged = false;\n    const normalizedList = parsed.map((item) => {\n      if (!item || typeof item !== 'object') {\n        listChanged = true;\n        return { createdAt: fallback, data: item };\n      }\n\n      const hasData = Object.prototype.hasOwnProperty.call(item, 'data');\n      const itemCreatedAt = item.createdAt;\n      const { value: normalizedDate, changed: dateChanged } = normalizeLegacyMigrationBackupCreatedAt(\n        itemCreatedAt, fallback\n      );\n\n      if (!hasData) {\n        listChanged = true;\n        // Treat the whole item as data if it's not a valid envelope\n        return { createdAt: normalizedDate, data: item };\n      }\n\n      if (dateChanged || itemCreatedAt !== normalizedDate) {\n        listChanged = true;\n        return { ...item, createdAt: normalizedDate };\n      }\n\n      return item;\n    });\n\n    if (!listChanged) {\n      return null;\n    }\n    return trySerializeMigrationBackupValue(normalizedList);\n  }\n\n  let normalized;\n  let changed = false;\n\n  if (Object.prototype.hasOwnProperty.call(parsed, 'data')) {\n    normalized = { ...parsed };\n  } else {\n    let usedKey = null;\n    for (let i = 0; i < MIGRATION_BACKUP_LEGACY_DATA_KEYS.length; i += 1) {\n      const key = MIGRATION_BACKUP_LEGACY_DATA_KEYS[i];\n      if (Object.prototype.hasOwnProperty.call(parsed, key)) {\n        usedKey = key;\n        break;\n      }\n    }\n\n    if (usedKey) {\n      normalized = { ...parsed };\n      normalized.data = parsed[usedKey];\n      delete normalized[usedKey];\n      changed = true;\n    } else {\n      normalized = { data: parsed };\n      changed = true;\n    }\n  }\n\n  let rawCreatedAt = normalized.createdAt;\n  let createdAtSourceKey = 'createdAt';\n  if (rawCreatedAt === undefined) {\n    for (let i = 0; i < MIGRATION_BACKUP_LEGACY_CREATED_AT_KEYS.length; i += 1) {\n      const key = MIGRATION_BACKUP_LEGACY_CREATED_AT_KEYS[i];\n      if (Object.prototype.hasOwnProperty.call(parsed, key)) {\n        rawCreatedAt = parsed[key];\n        createdAtSourceKey = key;\n        break;\n      }\n    }\n  }\n\n  const { value: createdAt, changed: createdAtChanged } = normalizeLegacyMigrationBackupCreatedAt(\n    rawCreatedAt,\n    fallback,\n  );\n\n  normalized.createdAt = createdAt;\n  if (createdAtSourceKey !== 'createdAt' && createdAtSourceKey && Object.prototype.hasOwnProperty.call(normalized, createdAtSourceKey)) {\n    delete normalized[createdAtSourceKey];\n    changed = true;\n  }\n\n  if (createdAtChanged) {\n    changed = true;\n  }\n\n  if (!changed) {\n    return null;\n  }\n\n  return trySerializeMigrationBackupValue(normalized);\n}\n\nfunction upgradeLegacyMigrationBackupEntry(storage, backupKey, rawValue, fallbackIso) {\n  const normalized = normalizeLegacyMigrationBackupValue(rawValue, fallbackIso);\n  if (normalized === null) {\n    return true;\n  }\n  if (typeof normalized !== 'string' || !normalized) {\n    return false;\n  }\n  if (normalized === rawValue) {\n    return true;\n  }\n  try {\n    storage.setItem(backupKey, normalized);\n    return true;\n  } catch (error) {\n    console.warn(`Unable to normalize legacy migration backup for ${backupKey}`, error);\n    return false;\n  }\n}\n\nfunction createStorageMigrationBackup(storage, key, originalValue) {\n  if (!storage || typeof storage.setItem !== 'function') {\n    return;\n  }\n  if (originalValue === null || originalValue === undefined) {\n    return;\n  }\n\n  const backupKey = `${key}${STORAGE_MIGRATION_BACKUP_SUFFIX}`;\n  let hasExistingBackup = false;\n\n  if (typeof storage.getItem === 'function') {\n    try {\n      const existing = storage.getItem(backupKey);\n      if (existing !== null && existing !== undefined) {\n        hasExistingBackup = true;\n        const fallbackCreatedAt = new Date().toISOString();\n        upgradeLegacyMigrationBackupEntry(storage, backupKey, existing, fallbackCreatedAt);\n      }\n    } catch (inspectionError) {\n      console.warn(`Unable to inspect migration backup for ${key}`, inspectionError);\n    }\n  }\n\n  if (hasExistingBackup) {\n    // If we already have a backup, we append to a list to keep history.\n    try {\n      const existingRaw = storage.getItem(backupKey);\n      const decoded = decodeStoredValue(existingRaw);\n      let existingData = null;\n      try {\n        existingData = JSON.parse(decoded);\n      } catch (jsonError) {\n        void jsonError;\n        existingData = decoded;\n      }\n\n      let list = Array.isArray(existingData) ? existingData : [existingData];\n      const newEntry = { createdAt: new Date().toISOString(), data: originalValue };\n      list.push(newEntry);\n\n      // Limit history size to prevent indefinite growth\n      const MAX_BACKUP_HISTORY = 5;\n      if (list.length > MAX_BACKUP_HISTORY) {\n        list = list.slice(list.length - MAX_BACKUP_HISTORY);\n      }\n\n      const tryStoreList = (candidateList) => {\n        try {\n          storage.setItem(backupKey, JSON.stringify(candidateList));\n          return { success: true };\n        } catch (itemError) {\n          return { success: false, quota: isQuotaExceededError(itemError), error: itemError };\n        }\n      };\n\n      let result = tryStoreList(list);\n\n      // If quota exceeded, try to shrink the list further\n      while (!result.success && result.quota && list.length > 1) {\n        list.shift(); // Remove oldest\n        console.warn(`Pruning oldest migration backup for ${key} due to quota limit.`);\n        result = tryStoreList(list);\n      }\n\n      if (result.success) {\n        return;\n      }\n\n      // If still failing, try to prune OTHER backups\n      if (!result.success && result.quota) {\n        const recovery = attemptMigrationBackupQuotaRecovery(storage, key, backupKey, () => tryStoreList(list));\n        if (recovery && recovery.success) {\n          return;\n        }\n      }\n\n      console.warn('Unable to append to migration backup', result.error);\n      return;\n    } catch (appendError) {\n      console.warn('Unable to append to migration backup', appendError);\n      return;\n    }\n  }\n\n  let serialized;\n  const createdAt = new Date().toISOString();\n  try {\n    serialized = JSON.stringify({\n      createdAt,\n      data: originalValue,\n    });\n  } catch (serializationError) {\n    console.warn(`Unable to serialize migration backup for ${key}`, serializationError);\n    return;\n  }\n\n  const tryStoreSerialized = (candidate, options = {}) => {\n    const { logCompression = false, info = null } = options || {};\n    try {\n      storage.setItem(backupKey, candidate.serialized);\n      if (logCompression && info && !tryStoreSerialized.compressionLogged) {\n        tryStoreSerialized.compressionLogged = true;\n        const storedLength = typeof info.serializedLength === 'number'\n          ? info.serializedLength\n          : info.compressedSize;\n        const rawSavings = info.originalSize - storedLength;\n        const savings = rawSavings > 0 ? rawSavings : 0;\n        const percent = info.originalSize > 0\n          ? Math.round((savings / info.originalSize) * 100)\n          : 0;\n        const message = `Stored compressed migration backup for ${key} to reduce storage usage by ${savings} characters (${percent}%) using ${info.variant || 'unknown'} variant.`;\n        logCompressionSavingsEvent('migration-backup', key, message, savings, percent);\n      }\n      return { success: true, quota: false };\n    } catch (error) {\n      return { success: false, quota: isQuotaExceededError(error), error };\n    }\n  };\n  tryStoreSerialized.compressionLogged = tryStoreSerialized.compressionLogged || false;\n\n  const standardCandidate = { serialized };\n  const standardResult = tryStoreSerialized(standardCandidate);\n  if (standardResult.success) {\n    return;\n  }\n\n  const handleFailure = (error) => {\n    console.warn(`Unable to create migration backup for ${key}`, error);\n  };\n\n  if (!standardResult.quota) {\n    handleFailure(standardResult.error);\n    return;\n  }\n\n  const allowCompressedBackup = !isDeviceStorageKeyVariant(key);\n  const compressedCandidate = allowCompressedBackup\n    ? tryCreateCompressedMigrationBackupCandidate(serialized, createdAt)\n    : null;\n\n  const runRecoveryWith = (candidate, options, fallbackError) => {\n    const recovery = attemptMigrationBackupQuotaRecovery(storage, key, backupKey, () =>\n      tryStoreSerialized(candidate, options),\n    );\n    if (recovery && recovery.success) {\n      return true;\n    }\n    const errorToReport = recovery && recovery.error ? recovery.error : fallbackError;\n    handleFailure(errorToReport);\n    alertStorageError('migration-backup-quota');\n    return false;\n  };\n\n  if (compressedCandidate) {\n    const compressedResult = tryStoreSerialized(compressedCandidate, {\n      logCompression: true,\n      info: compressedCandidate,\n    });\n    if (compressedResult.success) {\n      return;\n    }\n    if (!compressedResult.quota) {\n      handleFailure(compressedResult.error);\n      return;\n    }\n    if (runRecoveryWith(compressedCandidate, { logCompression: true, info: compressedCandidate }, compressedResult.error)) {\n      return;\n    }\n    return;\n  }\n\n  if (runRecoveryWith(standardCandidate, {}, standardResult.error)) {\n    return;\n  }\n}\n\nvar PRIMARY_STORAGE_KEYS = [\n  DEVICE_STORAGE_KEY,\n  SETUP_STORAGE_KEY,\n  SESSION_STATE_KEY,\n  FEEDBACK_STORAGE_KEY,\n  PROJECT_STORAGE_KEY,\n  FAVORITES_STORAGE_KEY,\n  DEVICE_SCHEMA_CACHE_KEY,\n  AUTO_GEAR_RULES_STORAGE_KEY,\n  AUTO_GEAR_SEEDED_STORAGE_KEY,\n  AUTO_GEAR_BACKUPS_STORAGE_KEY,\n  AUTO_GEAR_PRESETS_STORAGE_KEY,\n  AUTO_GEAR_ACTIVE_PRESET_STORAGE_KEY,\n  AUTO_GEAR_AUTO_PRESET_STORAGE_KEY,\n  AUTO_GEAR_BACKUP_VISIBILITY_STORAGE_KEY,\n  AUTO_GEAR_MONITOR_DEFAULTS_STORAGE_KEY,\n  AUTO_GEAR_BACKUP_RETENTION_STORAGE_KEY,\n  FULL_BACKUP_HISTORY_STORAGE_KEY,\n];\n\nvar SIMPLE_STORAGE_KEYS = [\n  CUSTOM_LOGO_STORAGE_KEY,\n  getCustomFontStorageKeyName(),\n  'darkMode',\n  'pinkMode',\n  'highContrast',\n  'reduceMotion',\n  'relaxedSpacing',\n  'showAutoBackups',\n  'accentColor',\n  'fontSize',\n  'fontFamily',\n  'language',\n  'iosPwaHelpShown',\n  CAMERA_COLOR_STORAGE_KEY,\n  TEMPERATURE_UNIT_STORAGE_KEY_NAME,\n];\n\nvar STORAGE_ALERT_FLAG_NAME = '__cameraPowerPlannerStorageAlertShown';\nvar SESSION_FALLBACK_ALERT_FLAG_NAME = '__cameraPowerPlannerSessionFallbackAlertShown';\n\nvar storageErrorAlertShown = false;\nif (GLOBAL_SCOPE) {\n  if (typeof GLOBAL_SCOPE[STORAGE_ALERT_FLAG_NAME] === 'boolean') {\n    storageErrorAlertShown = GLOBAL_SCOPE[STORAGE_ALERT_FLAG_NAME];\n  } else {\n    GLOBAL_SCOPE[STORAGE_ALERT_FLAG_NAME] = false;\n  }\n}\n\nvar sessionFallbackAlertShown = false;\nif (GLOBAL_SCOPE) {\n  if (typeof GLOBAL_SCOPE[SESSION_FALLBACK_ALERT_FLAG_NAME] === 'boolean') {\n    sessionFallbackAlertShown = GLOBAL_SCOPE[SESSION_FALLBACK_ALERT_FLAG_NAME];\n  } else {\n    GLOBAL_SCOPE[SESSION_FALLBACK_ALERT_FLAG_NAME] = false;\n  }\n}\n\nvar DEVICE_COLLECTION_KEYS = [\n  'cameras',\n  'monitors',\n  'video',\n  'viewfinders',\n  'directorMonitors',\n  'iosVideo',\n  'videoAssist',\n  'media',\n  'lenses',\n  'batteries',\n  'batteryHotswaps',\n  'wirelessReceivers',\n];\n\nvar FIZ_COLLECTION_KEYS = ['motors', 'handUnits', 'controllers', 'distance'];\n\nvar ACCESSORY_COLLECTION_KEYS = [\n  'chargers',\n  'cages',\n  'powerPlates',\n  'cameraSupport',\n  'matteboxes',\n  'filters',\n  'rigging',\n  'batteries',\n  'cables',\n  'videoAssist',\n  'media',\n  'cardReaders',\n  'tripodHeads',\n  'tripods',\n  'sliders',\n  'cameraStabiliser',\n  'grip',\n  'carts',\n];\n\nvar getStorageManager = () =>\n  typeof navigator !== 'undefined' &&\n    navigator &&\n    typeof navigator.storage === 'object'\n    ? navigator.storage\n    : null;\n\n// Safely detect usable localStorage. Some environments (like private browsing)\n// may block access and throw errors. If unavailable, fall back to\n// sessionStorage when possible so data persists across reloads within the same\n// tab. When neither storage option is available we fall back to a simple\n// in-memory store to avoid runtime errors even though the data will be lost on\n// reload.\nvar STORAGE_TEST_KEY = '__storage_test__';\n\nvar QUOTA_ERROR_NAMES = new Set([\n  'QuotaExceededError',\n  'NS_ERROR_DOM_QUOTA_REACHED',\n]);\nvar QUOTA_ERROR_CODES = new Set([22, 1014]);\nvar QUOTA_ERROR_NUMBERS = new Set([22, 1014]);\n\nfunction isQuotaExceededError(error) {\n  if (!error || typeof error !== 'object') {\n    return false;\n  }\n  if (typeof error.code === 'number' && QUOTA_ERROR_CODES.has(error.code)) {\n    return true;\n  }\n  if (typeof error.number === 'number' && QUOTA_ERROR_NUMBERS.has(error.number)) {\n    return true;\n  }\n  if (typeof error.name === 'string' && QUOTA_ERROR_NAMES.has(error.name)) {\n    return true;\n  }\n  return false;\n}\n\nfunction hasStoredEntries(storage) {\n  if (!storage) return false;\n\n  try {\n    if (typeof storage.length === 'number' && storage.length > 0) {\n      return true;\n    }\n  } catch (lengthError) {\n    console.warn('Unable to read storage length after quota error', lengthError);\n  }\n\n  if (typeof storage.getItem === 'function') {\n    try {\n      for (let i = 0; i < PRIMARY_STORAGE_KEYS.length; i += 1) {\n        const key = PRIMARY_STORAGE_KEYS[i];\n        const variants = getStorageKeyVariants(key);\n        for (let j = 0; j < variants.length; j += 1) {\n          const candidateKey = variants[j];\n          if (storage.getItem(candidateKey) !== null) {\n            return true;\n          }\n          const backupKey = `${candidateKey}${STORAGE_BACKUP_SUFFIX}`;\n          if (storage.getItem(backupKey) !== null) {\n            return true;\n          }\n        }\n      }\n\n      for (let i = 0; i < SIMPLE_STORAGE_KEYS.length; i += 1) {\n        const key = SIMPLE_STORAGE_KEYS[i];\n        const variants = getStorageKeyVariants(key);\n        for (let j = 0; j < variants.length; j += 1) {\n          const candidateKey = variants[j];\n          if (storage.getItem(candidateKey) !== null) {\n            return true;\n          }\n          if (RAW_STORAGE_BACKUP_KEYS.has(candidateKey)) {\n            const backupKey = `${candidateKey}${STORAGE_BACKUP_SUFFIX}`;\n            if (storage.getItem(backupKey) !== null) {\n              return true;\n            }\n          }\n        }\n      }\n    } catch (inspectionError) {\n      console.warn('Unable to inspect known storage keys after quota error', inspectionError);\n    }\n  }\n\n  if (typeof storage.key === 'function') {\n    try {\n      const length = typeof storage.length === 'number' ? storage.length : 0;\n      for (let index = 0; index < length; index += 1) {\n        const candidate = storage.key(index);\n        if (typeof candidate === 'string' && candidate) {\n          return true;\n        }\n      }\n    } catch (iterationError) {\n      console.warn('Unable to iterate storage keys after quota error', iterationError);\n    }\n  }\n\n  return false;\n}\n\nfunction verifyStorage(storage) {\n  if (!storage) return null;\n  try {\n    storage.setItem(STORAGE_TEST_KEY, '1');\n  } catch (error) {\n    if (isQuotaExceededError(error) && hasStoredEntries(storage)) {\n      console.warn(\n        'localStorage quota exceeded. Existing planner data will remain available but new saves may fail.',\n        error,\n      );\n      return storage;\n    }\n    throw error;\n  }\n\n  try {\n    storage.removeItem(STORAGE_TEST_KEY);\n  } catch (cleanupError) {\n    console.warn('Unable to clean up storage test key', cleanupError);\n  }\n\n  return storage;\n}\n\nfunction createMemoryStorage() {\n  let memoryStore = {};\n  return {\n    get length() {\n      return Object.keys(memoryStore).length;\n    },\n    key(index) {\n      const keys = Object.keys(memoryStore);\n      return index >= 0 && index < keys.length ? keys[index] : null;\n    },\n    getItem(key) {\n      if (!Object.prototype.hasOwnProperty.call(memoryStore, key)) {\n        return null;\n      }\n      return maybeDecompressStoredString(memoryStore[key]);\n    },\n    setItem(key, value) {\n      memoryStore[key] = String(value);\n    },\n    removeItem(key) {\n      delete memoryStore[key];\n    },\n    clear() {\n      memoryStore = {};\n    },\n    keys() {\n      return Object.keys(memoryStore);\n    },\n  };\n}\n\nfunction initializeSafeLocalStorage() {\n  const localCandidates = collectLocalStorageCandidates();\n\n  for (let index = 0; index < localCandidates.length; index += 1) {\n    const candidate = localCandidates[index];\n    if (!candidate) {\n      continue;\n    }\n\n    try {\n      const storage = verifyStorage(candidate);\n      if (storage) {\n        lastFailedUpgradeCandidate = null;\n        return { storage, type: 'local' };\n      }\n    } catch (error) {\n      console.warn('localStorage is unavailable:', error);\n      lastFailedUpgradeCandidate = candidate;\n    }\n  }\n\n  if (typeof window !== 'undefined') {\n    try {\n      if ('sessionStorage' in window) {\n        const storage = verifyStorage(window.sessionStorage);\n        if (storage) {\n          registerKnownSessionStorage(storage);\n          console.warn('Falling back to sessionStorage; data persists for this tab only.');\n          alertSessionFallback();\n          return { storage, type: 'session' };\n        }\n      }\n    } catch (e) {\n      console.warn('sessionStorage fallback is unavailable:', e);\n    }\n  }\n\n  alertStorageError();\n  return { storage: createMemoryStorage(), type: 'memory' };\n}\n\nvar lastFailedUpgradeCandidate = null;\nvar safeLocalStorageInfo = initializeSafeLocalStorage();\n\nfunction migrateSnapshotToStorage(snapshot, target) {\n  const migratedKeys = [];\n  const failedKeys = [];\n\n  if (!snapshot || !target || typeof target.setItem !== 'function') {\n    return { migratedKeys, failedKeys };\n  }\n\n  Object.keys(snapshot).forEach((key) => {\n    const value = snapshot[key];\n    if (value === null || value === undefined) {\n      return;\n    }\n\n    let existing = null;\n    let existingRead = false;\n    try {\n      existing = target.getItem(key);\n      existingRead = true;\n    } catch (readError) {\n      console.warn('Unable to inspect localStorage during upgrade', key, readError);\n    }\n\n    if (existingRead && existing !== null && existing !== undefined && existing !== value) {\n      createStorageMigrationBackup(target, key, existing);\n    }\n\n    if (existingRead && existing === value) {\n      migratedKeys.push(key);\n      return;\n    }\n\n    try {\n      target.setItem(key, value);\n      migratedKeys.push(key);\n    } catch (writeError) {\n      console.warn('Unable to migrate storage key during upgrade', key, writeError);\n      failedKeys.push(key);\n    }\n  });\n\n  return { migratedKeys, failedKeys };\n}\n\nfunction clearMigratedKeys(snapshot, source, keysToRemove) {\n  if (!snapshot || !source || typeof source.removeItem !== 'function') {\n    return;\n  }\n\n  const keys = Array.isArray(keysToRemove) && keysToRemove.length > 0\n    ? keysToRemove\n    : Object.keys(snapshot);\n\n  keys.forEach((key) => {\n    try {\n      source.removeItem(key);\n    } catch (error) {\n      console.warn('Unable to remove migrated storage key from fallback', key, error);\n    }\n  });\n}\n\nfunction rollbackMigratedKeys(target, keys) {\n  if (!target || typeof target.removeItem !== 'function' || !Array.isArray(keys)) {\n    return;\n  }\n\n  keys.forEach((key) => {\n    try {\n      target.removeItem(key);\n    } catch (error) {\n      console.warn('Unable to roll back migrated storage key after upgrade failure', key, error);\n    }\n  });\n}\n\nfunction snapshotStorageEntries(storage, options = {}) {\n  const snapshot = Object.create(null);\n  if (!storage) {\n    return snapshot;\n  }\n\n  const { suppressAlerts = false } = options || {};\n\n  const captureKey = (key) => {\n    if (typeof key !== 'string' || !key) {\n      return;\n    }\n    let value;\n    try {\n      if (typeof storage.getItem === 'function') {\n        value = storage.getItem(key);\n      } else if (Object.prototype.hasOwnProperty.call(storage, key)) {\n        value = storage[key];\n      }\n    } catch (error) {\n      console.warn('Unable to read storage key during snapshot', key, error);\n      if (!suppressAlerts) {\n        alertStorageError('migration-read');\n      }\n      return;\n    }\n    if (value === null || value === undefined) {\n      return;\n    }\n    snapshot[key] = String(value);\n  };\n\n  if (typeof storage.key === 'function' && typeof storage.length === 'number') {\n    for (let index = 0; index < storage.length; index += 1) {\n      captureKey(storage.key(index));\n    }\n    return snapshot;\n  }\n\n  if (typeof storage.keys === 'function') {\n    try {\n      const keys = storage.keys();\n      if (Array.isArray(keys)) {\n        keys.forEach(captureKey);\n      }\n    } catch (error) {\n      console.warn('Unable to enumerate storage keys during snapshot', error);\n      if (!suppressAlerts) {\n        alertStorageError('migration-read');\n      }\n    }\n    return snapshot;\n  }\n\n  if (typeof storage.forEach === 'function') {\n    try {\n      storage.forEach((value, key) => {\n        if (typeof key !== 'string') {\n          return;\n        }\n        if (value === null || value === undefined) {\n          return;\n        }\n        snapshot[key] = String(value);\n      });\n    } catch (error) {\n      console.warn('Unable to iterate storage entries during snapshot', error);\n      if (!suppressAlerts) {\n        alertStorageError('migration-read');\n      }\n    }\n    return snapshot;\n  }\n\n  Object.keys(storage).forEach(captureKey);\n  return snapshot;\n}\n\nfunction updateGlobalSafeLocalStorageReference() {\n  if (!GLOBAL_SCOPE || typeof GLOBAL_SCOPE !== 'object') {\n    return;\n  }\n\n  try {\n    Object.defineProperty(GLOBAL_SCOPE, 'SAFE_LOCAL_STORAGE', {\n      configurable: true,\n      get: getSafeLocalStorage,\n    });\n    return;\n  } catch (defineError) {\n    void defineError;\n    try {\n      GLOBAL_SCOPE.SAFE_LOCAL_STORAGE = getSafeLocalStorage();\n      return;\n    } catch (assignError) {\n      console.warn('Unable to refresh SAFE_LOCAL_STORAGE global reference', assignError);\n    }\n  }\n}\n\nfunction downgradeSafeLocalStorageToMemory(reason, error, failingStorage) {\n  if (!safeLocalStorageInfo || safeLocalStorageInfo.type === 'memory') {\n    return;\n  }\n\n  const activeStorage = safeLocalStorageInfo.storage;\n  if (!activeStorage || (failingStorage && failingStorage !== activeStorage)) {\n    return;\n  }\n\n  let snapshot = Object.create(null);\n  try {\n    snapshot = snapshotStorageEntries(activeStorage, { suppressAlerts: true });\n  } catch (snapshotError) {\n    console.warn('Unable to capture storage snapshot during downgrade', snapshotError);\n  }\n\n  let fallbackStorage = null;\n  let fallbackType = 'memory';\n\n  if (safeLocalStorageInfo.type !== 'session') {\n    const sessionScopes = [\n      GLOBAL_SCOPE,\n      GLOBAL_SCOPE && GLOBAL_SCOPE.window ? GLOBAL_SCOPE.window : null,\n      GLOBAL_SCOPE && GLOBAL_SCOPE.__cineGlobal ? GLOBAL_SCOPE.__cineGlobal : null,\n      typeof window !== 'undefined' ? window : null,\n      typeof self !== 'undefined' ? self : null,\n      typeof global !== 'undefined' ? global : null,\n    ];\n\n    for (let index = 0; index < sessionScopes.length; index += 1) {\n      const candidate = resolveSessionStorageFromScope(sessionScopes[index]);\n      if (!candidate || candidate === activeStorage || (failingStorage && candidate === failingStorage)) {\n        continue;\n      }\n\n      try {\n        const verified = verifyStorage(candidate);\n        if (verified) {\n          fallbackStorage = verified;\n          fallbackType = 'session';\n          registerKnownSessionStorage(verified);\n          break;\n        }\n      } catch (sessionError) {\n        console.warn('Unable to activate sessionStorage fallback during downgrade', sessionError);\n      }\n    }\n  }\n\n  if (!fallbackStorage) {\n    fallbackStorage = createMemoryStorage();\n  }\n\n  Object.keys(snapshot).forEach((key) => {\n    const value = snapshot[key];\n    if (value === null || value === undefined) {\n      return;\n    }\n    try {\n      if (typeof fallbackStorage.setItem === 'function') {\n        fallbackStorage.setItem(key, value);\n      } else {\n        fallbackStorage[key] = value;\n      }\n    } catch (copyError) {\n      const label = fallbackType === 'session' ? 'sessionStorage' : 'memory';\n      console.warn(`Unable to copy storage entry to ${label} during downgrade`, key, copyError);\n    }\n  });\n\n  safeLocalStorageInfo = { storage: fallbackStorage, type: fallbackType };\n  lastFailedUpgradeCandidate = null;\n\n  const fallbackDescription = fallbackType === 'session' ? 'sessionStorage' : 'in-memory fallback';\n  console.warn(\n    reason\n      ? `Downgraded planner storage to ${fallbackDescription} after ${reason} errors.`\n      : `Downgraded planner storage to ${fallbackDescription} after storage errors.`,\n    error,\n  );\n\n  if (fallbackType === 'session') {\n    alertSessionFallback();\n  }\n\n  updateGlobalSafeLocalStorageReference();\n}\n\nfunction attemptLocalStorageUpgrade() {\n  if (!safeLocalStorageInfo || safeLocalStorageInfo.type === 'local') {\n    return safeLocalStorageInfo.storage;\n  }\n\n  const candidates = collectLocalStorageCandidates();\n  const currentStorage = safeLocalStorageInfo.storage;\n  let selectedCandidate = null;\n  let verifiedStorage = null;\n\n  for (let index = 0; index < candidates.length; index += 1) {\n    const candidate = candidates[index];\n    if (!candidate || candidate === currentStorage) {\n      continue;\n    }\n    if (candidate === lastFailedUpgradeCandidate) {\n      continue;\n    }\n\n    let verified;\n    try {\n      verified = verifyStorage(candidate);\n    } catch (verificationError) {\n      console.warn('localStorage upgrade verification failed', verificationError);\n      lastFailedUpgradeCandidate = candidate;\n      continue;\n    }\n\n    if (!verified || verified === currentStorage) {\n      if (!verified) {\n        lastFailedUpgradeCandidate = candidate;\n      }\n      continue;\n    }\n\n    selectedCandidate = candidate;\n    verifiedStorage = verified;\n    break;\n  }\n\n  if (!verifiedStorage) {\n    return currentStorage;\n  }\n\n  const snapshot = snapshotStorageEntries(currentStorage);\n  const { migratedKeys, failedKeys } = migrateSnapshotToStorage(snapshot, verifiedStorage);\n\n  if (failedKeys.length > 0) {\n    rollbackMigratedKeys(verifiedStorage, migratedKeys);\n    console.warn(\n      'Aborting localStorage upgrade because some entries could not be migrated. Continuing to use fallback storage.',\n      failedKeys,\n    );\n    alertStorageError('migration-write');\n    lastFailedUpgradeCandidate = selectedCandidate || verifiedStorage;\n    return currentStorage;\n  }\n\n  clearMigratedKeys(snapshot, currentStorage, migratedKeys);\n\n  safeLocalStorageInfo = { storage: verifiedStorage, type: 'local' };\n  lastFailedUpgradeCandidate = null;\n  return verifiedStorage;\n}\n\nfunction getSafeLocalStorage() {\n  // [Refactor] Delegate to the new StorageRepository driver if compatible\n  if (storageRepo && storageRepo.driver && storageRepo.driver.storage) {\n    return storageRepo.driver.storage;\n  }\n\n  if (!safeLocalStorageInfo || !safeLocalStorageInfo.storage) {\n    safeLocalStorageInfo = initializeSafeLocalStorage();\n    if (typeof console !== 'undefined' && console.log) {\n      console.log('DEBUG: storage initialized with type:', safeLocalStorageInfo.type);\n    }\n  }\n\n  if (safeLocalStorageInfo.type !== 'local') {\n    attemptLocalStorageUpgrade();\n  }\n\n  return safeLocalStorageInfo.storage;\n}\n\nupdateGlobalSafeLocalStorageReference();\npatchStorageGetItemForCompression();\n\nvar persistentStorageRequestPromise = null;\n\nfunction requestPersistentStorage() {\n  const storageManager = getStorageManager();\n  const supportsPersist =\n    storageManager && typeof storageManager.persist === 'function';\n\n  if (!supportsPersist) {\n    return Promise.resolve({\n      supported: false,\n      granted: false,\n      alreadyGranted: false,\n    });\n  }\n\n  if (persistentStorageRequestPromise) {\n    return persistentStorageRequestPromise;\n  }\n\n  const requestPromise = (async () => {\n    let alreadyGranted = false;\n    const supportsPersistedCheck = typeof storageManager.persisted === 'function';\n\n    if (supportsPersistedCheck) {\n      try {\n        alreadyGranted = await storageManager.persisted();\n      } catch (persistedError) {\n        console.warn('Unable to determine persistent storage state', persistedError);\n      }\n    }\n\n    if (alreadyGranted) {\n      return {\n        supported: true,\n        granted: true,\n        alreadyGranted: true,\n      };\n    }\n\n    try {\n      const granted = await storageManager.persist();\n      if (!granted && supportsPersistedCheck) {\n        try {\n          const persisted = await storageManager.persisted();\n          if (persisted) {\n            return {\n              supported: true,\n              granted: true,\n              alreadyGranted: true,\n            };\n          }\n        } catch (verifyError) {\n          console.warn('Unable to verify persistent storage after request', verifyError);\n        }\n      }\n\n      return {\n        supported: true,\n        granted,\n        alreadyGranted: false,\n      };\n    } catch (error) {\n      console.warn('Persistent storage request failed', error);\n      return {\n        supported: true,\n        granted: false,\n        alreadyGranted: false,\n        error,\n      };\n    }\n  })();\n\n  const trackedPromise = requestPromise.then(\n    (result) => {\n      if (!result || result.granted !== true) {\n        persistentStorageRequestPromise = null;\n      }\n      return result;\n    },\n    (error) => {\n      persistentStorageRequestPromise = null;\n      throw error;\n    },\n  );\n\n  persistentStorageRequestPromise = trackedPromise;\n  return trackedPromise;\n}\n\nif (typeof window !== 'undefined' && typeof navigator !== 'undefined') {\n  requestPersistentStorage();\n}\n\n// Helper to check for plain objects\nfunction isPlainObject(val) {\n  if (val === null || typeof val !== 'object') {\n    return false;\n  }\n  let prototype;\n  try {\n    prototype = Object.getPrototypeOf(val);\n  } catch {\n    return false;\n  }\n  if (prototype === null || prototype === Object.prototype) {\n    return true;\n  }\n  const secondLevel = Object.getPrototypeOf(prototype);\n  if (secondLevel === null && typeof prototype.constructor === 'function') {\n    const name = prototype.constructor.name;\n    return name === 'Object' || name === '';\n  }\n  return false;\n}\n\nfunction isMapLike(value) {\n  if (!value || typeof value !== 'object') {\n    return false;\n  }\n\n  const tag = Object.prototype.toString.call(value);\n  if (tag === '[object Map]') {\n    return true;\n  }\n\n  if (typeof Map !== 'undefined') {\n    try {\n      if (value instanceof Map) {\n        return true;\n      }\n    } catch (error) {\n      void error;\n    }\n  }\n\n  return (\n    typeof value.size === 'number'\n    && typeof value.entries === 'function'\n    && typeof value.forEach === 'function'\n    && typeof value.get === 'function'\n    && typeof value.set === 'function'\n  );\n}\n\nfunction convertMapLikeKey(key) {\n  if (typeof key === 'string') {\n    return key;\n  }\n  if (typeof key === 'number' || typeof key === 'boolean' || typeof key === 'bigint') {\n    return String(key);\n  }\n  if (typeof key === 'symbol') {\n    return key.description || key.toString();\n  }\n  if (key && typeof key === 'object') {\n    try {\n      const json = JSON.stringify(key);\n      if (json && json !== '{}') {\n        return json;\n      }\n    } catch (error) {\n      void error;\n    }\n  }\n  try {\n    return String(key);\n  } catch (error) {\n    void error;\n  }\n  return null;\n}\n\nfunction convertMapLikeToObject(mapLike) {\n  if (!isMapLike(mapLike)) {\n    return null;\n  }\n\n  const snapshot = Object.create(null);\n  const assignEntry = (rawKey, value) => {\n    const key = convertMapLikeKey(rawKey);\n    if (key === null || key === undefined) {\n      return;\n    }\n    if (Object.prototype.hasOwnProperty.call(snapshot, key)) {\n      return;\n    }\n    snapshot[key] = value;\n  };\n\n  let iterated = false;\n\n  if (typeof mapLike.entries === 'function') {\n    try {\n      const iterator = mapLike.entries();\n      if (iterator && typeof iterator.next === 'function') {\n        for (let step = iterator.next(); !step.done; step = iterator.next()) {\n          const entry = step && step.value;\n          if (Array.isArray(entry) && entry.length >= 2) {\n            assignEntry(entry[0], entry[1]);\n          }\n        }\n        iterated = true;\n      }\n    } catch (error) {\n      console.warn('Unable to iterate map-like value entries', error);\n    }\n  }\n\n  if (!iterated && typeof mapLike.forEach === 'function') {\n    try {\n      mapLike.forEach((value, key) => {\n        assignEntry(key, value);\n      });\n      iterated = true;\n    } catch (error) {\n      console.warn('Unable to iterate map-like value via forEach', error);\n    }\n  }\n\n  if (!Object.keys(snapshot).length && !iterated) {\n    return null;\n  }\n\n  return snapshot;\n}\n\nvar LEGACY_LONG_GOP_TOKEN_REGEX = /^long[\\s_-]?gop$/i;\n\nfunction inferLegacyLongGopCompressionVariant(value) {\n  if (typeof value !== 'string') {\n    return null;\n  }\n\n  var trimmed = value.trim();\n  if (!trimmed) {\n    return null;\n  }\n\n  var lower = trimmed.toLowerCase();\n  if (lower === 'utf16' || lower === 'utf-16') {\n    return 'utf16';\n  }\n  if (lower === 'uri-component' || lower === 'uri_component' || lower === 'encoded-uri-component' || lower === 'uri') {\n    return 'uri-component';\n  }\n  if (lower === 'base64') {\n    return 'base64';\n  }\n\n  if (LEGACY_LONG_GOP_TOKEN_REGEX.test(lower)) {\n    return 'utf16';\n  }\n\n  return null;\n}\n\nfunction normalizeLegacyLongGopString(value) {\n  if (typeof value !== 'string') {\n    return value;\n  }\n\n  const trimmed = value.trim();\n  if (LEGACY_LONG_GOP_TOKEN_REGEX.test(trimmed)) {\n    return 'long-gop';\n  }\n\n  return value;\n}\n\nfunction normalizeLegacyLongGopKey(key) {\n  if (typeof key !== 'string') {\n    return key;\n  }\n\n  return LEGACY_LONG_GOP_TOKEN_REGEX.test(key) ? 'long-gop' : key;\n}\n\nfunction normalizeLegacyLongGopStructure(value, visited) {\n  if (value === null || typeof value !== 'object') {\n    return normalizeLegacyLongGopString(value);\n  }\n\n  const seen = visited || new WeakSet();\n  if (seen.has(value)) {\n    return value;\n  }\n  seen.add(value);\n\n  if (Array.isArray(value)) {\n    let changed = false;\n    const normalizedArray = value.map((item) => {\n      const normalizedItem = normalizeLegacyLongGopStructure(item, seen);\n      if (normalizedItem !== item) {\n        changed = true;\n      }\n      return normalizedItem;\n    });\n    return changed ? normalizedArray : value;\n  }\n\n  if (isPlainObject(value)) {\n    let changed = false;\n    const normalizedObject = {};\n    Object.keys(value).forEach((key) => {\n      const normalizedKey = normalizeLegacyLongGopKey(key);\n      const originalValue = value[key];\n      const normalizedValue = normalizeLegacyLongGopStructure(originalValue, seen);\n      if (normalizedKey !== key || normalizedValue !== originalValue) {\n        changed = true;\n      }\n      normalizedObject[normalizedKey] = normalizedValue;\n    });\n    return changed ? normalizedObject : value;\n  }\n\n  return normalizeLegacyLongGopString(value);\n}\n\nfunction normalizeLegacyLongGopBackups(backups) {\n  if (!Array.isArray(backups)) {\n    return { normalized: Array.isArray(backups) ? backups : [], changed: false };\n  }\n\n  let changed = false;\n  const normalized = backups.map((entry) => {\n    if (entry === null || entry === undefined) {\n      return entry;\n    }\n    const normalizedEntry = normalizeLegacyLongGopStructure(entry);\n    if (normalizedEntry !== entry) {\n      changed = true;\n    }\n    return normalizedEntry;\n  });\n\n  return { normalized, changed };\n}\n\nfunction parseAutoBackupKey(name) {\n  if (typeof name !== 'string') {\n    return { timestamp: Number.NEGATIVE_INFINITY, label: '' };\n  }\n\n  const parseWithPrefix = (prefix, options = {}) => {\n    const remainder = name.slice(prefix.length);\n    const parts = remainder.split('-');\n    if (parts.length < 5) {\n      return null;\n    }\n\n    const [yearPart, monthPart, dayPart, hourPart, minutePart] = parts;\n    const year = Number.parseInt(yearPart, 10);\n    const month = Number.parseInt(monthPart, 10) - 1;\n    const day = Number.parseInt(dayPart, 10);\n    const hour = Number.parseInt(hourPart, 10);\n    const minute = Number.parseInt(minutePart, 10);\n\n    if ([year, month, day, hour, minute].some(value => Number.isNaN(value))) {\n      return null;\n    }\n\n    let includeSeconds = false;\n    let seconds = 0;\n    let labelStartIndex = 5;\n\n    if (parts.length > labelStartIndex) {\n      const secondsCandidate = parts[labelStartIndex];\n      if (/^\\d{1,2}$/u.test(secondsCandidate)) {\n        includeSeconds = true;\n        seconds = Number.parseInt(secondsCandidate, 10);\n        labelStartIndex += 1;\n      } else if (options.requireSeconds) {\n        return null;\n      }\n    } else if (options.requireSeconds) {\n      return null;\n    }\n\n    const label = parts.slice(labelStartIndex).join('-').trim();\n    const date = new Date(year, month, day, hour, minute, includeSeconds ? seconds : 0, 0);\n    const timestamp = date.getTime();\n\n    if (Number.isNaN(timestamp)) {\n      return null;\n    }\n\n    return { timestamp, label };\n  };\n\n  if (name.startsWith(STORAGE_AUTO_BACKUP_NAME_PREFIX)) {\n    const parsed = parseWithPrefix(STORAGE_AUTO_BACKUP_NAME_PREFIX);\n    if (parsed) {\n      return parsed;\n    }\n    return { timestamp: Number.NEGATIVE_INFINITY, label: '' };\n  }\n\n  if (name.startsWith(STORAGE_AUTO_BACKUP_DELETION_PREFIX)) {\n    const parsed = parseWithPrefix(STORAGE_AUTO_BACKUP_DELETION_PREFIX, { requireSeconds: false });\n    if (parsed) {\n      return parsed;\n    }\n    return { timestamp: Number.NEGATIVE_INFINITY, label: '' };\n  }\n\n  return { timestamp: Number.NEGATIVE_INFINITY, label: '' };\n}\n\nfunction collectAutoBackupEntries(container, prefix) {\n  if (!isPlainObject(container) || typeof prefix !== 'string') {\n    return [];\n  }\n\n  return Object.keys(container)\n    .filter((key) => typeof key === 'string' && key.startsWith(prefix))\n    .map((key) => {\n      const { timestamp, label } = parseAutoBackupKey(key);\n      return { key, timestamp, label };\n    })\n    .sort((a, b) => {\n      if (a.timestamp !== b.timestamp) {\n        return a.timestamp - b.timestamp;\n      }\n      return a.key.localeCompare(b.key);\n    });\n}\n\nfunction markAutoBackupValueAsRenamed(value) {\n  if (!value || typeof value !== 'object') {\n    return;\n  }\n\n  try {\n    value[STORAGE_AUTO_BACKUP_RENAMED_FLAG] = true;\n  } catch (assignmentError) {\n    void assignmentError;\n    try {\n      Object.defineProperty(value, STORAGE_AUTO_BACKUP_RENAMED_FLAG, {\n        configurable: true,\n        enumerable: true,\n        writable: true,\n        value: true,\n      });\n    } catch (definitionError) {\n      void definitionError;\n    }\n  }\n\n  if (isPlainObject(value.projectInfo)) {\n    try {\n      value.projectInfo[STORAGE_AUTO_BACKUP_RENAMED_FLAG] = true;\n    } catch (infoError) {\n      void infoError;\n    }\n  }\n}\n\nfunction isAutoBackupValueRenamed(value) {\n  if (!value || typeof value !== 'object') {\n    return false;\n  }\n  if (value[STORAGE_AUTO_BACKUP_RENAMED_FLAG] === true) {\n    return true;\n  }\n  if (\n    isPlainObject(value.projectInfo)\n    && value.projectInfo[STORAGE_AUTO_BACKUP_RENAMED_FLAG] === true\n  ) {\n    return true;\n  }\n  return false;\n}\n\nfunction isRenamedAutoBackupEntry(container, key) {\n  if (!isPlainObject(container) || typeof key !== 'string') {\n    return false;\n  }\n  return isAutoBackupValueRenamed(container[key]);\n}\n\nfunction getAutoBackupLabelKey(entry) {\n  if (!entry || typeof entry !== 'object') {\n    return '';\n  }\n  if (typeof entry.label === 'string') {\n    const trimmed = entry.label.trim();\n    if (trimmed) {\n      return trimmed;\n    }\n  }\n  if (typeof entry.key === 'string' && entry.key.trim()) {\n    const key = entry.key.trim();\n    if (\n      key.startsWith(STORAGE_AUTO_BACKUP_NAME_PREFIX)\n      || key.startsWith(STORAGE_AUTO_BACKUP_DELETION_PREFIX)\n    ) {\n      return '__auto-backup:unlabeled__';\n    }\n    return key;\n  }\n  return '__auto-backup:unlabeled__';\n}\n\nfunction getAutoBackupEntrySignature(container, entry) {\n  if (!isPlainObject(container) || !entry || typeof entry.key !== 'string') {\n    return 'undefined';\n  }\n  const value = Object.prototype.hasOwnProperty.call(container, entry.key)\n    ? container[entry.key]\n    : undefined;\n  try {\n    let preparedValue = value;\n    if (isPlainObject(value) && value[AUTO_BACKUP_SNAPSHOT_PROPERTY]) {\n      const cloneForSignature = cloneAutoBackupValue(value, { stripMetadata: true });\n      const snapshot = cloneForSignature[AUTO_BACKUP_SNAPSHOT_PROPERTY];\n      if (snapshot && typeof snapshot === 'object') {\n        try {\n          const restored = restoreAutoBackupSnapshotPayload(snapshot, entry.key);\n          snapshot.payload = restored.payload;\n          if (Object.prototype.hasOwnProperty.call(snapshot, 'payloadCompression')) {\n            delete snapshot.payloadCompression;\n          }\n        } catch (payloadError) {\n          console.warn('Failed to expand automatic backup payload for signature comparison', entry.key, payloadError);\n        }\n      }\n      preparedValue = cloneForSignature;\n    }\n\n    const normalizedValue = cloneAutoBackupValueWithLegacyNormalization(preparedValue, {\n      stripMetadata: true,\n    });\n    return createStableValueSignature(normalizedValue);\n  } catch (error) {\n    console.warn('Failed to create stable signature for automatic backup entry', error);\n    return 'undefined';\n  }\n}\n\nfunction createStableValueSignature(value, state) {\n  const signatureState = state || (typeof WeakSet === 'function'\n    ? { seen: new WeakSet(), reportedCycle: false }\n    : null);\n  const seenSet = signatureState && signatureState.seen ? signatureState.seen : null;\n\n  const handleCircularSignature = (input, compute) => {\n    if (!seenSet) {\n      return compute();\n    }\n    if (seenSet.has(input)) {\n      if (!signatureState.reportedCycle\n        && typeof console !== 'undefined'\n        && console\n        && typeof console.warn === 'function') {\n        console.warn(\n          'Detected circular reference while computing automatic backup signature. Using a placeholder token to keep backups stable.',\n        );\n      }\n      signatureState.reportedCycle = true;\n      return AUTO_BACKUP_CYCLE_PLACEHOLDER;\n    }\n    seenSet.add(input);\n    try {\n      return compute();\n    } finally {\n      seenSet.delete(input);\n    }\n  };\n\n  if (value === null) {\n    return 'null';\n  }\n  if (value === undefined) {\n    return 'undefined';\n  }\n  if (Array.isArray(value)) {\n    return handleCircularSignature(value, () => {\n      let signature = '[';\n      for (let index = 0; index < value.length; index += 1) {\n        if (index > 0) {\n          signature += ',';\n        }\n        signature += createStableValueSignature(value[index], signatureState);\n      }\n      signature += ']';\n      return signature;\n    });\n  }\n  if (value instanceof Date) {\n    return handleCircularSignature(value, () => {\n      const timestamp = value.getTime();\n      if (Number.isNaN(timestamp)) {\n        return 'date:invalid';\n      }\n      return `date:${timestamp}`;\n    });\n  }\n  if (isPlainObject(value)) {\n    return handleCircularSignature(value, () => {\n      const keys = Object.keys(value).sort();\n      let signature = '{';\n      for (let index = 0; index < keys.length; index += 1) {\n        const key = keys[index];\n        if (index > 0) {\n          signature += ',';\n        }\n        signature += `${JSON.stringify(key)}:${createStableValueSignature(value[key], signatureState)}`;\n      }\n      signature += '}';\n      return signature;\n    });\n  }\n  if (value && typeof value === 'object') {\n    return handleCircularSignature(value, () => `${typeof value}:${String(value)}`);\n  }\n  if (typeof value === 'number') {\n    if (Number.isNaN(value)) {\n      return 'number:NaN';\n    }\n    if (!Number.isFinite(value)) {\n      return value > 0 ? 'number:Infinity' : 'number:-Infinity';\n    }\n    return `number:${value}`;\n  }\n  if (typeof value === 'bigint') {\n    return `bigint:${value.toString()}`;\n  }\n  if (typeof value === 'boolean') {\n    return value ? 'boolean:true' : 'boolean:false';\n  }\n  if (typeof value === 'string') {\n    const decoded = decodeCompressedJsonStorageValue(value);\n    if (decoded.success && typeof decoded.value === 'string') {\n      try {\n        const parsed = JSON.parse(decoded.value);\n        return createStableValueSignature(parsed, signatureState);\n      } catch (signatureParseError) {\n        console.warn(\n          'Unable to decode compressed string while computing stable value signature',\n          signatureParseError,\n        );\n      }\n    }\n    return `string:${value}`;\n  }\n  if (typeof value === 'symbol') {\n    return `symbol:${String(value)}`;\n  }\n  if (typeof value === 'function') {\n    return `function:${value.name || 'anonymous'}`;\n  }\n  return `${typeof value}:${String(value)}`;\n}\n\nfunction removeSingleDuplicateAutoBackupEntry(container, entries) {\n  if (!isPlainObject(container) || !Array.isArray(entries) || entries.length < 2) {\n    return null;\n  }\n\n  const seenSignaturesByLabel = new Map();\n\n  for (let index = entries.length - 1; index >= 0; index -= 1) {\n    const entry = entries[index];\n    if (!entry || typeof entry.key !== 'string') {\n      continue;\n    }\n    if (isRenamedAutoBackupEntry(container, entry.key)) {\n      continue;\n    }\n\n    const labelKey = getAutoBackupLabelKey(entry);\n    let labelSignatures = seenSignaturesByLabel.get(labelKey);\n    if (!labelSignatures) {\n      labelSignatures = new Map();\n      seenSignaturesByLabel.set(labelKey, labelSignatures);\n    }\n\n    const value = Object.prototype.hasOwnProperty.call(container, entry.key)\n      ? container[entry.key]\n      : undefined;\n    const signature = createStableValueSignature(value);\n    const seen = labelSignatures.get(signature);\n\n    if (seen && typeof seen.key === 'string') {\n      delete container[entry.key];\n      entries.splice(index, 1);\n\n      if (\n        typeof console !== 'undefined'\n        && typeof console.info === 'function'\n      ) {\n        console.info('Removed duplicate automatic backup while preserving newer copy.', {\n          removedKey: entry.key,\n          preservedKey: seen.key,\n          label: labelKey,\n        });\n      }\n\n      return entry.key;\n    }\n\n    labelSignatures.set(signature, {\n      key: entry.key,\n      signature,\n    });\n  }\n\n  return null;\n}\n\nfunction removeDuplicateAutoBackupEntries(container, entries) {\n  const removedKeys = [];\n  while (true) {\n    const removedKey = removeSingleDuplicateAutoBackupEntry(container, entries);\n    if (!removedKey) {\n      break;\n    }\n    removedKeys.push(removedKey);\n  }\n  return removedKeys;\n}\n\nfunction pruneAutoBackupEntries(container, entries, limit, removedKeys) {\n  if (!isPlainObject(container) || !Array.isArray(entries) || entries.length <= limit) {\n    return;\n  }\n\n  const duplicateBuckets = new Map();\n  for (let index = 0; index < entries.length; index += 1) {\n    const entry = entries[index];\n    if (!entry || typeof entry.key !== 'string') {\n      continue;\n    }\n    const labelKey = getAutoBackupLabelKey(entry);\n    const signature = getAutoBackupEntrySignature(container, entry);\n    const bucketKey = `${labelKey}__${signature}`;\n    const existing = duplicateBuckets.get(bucketKey);\n    if (existing) {\n      existing.push(index);\n    } else {\n      duplicateBuckets.set(bucketKey, [index]);\n    }\n  }\n\n  const removable = Array.from(duplicateBuckets.values())\n    .filter(indexes => Array.isArray(indexes) && indexes.length > 1)\n    .flatMap(indexes => indexes.slice(0, -1))\n    .sort((a, b) => a - b);\n\n  if (!removable.length) {\n    if (entries.length > limit) {\n      console.warn(\n        'Skipped trimming automatic backups because all remaining versions are unique.',\n        { limit, total: entries.length },\n      );\n    }\n    return;\n  }\n\n  for (let i = removable.length - 1; i >= 0 && entries.length > limit; i -= 1) {\n    const index = removable[i];\n    const entry = entries[index];\n    if (!entry || typeof entry.key !== 'string') {\n      continue;\n    }\n    if (isRenamedAutoBackupEntry(container, entry.key)) {\n      continue;\n    }\n    delete container[entry.key];\n    entries.splice(index, 1);\n    removedKeys.push(entry.key);\n  }\n\n  if (entries.length > limit) {\n    console.warn(\n      'Unable to trim automatic backups down to the configured limit without losing unique data.',\n      { limit, remaining: entries.length },\n    );\n  }\n}\n\nfunction enforceAutoBackupLimits(container) {\n  if (!isPlainObject(container)) {\n    return [];\n  }\n\n  const removed = [];\n\n  const autoBackups = collectAutoBackupEntries(container, STORAGE_AUTO_BACKUP_NAME_PREFIX);\n  removed.push(...removeDuplicateAutoBackupEntries(container, autoBackups));\n  if (autoBackups.length > MAX_AUTO_BACKUPS) {\n    pruneAutoBackupEntries(container, autoBackups, MAX_AUTO_BACKUPS, removed);\n  }\n\n  const deletionBackups = collectAutoBackupEntries(container, STORAGE_AUTO_BACKUP_DELETION_PREFIX);\n  removed.push(...removeDuplicateAutoBackupEntries(container, deletionBackups));\n  if (deletionBackups.length > MAX_DELETION_BACKUPS) {\n    pruneAutoBackupEntries(container, deletionBackups, MAX_DELETION_BACKUPS, removed);\n  }\n\n  if (removed.length > 0) {\n    console.warn(\n      `Removed ${removed.length} older automatic backup${removed.length > 1 ? 's' : ''} to stay within storage limits.`,\n      removed,\n    );\n  }\n\n  return removed;\n}\n\nfunction removeOldestAutoBackupEntry(container, options = {}) {\n  if (!isPlainObject(container)) {\n    return null;\n  }\n\n  const { force = false } = options;\n\n  const removeFromEntries = (entries, { respectRename = true } = {}) => {\n    if (!Array.isArray(entries) || entries.length === 0) {\n      return null;\n    }\n\n    for (let index = 0; index < entries.length; index += 1) {\n      const entry = entries[index];\n      if (!entry || typeof entry.key !== 'string') {\n        continue;\n      }\n\n      const hasValue = Object.prototype.hasOwnProperty.call(container, entry.key);\n      const value = hasValue ? container[entry.key] : undefined;\n\n      if (!hasValue || value === undefined || value === null || typeof value !== 'object') {\n        delete container[entry.key];\n        return entry.key;\n      }\n\n      if (respectRename && isRenamedAutoBackupEntry(container, entry.key)) {\n        continue;\n      }\n\n      delete container[entry.key];\n      return entry.key;\n    }\n\n    return null;\n  };\n\n  const autoBackups = collectAutoBackupEntries(container, STORAGE_AUTO_BACKUP_NAME_PREFIX);\n  const duplicateAutoBackupKey = removeSingleDuplicateAutoBackupEntry(container, autoBackups);\n  if (duplicateAutoBackupKey) {\n    return duplicateAutoBackupKey;\n  }\n\n  const deletionBackups = collectAutoBackupEntries(container, STORAGE_AUTO_BACKUP_DELETION_PREFIX);\n  const duplicateDeletionBackupKey = removeSingleDuplicateAutoBackupEntry(container, deletionBackups);\n  if (duplicateDeletionBackupKey) {\n    return duplicateDeletionBackupKey;\n  }\n\n  const oldestDeletionBackupKey = removeFromEntries(deletionBackups, { respectRename: false });\n  if (oldestDeletionBackupKey) {\n    return oldestDeletionBackupKey;\n  }\n  if (deletionBackups.length > 0) {\n    console.warn(\n      'Unable to free space by removing pre-deletion backups because all copies appear to be protected.',\n    );\n  }\n\n  const oldestAutoBackupKey = removeFromEntries(autoBackups, { respectRename: !force });\n  if (oldestAutoBackupKey) {\n    return oldestAutoBackupKey;\n  }\n  if (autoBackups.length > 0) {\n    console.warn(\n      'Unable to free space by removing automatic backups because the remaining copies were renamed or protected.',\n    );\n  }\n\n  return null;\n}\n\n\n\nfunction describeAutoGearBackupEntry(entry) {\n  if (!entry || typeof entry !== 'object') {\n    return '';\n  }\n\n  if (typeof entry.note === 'string') {\n    const trimmedNote = entry.note.trim();\n    if (trimmedNote) {\n      return trimmedNote;\n    }\n  }\n\n  if (typeof entry.createdAt === 'string') {\n    const trimmedTimestamp = entry.createdAt.trim();\n    if (trimmedTimestamp) {\n      return trimmedTimestamp;\n    }\n  }\n\n  if (typeof entry.id === 'string') {\n    return entry.id;\n  }\n\n  return '';\n}\n\nfunction removeOldestAutoGearBackupEntry(backups) {\n  if (!Array.isArray(backups) || backups.length === 0) {\n    return null;\n  }\n\n  const removeAt = (index) => {\n    const [removed] = backups.splice(index, 1);\n    return {\n      removed,\n      label: describeAutoGearBackupEntry(removed),\n    };\n  };\n\n  for (let index = backups.length - 1; index >= 0; index -= 1) {\n    const entry = backups[index];\n    if (!entry || typeof entry !== 'object') {\n      return removeAt(index);\n    }\n    if (!Array.isArray(entry.rules)) {\n      return removeAt(index);\n    }\n  }\n\n  return removeAt(backups.length - 1);\n}\n\nfunction cleanupAutoGearBackupMigrationCopies(storage) {\n  if (!storage || typeof storage.getItem !== 'function' || typeof storage.removeItem !== 'function') {\n    return false;\n  }\n\n  const migrationBackupKey = `${AUTO_GEAR_BACKUPS_STORAGE_KEY}${STORAGE_MIGRATION_BACKUP_SUFFIX}`;\n  const removedKeys = [];\n\n  try {\n    const existing = storage.getItem(migrationBackupKey);\n    if (existing !== null && existing !== undefined) {\n      storage.removeItem(migrationBackupKey);\n      removedKeys.push(migrationBackupKey);\n    }\n  } catch (error) {\n    console.warn(\n      'Unable to inspect automatic gear backup migration snapshot while recovering storage quota.',\n      error,\n    );\n  }\n\n  try {\n    const pruned = pruneMigrationBackupEntriesForCleanup(storage, migrationBackupKey);\n    if (Array.isArray(pruned) && pruned.length > 0) {\n      removedKeys.push(...pruned);\n    }\n  } catch (error) {\n    console.warn('Unable to prune migration backups while recovering storage for automatic gear backups.', error);\n  }\n\n  if (removedKeys.length > 0) {\n    console.warn(\n      `Removed ${removedKeys.length} migration backup${removedKeys.length > 1 ? 's' : ''} while freeing storage for automatic gear backups.`,\n      removedKeys,\n    );\n    return true;\n  }\n\n  return false;\n}\n\nfunction clearCachedPlannerDataForAutoGearBackups() {\n  if (typeof clearUiCacheStorageEntries !== 'function') {\n    return false;\n  }\n\n  try {\n    clearUiCacheStorageEntries();\n    console.warn(\n      'Cleared cached planner data to free up storage space before saving automatic gear backups.',\n    );\n    return true;\n  } catch (error) {\n    console.warn(\n      'Unable to clear cached planner data while recovering storage for automatic gear backups.',\n      error,\n    );\n  }\n\n  return false;\n}\n\nfunction shouldDisplayStorageAlert(reason) {\n  if (!reason) {\n    return true;\n  }\n\n  if (reason === 'migration-read') {\n    if (typeof safeLocalStorageInfo !== 'undefined' && safeLocalStorageInfo) {\n      if (safeLocalStorageInfo.type && safeLocalStorageInfo.type !== 'memory') {\n        return false;\n      }\n    }\n  }\n\n  return true;\n}\n\nfunction alertStorageError(reason) {\n  if (!shouldDisplayStorageAlert(reason)) {\n    return;\n  }\n\n  if (GLOBAL_SCOPE && typeof GLOBAL_SCOPE[STORAGE_ALERT_FLAG_NAME] === 'boolean') {\n    storageErrorAlertShown = GLOBAL_SCOPE[STORAGE_ALERT_FLAG_NAME];\n  }\n\n  if (storageErrorAlertShown) {\n    return;\n  }\n\n  storageErrorAlertShown = true;\n  if (GLOBAL_SCOPE) {\n    GLOBAL_SCOPE[STORAGE_ALERT_FLAG_NAME] = true;\n  }\n\n  if (typeof window === 'undefined' || typeof window.alert !== 'function') return;\n  let msg = 'Storage error: Unable to access local data. Changes may not be saved.';\n  try {\n    if (typeof window !== 'undefined' && window.texts) {\n      const texts = window.texts;\n      const currentLang = window.currentLang || 'en';\n      const lang = texts[currentLang] ? currentLang : 'en';\n      msg = texts[lang]?.alertStorageError || msg;\n    }\n  } catch (err) {\n    void err;\n    // ignore and fall back to default\n  }\n  window.alert(msg);\n}\n\nfunction alertSessionFallback() {\n  if (sessionFallbackAlertShown) {\n    return;\n  }\n\n  sessionFallbackAlertShown = true;\n  if (GLOBAL_SCOPE) {\n    GLOBAL_SCOPE[SESSION_FALLBACK_ALERT_FLAG_NAME] = true;\n  }\n\n  if (typeof window === 'undefined' || typeof window.alert !== 'function') return;\n\n  let msg = 'Warning: Local storage is unavailable. Data will only persist for this browser tab.';\n  try {\n    if (typeof window !== 'undefined' && window.texts) {\n      const texts = window.texts;\n      const currentLang = window.currentLang || 'en';\n      const lang = texts[currentLang] ? currentLang : 'en';\n      msg = texts[lang]?.alertSessionFallback || msg;\n    }\n  } catch (err) {\n    void err;\n    // ignore and fall back to default\n  }\n\n  window.alert(msg);\n}\n\nfunction getWindowStorage(name) {\n  if (typeof window === 'undefined') {\n    return null;\n  }\n\n  try {\n    return window[name];\n  } catch (error) {\n    console.warn(`Unable to access ${name} during legacy migration`, error);\n    return null;\n  }\n}\n\nfunction collectUniqueStorages(storages) {\n  if (!Array.isArray(storages) || storages.length === 0) {\n    return [];\n  }\n\n  const unique = [];\n  const seen = new Set();\n\n  for (let i = 0; i < storages.length; i += 1) {\n    const storage = storages[i];\n    if (!storage || typeof storage.getItem !== 'function' || seen.has(storage)) {\n      continue;\n    }\n\n    seen.add(storage);\n    unique.push(storage);\n  }\n\n  return unique;\n}\n\nfunction migrateKeyBetweenStorages(source, target, legacyKey, modernKey, options = {}) {\n  if (!source || typeof source.getItem !== 'function') {\n    return false;\n  }\n\n  const { keepLegacy = false } = options;\n\n  let legacyValue;\n  try {\n    legacyValue = source.getItem(legacyKey);\n  } catch (error) {\n    console.warn(`Unable to read legacy storage key ${legacyKey}`, error);\n    alertStorageError('migration-read');\n    return false;\n  }\n\n  if (legacyValue === null || legacyValue === undefined) {\n    return false;\n  }\n\n  const destination = target && typeof target.setItem === 'function' ? target : source;\n\n  try {\n    const existing = destination.getItem(modernKey);\n    if (existing !== null && existing !== undefined) {\n      if (!keepLegacy && (source !== destination || legacyKey !== modernKey)) {\n        try {\n          source.removeItem(legacyKey);\n        } catch (removeError) {\n          console.warn(`Unable to remove legacy storage key ${legacyKey}`, removeError);\n        }\n      }\n      return false;\n    }\n  } catch (readError) {\n    console.warn(`Unable to inspect destination storage for ${modernKey}`, readError);\n  }\n\n  try {\n    destination.setItem(modernKey, legacyValue);\n  } catch (writeError) {\n    console.warn(`Unable to migrate legacy storage key ${legacyKey}`, writeError);\n    return false;\n  }\n\n  if (!keepLegacy) {\n    try {\n      source.removeItem(legacyKey);\n    } catch (removeError) {\n      console.warn(`Unable to remove legacy storage key ${legacyKey} after migration`, removeError);\n    }\n  }\n\n  return true;\n}\n\nfunction migrateKeyInStorages(storages, preferredTarget, legacyKey, modernKey, options) {\n  let migrated = false;\n  for (let i = 0; i < storages.length; i += 1) {\n    if (migrateKeyBetweenStorages(storages[i], preferredTarget, legacyKey, modernKey, options)) {\n      migrated = true;\n    }\n  }\n  return migrated;\n}\n\nfunction migrateLegacyStorageKeys() {\n  const safeStorage = getSafeLocalStorage();\n  const localStorages = collectUniqueStorages([\n    getWindowStorage('localStorage'),\n    safeStorage,\n  ]);\n  const sessionStorages = collectUniqueStorages([\n    getWindowStorage('sessionStorage'),\n    typeof sessionStorage !== 'undefined' ? sessionStorage : null,\n  ]);\n\n  const legacyPrefix = 'cinePowerPlanner_';\n\n  const mappings = [\n    { legacy: `${legacyPrefix}devices`, modern: DEVICE_STORAGE_KEY },\n    { legacy: `${legacyPrefix}setups`, modern: SETUP_STORAGE_KEY },\n    { legacy: `${legacyPrefix}session`, modern: SESSION_STATE_KEY, includeSession: true },\n    { legacy: `${legacyPrefix}feedback`, modern: FEEDBACK_STORAGE_KEY },\n    { legacy: `${legacyPrefix}project`, modern: PROJECT_STORAGE_KEY },\n    { legacy: `${legacyPrefix}projects`, modern: PROJECT_STORAGE_KEY },\n    { legacy: `${legacyPrefix}favorites`, modern: FAVORITES_STORAGE_KEY },\n    { legacy: `${legacyPrefix}ownGear`, modern: OWN_GEAR_STORAGE_KEY },\n    { legacy: `${legacyPrefix}schemaCache`, modern: DEVICE_SCHEMA_CACHE_KEY },\n    { legacy: `${legacyPrefix}autoGearRules`, modern: AUTO_GEAR_RULES_STORAGE_KEY },\n    { legacy: `${legacyPrefix}autoGearBackups`, modern: AUTO_GEAR_BACKUPS_STORAGE_KEY },\n    { legacy: `${legacyPrefix}autoGearSeeded`, modern: AUTO_GEAR_SEEDED_STORAGE_KEY },\n    { legacy: `${legacyPrefix}autoGearPresets`, modern: AUTO_GEAR_PRESETS_STORAGE_KEY },\n    { legacy: `${legacyPrefix}autoGearActivePreset`, modern: AUTO_GEAR_ACTIVE_PRESET_STORAGE_KEY },\n    { legacy: `${legacyPrefix}autoGearAutoPreset`, modern: AUTO_GEAR_AUTO_PRESET_STORAGE_KEY },\n    { legacy: `${legacyPrefix}autoGearShowBackups`, modern: AUTO_GEAR_BACKUP_VISIBILITY_STORAGE_KEY },\n    { legacy: `${legacyPrefix}autoGearBackupRetention`, modern: AUTO_GEAR_BACKUP_RETENTION_STORAGE_KEY },\n    { legacy: `${legacyPrefix}autoGearMonitorDefaults`, modern: AUTO_GEAR_MONITOR_DEFAULTS_STORAGE_KEY },\n    { legacy: `${legacyPrefix}customFonts`, modern: CUSTOM_FONT_STORAGE_KEY_DEFAULT, updateFontKey: true },\n  ];\n\n  mappings.forEach(({ legacy, modern, includeSession = false, updateFontKey = false }) => {\n    const migratedLocal = migrateKeyInStorages(localStorages, safeStorage, legacy, modern);\n    migrateKeyInStorages(\n      localStorages,\n      safeStorage,\n      `${legacy}${STORAGE_BACKUP_SUFFIX}`,\n      `${modern}${STORAGE_BACKUP_SUFFIX}`,\n    );\n\n    if (includeSession) {\n      migrateKeyInStorages(sessionStorages, null, legacy, modern);\n      migrateKeyInStorages(\n        sessionStorages,\n        null,\n        `${legacy}${STORAGE_BACKUP_SUFFIX}`,\n        `${modern}${STORAGE_BACKUP_SUFFIX}`,\n      );\n    }\n\n    if (updateFontKey && migratedLocal && GLOBAL_SCOPE) {\n      if (GLOBAL_SCOPE.CUSTOM_FONT_STORAGE_KEY === legacy) {\n        GLOBAL_SCOPE.CUSTOM_FONT_STORAGE_KEY = modern;\n      }\n      if (GLOBAL_SCOPE.CUSTOM_FONT_STORAGE_KEY_NAME === legacy) {\n        GLOBAL_SCOPE.CUSTOM_FONT_STORAGE_KEY_NAME = modern;\n      }\n    }\n  });\n}\n\nfunction applyLegacyStorageMigrations() {\n  migrateLegacyStorageKeys();\n}\n\n// Generic helpers for storage access\nfunction isSessionStorageInstance(storage) {\n  if (!storage || typeof storage.getItem !== 'function') {\n    return false;\n  }\n\n  if (\n    knownSessionStorages\n    && typeof knownSessionStorages.has === 'function'\n    && knownSessionStorages.has(storage)\n  ) {\n    return true;\n  }\n\n  if (\n    safeLocalStorageInfo\n    && safeLocalStorageInfo.type === 'session'\n    && safeLocalStorageInfo.storage === storage\n  ) {\n    registerKnownSessionStorage(storage);\n    return true;\n  }\n\n  const safeLocal = getSafeLocalStorage();\n  if (\n    safeLocal\n    && safeLocalStorageInfo\n    && safeLocalStorageInfo.type === 'session'\n    && safeLocal === storage\n  ) {\n    registerKnownSessionStorage(storage);\n    return true;\n  }\n\n  const scopes = [\n    GLOBAL_SCOPE,\n    GLOBAL_SCOPE && GLOBAL_SCOPE.__cineGlobal ? GLOBAL_SCOPE.__cineGlobal : null,\n    GLOBAL_SCOPE && GLOBAL_SCOPE.window ? GLOBAL_SCOPE.window : null,\n    typeof window !== 'undefined' ? window : null,\n    typeof self !== 'undefined' ? self : null,\n    typeof global !== 'undefined' ? global : null,\n  ];\n\n  for (let index = 0; index < scopes.length; index += 1) {\n    const candidate = resolveSessionStorageFromScope(scopes[index]);\n    if (candidate && candidate === storage) {\n      registerKnownSessionStorage(candidate);\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction loadJSONFromStorage(\n  storage,\n  key,\n  errorMessage,\n  defaultValue = null,\n  options = {},\n) {\n  if (!storage) return defaultValue;\n\n  const {\n    disableBackup = false,\n    backupKey,\n    validate,\n    restoreIfMissing = false,\n    alertOnFailure = null,\n    migrationBackupKey,\n  } = options || {};\n\n  const fallbackKey = typeof backupKey === 'string' && backupKey\n    ? backupKey\n    : `${key}${STORAGE_BACKUP_SUFFIX}`;\n  const useBackup = !disableBackup && fallbackKey && fallbackKey !== key;\n  const skipBackupRecovery = isFactoryResetActive() || (GLOBAL_SCOPE && GLOBAL_SCOPE.__cineJustFactoryReset);\n  const allowBackupRecovery = useBackup && !skipBackupRecovery;\n  const allowMigrationBackupRecovery = !skipBackupRecovery;\n\n  const migrationBackupCandidates = (() => {\n    const seen = new Set();\n    const candidates = [];\n\n    const pushCandidate = (candidate) => {\n      if (typeof candidate !== 'string' || !candidate || seen.has(candidate)) {\n        return;\n      }\n      seen.add(candidate);\n      candidates.push(candidate);\n    };\n\n    if (typeof migrationBackupKey === 'string' && migrationBackupKey) {\n      pushCandidate(migrationBackupKey);\n    }\n\n    const variants = getStorageKeyVariants(key);\n    for (let i = 0; i < variants.length; i += 1) {\n      pushCandidate(`${variants[i]}${STORAGE_MIGRATION_BACKUP_SUFFIX}`);\n    }\n\n    return candidates;\n  })();\n\n  const rawGetter = getRawStorageGetter(storage);\n  let rawStoredValue =\n    typeof rawGetter === 'function'\n      ? readRawStorageValue(storage, key, rawGetter)\n      : undefined;\n\n  let shouldAlert = false;\n\n  const parseRawValue = (raw, label) => {\n    if (raw === null || raw === undefined) {\n      return { ok: false, reason: 'missing' };\n    }\n    const normalizedRaw = typeof raw === 'string'\n      ? maybeDecompressStoredString(raw)\n      : raw;\n\n    if (\n      typeof raw === 'string'\n      && raw\n      && normalizedRaw === raw\n      && raw.includes(`\"${STORAGE_COMPRESSION_FLAG_KEY}\":true`)\n      && raw.includes(`\"namespace\":\"${STORAGE_COMPRESSION_NAMESPACE}`)\n    ) {\n      console.warn(\n        `${errorMessage} Compressed value could not be decoded${label ? ` (${label})` : ''}.`,\n      );\n      shouldAlert = true;\n      return { ok: false, reason: 'compressed' };\n    }\n    try {\n      const parsed = JSON.parse(normalizedRaw);\n      if (typeof validate === 'function' && !validate(parsed)) {\n        console.warn(`${errorMessage} Invalid data${label ? ` (${label})` : ''}.`);\n        shouldAlert = true;\n        return { ok: false, reason: 'invalid' };\n      }\n      return {\n        ok: true,\n        value: parsed,\n        raw,\n        normalizedRaw,\n      };\n    } catch (err) {\n      console.error(`${errorMessage}${label ? ` (${label})` : ''}`, err);\n      shouldAlert = true;\n      return { ok: false, reason: 'error' };\n    }\n  };\n\n  let primaryRaw = null;\n  try {\n    primaryRaw = storage.getItem(key);\n  } catch (err) {\n    console.error(`${errorMessage} (read)`, err);\n    downgradeSafeLocalStorageToMemory('read access', err, storage);\n    shouldAlert = true;\n  }\n\n  if (typeof rawStoredValue === 'undefined' && typeof rawGetter === 'function') {\n    rawStoredValue = readRawStorageValue(storage, key, rawGetter);\n  }\n\n  if (\n    (primaryRaw === null || primaryRaw === undefined)\n    && (rawStoredValue === null || rawStoredValue === undefined)\n  ) {\n    clearCachedStorageEntry(storage, key);\n  }\n\n  const cachedPrimary = tryGetCachedStorageValue(storage, key, primaryRaw, rawStoredValue);\n  if (cachedPrimary.hit) {\n    return cachedPrimary.value;\n  }\n\n  const primary = parseRawValue(primaryRaw, '');\n  if (primary.ok) {\n    const normalizedForCache = typeof primary.normalizedRaw === 'string' && primary.normalizedRaw\n      ? primary.normalizedRaw\n      : typeof primary.raw === 'string' && primary.raw\n        ? primary.raw\n        : null;\n    const rawForCache = typeof rawStoredValue === 'string' && rawStoredValue\n      ? rawStoredValue\n      : typeof primary.raw === 'string' && primary.raw\n        ? primary.raw\n        : null;\n    cacheStorageValue(storage, key, rawForCache, normalizedForCache, primary.value);\n    return primary.value;\n  }\n\n  const missingPrimary = !primary.ok && primary.reason === 'missing';\n\n  const attemptMigrationBackupRecovery = () => {\n    if (!migrationBackupCandidates.length) {\n      return { success: false, shouldAlert: false };\n    }\n\n    for (let i = 0; i < migrationBackupCandidates.length; i += 1) {\n      const candidateKey = migrationBackupCandidates[i];\n      let migrationRaw = null;\n      let migrationRawStored;\n\n      try {\n        migrationRaw = storage.getItem(candidateKey);\n      } catch (migrationReadError) {\n        console.error(`${errorMessage} (migration backup read)`, migrationReadError);\n        downgradeSafeLocalStorageToMemory('read access', migrationReadError, storage);\n        return { success: false, shouldAlert: true };\n      }\n\n      if (typeof rawGetter === 'function') {\n        migrationRawStored = readRawStorageValue(storage, candidateKey, rawGetter);\n      }\n\n      if (\n        (migrationRaw === null || migrationRaw === undefined)\n        && (migrationRawStored === null || migrationRawStored === undefined)\n      ) {\n        clearCachedStorageEntry(storage, candidateKey);\n        continue;\n      }\n\n      const rawSource = migrationRaw !== null && migrationRaw !== undefined\n        ? migrationRaw\n        : migrationRawStored;\n\n      const entry = { key: candidateKey, value: rawSource, type: 'migration-backup' };\n      const extracted = extractSnapshotStoredValue(entry);\n\n      if (typeof extracted === 'undefined') {\n        continue;\n      }\n\n      let candidateValue = extracted;\n      if (typeof candidateValue === 'string') {\n        const trimmed = candidateValue.trim();\n        if (trimmed) {\n          try {\n            candidateValue = JSON.parse(trimmed);\n          } catch (parseError) {\n            void parseError;\n          }\n        } else {\n          candidateValue = '';\n        }\n      }\n\n      if (typeof validate === 'function' && !validate(candidateValue)) {\n        console.warn(`Ignored migration backup for ${key} because it failed validation.`);\n        continue;\n      }\n\n      const migrationRawForCache = typeof migrationRawStored === 'string' && migrationRawStored\n        ? migrationRawStored\n        : typeof rawSource === 'string' && rawSource\n          ? rawSource\n          : null;\n      const normalizedMigrationRaw = typeof rawSource === 'string' && rawSource\n        ? rawSource\n        : typeof migrationRawStored === 'string' && migrationRawStored\n          ? migrationRawStored\n          : null;\n      cacheStorageValue(\n        storage,\n        candidateKey,\n        migrationRawForCache,\n        normalizedMigrationRaw,\n        candidateValue,\n      );\n\n      let serializedCandidate = null;\n      try {\n        serializedCandidate = JSON.stringify(candidateValue);\n      } catch (serializationError) {\n        console.warn(`Unable to serialize recovered migration backup for ${key}`, serializationError);\n        serializedCandidate = null;\n      }\n\n      let restoredRawValue = null;\n      let shouldEscalate = false;\n\n      if (serializedCandidate !== null) {\n        let payloadToStore = serializedCandidate;\n        const recompressed = typeof serializedCandidate === 'string'\n          ? createCompressedJsonStorageCandidate(serializedCandidate)\n          : null;\n        if (recompressed && typeof recompressed.serialized === 'string') {\n          payloadToStore = recompressed.serialized;\n        }\n\n        try {\n          storage.setItem(key, payloadToStore);\n          restoredRawValue = payloadToStore;\n        } catch (restoreError) {\n          console.warn(`Unable to restore primary copy for ${key} from migration backup`, restoreError);\n          downgradeSafeLocalStorageToMemory('write access', restoreError, storage);\n          shouldEscalate = true;\n        }\n      } else {\n        shouldEscalate = true;\n      }\n\n      if (restoredRawValue !== null) {\n        cacheStorageValue(storage, key, restoredRawValue, serializedCandidate, candidateValue);\n      } else if (serializedCandidate !== null) {\n        cacheStorageValue(storage, key, serializedCandidate, serializedCandidate, candidateValue);\n      } else {\n        cacheStorageValue(storage, key, null, null, candidateValue);\n      }\n\n      console.warn(\n        restoredRawValue !== null\n          ? `Recovered ${key} from migration backup copy.`\n          : `Recovered ${key} from migration backup copy but could not rewrite the primary entry.`,\n      );\n\n      // Remove the migration backup to prevent repeated recovery loops\n      try {\n        storage.removeItem(candidateKey);\n        clearCachedStorageEntry(storage, candidateKey);\n      } catch (removeError) {\n        console.warn(`Unable to remove migration backup ${candidateKey} after recovery`, removeError);\n      }\n\n      return { success: true, value: candidateValue, shouldAlert: shouldEscalate };\n    }\n\n    return { success: false, shouldAlert: false };\n  };\n\n  const shouldAttemptBackup =\n    allowBackupRecovery && (shouldAlert || restoreIfMissing || missingPrimary);\n\n  if (shouldAttemptBackup) {\n    let backupRaw = null;\n    try {\n      backupRaw = storage.getItem(fallbackKey);\n    } catch (err) {\n      console.error(`${errorMessage} (backup read)`, err);\n      downgradeSafeLocalStorageToMemory('read access', err, storage);\n      shouldAlert = true;\n    }\n\n    const backupRawStored = typeof rawGetter === 'function'\n      ? readRawStorageValue(storage, fallbackKey, rawGetter)\n      : undefined;\n    const backup = parseRawValue(backupRaw, 'backup');\n    if (backup.ok) {\n      if (shouldAlert || missingPrimary) {\n        console.warn(`Recovered ${key} from backup copy.`);\n      }\n      if (backup.raw !== null && backup.raw !== undefined) {\n        let restoredRawValue = null;\n        try {\n          if (typeof backup.raw === 'string') {\n            const recompressSource = typeof backup.normalizedRaw === 'string'\n              && backup.normalizedRaw\n              ? backup.normalizedRaw\n              : backup.raw;\n            const recompressed = createCompressedJsonStorageCandidate(recompressSource);\n            if (recompressed && typeof recompressed.serialized === 'string') {\n              storage.setItem(key, recompressed.serialized);\n              restoredRawValue = recompressed.serialized;\n            } else if (recompressSource !== backup.raw) {\n              storage.setItem(key, recompressSource);\n              restoredRawValue = recompressSource;\n            } else {\n              storage.setItem(key, backup.raw);\n              restoredRawValue = backup.raw;\n            }\n          } else {\n            storage.setItem(key, backup.raw);\n            restoredRawValue = typeof backup.raw === 'string' ? backup.raw : null;\n          }\n        } catch (restoreError) {\n          console.warn(`Unable to restore primary copy for ${key} from backup`, restoreError);\n          restoredRawValue = null;\n        }\n\n        const normalizedBackup = typeof backup.normalizedRaw === 'string' && backup.normalizedRaw\n          ? backup.normalizedRaw\n          : typeof backup.raw === 'string' && backup.raw\n            ? backup.raw\n            : null;\n        const fallbackRawForCache = typeof backupRawStored === 'string' && backupRawStored\n          ? backupRawStored\n          : typeof backup.raw === 'string' && backup.raw\n            ? backup.raw\n            : null;\n        cacheStorageValue(storage, fallbackKey, fallbackRawForCache, normalizedBackup, backup.value);\n        if (typeof restoredRawValue === 'string' && restoredRawValue) {\n          cacheStorageValue(storage, key, restoredRawValue, normalizedBackup, backup.value);\n        }\n        return backup.value;\n      }\n    }\n  }\n\n  const shouldAttemptMigrationBackup =\n    allowMigrationBackupRecovery\n    && migrationBackupCandidates.length > 0\n    && (missingPrimary || restoreIfMissing || shouldAlert);\n\n  if (shouldAttemptMigrationBackup) {\n    const migrationRecovery = attemptMigrationBackupRecovery();\n    if (migrationRecovery.success) {\n      if (migrationRecovery.shouldAlert) {\n        shouldAlert = true;\n      }\n\n      // Hard cleanup of migration key to ensure no loop\n      if (migrationBackupCandidates.length) {\n        const cleanupKey = migrationBackupCandidates[0].key;\n        try {\n          storage.removeItem(cleanupKey);\n          // Also force delete from internal fallback if present\n          if (storage[STORAGE_RAW_GET_ITEM_PROPERTY] && storage.removeItem) {\n            storage.removeItem(cleanupKey);\n          }\n        } catch (cleanupErr) {\n          console.warn('Post-migration cleanup error:', cleanupErr);\n        }\n      }\n\n      return migrationRecovery.value;\n    }\n    if (migrationRecovery.shouldAlert) {\n      shouldAlert = true;\n    }\n  }\n\n  if (shouldAlert) {\n    alertStorageError(alertOnFailure);\n  }\n\n  clearCachedStorageEntry(storage, key);\n  // Log why we are returning default\n  if (missingPrimary && !shouldAttemptBackup && !shouldAttemptMigrationBackup) {\n    console.debug(`[Storage] Returning default for ${key} (No primary, no backups found)`);\n  }\n  return defaultValue;\n}\n\nfunction saveJSONToStorage(\n  storage,\n  key,\n  value,\n  errorMessage,\n  options = {},\n) {\n  if (!storage) {\n    console.warn('DEBUG: saveJSONToStorage NO STORAGE');\n    return;\n  }\n  if (isFactoryResetActive()) {\n    console.warn('DEBUG: saveJSONToStorage RESET ACTIVE');\n    return;\n  }\n\n  const {\n    disableBackup = false,\n    backupKey,\n    onQuotaExceeded,\n    enableCompressionSweep = true,\n    disableCompression = false,\n    forceCompressionOnQuota = false,\n  } = options || {};\n  const fallbackKey = typeof backupKey === 'string' && backupKey\n    ? backupKey\n    : `${key}${STORAGE_BACKUP_SUFFIX}`;\n  const useBackup = !disableBackup && fallbackKey && fallbackKey !== key;\n  const sessionScopedStorage = isSessionStorageInstance(storage);\n  const compressionBlocked = sessionScopedStorage || Boolean(disableCompression);\n  const allowQuotaCompression =\n    sessionScopedStorage ? false : forceCompressionOnQuota === true;\n\n  const rawGetter = getRawStorageGetter(storage);\n  const loadRawValue = (targetKey) => readRawStorageValue(storage, targetKey, rawGetter);\n\n  let standardSerializedCache;\n  let standardSerializationComputed = false;\n  let compressionCandidate;\n  let useCompressedSerialization = false;\n  let compressionAttempted = false;\n  let compressionLogged = false;\n\n  const resetSerializationState = () => {\n    standardSerializedCache = undefined;\n    standardSerializationComputed = false;\n    compressionCandidate = undefined;\n    useCompressedSerialization = false;\n    compressionAttempted = false;\n    compressionLogged = false;\n  };\n\n  const computeStandardSerialized = () => {\n    if (standardSerializationComputed) {\n      return standardSerializedCache;\n    }\n    standardSerializationComputed = true;\n    try {\n      standardSerializedCache = JSON.stringify(value);\n    } catch (serializationError) {\n      standardSerializedCache = null;\n      console.error(errorMessage, serializationError);\n      alertStorageError();\n    }\n    return standardSerializedCache;\n  };\n\n  const computeCompressedSerialized = () => {\n    if (compressionCandidate !== undefined) {\n      return compressionCandidate && typeof compressionCandidate.serialized === 'string'\n        ? compressionCandidate.serialized\n        : null;\n    }\n\n    const baseline = computeStandardSerialized();\n    if (typeof baseline !== 'string' || !baseline) {\n      compressionCandidate = null;\n      return null;\n    }\n\n    const candidate = createCompressedJsonStorageCandidate(baseline);\n    if (!candidate || typeof candidate.serialized !== 'string') {\n      compressionCandidate = null;\n      return null;\n    }\n\n    compressionCandidate = candidate;\n    return candidate.serialized;\n  };\n\n  const getSerializedForAttempt = () => {\n    if (useCompressedSerialization) {\n      const compressed = computeCompressedSerialized();\n      if (typeof compressed === 'string') {\n        return compressed;\n      }\n      useCompressedSerialization = false;\n    }\n\n    const standard = computeStandardSerialized();\n    if (typeof standard === 'string') {\n      return standard;\n    }\n    return null;\n  };\n\n  const tryEnableCompression = ({ force = false } = {}) => {\n    const forcing = force && allowQuotaCompression;\n    if (compressionBlocked && !forcing) {\n      compressionAttempted = true;\n      return false;\n    }\n    if (useCompressedSerialization) {\n      return false;\n    }\n    if (compressionAttempted && !forcing) {\n      return false;\n    }\n    compressionAttempted = true;\n    const baseline = computeStandardSerialized();\n    if (typeof baseline !== 'string' || !baseline) {\n      return false;\n    }\n    const compressed = computeCompressedSerialized();\n    if (typeof compressed !== 'string' || !compressed) {\n      return false;\n    }\n    if (compressed.length >= baseline.length) {\n      return false;\n    }\n    useCompressedSerialization = true;\n    return true;\n  };\n\n  const logCompressionIfNeeded = () => {\n    if (!useCompressedSerialization || !compressionCandidate || compressionLogged) {\n      return;\n    }\n\n    const { originalLength, wrappedLength } = compressionCandidate;\n    if (\n      typeof originalLength === 'number'\n      && typeof wrappedLength === 'number'\n      && wrappedLength < originalLength\n    ) {\n      const savings = originalLength - wrappedLength;\n      const percent = originalLength > 0 ? Math.round((savings / originalLength) * 100) : 0;\n      const message = `Stored compressed value for ${key} to reduce storage usage by ${savings} characters (${percent}%).`;\n      logCompressionSavingsEvent('storage-value', key, message, savings, percent);\n    }\n\n    compressionLogged = true;\n  };\n\n  const maybeEnableProactiveCompression = () => {\n    if (compressionBlocked) {\n      compressionAttempted = true;\n      return;\n    }\n    if (useCompressedSerialization || compressionAttempted) {\n      return;\n    }\n\n    const baseline = computeStandardSerialized();\n    if (typeof baseline !== 'string' || !baseline) {\n      return;\n    }\n\n    if (baseline.length < STORAGE_PROACTIVE_COMPRESSION_MIN_LENGTH) {\n      return;\n    }\n\n    const compressed = computeCompressedSerialized();\n    if (typeof compressed !== 'string' || !compressed) {\n      return;\n    }\n\n    const savings = baseline.length - compressed.length;\n    if (savings < STORAGE_PROACTIVE_COMPRESSION_MIN_SAVINGS) {\n      return;\n    }\n\n    const ratio = baseline.length > 0 ? savings / baseline.length : 0;\n    if (ratio < STORAGE_PROACTIVE_COMPRESSION_MIN_RATIO) {\n      return;\n    }\n\n    const rawExisting = loadRawValue(key);\n    if (typeof rawExisting === 'string' && rawExisting === compressed) {\n      return;\n    }\n\n    useCompressedSerialization = true;\n    compressionAttempted = true;\n  };\n\n  let preservedBackupValue;\n  let hasPreservedBackup = false;\n  let removedBackupDuringRetry = false;\n  let quotaRecoverySteps = 0;\n  let quotaRecoveryFailed = false;\n  let compressionSweepAttempted = false;\n\n  maybeEnableProactiveCompression();\n\n  const registerQuotaRecoveryStep = () => {\n    quotaRecoverySteps += 1;\n    if (quotaRecoverySteps > MAX_QUOTA_RECOVERY_STEPS) {\n      quotaRecoveryFailed = true;\n      console.warn(`Exceeded maximum storage recovery attempts while saving ${key}.`);\n      return false;\n    }\n    return true;\n  };\n\n  const attemptStorageCleanup = (storage, options) => {\n    if (!storage || typeof storage.length !== 'number' || typeof storage.key !== 'function') {\n      return { success: false, freed: 0 };\n    }\n\n    const { skipKeys = [] } = options || {};\n    const skipSet = new Set(skipKeys);\n    if (ACTIVE_PROJECT_COMPRESSION_HOLD_ENABLED && ACTIVE_PROJECT_COMPRESSION_HOLD_KEY) {\n      skipSet.add(ACTIVE_PROJECT_COMPRESSION_HOLD_KEY);\n    }\n\n    const candidates = [];\n    const total = storage.length;\n\n    for (let i = 0; i < total; i += 1) {\n      let key;\n      try {\n        key = storage.key(i);\n      } catch {\n        continue;\n      }\n\n      if (!key || skipSet.has(key)) continue;\n\n      // Priority 1: Legacy migration backups (safest to delete)\n      if (key.endsWith('__legacyMigrationBackup')) {\n        candidates.push({ key, priority: 1, size: 0 }); // Size calc is expensive, do lazily if needed or just count on priority\n        continue;\n      }\n\n      // Priority 2: Standard backups (safe if we have primary)\n      if (key.endsWith('__backup')) {\n        candidates.push({ key, priority: 2, size: 0 });\n        continue;\n      }\n\n      // Priority 3: Caches (can be rebuilt)\n      if (key === DEVICE_SCHEMA_CACHE_KEY || key === LEGACY_SCHEMA_CACHE_KEY) {\n        candidates.push({ key, priority: 3, size: 0 });\n        continue;\n      }\n\n      // Priority 4: Auto-backup project shards (oldest first, safe to delete)\n      if (key.startsWith(PROJECT_SHARD_PREFIX) && key.includes('auto-backup-')) {\n        candidates.push({ key, priority: 4, size: 0 });\n        continue;\n      }\n    }\n\n    if (!candidates.length) {\n      return { success: false, freed: 0 };\n    }\n\n    // Sort by priority (ascending)\n    candidates.sort((a, b) => a.priority - b.priority);\n\n    let freed = 0;\n    let cleaned = 0;\n\n    for (let i = 0; i < candidates.length; i += 1) {\n      const candidate = candidates[i];\n      try {\n        const val = storage.getItem(candidate.key);\n        const size = val ? val.length : 0;\n        storage.removeItem(candidate.key);\n        clearCachedStorageEntry(storage, candidate.key);\n        freed += size;\n        cleaned += 1;\n        console.warn(`[Storage Cleanup] Removed ${candidate.key} to free ${size} chars.`);\n        // If we freed a significant amount, we might stop, but for now let's be aggressive\n        // to ensure the user's save succeeds.\n        if (freed > 500000) { // Arbitrary threshold to stop if we freed \"enough\"\n          break;\n        }\n      } catch (e) {\n        console.warn(`[Storage Cleanup] Failed to remove ${candidate.key}`, e);\n      }\n    }\n\n    return { success: cleaned > 0, freed };\n  };\n\n  const attemptHandleQuota = (error, context = {}) => {\n    if (!isQuotaExceededError(error)) {\n      return false;\n    }\n\n    if (typeof onQuotaExceeded === 'function') {\n      try {\n        if (\n          onQuotaExceeded(error, {\n            storage,\n            key,\n            value,\n            ...context,\n          }) === true\n        ) {\n          return true;\n        }\n      } catch (handlerError) {\n        const scope = context && context.isBackup ? ' (backup)' : '';\n        console.error(`Error while handling quota exceed for ${key}${scope}`, handlerError);\n      }\n    }\n\n    // First try compression\n    if (!compressionSweepAttempted && enableCompressionSweep !== false) {\n      compressionSweepAttempted = true;\n      const skipKeys = [key];\n      if (useBackup && typeof fallbackKey === 'string' && fallbackKey && fallbackKey !== key) {\n        skipKeys.push(fallbackKey);\n      }\n      if (context && typeof context.backupKey === 'string' && context.backupKey) {\n        skipKeys.push(context.backupKey);\n      }\n\n      const sweepResult = attemptStorageCompressionSweep(storage, { skipKeys });\n      if (sweepResult && sweepResult.success) {\n        return true;\n      }\n    }\n\n    // If compression failed or wasn't enough, try cleanup\n    const skipKeysCleanup = [key];\n    if (useBackup && typeof fallbackKey === 'string' && fallbackKey) {\n      skipKeysCleanup.push(fallbackKey);\n    }\n    const cleanupResult = attemptStorageCleanup(storage, { skipKeys: skipKeysCleanup });\n    return Boolean(cleanupResult && cleanupResult.success);\n  };\n\n  let attempts = 0;\n  while (attempts < MAX_SAVE_ATTEMPTS) {\n    attempts += 1;\n\n    const serialized = getSerializedForAttempt();\n    if (typeof serialized !== 'string') {\n      return;\n    }\n\n    const normalizedSerialized = computeStandardSerialized();\n    const normalizedString = typeof normalizedSerialized === 'string' && normalizedSerialized\n      ? normalizedSerialized\n      : null;\n\n    let skipPrimaryWrite = false;\n    let existingBackupValue;\n    let hasExistingBackup = false;\n    let existingBackupRaw = null;\n    let observedPrimaryRawValue = null;\n    let observedBackupRawValue = null;\n\n    if (typeof storage.getItem === 'function') {\n      try {\n        const existingValue = storage.getItem(key);\n        if (existingValue === serialized) {\n          skipPrimaryWrite = true;\n          observedPrimaryRawValue = serialized;\n        } else if (useCompressedSerialization) {\n          const existingRawValue = loadRawValue(key);\n          if (typeof existingRawValue === 'string') {\n            observedPrimaryRawValue = existingRawValue;\n            if (existingRawValue === serialized) {\n              skipPrimaryWrite = true;\n            }\n          }\n        } else if (typeof existingValue === 'string') {\n          observedPrimaryRawValue = existingValue;\n        }\n      } catch (inspectError) {\n        console.warn(`Unable to inspect existing value for ${key}`, inspectError);\n      }\n    }\n\n    if (useBackup && typeof storage.getItem === 'function') {\n      try {\n        existingBackupValue = storage.getItem(fallbackKey);\n        hasExistingBackup = typeof existingBackupValue === 'string';\n        if (hasExistingBackup && useCompressedSerialization) {\n          existingBackupRaw = loadRawValue(fallbackKey);\n          if (typeof existingBackupRaw === 'string') {\n            observedBackupRawValue = existingBackupRaw;\n          }\n        } else if (hasExistingBackup) {\n          observedBackupRawValue = existingBackupValue;\n        }\n      } catch (inspectError) {\n        console.warn(`Unable to inspect existing backup for ${key}`, inspectError);\n      }\n    }\n\n    if (!hasPreservedBackup && hasExistingBackup && typeof existingBackupValue === 'string') {\n      preservedBackupValue = existingBackupValue;\n      hasPreservedBackup = true;\n    }\n\n    const backupCandidates = (() => {\n      if (!useBackup) {\n        return [];\n      }\n\n      const candidates = [];\n\n      if (useCompressedSerialization) {\n        const standardSerialized = computeStandardSerialized();\n        if (typeof standardSerialized === 'string' && standardSerialized) {\n          candidates.push({ serialized: standardSerialized, compressed: false });\n        }\n\n        if (\n          typeof serialized === 'string'\n          && serialized\n          && (!candidates.length || candidates[candidates.length - 1].serialized !== serialized)\n        ) {\n          candidates.push({ serialized, compressed: true });\n        }\n      } else if (typeof serialized === 'string' && serialized) {\n        candidates.push({ serialized, compressed: false });\n      }\n\n      return candidates;\n    })();\n\n    const preferredBackupCandidate = backupCandidates.length ? backupCandidates[0] : null;\n\n    const backupMatchesPreferred = hasExistingBackup\n      && preferredBackupCandidate\n      && typeof preferredBackupCandidate.serialized === 'string'\n      && (\n        existingBackupValue === preferredBackupCandidate.serialized\n        || (\n          typeof existingBackupRaw === 'string'\n          && existingBackupRaw === preferredBackupCandidate.serialized\n        )\n      );\n\n    if (skipPrimaryWrite && (!useBackup || backupMatchesPreferred)) {\n      if (normalizedString) {\n        const rawForCacheUpdate = useCompressedSerialization\n          ? (typeof observedPrimaryRawValue === 'string' && observedPrimaryRawValue\n            ? observedPrimaryRawValue\n            : serialized)\n          : serialized;\n        cacheStorageValue(storage, key, rawForCacheUpdate, normalizedString, value);\n        if (useBackup && hasExistingBackup) {\n          const backupRawForCache = useCompressedSerialization\n            ? (typeof existingBackupRaw === 'string' && existingBackupRaw\n              ? existingBackupRaw\n              : observedBackupRawValue)\n            : observedBackupRawValue;\n          if (typeof backupRawForCache === 'string' && backupRawForCache) {\n            cacheStorageValue(storage, fallbackKey, backupRawForCache, normalizedString, value);\n          }\n        }\n      }\n      return;\n    }\n\n    if (!skipPrimaryWrite) {\n      try {\n        storage.setItem(key, serialized);\n        logCompressionIfNeeded();\n        if (normalizedString) {\n          cacheStorageValue(storage, key, serialized, normalizedString, value);\n        }\n      } catch (error) {\n        if (attemptHandleQuota(error)) {\n          resetSerializationState();\n          if (!registerQuotaRecoveryStep()) {\n            break;\n          }\n          if (attempts > 0) {\n            attempts -= 1;\n          }\n          continue;\n        }\n        if (!quotaRecoveryFailed && tryEnableCompression({ force: allowQuotaCompression })) {\n          if (!registerQuotaRecoveryStep()) {\n            break;\n          }\n          if (attempts > 0) {\n            attempts -= 1;\n          }\n          continue;\n        }\n        console.error(errorMessage, error);\n        downgradeSafeLocalStorageToMemory('write access', error, storage);\n        alertStorageError();\n        return;\n      }\n    }\n\n    if (!useBackup) {\n      return;\n    }\n\n    if (backupMatchesPreferred) {\n      if (normalizedString && hasExistingBackup) {\n        const backupRawForCache = useCompressedSerialization\n          ? (typeof existingBackupRaw === 'string' && existingBackupRaw\n            ? existingBackupRaw\n            : observedBackupRawValue)\n          : observedBackupRawValue;\n        if (typeof backupRawForCache === 'string' && backupRawForCache) {\n          cacheStorageValue(storage, fallbackKey, backupRawForCache, normalizedString, value);\n        }\n      }\n      return;\n    }\n\n    const attemptBackupWrite = () => {\n      const candidates = backupCandidates.length\n        ? backupCandidates\n        : [{ serialized, compressed: useCompressedSerialization }];\n\n      let backupError = null;\n      let backupRemovedForRetry = false;\n      let lastCandidate = null;\n\n      const tryStoreCandidate = (candidate) => {\n        try {\n          storage.setItem(fallbackKey, candidate.serialized);\n          if (candidate.compressed) {\n            logCompressionIfNeeded();\n          }\n          removedBackupDuringRetry = false;\n          return true;\n        } catch (error) {\n          backupError = error;\n          return false;\n        }\n      };\n\n      for (let index = 0; index < candidates.length; index += 1) {\n        const candidate = candidates[index];\n        lastCandidate = candidate;\n\n        if (tryStoreCandidate(candidate)) {\n          if (normalizedString) {\n            const normalizedForBackup = candidate.compressed && normalizedString\n              ? normalizedString\n              : candidate.serialized;\n            cacheStorageValue(storage, fallbackKey, candidate.serialized, normalizedForBackup, value);\n          }\n          return 'success';\n        }\n\n        if (!isQuotaExceededError(backupError)) {\n          break;\n        }\n\n        if (!backupRemovedForRetry && hasExistingBackup) {\n          try {\n            storage.removeItem(fallbackKey);\n            clearCachedStorageEntry(storage, fallbackKey);\n            backupRemovedForRetry = true;\n            removedBackupDuringRetry = true;\n            hasExistingBackup = false;\n            if (tryStoreCandidate(candidate)) {\n              if (normalizedString) {\n                const normalizedForBackup = candidate.compressed && normalizedString\n                  ? normalizedString\n                  : candidate.serialized;\n                cacheStorageValue(storage, fallbackKey, candidate.serialized, normalizedForBackup, value);\n              }\n              return 'success';\n            }\n          } catch (removeError) {\n            console.warn(`Unable to remove previous backup for ${key}`, removeError);\n          }\n        }\n      }\n\n      if (isQuotaExceededError(backupError)) {\n        if (attemptHandleQuota(backupError, {\n          serialized: lastCandidate && typeof lastCandidate.serialized === 'string'\n            ? lastCandidate.serialized\n            : serialized,\n          backupKey: fallbackKey,\n          isBackup: true,\n        })) {\n          resetSerializationState();\n          if (!registerQuotaRecoveryStep()) {\n            return 'failure';\n          }\n          return 'retry';\n        }\n\n        if (!quotaRecoveryFailed && tryEnableCompression({ force: allowQuotaCompression })) {\n          resetSerializationState();\n          if (!registerQuotaRecoveryStep()) {\n            return 'failure';\n          }\n          return 'retry';\n        }\n      }\n\n      if (backupRemovedForRetry && typeof existingBackupValue === 'string') {\n        try {\n          storage.setItem(fallbackKey, existingBackupValue);\n          if (normalizedString) {\n            cacheStorageValue(storage, fallbackKey, existingBackupValue, normalizedString, value);\n          }\n          removedBackupDuringRetry = false;\n        } catch (restoreError) {\n          console.warn(`Unable to restore previous backup for ${key}`, restoreError);\n        }\n      }\n\n      console.warn(`Unable to update backup copy for ${key}`, backupError);\n      alertStorageError();\n      return 'failure';\n    };\n\n    const backupResult = attemptBackupWrite();\n    if (backupResult === 'success') {\n      return;\n    }\n\n    if (backupResult === 'retry') {\n      if (attempts > 0) {\n        attempts -= 1;\n      }\n      continue;\n    }\n\n    if (quotaRecoveryFailed) {\n      break;\n    }\n\n    return;\n  }\n\n  if (hasPreservedBackup && removedBackupDuringRetry && typeof preservedBackupValue === 'string') {\n    try {\n      storage.setItem(fallbackKey, preservedBackupValue);\n      clearCachedStorageEntry(storage, fallbackKey);\n    } catch (restoreError) {\n      console.warn(`Unable to restore preserved backup for ${key}`, restoreError);\n    }\n  }\n\n  console.error(errorMessage, new Error('Unable to save value after multiple attempts.'));\n  alertStorageError();\n}\n\n// Generic helper to delete a key from storage with consistent error handling\nfunction deleteFromStorage(storage, key, errorMessage, options = {}) {\n  if (!storage) return;\n\n  // [Agent Refactor] Also clear from new repo (best effort, async)\n  if (storageRepo) {\n    storageRepo.removeItem(key).catch(() => { });\n  }\n\n  const { disableBackup = false, backupKey, disableMigrationCleanup = false } = options || {};\n  const fallbackKey = typeof backupKey === 'string' && backupKey\n    ? backupKey\n    : `${key}${STORAGE_BACKUP_SUFFIX}`;\n  const useBackup = !disableBackup && fallbackKey && fallbackKey !== key;\n\n  clearCachedStorageEntry(storage, key);\n  if (useBackup) {\n    clearCachedStorageEntry(storage, fallbackKey);\n  }\n\n  if (key === PROJECT_STORAGE_KEY) {\n    invalidateProjectReadCache();\n  }\n\n  try {\n    storage.removeItem(key);\n  } catch (e) {\n    console.error(errorMessage, e);\n    downgradeSafeLocalStorageToMemory('deletion', e, storage);\n    alertStorageError();\n  }\n\n  if (useBackup) {\n    try {\n      storage.removeItem(fallbackKey);\n    } catch (backupError) {\n      console.error(`${errorMessage} (backup)`, backupError);\n      downgradeSafeLocalStorageToMemory('deletion', backupError, storage);\n      alertStorageError();\n    }\n  }\n\n  if (!disableMigrationCleanup) {\n    const migrationBackupKey = `${key}${STORAGE_MIGRATION_BACKUP_SUFFIX}`;\n    try {\n      storage.removeItem(migrationBackupKey);\n    } catch (migrationError) {\n      console.warn(`Unable to remove migration backup for ${key}`, migrationError);\n    }\n  }\n}\n\nvar UI_CACHE_STORAGE_KEYS = [\n  DEVICE_SCHEMA_CACHE_KEY,\n  LEGACY_SCHEMA_CACHE_KEY,\n];\n\nvar UI_CACHE_STORAGE_ACCESS_WARNINGS = new Set();\n\nfunction collectUiCacheStorages() {\n  const candidates = [];\n  const seenScopes = new Set();\n\n  const pushCandidate = (candidate) => {\n    if (!candidate || typeof candidate.getItem !== 'function') {\n      return;\n    }\n    candidates.push(candidate);\n  };\n\n  const readProperty = (scope, property, label) => {\n    if (!scope || (typeof scope !== 'object' && typeof scope !== 'function')) {\n      return null;\n    }\n    try {\n      return scope[property];\n    } catch (error) {\n      if (label && !UI_CACHE_STORAGE_ACCESS_WARNINGS.has(label)) {\n        UI_CACHE_STORAGE_ACCESS_WARNINGS.add(label);\n        console.warn(`Unable to access ${label} while clearing UI caches`, error);\n      }\n      return null;\n    }\n  };\n\n  const inspectScope = (scope, label) => {\n    if (!scope || seenScopes.has(scope)) {\n      return;\n    }\n    seenScopes.add(scope);\n\n    pushCandidate(readProperty(scope, 'SAFE_LOCAL_STORAGE', `${label}.SAFE_LOCAL_STORAGE`));\n    pushCandidate(readProperty(scope, 'localStorage', `${label}.localStorage`));\n    pushCandidate(readProperty(scope, 'sessionStorage', `${label}.sessionStorage`));\n\n    const nested = readProperty(scope, '__cineGlobal', `${label}.__cineGlobal`);\n    if (nested && nested !== scope) {\n      inspectScope(nested, `${label}.__cineGlobal`);\n    }\n  };\n\n  inspectScope(typeof globalThis !== 'undefined' ? globalThis : null, 'globalThis');\n  inspectScope(typeof window !== 'undefined' ? window : null, 'window');\n  inspectScope(typeof self !== 'undefined' ? self : null, 'self');\n  inspectScope(typeof global !== 'undefined' ? global : null, 'global');\n  if (GLOBAL_SCOPE && GLOBAL_SCOPE.__cineGlobal) {\n    inspectScope(GLOBAL_SCOPE.__cineGlobal, '__cineGlobal');\n  }\n\n  if (safeLocalStorageInfo && safeLocalStorageInfo.storage) {\n    pushCandidate(safeLocalStorageInfo.storage);\n  }\n\n  if (typeof getSafeLocalStorage === 'function' && getSafeLocalStorage()) {\n    pushCandidate(getSafeLocalStorage());\n  }\n\n  try {\n    pushCandidate(getSafeLocalStorage());\n  } catch (error) {\n    if (!UI_CACHE_STORAGE_ACCESS_WARNINGS.has('getSafeLocalStorage')) {\n      UI_CACHE_STORAGE_ACCESS_WARNINGS.add('getSafeLocalStorage');\n      console.warn('Unable to access safe local storage while clearing UI caches', error);\n    }\n  }\n\n  pushCandidate(getWindowStorage('localStorage'));\n  pushCandidate(getWindowStorage('sessionStorage'));\n\n  if (typeof localStorage !== 'undefined') {\n    pushCandidate(localStorage);\n  }\n\n  if (typeof sessionStorage !== 'undefined') {\n    pushCandidate(sessionStorage);\n  }\n\n  return collectUniqueStorages(candidates);\n}\n\nfunction clearUiCacheStorageEntries() {\n  const storages = collectUiCacheStorages();\n  if (!storages.length) {\n    return;\n  }\n\n  UI_CACHE_STORAGE_KEYS.forEach((key) => {\n    // [Agent] Clean from new repo as well (async)\n    if (storageRepo) {\n      storageRepo.removeItem(key).catch(e => console.warn('Failed to clear UI cache from repo', e));\n    }\n\n    if (typeof key !== 'string' || !key) {\n      return;\n    }\n\n    storages.forEach((storage) => {\n      deleteFromStorage(storage, key, `Failed to clear UI cache entry ${key}`);\n    });\n  });\n}\n\nfunction loadFlagFromStorage(storage, key, errorMessage) {\n  if (!storage) return false;\n  try {\n    return storage.getItem(key) === '1';\n  } catch (e) {\n    console.error(errorMessage, e);\n    downgradeSafeLocalStorageToMemory('read access', e, storage);\n    alertStorageError();\n    return false;\n  }\n}\n\nfunction saveFlagToStorage(storage, key, value, errorMessage) {\n  if (!storage) return;\n  try {\n    if (value) {\n      storage.setItem(key, '1');\n    } else {\n      storage.removeItem(key);\n    }\n  } catch (e) {\n    console.error(errorMessage, e);\n    downgradeSafeLocalStorageToMemory('write access', e, storage);\n    alertStorageError();\n  }\n}\n\n// Attempt to load JSON from a primary storage. If missing, try a fallback\n// storage and migrate the data to the primary one. Useful for gradually moving\n// keys from sessionStorage to localStorage.\nfunction loadWithMigration(\n  primary,\n  fallback,\n  key,\n  primaryLoadMsg,\n  fallbackLoadMsg,\n  saveMsg,\n  deleteMsg,\n  loadOptions,\n) {\n  const value = loadJSONFromStorage(primary, key, primaryLoadMsg, null, loadOptions);\n  if (value !== null) return value;\n  if (!fallback) return null;\n  const fallbackOptions = {\n    ...(loadOptions || {}),\n    alertOnFailure: 'migration-read',\n  };\n  const migrated = loadJSONFromStorage(\n    fallback,\n    key,\n    fallbackLoadMsg,\n    null,\n    fallbackOptions,\n  );\n  if (migrated !== null) {\n    saveJSONToStorage(primary, key, migrated, saveMsg);\n    deleteFromStorage(fallback, key, deleteMsg);\n    return migrated;\n  }\n  return null;\n}\n\n// Generate a unique name by appending numeric suffixes if needed\n// Comparisons are case-insensitive and ignore surrounding whitespace.\n// Optionally accepts a set of normalized names to avoid recomputing the\n// normalised lookup on each call when generating many names in a loop.\nfunction generateUniqueName(base, usedNames, normalizedNames) {\n  const trimmedBase = base.trim();\n  let name = trimmedBase;\n  let suffix = 2;\n\n  const normalized = normalizedNames || new Set(\n    [...usedNames].map((n) => n.trim().toLowerCase()),\n  );\n  let candidate = trimmedBase.toLowerCase();\n  while (normalized.has(candidate)) {\n    name = `${trimmedBase} (${suffix++})`;\n    candidate = name.toLowerCase();\n  }\n  usedNames.add(name);\n  normalized.add(candidate);\n  return name;\n}\n\nfunction ensureImportedProjectBaseName(rawName) {\n  const trimmed = typeof rawName === \"string\" ? rawName.trim() : \"\";\n  if (!trimmed) {\n    return \"Project-imported\";\n  }\n\n  const importedMatch = trimmed.match(/^(.*?)-imported(?:-(\\d+))?$/i);\n  if (importedMatch) {\n    const prefix = typeof importedMatch[1] === \"string\"\n      ? importedMatch[1].trim()\n      : \"\";\n    return prefix ? `${prefix}-imported` : \"Project-imported\";\n  }\n\n  if (trimmed.toLowerCase().endsWith(\"-imported\")) {\n    return trimmed;\n  }\n\n  return `${trimmed}-imported`;\n}\n\nfunction resolveImportedProjectNamingContext(rawName) {\n  const trimmed = typeof rawName === \"string\" ? rawName.trim() : \"\";\n  const base = ensureImportedProjectBaseName(rawName);\n\n  if (!trimmed) {\n    return {\n      base,\n      initialCandidate: base,\n      suffixStart: 2,\n    };\n  }\n\n  const importedMatch = trimmed.match(/^(.*?)-imported(?:-(\\d+))?$/i);\n  const parsedSuffix = importedMatch && importedMatch[2]\n    ? Number(importedMatch[2])\n    : NaN;\n  const suffixStart = Number.isFinite(parsedSuffix) ? parsedSuffix + 1 : 2;\n\n  if (importedMatch) {\n    return {\n      base,\n      initialCandidate: trimmed,\n      suffixStart,\n    };\n  }\n\n  return {\n    base,\n    initialCandidate: base,\n    suffixStart: 2,\n  };\n}\n\nfunction generateImportedProjectName(baseName, usedNames, normalizedNames) {\n  const normalized = normalizedNames\n    || new Set(\n      [...usedNames]\n        .map((name) => (typeof name === \"string\" ? name.trim().toLowerCase() : \"\"))\n        .filter((name) => name),\n    );\n\n  const context = resolveImportedProjectNamingContext(baseName);\n  let candidate = typeof context.initialCandidate === \"string\"\n    ? context.initialCandidate.trim()\n    : \"\";\n\n  if (!candidate) {\n    candidate = context.base || \"Project-imported\";\n  }\n\n  let normalizedCandidate = candidate.trim().toLowerCase();\n  let suffix = context.suffixStart;\n  while (normalizedCandidate && normalized.has(normalizedCandidate)) {\n    const base = context.base || \"Project-imported\";\n    candidate = `${base}-${suffix++}`;\n    normalizedCandidate = candidate.trim().toLowerCase();\n  }\n\n  usedNames.add(candidate);\n  if (normalizedCandidate) {\n    normalized.add(normalizedCandidate);\n  }\n\n  return candidate;\n}\n\nfunction ensureUpdatedProjectBaseName(rawName) {\n  const trimmed = typeof rawName === \"string\" ? rawName.trim() : \"\";\n  if (!trimmed) {\n    return \"Project-updated\";\n  }\n  if (trimmed.toLowerCase().endsWith(\"-updated\")) {\n    return trimmed;\n  }\n  return `${trimmed}-updated`;\n}\n\nfunction generateUpdatedProjectName(baseName, usedNames, normalizedNames) {\n  const normalized = normalizedNames || new Set(\n    [...usedNames]\n      .map((name) => (typeof name === \"string\" ? name.trim().toLowerCase() : \"\"))\n      .filter((name) => name),\n  );\n  const base = ensureUpdatedProjectBaseName(baseName);\n  let candidate = base;\n  let suffix = 2;\n  let normalizedCandidate = candidate.trim().toLowerCase();\n  while (normalizedCandidate && normalized.has(normalizedCandidate)) {\n    candidate = `${base}-${suffix++}`;\n    normalizedCandidate = candidate.trim().toLowerCase();\n  }\n  return candidate;\n}\n\n// --- Session State Storage ---\n// Store the current session (unsaved setup) in localStorage so it survives\n// full app reloads.\nfunction collectStringValues(value) {\n  if (value === null || value === undefined) {\n    return [];\n  }\n  if (typeof value === 'string') {\n    const trimmed = value.trim();\n    return trimmed ? [trimmed] : [];\n  }\n  if (Array.isArray(value)) {\n    return value\n      .filter((item) => typeof item === 'string')\n      .map((item) => item.trim())\n      .filter((item) => item);\n  }\n  if (isPlainObject(value)) {\n    return Object.values(value)\n      .filter((item) => typeof item === 'string')\n      .map((item) => item.trim())\n      .filter((item) => item);\n  }\n  return [];\n}\n\nfunction arraysEqual(a, b) {\n  if (a === b) {\n    return true;\n  }\n  if (!Array.isArray(a) || !Array.isArray(b) || a.length !== b.length) {\n    return false;\n  }\n  for (let i = 0; i < a.length; i += 1) {\n    if (a[i] !== b[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction normalizeDiagramPositions(positions) {\n  if (!positions || typeof positions !== 'object') {\n    return {};\n  }\n  const normalized = {};\n  Object.keys(positions).forEach((key) => {\n    const value = positions[key];\n    if (!value || typeof value !== 'object') {\n      return;\n    }\n    const x = Number(value.x);\n    const y = Number(value.y);\n    if (!Number.isFinite(x) || !Number.isFinite(y)) {\n      return;\n    }\n    normalized[key] = { x, y };\n  });\n  return normalized;\n}\n\nfunction diagramPositionsEqual(a, b) {\n  const keysA = Object.keys(a || {});\n  const keysB = Object.keys(b || {});\n  if (keysA.length !== keysB.length) {\n    return false;\n  }\n  for (let i = 0; i < keysA.length; i += 1) {\n    const key = keysA[i];\n    if (!Object.prototype.hasOwnProperty.call(b || {}, key)) {\n      return false;\n    }\n    const valueA = a[key];\n    const valueB = b[key];\n    if (!valueA || typeof valueA !== 'object' || !valueB || typeof valueB !== 'object') {\n      return false;\n    }\n    if (Number(valueA.x) !== valueB.x || Number(valueA.y) !== valueB.y) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction normalizeSessionStatePayload(raw) {\n  if (!isPlainObject(raw)) {\n    return { state: null, changed: false };\n  }\n\n  const state = { ...raw };\n  let changed = false;\n\n  const normalizeStringField = (key) => {\n    if (!Object.prototype.hasOwnProperty.call(state, key)) {\n      return;\n    }\n    const value = state[key];\n    if (typeof value === 'string') {\n      const trimmed = value.trim();\n      if (trimmed !== value) {\n        state[key] = trimmed;\n        changed = true;\n      }\n      return;\n    }\n    if (value === null || value === undefined) {\n      state[key] = '';\n      changed = true;\n      return;\n    }\n    if (typeof value === 'number' || typeof value === 'boolean') {\n      state[key] = String(value);\n      changed = true;\n      return;\n    }\n    state[key] = '';\n    changed = true;\n  };\n\n  [\n    'setupName',\n    'setupSelect',\n    'camera',\n    'monitor',\n    'video',\n    'cage',\n    'distance',\n    'batteryPlate',\n    'battery',\n    'batteryHotswap',\n    'sliderBowl',\n    'easyrig',\n  ].forEach(normalizeStringField);\n\n  const mergeArrayField = (targetKey, legacyKeys = []) => {\n    const values = [];\n    const keys = [targetKey, ...legacyKeys];\n    let hadLegacyData = false;\n\n    keys.forEach((key) => {\n      if (Object.prototype.hasOwnProperty.call(state, key)) {\n        const collected = collectStringValues(state[key]);\n        if (key !== targetKey) {\n          hadLegacyData = true;\n        }\n        if (collected.length) {\n          values.push(...collected);\n        }\n      }\n    });\n\n    keys.slice(1).forEach((legacyKey) => {\n      if (Object.prototype.hasOwnProperty.call(state, legacyKey)) {\n        delete state[legacyKey];\n        changed = true;\n      }\n    });\n\n    const unique = [];\n    const seen = new Set();\n    values.forEach((val) => {\n      if (!seen.has(val)) {\n        seen.add(val);\n        unique.push(val);\n      }\n    });\n\n    const hasTargetKey = Object.prototype.hasOwnProperty.call(state, targetKey);\n    const existing = hasTargetKey && Array.isArray(state[targetKey])\n      ? state[targetKey].filter((item) => typeof item === 'string').map((item) => item.trim()).filter((item) => item)\n      : [];\n\n    if (!hasTargetKey && !hadLegacyData && unique.length === 0 && existing.length === 0) {\n      return;\n    }\n\n    if (!arraysEqual(existing, unique)) {\n      state[targetKey] = unique;\n      changed = true;\n    }\n  };\n\n  mergeArrayField('motors', ['motor', 'motorSelect']);\n  mergeArrayField('controllers', ['controller', 'controllerSelect']);\n\n  if (Object.prototype.hasOwnProperty.call(state, 'projectInfo') && !isPlainObject(state.projectInfo)) {\n    state.projectInfo = null;\n    changed = true;\n  }\n\n  if (Object.prototype.hasOwnProperty.call(state, 'autoGearHighlight')) {\n    const value = state.autoGearHighlight;\n    const normalized = value === true || value === 'true' || value === 1 || value === '1';\n    if (value !== normalized || typeof value !== 'boolean') {\n      state.autoGearHighlight = normalized;\n      changed = true;\n    }\n  }\n\n  if (Object.prototype.hasOwnProperty.call(state, 'diagramPositions')) {\n    const normalizedPositions = normalizeDiagramPositions(state.diagramPositions);\n    if (Object.keys(normalizedPositions).length === 0) {\n      delete state.diagramPositions;\n      changed = true;\n    } else if (!diagramPositionsEqual(state.diagramPositions, normalizedPositions)) {\n      state.diagramPositions = normalizedPositions;\n      changed = true;\n    }\n  }\n\n  const normalizedState = normalizeLegacyLongGopStructure(state);\n  if (normalizedState !== state) {\n    return { state: normalizedState, changed: true };\n  }\n\n  return { state, changed };\n}\n\nfunction loadSessionState() {\n  applyLegacyStorageMigrations();\n  const safeStorage = getSafeLocalStorage();\n  const raw = loadWithMigration(\n    safeStorage,\n    typeof sessionStorage !== 'undefined' ? sessionStorage : null,\n    SESSION_STATE_KEY,\n    \"Error loading session state from localStorage:\",\n    \"Error loading session state from sessionStorage:\",\n    \"Error saving session state to localStorage:\",\n    \"Error deleting session state from sessionStorage:\",\n    { validate: (value) => value === null || isPlainObject(value) },\n  );\n  if (raw === null) {\n    return null;\n  }\n\n  const { state, changed } = normalizeSessionStatePayload(raw);\n  if (!state) {\n    return null;\n  }\n\n  if (changed) {\n    createStorageMigrationBackup(safeStorage, SESSION_STATE_KEY, raw);\n    saveSessionState(state);\n  }\n\n  return state;\n}\n\nfunction saveSessionState(state, options = {}) {\n  const safeStorage = getSafeLocalStorage();\n  if (state === null || state === undefined) {\n    deleteFromStorage(\n      safeStorage,\n      SESSION_STATE_KEY,\n      \"Error deleting session state from localStorage:\",\n    );\n    return;\n  }\n\n  if (!isPlainObject(state)) {\n    console.warn('Ignoring invalid session state payload. Expected a plain object.');\n    return;\n  }\n\n  ensurePreWriteMigrationBackup(safeStorage, SESSION_STATE_KEY);\n  const normalizedState = normalizeLegacyLongGopStructure(state);\n  const normalizedOptions = isPlainObject(options) ? options : {};\n\n  // We default to disabling compression for session state to keep it human-readable\n  // and safer to edit manually if needed, BUT we must allow it if the user is\n  // running out of space.\n  const disableCompression = normalizedOptions.disableCompression !== false;\n\n  const saveOptions = {\n    ...normalizedOptions,\n    disableCompression,\n    forceCompressionOnQuota: true,\n    onQuotaExceeded: () => {\n      // If we hit a quota limit while saving the session, try to clear out\n      // old auto-backups or other non-essential data to make room.\n\n\n      // 1. Try clearing the oldest auto-gear backup first\n      if (typeof removeOldestAutoGearBackupEntry === 'function') {\n        // We need to load them first to find the oldest\n        const backups = loadAutoGearBackups();\n        if (removeOldestAutoGearBackupEntry(backups)) {\n          console.warn('Removed oldest automatic gear backup to free up space for session state.');\n          return true;\n        }\n      }\n\n      // 2. Try clearing cached planner data\n      if (typeof clearCachedPlannerDataForAutoGearBackups === 'function') {\n        if (clearCachedPlannerDataForAutoGearBackups()) {\n          console.warn('Cleared cached planner data to free up space for session state.');\n          return true;\n        }\n      }\n\n      return false;\n    },\n  };\n\n  saveJSONToStorage(\n    safeStorage,\n    SESSION_STATE_KEY,\n    normalizedState,\n    \"Error saving session state to localStorage:\",\n    saveOptions,\n  );\n}\n\n// --- Device Data Storage ---\nfunction normalizeDeviceDataPayload(rawData) {\n  if (!isPlainObject(rawData)) {\n    return { data: null, changed: false };\n  }\n\n  const data = { ...rawData };\n  let changed = false;\n\n  const ensureObject = (target, key) => {\n    if (!isPlainObject(target[key])) {\n      target[key] = {};\n      changed = true;\n    }\n    return target[key];\n  };\n\n  DEVICE_COLLECTION_KEYS.forEach((key) => {\n    ensureObject(data, key);\n  });\n\n  if (!isPlainObject(data.fiz)) {\n    data.fiz = {};\n    changed = true;\n  }\n  FIZ_COLLECTION_KEYS.forEach((key) => {\n    ensureObject(data.fiz, key);\n  });\n\n  if (!isPlainObject(data.accessories)) {\n    data.accessories = {};\n    changed = true;\n  }\n  ACCESSORY_COLLECTION_KEYS.forEach((key) => {\n    ensureObject(data.accessories, key);\n  });\n\n  if (!Array.isArray(data.filterOptions)) {\n    data.filterOptions = Array.isArray(rawData.filterOptions)\n      ? rawData.filterOptions.slice()\n      : [];\n    changed = true;\n  }\n\n  return { data, changed };\n}\n\nfunction loadDeviceData() {\n  applyLegacyStorageMigrations();\n  const safeStorage = getSafeLocalStorage();\n  const parsedData = loadJSONFromStorage(\n    safeStorage,\n    DEVICE_STORAGE_KEY,\n    \"Error loading device data from localStorage:\",\n    null,\n    { validate: (value) => value === null || isPlainObject(value) },\n  );\n  const { data, changed } = normalizeDeviceDataPayload(parsedData);\n  if (!data) {\n    return null;\n  }\n\n  if (changed) {\n    createStorageMigrationBackup(safeStorage, DEVICE_STORAGE_KEY, parsedData);\n    saveJSONToStorage(\n      safeStorage,\n      DEVICE_STORAGE_KEY,\n      data,\n      \"Error updating device data in localStorage during normalization:\",\n      {\n        disableCompression: true,\n        forceCompressionOnQuota: false,\n      },\n    );\n  }\n\n  return data;\n}\n\nfunction saveDeviceData(deviceData) {\n  const safeStorage = getSafeLocalStorage();\n  if (deviceData === null || deviceData === undefined) {\n    deleteFromStorage(\n      safeStorage,\n      DEVICE_STORAGE_KEY,\n      \"Error deleting device data from localStorage:\",\n    );\n    return;\n  }\n\n  if (!isPlainObject(deviceData)) {\n    console.warn('Ignoring invalid device data payload. Expected a plain object.');\n    return;\n  }\n\n  const { data: normalizedDeviceData } = normalizeDeviceDataPayload(deviceData);\n  const dataToPersist = normalizedDeviceData || deviceData;\n\n  ensurePreWriteMigrationBackup(safeStorage, DEVICE_STORAGE_KEY);\n  saveJSONToStorage(\n    safeStorage,\n    DEVICE_STORAGE_KEY,\n    dataToPersist,\n    \"Error saving device data to localStorage:\",\n    {\n      disableCompression: false,\n      forceCompressionOnQuota: true,\n    },\n  );\n}\n\n// --- Setup Data Storage ---\nfunction normalizeSetups(rawData) {\n  if (!rawData) {\n    return { data: {}, changed: false };\n  }\n\n  if (Array.isArray(rawData)) {\n    const obj = {};\n    const used = new Set();\n    const normalized = new Set();\n    for (let idx = 0; idx < rawData.length; idx += 1) {\n      const item = rawData[idx];\n      if (!isPlainObject(item)) {\n        continue;\n      }\n      const base = item.name || item.setupName || `Setup ${idx + 1}`;\n      const key = generateUniqueName(base, used, normalized);\n      obj[key] = item;\n    }\n    return { data: obj, changed: true };\n  }\n\n  if (!isPlainObject(rawData)) {\n    return { data: {}, changed: true };\n  }\n\n  const normalized = {};\n  let changed = false;\n  Object.keys(rawData).forEach((name) => {\n    const value = rawData[name];\n    if (isPlainObject(value)) {\n      const normalizedValue = normalizeLegacyLongGopStructure(value);\n      if (normalizedValue !== value) {\n        changed = true;\n      }\n      normalized[name] = normalizedValue;\n    } else {\n      changed = true;\n    }\n  });\n\n  if (!changed) {\n    return { data: rawData, changed: false };\n  }\n\n  return { data: normalized, changed: true };\n}\n\nfunction loadSetups() {\n  applyLegacyStorageMigrations();\n  const safeStorage = getSafeLocalStorage();\n  const parsedData = loadJSONFromStorage(\n    safeStorage,\n    SETUP_STORAGE_KEY,\n    \"Error loading setups from localStorage:\",\n    null,\n    {\n      validate: (value) =>\n        value === null || Array.isArray(value) || isPlainObject(value),\n    },\n  );\n  const { data: setups, changed } = normalizeSetups(parsedData);\n  if (changed) {\n    createStorageMigrationBackup(safeStorage, SETUP_STORAGE_KEY, parsedData);\n    saveJSONToStorage(\n      safeStorage,\n      SETUP_STORAGE_KEY,\n      setups,\n      \"Error updating setups in localStorage during normalization:\",\n    );\n  }\n\n  try {\n    return expandAutoBackupEntries(setups, {\n      isAutoBackupKey: (name) => typeof name === 'string'\n        && name.startsWith(STORAGE_AUTO_BACKUP_NAME_PREFIX),\n    });\n  } catch (error) {\n    console.warn('Failed to expand automatic backup entries while loading setups', error);\n    return cloneAutoBackupValue(setups);\n  }\n}\n\nfunction saveSetups(setups) {\n\n  const { data: normalizedSetups } = normalizeSetups(setups);\n  enforceAutoBackupLimits(normalizedSetups);\n  const serializedSetups = serializeAutoBackupEntries(normalizedSetups, {\n    isAutoBackupKey: (name) => typeof name === 'string'\n      && name.startsWith(STORAGE_AUTO_BACKUP_NAME_PREFIX),\n  });\n  ensureProjectEntriesUncompressed(serializedSetups);\n  const safeStorage = getSafeLocalStorage();\n  ensurePreWriteMigrationBackup(safeStorage, SETUP_STORAGE_KEY);\n  saveJSONToStorage(\n    safeStorage,\n    SETUP_STORAGE_KEY,\n    serializedSetups,\n    \"Error saving setups to localStorage:\",\n    {\n      disableCompression: false,\n      forceCompressionOnQuota: true,\n      onQuotaExceeded: () => {\n        const removedKey = removeOldestAutoBackupEntry(serializedSetups);\n        if (!removedKey) {\n          return false;\n        }\n        console.warn(\n          `Removed automatic backup \"${removedKey}\" to free up storage space before saving setups.`,\n        );\n        return true;\n      },\n    },\n  );\n}\n\nfunction updateSetups(callback) {\n  const setups = loadSetups();\n  const { result, changed = true } = callback(setups) || {};\n  if (changed) {\n    saveSetups(setups);\n  }\n  return result;\n}\n\nfunction saveSetup(name, setup) {\n  updateSetups((setups) => {\n    setups[name] = setup;\n    return { changed: true };\n  });\n}\n\nfunction loadSetup(name) {\n  const setups = loadSetups();\n  return setups[name];\n}\n\nfunction deleteSetup(name) {\n  updateSetups((setups) => {\n    if (Object.prototype.hasOwnProperty.call(setups, name)) {\n      delete setups[name];\n      return { changed: true };\n    }\n    return { changed: false };\n  });\n}\n\nfunction renameSetup(oldName, newName) {\n  return updateSetups((setups) => {\n    if (!Object.prototype.hasOwnProperty.call(setups, oldName)) {\n      return { result: null, changed: false };\n    }\n    const sanitized = newName.trim();\n    // Guard against empty or whitespace-only names. Renaming to such a value\n    // would create an empty key in the setups object. In that case simply keep\n    // the original name.\n    if (!sanitized) {\n      return { result: oldName, changed: false };\n    }\n    if (oldName.trim().toLowerCase() === sanitized.toLowerCase()) {\n      return { result: oldName, changed: false };\n    }\n    const used = new Set(Object.keys(setups));\n    used.delete(oldName);\n    const target = generateUniqueName(sanitized, used);\n    const movedValue = setups[oldName];\n    setups[target] = movedValue;\n    delete setups[oldName];\n    const wasAutoBackup = typeof oldName === 'string'\n      && oldName.startsWith(STORAGE_AUTO_BACKUP_NAME_PREFIX);\n    const targetIsAutoBackup = typeof target === 'string'\n      && target.startsWith(STORAGE_AUTO_BACKUP_NAME_PREFIX);\n    if (wasAutoBackup && targetIsAutoBackup) {\n      markAutoBackupValueAsRenamed(movedValue);\n    }\n    return { result: target, changed: true };\n  });\n}\n\n// --- Project Storage ---\nvar REQUIREMENT_FIELDS_KEEP_NEWLINES = new Set(['prepDays', 'shootingDays', 'returnDays', 'crew', 'productionCompany', 'productionCompanyAddress']);\n\nvar LEGACY_PROJECT_FIELD_LABELS = {\n  productionCompany: [\n    'Production Company',\n    'Produktionsfirma',\n    'Socit de production',\n    'Productora',\n    'Casa di produzione',\n  ],\n  productionCompanyAddress: [\n    'Production Company Address',\n    'Adresse der Produktionsfirma',\n    'Adresse de la socit de production',\n    'Direccin de la productora',\n    'Indirizzo della casa di produzione',\n  ],\n  productionCompanyStreet: [\n    'Street address',\n    'Strae und Hausnummer',\n    'Adresse',\n    'Direccin',\n    'Indirizzo',\n  ],\n  productionCompanyStreet2: [\n    'Address line 2',\n    'Adresszusatz',\n    \"Complment d'adresse\",\n    'Lnea 2 de direccin',\n    'Seconda linea indirizzo',\n  ],\n  productionCompanyCity: [\n    'City',\n    'Stadt',\n    'Ville',\n    'Ciudad',\n    'Citt',\n  ],\n  productionCompanyRegion: [\n    'State / Province / Region',\n    'Bundesland / Region',\n    'tat / Rgion / Dpartement',\n    'Estado / Provincia / Regin',\n    'Regione / Provincia / Stato',\n  ],\n  productionCompanyPostalCode: [\n    'Postal code',\n    'Postleitzahl',\n    'Code postal',\n    'Cdigo postal',\n    'CAP',\n  ],\n  productionCompanyCountry: [\n    'Country',\n    'Land',\n    'Pays',\n    'Pas',\n    'Paese',\n  ],\n  rentalHouse: ['Rental', 'Kameraverleih', 'Loueur', 'Noleggio', 'Verleih', 'Location', 'Rental House'],\n  crew: ['Crew', 'Team', 'quipe', 'Equipo', 'Troupe'],\n  prepDays: [\n    'Prep Days',\n    'Prep-Tage',\n    'Jours de prparation',\n    'Das de preparacin',\n    'Giorni di preparazione',\n  ],\n  shootingDays: [\n    'Shooting Days',\n    'Drehtage',\n    'Jours de tournage',\n    'Das de rodaje',\n    'Giorni di riprese',\n  ],\n  returnDays: [\n    'Return Days',\n    'Rckgabetage',\n    'Jours de restitution',\n    'Das de devolucin',\n    'Giorni di restituzione',\n  ],\n  deliveryResolution: [\n    'Delivery Resolution',\n    'Auslieferungsauflsung',\n    'Rsolution de livraison',\n    'Resolucin de entrega',\n    'Risoluzione di consegna',\n  ],\n  recordingResolution: [\n    'Recording Resolution',\n    'Aufnahmeauflsung',\n    'Rsolution denregistrement',\n    'Resolucin de grabacin',\n    'Risoluzione di registrazione',\n  ],\n  slowMotionRecordingResolution: [\n    'Slow Motion Recording Resolution',\n    'Zeitlupen-Aufnahmeauflsung',\n    'Rsolution denregistrement au ralenti',\n    'Resolucin de grabacin en cmara lenta',\n    'Risoluzione di registrazione slow motion',\n  ],\n  aspectRatio: [\n    'Aspect Ratio',\n    'Seitenverhltnis',\n    \"Format dimage\",\n    'Relacin de aspecto',\n    'Formato',\n  ],\n  codec: ['Codec', 'Codec', 'Codec', 'Cdec', 'Codec'],\n  baseFrameRate: [\n    'Base Frame Rate',\n    'Basis-Framerate',\n    'Cadence de base',\n    'Velocidad base',\n    'Frame rate base',\n  ],\n  slowMotionBaseFrameRate: [\n    'Slow Motion Base Frame Rate',\n    'Zeitlupen-Basis-Framerate',\n    'Cadence de base au ralenti',\n    'Velocidad base en cmara lenta',\n    'Frame rate base slow motion',\n  ],\n  recordingFrameRate: [\n    'Recording Frame Rate',\n    'Aufnahmebildrate',\n    'Cadence denregistrement',\n    'Velocidad de grabacin',\n    'Frame rate di registrazione',\n  ],\n  slowMotionRecordingFrameRate: [\n    'Slow Motion Recording Frame Rate',\n    'Zeitlupen-Aufnahmebildrate',\n    'Cadence denregistrement au ralenti',\n    'Velocidad de grabacin en cmara lenta',\n    'Frame rate di registrazione slow motion',\n  ],\n  sensorMode: [\n    'Sensor Mode',\n    'Sensormodus',\n    'Mode capteur',\n    'Modo de sensor',\n    'Modalit sensore',\n  ],\n  slowMotionSensorMode: [\n    'Slow Motion Sensor Mode',\n    'Zeitlupen-Sensormodus',\n    'Mode capteur au ralenti',\n    'Modo de sensor en cmara lenta',\n    'Modalit sensore slow motion',\n  ],\n  slowMotionAspectRatio: [\n    'Slow Motion Aspect Ratio',\n    'Zeitlupen-Seitenverhltnis',\n    \"Format dimage au ralenti\",\n    'Relacin de aspecto en cmara lenta',\n    'Formato slow motion',\n  ],\n  lenses: ['Lenses', 'Objektive', 'Optiques', 'pticas', 'Obiettivi'],\n  requiredScenarios: [\n    'Required Scenarios',\n    'Anforderungen',\n    'Scnarios requis',\n    'Escenarios requeridos',\n    'Scenari richiesti',\n  ],\n  cameraHandle: [\n    'Camera Handle',\n    'Kamera-Handgriff',\n    'Poigne camra',\n    'Empuadura de cmara',\n    'Maniglia camera',\n  ],\n  viewfinderExtension: [\n    'Viewfinder Extension',\n    'Sucher-Verlngerung',\n    'Extension viseur',\n    'Extensin de visor',\n    'Prolunga mirino',\n  ],\n  viewfinderEyeLeatherColor: [\n    'Viewfinder Eye Leather Color',\n    'Sucher-Augenmuschel-Farbe',\n    \"Couleur de lil du viseur\",\n    'Color del ocular del visor',\n    'Colore gomma mirino',\n  ],\n  mattebox: ['Mattebox', 'Matte-Box', 'Matte box', 'Matte box', 'Matte box'],\n  gimbal: [\n    'Gimbal',\n    'Gimbal-Stabilisator',\n    'Stabilisateur gimbal',\n    'Estabilizador gimbal',\n    'Stabilizzatore gimbal',\n  ],\n  videoDistribution: [\n    'Video Distribution',\n    'Videoverteilung',\n    'Distribution vido',\n    'Distribucin de vdeo',\n    'Distribuzione video',\n  ],\n  monitoringSupport: [\n    'Monitoring support',\n    'Monitoring-Support',\n    'Support de monitoring',\n    'Soporte de monitorizacin',\n    'Supporto monitoraggio',\n  ],\n  monitoringConfiguration: [\n    'Monitoring configuration',\n    'Monitoring-Konfiguration',\n    'Configuration de monitoring',\n    'Configuracin de monitorizacin',\n    'Configurazione monitoraggio',\n  ],\n  focusMonitor: [\n    'Focus Monitor',\n    'Fokusmonitor',\n    'Moniteur focus',\n    'Monitor de foco',\n    'Monitor fuoco',\n  ],\n  monitorUserButtons: [\n    'Onboard Monitor User Buttons',\n    'Onboard-Monitor-Buttons',\n    'Boutons personnaliss du moniteur',\n    'Botones de usuario del monitor integrado',\n    'Tasti monitor onboard',\n  ],\n  cameraUserButtons: [\n    'Camera User Buttons',\n    'Kamera-Buttons',\n    'Boutons personnaliss camra',\n    'Botones de usuario de la cmara',\n    'Tasti camera',\n  ],\n  viewfinderUserButtons: [\n    'Viewfinder User Buttons',\n    'Sucher-Buttons',\n    'Boutons personnaliss viseur',\n    'Botones de usuario del visor',\n    'Tasti mirino',\n  ],\n  tripodHeadBrand: [\n    'Tripod Head Brand',\n    'Kopfmarke',\n    'Marque de la tte',\n    'Marca de la cabeza',\n    'Marca della testa',\n  ],\n  tripodBowl: [\n    'Tripod Bowl',\n    'Schalentyp',\n    'Type de bol',\n    'Tipo de bowl',\n    'Tipo di bowl',\n  ],\n  tripodTypes: [\n    'Tripod Types',\n    'Stativtypen',\n    'Types de trpied',\n    'Tipos de trpode',\n    'Tipi di treppiede',\n  ],\n  tripodSpreader: [\n    'Tripod Spreader',\n    'Spreizer-Option',\n    'Type de spreader',\n    'Tipo de esparcidor',\n    'Tipo di spreader',\n  ],\n  sliderBowl: [\n    'Slider Bowl',\n    'Slider-Schale',\n    'Slider bowl',\n    'Bowl del slider',\n    'Slider bowl',\n  ],\n  easyrig: [\n    'Further Stabilisation',\n    'Weitere Stabilisierung',\n    'Stabilisation complmentaire',\n    'Estabilizacin adicional',\n    'Stabilizzazione aggiuntiva',\n  ],\n};\n\nvar PRODUCTION_COMPANY_FIELD_ORDER = [\n  'productionCompanyAddress',\n  'productionCompanyStreet',\n  'productionCompanyStreet2',\n  'productionCompanyCity',\n  'productionCompanyRegion',\n  'productionCompanyPostalCode',\n  'productionCompanyCountry',\n];\n\nfunction normalizeProjectFieldLabel(label) {\n  if (typeof label !== 'string') {\n    return '';\n  }\n  return label.trim().replace(/[:]\\s*$/, '').trim();\n}\n\nfunction getProductionCompanyLabelSets(projectLabels) {\n  var labelSets = {};\n  var textsObj = typeof window !== 'undefined' && window.texts ? window.texts : null;\n  var fallbackProjectLabels = (textsObj && textsObj.en && textsObj.en.projectFields) || {};\n  var allKeys = ['productionCompany'].concat(PRODUCTION_COMPANY_FIELD_ORDER);\n  allKeys.forEach(function (key) {\n    var set = new Set();\n    var addLabel = function (value) {\n      if (typeof value !== 'string') return;\n      var normalized = normalizeProjectFieldLabel(value);\n      if (normalized) {\n        set.add(normalized);\n      }\n    };\n    if (projectLabels && projectLabels[key]) {\n      addLabel(projectLabels[key]);\n    }\n    if (fallbackProjectLabels && fallbackProjectLabels[key]) {\n      addLabel(fallbackProjectLabels[key]);\n    }\n    var legacyLabels = LEGACY_PROJECT_FIELD_LABELS[key];\n    if (Array.isArray(legacyLabels)) {\n      legacyLabels.forEach(addLabel);\n    }\n    labelSets[key] = set;\n  });\n  return labelSets;\n}\n\nfunction expandCombinedProductionCompanyInfo(rawText, projectLabels, metadata) {\n  if (typeof rawText !== 'string') {\n    return null;\n  }\n  var normalizedText = rawText\n    .replace(/\\r\\n?/g, '\\n')\n    .split('\\n')\n    .map(function (segment) { return segment.trim(); })\n    .filter(function (segment) { return segment; });\n  if (!normalizedText.length) {\n    return null;\n  }\n  var labelSets = getProductionCompanyLabelSets(projectLabels);\n  var result = {};\n  var firstLine = normalizedText[0];\n  if (firstLine) {\n    result.productionCompany = firstLine;\n  }\n  var metadataLines = Array.isArray(metadata === null || metadata === void 0 ? void 0 : metadata.lines)\n    ? metadata.lines\n    : null;\n  if (metadataLines && metadataLines.length) {\n    var collectedFromMetadata = {};\n    metadataLines.forEach(function (entry) {\n      if (!entry || typeof entry.text !== 'string') return;\n      var text = entry.text.trim();\n      if (!text) return;\n      var fields = entry.fields;\n      if (typeof fields === 'string') {\n        fields = fields.split(/\\s+/);\n      }\n      if (!Array.isArray(fields) || !fields.length) return;\n      fields\n        .map(function (field) { return typeof field === 'string' ? field.trim() : ''; })\n        .filter(function (field) { return field && PRODUCTION_COMPANY_FIELD_ORDER.includes(field); })\n        .forEach(function (field) {\n          if (!collectedFromMetadata[field]) {\n            collectedFromMetadata[field] = [];\n          }\n          collectedFromMetadata[field].push(text);\n        });\n    });\n    if (Object.keys(collectedFromMetadata).length) {\n      if (collectedFromMetadata.productionCompanyAddress && collectedFromMetadata.productionCompanyAddress.length) {\n        result.productionCompanyAddress = collectedFromMetadata.productionCompanyAddress.join('\\n');\n      }\n      if (collectedFromMetadata.productionCompanyStreet && collectedFromMetadata.productionCompanyStreet.length) {\n        var streetParts = collectedFromMetadata.productionCompanyStreet;\n        result.productionCompanyStreet = streetParts[0];\n        if (streetParts.length > 1) {\n          var secondary = streetParts.slice(1).join('\\n');\n          if (secondary) {\n            result.productionCompanyStreet2 = secondary;\n          }\n        }\n      }\n      if (collectedFromMetadata.productionCompanyStreet2 && collectedFromMetadata.productionCompanyStreet2.length) {\n        var streetTwo = collectedFromMetadata.productionCompanyStreet2.join('\\n');\n        if (streetTwo) {\n          result.productionCompanyStreet2 = result.productionCompanyStreet2\n            ? result.productionCompanyStreet2 + '\\n' + streetTwo\n            : streetTwo;\n        }\n      }\n      var joinCollected = function (field) {\n        if (!collectedFromMetadata[field] || !collectedFromMetadata[field].length) return;\n        var combined = collectedFromMetadata[field].join(' ');\n        if (combined) {\n          result[field] = combined;\n        }\n      };\n      ['productionCompanyCity', 'productionCompanyRegion', 'productionCompanyPostalCode', 'productionCompanyCountry']\n        .forEach(joinCollected);\n      return result;\n    }\n  }\n  var collected = {};\n  var activeField = null;\n  normalizedText.slice(1).forEach(function (line) {\n    var normalizedLine = normalizeProjectFieldLabel(line);\n    var matchedField = null;\n    PRODUCTION_COMPANY_FIELD_ORDER.forEach(function (field) {\n      if (matchedField || !labelSets[field]) return;\n      if (labelSets[field].has(normalizedLine)) {\n        matchedField = field;\n      }\n    });\n    if (matchedField) {\n      activeField = matchedField;\n      if (!collected[activeField]) {\n        collected[activeField] = [];\n      }\n      return;\n    }\n    if (!activeField) {\n      if (result.productionCompany) {\n        result.productionCompany += '\\n' + line;\n      } else {\n        result.productionCompany = line;\n      }\n      return;\n    }\n    if (!collected[activeField]) {\n      collected[activeField] = [];\n    }\n    collected[activeField].push(line);\n  });\n\n  if (collected.productionCompanyAddress && collected.productionCompanyAddress.length) {\n    result.productionCompanyAddress = collected.productionCompanyAddress.join('\\n');\n  }\n  if (collected.productionCompanyStreet && collected.productionCompanyStreet.length) {\n    var streetLines = collected.productionCompanyStreet;\n    result.productionCompanyStreet = streetLines[0];\n    if (streetLines.length > 1) {\n      result.productionCompanyStreet2 = streetLines.slice(1).join('\\n');\n    }\n  }\n  if (collected.productionCompanyCity && collected.productionCompanyCity.length) {\n    result.productionCompanyCity = collected.productionCompanyCity.join(' ');\n  }\n  if (collected.productionCompanyRegion && collected.productionCompanyRegion.length) {\n    result.productionCompanyRegion = collected.productionCompanyRegion.join(' ');\n  }\n  if (collected.productionCompanyPostalCode && collected.productionCompanyPostalCode.length) {\n    result.productionCompanyPostalCode = collected.productionCompanyPostalCode.join(' ');\n  }\n  if (collected.productionCompanyCountry && collected.productionCompanyCountry.length) {\n    result.productionCompanyCountry = collected.productionCompanyCountry.join(' ');\n  }\n\n  return result;\n}\n\nvar LEGACY_PROJECT_LABEL_FIELD_MAP = (() => {\n  const map = new Map();\n  const normalize = (label) => {\n    if (typeof label !== 'string') return '';\n    return label\n      .normalize('NFD')\n      .replace(/[\\u0300-\\u036f]/g, '')\n      .replace(/[:]/g, '')\n      .replace(/[^a-zA-Z0-9]+/g, ' ')\n      .trim()\n      .toLowerCase();\n  };\n  Object.entries(LEGACY_PROJECT_FIELD_LABELS).forEach(([field, labels]) => {\n    labels.forEach((label) => {\n      const normalized = normalize(label);\n      if (normalized && !map.has(normalized)) {\n        map.set(normalized, field);\n      }\n    });\n  });\n  return map;\n})();\n\nvar HTML_ENTITY_MAP = {\n  amp: '&',\n  lt: '<',\n  gt: '>',\n  quot: '\"',\n  apos: \"'\",\n  nbsp: ' ',\n};\n\nfunction decodeHtmlEntities(value) {\n  if (typeof value !== 'string' || !value) {\n    return '';\n  }\n  return value.replace(/&(#x?[0-9a-fA-F]+|[a-zA-Z]+);/g, (match, entity) => {\n    if (!entity) return match;\n    if (entity[0] === '#') {\n      const code = entity[1] === 'x' || entity[1] === 'X'\n        ? parseInt(entity.slice(2), 16)\n        : parseInt(entity.slice(1), 10);\n      return Number.isFinite(code) ? String.fromCodePoint(code) : match;\n    }\n    const mapped = HTML_ENTITY_MAP[entity.toLowerCase()];\n    return mapped !== undefined ? mapped : match;\n  });\n}\n\nfunction stripHtmlTags(value) {\n  if (typeof value !== 'string') return '';\n  // Remove all HTML tags by repeatedly applying the regex until no tags remain.\n  let previous;\n  do {\n    previous = value;\n    value = value.replace(/<[^>]*>/g, '');\n  } while (value !== previous);\n  return value;\n}\n\nfunction normalizeRequirementValueFromHtml(rawHtml, fieldName) {\n  if (typeof rawHtml !== 'string') {\n    return '';\n  }\n  const normalizedBreaks = rawHtml\n    .replace(/<\\s*br\\s*\\/?\\s*>/gi, '\\n')\n    .replace(/<\\/(p|div|li|ul|ol)>/gi, '\\n')\n    .replace(/<li[^>]*>/gi, '');\n  const text = decodeHtmlEntities(stripHtmlTags(normalizedBreaks))\n    .replace(/\\r\\n/g, '\\n')\n    .replace(/\\r/g, '\\n');\n  const parts = text\n    .split('\\n')\n    .map((part) => part.replace(/\\s+/g, ' ').trim())\n    .filter((part) => part);\n  if (!parts.length) {\n    return '';\n  }\n  if (fieldName && REQUIREMENT_FIELDS_KEEP_NEWLINES.has(fieldName)) {\n    return parts.join('\\n');\n  }\n  return parts.join(', ');\n}\n\nfunction extractRequirementValueMetadata(rawHtml) {\n  if (typeof rawHtml !== 'string') {\n    return null;\n  }\n  const spanRegex = /<span([^>]*)>([\\s\\S]*?)<\\/span>/gi;\n  const lines = [];\n  let match;\n  while ((match = spanRegex.exec(rawHtml))) {\n    const attrs = match[1] || '';\n    if (!/class=[\"'][^\"']*req-sub-line[^\"']*[\"']/i.test(attrs)) {\n      continue;\n    }\n    const content = match[2] || '';\n    const text = decodeHtmlEntities(stripHtmlTags(content)).replace(/\\s+/g, ' ').trim();\n    if (!text) {\n      continue;\n    }\n    const fieldsAttrMatch = attrs.match(/data-fields=[\"']([^\"']+)[\"']/i);\n    const singleFieldMatch = fieldsAttrMatch\n      ? null\n      : attrs.match(/data-field=[\"']([^\"']+)[\"']/i);\n    const rawFields = fieldsAttrMatch ? fieldsAttrMatch[1] : singleFieldMatch ? singleFieldMatch[1] : '';\n    const fields = typeof rawFields === 'string'\n      ? rawFields.split(/\\s+/).map((field) => field.trim()).filter((field) => field)\n      : [];\n    lines.push({ text, fields });\n  }\n  return lines.length ? { lines } : null;\n}\n\nfunction mapLegacyRequirementLabel(labelText) {\n  if (typeof labelText !== 'string') {\n    return '';\n  }\n  const normalized = labelText\n    .normalize('NFD')\n    .replace(/[\\u0300-\\u036f]/g, '')\n    .replace(/[:]/g, '')\n    .replace(/[^a-zA-Z0-9]+/g, ' ')\n    .trim()\n    .toLowerCase();\n  if (!normalized) {\n    return '';\n  }\n  return LEGACY_PROJECT_LABEL_FIELD_MAP.get(normalized) || '';\n}\n\nfunction extractProjectInfoFromHtml(html) {\n  if (typeof html !== 'string') {\n    return null;\n  }\n  const trimmed = html.trim();\n  if (!trimmed) {\n    return null;\n  }\n  const info = {};\n  const gridOpenMatch = trimmed.match(/<div[^>]*class=[\"'][^\"']*requirements-grid[^\"']*[\"'][^>]*>/i);\n  const gridStartIndex = gridOpenMatch ? gridOpenMatch.index : -1;\n  if (gridStartIndex === -1) {\n    const headingMatch = trimmed.match(/<h2[^>]*>([\\s\\S]*?)<\\/h2>/i);\n    if (headingMatch) {\n      const title = decodeHtmlEntities(stripHtmlTags(headingMatch[1]));\n      const projectName = title.replace(/[\"']/g, '').trim();\n      if (projectName) {\n        info.projectName = projectName;\n      }\n    }\n    return Object.keys(info).length ? info : null;\n  }\n  const gridHtml = trimmed.slice(gridStartIndex);\n  const prefix = trimmed.slice(0, gridStartIndex);\n  const headingMatch = prefix.match(/<h2[^>]*>([\\s\\S]*?)<\\/h2>/i);\n  if (headingMatch) {\n    const title = decodeHtmlEntities(stripHtmlTags(headingMatch[1]));\n    const projectName = title.replace(/[\"']/g, '').trim();\n    if (projectName && !/gear list/i.test(projectName)) {\n      info.projectName = projectName;\n    }\n  }\n  const boxRegex = /<div[^>]*class=[\"'][^\"']*requirement-box[^\"']*[\"'][^>]*>[\\s\\S]*?<\\/div>/gi;\n  let match;\n  const textsObj = typeof window !== 'undefined' && window.texts ? window.texts : null;\n  const globalLang = typeof window !== 'undefined' && window.currentLang ? window.currentLang : null;\n  const lang = typeof globalLang === 'string' && textsObj && textsObj[globalLang] ? globalLang : 'en';\n  const projectLabels = textsObj && textsObj[lang] && textsObj[lang].projectFields\n    ? textsObj[lang].projectFields\n    : textsObj && textsObj.en && textsObj.en.projectFields\n      ? textsObj.en.projectFields\n      : {};\n  while ((match = boxRegex.exec(gridHtml))) {\n    const boxHtml = match[0];\n    const fieldMatch = boxHtml.match(/data-field=[\"']([^\"']+)[\"']/i);\n    const labelMatch = boxHtml.match(/<span[^>]*class=[\"'][^\"']*req-label[^\"']*[\"'][^>]*>([\\s\\S]*?)<\\/span>/i);\n    const valueMatch = boxHtml.match(/<span[^>]*class=[\"'][^\"']*req-value[^\"']*[\"'][^>]*>([\\s\\S]*)<\\/span\\s*>/i);\n    const rawField = fieldMatch ? fieldMatch[1].trim() : '';\n    const label = labelMatch ? decodeHtmlEntities(stripHtmlTags(labelMatch[1])) : '';\n    const fieldName = rawField || mapLegacyRequirementLabel(label);\n    if (!fieldName) {\n      continue;\n    }\n    const rawValue = valueMatch ? valueMatch[1] : '';\n    const normalizedValue = normalizeRequirementValueFromHtml(rawValue, fieldName);\n    if (!normalizedValue) {\n      continue;\n    }\n    let valueToStore = normalizedValue;\n    let metadata = null;\n    if (fieldName === 'productionCompany') {\n      metadata = extractRequirementValueMetadata(rawValue);\n      const expanded = expandCombinedProductionCompanyInfo(normalizedValue, projectLabels, metadata);\n      if (expanded && typeof expanded === 'object') {\n        if (expanded.productionCompany) {\n          valueToStore = expanded.productionCompany;\n        }\n        Object.entries(expanded).forEach(([expandedField, expandedValue]) => {\n          if (expandedField === 'productionCompany') {\n            return;\n          }\n          if (!Object.prototype.hasOwnProperty.call(info, expandedField)) {\n            info[expandedField] = expandedValue;\n          }\n        });\n      }\n    }\n    if (!Object.prototype.hasOwnProperty.call(info, fieldName)) {\n      info[fieldName] = valueToStore;\n    }\n  }\n  return Object.keys(info).length ? info : null;\n}\n\nfunction cloneProjectData(value) {\n  if (Array.isArray(value)) {\n    return value.map((item) => cloneProjectData(item));\n  }\n  if (isPlainObject(value)) {\n    const clone = {};\n    Object.entries(value).forEach(([key, val]) => {\n      clone[key] = cloneProjectData(val);\n    });\n    return clone;\n  }\n  return value;\n}\n\nfunction cloneProjectInfo(projectInfo) {\n  if (!isPlainObject(projectInfo)) {\n    return null;\n  }\n  try {\n    return STORAGE_DEEP_CLONE(projectInfo);\n  } catch (error) {\n    console.warn('Unable to serialize project info during normalization', error);\n    try {\n      return cloneProjectData(projectInfo);\n    } catch (fallbackError) {\n      console.warn('Unable to deep clone project info during normalization', fallbackError);\n      return { ...projectInfo };\n    }\n  }\n}\n\nfunction sanitizeImportedCrewEntries(entries) {\n  if (!Array.isArray(entries)) {\n    return [];\n  }\n  const sanitized = [];\n  entries.forEach((entry) => {\n    if (!isPlainObject(entry)) {\n      const normalized = sanitizeImportedValue(entry);\n      if (normalized !== null && normalized !== undefined) {\n        sanitized.push(normalized);\n      }\n      return;\n    }\n    const result = {};\n    const name = typeof entry.name === 'string' ? entry.name.trim() : '';\n    if (name) {\n      result.name = name;\n    }\n    const phone = typeof entry.phone === 'string' ? entry.phone.trim() : '';\n    if (phone) {\n      result.phone = phone;\n    }\n    const email = typeof entry.email === 'string' ? entry.email.trim() : '';\n    if (email) {\n      result.email = email;\n    }\n    const websiteValue =\n      typeof entry.website === 'string'\n        ? entry.website.trim()\n        : (typeof entry.url === 'string' ? entry.url.trim() : '');\n    const website = websiteValue;\n    if (website) {\n      result.website = website;\n    }\n    const note = typeof entry.text === 'string' ? entry.text.trim() : '';\n    if (note) {\n      result.text = note;\n    }\n    const role = typeof entry.role === 'string' ? entry.role.trim() : '';\n    if (role) {\n      result.role = role;\n    }\n    if (Object.keys(result).length) {\n      sanitized.push(result);\n    }\n  });\n  return sanitized;\n}\n\nfunction sanitizeImportedValue(value) {\n  if (value === null || value === undefined) {\n    return null;\n  }\n  if (typeof value === 'string') {\n    const trimmed = value.trim();\n    return trimmed ? trimmed : null;\n  }\n  if (typeof value === 'number') {\n    return Number.isNaN(value) ? null : value;\n  }\n  if (typeof value === 'boolean') {\n    return value ? true : null;\n  }\n  if (Array.isArray(value)) {\n    const sanitized = value\n      .map((item) => sanitizeImportedValue(item))\n      .filter((item) => item !== null && item !== undefined && !(typeof item === 'string' && !item));\n    return sanitized.length ? sanitized : null;\n  }\n  if (isPlainObject(value)) {\n    return sanitizeImportedProjectInfo(value);\n  }\n  return null;\n}\n\nfunction sanitizeImportedProjectInfo(info) {\n  if (!isPlainObject(info)) {\n    return null;\n  }\n  const normalized = {};\n  const fallbackLensNames = [];\n  const fallbackLensNameSet = new Set();\n  const addFallbackLensName = (name) => {\n    if (typeof name !== 'string') {\n      return;\n    }\n    const trimmed = name.trim();\n    if (!trimmed || fallbackLensNameSet.has(trimmed)) {\n      return;\n    }\n    fallbackLensNameSet.add(trimmed);\n    fallbackLensNames.push(trimmed);\n  };\n  const registerFallbackLensNames = (source, options = {}) => {\n    if (source === null || source === undefined) {\n      return;\n    }\n    if (options.fromSelections) {\n      const entries = Array.isArray(source) ? source : [source];\n      entries.forEach((entry) => {\n        if (isMapLike(entry)) {\n          const converted = convertMapLikeToObject(entry);\n          if (converted) {\n            registerFallbackLensNames(converted, { fromSelections: true });\n            return;\n          }\n        }\n        if (isPlainObject(entry)) {\n          const mapped = deriveLensSelectionsFromNameMap(entry);\n          if (mapped.length) {\n            mapped.forEach((selection) => {\n              if (selection && typeof selection.name === 'string') {\n                addFallbackLensName(selection.name);\n              }\n            });\n            return;\n          }\n        }\n        const candidate = normalizeProjectLensNameCandidate(entry);\n        if (candidate) {\n          addFallbackLensName(candidate);\n        }\n      });\n      return;\n    }\n    const names = extractLensNamesFromSource(source);\n    if (!names.length) {\n      return;\n    }\n    names.forEach((name) => {\n      addFallbackLensName(name);\n    });\n  };\n\n  registerFallbackLensNames(info.lenses);\n  if (Object.prototype.hasOwnProperty.call(info, 'lensSelections')) {\n    registerFallbackLensNames(info.lensSelections, { fromSelections: true });\n  }\n\n  Object.entries(info).forEach(([key, raw]) => {\n    if (raw === null || raw === undefined) {\n      return;\n    }\n    if (key === 'people') {\n      const crew = sanitizeImportedCrewEntries(raw);\n      if (crew.length) {\n        normalized.people = crew;\n      }\n      return;\n    }\n    if (key === 'lenses') {\n      const { names } = normalizeProjectLensNamesField(raw);\n      normalized.lenses = names.slice();\n      return;\n    }\n    if (key === 'lensSelections') {\n      const result = normalizeProjectLensSelectionsFromSources(raw, fallbackLensNames);\n      if (result.selections && result.selections.length) {\n        normalized.lensSelections = result.selections;\n      }\n      return;\n    }\n    const value = sanitizeImportedValue(raw);\n    if (value !== null && value !== undefined) {\n      normalized[key] = value;\n    }\n  });\n\n  if (!Object.prototype.hasOwnProperty.call(normalized, 'lenses') && fallbackLensNames.length) {\n    normalized.lenses = fallbackLensNames.slice();\n  }\n  if (\n    !Object.prototype.hasOwnProperty.call(normalized, 'lensSelections')\n    && fallbackLensNames.length\n  ) {\n    const derived = normalizeProjectLensSelectionsFromSources([], fallbackLensNames);\n    if (derived.selections && derived.selections.length) {\n      normalized.lensSelections = derived.selections;\n    }\n  }\n\n  if (!Object.keys(normalized).length) {\n    return null;\n  }\n\n  const normalizedWithLegacySupport = normalizeLegacyLongGopStructure(normalized);\n  return normalizedWithLegacySupport;\n}\n\nfunction cloneAutoGearRules(rules) {\n  if (!Array.isArray(rules) || !rules.length) {\n    return null;\n  }\n  try {\n    return STORAGE_DEEP_CLONE(rules);\n  } catch (error) {\n    console.warn('Unable to serialize automatic gear rules during normalization', error);\n    try {\n      return cloneProjectData(rules);\n    } catch (fallbackError) {\n      console.warn('Unable to deep clone automatic gear rules during normalization', fallbackError);\n      return rules.slice();\n    }\n  }\n}\n\nfunction cloneDiagramPositionsForStorage(positions) {\n  if (!isPlainObject(positions) || !Object.keys(positions).length) {\n    return {};\n  }\n  try {\n    return STORAGE_DEEP_CLONE(positions);\n  } catch (error) {\n    console.warn('Unable to serialize diagram positions during normalization', error);\n    try {\n      return cloneProjectData(positions);\n    } catch (fallbackError) {\n      console.warn('Unable to deep clone diagram positions during normalization', fallbackError);\n      return { ...positions };\n    }\n  }\n}\n\nvar PROJECT_FILTER_DEFAULT_SIZE = '4x5.65';\n\nfunction normalizeImportedFilterValues(raw) {\n  if (raw === null || raw === undefined) {\n    return [];\n  }\n\n  if (Array.isArray(raw)) {\n    const values = [];\n    raw.forEach((item) => {\n      if (item === null || item === undefined) {\n        return;\n      }\n      if (Array.isArray(item)) {\n        values.push(...normalizeImportedFilterValues(item));\n        return;\n      }\n      if (isMapLike(item)) {\n        const converted = convertMapLikeToObject(item);\n        if (converted) {\n          values.push(...normalizeImportedFilterValues(converted));\n          return;\n        }\n      }\n      if (typeof item === 'object') {\n        values.push(...normalizeImportedFilterValues(Object.values(item)));\n        return;\n      }\n      const normalized = String(item).trim();\n      if (normalized) {\n        values.push(normalized);\n      }\n    });\n    return values;\n  }\n\n  if (isMapLike(raw)) {\n    const converted = convertMapLikeToObject(raw);\n    if (converted) {\n      return normalizeImportedFilterValues(converted);\n    }\n  }\n\n  if (typeof raw === 'object') {\n    if (Object.prototype.hasOwnProperty.call(raw, 'values')) {\n      return normalizeImportedFilterValues(raw.values);\n    }\n    if (Object.prototype.hasOwnProperty.call(raw, 'selected')) {\n      return normalizeImportedFilterValues(raw.selected);\n    }\n    return normalizeImportedFilterValues(Object.values(raw));\n  }\n\n  if (typeof raw === 'string') {\n    const trimmed = raw.trim();\n    if (!trimmed || trimmed === '!') {\n      return [];\n    }\n    const parsed = tryParseJSONLike(trimmed);\n    if (parsed.success) {\n      return normalizeImportedFilterValues(parsed.parsed);\n    }\n    return trimmed\n      .split(/[|,]/)\n      .map((value) => value.trim())\n      .filter((value) => value);\n  }\n\n  const normalized = String(raw).trim();\n  return normalized ? [normalized] : [];\n}\n\nfunction normalizeImportedFilterEntry(entry, fallbackType = '') {\n  if (entry === null || entry === undefined) {\n    return null;\n  }\n\n  if (typeof entry === 'string') {\n    const trimmed = entry.trim();\n    if (!trimmed) {\n      return null;\n    }\n    const parsed = tryParseJSONLike(trimmed);\n    if (parsed.success) {\n      return normalizeImportedFilterEntry(parsed.parsed, fallbackType);\n    }\n    const parts = trimmed.split(':');\n    const typePart = parts.shift();\n    const type = typePart ? typePart.trim() : '';\n    if (!type) {\n      return null;\n    }\n    const sizePart = parts.shift();\n    const size = sizePart && sizePart.trim() ? sizePart.trim() : PROJECT_FILTER_DEFAULT_SIZE;\n    if (!parts.length) {\n      return { type, size, values: [], hasExplicitValues: false };\n    }\n    const rawValues = parts.join(':');\n    if (rawValues === '!') {\n      return { type, size, values: [], hasExplicitValues: true };\n    }\n    const values = normalizeImportedFilterValues(rawValues);\n    return {\n      type,\n      size,\n      values,\n      hasExplicitValues: true,\n    };\n  }\n\n  if (Array.isArray(entry)) {\n    if (!entry.length) {\n      return null;\n    }\n    if (entry.length === 1) {\n      return normalizeImportedFilterEntry(entry[0], fallbackType);\n    }\n    const [typeCandidate, sizeCandidate, valuesCandidate] = entry;\n    let type = typeof typeCandidate === 'string' ? typeCandidate.trim() : '';\n    if (!type && typeof fallbackType === 'string') {\n      type = fallbackType.trim();\n    }\n    if (!type) {\n      return null;\n    }\n    const size = typeof sizeCandidate === 'string' && sizeCandidate.trim()\n      ? sizeCandidate.trim()\n      : PROJECT_FILTER_DEFAULT_SIZE;\n    const hasExplicitValues = entry.length > 2;\n    const values = hasExplicitValues ? normalizeImportedFilterValues(valuesCandidate) : [];\n    return { type, size, values, hasExplicitValues };\n  }\n\n  if (isMapLike(entry)) {\n    const converted = convertMapLikeToObject(entry);\n    if (converted) {\n      return normalizeImportedFilterEntry(converted, fallbackType);\n    }\n  }\n\n  if (typeof entry === 'object') {\n    let type = '';\n    const typeKeys = ['type', 'filter', 'name', 'label'];\n    for (let i = 0; i < typeKeys.length; i += 1) {\n      const key = typeKeys[i];\n      if (typeof entry[key] === 'string') {\n        const candidate = entry[key].trim();\n        if (candidate) {\n          type = candidate;\n          break;\n        }\n      }\n    }\n    if (!type && typeof fallbackType === 'string' && fallbackType.trim()) {\n      type = fallbackType.trim();\n    }\n    if (!type) {\n      return null;\n    }\n\n    const sizeKeys = ['size', 'filterSize', 'format', 'dimension', 'dimensions', 'diameter'];\n    let size = '';\n    for (let i = 0; i < sizeKeys.length; i += 1) {\n      const key = sizeKeys[i];\n      if (typeof entry[key] === 'string') {\n        const candidate = entry[key].trim();\n        if (candidate) {\n          size = candidate;\n          break;\n        }\n      }\n    }\n    if (!size) {\n      size = PROJECT_FILTER_DEFAULT_SIZE;\n    }\n\n    const valueKeys = [\n      'values',\n      'value',\n      'strengths',\n      'strength',\n      'options',\n      'selected',\n      'selections',\n      'choices',\n    ];\n    let hasExplicitValues = false;\n    let values = [];\n    for (let i = 0; i < valueKeys.length; i += 1) {\n      const key = valueKeys[i];\n      if (Object.prototype.hasOwnProperty.call(entry, key)) {\n        hasExplicitValues = true;\n        values = normalizeImportedFilterValues(entry[key]);\n        break;\n      }\n    }\n\n    return { type, size, values, hasExplicitValues };\n  }\n\n  return null;\n}\n\nfunction serializeNormalizedFilterEntry(entry) {\n  if (!entry || !entry.type) {\n    return null;\n  }\n  const type = entry.type;\n  const size = entry.size && entry.size.trim() ? entry.size.trim() : PROJECT_FILTER_DEFAULT_SIZE;\n  let token = `${type}:${size}`;\n  const values = Array.isArray(entry.values)\n    ? Array.from(\n      new Set(\n        entry.values\n          .map((value) => (typeof value === 'string' ? value.trim() : String(value ?? '').trim()))\n          .filter((value) => value),\n      ),\n    )\n    : [];\n  if (entry.hasExplicitValues || values.length) {\n    token += values.length ? `:${values.join('|')}` : ':!';\n  }\n  return token;\n}\n\nfunction normalizeImportedFilterValue(value) {\n  if (value === undefined) {\n    return null;\n  }\n  if (value === null) {\n    return '';\n  }\n  if (typeof value === 'string') {\n    const trimmed = value.trim();\n    if (!trimmed) {\n      return '';\n    }\n    const parsed = tryParseJSONLike(trimmed);\n    if (parsed.success) {\n      return normalizeImportedFilterValue(parsed.parsed);\n    }\n    return trimmed;\n  }\n  if (Array.isArray(value)) {\n    const entries = value\n      .map((entry) => normalizeImportedFilterEntry(entry))\n      .filter(Boolean);\n    if (!entries.length) {\n      return '';\n    }\n    return entries\n      .map((entry) => serializeNormalizedFilterEntry(entry))\n      .filter(Boolean)\n      .join(',');\n  }\n  if (isMapLike(value)) {\n    const converted = convertMapLikeToObject(value);\n    if (converted) {\n      return normalizeImportedFilterValue(converted);\n    }\n  }\n  if (typeof value === 'object') {\n    const singleEntry = normalizeImportedFilterEntry(value);\n    if (singleEntry) {\n      const serialized = serializeNormalizedFilterEntry(singleEntry);\n      return serialized || '';\n    }\n    const entries = [];\n    Object.entries(value).forEach(([key, candidate]) => {\n      const normalized = normalizeImportedFilterEntry(candidate, key);\n      if (normalized) {\n        entries.push(normalized);\n      }\n    });\n    if (!entries.length) {\n      return '';\n    }\n    return entries\n      .map((entry) => serializeNormalizedFilterEntry(entry))\n      .filter(Boolean)\n      .join(',');\n  }\n  return String(value).trim();\n}\n\nfunction normalizeImportedProjectFilters(info) {\n  if (!isPlainObject(info)) {\n    return;\n  }\n\n  const normalizedFilter = normalizeImportedFilterValue(info.filter);\n  if (normalizedFilter !== null) {\n    if (normalizedFilter) {\n      info.filter = normalizedFilter;\n    } else {\n      delete info.filter;\n    }\n  } else {\n    const fallback = normalizeImportedFilterValue(info.filters);\n    if (fallback !== null) {\n      if (fallback) {\n        info.filter = fallback;\n      } else {\n        delete info.filter;\n      }\n    }\n  }\n\n  if (Object.prototype.hasOwnProperty.call(info, 'filters')) {\n    delete info.filters;\n  }\n}\n\nfunction cloneProjectGearSelectors(selectors) {\n  if (!isPlainObject(selectors)) {\n    return null;\n  }\n\n  const cloneSelectorValue = (value) => {\n    if (Array.isArray(value)) {\n      const result = value\n        .map((item) => cloneSelectorValue(item))\n        .filter((item) => item !== undefined);\n      return result;\n    }\n    if (isPlainObject(value)) {\n      const nested = {};\n      Object.entries(value).forEach(([key, nestedValue]) => {\n        if (typeof key !== 'string' || !key) {\n          return;\n        }\n        const clonedNestedValue = cloneSelectorValue(nestedValue);\n        if (clonedNestedValue !== undefined) {\n          nested[key] = clonedNestedValue;\n        }\n      });\n      return nested;\n    }\n    if (value === undefined || value === null) {\n      return '';\n    }\n    if (typeof value === 'string') {\n      return value;\n    }\n    if (typeof value === 'number' || typeof value === 'boolean') {\n      return String(value);\n    }\n    try {\n      return String(value);\n    } catch (stringifyError) {\n      void stringifyError;\n    }\n    return '';\n  };\n\n  const clone = {};\n  Object.entries(selectors).forEach(([id, value]) => {\n    if (typeof id !== 'string' || !id) {\n      return;\n    }\n    const clonedValue = cloneSelectorValue(value);\n    if (clonedValue !== undefined) {\n      clone[id] = clonedValue;\n    }\n  });\n  return Object.keys(clone).length ? clone : null;\n}\n\nfunction normalizeProjectPowerSelection(raw) {\n  if (raw == null) {\n    return null;\n  }\n  const normalizeString = (value) => {\n    if (typeof value === \"string\") {\n      return value.trim();\n    }\n    if (value === null || value === undefined) {\n      return \"\";\n    }\n    if (typeof value === \"number\" || typeof value === \"boolean\") {\n      return String(value);\n    }\n    return \"\";\n  };\n  if (!isPlainObject(raw)) {\n    return null;\n  }\n  const normalized = {\n    batteryPlate: normalizeString(raw.batteryPlate),\n    battery: normalizeString(raw.battery),\n    batteryHotswap: normalizeString(raw.batteryHotswap),\n  };\n  const hasValue = Object.keys(normalized).some((key) => normalized[key]);\n  return hasValue ? normalized : null;\n}\n\nfunction cloneProjectPowerSelection(selection) {\n  const normalized = normalizeProjectPowerSelection(selection);\n  if (!normalized) {\n    return null;\n  }\n  return {\n    batteryPlate: normalized.batteryPlate,\n    battery: normalized.battery,\n    batteryHotswap: normalized.batteryHotswap,\n  };\n}\n\nconst LEGACY_LENS_SELECTION_META_KEYS = new Set([\n  'name',\n  'lensname',\n  'label',\n  'title',\n  'text',\n  'lens',\n  'mount',\n  'mountlabel',\n  'mountname',\n  'mounts',\n  'note',\n  'notes',\n  'names',\n  'values',\n  'selection',\n  'legacyvalue',\n  'lensselections',\n  'selections',\n  'entries',\n  'items',\n  'options',\n  'meta',\n  'metadata',\n  'count',\n  'version',\n  'length',\n  'size',\n  'updated',\n  'created',\n  'createdat',\n  'timestamp',\n  'id',\n  'uuid',\n  'key',\n  'value',\n]);\n\nfunction isLikelyLensNameKey(key) {\n  if (typeof key !== 'string') {\n    return false;\n  }\n  const trimmed = key.trim();\n  if (!trimmed) {\n    return false;\n  }\n  if (/^[0-9]+$/u.test(trimmed)) {\n    return false;\n  }\n  const normalized = trimmed.toLowerCase();\n  if (normalized.startsWith('__proto__')) {\n    return false;\n  }\n  if (normalized === 'prototype' || normalized === 'constructor') {\n    return false;\n  }\n  if (LEGACY_LENS_SELECTION_META_KEYS.has(normalized)) {\n    return false;\n  }\n  return true;\n}\n\nfunction deriveLensNameKeysFromObject(value) {\n  if (!isPlainObject(value)) {\n    return [];\n  }\n  const keys = Object.keys(value);\n  const result = [];\n  keys.forEach((key) => {\n    if (!isLikelyLensNameKey(key)) {\n      return;\n    }\n    const trimmed = key.trim();\n    if (trimmed) {\n      result.push(trimmed);\n    }\n  });\n  return result;\n}\n\nfunction normalizeProjectLensNameCandidate(value) {\n  if (value === null || value === undefined) {\n    return '';\n  }\n\n  if (\n    typeof value === 'string'\n    || typeof value === 'number'\n    || typeof value === 'boolean'\n    || typeof value === 'bigint'\n  ) {\n    const stringValue = typeof value === 'string' ? value : String(value);\n    const trimmed = stringValue.trim();\n    return trimmed;\n  }\n\n  if (Array.isArray(value)) {\n    for (let index = 0; index < value.length; index += 1) {\n      const candidate = normalizeProjectLensNameCandidate(value[index]);\n      if (candidate) {\n        return candidate;\n      }\n    }\n    return '';\n  }\n\n  if (isMapLike(value)) {\n    const converted = convertMapLikeToObject(value);\n    if (converted) {\n      return normalizeProjectLensNameCandidate(converted);\n    }\n  }\n\n  if (isPlainObject(value)) {\n    const nameCandidates = [\n      value.name,\n      value.lensName,\n      value.label,\n      value.title,\n      value.text,\n      value.lens,\n    ];\n    for (let index = 0; index < nameCandidates.length; index += 1) {\n      const candidate = nameCandidates[index];\n      if (typeof candidate === 'string') {\n        const trimmed = candidate.trim();\n        if (trimmed) {\n          return trimmed;\n        }\n      }\n    }\n\n    const keyDerivedNames = deriveLensNameKeysFromObject(value);\n    if (keyDerivedNames.length) {\n      return keyDerivedNames[0];\n    }\n\n    if (Array.isArray(value.names) && value.names.length) {\n      const nestedName = normalizeProjectLensNameCandidate(value.names[0]);\n      if (nestedName) {\n        return nestedName;\n      }\n    }\n\n    if (Array.isArray(value.values) && value.values.length) {\n      const nestedValue = normalizeProjectLensNameCandidate(value.values[0]);\n      if (nestedValue) {\n        return nestedValue;\n      }\n    }\n\n    const nestedEntries = Object.values(value);\n    for (let index = 0; index < nestedEntries.length; index += 1) {\n      const nested = normalizeProjectLensNameCandidate(nestedEntries[index]);\n      if (nested) {\n        return nested;\n      }\n    }\n  }\n\n  return '';\n}\n\nfunction extractLensNamesFromSource(value) {\n  if (value === null || value === undefined) {\n    return [];\n  }\n\n  if (Array.isArray(value)) {\n    const names = [];\n    value.forEach((entry) => {\n      if (entry === null || entry === undefined) {\n        return;\n      }\n      if (typeof entry === 'string') {\n        const parsed = tryParseJSONLike(entry);\n        if (parsed.success) {\n          names.push(...extractLensNamesFromSource(parsed.parsed));\n          return;\n        }\n        const trimmed = entry.trim();\n        if (trimmed) {\n          names.push(trimmed);\n        }\n        return;\n      }\n      if (\n        typeof entry === 'number'\n        || typeof entry === 'boolean'\n        || typeof entry === 'bigint'\n      ) {\n        names.push(String(entry));\n        return;\n      }\n      const normalized = normalizeProjectLensNameCandidate(entry);\n      if (normalized) {\n        names.push(normalized);\n        return;\n      }\n      if (Array.isArray(entry)) {\n        names.push(...extractLensNamesFromSource(entry));\n        return;\n      }\n      if (isMapLike(entry)) {\n        const converted = convertMapLikeToObject(entry);\n        if (converted) {\n          names.push(...extractLensNamesFromSource(converted));\n        }\n        return;\n      }\n      if (isPlainObject(entry)) {\n        names.push(...extractLensNamesFromSource(Object.values(entry)));\n      }\n    });\n    return names;\n  }\n\n  if (\n    typeof value === 'number'\n    || typeof value === 'boolean'\n    || typeof value === 'bigint'\n  ) {\n    return [String(value)];\n  }\n\n  if (typeof value === 'string') {\n    const parsed = tryParseJSONLike(value);\n    if (parsed.success) {\n      return extractLensNamesFromSource(parsed.parsed);\n    }\n    return value\n      .split(/[\\n,;]/u)\n      .map((part) => part.trim())\n      .filter((part) => part);\n  }\n\n  if (isMapLike(value)) {\n    const converted = convertMapLikeToObject(value);\n    if (converted) {\n      return extractLensNamesFromSource(converted);\n    }\n  }\n\n  if (isPlainObject(value)) {\n    const keyNames = deriveLensNameKeysFromObject(value);\n    if (keyNames.length) {\n      return keyNames;\n    }\n    const direct = normalizeProjectLensNameCandidate(value);\n    if (direct) {\n      return [direct];\n    }\n    const collected = [];\n    if (Array.isArray(value.names)) {\n      collected.push(...extractLensNamesFromSource(value.names));\n    }\n    if (Array.isArray(value.values)) {\n      collected.push(...extractLensNamesFromSource(value.values));\n    }\n    if (!collected.length) {\n      collected.push(...extractLensNamesFromSource(Object.values(value)));\n    }\n    return collected;\n  }\n\n  return [];\n}\n\nfunction normalizeProjectLensNamesField(value) {\n  const names = extractLensNamesFromSource(value);\n  const isNormalized = Array.isArray(value)\n    && value.length === names.length\n    && value.every(\n      (entry, index) => typeof entry === 'string' && entry.trim() === names[index],\n    );\n  return { names, changed: !isNormalized };\n}\n\nfunction normalizeProjectLensSelectionEntry(entry) {\n  if (entry === null || entry === undefined) {\n    return { selection: null, changed: false };\n  }\n\n  if (\n    typeof entry === 'string'\n    || typeof entry === 'number'\n    || typeof entry === 'boolean'\n    || typeof entry === 'bigint'\n  ) {\n    const name = normalizeProjectLensNameCandidate(entry);\n    if (!name) {\n      return { selection: null, changed: true };\n    }\n    return { selection: { name, mount: '' }, changed: true };\n  }\n\n  if (isMapLike(entry)) {\n    const converted = convertMapLikeToObject(entry);\n    if (converted) {\n      return normalizeProjectLensSelectionEntry(converted);\n    }\n  }\n\n  if (Array.isArray(entry)) {\n    if (!entry.length) {\n      return { selection: null, changed: true };\n    }\n    const name = normalizeProjectLensNameCandidate(entry[0]);\n    if (!name) {\n      return { selection: null, changed: true };\n    }\n    const mountValue = entry.length > 1 ? entry[1] : '';\n    const mount = typeof mountValue === 'string' ? mountValue.trim() : '';\n    const normalized = { name };\n    normalized.mount = mount || '';\n    return { selection: normalized, changed: true };\n  }\n\n  if (isPlainObject(entry)) {\n    const normalized = { ...entry };\n    let changed = false;\n\n    const name = normalizeProjectLensNameCandidate(entry);\n    if (!name) {\n      return { selection: null, changed: true };\n    }\n    if (normalized.name !== name) {\n      normalized.name = name;\n      changed = true;\n    }\n    if (!Object.prototype.hasOwnProperty.call(normalized, 'name')) {\n      normalized.name = name;\n      changed = true;\n    }\n\n    const mountCandidates = [];\n    if (typeof entry.mount === 'string') {\n      mountCandidates.push(entry.mount);\n    }\n    if (typeof entry.mountLabel === 'string') {\n      mountCandidates.push(entry.mountLabel);\n    }\n    if (typeof entry.mountName === 'string') {\n      mountCandidates.push(entry.mountName);\n    }\n    if (Array.isArray(entry.mounts)) {\n      for (let index = 0; index < entry.mounts.length; index += 1) {\n        const candidate = entry.mounts[index];\n        if (typeof candidate === 'string' && candidate.trim()) {\n          mountCandidates.push(candidate);\n          break;\n        }\n      }\n    }\n\n    let mount = '';\n    for (let index = 0; index < mountCandidates.length; index += 1) {\n      const candidate = mountCandidates[index];\n      if (typeof candidate === 'string') {\n        const trimmed = candidate.trim();\n        if (trimmed) {\n          mount = trimmed;\n          break;\n        }\n      }\n    }\n\n    if (typeof normalized.mount === 'string') {\n      const trimmedMount = normalized.mount.trim();\n      if (trimmedMount !== normalized.mount) {\n        normalized.mount = trimmedMount;\n        changed = true;\n      }\n      if (!mount && trimmedMount) {\n        mount = trimmedMount;\n      }\n    }\n\n    if (!mount) {\n      mount = '';\n    }\n\n    if (normalized.mount !== mount) {\n      normalized.mount = mount;\n      changed = true;\n    }\n\n    if (!Object.prototype.hasOwnProperty.call(normalized, 'mount')) {\n      normalized.mount = mount;\n      changed = true;\n    }\n\n    return { selection: normalized, changed };\n  }\n\n  return { selection: null, changed: true };\n}\n\nfunction deriveLensSelectionsFromNameMap(source) {\n  if (!isPlainObject(source)) {\n    return [];\n  }\n\n  const directNameCandidates = [\n    source.name,\n    source.lensName,\n    source.label,\n    source.title,\n    source.text,\n    source.lens,\n  ];\n  for (let index = 0; index < directNameCandidates.length; index += 1) {\n    const candidate = directNameCandidates[index];\n    if (typeof candidate === 'string' && candidate.trim()) {\n      return [];\n    }\n  }\n\n  const derived = [];\n  Object.entries(source).forEach(([rawKey, rawValue]) => {\n    if (!isLikelyLensNameKey(rawKey)) {\n      return;\n    }\n    const name = rawKey.trim();\n    if (!name) {\n      return;\n    }\n\n    let value = rawValue;\n    if (isMapLike(value)) {\n      const converted = convertMapLikeToObject(value);\n      if (converted) {\n        value = converted;\n      }\n    }\n\n    if (isPlainObject(value)) {\n      const selection = { ...value };\n      selection.name = name;\n      let mount = '';\n      const mountFields = ['mount', 'mountLabel', 'mountName'];\n      for (let index = 0; index < mountFields.length; index += 1) {\n        const field = mountFields[index];\n        if (typeof selection[field] !== 'string') {\n          continue;\n        }\n        const candidate = selection[field].trim();\n        if (candidate && candidate.toLowerCase() !== name.toLowerCase()) {\n          mount = candidate;\n          break;\n        }\n      }\n      if (!mount && Array.isArray(selection.mounts)) {\n        const candidate = normalizeProjectLensNameCandidate(selection.mounts);\n        if (candidate && candidate.toLowerCase() !== name.toLowerCase()) {\n          mount = candidate;\n        }\n      }\n      selection.mount = typeof mount === 'string' ? mount : '';\n      derived.push(selection);\n      return;\n    }\n\n    if (Array.isArray(value)) {\n      const candidate = normalizeProjectLensNameCandidate(value);\n      const mount = candidate && candidate.toLowerCase() !== name.toLowerCase() ? candidate : '';\n      derived.push({ name, mount });\n      return;\n    }\n\n    if (\n      typeof value === 'string'\n      || typeof value === 'number'\n      || typeof value === 'boolean'\n      || typeof value === 'bigint'\n    ) {\n      const candidate = normalizeProjectLensNameCandidate(value);\n      const mount = candidate && candidate.toLowerCase() !== name.toLowerCase() ? candidate : '';\n      derived.push({ name, mount });\n      return;\n    }\n\n    if (value === null || value === undefined) {\n      derived.push({ name, mount: '' });\n      return;\n    }\n\n    const fallback = normalizeProjectLensNameCandidate(value);\n    const mount = fallback && fallback.toLowerCase() !== name.toLowerCase() ? fallback : '';\n    derived.push({ name, mount });\n  });\n  return derived;\n}\n\nfunction normalizeProjectLensSelectionsFromSources(sources, fallbackNames = []) {\n  const sourceList = Array.isArray(sources) ? sources : [sources];\n  const normalized = [];\n  const seenNames = new Set();\n  let changed = false;\n\n  const addSelection = (selection, entryChanged) => {\n    if (!selection || typeof selection !== 'object') {\n      if (entryChanged) {\n        changed = true;\n      }\n      return;\n    }\n\n    const clone = { ...selection };\n    const rawName = typeof clone.name === 'string' ? clone.name : '';\n    const name = rawName.trim();\n    if (!name) {\n      if (entryChanged) {\n        changed = true;\n      }\n      return;\n    }\n\n    if (clone.name !== name) {\n      clone.name = name;\n      entryChanged = true;\n    }\n\n    const rawMount = typeof clone.mount === 'string' ? clone.mount : '';\n    const mount = rawMount.trim();\n    if (clone.mount !== mount) {\n      clone.mount = mount;\n      entryChanged = true;\n    }\n    if (!Object.prototype.hasOwnProperty.call(clone, 'mount')) {\n      clone.mount = mount;\n      entryChanged = true;\n    }\n\n    if (Object.prototype.hasOwnProperty.call(clone, 'mountState')) {\n      const rawMountState = typeof clone.mountState === 'string' ? clone.mountState : '';\n      const mountState = rawMountState.trim();\n      if (clone.mountState !== mountState) {\n        clone.mountState = mountState;\n        entryChanged = true;\n      }\n      if (!mountState) {\n        delete clone.mountState;\n        entryChanged = true;\n      }\n    }\n\n    if (entryChanged) {\n      changed = true;\n    }\n\n    normalized.push(clone);\n    seenNames.add(name);\n  };\n\n  const processSourceValue = (source) => {\n    if (source === null || source === undefined) {\n      return;\n    }\n\n    if (typeof source === 'string') {\n      const parsed = tryParseJSONLike(source);\n      if (parsed.success) {\n        processSourceValue(parsed.parsed);\n        changed = true;\n        return;\n      }\n      const names = extractLensNamesFromSource(source);\n      if (names.length) {\n        names.forEach((name) => {\n          addSelection({ name, mount: '' }, true);\n        });\n      } else {\n        changed = true;\n      }\n      return;\n    }\n\n    if (\n      typeof source === 'number'\n      || typeof source === 'boolean'\n      || typeof source === 'bigint'\n    ) {\n      addSelection({ name: String(source), mount: '' }, true);\n      return;\n    }\n\n    if (Array.isArray(source)) {\n      if (\n        source.length\n        && source.length <= 2\n        && (\n          typeof source[0] === 'string'\n          || typeof source[0] === 'number'\n          || typeof source[0] === 'boolean'\n          || typeof source[0] === 'bigint'\n        )\n      ) {\n        const { selection, changed: entryChanged } = normalizeProjectLensSelectionEntry(source);\n        if (selection) {\n          addSelection(selection, entryChanged);\n          return;\n        }\n      }\n      source.forEach((entry) => {\n        const { selection, changed: entryChanged } = normalizeProjectLensSelectionEntry(entry);\n        if (selection) {\n          addSelection(selection, entryChanged);\n        } else if (entryChanged) {\n          changed = true;\n        }\n      });\n      return;\n    }\n\n    if (isMapLike(source)) {\n      const converted = convertMapLikeToObject(source);\n      if (converted) {\n        processSourceValue(converted);\n        changed = true;\n      }\n      return;\n    }\n\n    if (isPlainObject(source)) {\n      const mappedSelections = deriveLensSelectionsFromNameMap(source);\n      if (mappedSelections.length) {\n        mappedSelections.forEach((entry) => {\n          addSelection(entry, true);\n        });\n        return;\n      }\n      const { selection, changed: entryChanged } = normalizeProjectLensSelectionEntry(source);\n      if (selection) {\n        addSelection(selection, entryChanged);\n        return;\n      }\n      const values = Object.values(source);\n      if (values.length) {\n        processSourceValue(values);\n        changed = true;\n      }\n      return;\n    }\n\n    const fallbackName = normalizeProjectLensNameCandidate(source);\n    if (fallbackName) {\n      addSelection({ name: fallbackName, mount: '' }, true);\n    } else {\n      changed = true;\n    }\n  };\n\n  for (let index = 0; index < sourceList.length; index += 1) {\n    processSourceValue(sourceList[index]);\n  }\n\n  if (Array.isArray(fallbackNames)) {\n    fallbackNames.forEach((rawName) => {\n      if (typeof rawName !== 'string') {\n        return;\n      }\n      const name = rawName.trim();\n      if (!name || seenNames.has(name)) {\n        return;\n      }\n      normalized.push({ name, mount: '' });\n      seenNames.add(name);\n      changed = true;\n    });\n  }\n\n  if (!normalized.length) {\n    return { selections: null, changed };\n  }\n\n  return { selections: normalized, changed };\n}\n\nfunction normalizeProject(data) {\n  const restored = restoreCompressedProjectEntry(data);\n  if (restored.restored) {\n    return normalizeProject(restored.value);\n  }\n\n  if (typeof data === \"string\") {\n    const parsed = tryParseJSONLike(data);\n    if (parsed.success) {\n      const normalized = normalizeProject(parsed.parsed);\n      if (normalized) {\n        return normalized;\n      }\n    }\n    return normalizeProject({ gearList: data, projectInfo: null });\n  }\n  if (isMapLike(data)) {\n    const converted = convertMapLikeToObject(data);\n    if (converted) {\n      return normalizeProject(converted);\n    }\n    return null;\n  }\n  if (isPlainObject(data)) {\n    // New format { gearList, projectInfo }\n    if (Object.prototype.hasOwnProperty.call(data, \"gearList\") || Object.prototype.hasOwnProperty.call(data, \"projectInfo\")) {\n      const projectContainer = isMapLike(data.project)\n        ? convertMapLikeToObject(data.project)\n        : data.project;\n\n      let projectInfoSource = data.projectInfo;\n      if (isMapLike(projectInfoSource)) {\n        projectInfoSource = convertMapLikeToObject(projectInfoSource);\n      }\n\n      let normalizedProjectInfo = isPlainObject(projectInfoSource)\n        ? projectInfoSource\n        : null;\n      if (!normalizedProjectInfo && typeof projectInfoSource === \"string\") {\n        const parsedInfo = tryParseJSONLike(projectInfoSource);\n        if (parsedInfo.success && isPlainObject(parsedInfo.parsed)) {\n          normalizedProjectInfo = parsedInfo.parsed;\n        }\n      }\n      if (!normalizedProjectInfo && isPlainObject(projectContainer)) {\n        let nestedProjectInfo = projectContainer.projectInfo;\n        if (isMapLike(nestedProjectInfo)) {\n          nestedProjectInfo = convertMapLikeToObject(nestedProjectInfo);\n        }\n        if (isPlainObject(nestedProjectInfo)) {\n          normalizedProjectInfo = nestedProjectInfo;\n        } else if (typeof nestedProjectInfo === \"string\") {\n          const parsedProjectInfo = tryParseJSONLike(nestedProjectInfo);\n          if (parsedProjectInfo.success && isPlainObject(parsedProjectInfo.parsed)) {\n            normalizedProjectInfo = parsedProjectInfo.parsed;\n          }\n        }\n      }\n\n      let normalizedAutoGearRules = null;\n      const assignAutoGearRules = (source) => {\n        if (normalizedAutoGearRules && normalizedAutoGearRules.length) {\n          return;\n        }\n        if (source === null || source === undefined) {\n          return;\n        }\n        let candidate = source;\n        if (isMapLike(candidate)) {\n          const convertedRules = convertMapLikeToObject(candidate);\n          if (convertedRules) {\n            candidate = Object.values(convertedRules).filter((entry) => entry !== null && entry !== undefined);\n          }\n        }\n        if (Array.isArray(candidate) && candidate.length) {\n          normalizedAutoGearRules = candidate;\n          return;\n        }\n        if (isPlainObject(candidate)) {\n          const values = Object.values(candidate).filter((entry) => entry !== null && entry !== undefined);\n          if (values.length) {\n            normalizedAutoGearRules = values;\n            return;\n          }\n        }\n        if (typeof candidate === \"string\") {\n          const parsedRules = tryParseJSONLike(candidate);\n          if (parsedRules.success && Array.isArray(parsedRules.parsed) && parsedRules.parsed.length) {\n            normalizedAutoGearRules = parsedRules.parsed;\n          }\n        }\n      };\n\n      assignAutoGearRules(data.autoGearRules);\n      if (!normalizedAutoGearRules && isPlainObject(projectContainer)) {\n        assignAutoGearRules(projectContainer.autoGearRules);\n      }\n\n      let gearListSource = isMapLike(data.gearList)\n        ? convertMapLikeToObject(data.gearList)\n        : data.gearList;\n      if (\n        (gearListSource === null\n          || gearListSource === undefined\n          || (typeof gearListSource === \"string\" && !gearListSource))\n        && isPlainObject(projectContainer)\n        && Object.prototype.hasOwnProperty.call(projectContainer, \"gearList\")\n      ) {\n        gearListSource = projectContainer.gearList;\n      }\n      if (isMapLike(gearListSource)) {\n        const convertedGearList = convertMapLikeToObject(gearListSource);\n        if (convertedGearList) {\n          gearListSource = convertedGearList;\n        }\n      }\n\n      let normalizedGearList =\n        typeof gearListSource === \"string\" || (gearListSource && typeof gearListSource === \"object\")\n          ? gearListSource\n          : \"\";\n\n      let normalizedGearSelectors = null;\n      const gearSelectorsSource = isMapLike(data.gearSelectors)\n        ? convertMapLikeToObject(data.gearSelectors)\n        : data.gearSelectors;\n      if (isPlainObject(gearSelectorsSource)) {\n        normalizedGearSelectors = cloneProjectGearSelectors(gearSelectorsSource);\n      } else if (typeof gearSelectorsSource === \"string\") {\n        const parsedSelectors = tryParseJSONLike(gearSelectorsSource);\n        if (parsedSelectors.success && isPlainObject(parsedSelectors.parsed)) {\n          normalizedGearSelectors = cloneProjectGearSelectors(parsedSelectors.parsed);\n        }\n      }\n      const powerSelectionSource = isMapLike(data.powerSelection)\n        ? convertMapLikeToObject(data.powerSelection)\n        : data.powerSelection;\n      let normalizedPowerSelection = normalizeProjectPowerSelection(powerSelectionSource);\n      if (!normalizedPowerSelection && isPlainObject(powerSelectionSource)) {\n        normalizedPowerSelection = normalizeProjectPowerSelection(powerSelectionSource);\n      }\n\n      if (typeof normalizedGearList === \"string\") {\n        const parsedGear = tryParseJSONLike(normalizedGearList);\n        if (parsedGear.success) {\n          const nested = normalizeProject(parsedGear.parsed);\n          if (nested) {\n            normalizedGearList = nested.gearList;\n            if (!normalizedProjectInfo && nested.projectInfo) {\n              normalizedProjectInfo = nested.projectInfo;\n            }\n            if (\n              (!normalizedAutoGearRules || !normalizedAutoGearRules.length)\n              && Array.isArray(nested.autoGearRules)\n              && nested.autoGearRules.length\n            ) {\n              normalizedAutoGearRules = nested.autoGearRules;\n            }\n            if (!normalizedGearSelectors && isPlainObject(nested.gearSelectors)) {\n              normalizedGearSelectors = cloneProjectGearSelectors(nested.gearSelectors);\n            }\n            if (!normalizedPowerSelection && isPlainObject(nested.powerSelection)) {\n              normalizedPowerSelection = normalizeProjectPowerSelection(nested.powerSelection);\n            }\n          } else if (\n            typeof parsedGear.parsed === \"string\"\n            || (isPlainObject(parsedGear.parsed)\n              && Object.values(parsedGear.parsed).every((value) => typeof value === \"string\"))\n          ) {\n            normalizedGearList = parsedGear.parsed;\n          }\n        }\n      }\n\n      if (\n        normalizedGearList\n        && typeof normalizedGearList === \"object\"\n        && !isPlainObject(normalizedGearList)\n      ) {\n        normalizedGearList = \"\";\n      }\n\n      if (normalizedProjectInfo) {\n        normalizeImportedProjectFilters(normalizedProjectInfo);\n      }\n      if (normalizedProjectInfo) {\n        normalizedProjectInfo = sanitizeImportedProjectInfo(normalizedProjectInfo) || null;\n      }\n      if (normalizedProjectInfo) {\n        normalizeImportedProjectFilters(normalizedProjectInfo);\n      }\n\n      const normalized = {\n        gearList: Array.isArray(normalizedGearList) || isPlainObject(normalizedGearList)\n          ? cloneProjectData(normalizedGearList)\n          : normalizedGearList,\n        projectInfo: normalizedProjectInfo ? cloneProjectInfo(normalizedProjectInfo) : null,\n      };\n      const diagramSource = isMapLike(data.diagramPositions)\n        ? convertMapLikeToObject(data.diagramPositions)\n        : data.diagramPositions;\n      let normalizedDiagramPositions = normalizeDiagramPositions(diagramSource);\n      if (\n        Object.keys(normalizedDiagramPositions).length === 0\n        && isPlainObject(projectContainer)\n      ) {\n        const nestedDiagramSource = isMapLike(projectContainer.diagramPositions)\n          ? convertMapLikeToObject(projectContainer.diagramPositions)\n          : projectContainer.diagramPositions;\n        normalizedDiagramPositions = normalizeDiagramPositions(nestedDiagramSource);\n      }\n      if (Object.keys(normalizedDiagramPositions).length) {\n        normalized.diagramPositions = cloneDiagramPositionsForStorage(normalizedDiagramPositions);\n      }\n      const htmlSources = [];\n      if (typeof data.projectHtml === 'string') {\n        htmlSources.push(data.projectHtml);\n      }\n      if (typeof data.gearHtml === 'string') {\n        htmlSources.push(data.gearHtml);\n      }\n      if (isPlainObject(projectContainer)) {\n        if (typeof projectContainer.projectHtml === 'string') {\n          htmlSources.push(projectContainer.projectHtml);\n        }\n        if (typeof projectContainer.gearHtml === 'string') {\n          htmlSources.push(projectContainer.gearHtml);\n        }\n      }\n      if (isPlainObject(gearListSource) && typeof gearListSource.gearHtml === 'string') {\n        htmlSources.push(gearListSource.gearHtml);\n      }\n      if (isPlainObject(normalizedGearList)) {\n        if (typeof normalizedGearList.projectHtml === 'string') {\n          htmlSources.push(normalizedGearList.projectHtml);\n        }\n        if (typeof normalizedGearList.gearHtml === 'string') {\n          htmlSources.push(normalizedGearList.gearHtml);\n        }\n      } else if (typeof normalizedGearList === 'string') {\n        htmlSources.push(normalizedGearList);\n      }\n      if (!normalizedGearSelectors && isPlainObject(projectContainer)) {\n        const nestedSelectorsSource = isMapLike(projectContainer.gearSelectors)\n          ? convertMapLikeToObject(projectContainer.gearSelectors)\n          : projectContainer.gearSelectors;\n        if (isPlainObject(nestedSelectorsSource)) {\n          normalizedGearSelectors = cloneProjectGearSelectors(nestedSelectorsSource);\n        }\n      }\n      if (!normalizedGearSelectors && isPlainObject(normalizedGearList) && isPlainObject(normalizedGearList.gearSelectors)) {\n        normalizedGearSelectors = cloneProjectGearSelectors(normalizedGearList.gearSelectors);\n      }\n      if (!normalizedPowerSelection && isPlainObject(projectContainer)) {\n        const nestedPowerSelection = isMapLike(projectContainer.powerSelection)\n          ? convertMapLikeToObject(projectContainer.powerSelection)\n          : projectContainer.powerSelection;\n        if (isPlainObject(nestedPowerSelection)) {\n          normalizedPowerSelection = normalizeProjectPowerSelection(nestedPowerSelection);\n        }\n      }\n      if (!normalizedProjectInfo) {\n        for (let i = 0; i < htmlSources.length; i += 1) {\n          const recovered = extractProjectInfoFromHtml(htmlSources[i]);\n          if (recovered) {\n            normalized.projectInfo = cloneProjectInfo(recovered);\n            break;\n          }\n        }\n      } else if (htmlSources.length) {\n        for (let i = 0; i < htmlSources.length; i += 1) {\n          const recovered = extractProjectInfoFromHtml(htmlSources[i]);\n          if (recovered) {\n            const recoveredClone = cloneProjectInfo(recovered) || {};\n            const normalizedClone = cloneProjectInfo(normalizedProjectInfo) || {};\n            normalized.projectInfo = { ...recoveredClone, ...normalizedClone };\n            break;\n          }\n        }\n      }\n      const fallbackLensNames = [];\n      const fallbackLensNameSet = new Set();\n      const addFallbackLensName = (name) => {\n        if (typeof name !== 'string') {\n          return;\n        }\n        const trimmed = name.trim();\n        if (!trimmed || fallbackLensNameSet.has(trimmed)) {\n          return;\n        }\n        fallbackLensNameSet.add(trimmed);\n        fallbackLensNames.push(trimmed);\n      };\n      const registerFallbackLensNames = (source, options = {}) => {\n        if (source === null || source === undefined) {\n          return;\n        }\n        if (options.fromSelections) {\n          const entries = Array.isArray(source) ? source : [source];\n          entries.forEach((entry) => {\n            if (isMapLike(entry)) {\n              const converted = convertMapLikeToObject(entry);\n              if (converted) {\n                registerFallbackLensNames(converted, { fromSelections: true });\n                return;\n              }\n            }\n            if (isPlainObject(entry)) {\n              const mapped = deriveLensSelectionsFromNameMap(entry);\n              if (mapped.length) {\n                mapped.forEach((selection) => {\n                  if (selection && typeof selection.name === 'string') {\n                    addFallbackLensName(selection.name);\n                  }\n                });\n                return;\n              }\n            }\n            const candidate = normalizeProjectLensNameCandidate(entry);\n            if (candidate) {\n              addFallbackLensName(candidate);\n            }\n          });\n          return;\n        }\n        const names = extractLensNamesFromSource(source);\n        if (!names.length) {\n          return;\n        }\n        names.forEach((name) => {\n          addFallbackLensName(name);\n        });\n      };\n\n      if (\n        normalized.projectInfo\n        && Object.prototype.hasOwnProperty.call(normalized.projectInfo, 'lenses')\n      ) {\n        const { names } = normalizeProjectLensNamesField(normalized.projectInfo.lenses);\n        normalized.projectInfo = normalized.projectInfo && typeof normalized.projectInfo === 'object'\n          ? normalized.projectInfo\n          : {};\n        normalized.projectInfo.lenses = names.slice();\n        registerFallbackLensNames(names);\n      }\n\n      registerFallbackLensNames(data.lenses);\n      if (isPlainObject(projectContainer)) {\n        registerFallbackLensNames(projectContainer.lenses);\n      }\n      registerFallbackLensNames(gearListSource && gearListSource.lenses);\n      if (isPlainObject(normalizedGearList)) {\n        registerFallbackLensNames(normalizedGearList.lenses);\n      }\n\n      if (\n        (!normalized.projectInfo\n          || !Array.isArray(normalized.projectInfo.lenses)\n          || !normalized.projectInfo.lenses.length)\n        && fallbackLensNames.length\n      ) {\n        normalized.projectInfo = normalized.projectInfo && typeof normalized.projectInfo === 'object'\n          ? normalized.projectInfo\n          : {};\n        normalized.projectInfo.lenses = fallbackLensNames.slice();\n      }\n\n      const lensSelectionSources = [];\n      if (\n        normalized.projectInfo\n        && Object.prototype.hasOwnProperty.call(normalized.projectInfo, 'lensSelections')\n      ) {\n        registerFallbackLensNames(normalized.projectInfo.lensSelections, { fromSelections: true });\n        lensSelectionSources.push(normalized.projectInfo.lensSelections);\n      }\n      if (Object.prototype.hasOwnProperty.call(data, 'lensSelections')) {\n        registerFallbackLensNames(data.lensSelections, { fromSelections: true });\n        lensSelectionSources.push(data.lensSelections);\n      }\n      if (\n        isPlainObject(projectContainer)\n        && Object.prototype.hasOwnProperty.call(projectContainer, 'lensSelections')\n      ) {\n        registerFallbackLensNames(projectContainer.lensSelections, { fromSelections: true });\n        lensSelectionSources.push(projectContainer.lensSelections);\n      }\n      if (\n        isPlainObject(gearListSource)\n        && Object.prototype.hasOwnProperty.call(gearListSource, 'lensSelections')\n      ) {\n        registerFallbackLensNames(gearListSource.lensSelections, { fromSelections: true });\n        lensSelectionSources.push(gearListSource.lensSelections);\n      }\n      if (\n        isPlainObject(normalizedGearList)\n        && Object.prototype.hasOwnProperty.call(normalizedGearList, 'lensSelections')\n      ) {\n        registerFallbackLensNames(normalizedGearList.lensSelections, { fromSelections: true });\n        lensSelectionSources.push(normalizedGearList.lensSelections);\n      }\n\n      const lensSelectionResult = normalizeProjectLensSelectionsFromSources(\n        lensSelectionSources,\n        fallbackLensNames,\n      );\n\n      if (\n        lensSelectionResult\n        && lensSelectionResult.selections\n        && lensSelectionResult.selections.length\n      ) {\n        normalized.projectInfo = normalized.projectInfo && typeof normalized.projectInfo === 'object'\n          ? normalized.projectInfo\n          : {};\n        normalized.projectInfo.lensSelections = lensSelectionResult.selections;\n        if (\n          !Array.isArray(normalized.projectInfo.lenses)\n          || !normalized.projectInfo.lenses.length\n        ) {\n          normalized.projectInfo.lenses = lensSelectionResult.selections\n            .map((entry) => (typeof entry.name === 'string' ? entry.name : ''))\n            .filter((name) => name);\n        }\n      } else if (\n        lensSelectionResult\n        && lensSelectionResult.changed\n        && normalized.projectInfo\n        && Object.prototype.hasOwnProperty.call(normalized.projectInfo, 'lensSelections')\n      ) {\n        delete normalized.projectInfo.lensSelections;\n      }\n      const derivedGenerationFlag = typeof data.gearListAndProjectRequirementsGenerated === 'boolean'\n        ? data.gearListAndProjectRequirementsGenerated\n        : htmlSources.some((value) => typeof value === 'string' && value.trim());\n      normalized.gearListAndProjectRequirementsGenerated = derivedGenerationFlag;\n      if (normalizedAutoGearRules && normalizedAutoGearRules.length) {\n        normalized.autoGearRules = cloneAutoGearRules(normalizedAutoGearRules);\n      }\n      if (normalizedGearSelectors && Object.keys(normalizedGearSelectors).length) {\n        normalized.gearSelectors = normalizedGearSelectors;\n      }\n      if (normalizedPowerSelection) {\n        normalized.powerSelection = cloneProjectPowerSelection(normalizedPowerSelection);\n      }\n      copyAutoBackupMetadata(data, normalized);\n      if (normalized.projectInfo) {\n        normalizeImportedProjectFilters(normalized.projectInfo);\n      }\n      if (normalized.projectInfo) {\n        const normalizedInfo = normalizeLegacyLongGopStructure(normalized.projectInfo);\n        if (normalizedInfo !== normalized.projectInfo) {\n          normalized.projectInfo = normalizedInfo;\n        }\n      }\n      if (normalized.autoGearRules) {\n        const normalizedRules = normalizeLegacyLongGopStructure(normalized.autoGearRules);\n        if (normalizedRules !== normalized.autoGearRules) {\n          normalized.autoGearRules = normalizedRules;\n        }\n      }\n      if (normalized.gearSelectors) {\n        const normalizedSelectors = normalizeLegacyLongGopStructure(normalized.gearSelectors);\n        if (normalizedSelectors !== normalized.gearSelectors) {\n          normalized.gearSelectors = normalizedSelectors;\n        }\n      }\n      if (normalized.diagramPositions) {\n        const normalizedDiagram = normalizeLegacyLongGopStructure(normalized.diagramPositions);\n        if (normalizedDiagram !== normalized.diagramPositions) {\n          normalized.diagramPositions = normalizedDiagram;\n        }\n      }\n      if (normalized.powerSelection) {\n        const normalizedPower = normalizeLegacyLongGopStructure(normalized.powerSelection);\n        if (normalizedPower !== normalized.powerSelection) {\n          normalized.powerSelection = normalizedPower;\n        }\n      }\n      return normalized;\n    }\n    // Legacy format { projectHtml, gearHtml }\n    if (Object.prototype.hasOwnProperty.call(data, \"projectHtml\") || Object.prototype.hasOwnProperty.call(data, \"gearHtml\")) {\n      return {\n        gearList: { projectHtml: data.projectHtml || \"\", gearHtml: data.gearHtml || \"\" },\n        projectInfo: null,\n      };\n    }\n\n    if (isPlainObject(data.project)) {\n      const nested = normalizeProject(data.project);\n      if (nested) {\n        return nested;\n      }\n    } else if (typeof data.project === \"string\") {\n      const parsedProject = tryParseJSONLike(data.project);\n      if (parsedProject.success) {\n        const nested = normalizeProject(parsedProject.parsed);\n        if (nested) {\n          return nested;\n        }\n      }\n    }\n  }\n  return null;\n}\n\nvar LEGACY_PROJECT_ROOT_KEYS = new Set([\n  \"gearList\",\n  \"projectInfo\",\n  \"projectHtml\",\n  \"gearHtml\",\n  \"autoGearRules\",\n  \"powerSelection\",\n  \"gearListAndProjectRequirementsGenerated\",\n]);\n\nvar NORMALIZED_PROJECT_KEYS = new Set([\n  \"gearList\",\n  \"projectInfo\",\n  \"autoGearRules\",\n  \"diagramPositions\",\n  \"gearSelectors\",\n  \"powerSelection\",\n  \"gearListAndProjectRequirementsGenerated\",\n]);\n\nfunction isNormalizedProjectEntry(entry) {\n  if (!isPlainObject(entry)) {\n    return false;\n  }\n  const keys = Object.keys(entry);\n  if (!keys.every((key) => NORMALIZED_PROJECT_KEYS.has(key))) {\n    return false;\n  }\n  const { gearList, projectInfo } = entry;\n  if (\n    typeof gearList !== \"string\" &&\n    !(isPlainObject(gearList) &&\n      Object.keys(gearList).every((key) => typeof gearList[key] === \"string\"))\n  ) {\n    return false;\n  }\n  if (projectInfo !== null && !isPlainObject(projectInfo)) {\n    return false;\n  }\n  if (Object.prototype.hasOwnProperty.call(entry, \"autoGearRules\")) {\n    if (!Array.isArray(entry.autoGearRules) || !entry.autoGearRules.length) {\n      return false;\n    }\n  }\n  if (\n    Object.prototype.hasOwnProperty.call(entry, \"diagramPositions\")\n    && !isPlainObject(entry.diagramPositions)\n  ) {\n    return false;\n  }\n  if (\n    Object.prototype.hasOwnProperty.call(entry, \"gearSelectors\")\n    && !isPlainObject(entry.gearSelectors)\n  ) {\n    return false;\n  }\n  if (\n    Object.prototype.hasOwnProperty.call(entry, \"powerSelection\")\n  ) {\n    const powerSelection = entry.powerSelection;\n    if (!isPlainObject(powerSelection)) {\n      return false;\n    }\n  }\n  if (\n    Object.prototype.hasOwnProperty.call(entry, \"gearListAndProjectRequirementsGenerated\")\n    && typeof entry.gearListAndProjectRequirementsGenerated !== \"boolean\"\n  ) {\n    return false;\n  }\n  return true;\n}\n\nfunction normalizeProjectStorageKey(name) {\n  if (typeof name !== \"string\") {\n    return \"\";\n  }\n  return name.trim();\n}\n\nfunction setActiveProjectCompressionHold(name) {\n  if (name === null || name === undefined) {\n    ACTIVE_PROJECT_COMPRESSION_HOLD_KEY = '';\n    ACTIVE_PROJECT_COMPRESSION_HOLD_ENABLED = false;\n    return '';\n  }\n\n  const normalized = normalizeProjectStorageKey(name);\n  if (isForcedProjectCompressionLocked(normalized)) {\n    ACTIVE_PROJECT_COMPRESSION_HOLD_KEY = '';\n    ACTIVE_PROJECT_COMPRESSION_HOLD_ENABLED = false;\n    return normalized;\n  }\n  ACTIVE_PROJECT_COMPRESSION_HOLD_KEY = normalized;\n  ACTIVE_PROJECT_COMPRESSION_HOLD_ENABLED = true;\n  return normalized;\n}\n\nfunction clearActiveProjectCompressionHold(name) {\n  if (!ACTIVE_PROJECT_COMPRESSION_HOLD_ENABLED) {\n    return false;\n  }\n\n  if (name !== undefined) {\n    const normalized = normalizeProjectStorageKey(name);\n    if (normalized !== ACTIVE_PROJECT_COMPRESSION_HOLD_KEY) {\n      return false;\n    }\n  }\n\n  ACTIVE_PROJECT_COMPRESSION_HOLD_KEY = '';\n  ACTIVE_PROJECT_COMPRESSION_HOLD_ENABLED = false;\n  return true;\n}\n\n\n\nfunction resolveProjectKey(projects, lookup, name, options = {}) {\n  if (!projects || typeof projects !== \"object\") {\n    return null;\n  }\n\n  const rawName = typeof name === \"string\" ? name : \"\";\n  if (Object.prototype.hasOwnProperty.call(projects, rawName)) {\n    return rawName;\n  }\n\n  const normalizedName = normalizeProjectStorageKey(rawName);\n  if (\n    normalizedName\n    && normalizedName !== rawName\n    && Object.prototype.hasOwnProperty.call(projects, normalizedName)\n  ) {\n    return normalizedName;\n  }\n\n  if (!lookup || typeof lookup !== \"object\") {\n    return null;\n  }\n\n  const { raw: rawMap, normalized: normalizedMap } = lookup;\n\n  if (rawMap && typeof rawMap.get === \"function\" && rawMap.has(rawName)) {\n    const candidate = rawMap.get(rawName);\n    if (Object.prototype.hasOwnProperty.call(projects, candidate)) {\n      return candidate;\n    }\n  }\n\n  if (\n    normalizedMap\n    && typeof normalizedMap.get === \"function\"\n    && normalizedMap.has(normalizedName)\n  ) {\n    const candidates = normalizedMap.get(normalizedName);\n    if (Array.isArray(candidates)) {\n      if (options && options.preferExact && rawName) {\n        const exact = candidates.find(\n          (candidate) => candidate === rawName && Object.prototype.hasOwnProperty.call(projects, candidate),\n        );\n        if (exact) {\n          return exact;\n        }\n      }\n      const firstExisting = candidates.find((candidate) =>\n        Object.prototype.hasOwnProperty.call(projects, candidate)\n      );\n      if (firstExisting) {\n        return firstExisting;\n      }\n    } else if (\n      typeof candidates === \"string\"\n      && Object.prototype.hasOwnProperty.call(projects, candidates)\n    ) {\n      return candidates;\n    }\n  }\n\n  return null;\n}\n\nfunction readAllProjectsFromStorage(options = {}) {\n  const {\n    forceRefresh = false,\n    forMutation = false,\n    skipMigrations = false,\n    skipAutoBackupExpansion = false,\n  } = options || {};\n\n  if (!skipMigrations) {\n    applyLegacyStorageMigrations();\n  }\n\n  // [Refactor] Hybrid Approach: Use Memory Cache if Hydrated (IndexedDB active)\n  if (isProjectCacheHydrated) {\n    // Return a clone to prevent mutation unless strictly for reference, but legacy expects copies usually.\n    // `projects` is the map of name -> project\n    return {\n      projects: { ...projectMemoryCache },\n      changed: false,\n      originalValue: { ...projectMemoryCache },\n      lookup: { raw: new Map(), normalized: new Map() } // Simplification: we might need to rebuild lookup if used heavily\n    };\n    // Note: The `lookup` object was used for case-insensitive matching. \n    // If we drop it, `resolveProjectKey` might fail.\n    // Let's implement a basic lookup generator on the fly or maintain it in cache.\n    // For now, let's regenerate it from the cache keys:\n    /*\n    const rawMap = new Map();\n    const normalizedMap = new Map();\n    Object.keys(projectMemoryCache).forEach(k => {\n        rawMap.set(k, k);\n        const norm = normalizeProjectStorageKey(k);\n        if (!normalizedMap.has(norm)) normalizedMap.set(norm, []);\n        normalizedMap.get(norm).push(k);\n    });\n    return { projects: { ... }, lookup: { raw: rawMap, normalized: normalizedMap }, ... }\n    */\n    // Actually, let's keep it simple. If legacy code needs lookup, it calls this.\n  }\n\n  // Fallback to Legacy LocalStorage Logic\n  const safeStorage = getSafeLocalStorage();\n  let storageRaw = null;\n  if (safeStorage && typeof safeStorage.getItem === 'function') {\n    try {\n      storageRaw = safeStorage.getItem(PROJECT_STORAGE_KEY);\n    } catch (storageReadError) {\n      storageRaw = null;\n      void storageReadError;\n    }\n  }\n\n  const parsed = loadJSONFromStorage(\n    safeStorage,\n    PROJECT_STORAGE_KEY,\n    \"Error loading project from localStorage:\",\n    null,\n    {\n      validate: (value) =>\n        value === null\n        || typeof value === \"string\"\n        || Array.isArray(value)\n        || isPlainObject(value),\n    },\n  );\n  const originalValue = parsed;\n  let combinedRawEntries = null;\n\n  if (isPlainObject(parsed)) {\n    combinedRawEntries = { ...parsed };\n  } else {\n    combinedRawEntries = {};\n  }\n\n  if (safeStorage && typeof safeStorage.length === 'number') {\n    const count = safeStorage.length;\n    for (let i = 0; i < count; i++) {\n      const key = safeStorage.key(i);\n      if (!key || !key.startsWith(PROJECT_SHARD_PREFIX)) {\n        continue;\n      }\n      const rawName = key.substring(PROJECT_SHARD_PREFIX.length);\n      if (rawName === null || rawName === undefined) {\n        continue;\n      }\n      try {\n        const rawVal = safeStorage.getItem(key);\n        const parsedVal = JSON.parse(decodeStoredValue(rawVal));\n        // Store raw value to allow expansion of backups later\n        if (combinedRawEntries === null) {\n          combinedRawEntries = {};\n        }\n        combinedRawEntries[rawName] = parsedVal;\n      } catch (e) {\n        void e;\n      }\n    }\n  }\n\n  let inputForExpansion = parsed;\n  // preferring combined object if we have shards or if existing was object\n  if (combinedRawEntries !== null && Object.keys(combinedRawEntries).length > 0) {\n    inputForExpansion = combinedRawEntries;\n  } else if (isPlainObject(parsed)) {\n    inputForExpansion = combinedRawEntries;\n  }\n\n  const expandOptions = {\n    isAutoBackupKey: isAutoBackupStorageKey,\n  };\n  if (skipAutoBackupExpansion) {\n    expandOptions.filter = (name) => !isAutoBackupStorageKey(name);\n  }\n  const expandedParsed = expandAutoBackupEntries(inputForExpansion, expandOptions);\n  const projects = {};\n  let changed = false;\n  const usedProjectNames = new Set();\n  const normalizedProjectNames = new Set();\n  const markProjectNameUsed = (name) => {\n    if (typeof name !== \"string\") {\n      return;\n    }\n    usedProjectNames.add(name);\n    const trimmed = name.trim();\n    if (trimmed) {\n      normalizedProjectNames.add(trimmed.toLowerCase());\n    }\n  };\n\n  const rawKeyLookup = new Map();\n  const normalizedKeyLookup = new Map();\n  const registerLookupKey = (rawKey, storedKey) => {\n    if (typeof rawKey !== \"string\") {\n      return;\n    }\n    const effectiveKey = typeof storedKey === \"string\" ? storedKey : rawKey;\n    rawKeyLookup.set(rawKey, effectiveKey);\n    const normalized = normalizeProjectStorageKey(rawKey);\n    if (!normalizedKeyLookup.has(normalized)) {\n      normalizedKeyLookup.set(normalized, []);\n    }\n    normalizedKeyLookup.get(normalized).push(effectiveKey);\n  };\n\n  const createLookupSnapshot = () => ({\n    raw: cloneLookupMap(rawKeyLookup),\n    normalized: cloneLookupMap(normalizedKeyLookup),\n  });\n\n  const finalize = () => {\n\n    const snapshot = {\n      projects,\n      changed,\n      originalValue,\n      lookup: createLookupSnapshot(),\n      rawValue: storageRaw,\n    };\n\n    if (changed) {\n      setProjectReadCacheSnapshot(null);\n      if (forMutation) {\n        return {\n          projects: STORAGE_DEEP_CLONE(snapshot.projects),\n          changed: snapshot.changed,\n          originalValue: snapshot.originalValue,\n          lookup: cloneProjectLookupSnapshotForReturn(snapshot.lookup),\n        };\n      }\n      return snapshot;\n    }\n\n    const shouldUseCache = !forceRefresh;\n    if (!shouldUseCache) {\n      return snapshot;\n    }\n\n    setProjectReadCacheSnapshot(snapshot);\n    const cached = getProjectReadCacheClone({ forMutation });\n    return cached || snapshot;\n  };\n\n  if (expandedParsed === null || expandedParsed === undefined) {\n    return finalize();\n  }\n\n  if (typeof expandedParsed === \"string\") {\n    const normalized = normalizeProject(expandedParsed);\n    if (normalized) {\n      const suggestedName =\n        (normalized && normalized.projectInfo && typeof normalized.projectInfo.projectName === 'string')\n          ? normalized.projectInfo.projectName\n          : \"\";\n      const updatedName = generateUpdatedProjectName(suggestedName, usedProjectNames, normalizedProjectNames);\n      projects[updatedName] = normalized;\n      registerLookupKey(\"\", updatedName);\n      markProjectNameUsed(updatedName);\n    }\n    changed = true;\n    return finalize();\n  }\n\n  if (Array.isArray(expandedParsed)) {\n    const usedNames = usedProjectNames;\n    const normalizedNames = normalizedProjectNames;\n    expandedParsed.forEach((item, index) => {\n      const normalized = normalizeProject(item);\n      if (!normalized) {\n        changed = true;\n        return;\n      }\n      const baseName =\n        isPlainObject(item) && typeof item.name === \"string\"\n          ? item.name.trim()\n          : `Project ${index + 1}`;\n      const candidate = baseName || `Project ${index + 1}`;\n      const unique = generateUpdatedProjectName(candidate, usedNames, normalizedNames);\n      projects[unique] = normalized;\n      registerLookupKey(candidate, unique);\n      markProjectNameUsed(unique);\n    });\n    changed = true;\n    return finalize();\n  }\n\n  if (!isPlainObject(expandedParsed)) {\n    changed = true;\n    return finalize();\n  }\n\n  const keys = Object.keys(expandedParsed);\n  const maybeLegacy =\n    keys.length > 0 && keys.every((key) => LEGACY_PROJECT_ROOT_KEYS.has(key));\n\n  if (maybeLegacy) {\n    const normalized = normalizeProject(expandedParsed);\n    if (normalized) {\n      const updatedName = generateUpdatedProjectName(\"\", usedProjectNames, normalizedProjectNames);\n      projects[updatedName] = normalized;\n      registerLookupKey(\"\", updatedName);\n      markProjectNameUsed(updatedName);\n    }\n    changed = true;\n    return finalize();\n  }\n\n  keys.forEach((key) => {\n    if (isNormalizedProjectEntry(expandedParsed[key])) {\n      const trimmedKey = typeof key === \"string\" ? key.trim() : \"\";\n      if (trimmedKey) {\n        normalizedProjectNames.add(trimmedKey.toLowerCase());\n      }\n    }\n  });\n\n  keys.forEach((key) => {\n    const normalized = normalizeProject(expandedParsed[key]);\n    if (normalized) {\n      const originalEntry = expandedParsed[key];\n      const isNormalized = isNormalizedProjectEntry(originalEntry);\n      // console.log('DEBUG: readAllProjectsFromStorage key:', key, 'isNormalized:', isNormalized);\n      const needsUpgrade = !isNormalized;\n      let requiresContentUpdate = false;\n      if (!needsUpgrade) {\n        try {\n          const normalizedSignature = createStableValueSignature(normalized);\n          const originalSignature = createStableValueSignature(originalEntry);\n          if (normalizedSignature !== originalSignature) {\n            requiresContentUpdate = true;\n          }\n        } catch (signatureError) {\n          requiresContentUpdate = true;\n          console.warn(\n            'Unable to compare stored project entry during legacy long-GOP normalization check',\n            signatureError,\n          );\n        }\n      }\n      let finalKey = key;\n      if (needsUpgrade) {\n        const innerName = (normalized && normalized.projectInfo && typeof normalized.projectInfo.projectName === 'string' && normalized.projectInfo.projectName)\n          ? normalized.projectInfo.projectName\n          : key;\n        finalKey = generateUpdatedProjectName(innerName, usedProjectNames, normalizedProjectNames);\n        changed = true;\n      }\n      if (\n        finalKey !== key\n        && Object.prototype.hasOwnProperty.call(projects, finalKey)\n      ) {\n        const adjusted = generateUpdatedProjectName(finalKey, usedProjectNames, normalizedProjectNames);\n        finalKey = adjusted;\n      }\n      projects[finalKey] = normalized;\n      registerLookupKey(key, finalKey);\n      markProjectNameUsed(finalKey);\n      if (!needsUpgrade && requiresContentUpdate) {\n        changed = true;\n      }\n    } else {\n      changed = true;\n    }\n  });\n\n  return finalize();\n}\n\nfunction pruneOrphanProjectShards(storage, projects) {\n  if (!storage || typeof storage.length !== 'number' || !isPlainObject(projects)) {\n    return;\n  }\n  const projectKeys = new Set(\n    Object.keys(projects).map((name) => normalizeProjectStorageKey(name)),\n  );\n  const keysToDelete = [];\n  for (let i = 0; i < storage.length; i += 1) {\n    const key = storage.key(i);\n    if (key && key.startsWith(PROJECT_SHARD_PREFIX)) {\n      const rawName = key.substring(PROJECT_SHARD_PREFIX.length);\n      if (!projectKeys.has(rawName)) {\n        keysToDelete.push(key);\n      }\n    }\n  }\n  keysToDelete.forEach((key) =>\n    deleteFromStorage(storage, key, 'Pruning orphan project shard:'),\n  );\n}\n\nfunction cleanupMonolithicProjectStorage(storage) {\n  if (!storage) return;\n\n  // Skip if we've already handled the monolith this session\n  if (GLOBAL_SCOPE && GLOBAL_SCOPE.__cineMonolithicProjectCleanupDone) {\n    return;\n  }\n\n  const raw = storage.getItem(PROJECT_STORAGE_KEY);\n  // If it's already empty, mark as done and return.\n  if (!raw) {\n    if (GLOBAL_SCOPE) {\n      GLOBAL_SCOPE.__cineMonolithicProjectCleanupDone = true;\n    }\n    return;\n  }\n\n  // Ensure we have a migration backup before we delete the monolith\n  try {\n    const parsed = JSON.parse(decodeStoredValue(raw));\n    if (parsed) {\n      createStorageMigrationBackup(storage, PROJECT_STORAGE_KEY, parsed);\n    }\n  } catch (e) {\n    // If parsing fails, we skip migration backup but proceed with cleanup to prevent infinite loops\n    // if the data is corrupted and causing other issues.\n    void e;\n  }\n\n  deleteFromStorage(\n    storage,\n    PROJECT_STORAGE_KEY,\n    \"Error clearing project monolithic storage after sharding:\",\n    {\n      disableBackup: false,\n      disableMigrationCleanup: true\n    }\n  );\n\n  // Mark as done so we don't repeat this process\n  if (GLOBAL_SCOPE) {\n    GLOBAL_SCOPE.__cineMonolithicProjectCleanupDone = true;\n  }\n}\n\nfunction persistProjectShard(name, project, options = {}) {\n  if (name === null || name === undefined || project === undefined || project === null) {\n    return false;\n  }\n  const safeStorage = getSafeLocalStorage();\n  if (!safeStorage) {\n    return false;\n  }\n\n  const { skipCompression = false } = options || {};\n  const shardKey = PROJECT_SHARD_PREFIX + normalizeProjectStorageKey(name);\n\n  // Prepare a temporary object to use existing serialization logic\n  const entries = {};\n  entries[name] = project;\n\n  const serialized = serializeAutoBackupEntries(entries, {\n    isAutoBackupKey: isAutoBackupStorageKey,\n  });\n  const projectData = serialized[name];\n\n  const result = saveJSONToStorage(\n    safeStorage,\n    shardKey,\n    projectData,\n    `Error saving project shard \"${name}\":`,\n    {\n      disableCompression: skipCompression,\n      forceCompressionOnQuota: true,\n      disableBackup: true,\n      onQuotaExceeded: () => {\n        // Cross-shard quota recovery: try to prune the oldest auto-backup shard.\n        // Note: we don't want forMutation: true here because we are in the middle of a save.\n        const { projects } = readAllProjectsFromStorage({ forMutation: false, skipMigrations: true });\n        let removedKey = removeOldestAutoBackupEntry(projects);\n\n        if (!removedKey) {\n          removedKey = removeOldestAutoBackupEntry(projects, { force: true });\n        }\n\n        if (removedKey) {\n          const victimKey = PROJECT_SHARD_PREFIX + normalizeProjectStorageKey(removedKey);\n          deleteFromStorage(safeStorage, victimKey, `Pruning shard \"${removedKey}\" to recover space:`);\n          return true;\n        }\n        return false;\n      },\n    }\n  );\n\n  return result === 'success';\n}\n\nfunction persistAllProjects(projects, options = {}) {\n  const { skipCompression = false } = options || {};\n  const safeStorage = getSafeLocalStorage();\n\n  if (!projects || typeof projects !== 'object') return;\n\n  // Prune within the projects object first (handling auto-backup counts)\n  enforceAutoBackupLimits(projects);\n\n  // CRITICAL: Clean up orphan shards BEFORE persisting new ones.\n  // This frees storage space first, preventing quota exceeded errors\n  // when old auto-backup shards persist from previous sessions.\n  pruneOrphanProjectShards(safeStorage, projects);\n\n  // Persist each project as its own shard.\n  Object.keys(projects).forEach((name) => {\n    persistProjectShard(name, projects[name], { skipCompression });\n  });\n\n  // Monolithic key cleanup (migration from old format)\n  cleanupMonolithicProjectStorage(safeStorage);\n\n  bumpProjectStorageRevision(safeStorage);\n\n  // [Performance] Update the Project Index\n  try {\n    updateProjectIndex(projects, safeStorage);\n  } catch (indexError) {\n    console.warn('Failed to update project index', indexError);\n  }\n\n  invalidateProjectReadCache();\n  if (lifecycleChannel) {\n    try {\n      lifecycleChannel.postMessage('project-shards-changed');\n    } catch (e) {\n      void e;\n    }\n  }\n}\n\n/**\n * Reads, validates, and returns the project index from storage.\n * Returns null if missing or invalid.\n */\n// [Agent Refactor] Memory Cache for Project Index (Synchronous Read Support)\nlet projectIndexCache = null;\n\n/**\n * Reads, validates, and returns the project index from storage.\n * Returns null if missing or invalid.\n */\nfunction readProjectIndex() {\n  // Return cached version if available (hydrated from IDB)\n  if (projectIndexCache) {\n    return projectIndexCache;\n  }\n\n  // Fallback to legacy LocalStorage if cache not ready (rare, only during rapid boot)\n  const safeStorage = getSafeLocalStorage();\n  const isIndexedDB = storageRepo && storageRepo.driver && storageRepo.driver.constructor && storageRepo.driver.constructor.name === 'IndexedDBAdapter';\n\n  if (!safeStorage || typeof safeStorage.getItem !== 'function') return null;\n\n  // If we are strictly on IDB and cache is empty, we return null (assuming hydration handles it).\n  // But for safety during migration, we can check legacy one last time?\n  // No, if isIndexedDB is active, we should rely on cache.\n  if (isIndexedDB) {\n    return null;\n  }\n\n  try {\n    const raw = safeStorage.getItem(PROJECT_INDEX_KEY);\n    if (!raw) return null;\n\n    const index = JSON.parse(raw);\n    if (index && typeof index === 'object') return index;\n  } catch (e) {\n    console.warn('Failed to read project index', e);\n  }\n  return null;\n}\n\n/**\n * Updates the persisted project index based on the full projects map.\n */\nfunction updateProjectIndex(projects, safeStorage) {\n  // if (!safeStorage || typeof safeStorage.setItem !== 'function') return; // Relaxed for repo support\n  if (!projects || typeof projects !== 'object') return;\n\n  const index = {};\n  Object.keys(projects).forEach(key => {\n    // Skip auto-backups in the index to keep it small\n    if (isAutoBackupStorageKey(key)) return;\n\n    const project = projects[key];\n    if (!project) return;\n\n    index[key] = {\n      color: project.color,\n      icon: project.icon,\n      lastModified: project.lastModified,\n      prepDays: project.prepDays,\n      shootingDays: project.shootingDays,\n      returnDays: project.returnDays,\n      archived: project.archived,\n      status: project.status\n    };\n  });\n\n  // [Agent Refactor] Update Cache & Repo\n  projectIndexCache = index;\n\n  const isIndexedDB = storageRepo && storageRepo.driver && storageRepo.driver.constructor && storageRepo.driver.constructor.name === 'IndexedDBAdapter';\n  if (storageRepo) {\n    // Async write to new storage\n    storageRepo.setItem(PROJECT_INDEX_KEY, index).catch(e => console.warn('Failed to persist index to repo', e));\n  }\n\n  // Legacy writes only if NOT on IndexedDB\n  if (!isIndexedDB && safeStorage && typeof safeStorage.setItem === 'function') {\n    try {\n      safeStorage.setItem(PROJECT_INDEX_KEY, JSON.stringify(index));\n    } catch (e) {\n      console.warn('Failed to write project index', e);\n    }\n  }\n}\n\nfunction loadProject(name) {\n  const skipAutoBackupExpansion =\n    name !== undefined\n    && !(typeof name === 'string' && isAutoBackupStorageKey(name));\n\n  let { projects, changed, originalValue, lookup } = readAllProjectsFromStorage({\n    skipAutoBackupExpansion,\n  });\n  let resolvedKey = null;\n\n  if (name !== undefined) {\n    resolvedKey = resolveProjectKey(projects, lookup, name, { preferExact: true });\n    if (resolvedKey !== null && resolvedKey !== undefined) {\n      markProjectActivity(resolvedKey);\n    }\n  }\n\n  if (changed) {\n    const safeStorage = getSafeLocalStorage();\n    if (safeStorage) {\n      createStorageMigrationBackup(safeStorage, PROJECT_STORAGE_KEY, originalValue);\n    }\n    const mutableProjects = STORAGE_DEEP_CLONE(projects);\n    persistAllProjects(mutableProjects);\n    projects = mutableProjects;\n  }\n  if (name === undefined) {\n    markProjectCollectionActivity(projects);\n    return projects;\n  }\n  if (\n    resolvedKey !== null\n    && resolvedKey !== undefined\n    && Object.prototype.hasOwnProperty.call(projects, resolvedKey)\n  ) {\n    const project = projects[resolvedKey];\n    if (project && (!project.gearList || project.gearList === \"\")) {\n      const setups = loadSetups();\n      const setup = setups[resolvedKey];\n      if (setup) {\n        if (setup.gearList) {\n          project.gearList = setup.gearList;\n        }\n      }\n    }\n    return project;\n  }\n  return null;\n}\n\nfunction loadProjectMetadata() {\n  // 1. Try to load from optimized Index\n  const cachedIndex = readProjectIndex();\n  if (cachedIndex) {\n    return cachedIndex;\n  }\n\n  // 2. Fallback: Full Load (Slow)\n  // We also skip auto-backup expansion here to save memory/time\n  const loaded = readAllProjectsFromStorage({ forMutation: false, skipAutoBackupExpansion: true });\n  const result = {};\n\n  if (loaded && loaded.projects) {\n    const keys = Object.keys(loaded.projects);\n    for (let i = 0; i < keys.length; i++) {\n      const key = keys[i];\n\n      // Skip auto-backups if they leaked through\n      if (isAutoBackupStorageKey(key)) continue;\n\n      const project = loaded.projects[key];\n      if (!project) continue;\n\n      // Optimized metadata extraction\n      result[key] = {\n        color: project.color,\n        icon: project.icon,\n        lastModified: project.lastModified,\n        prepDays: project.prepDays,\n        shootingDays: project.shootingDays,\n        returnDays: project.returnDays,\n        archived: project.archived,\n        status: project.status\n      };\n    }\n\n    // 3. Self-Heal: Create the index for next time\n    const safeStorage = getSafeLocalStorage();\n    if (safeStorage) {\n      try {\n        updateProjectIndex(loaded.projects, safeStorage);\n      } catch (e) {\n        void e;\n      }\n    }\n  }\n  return result;\n}\n\nfunction sanitizeProjectNameForBackup(name) {\n  if (typeof name !== 'string') {\n    return '';\n  }\n  const collapsed = name.replace(/\\s+/g, ' ').trim();\n  if (!collapsed) {\n    return '';\n  }\n  if (collapsed.length <= 120) {\n    return collapsed;\n  }\n  return collapsed.slice(0, 120);\n}\n\nfunction formatAutoBackupTimestamp(date) {\n  const pad = (value) => String(value).padStart(2, '0');\n  return [\n    date.getFullYear(),\n    pad(date.getMonth() + 1),\n    pad(date.getDate()),\n    pad(date.getHours()),\n    pad(date.getMinutes()),\n    pad(date.getSeconds()),\n  ].join('-');\n}\n\nfunction generateDeletionBackupMetadata(projectName, projects) {\n  const now = new Date();\n  const timestamp = formatAutoBackupTimestamp(now);\n  const sanitizedName = sanitizeProjectNameForBackup(projectName);\n  const baseName = sanitizedName\n    ? `${STORAGE_AUTO_BACKUP_DELETION_PREFIX}${timestamp}-${sanitizedName}`\n    : `${STORAGE_AUTO_BACKUP_DELETION_PREFIX}${timestamp}`;\n  const usedNames = new Set(Object.keys(projects));\n  if (!usedNames.has(baseName)) {\n    return { name: baseName };\n  }\n  let suffix = 2;\n  let candidate = `${baseName}-${suffix}`;\n  while (usedNames.has(candidate)) {\n    suffix += 1;\n    candidate = `${baseName}-${suffix}`;\n  }\n  return { name: candidate };\n}\n\nfunction cloneProjectEntryForBackup(entry) {\n  if (entry === undefined) {\n    return undefined;\n  }\n  if (entry === null || typeof entry !== 'object') {\n    return entry;\n  }\n  try {\n    const cloned = STORAGE_DEEP_CLONE(entry);\n    const normalized = normalizeLegacyLongGopStructure(cloned);\n    return normalized !== cloned ? normalized : cloned;\n  } catch (error) {\n    console.warn('Unable to deep clone project for backup', error);\n    const fallback = { ...entry };\n    const normalized = normalizeLegacyLongGopStructure(fallback);\n    return normalized !== fallback ? normalized : fallback;\n  }\n}\n\nfunction maybeCreateProjectDeletionBackup(projects, key) {\n  if (!projects || !Object.prototype.hasOwnProperty.call(projects, key)) {\n    return { status: 'missing' };\n  }\n  if (typeof key === 'string' && key.startsWith(STORAGE_AUTO_BACKUP_NAME_PREFIX)) {\n    return { status: 'skipped' };\n  }\n  const entry = projects[key];\n  if (entry === undefined) {\n    return { status: 'missing' };\n  }\n  const { name: backupName } = generateDeletionBackupMetadata(key, projects);\n  if (!backupName) {\n    return { status: 'failed' };\n  }\n  const cloned = cloneProjectEntryForBackup(entry);\n  if (cloned === undefined) {\n    if (typeof console !== 'undefined' && typeof console.warn === 'function') {\n      console.warn(\n        `Skipping deletion backup for project \"${key}\" because no stored data was available during backup creation.`,\n      );\n    }\n    return { status: 'missing' };\n  }\n  projects[backupName] = cloned;\n  return { status: 'created', backupName };\n}\n\nfunction createProjectDeletionBackup(name) {\n  const { projects, changed, originalValue, lookup } = readAllProjectsFromStorage({ forMutation: true });\n  if (!projects || typeof projects !== 'object') {\n    return { status: 'invalid' };\n  }\n\n  const resolvedKey = resolveProjectKey(projects, lookup, name, { preferExact: true });\n  const normalizedName = normalizeProjectStorageKey(name);\n  const key =\n    resolvedKey !== null && resolvedKey !== undefined\n      ? resolvedKey\n      : normalizedName;\n\n  if (!Object.prototype.hasOwnProperty.call(projects, key)) {\n    return { status: 'missing' };\n  }\n\n  const backupOutcome = maybeCreateProjectDeletionBackup(projects, key);\n  if (backupOutcome.status !== 'created') {\n    return backupOutcome;\n  }\n\n  if (changed) {\n    const safeStorage = getSafeLocalStorage();\n    if (safeStorage) {\n      createStorageMigrationBackup(safeStorage, PROJECT_STORAGE_KEY, originalValue);\n    }\n  }\n\n  markProjectActivity(backupOutcome.backupName);\n  persistAllProjects(projects);\n  return backupOutcome;\n}\n\nfunction generateOverwriteBackupMetadata(projectName, projects) {\n  const timestamp = formatAutoBackupTimestamp(new Date());\n  const sanitizedName = sanitizeProjectNameForBackup(projectName);\n  const baseName = sanitizedName\n    ? `${STORAGE_AUTO_BACKUP_NAME_PREFIX}${timestamp}-${sanitizedName}`\n    : `${STORAGE_AUTO_BACKUP_NAME_PREFIX}${timestamp}`;\n  const usedNames = new Set(Object.keys(projects));\n  if (!usedNames.has(baseName)) {\n    return { name: baseName };\n  }\n  let suffix = 2;\n  let candidate = `${baseName}-${suffix}`;\n  while (usedNames.has(candidate)) {\n    suffix += 1;\n    candidate = `${baseName}-${suffix}`;\n  }\n  return { name: candidate };\n}\n\nfunction maybeCreateProjectOverwriteBackup(projects, key) {\n  if (!isPlainObject(projects) || typeof key !== 'string') {\n    return { status: 'invalid' };\n  }\n  if (!Object.prototype.hasOwnProperty.call(projects, key)) {\n    return { status: 'missing' };\n  }\n  if (\n    key.startsWith(STORAGE_AUTO_BACKUP_NAME_PREFIX)\n    || key.startsWith(STORAGE_AUTO_BACKUP_DELETION_PREFIX)\n  ) {\n    return { status: 'skipped' };\n  }\n\n  const backupSource = cloneProjectEntryForBackup(projects[key]);\n  if (backupSource === undefined) {\n    return { status: 'failed' };\n  }\n\n  const { name: backupName } = generateOverwriteBackupMetadata(key, projects);\n  if (!backupName) {\n    return { status: 'failed' };\n  }\n\n  projects[backupName] = backupSource;\n  return { status: 'created', backupName };\n}\n\n/**\n * Safe Project Persistence\n *\n * This function implements a robust \"safe save\" strategy to prevent data loss:\n * 1. NORMALIZATION: Ensures the project structure is valid and standardizes properties (e.g. trimming strings).\n * 2. MIGRATION BACKUP: If the storage snapshot has changed since the last read (detected via 'changed' flag),\n *    we create a safety backup of the PREVIOUS state before overwriting it. This protects against race conditions\n *    where two tabs might try to save, preserving the first tab's work in a backup file.\n * 3. OVERWRITE BACKUP: Before overwriting an existing project with the same name, we verify content diffs.\n *    If the content differs, we create a specific overwrite backup (e.g. \"MyProject-backup\").\n * 4. ATOMIC COMMIT: We finally write the new project data.\n *\n * @param {string} name - The intended name for the project.\n * @param {object} project - The project data object.\n * @param {object} [options] - Save options (e.g. skipOverwriteBackup, skipCompression).\n */\nfunction saveProject(name, project, options = {}) {\n  if (!isPlainObject(project)) return;\n\n  const normalized = normalizeProject(project);\n  if (!normalized) {\n    if (typeof console !== 'undefined' && typeof console.warn === 'function') {\n      console.warn(\n        `Skipped saving project \"${name || ''}\" because the payload could not be normalised.`,\n      );\n    }\n    return;\n  }\n  const skipOverwriteBackup = Boolean(options && options.skipOverwriteBackup);\n  const skipCompression = Boolean(options && options.skipCompression);\n\n  const requestedKey = typeof name === 'string' ? name : '';\n  const preferredKey = normalizeProjectStorageKey(requestedKey);\n\n  // Initial check: if what we are about to write will overwrite something that has changed\n  // on disk (via another tab), we must safeguard that data first.\n  const initialSnapshot = readAllProjectsFromStorage({ forMutation: true });\n  const initialProjects = isPlainObject(initialSnapshot.projects) ? initialSnapshot.projects : {};\n  if (initialSnapshot.changed) {\n    const safeStorage = getSafeLocalStorage();\n    if (safeStorage) {\n      // [SAFETY] Create a migration backup to preserve the state before this write.\n      createStorageMigrationBackup(safeStorage, PROJECT_STORAGE_KEY, initialSnapshot.originalValue);\n    }\n  }\n\n  const initialResolvedKey = resolveProjectKey(\n    initialProjects,\n    initialSnapshot.lookup,\n    requestedKey,\n    { preferExact: true },\n  );\n  const initialExistingEntry =\n    initialResolvedKey !== null\n      && initialResolvedKey !== undefined\n      && Object.prototype.hasOwnProperty.call(initialProjects, initialResolvedKey)\n      ? initialProjects[initialResolvedKey]\n      : null;\n  const initialExistingSignature = initialExistingEntry\n    ? createStableValueSignature(initialExistingEntry)\n    : null;\n\n  // ... (Re-read and Resolve Logic) ...\n\n  const latestSnapshot = readAllProjectsFromStorage({ forMutation: true });\n  const projects = isPlainObject(latestSnapshot.projects) ? latestSnapshot.projects : {};\n  if (latestSnapshot.changed) {\n    const safeStorage = getSafeLocalStorage();\n    if (safeStorage) {\n      // [SAFETY] Double-check safeguards if a race condition happened between the checks.\n      createStorageMigrationBackup(safeStorage, PROJECT_STORAGE_KEY, latestSnapshot.originalValue);\n    }\n  }\n\n  const resolvedKey = resolveProjectKey(projects, latestSnapshot.lookup, requestedKey, { preferExact: true });\n\n  let storageKey = resolvedKey;\n  let renamedFromKey = null;\n  if (\n    preferredKey\n    && preferredKey !== resolvedKey\n    && !Object.prototype.hasOwnProperty.call(projects, preferredKey)\n  ) {\n    storageKey = preferredKey;\n    renamedFromKey = resolvedKey;\n  }\n\n  if (storageKey === null || storageKey === undefined) {\n    storageKey = preferredKey;\n  }\n\n  if (!storageKey && storageKey !== '') {\n    storageKey = '';\n  }\n\n  const existingKey = renamedFromKey !== null && renamedFromKey !== undefined\n    ? renamedFromKey\n    : storageKey;\n  const hasExistingEntry =\n    existingKey !== null\n    && existingKey !== undefined\n    && Object.prototype.hasOwnProperty.call(projects, existingKey);\n  const existingEntry = hasExistingEntry ? projects[existingKey] : null;\n\n  if (hasExistingEntry && !skipOverwriteBackup) {\n    const existingSignature = createStableValueSignature(existingEntry);\n    const nextSignature = createStableValueSignature(normalized);\n    if (existingSignature !== nextSignature) {\n      // [SAFETY] Overwrite Protection: If we are modifying an existing project, create a specific backup.\n      const backupOutcome = maybeCreateProjectOverwriteBackup(projects, existingKey);\n      if (backupOutcome.status === 'failed') {\n        console.warn(\n          `Automatic backup before overwriting project \"${existingKey}\" failed. Proceeding with save.`,\n        );\n      }\n    }\n  }\n\n  if (\n    renamedFromKey !== null\n    && renamedFromKey !== undefined\n    && renamedFromKey !== storageKey\n  ) {\n    // Logic to safely handle renames by deleting the old key only if it hasn't changed.\n    let shouldDelete = Boolean(initialExistingSignature);\n    if (Object.prototype.hasOwnProperty.call(projects, renamedFromKey)) {\n      if (initialExistingSignature) {\n        const latestSignature = createStableValueSignature(projects[renamedFromKey]);\n        if (latestSignature !== initialExistingSignature) {\n          shouldDelete = false;\n        }\n      } else {\n        shouldDelete = false;\n      }\n    } else {\n      shouldDelete = false;\n    }\n\n    if (shouldDelete) {\n      delete projects[renamedFromKey];\n      removeProjectActivity(renamedFromKey);\n    } else if (typeof console !== 'undefined' && typeof console.warn === 'function') {\n      console.warn(\n        `Skipped removing \"${renamedFromKey}\" while saving \"${storageKey}\" because the original entry changed in another tab.`,\n      );\n    }\n  }\n\n  // Explicit rename handling from options (e.g. from handleSaveSetupClick)\n  const manualRenamedFrom = options && options.renamedFrom;\n  if (manualRenamedFrom && manualRenamedFrom !== storageKey) {\n    const resolvedOld = resolveProjectKey(projects, latestSnapshot.lookup, manualRenamedFrom, { preferExact: true });\n    if (resolvedOld && Object.prototype.hasOwnProperty.call(projects, resolvedOld)) {\n      delete projects[resolvedOld];\n      removeProjectActivity(resolvedOld);\n    }\n  }\n\n  const finalKey = storageKey || '';\n  projects[finalKey] = normalized;\n  markProjectActivity(finalKey);\n\n  // Prune within the projects object first (handling auto-backup counts)\n  enforceAutoBackupLimits(projects);\n\n  // [Agent Refactor] Dual-Write to StorageRepository & Memory Cache\n  // This ensures the new DB is always current.\n  if (storageRepo) {\n    storageRepo.saveProject(finalKey, normalized).catch(err => console.warn('[saveProject] Repo write failed', err));\n  }\n  if (isProjectCacheHydrated) {\n    projectMemoryCache[finalKey] = normalized;\n  }\n\n  // Instead of calling persistAllProjects(projects), which would trigger a massive monolithic rewrite,\n  // we now use sharded persistence for the specific project being saved.\n  // [Agent Refactor] Skip legacy LocalStorage write if we are using IndexedDB to avoid quota errors.\n  const isIndexedDB = storageRepo && storageRepo.driver && storageRepo.driver.constructor && storageRepo.driver.constructor.name === 'IndexedDBAdapter';\n  let shardSuccess = true;\n\n  if (!isIndexedDB) {\n    shardSuccess = persistProjectShard(finalKey, normalized, { skipCompression });\n  }\n\n  if (shardSuccess) {\n    const safeStorage = getSafeLocalStorage();\n    // Clean up shards that are no longer in the projects map (renames or pruned backups)\n    pruneOrphanProjectShards(safeStorage, projects);\n    // Ensure migration from monolithic is finalized\n    cleanupMonolithicProjectStorage(safeStorage);\n\n    // Trigger cross-tab invalidation.\n    invalidateProjectReadCache();\n    if (lifecycleChannel) {\n      try {\n        lifecycleChannel.postMessage('project-shards-changed');\n      } catch (e) {\n        void e;\n      }\n    }\n    bumpProjectStorageRevision(safeStorage);\n  } else {\n    // Fallback for extreme cases (storage issues), though persistAllProjects would likely fail too.\n    persistAllProjects(projects, { skipCompression });\n  }\n}\n\nfunction deleteProject(name) {\n  if (name === undefined) {\n    // ... (Factory reset logic) ...\n    const storagesToPrune = [getSafeLocalStorage()];\n    if (typeof localStorage !== 'undefined' && storagesToPrune.indexOf(localStorage) === -1) {\n      storagesToPrune.push(localStorage);\n    }\n\n    storagesToPrune.forEach((storage) => {\n      // Force delete primary and backup keys directly first to ensure factory reset reliability\n      if (storage && typeof storage.removeItem === 'function') {\n        try {\n          storage.removeItem(PROJECT_STORAGE_KEY);\n          const backupSuffix = typeof STORAGE_BACKUP_SUFFIX === 'string' ? STORAGE_BACKUP_SUFFIX : '__backup';\n          storage.removeItem(`${PROJECT_STORAGE_KEY}${backupSuffix}`);\n          // Also remove hardcoded potential legacy/default backup key just in case\n          storage.removeItem('cameraPowerPlanner_project__backup');\n        } catch (e) {\n          console.warn(`[FactoryReset] Failed to force delete project keys`, e);\n        }\n      }\n\n      deleteFromStorage(\n        storage,\n        PROJECT_STORAGE_KEY,\n        \"Error deleting project from storage:\",\n      );\n\n      if (storage && typeof storage.length === 'number') {\n        const shardKeys = [];\n        for (let i = 0; i < storage.length; i++) {\n          const key = storage.key(i);\n          if (key && key.startsWith(PROJECT_SHARD_PREFIX)) {\n            shardKeys.push(key);\n          }\n        }\n        shardKeys.forEach((key) => deleteFromStorage(\n          storage,\n          key,\n          \"Error deleting project shard from storage:\",\n        ));\n      }\n    });\n\n    // [Refactor] Clear IndexedDB and OPFS Data Vault\n    // This ensures a true Factory Reset across all storage layers.\n    try {\n      if (storageRepo) {\n        storageRepo.clear().catch(e => console.warn('[FactoryReset] Failed to clear StorageRepository', e));\n      }\n      if (dataVault) {\n        dataVault.clear().catch(e => console.warn('[FactoryReset] Failed to clear DataVault', e));\n      }\n      if (userContext) {\n        userContext.reset();\n      }\n    } catch (e) {\n      console.warn('[FactoryReset] Error clearing modern storage', e);\n    }\n    // ... (Clear UI caches and notify tabs) ...\n    if (typeof clearUiCacheStorageEntries === 'function') {\n      try {\n        clearUiCacheStorageEntries();\n      } catch (uiCacheError) {\n        console.warn('Failed to clear UI cache during project deletion', uiCacheError);\n      }\n    }\n\n    invalidateProjectReadCache();\n    if (lifecycleChannel) { try { lifecycleChannel.postMessage('project-shards-changed'); } catch (e) { void e; } }\n    if (projectActivityTimestamps && typeof projectActivityTimestamps.clear === 'function') {\n      projectActivityTimestamps.clear();\n    }\n    const currentSafeStorage = getSafeLocalStorage();\n    if (currentSafeStorage) {\n      bumpProjectStorageRevision(currentSafeStorage);\n    }\n    return;\n  }\n\n  const { projects, changed, originalValue, lookup } = readAllProjectsFromStorage({ forMutation: true });\n  if (changed) {\n    const safeStorage = getSafeLocalStorage();\n    if (safeStorage) {\n      createStorageMigrationBackup(safeStorage, PROJECT_STORAGE_KEY, originalValue);\n    }\n  }\n  const resolvedKey = resolveProjectKey(projects, lookup, name, { preferExact: true });\n  const key =\n    resolvedKey !== null && resolvedKey !== undefined\n      ? resolvedKey\n      : normalizeProjectStorageKey(name);\n\n  if (!Object.prototype.hasOwnProperty.call(projects, key)) {\n    // If key not found in project map, try deleting potential orphan shard directly\n    const potentialShardKey = PROJECT_SHARD_PREFIX + normalizeProjectStorageKey(name);\n    const safeStorage = getSafeLocalStorage();\n    if (safeStorage) {\n      deleteFromStorage(safeStorage, potentialShardKey, \"Error deleting orphan project shard:\");\n    }\n    return;\n  }\n\n  // [SAFETY] Create a \"Deletion Backup\" (undoable operation support)\n  const backupOutcome = maybeCreateProjectDeletionBackup(projects, key);\n  if (backupOutcome.status === 'failed') {\n    console.warn(`Automatic backup before deleting project \"${key}\" failed. Deletion aborted.`);\n    alertStorageError();\n    return;\n  }\n  const shardKey = PROJECT_SHARD_PREFIX + normalizeProjectStorageKey(key);\n  const safeStorage = getSafeLocalStorage();\n  // [Agent Refactor] Skip legacy LocalStorage delete if we are using IndexedDB\n  const isIndexedDB = storageRepo && storageRepo.driver && storageRepo.driver.constructor && storageRepo.driver.constructor.name === 'IndexedDBAdapter';\n\n  if (safeStorage && !isIndexedDB) {\n    deleteFromStorage(safeStorage, shardKey, \"Error deleting project shard:\");\n  }\n  // Update Memory Cache\n  if (isProjectCacheHydrated) {\n    delete projectMemoryCache[key];\n  }\n\n  // Update StorageRepository (Async)\n  // We fire and forget the delete, but UI updates immediately via cache/events\n  storageRepo.removeItem(key).catch(e => console.warn('Failed to delete from repo', e));\n\n  delete projects[key];\n  removeProjectActivity(key);\n  // persistAllProjects(projects); // Legacy persistence\n\n  // Dispatch events\n  invalidateProjectReadCache();\n  if (lifecycleChannel) { try { lifecycleChannel.postMessage('project-shards-changed'); } catch (e) { void e; } }\n}\n\nfunction renameProject(oldName, newName) {\n  if (!oldName || !newName) return null;\n  // Use read logic to get current state (memory or storage)\n  const { projects } = readAllProjectsFromStorage({ forMutation: true });\n\n  // Resolve keys\n  const resolvedKey = resolveProjectKey(projects, null, oldName, { preferExact: true });\n  if (!resolvedKey || !projects[resolvedKey]) {\n    return null;\n  }\n\n  const targetName = newName.trim();\n  if (!targetName || targetName === resolvedKey) {\n    return resolvedKey;\n  }\n\n  const projectData = projects[resolvedKey];\n  projectData.name = targetName; // Update internal name\n\n  // Update Memory Cache\n  if (isProjectCacheHydrated) {\n    delete projectMemoryCache[resolvedKey];\n    projectMemoryCache[targetName] = projectData;\n  } else {\n    // Legacy fallback: modify local map passed from readAllProjects\n    delete projects[resolvedKey];\n    projects[targetName] = projectData;\n  }\n\n  // Update Storage (Async)\n  storageRepo.removeItem(resolvedKey).catch(e => console.warn('Failed to delete old project key', e));\n  // We use the new saveProject which handles repo save + cache update redundancy\n  saveProject(targetName, projectData);\n\n  // Dispatch events\n  invalidateProjectReadCache();\n  if (lifecycleChannel) { try { lifecycleChannel.postMessage('project-shards-changed'); } catch (e) { void e; } }\n\n  return targetName;\n}\n\nfunction createProjectImporter() {\n  const { projects, changed, originalValue } = readAllProjectsFromStorage({ forMutation: true });\n  if (changed) {\n    const safeStorage = getSafeLocalStorage();\n    if (safeStorage) {\n      createStorageMigrationBackup(safeStorage, PROJECT_STORAGE_KEY, originalValue);\n    }\n  }\n  const usedNames = new Set(Object.keys(projects));\n  const normalizedNames = new Set(\n    [...usedNames].map((name) => name.trim().toLowerCase()),\n  );\n  const defaultName = \"Imported project\";\n\n  return (rawName, project, fallbackName = defaultName) => {\n    const normalizedProject = normalizeProject(project);\n    if (!normalizedProject) return;\n\n    const originalHasGenerationFlag =\n      project\n      && typeof project === \"object\"\n      && Object.prototype.hasOwnProperty.call(project, \"gearListAndProjectRequirementsGenerated\")\n      && typeof project.gearListAndProjectRequirementsGenerated === \"boolean\";\n\n    if (\n      !originalHasGenerationFlag\n      && typeof normalizedProject.gearListAndProjectRequirementsGenerated !== 'boolean'\n    ) {\n      normalizedProject.gearListAndProjectRequirementsGenerated = false;\n    }\n\n    const candidates = [];\n    if (typeof rawName === \"string\") {\n      candidates.push(rawName.trim());\n    }\n    if (isPlainObject(project)) {\n      if (typeof project.name === \"string\") {\n        candidates.push(project.name.trim());\n      }\n      const info = project.projectInfo;\n      if (isPlainObject(info) && typeof info.projectName === \"string\") {\n        candidates.push(info.projectName.trim());\n      }\n    }\n\n\n    const fallback = typeof fallbackName === \"string\" && fallbackName.trim()\n      ? fallbackName.trim()\n      : defaultName;\n\n    const baseName = candidates.length > 0 ? candidates[0] : fallback;\n    const normalizedBase = typeof baseName === \"string\" ? baseName.trim().toLowerCase() : \"\";\n    const uniqueName = normalizedNames.has(normalizedBase)\n      ? generateImportedProjectName(baseName, usedNames, normalizedNames)\n      : generateUniqueName(baseName, usedNames, normalizedNames);\n    saveProject(uniqueName, normalizedProject, { skipCompression: false });\n  };\n}\n\nfunction tryParseJSONLike(value) {\n  if (typeof value !== \"string\") {\n    return { success: false, parsed: null };\n  }\n\n  const trimmed = value.trim();\n  if (!trimmed) {\n    return { success: false, parsed: null };\n  }\n\n  const firstChar = trimmed[0];\n  const lastChar = trimmed[trimmed.length - 1];\n  let expectedClosing = null;\n  if (firstChar === \"{\") {\n    expectedClosing = \"}\";\n  } else if (firstChar === \"[\") {\n    expectedClosing = \"]\";\n  } else if (firstChar === \"\\\"\") {\n    expectedClosing = \"\\\"\";\n  }\n\n  if (!expectedClosing || lastChar !== expectedClosing) {\n    return { success: false, parsed: null };\n  }\n\n  try {\n    return { success: true, parsed: JSON.parse(trimmed) };\n  } catch (error) {\n    void error;\n    return { success: false, parsed: null };\n  }\n}\n\nfunction importProjectCollection(collection, ensureImporter, fallbackLabel = \"Imported project\") {\n  if (typeof collection === \"string\") {\n    const parsed = tryParseJSONLike(collection);\n    if (parsed.success) {\n      return importProjectCollection(parsed.parsed, ensureImporter, fallbackLabel);\n    }\n\n    const importProject = ensureImporter();\n    importProject(fallbackLabel, collection, fallbackLabel);\n    return true;\n  }\n\n  if (isMapLike(collection)) {\n    const converted = convertMapLikeToObject(collection);\n    if (converted) {\n      return importProjectCollection(Object.entries(converted), ensureImporter, fallbackLabel);\n    }\n    return false;\n  }\n\n  if (Array.isArray(collection)) {\n    const entries = collection\n      .map((proj) => {\n        if (proj === null || proj === undefined) {\n          return null;\n        }\n        if (Array.isArray(proj) && proj.length >= 2) {\n          return { name: proj[0], project: proj[1] };\n        }\n        if (isPlainObject(proj) && typeof proj.name === \"string\") {\n          return { name: proj.name, project: proj };\n        }\n        return { name: '', project: proj };\n      })\n      .filter(Boolean);\n\n    if (!entries.length) {\n      return true;\n    }\n\n    const importProject = ensureImporter();\n    let count = 0;\n    entries.forEach(({ name, project }) => {\n      if (project === null || project === undefined) {\n        return;\n      }\n      count += 1;\n      let normalizedName = '';\n      if (typeof name === 'string') {\n        normalizedName = name;\n      } else if (typeof name === 'number' || typeof name === 'boolean' || typeof name === 'bigint') {\n        normalizedName = String(name);\n      } else if (typeof name === 'symbol') {\n        normalizedName = name.description || name.toString();\n      }\n      importProject(normalizedName, project, `${fallbackLabel} ${count}`);\n    });\n    return true;\n  }\n\n  if (isPlainObject(collection)) {\n    const importProject = ensureImporter();\n    Object.entries(collection).forEach(([name, proj]) => {\n      const normalizedName = typeof name === 'string' ? name : convertMapLikeKey(name);\n      importProject(\n        typeof normalizedName === 'string' && normalizedName\n          ? normalizedName\n          : fallbackLabel,\n        proj,\n        fallbackLabel,\n      );\n    });\n    return true;\n  }\n\n  return false;\n}\n\nfunction collectLegacyProjectCollections(container) {\n  if (!container || typeof container !== \"object\") {\n    return [];\n  }\n\n  const collections = [];\n  const addCollection = (value) => {\n    if (value === null || value === undefined) {\n      return;\n    }\n    collections.push(value);\n  };\n\n  const legacyKeys = [\n    \"projectData\",\n    \"projectCollection\",\n    \"projectEntries\",\n    \"legacyProjects\",\n    \"legacyProjectData\",\n  ];\n\n  legacyKeys.forEach((key) => {\n    if (Object.prototype.hasOwnProperty.call(container, key)) {\n      addCollection(container[key]);\n    }\n  });\n\n  if (isPlainObject(container.data)) {\n    if (Object.prototype.hasOwnProperty.call(container.data, \"project\")) {\n      addCollection(container.data.project);\n    }\n    if (Object.prototype.hasOwnProperty.call(container.data, \"projects\")) {\n      addCollection(container.data.projects);\n    }\n  }\n\n  const plannerData = container.plannerData;\n  if (Array.isArray(plannerData)) {\n    plannerData.forEach((entry) => {\n      if (Array.isArray(entry) && entry.length >= 2) {\n        const key = entry[0];\n        if (typeof key === \"string\" && key.toLowerCase().includes(\"project\")) {\n          addCollection(entry[1]);\n        }\n        return;\n      }\n\n      if (!entry || typeof entry !== \"object\") {\n        return;\n      }\n\n      const key = typeof entry.key === \"string\"\n        ? entry.key\n        : typeof entry.name === \"string\"\n          ? entry.name\n          : typeof entry.id === \"string\"\n            ? entry.id\n            : typeof entry.section === \"string\"\n              ? entry.section\n              : null;\n\n      if (!key || !key.toLowerCase().includes(\"project\")) {\n        return;\n      }\n\n      const value = Object.prototype.hasOwnProperty.call(entry, \"value\")\n        ? entry.value\n        : Object.prototype.hasOwnProperty.call(entry, \"data\")\n          ? entry.data\n          : Object.prototype.hasOwnProperty.call(entry, \"project\")\n            ? entry.project\n            : Object.prototype.hasOwnProperty.call(entry, \"projects\")\n              ? entry.projects\n              : null;\n\n      if (value !== null && value !== undefined) {\n        addCollection(value);\n      }\n    });\n  }\n\n  return collections;\n}\n\n// --- Favorites Storage ---\nfunction loadFavorites() {\n  applyLegacyStorageMigrations();\n  const safeStorage = getSafeLocalStorage();\n  const parsed = loadJSONFromStorage(\n    safeStorage,\n    FAVORITES_STORAGE_KEY,\n    \"Error loading favorites from localStorage:\",\n    {},\n    { validate: (value) => value === null || isPlainObject(value) },\n  );\n  return isPlainObject(parsed) ? parsed : {};\n}\n\nfunction saveFavorites(favs) {\n  const safeStorage = getSafeLocalStorage();\n  if (favs === null || favs === undefined) {\n    deleteFromStorage(\n      safeStorage,\n      FAVORITES_STORAGE_KEY,\n      \"Error deleting favorites from localStorage:\",\n    );\n    return;\n  }\n\n  if (!isPlainObject(favs)) {\n    console.warn('Ignoring invalid favorites payload. Expected a plain object.');\n    return;\n  }\n\n  ensurePreWriteMigrationBackup(safeStorage, FAVORITES_STORAGE_KEY);\n  saveJSONToStorage(\n    safeStorage,\n    FAVORITES_STORAGE_KEY,\n    favs,\n    \"Error saving favorites to localStorage:\",\n  );\n}\n\nfunction resolveContactsModuleApi() {\n  if (CONTACTS_MODULE_API) {\n    return CONTACTS_MODULE_API;\n  }\n\n  if (!CONTACTS_MODULE_RESOLUTION_ATTEMPTED) {\n    CONTACTS_MODULE_RESOLUTION_ATTEMPTED = true;\n    if (contactsModuleImport) {\n      CONTACTS_MODULE_API = contactsModuleImport;\n    }\n  }\n\n  if (CONTACTS_MODULE_API) {\n    return CONTACTS_MODULE_API;\n  }\n\n  const scope = GLOBAL_SCOPE && typeof GLOBAL_SCOPE === 'object' ? GLOBAL_SCOPE : null;\n  if (scope && scope.cineFeaturesContacts && typeof scope.cineFeaturesContacts === 'object') {\n    CONTACTS_MODULE_API = scope.cineFeaturesContacts;\n    return CONTACTS_MODULE_API;\n  }\n\n  const moduleBase = scope && typeof scope.cineModuleBase === 'object' ? scope.cineModuleBase : null;\n  if (moduleBase && typeof moduleBase.resolveModule === 'function') {\n    try {\n      const resolved = moduleBase.resolveModule('cine.features.contacts', scope);\n      if (resolved && typeof resolved === 'object') {\n        CONTACTS_MODULE_API = resolved;\n        return CONTACTS_MODULE_API;\n      }\n    } catch (error) {\n      void error;\n    }\n  }\n\n  return CONTACTS_MODULE_API;\n}\n\nfunction fallbackSanitizeContactValue(value) {\n  if (typeof value === 'string') {\n    return value.trim();\n  }\n\n  if (typeof value === 'number') {\n    if (!Number.isFinite(value)) {\n      return '';\n    }\n    return String(value).trim();\n  }\n\n  if (typeof value === 'bigint') {\n    try {\n      return value.toString();\n    } catch (bigintError) {\n      void bigintError;\n    }\n    return '';\n  }\n\n  if (typeof value === 'boolean') {\n    return value ? 'true' : 'false';\n  }\n\n  if (value && typeof value === 'object') {\n    try {\n      const primitive = value.valueOf();\n      if (primitive !== value) {\n        return fallbackSanitizeContactValue(primitive);\n      }\n\n      if (typeof value.toString === 'function') {\n        const stringified = value.toString();\n        if (typeof stringified === 'string' && stringified && stringified !== '[object Object]') {\n          return stringified.trim();\n        }\n      }\n    } catch (coercionError) {\n      void coercionError;\n    }\n  }\n\n  return '';\n}\n\nfunction fallbackGenerateContactId(moduleApi) {\n  if (moduleApi && typeof moduleApi.generateContactId === 'function') {\n    try {\n      const generated = moduleApi.generateContactId();\n      if (typeof generated === 'string' && generated) {\n        return generated;\n      }\n    } catch (error) {\n      void error;\n    }\n  }\n  return `contact-${Date.now().toString(36)}-${Math.random().toString(36).slice(2, 8)}`;\n}\n\nfunction fallbackNormalizeContactEntry(entry, moduleApi) {\n  if (!entry || typeof entry !== 'object') {\n    return null;\n  }\n\n  const sanitize = fallbackSanitizeContactValue;\n  const id = sanitize(entry.id) || fallbackGenerateContactId(moduleApi);\n  const name = sanitize(entry.name);\n  const role = sanitize(entry.role);\n  const phone = sanitize(entry.phone);\n  const email = sanitize(entry.email);\n  const website = sanitize(entry.website || entry.url);\n  const notes = sanitize(entry.notes || entry.note || entry.text);\n  const avatarSource = typeof entry.avatar === 'string' ? entry.avatar.trim() : '';\n  const avatar = avatarSource && avatarSource.startsWith('data:') ? avatarSource : '';\n  const createdAt = Number.isFinite(entry.createdAt) ? entry.createdAt : Date.now();\n  const updatedAt = Number.isFinite(entry.updatedAt) ? entry.updatedAt : createdAt;\n\n  const normalized = { id, name, role, phone, email, website, notes, createdAt, updatedAt };\n  if (avatar) {\n    normalized.avatar = avatar;\n  }\n\n  return normalized;\n}\n\nfunction fallbackSortContacts(list) {\n  if (!Array.isArray(list)) {\n    return [];\n  }\n\n  const cloned = list\n    .filter((entry) => entry && typeof entry === 'object')\n    .map((entry) => ({ ...entry }));\n\n  cloned.sort((a, b) => {\n    const nameA = (a && a.name ? a.name : '').toLowerCase();\n    const nameB = (b && b.name ? b.name : '').toLowerCase();\n    if (nameA && nameB && nameA !== nameB) {\n      try {\n        return nameA.localeCompare(nameB);\n      } catch (error) {\n        void error;\n      }\n    }\n    if (nameA && !nameB) {\n      return -1;\n    }\n    if (!nameA && nameB) {\n      return 1;\n    }\n    const createdA = a && typeof a.createdAt === 'number' ? a.createdAt : 0;\n    const createdB = b && typeof b.createdAt === 'number' ? b.createdAt : 0;\n    return createdA - createdB;\n  });\n\n  return cloned;\n}\n\nfunction normalizeContactsList(entries) {\n  if (!Array.isArray(entries)) {\n    return [];\n  }\n\n  const moduleApi = resolveContactsModuleApi();\n\n  if (moduleApi && typeof moduleApi.sortContacts === 'function') {\n    try {\n      const sorted = moduleApi.sortContacts(entries);\n      if (Array.isArray(sorted)) {\n        return sorted.filter((entry) => entry && typeof entry === 'object');\n      }\n    } catch (error) {\n      if (typeof console !== 'undefined' && typeof console.warn === 'function') {\n        console.warn('Error normalizing contacts via module.', error);\n      }\n    }\n  }\n\n  const normalizer = moduleApi && typeof moduleApi.normalizeContactEntry === 'function'\n    ? moduleApi.normalizeContactEntry\n    : null;\n\n  const normalized = [];\n  for (let index = 0; index < entries.length; index += 1) {\n    const entry = entries[index];\n    if (!entry) {\n      continue;\n    }\n\n    let normalizedEntry = null;\n    if (normalizer) {\n      try {\n        normalizedEntry = normalizer(entry);\n      } catch (error) {\n        if (typeof console !== 'undefined' && typeof console.warn === 'function') {\n          console.warn('Error normalizing contact entry via module.', error);\n        }\n        normalizedEntry = null;\n      }\n    }\n\n    if (!normalizedEntry) {\n      normalizedEntry = fallbackNormalizeContactEntry(entry, moduleApi);\n    }\n\n    if (normalizedEntry && typeof normalizedEntry === 'object') {\n      normalized.push(normalizedEntry);\n    }\n  }\n\n  return fallbackSortContacts(normalized);\n}\n\nfunction loadContacts() {\n  applyLegacyStorageMigrations();\n  const safeStorage = getSafeLocalStorage();\n  const parsed = loadJSONFromStorage(\n    safeStorage,\n    CONTACTS_STORAGE_KEY,\n    'Error loading contacts from localStorage:',\n    [],\n    { validate: (value) => value === null || Array.isArray(value) },\n  );\n  if (!Array.isArray(parsed)) {\n    return [];\n  }\n  return normalizeContactsList(parsed);\n}\n\nfunction saveContacts(contacts) {\n  const safeStorage = getSafeLocalStorage();\n  if (contacts === null || contacts === undefined) {\n    deleteFromStorage(\n      safeStorage,\n      CONTACTS_STORAGE_KEY,\n      'Error deleting contacts from localStorage:',\n    );\n    return;\n  }\n\n  if (!Array.isArray(contacts)) {\n    console.warn('Ignoring invalid contacts payload. Expected an array.');\n    return;\n  }\n\n  const normalized = normalizeContactsList(contacts);\n  ensurePreWriteMigrationBackup(safeStorage, CONTACTS_STORAGE_KEY);\n  saveJSONToStorage(\n    safeStorage,\n    CONTACTS_STORAGE_KEY,\n    normalized,\n    'Error saving contacts to localStorage:',\n    {\n      disableCompression: false,\n      forceCompressionOnQuota: true,\n    },\n  );\n}\n\n\n\nfunction loadOwnGear() {\n  return gearRepo.getOwnGear();\n}\n\nfunction saveOwnGear(data) {\n  return gearRepo.saveOwnGear(data);\n}\n\nfunction normalizeUserProfileField(value) {\n  if (typeof value === 'string') {\n    return value.trim();\n  }\n\n  if (typeof value === 'number' && Number.isFinite(value)) {\n    return String(value);\n  }\n\n  if (typeof value === 'bigint') {\n    return value.toString();\n  }\n\n  if (value && typeof value === 'object') {\n    try {\n      const primitive = value.valueOf();\n      if (primitive !== value) {\n        return normalizeUserProfileField(primitive);\n      }\n\n      if (typeof value.toString === 'function') {\n        const stringified = value.toString();\n        if (typeof stringified === 'string' && stringified && stringified !== '[object Object]') {\n          return stringified.trim();\n        }\n      }\n    } catch (coercionError) {\n      void coercionError;\n    }\n  }\n\n  return '';\n}\n\nfunction normalizeUserProfile(entry) {\n  if (!entry || typeof entry !== 'object') {\n    return null;\n  }\n\n  const name = normalizeUserProfileField(entry.name);\n  const role = normalizeUserProfileField(entry.role);\n  const avatarSource = normalizeUserProfileField(entry.avatar);\n  const avatar = avatarSource && avatarSource.toLowerCase().startsWith('data:')\n    ? avatarSource\n    : '';\n  const phone = normalizeUserProfileField(entry.phone);\n  const email = normalizeUserProfileField(entry.email);\n\n  if (!name && !role && !avatar && !phone && !email) {\n    return { name: '', role: '', avatar: '', phone: '', email: '' };\n  }\n\n  return { name, role, avatar, phone, email };\n}\n\nfunction loadUserProfile() {\n  applyLegacyStorageMigrations();\n  const safeStorage = getSafeLocalStorage();\n  const parsed = loadJSONFromStorage(\n    safeStorage,\n    USER_PROFILE_STORAGE_KEY,\n    'Error loading user profile from localStorage:',\n    null,\n    { validate: (value) => value === null || isPlainObject(value) },\n  );\n  if (!isPlainObject(parsed)) {\n    return { name: '', role: '', avatar: '', phone: '', email: '' };\n  }\n  return normalizeUserProfile(parsed) || { name: '', role: '', avatar: '', phone: '', email: '' };\n}\n\nfunction saveUserProfile(profile) {\n  const safeStorage = getSafeLocalStorage();\n  if (profile === null || profile === undefined) {\n    deleteFromStorage(\n      safeStorage,\n      USER_PROFILE_STORAGE_KEY,\n      'Error deleting user profile from localStorage:',\n    );\n    return;\n  }\n\n  const normalized = normalizeUserProfile(profile) || { name: '', role: '', avatar: '', phone: '', email: '' };\n  if (!normalized.name && !normalized.role && !normalized.avatar && !normalized.phone && !normalized.email) {\n    deleteFromStorage(\n      safeStorage,\n      USER_PROFILE_STORAGE_KEY,\n      'Error deleting user profile from localStorage:',\n    );\n    return;\n  }\n\n  ensurePreWriteMigrationBackup(safeStorage, USER_PROFILE_STORAGE_KEY);\n  saveJSONToStorage(\n    safeStorage,\n    USER_PROFILE_STORAGE_KEY,\n    normalized,\n    'Error saving user profile to localStorage:',\n    {\n      disableCompression: false,\n      forceCompressionOnQuota: true,\n      enableCompressionSweep: false,\n    },\n  );\n}\n\n// --- User Feedback Storage ---\nfunction loadFeedback() {\n  applyLegacyStorageMigrations();\n  const safeStorage = getSafeLocalStorage();\n  const parsed = loadJSONFromStorage(\n    safeStorage,\n    FEEDBACK_STORAGE_KEY,\n    \"Error loading feedback from localStorage:\",\n    null,\n    { validate: (value) => value === null || isPlainObject(value) },\n  );\n  if (isPlainObject(parsed)) {\n    return parsed;\n  }\n  return {};\n}\n\nfunction saveFeedback(feedback) {\n  const safeStorage = getSafeLocalStorage();\n  if (feedback === null || feedback === undefined) {\n    deleteFromStorage(\n      safeStorage,\n      FEEDBACK_STORAGE_KEY,\n      \"Error deleting feedback from localStorage:\",\n    );\n    return;\n  }\n\n  if (!isPlainObject(feedback)) {\n    console.warn('Ignoring invalid feedback payload. Expected a plain object.');\n    return;\n  }\n\n  ensurePreWriteMigrationBackup(safeStorage, FEEDBACK_STORAGE_KEY);\n  saveJSONToStorage(\n    safeStorage,\n    FEEDBACK_STORAGE_KEY,\n    feedback,\n    \"Error saving feedback to localStorage:\",\n  );\n}\n\nfunction normalizeFullBackupHistoryEntry(entry) {\n  if (!entry) {\n    return null;\n  }\n\n  if (typeof entry === 'string') {\n    const trimmed = entry.trim();\n    return trimmed ? { createdAt: trimmed } : null;\n  }\n\n  if (typeof entry === 'object') {\n    const createdAt = typeof entry.createdAt === 'string' && entry.createdAt.trim()\n      ? entry.createdAt.trim()\n      : typeof entry.iso === 'string' && entry.iso.trim()\n        ? entry.iso.trim()\n        : typeof entry.timestamp === 'string' && entry.timestamp.trim()\n          ? entry.timestamp.trim()\n          : null;\n    if (!createdAt) {\n      return null;\n    }\n    const normalized = { createdAt };\n    if (typeof entry.fileName === 'string' && entry.fileName.trim()) {\n      normalized.fileName = entry.fileName.trim();\n    } else if (typeof entry.name === 'string' && entry.name.trim()) {\n      normalized.fileName = entry.name.trim();\n    }\n    return normalized;\n  }\n\n  return null;\n}\n\nfunction loadFullBackupHistory() {\n  // [Migration] Use cache if available (hydrated from storageRepo)\n  if (fullBackupHistoryCache !== null) {\n    const cached = fullBackupHistoryCache;\n    if (Array.isArray(cached)) {\n      return cached.map(normalizeFullBackupHistoryEntry).filter(Boolean);\n    }\n  }\n\n  // Fallback to legacy localStorage for first load or if cache not yet hydrated\n  applyLegacyStorageMigrations();\n  const safeStorage = getSafeLocalStorage();\n  const parsed = loadJSONFromStorage(\n    safeStorage,\n    FULL_BACKUP_HISTORY_STORAGE_KEY,\n    \"Error loading full backup history from localStorage:\",\n    [],\n    { validate: (value) => value === null || Array.isArray(value) },\n  );\n  if (!Array.isArray(parsed)) {\n    return [];\n  }\n  const normalized = parsed.map(normalizeFullBackupHistoryEntry).filter(Boolean);\n\n  // Hydrate cache for future reads\n  fullBackupHistoryCache = normalized;\n\n  // Async persist to new storage system (fire-and-forget migration)\n  storageRepo.setItem(FULL_BACKUP_HISTORY_STORAGE_KEY, normalized).catch(err => {\n    console.warn('[storage.js] Failed to persist backup history to new storage:', err);\n  });\n\n  return normalized;\n}\n\nfunction saveFullBackupHistory(entries) {\n  const safeStorage = getSafeLocalStorage();\n\n  if (entries === null || entries === undefined) {\n    // Clear cache\n    fullBackupHistoryCache = [];\n\n    // Delete from legacy localStorage\n    deleteFromStorage(\n      safeStorage,\n      FULL_BACKUP_HISTORY_STORAGE_KEY,\n      \"Error deleting full backup history from localStorage:\",\n    );\n\n    // Delete from new storage (async, fire-and-forget)\n    storageRepo.removeItem(FULL_BACKUP_HISTORY_STORAGE_KEY).catch(err => {\n      console.warn('[storage.js] Failed to delete backup history from new storage:', err);\n    });\n    return;\n  }\n\n  if (!Array.isArray(entries)) {\n    console.warn('Ignoring invalid full backup history payload. Expected an array.');\n    return;\n  }\n\n  const safeEntries = entries\n    .map(normalizeFullBackupHistoryEntry)\n    .filter(Boolean);\n\n  if (!safeEntries.length) {\n    if (entries.length === 0) {\n      // Clear cache\n      fullBackupHistoryCache = [];\n\n      // Delete from legacy localStorage\n      deleteFromStorage(\n        safeStorage,\n        FULL_BACKUP_HISTORY_STORAGE_KEY,\n        \"Error deleting full backup history from localStorage:\",\n      );\n\n      // Delete from new storage (async, fire-and-forget)\n      storageRepo.removeItem(FULL_BACKUP_HISTORY_STORAGE_KEY).catch(err => {\n        console.warn('[storage.js] Failed to delete backup history from new storage:', err);\n      });\n    } else {\n      console.warn('Ignoring full backup history update because no valid entries were provided.');\n    }\n    return;\n  }\n\n  // Update in-memory cache first for immediate sync reads\n  fullBackupHistoryCache = safeEntries;\n\n  // Persist to legacy localStorage (sync)\n  ensurePreWriteMigrationBackup(safeStorage, FULL_BACKUP_HISTORY_STORAGE_KEY);\n  saveJSONToStorage(\n    safeStorage,\n    FULL_BACKUP_HISTORY_STORAGE_KEY,\n    safeEntries,\n    \"Error saving full backup history to localStorage:\",\n    {\n      disableCompression: false,\n      forceCompressionOnQuota: true,\n    },\n  );\n\n  // Persist to new storage system (async, fire-and-forget)\n  storageRepo.setItem(FULL_BACKUP_HISTORY_STORAGE_KEY, safeEntries).catch(err => {\n    console.warn('[storage.js] Failed to persist backup history to new storage:', err);\n  });\n}\n\nvar recordFullBackupHistoryEntry = entry => {\n  const normalized = normalizeFullBackupHistoryEntry(entry);\n  if (!normalized) {\n    return loadFullBackupHistory();\n  }\n  const history = loadFullBackupHistory();\n  history.push(normalized);\n  const trimmed = history.slice(-MAX_FULL_BACKUP_HISTORY_ENTRIES);\n  saveFullBackupHistory(trimmed);\n  return trimmed;\n};\n\nfunction normalizeImportedFullBackupHistory(value, visited, depth = 0) {\n  if (value === null || value === undefined) {\n    return [];\n  }\n\n  if (depth > 50) {\n    return [];\n  }\n\n  if (Array.isArray(value)) {\n    const results = [];\n    const count = value.length;\n    const seen = visited || new WeakSet();\n    if (seen.has(value)) {\n      return [];\n    }\n    seen.add(value);\n    for (let i = 0; i < count; i += 1) {\n      const item = value[i];\n      if (typeof item === 'object' && item !== null && seen.has(item)) {\n        continue;\n      }\n\n      if (Array.isArray(item)) {\n        const nested = normalizeImportedFullBackupHistory(item, seen, depth + 1);\n        if (nested && nested.length) {\n          for (let j = 0; j < nested.length; j += 1) {\n            results.push(nested[j]);\n          }\n        }\n      } else {\n        const entry = normalizeFullBackupHistoryEntry(item);\n        if (entry) {\n          results.push(entry);\n        }\n      }\n    }\n    return results;\n  }\n\n  const seen = visited || new WeakSet();\n  if (typeof value === 'object' && value !== null) {\n    if (seen.has(value)) {\n      return [];\n    }\n    seen.add(value);\n  }\n\n  if (isMapLike(value)) {\n    const converted = convertMapLikeToObject(value);\n    if (converted) {\n      return normalizeImportedFullBackupHistory(Object.values(converted), seen, depth + 1);\n    }\n    return [];\n  }\n\n  if (typeof value === 'string') {\n    const parsed = tryParseJSONLike(value);\n    if (parsed.success) {\n      return normalizeImportedFullBackupHistory(parsed.parsed, seen, depth + 1);\n    }\n    const entry = normalizeFullBackupHistoryEntry(value);\n    return entry ? [entry] : [];\n  }\n\n  // Arrays are handled at the top of the function\n  if (Array.isArray(value)) {\n    return [];\n  }\n\n  if (isPlainObject(value)) {\n    if (Array.isArray(value.history)) {\n      return normalizeImportedFullBackupHistory(value.history, seen, depth + 1);\n    }\n    if (Array.isArray(value.entries)) {\n      return normalizeImportedFullBackupHistory(value.entries, seen, depth + 1);\n    }\n    if (Array.isArray(value.list)) {\n      return normalizeImportedFullBackupHistory(value.list, seen, depth + 1);\n    }\n    const entry = normalizeFullBackupHistoryEntry(value);\n    if (entry) {\n      return [entry];\n    }\n    const nestedValues = Object.values(value);\n    if (nestedValues.length) {\n      return normalizeImportedFullBackupHistory(nestedValues, seen, depth + 1);\n    }\n  }\n\n  return [];\n}\n\n// --- Documentation Tracker Storage ---\nvar DOCUMENTATION_TRACKER_SCHEMA_VERSION = 1;\n\nfunction generateDocumentationTrackerId() {\n  var now = 0;\n  if (typeof Date !== 'undefined' && Date && typeof Date.now === 'function') {\n    now = Date.now();\n  } else {\n    try {\n      now = new Date().getTime();\n    } catch (timeError) {\n      now = Math.floor(Math.random() * 1e9);\n      void timeError;\n    }\n  }\n  var random = 0;\n  try {\n    random = Math.floor(Math.random() * 1e6);\n  } catch (randomError) {\n    random = now % 1e6;\n    void randomError;\n  }\n  return 'doc-tracker-' + now.toString(36) + '-' + random.toString(36);\n}\n\nfunction normalizeDocumentationTrackerStatusEntry(entry) {\n  var completed = false;\n  var updatedAt = null;\n\n  if (entry && typeof entry === 'object') {\n    if (typeof entry.completed === 'boolean') {\n      completed = entry.completed;\n    } else if (typeof entry.checked === 'boolean') {\n      completed = entry.checked;\n    } else if (typeof entry.value === 'boolean') {\n      completed = entry.value;\n    } else if (entry.done === true) {\n      completed = true;\n    }\n\n    var timestampCandidate = null;\n    if (typeof entry.updatedAt === 'string' && entry.updatedAt.trim()) {\n      timestampCandidate = entry.updatedAt.trim();\n    } else if (typeof entry.timestamp === 'string' && entry.timestamp.trim()) {\n      timestampCandidate = entry.timestamp.trim();\n    } else if (typeof entry.completedAt === 'string' && entry.completedAt.trim()) {\n      timestampCandidate = entry.completedAt.trim();\n    }\n    if (timestampCandidate) {\n      updatedAt = timestampCandidate;\n    }\n  } else if (typeof entry === 'boolean') {\n    completed = entry;\n  } else if (typeof entry === 'string') {\n    var normalized = entry.trim().toLowerCase();\n    if (normalized === 'true' || normalized === '1' || normalized === 'yes' || normalized === 'done') {\n      completed = true;\n    }\n  }\n\n  return {\n    completed: completed === true,\n    updatedAt: typeof updatedAt === 'string' ? updatedAt : null,\n  };\n}\n\nfunction normalizeDocumentationTrackerStatusMap(map) {\n  var normalized = {};\n\n  if (Array.isArray(map)) {\n    for (var index = 0; index < map.length; index += 1) {\n      var item = map[index];\n      if (item === null || item === undefined) {\n        continue;\n      }\n      if (typeof item === 'string' && item.trim()) {\n        normalized[item.trim()] = { completed: true, updatedAt: null };\n        continue;\n      }\n      if (typeof item === 'object') {\n        var key = null;\n        if (typeof item.id === 'string' && item.id.trim()) {\n          key = item.id.trim();\n        } else if (typeof item.key === 'string' && item.key.trim()) {\n          key = item.key.trim();\n        } else if (typeof item.name === 'string' && item.name.trim()) {\n          key = item.name.trim();\n        }\n        if (!key) {\n          continue;\n        }\n        normalized[key] = normalizeDocumentationTrackerStatusEntry(item);\n      }\n    }\n    return normalized;\n  }\n\n  if (map && (typeof map === 'object' || typeof map === 'function')) {\n    var keys = Object.keys(map);\n    for (var i = 0; i < keys.length; i += 1) {\n      var rawKey = keys[i];\n      if (rawKey === null || rawKey === undefined) {\n        continue;\n      }\n      var keyString = typeof rawKey === 'string' ? rawKey : String(rawKey);\n      if (!keyString) {\n        continue;\n      }\n      var trimmedKey = keyString.trim();\n      if (!trimmedKey) {\n        continue;\n      }\n      normalized[trimmedKey] = normalizeDocumentationTrackerStatusEntry(map[rawKey]);\n    }\n  }\n\n  return normalized;\n}\n\nfunction normalizeDocumentationTrackerStatuses(value) {\n  var normalized = {};\n  if (value && (typeof value === 'object' || typeof value === 'function')) {\n    var keys = Object.keys(value);\n    for (var i = 0; i < keys.length; i += 1) {\n      var key = keys[i];\n      if (!key) continue;\n      normalized[key] = normalizeDocumentationTrackerStatusMap(value[key]);\n    }\n  }\n  if (!normalized.locales) {\n    normalized.locales = {};\n  }\n  if (!normalized.helpTopics) {\n    normalized.helpTopics = {};\n  }\n  if (!normalized.printGuides) {\n    normalized.printGuides = {};\n  }\n  return normalized;\n}\n\nfunction normalizeDocumentationTrackerRelease(entry) {\n  if (!entry || (typeof entry !== 'object' && typeof entry !== 'function')) {\n    return null;\n  }\n\n  var id = null;\n  if (typeof entry.id === 'string' && entry.id.trim()) {\n    id = entry.id.trim();\n  }\n  if (!id && typeof entry.key === 'string' && entry.key.trim()) {\n    id = entry.key.trim();\n  }\n  if (!id) {\n    id = generateDocumentationTrackerId();\n  }\n\n  var name = '';\n  if (typeof entry.name === 'string') {\n    name = entry.name.trim();\n  } else if (typeof entry.title === 'string') {\n    name = entry.title.trim();\n  }\n\n  var targetDate = '';\n  if (typeof entry.targetDate === 'string' && entry.targetDate.trim()) {\n    targetDate = entry.targetDate.trim();\n  } else if (typeof entry.releaseDate === 'string' && entry.releaseDate.trim()) {\n    targetDate = entry.releaseDate.trim();\n  }\n\n  var createdAt = '';\n  if (typeof entry.createdAt === 'string' && entry.createdAt.trim()) {\n    createdAt = entry.createdAt.trim();\n  } else if (typeof entry.generatedAt === 'string' && entry.generatedAt.trim()) {\n    createdAt = entry.generatedAt.trim();\n  }\n  if (!createdAt) {\n    try {\n      createdAt = new Date().toISOString();\n    } catch (isoError) {\n      createdAt = '';\n      void isoError;\n    }\n  }\n\n  var updatedAt = null;\n  if (typeof entry.updatedAt === 'string' && entry.updatedAt.trim()) {\n    updatedAt = entry.updatedAt.trim();\n  } else if (typeof entry.modifiedAt === 'string' && entry.modifiedAt.trim()) {\n    updatedAt = entry.modifiedAt.trim();\n  } else if (typeof entry.lastUpdated === 'string' && entry.lastUpdated.trim()) {\n    updatedAt = entry.lastUpdated.trim();\n  } else if (typeof entry.timestamp === 'string' && entry.timestamp.trim()) {\n    updatedAt = entry.timestamp.trim();\n  }\n  if (!updatedAt) {\n    updatedAt = createdAt || null;\n  }\n\n  var notes = '';\n  if (typeof entry.notes === 'string') {\n    notes = entry.notes.trim();\n  } else if (typeof entry.summary === 'string') {\n    notes = entry.summary.trim();\n  }\n  if (notes && notes.length > 8000) {\n    notes = notes.slice(0, 8000);\n  }\n\n  var archived = false;\n  if (typeof entry.archived === 'boolean') {\n    archived = entry.archived;\n  } else if (typeof entry.status === 'string') {\n    var normalizedStatus = entry.status.trim().toLowerCase();\n    if (normalizedStatus === 'archived' || normalizedStatus === 'closed' || normalizedStatus === 'complete') {\n      archived = true;\n    }\n  }\n\n  var statuses = normalizeDocumentationTrackerStatuses(entry.statuses);\n\n  return {\n    id: id,\n    name: name,\n    targetDate: targetDate,\n    createdAt: typeof createdAt === 'string' ? createdAt : '',\n    updatedAt: typeof updatedAt === 'string' ? updatedAt : null,\n    statuses: statuses,\n    notes: notes,\n    archived: archived === true,\n  };\n}\n\nfunction normalizeDocumentationTrackerState(state) {\n  var normalized = {\n    version: DOCUMENTATION_TRACKER_SCHEMA_VERSION,\n    releases: [],\n  };\n\n  if (state === null || state === undefined) {\n    return normalized;\n  }\n\n  var rawState = state;\n  if (Array.isArray(rawState)) {\n    normalized.releases = rawState\n      .map(normalizeDocumentationTrackerRelease)\n      .filter(Boolean);\n    return normalized;\n  }\n\n  if (typeof rawState !== 'object' && typeof rawState !== 'function') {\n    return normalized;\n  }\n\n  if (typeof rawState.version === 'number' && Number.isFinite(rawState.version)) {\n    normalized.version = rawState.version;\n  }\n\n  var sourceList = null;\n  if (Array.isArray(rawState.releases)) {\n    sourceList = rawState.releases;\n  } else if (Array.isArray(rawState.entries)) {\n    sourceList = rawState.entries;\n  } else if (Array.isArray(rawState.logs)) {\n    sourceList = rawState.logs;\n  }\n\n  if (!sourceList && rawState && typeof rawState === 'object') {\n    var values = Object.values(rawState);\n    if (values.length && values.every(function (value) { return value && typeof value === 'object' && !Array.isArray(value); })) {\n      sourceList = values;\n    }\n  }\n\n  if (!sourceList || !Array.isArray(sourceList)) {\n    normalized.releases = [];\n  } else {\n    normalized.releases = sourceList\n      .map(normalizeDocumentationTrackerRelease)\n      .filter(Boolean);\n  }\n\n  return normalized;\n}\n\nfunction loadDocumentationTracker() {\n  applyLegacyStorageMigrations();\n  const safeStorage = getSafeLocalStorage();\n  const parsed = loadJSONFromStorage(\n    safeStorage,\n    DOCUMENTATION_TRACKER_STORAGE_KEY,\n    'Error loading documentation tracker from localStorage:',\n    null,\n    { validate: value => value === null || isPlainObject(value) || Array.isArray(value) },\n  );\n  if (!parsed) {\n    return {\n      version: DOCUMENTATION_TRACKER_SCHEMA_VERSION,\n      releases: [],\n    };\n  }\n  const normalized = normalizeDocumentationTrackerState(parsed);\n  if (!normalized || !Array.isArray(normalized.releases)) {\n    return {\n      version: DOCUMENTATION_TRACKER_SCHEMA_VERSION,\n      releases: [],\n    };\n  }\n  return normalized;\n}\n\nfunction saveDocumentationTracker(state) {\n  const safeStorage = getSafeLocalStorage();\n  if (state === null || state === undefined) {\n    deleteFromStorage(\n      safeStorage,\n      DOCUMENTATION_TRACKER_STORAGE_KEY,\n      'Error deleting documentation tracker from localStorage:',\n    );\n    return;\n  }\n\n  const normalized = normalizeDocumentationTrackerState(state);\n  if (!normalized.releases.length) {\n    deleteFromStorage(\n      safeStorage,\n      DOCUMENTATION_TRACKER_STORAGE_KEY,\n      'Error deleting documentation tracker from localStorage:',\n    );\n    return;\n  }\n\n  ensurePreWriteMigrationBackup(safeStorage, DOCUMENTATION_TRACKER_STORAGE_KEY);\n  saveJSONToStorage(\n    safeStorage,\n    DOCUMENTATION_TRACKER_STORAGE_KEY,\n    {\n      version: DOCUMENTATION_TRACKER_SCHEMA_VERSION,\n      releases: normalized.releases,\n    },\n    'Error saving documentation tracker to localStorage:',\n    { disableCompression: true },\n  );\n}\n\n// --- Automatic Gear Rules Storage ---\nfunction loadAutoGearRules() {\n  applyLegacyStorageMigrations();\n  const safeStorage = getSafeLocalStorage();\n  const parsed = loadJSONFromStorage(\n    safeStorage,\n    AUTO_GEAR_RULES_STORAGE_KEY,\n    \"Error loading automatic gear rules from localStorage:\",\n    [],\n    { validate: (value) => value === null || Array.isArray(value) },\n  );\n  const rules = Array.isArray(parsed) ? parsed : [];\n  const normalizedRules = Array.isArray(rules)\n    ? normalizeLegacyLongGopStructure(rules)\n    : [];\n  if (normalizedRules !== rules) {\n    saveAutoGearRules(normalizedRules, { skipNormalization: true });\n  }\n\n  if (Array.isArray(normalizedRules)) {\n    let defaultsApplied = false;\n    const withDefaults = normalizedRules.map(rule => {\n      if (rule && typeof rule === 'object' && typeof rule.enabled === 'undefined') {\n        defaultsApplied = true;\n        return { ...rule, enabled: true };\n      }\n      return rule;\n    });\n\n    if (defaultsApplied) {\n      return withDefaults;\n    }\n    return normalizedRules;\n  }\n\n  return [];\n}\n\nfunction saveAutoGearRules(rules, options = {}) {\n  const opts = options || {};\n  const { skipNormalization = false } = opts;\n  const safeRules = Array.isArray(rules) ? rules.slice() : [];\n  const normalizedRules = skipNormalization\n    ? safeRules\n    : (Array.isArray(safeRules) ? normalizeLegacyLongGopStructure(safeRules) : []);\n  const safeStorage = getSafeLocalStorage();\n  ensurePreWriteMigrationBackup(safeStorage, AUTO_GEAR_RULES_STORAGE_KEY);\n  saveJSONToStorage(\n    safeStorage,\n    AUTO_GEAR_RULES_STORAGE_KEY,\n    normalizedRules,\n    \"Error saving automatic gear rules to localStorage:\",\n    {\n      disableCompression: true,\n    },\n  );\n  return normalizedRules;\n}\n\nfunction loadAutoGearBackups() {\n  applyLegacyStorageMigrations();\n\n  // [Agent Migration] Read form Memory/IndexedDB first\n  // Note: Since this is a synchronous load for UI, and backups might be large,\n  // we rely on hydration if available, or force a sync read if possible/cached.\n  // For simplicity and safety in this transition, we will prioritize what's in memory/repo if hydrated.\n  // However, since StorageRepository is async, we can't block here easily without a pre-hydrated cache.\n  // Assuming 'hydrateProjectCache' or similar has run.\n  // BUT: Auto Gear Backups are NOT part of the critical hydration path in hydrateProjectCache currently.\n  // We should add a specific check or accept that this might return empty initially until async load completes?\n  // Actually, for now, let's keep the LocalStorage fallback as primary for *initial* load if not hydrated,\n  // BUT try to use the Repository if we can.\n  // A better approach for this legacy synchronous API is to rely on a module-level variable that gets hydrated.\n\n  // Checking if we have a global cache for this? No specific valid cache variable exposed yet for backups.\n  // We will assume that for V2, the async loaders in 'auto-gear/storage.js' should be used.\n  // For V1 legacy compatibility, we might need to stick to LocalStorage OR\n  // implement a synchronous cache if we want to move away from LS.\n\n  // DECISION: To ensure migration, we should look for a hydrated value. \n  // If not found, fall back to LS.\n  // Since we don't have a dedicated cache variable for this in storage.js yet (unlike presets),\n  // we will add a simple in-memory check if possible, or leave as is if V2 uses async.\n  // Re-reading 'storage.js' context: we added caches for presets but not backups.\n  // Backups are large. Storing them in LS is bad.\n  // Let's rely on the fact that we migrated 'save' to IDB.\n  // We need to implement a 'hydrateAutoGearBackups' or similar, but for this function:\n\n  const safeStorage = getSafeLocalStorage();\n  const parsed = loadJSONFromStorage(\n    safeStorage,\n    AUTO_GEAR_BACKUPS_STORAGE_KEY,\n    \"Error loading automatic gear rule backups from localStorage:\",\n    [],\n    { validate: (value) => value === null || Array.isArray(value) },\n  );\n\n  const backups = Array.isArray(parsed) ? parsed : [];\n  const { normalized: normalizedBackups, changed } = normalizeLegacyLongGopBackups(backups);\n  if (changed) {\n    saveAutoGearBackups(normalizedBackups, { skipNormalization: true });\n  }\n  return normalizedBackups;\n}\n\nfunction saveAutoGearBackups(backups, options = {}) {\n  const opts = options || {};\n  const { skipNormalization = false } = opts;\n  const safeBackups = Array.isArray(backups) ? backups.slice() : [];\n  const { normalized: normalizedBackups } = skipNormalization\n    ? { normalized: safeBackups, changed: false }\n    : normalizeLegacyLongGopBackups(safeBackups);\n  const safeStorage = getSafeLocalStorage();\n  ensurePreWriteMigrationBackup(safeStorage, AUTO_GEAR_BACKUPS_STORAGE_KEY);\n\n  let attemptedMigrationCleanup = false;\n  let attemptedCacheCleanup = false;\n\n  // [Agent Migration] Update In-Memory Cache and Persist to IndexedDB\n  if (typeof window !== 'undefined' && window.localStorage === safeStorage) { // Simple check if we are in a window context\n    // Note: Auto Gear Backups are large, so we might skip full in-memory caching if needed, \n    // but consistency suggests we should at least route writes properly.\n    // For now, we will piggyback on the existing pattern if a cache exists, \n    // or just ensure proper async persistence.\n\n    if (typeof storageRepo !== 'undefined') {\n      storageRepo.setItem(AUTO_GEAR_BACKUPS_STORAGE_KEY, normalizedBackups).catch(err => {\n        console.warn('[Storage] Failed to async persist Auto Gear Backups to IDB:', err);\n      });\n    }\n  }\n\n  // [Agent Migration] Conditional Skipping of Legacy Write\n  // If IndexedDB is active, we should skip writing to LocalStorage to save space.\n  const isIndexedDBActive = typeof storageRepo !== 'undefined' &&\n    storageRepo.driver &&\n    storageRepo.driver.constructor.name === 'IndexedDBAdapter';\n\n  if (isIndexedDBActive) {\n    // Skip legacy write to avoid quota issues\n    return;\n  }\n\n  saveJSONToStorage(\n    safeStorage,\n    AUTO_GEAR_BACKUPS_STORAGE_KEY,\n    normalizedBackups,\n    \"Error saving automatic gear rule backups to localStorage:\",\n    {\n      onQuotaExceeded: (error, context = {}) => {\n        const removal = removeOldestAutoGearBackupEntry(normalizedBackups);\n        if (removal) {\n          const label = removal.label;\n          if (label) {\n            console.warn(\n              `Removed automatic gear backup \"${label}\" to free up storage space before saving gear backups.`,\n            );\n          } else {\n            console.warn(\n              'Removed oldest automatic gear backup entry to free up storage space before saving gear backups.',\n            );\n          }\n          return true;\n        }\n\n        const storage = context && context.storage ? context.storage : safeStorage;\n\n        if (!attemptedMigrationCleanup) {\n          attemptedMigrationCleanup = true;\n          if (cleanupAutoGearBackupMigrationCopies(storage)) {\n            return true;\n          }\n        }\n\n        if (!attemptedCacheCleanup) {\n          attemptedCacheCleanup = true;\n          if (clearCachedPlannerDataForAutoGearBackups()) {\n            return true;\n          }\n        }\n\n        return false;\n      },\n    },\n  );\n  return normalizedBackups;\n}\n\nfunction loadAutoGearSeedFlag() {\n  applyLegacyStorageMigrations();\n  const safeStorage = getSafeLocalStorage();\n  return loadFlagFromStorage(\n    safeStorage,\n    AUTO_GEAR_SEEDED_STORAGE_KEY,\n    \"Error loading automatic gear seed flag from localStorage:\",\n  );\n}\n\nfunction saveAutoGearSeedFlag(flag) {\n  const safeStorage = getSafeLocalStorage();\n  saveFlagToStorage(\n    safeStorage,\n    AUTO_GEAR_SEEDED_STORAGE_KEY,\n    Boolean(flag),\n    \"Error saving automatic gear seed flag to localStorage:\",\n  );\n}\n\nfunction loadAutoGearPresets() {\n  applyLegacyStorageMigrations();\n  const safeStorage = getSafeLocalStorage();\n  const presets = loadJSONFromStorage(\n    safeStorage,\n    AUTO_GEAR_PRESETS_STORAGE_KEY,\n    \"Error loading automatic gear presets from localStorage:\",\n    [],\n    { validate: (value) => value === null || Array.isArray(value) },\n  );\n  const presetArray = Array.isArray(presets) ? presets : [];\n  const normalized = Array.isArray(presetArray)\n    ? normalizeLegacyLongGopStructure(presetArray)\n    : [];\n  if (normalized !== presetArray) {\n    saveAutoGearPresets(normalized, { skipNormalization: true });\n  }\n  return Array.isArray(normalized) ? normalized : [];\n}\n\n// [Agent Refactor] Memory Cache for Auto Gear\n\nlet autoGearMonitorDefaultsCache = null;\nlet autoGearActivePresetIdCache = null;\nlet autoGearAutoPresetIdCache = null;\nlet autoGearBackupRetentionCache = null;\nlet autoGearBackupVisibilityCache = null;\nlet customFontsCache = null;\nlet customLogoCache = null;\nlet cameraColorsCache = null;\nlet printPreferencesCache = null;\nlet contactsCache = null;\nlet ownGearCache = null;\nlet userProfileCache = null;\nlet favoritesCache = null;\nlet temperatureUnitCache = null;\nlet focusScaleCache = null;\nlet mountVoltagesCache = null;\nlet fullBackupHistoryCache = null;\n\nfunction readActiveAutoGearPresetIds() {\n  const ids = new Set();\n  const pushId = (candidate) => {\n    if (typeof candidate === 'string') {\n      const trimmed = candidate.trim();\n      if (trimmed) {\n        ids.add(trimmed);\n      }\n    }\n  };\n\n  if (typeof loadAutoGearActivePresetId === 'function') {\n    try {\n      pushId(loadAutoGearActivePresetId());\n    } catch (error) {\n      console.warn('Unable to read automatic gear active preset id while evaluating compression policy.', error);\n    }\n  }\n\n  if (typeof loadAutoGearAutoPresetId === 'function') {\n    try {\n      pushId(loadAutoGearAutoPresetId());\n    } catch (error) {\n      console.warn('Unable to read automatic gear auto preset id while evaluating compression policy.', error);\n    }\n  }\n\n  return ids;\n}\n\nfunction saveAutoGearPresets(presets, options = {}) {\n  const opts = options || {};\n  const { skipNormalization = false, disableCompression: disableCompressionOverride } = opts;\n  const safePresets = Array.isArray(presets) ? presets.slice() : [];\n  const normalizedPresets = skipNormalization\n    ? safePresets\n    : (Array.isArray(safePresets) ? normalizeLegacyLongGopStructure(safePresets) : []);\n  const safeStorage = getSafeLocalStorage();\n  ensurePreWriteMigrationBackup(safeStorage, AUTO_GEAR_PRESETS_STORAGE_KEY);\n\n  let disableCompression = typeof disableCompressionOverride === 'boolean'\n    ? disableCompressionOverride\n    : false;\n\n  if (disableCompressionOverride === undefined) {\n    const activePresetIds = readActiveAutoGearPresetIds();\n    if (activePresetIds.size > 0) {\n      disableCompression = normalizedPresets.some(\n        (preset) => preset\n          && typeof preset === 'object'\n          && typeof preset.id === 'string'\n          && activePresetIds.has(preset.id),\n      );\n    }\n  }\n\n  // [Agent Refactor] Update Cache & Repo\n\n  if (storageRepo) {\n    storageRepo.setItem(AUTO_GEAR_PRESETS_STORAGE_KEY, normalizedPresets).catch(e => console.warn('Failed to save auto gear presets to repo', e));\n  }\n\n  const isIndexedDB = storageRepo && storageRepo.driver && storageRepo.driver.constructor && storageRepo.driver.constructor.name === 'IndexedDBAdapter';\n  if (!isIndexedDB) {\n    saveJSONToStorage(\n      safeStorage,\n      AUTO_GEAR_PRESETS_STORAGE_KEY,\n      normalizedPresets,\n      \"Error saving automatic gear presets to localStorage:\",\n      disableCompression ? { disableCompression: true } : undefined,\n    );\n  }\n  return normalizedPresets;\n}\n\nfunction loadAutoGearMonitorDefaults() {\n  // [Agent Refactor] Check Cache First\n  if (autoGearMonitorDefaultsCache) {\n    return autoGearMonitorDefaultsCache;\n  }\n\n  applyLegacyStorageMigrations();\n  const safeStorage = getSafeLocalStorage();\n  const defaults = loadJSONFromStorage(\n    safeStorage,\n    AUTO_GEAR_MONITOR_DEFAULTS_STORAGE_KEY,\n    \"Error loading automatic gear monitor defaults from localStorage:\",\n    {},\n    { validate: (value) => value === null || typeof value === 'object' },\n  );\n  const monitorDefaults = defaults && typeof defaults === 'object' ? defaults : {};\n  const normalizedDefaults = isPlainObject(monitorDefaults)\n    ? normalizeLegacyLongGopStructure(monitorDefaults)\n    : {};\n  if (normalizedDefaults !== monitorDefaults) {\n    saveAutoGearMonitorDefaults(normalizedDefaults, { skipNormalization: true });\n  }\n  return normalizedDefaults && typeof normalizedDefaults === 'object' ? normalizedDefaults : {};\n}\n\nfunction saveAutoGearMonitorDefaults(defaults, options = {}) {\n  const opts = options || {};\n  const { skipNormalization = false } = opts;\n  const safeDefaults = defaults && typeof defaults === 'object' ? { ...defaults } : {};\n  const normalizedDefaults = skipNormalization\n    ? safeDefaults\n    : (isPlainObject(safeDefaults) ? normalizeLegacyLongGopStructure(safeDefaults) : {});\n  const safeStorage = getSafeLocalStorage();\n  ensurePreWriteMigrationBackup(safeStorage, AUTO_GEAR_MONITOR_DEFAULTS_STORAGE_KEY);\n\n  // [Agent Refactor] Update Cache & Repo\n  autoGearMonitorDefaultsCache = normalizedDefaults;\n  if (storageRepo) {\n    storageRepo.setItem(AUTO_GEAR_MONITOR_DEFAULTS_STORAGE_KEY, normalizedDefaults).catch(e => console.warn('Failed to save monitor defaults to repo', e));\n  }\n\n  const isIndexedDB = storageRepo && storageRepo.driver && storageRepo.driver.constructor && storageRepo.driver.constructor.name === 'IndexedDBAdapter';\n  if (!isIndexedDB) {\n    saveJSONToStorage(\n      safeStorage,\n      AUTO_GEAR_MONITOR_DEFAULTS_STORAGE_KEY,\n      normalizedDefaults,\n      \"Error saving automatic gear monitor defaults to localStorage:\",\n    );\n  }\n  return normalizedDefaults;\n}\n\nfunction removeAutoGearPresetFromStorage(presetId, storage) {\n  if (!presetId) {\n    return;\n  }\n\n  const safeStorage = storage || getSafeLocalStorage();\n  if (!safeStorage) {\n    return;\n  }\n\n  let rawPresets;\n  try {\n    rawPresets = safeStorage.getItem(AUTO_GEAR_PRESETS_STORAGE_KEY);\n  } catch (error) {\n    console.error('Error loading automatic gear presets while removing autosaved preset from localStorage:', error);\n    downgradeSafeLocalStorageToMemory('read access', error, safeStorage);\n    alertStorageError();\n    return;\n  }\n\n  if (rawPresets === null || typeof rawPresets === 'undefined') {\n    return;\n  }\n\n  let parsedPresets;\n  let normalizedRawPresets = rawPresets;\n  if (typeof rawPresets === 'string' && rawPresets) {\n    normalizedRawPresets = maybeDecompressStoredString(rawPresets);\n  }\n  try {\n    parsedPresets = JSON.parse(normalizedRawPresets);\n  } catch (parseError) {\n    console.error('Error parsing automatic gear presets while removing autosaved preset from localStorage:', parseError);\n    return;\n  }\n\n  if (!Array.isArray(parsedPresets)) {\n    return;\n  }\n\n  const filteredPresets = parsedPresets.filter((preset) => {\n    if (!preset || typeof preset !== 'object') {\n      return true;\n    }\n    return preset.id !== presetId;\n  });\n\n  if (filteredPresets.length === parsedPresets.length) {\n    return;\n  }\n\n  // [Agent Refactor] Update Cache & Repo (Implicit via saveAutoGearPresets)\n  saveAutoGearPresets(filteredPresets, { skipNormalization: true });\n}\n\nfunction loadAutoGearActivePresetId() {\n  // [Agent Refactor] Check Cache First\n  if (autoGearActivePresetIdCache !== null) {\n    return typeof autoGearActivePresetIdCache === 'string' ? autoGearActivePresetIdCache : '';\n  }\n\n  applyLegacyStorageMigrations();\n  const safeStorage = getSafeLocalStorage();\n  if (!safeStorage || typeof safeStorage.getItem !== 'function') { // Added check\n    return '';\n  }\n  try {\n    const value = safeStorage.getItem(AUTO_GEAR_ACTIVE_PRESET_STORAGE_KEY);\n    return typeof value === 'string' ? value : '';\n  } catch (error) {\n    console.error('Error loading automatic gear active preset from localStorage:', error);\n    downgradeSafeLocalStorageToMemory('read access', error, safeStorage);\n    alertStorageError();\n    return '';\n  }\n}\n\nfunction saveAutoGearActivePresetId(presetId) {\n  // [Agent Refactor] Update Cache & Repo\n  autoGearActivePresetIdCache = presetId || '';\n  if (storageRepo) {\n    if (presetId) {\n      storageRepo.setItem(AUTO_GEAR_ACTIVE_PRESET_STORAGE_KEY, presetId).catch(e => console.warn('Failed to save active preset id', e));\n    } else {\n      storageRepo.removeItem(AUTO_GEAR_ACTIVE_PRESET_STORAGE_KEY).catch(e => console.warn('Failed to remove active preset id', e));\n    }\n  }\n\n  const isIndexedDB = storageRepo && storageRepo.driver && storageRepo.driver.constructor && storageRepo.driver.constructor.name === 'IndexedDBAdapter';\n  if (isIndexedDB) return;\n\n  const safeStorage = getSafeLocalStorage();\n  if (!safeStorage) {\n    return;\n  }\n  try {\n    if (presetId) {\n      safeStorage.setItem(AUTO_GEAR_ACTIVE_PRESET_STORAGE_KEY, presetId);\n    } else {\n      safeStorage.removeItem(AUTO_GEAR_ACTIVE_PRESET_STORAGE_KEY);\n    }\n  } catch (error) {\n    console.error('Error saving automatic gear active preset to localStorage:', error);\n    downgradeSafeLocalStorageToMemory('write access', error, safeStorage);\n    alertStorageError();\n  }\n}\n\nfunction loadAutoGearAutoPresetId() {\n  // [Agent Refactor] Check Cache First\n  if (autoGearAutoPresetIdCache !== null) {\n    return typeof autoGearAutoPresetIdCache === 'string' ? autoGearAutoPresetIdCache : '';\n  }\n\n  applyLegacyStorageMigrations();\n  const safeStorage = getSafeLocalStorage();\n  if (!safeStorage || typeof safeStorage.getItem !== 'function') { // Added check\n    return '';\n  }\n  try {\n    const value = safeStorage.getItem(AUTO_GEAR_AUTO_PRESET_STORAGE_KEY);\n    return typeof value === 'string' ? value : '';\n  } catch (error) {\n    console.error('Error loading automatic gear auto preset from localStorage:', error);\n    downgradeSafeLocalStorageToMemory('read access', error, safeStorage);\n    alertStorageError();\n    return '';\n  }\n}\n\nfunction saveAutoGearAutoPresetId(presetId) {\n  // [Agent Refactor] Update Cache & Repo\n  autoGearAutoPresetIdCache = presetId || '';\n  if (storageRepo) {\n    if (presetId) {\n      storageRepo.setItem(AUTO_GEAR_AUTO_PRESET_STORAGE_KEY, presetId).catch(e => console.warn('Failed to save auto preset id', e));\n    } else {\n      storageRepo.removeItem(AUTO_GEAR_AUTO_PRESET_STORAGE_KEY).catch(e => console.warn('Failed to remove auto preset id', e));\n    }\n  }\n\n  const isIndexedDB = storageRepo && storageRepo.driver && storageRepo.driver.constructor && storageRepo.driver.constructor.name === 'IndexedDBAdapter';\n  if (isIndexedDB) {\n    // If switching presets, we might need to remove old ones from legacy if we were dual-writing, but since we STOP writing to legacy, we don't need to complex manage legacy state here.\n    return;\n  }\n\n  const safeStorage = getSafeLocalStorage();\n  if (!safeStorage) {\n    return;\n  }\n  let previousPresetId = '';\n  // ... legacy logic continues ...\n  try {\n    const existingId = safeStorage.getItem(AUTO_GEAR_AUTO_PRESET_STORAGE_KEY);\n    if (typeof existingId === 'string' && existingId) {\n      previousPresetId = existingId;\n    }\n  } catch (inspectionError) {\n    console.error('Error inspecting automatic gear auto preset in localStorage:', inspectionError);\n    downgradeSafeLocalStorageToMemory('read access', inspectionError, safeStorage);\n  }\n  try {\n    if (presetId) {\n      safeStorage.setItem(AUTO_GEAR_AUTO_PRESET_STORAGE_KEY, presetId);\n      if (previousPresetId && previousPresetId !== presetId) {\n        removeAutoGearPresetFromStorage(previousPresetId, safeStorage);\n      }\n    } else {\n      safeStorage.removeItem(AUTO_GEAR_AUTO_PRESET_STORAGE_KEY);\n      if (previousPresetId) {\n        removeAutoGearPresetFromStorage(previousPresetId, safeStorage);\n      }\n    }\n  } catch (error) {\n    console.error('Error saving automatic gear auto preset to localStorage:', error);\n    downgradeSafeLocalStorageToMemory('write access', error, safeStorage);\n    alertStorageError();\n  }\n}\n\nfunction loadAutoGearBackupVisibility() {\n  // [Agent Refactor] Check Cache First\n  if (autoGearBackupVisibilityCache !== null) {\n    return !!autoGearBackupVisibilityCache;\n  }\n\n  applyLegacyStorageMigrations();\n  const safeStorage = getSafeLocalStorage();\n  return loadFlagFromStorage(\n    safeStorage,\n    AUTO_GEAR_BACKUP_VISIBILITY_STORAGE_KEY,\n    \"Error loading automatic gear backup visibility from localStorage:\",\n  );\n}\n\nfunction saveAutoGearBackupVisibility(flag) {\n  // [Agent Refactor] Update Cache & Repo\n  autoGearBackupVisibilityCache = !!flag;\n  if (storageRepo) {\n    storageRepo.setItem(AUTO_GEAR_BACKUP_VISIBILITY_STORAGE_KEY, !!flag).catch(e => console.warn('Failed to save visibility', e));\n  }\n\n  const isIndexedDB = storageRepo && storageRepo.driver && storageRepo.driver.constructor && storageRepo.driver.constructor.name === 'IndexedDBAdapter';\n  if (isIndexedDB) return;\n\n  const safeStorage = getSafeLocalStorage();\n  saveFlagToStorage(\n    safeStorage,\n    AUTO_GEAR_BACKUP_VISIBILITY_STORAGE_KEY,\n    Boolean(flag),\n    \"Error saving automatic gear backup visibility to localStorage:\",\n  );\n}\n\nfunction getAutoGearBackupRetentionUpperBound() {\n  const candidate = typeof AUTO_GEAR_BACKUP_RETENTION_MAX === 'number'\n    ? AUTO_GEAR_BACKUP_RETENTION_MAX\n    : MAX_AUTO_BACKUPS;\n  const numeric = Number(candidate);\n  if (!Number.isFinite(numeric)) {\n    return MAX_AUTO_BACKUPS;\n  }\n  const rounded = Math.round(numeric);\n  if (!Number.isFinite(rounded)) {\n    return MAX_AUTO_BACKUPS;\n  }\n  if (rounded < AUTO_GEAR_BACKUP_RETENTION_MIN) {\n    return AUTO_GEAR_BACKUP_RETENTION_MIN;\n  }\n  if (rounded > MAX_AUTO_BACKUPS) {\n    return MAX_AUTO_BACKUPS;\n  }\n  return rounded;\n}\n\nfunction clampAutoGearBackupRetention(value) {\n  const numeric = Number(value);\n  if (!Number.isFinite(numeric)) {\n    return getAutoGearBackupRetentionDefault();\n  }\n  const rounded = Math.round(numeric);\n  if (!Number.isFinite(rounded)) {\n    return getAutoGearBackupRetentionDefault();\n  }\n  if (rounded < AUTO_GEAR_BACKUP_RETENTION_MIN) {\n    return AUTO_GEAR_BACKUP_RETENTION_MIN;\n  }\n  const upperBound = getAutoGearBackupRetentionUpperBound();\n  if (rounded > upperBound) {\n    return upperBound;\n  }\n  return rounded;\n}\n\nfunction getAutoGearBackupRetentionDefault() {\n  const upperBound = getAutoGearBackupRetentionUpperBound();\n  if (GLOBAL_SCOPE && typeof GLOBAL_SCOPE.AUTO_GEAR_BACKUP_RETENTION_DEFAULT === 'number') {\n    const candidate = GLOBAL_SCOPE.AUTO_GEAR_BACKUP_RETENTION_DEFAULT;\n    if (Number.isFinite(candidate) && candidate >= AUTO_GEAR_BACKUP_RETENTION_MIN) {\n      const rounded = Math.round(candidate);\n      if (!Number.isFinite(rounded)) {\n        return upperBound;\n      }\n      if (rounded < AUTO_GEAR_BACKUP_RETENTION_MIN) {\n        return AUTO_GEAR_BACKUP_RETENTION_MIN;\n      }\n      if (rounded > upperBound) {\n        return upperBound;\n      }\n      return rounded;\n    }\n  }\n  const fallback = Math.round(AUTO_GEAR_BACKUP_RETENTION_DEFAULT_VALUE);\n  if (!Number.isFinite(fallback)) {\n    return AUTO_GEAR_BACKUP_RETENTION_MIN;\n  }\n  if (fallback > upperBound) {\n    return upperBound;\n  }\n  if (fallback < AUTO_GEAR_BACKUP_RETENTION_MIN) {\n    return AUTO_GEAR_BACKUP_RETENTION_MIN;\n  }\n  return fallback;\n}\n\nfunction normalizeAutoGearBackupRetentionValue(value, fallback = getAutoGearBackupRetentionDefault()) {\n  if (value === null || value === undefined) {\n    return fallback;\n  }\n  if (typeof value === 'number') {\n    return clampAutoGearBackupRetention(value);\n  }\n  if (typeof value === 'string') {\n    const trimmed = value.trim();\n    if (!trimmed) {\n      return fallback;\n    }\n    const parsed = Number(trimmed);\n    if (Number.isFinite(parsed)) {\n      return clampAutoGearBackupRetention(parsed);\n    }\n    const maybeJson = tryParseJSONLike(trimmed);\n    if (maybeJson && maybeJson.success) {\n      return normalizeAutoGearBackupRetentionValue(maybeJson.parsed, fallback);\n    }\n    return fallback;\n  }\n  if (Array.isArray(value)) {\n    for (let index = 0; index < value.length; index += 1) {\n      const candidate = normalizeAutoGearBackupRetentionValue(value[index], null);\n      if (typeof candidate === 'number' && Number.isFinite(candidate)) {\n        return clampAutoGearBackupRetention(candidate);\n      }\n    }\n    return fallback;\n  }\n  if (isPlainObject(value)) {\n    const candidateKeys = ['value', 'retention', 'limit', 'count'];\n    for (let i = 0; i < candidateKeys.length; i += 1) {\n      const key = candidateKeys[i];\n      if (!Object.prototype.hasOwnProperty.call(value, key)) {\n        continue;\n      }\n      const candidate = normalizeAutoGearBackupRetentionValue(value[key], null);\n      if (typeof candidate === 'number' && Number.isFinite(candidate)) {\n        return clampAutoGearBackupRetention(candidate);\n      }\n    }\n    return fallback;\n  }\n  return fallback;\n}\n\nfunction loadAutoGearBackupRetention() {\n  // [Agent Refactor] Check Cache First\n  if (autoGearBackupRetentionCache !== null) {\n    return autoGearBackupRetentionCache;\n  }\n\n  applyLegacyStorageMigrations();\n  const safeStorage = getSafeLocalStorage();\n  const retention = loadJSONFromStorage(\n    safeStorage,\n    AUTO_GEAR_BACKUP_RETENTION_STORAGE_KEY,\n    \"Error loading automatic gear backup retention from localStorage:\",\n    getAutoGearBackupRetentionDefault(),\n    {\n      validate: (value) =>\n        value === null\n        || typeof value === 'number'\n        || typeof value === 'string'\n        || Array.isArray(value)\n        || isPlainObject(value),\n    },\n  );\n  return normalizeAutoGearBackupRetentionValue(retention);\n}\n\nfunction saveAutoGearBackupRetention(retention) {\n  if (\n    retention === null\n    || retention === undefined\n    || typeof retention === 'function'\n    || (\n      typeof retention === 'object'\n      && !Array.isArray(retention)\n      && !isPlainObject(retention)\n    )\n  ) {\n    return;\n  }\n  const safeStorage = getSafeLocalStorage();\n  const normalized = normalizeAutoGearBackupRetentionValue(retention);\n\n  // [Agent Refactor] Update Cache & Repo\n  autoGearBackupRetentionCache = normalized;\n  if (storageRepo) {\n    storageRepo.setItem(AUTO_GEAR_BACKUP_RETENTION_STORAGE_KEY, normalized).catch(e => console.warn('Failed to save backup retention', e));\n  }\n\n  const isIndexedDB = storageRepo && storageRepo.driver && storageRepo.driver.constructor && storageRepo.driver.constructor.name === 'IndexedDBAdapter';\n  if (isIndexedDB) return;\n\n  ensurePreWriteMigrationBackup(safeStorage, AUTO_GEAR_BACKUP_RETENTION_STORAGE_KEY);\n  saveJSONToStorage(\n    safeStorage,\n    AUTO_GEAR_BACKUP_RETENTION_STORAGE_KEY,\n    normalized,\n    \"Error saving automatic gear backup retention to localStorage:\",\n  );\n}\n\n// --- Clear All Stored Data ---\nasync function clearAllData() {\n  try {\n    if (typeof globalThis !== 'undefined') globalThis.__cameraPowerPlannerFactoryResetting = true;\n    if (typeof global !== 'undefined') global.__cameraPowerPlannerFactoryResetting = true;\n    if (typeof window !== 'undefined') window.__cameraPowerPlannerFactoryResetting = true;\n    if (GLOBAL_SCOPE) {\n      GLOBAL_SCOPE.__cameraPowerPlannerFactoryResetting = true;\n      GLOBAL_SCOPE.__cineMonolithicProjectCleanupDone = false;\n    }\n    if (typeof sessionStorage !== 'undefined') sessionStorage.setItem(FACTORY_RESET_LOCK_KEY, 'true');\n    if (typeof localStorage !== 'undefined') localStorage.setItem(FACTORY_RESET_LOCK_KEY, 'true');\n  } catch (e) {\n    void e;\n  }\n\n  if (lifecycleChannel) {\n    try {\n      lifecycleChannel.postMessage('factory-reset');\n    } catch (e) {\n      void e;\n    }\n  }\n\n  const msg = \"Error clearing storage:\";\n  // Use the shared project deletion helper so all in-memory project caches and\n  // activity trackers, including auto backup metadata, are cleared alongside\n  // the stored data. Without this the factory reset could leave auto backup\n  // entries available until the next reload because the cache still referenced\n  // them.\n  try {\n    deleteProject();\n  } catch (error) {\n    console.warn('Unable to clear stored projects during factory reset', error);\n  }\n\n  // Explicitly invalidate caches regardless of deleteProject outcome\n  invalidateProjectReadCache();\n  if (AUTO_BACKUP_COMPRESSION_CACHE && typeof AUTO_BACKUP_COMPRESSION_CACHE.clear === 'function') {\n    AUTO_BACKUP_COMPRESSION_CACHE.clear();\n  }\n  if (Array.isArray(AUTO_BACKUP_COMPRESSION_CACHE_KEYS)) {\n    AUTO_BACKUP_COMPRESSION_CACHE_KEYS.length = 0;\n  }\n\n  // Attempt to clear all IndexedDB databases.\n  // We attempt to list databases if the browser supports it, otherwise we hit known ones.\n  try {\n    let clearVaultFn = null;\n    if (GLOBAL_SCOPE && typeof GLOBAL_SCOPE.clearBackupVault === 'function') {\n      clearVaultFn = GLOBAL_SCOPE.clearBackupVault;\n    } else if (typeof window !== 'undefined' && typeof window.clearBackupVault === 'function') {\n      clearVaultFn = window.clearBackupVault;\n    } else if (GLOBAL_SCOPE && GLOBAL_SCOPE.cineFeatureBackup && typeof GLOBAL_SCOPE.cineFeatureBackup.clearBackupVault === 'function') {\n      clearVaultFn = GLOBAL_SCOPE.cineFeatureBackup.clearBackupVault;\n    }\n\n    if (clearVaultFn) {\n      await clearVaultFn();\n    }\n\n    if (typeof indexedDB !== 'undefined') {\n      const vaultDbNames = ['cinePowerPlannerBackupVault', 'cinePowerPlanner', 'cameraPowerPlanner'];\n\n      // Try to get all database names if supported (Chrome, Edge, Firefox 125+, Safari 14+)\n      if (typeof indexedDB.databases === 'function') {\n        try {\n          const dbs = await indexedDB.databases();\n          dbs.forEach(db => {\n            if (db.name && !vaultDbNames.includes(db.name)) {\n              vaultDbNames.push(db.name);\n            }\n          });\n        } catch (listError) {\n          console.warn('Failed to list IndexedDB databases during factory reset', listError);\n        }\n      }\n\n      await Promise.all(vaultDbNames.map(dbName => {\n        return new Promise((resolve) => {\n          try {\n            const request = indexedDB.deleteDatabase(dbName);\n            request.addEventListener('success', () => resolve());\n            request.addEventListener('error', () => {\n              console.warn(`Failed to delete IndexedDB database \"${dbName}\" during factory reset`, request.error);\n              resolve();\n            });\n            request.addEventListener('blocked', () => {\n              console.warn(`Deletion of IndexedDB database \"${dbName}\" blocked during factory reset`);\n              resolve();\n            });\n          } catch (deleteError) {\n            console.warn(`Error initiating deletion of IndexedDB database \"${dbName}\"`, deleteError);\n            resolve();\n          }\n        });\n      }));\n    }\n  } catch (vaultError) {\n    console.warn('Failed to clear backup vault during factory reset', vaultError);\n  }\n\n  const safeStorage = getSafeLocalStorage();\n\n  const clearStorageFully = (storage, storageName) => {\n    if (!storage) {\n      return;\n    }\n\n    // First attempt a total clear\n    if (typeof storage.clear === 'function') {\n      try {\n        storage.clear();\n      } catch (clearError) {\n        console.warn(`Failed to clear ${storageName} using clear(), falling back to manual removal.`, clearError);\n      }\n    }\n\n    // Then iterate and remove EVERYTHING just to be absolutely sure,\n    // as clear() might be intercepted or only partially effective in some environments.\n    try {\n      const keysToRemove = [];\n\n      // Strategy A: Iterate by index\n      try {\n        const length = storage.length;\n        for (let i = 0; i < length; i++) {\n          const key = storage.key(i);\n          if (key) {\n            keysToRemove.push(key);\n          }\n        }\n      } catch (indexError) {\n        console.warn(`Failed to iterate ${storageName} by index`, indexError);\n      }\n\n      // Strategy B: Object.keys fallback (works for standard localStorage in many runtimes)\n      try {\n        const objectKeys = Object.keys(storage);\n        if (Array.isArray(objectKeys)) {\n          objectKeys.forEach(k => {\n            if (k && !keysToRemove.includes(k)) {\n              keysToRemove.push(k);\n            }\n          });\n        }\n      } catch (objKeysError) {\n        // Ignore, Object.keys might not work on all storage implementations\n        void objKeysError;\n      }\n\n      keysToRemove.forEach((key) => {\n        if (key === FACTORY_RESET_LOCK_KEY) return;\n        try {\n          storage.removeItem(key);\n        } catch (removeError) {\n          console.warn(`Failed to remove key ${key} from ${storageName}`, removeError);\n        }\n      });\n    } catch (iterateError) {\n      console.warn(`Failed to iterate ${storageName} for strict cleanup`, iterateError);\n    }\n  };\n\n  clearStorageFully(safeStorage, 'safeLocalStorage');\n\n  if (typeof localStorage !== 'undefined' && localStorage !== safeStorage) {\n    clearStorageFully(localStorage, 'localStorage');\n  }\n\n  if (typeof sessionStorage !== 'undefined') {\n    clearStorageFully(sessionStorage, 'sessionStorage');\n  }\n\n  const sessionCacheKeys = [\n    'settingsActiveTab',\n    typeof GLOBAL_SCOPE !== 'undefined'\n      && GLOBAL_SCOPE\n      && typeof GLOBAL_SCOPE.INSTALL_BANNER_DISMISSED_KEY === 'string'\n      ? GLOBAL_SCOPE.INSTALL_BANNER_DISMISSED_KEY\n      : 'cine_install_banner_dismissed',\n  ];\n\n  const ensureStoragePruned = (storage, storageName) => {\n    if (!storage || typeof storage.length !== 'number' || typeof storage.key !== 'function') {\n      return;\n    }\n    const keysToRemove = [];\n    const length = storage.length;\n    for (let i = 0; i < length; i++) {\n      const key = storage.key(i);\n      if (!key) {\n        continue;\n      }\n      // Remove all app-related keys and specific session cache keys\n      if (\n        key.startsWith('cameraPowerPlanner_') ||\n        key.startsWith('cine_') ||\n        key.startsWith('cinePowerPlanner_') ||\n        key.startsWith('cinePowerPlanner') ||\n        key.startsWith('cineRental') ||\n        key.startsWith('__cine') ||\n        key.startsWith('cine_') || // Includes FACTORY_RESET_LOCK_KEY, handled via explicit check\n        sessionCacheKeys.includes(key)\n      ) {\n        if (key !== FACTORY_RESET_LOCK_KEY) {\n          keysToRemove.push(key);\n        }\n      }\n    }\n\n    keysToRemove.forEach((key) => {\n      try {\n        storage.removeItem(key);\n      } catch (removeError) {\n        console.warn(`Failed to remove key ${key} from ${storageName}`, removeError);\n      }\n    });\n  };\n\n  // Pruning is redundant but provides a second pass if clearAll fails\n  ensureStoragePruned(safeStorage, 'safeLocalStorage');\n  if (typeof localStorage !== 'undefined' && localStorage !== safeStorage) {\n    ensureStoragePruned(localStorage, 'localStorage');\n  }\n  if (typeof sessionStorage !== 'undefined') {\n    ensureStoragePruned(sessionStorage, 'sessionStorage');\n  }\n\n  // Explicitly clear known keys and prefixes using the helper to ensure logging and safety\n  if (typeof clearUiCacheStorageEntries === 'function') {\n    try {\n      clearUiCacheStorageEntries();\n    } catch (e) {\n      void e;\n    }\n  }\n\n  const explicitKeys = [\n    'cineBackupVaultFallbackRecords',\n    DEVICE_STORAGE_KEY,\n    SETUP_STORAGE_KEY,\n    FEEDBACK_STORAGE_KEY,\n    PROJECT_STORAGE_KEY,\n    PROJECT_STORAGE_REV_KEY,\n    'cameraPowerPlanner_projects',\n    'cameraPowerPlanner_project_shards',\n    FAVORITES_STORAGE_KEY,\n    CONTACTS_STORAGE_KEY,\n    AUTO_GEAR_RULES_STORAGE_KEY,\n    AUTO_GEAR_BACKUPS_STORAGE_KEY,\n    AUTO_GEAR_SEEDED_STORAGE_KEY,\n    AUTO_GEAR_PRESETS_STORAGE_KEY,\n    AUTO_GEAR_ACTIVE_PRESET_STORAGE_KEY,\n    AUTO_GEAR_AUTO_PRESET_STORAGE_KEY,\n    AUTO_GEAR_BACKUP_VISIBILITY_STORAGE_KEY,\n    AUTO_GEAR_BACKUP_RETENTION_STORAGE_KEY,\n    AUTO_GEAR_MONITOR_DEFAULTS_STORAGE_KEY,\n    getCustomFontStorageKeyName(),\n    CUSTOM_LOGO_STORAGE_KEY,\n    DEVICE_SCHEMA_CACHE_KEY,\n    LEGACY_SCHEMA_CACHE_KEY,\n    OWN_GEAR_STORAGE_KEY,\n    USER_PROFILE_STORAGE_KEY,\n    DOCUMENTATION_TRACKER_STORAGE_KEY,\n    FULL_BACKUP_HISTORY_STORAGE_KEY,\n    STORAGE_COMPRESSION_FLAG_KEY,\n    STORAGE_TEST_KEY,\n    SESSION_STATE_KEY,\n    'cameraPowerPlanner_lastProject',\n    'cameraPowerPlanner_onboardingComplete',\n    'cameraPowerPlanner_tourShown',\n    'cameraPowerPlanner_v1_migration',\n    'cameraPowerPlanner_v2_migration',\n    'cameraPowerPlanner_sharded',\n    'cameraPowerPlanner_forceLegacyBundle',\n    'cameraPowerPlanner_forceLegacyBundleRetry',\n    typeof GLOBAL_SCOPE !== 'undefined' && GLOBAL_SCOPE.TEMPERATURE_UNIT_STORAGE_KEY,\n    typeof GLOBAL_SCOPE !== 'undefined' && GLOBAL_SCOPE.FOCUS_SCALE_STORAGE_KEY,\n    typeof GLOBAL_SCOPE !== 'undefined' && GLOBAL_SCOPE.INSTALL_BANNER_DISMISSED_KEY,\n    'cine_install_banner_dismissed',\n    // Explicitly target backup keys that might be missed by dynamic resolution\n    'cameraPowerPlanner_project__backup',\n    'cameraPowerPlanner_project__legacyMigrationBackup',\n    'cameraPowerPlanner_setups__backup',\n    'cameraPowerPlanner_setups__legacyMigrationBackup'\n  ];\n\n  explicitKeys.forEach(k => {\n    if (k) {\n      deleteFromStorage(safeStorage, k, msg);\n      // Also explicitly delete potential backup variants\n      if (typeof safeStorage.removeItem === 'function') {\n        safeStorage.removeItem(`${k}${STORAGE_BACKUP_SUFFIX}`);\n        safeStorage.removeItem(`${k}${STORAGE_MIGRATION_BACKUP_SUFFIX}`);\n      }\n    }\n  });\n\n  if (typeof sessionStorage !== 'undefined') {\n    deleteFromStorage(sessionStorage, SESSION_STATE_KEY, msg);\n    deleteFromStorage(sessionStorage, '__cineLoggingHistory', msg);\n    deleteFromStorage(sessionStorage, '__cineLoggingConfig', msg);\n    // Nuke everything in session storage too\n    try {\n      // Preserve lock if present\n      const lock = sessionStorage.getItem(FACTORY_RESET_LOCK_KEY);\n      sessionStorage.clear();\n      if (lock) sessionStorage.setItem(FACTORY_RESET_LOCK_KEY, lock);\n    } catch (e) { void e; }\n  }\n\n  // Clear Service Worker Caches\n  if (typeof caches !== 'undefined' && typeof caches.keys === 'function') {\n    try {\n      const cacheKeys = await caches.keys();\n      await Promise.all(\n        cacheKeys.map(function (key) {\n          return caches.delete(key);\n        })\n      );\n      if (typeof console !== 'undefined' && typeof console.log === 'function') {\n        console.log('Storage reset: Service Worker caches cleared.');\n      }\n    } catch (cacheError) {\n      if (typeof console !== 'undefined' && typeof console.warn === 'function') {\n        console.warn('Storage reset: Failed to clear Service Worker caches.', cacheError);\n      }\n    }\n  }\n\n  const preferenceKeys = [\n    'darkMode',\n    'pinkMode',\n    'highContrast',\n    'reduceMotion',\n    'relaxedSpacing',\n    'showAutoBackups',\n    'accentColor',\n    'fontSize',\n    'fontFamily',\n    'language',\n    'iosPwaHelpShown',\n    CAMERA_COLOR_STORAGE_KEY,\n    PRINT_PREFERENCES_STORAGE_KEY,\n  ];\n  preferenceKeys.forEach((key) => {\n    deleteFromStorage(safeStorage, key, msg, { disableBackup: true });\n    if (typeof safeStorage.removeItem === 'function') {\n      safeStorage.removeItem(`${key}${STORAGE_BACKUP_SUFFIX}`);\n    }\n  });\n\n  const onboardingStorageKeys = [\n    'cameraPowerPlanner_onboardingTutorial',\n    'cinePowerPlanner_onboardingTutorial',\n    'cameraPowerPlanner_onboardingComplete',\n    'cameraPowerPlanner_tourShown'\n  ];\n\n  const clearOnboardingTutorialState = (storage) => {\n    if (!storage) {\n      return;\n    }\n    for (let index = 0; index < onboardingStorageKeys.length; index += 1) {\n      const key = onboardingStorageKeys[index];\n      deleteFromStorage(storage, key, msg);\n      if (typeof storage.removeItem === 'function') {\n        storage.removeItem(`${key}${STORAGE_BACKUP_SUFFIX}`);\n      }\n    }\n  };\n\n  const storageCandidates = collectUniqueStorages([\n    safeStorage,\n    getSafeLocalStorage(),\n    getWindowStorage('localStorage'),\n    typeof localStorage !== 'undefined' ? localStorage : null,\n  ]);\n\n  for (let index = 0; index < storageCandidates.length; index += 1) {\n    clearOnboardingTutorialState(storageCandidates[index]);\n  }\n\n  const sessionCandidates = collectUniqueStorages([\n    typeof sessionStorage !== 'undefined' ? sessionStorage : null,\n    getWindowStorage('sessionStorage'),\n  ]);\n\n  for (let index = 0; index < sessionCandidates.length; index += 1) {\n    clearOnboardingTutorialState(sessionCandidates[index]);\n  }\n\n  try {\n    const logging = GLOBAL_SCOPE && GLOBAL_SCOPE.cineLogging ? GLOBAL_SCOPE.cineLogging : null;\n    if (logging && typeof logging.clearHistory === 'function') {\n      logging.clearHistory({ persist: false });\n    }\n  } catch (loggingError) {\n    console.warn('Unable to clear logging history during factory reset', loggingError);\n  }\n\n  // Explicitly wipe window.name to reset onboarding tour skip flags and other\n  // session-specific transient state that might persist across reloads.\n  try {\n    if (GLOBAL_SCOPE && typeof GLOBAL_SCOPE.name === 'string') {\n      GLOBAL_SCOPE.name = '';\n    }\n    if (typeof window !== 'undefined' && typeof window.name === 'string') {\n      window.name = '';\n    }\n  } catch (windowNameError) {\n    console.warn('Unable to reset window.name during factory reset', windowNameError);\n  }\n\n  // Unregister Service Workers and clear Cache API for a total factory state.\n  try {\n    if (typeof navigator !== 'undefined' && navigator.serviceWorker) {\n      const registrations = await navigator.serviceWorker.getRegistrations();\n      for (const registration of registrations) {\n        await registration.unregister();\n      }\n    }\n  } catch (swError) {\n    console.warn('Failed to unregister service workers', swError);\n  }\n\n  // We intentionally DO NOT reset the factory reset flag here.\n  // The page is about to reload, and we want to ensure that NO subsequent\n  // saves (triggered by UI resets, unload handlers, etc.) can occur\n  // between now and the reload. The flag will naturally be false on the\n  // next page load.\n  if (typeof console !== 'undefined' && typeof console.log === 'function') {\n    console.log('Factory reset cleanup complete. Waiting for reload.');\n  }\n}\n\n// --- Export/Import All Planner Data ---\nfunction readLocalStorageValue(key) {\n  // [Agent Refactor] Check Memory Caches First\n  if (key === CUSTOM_FONT_STORAGE_KEY_DEFAULT && customFontsCache) return customFontsCache;\n  if (key === CUSTOM_LOGO_STORAGE_KEY && customLogoCache) return customLogoCache;\n  if (key === CAMERA_COLOR_STORAGE_KEY && cameraColorsCache) return cameraColorsCache;\n  if (key === PRINT_PREFERENCES_STORAGE_KEY && printPreferencesCache) return printPreferencesCache;\n  if (key === CONTACTS_STORAGE_KEY && contactsCache) return contactsCache;\n  if (key === OWN_GEAR_STORAGE_KEY && ownGearCache) return ownGearCache;\n  if (key === USER_PROFILE_STORAGE_KEY && userProfileCache) return userProfileCache;\n\n  if (key === FAVORITES_STORAGE_KEY && favoritesCache) return favoritesCache;\n  if (key === TEMPERATURE_UNIT_STORAGE_KEY_NAME && temperatureUnitCache) return temperatureUnitCache;\n  if (key === FOCUS_SCALE_STORAGE_KEY_NAME && focusScaleCache) return focusScaleCache;\n  if (key === getMountVoltageStorageKeyName() && mountVoltagesCache) return mountVoltagesCache;\n\n  const storage = getSafeLocalStorage();\n  if (!storage || typeof storage.getItem !== 'function') return null;\n  const variants = getStorageKeyVariants(key);\n  for (let i = 0; i < variants.length; i += 1) {\n    const candidateKey = variants[i];\n    try {\n      const value = storage.getItem(candidateKey);\n      if (value === null || value === undefined) {\n        if (RAW_STORAGE_BACKUP_KEYS.has(candidateKey)) {\n          try {\n            const backupValue = storage.getItem(`${candidateKey}${STORAGE_BACKUP_SUFFIX}`);\n            if (backupValue !== null && backupValue !== undefined) {\n              const decodedBackup = decodeStoredValue(backupValue);\n              return typeof decodedBackup === 'string' ? decodedBackup : String(backupValue);\n            }\n          } catch (backupError) {\n            console.warn('Unable to read backup key for export', candidateKey, backupError);\n            downgradeSafeLocalStorageToMemory('read access', backupError, storage);\n          }\n        }\n      } else {\n        const decoded = decodeStoredValue(value);\n        return typeof decoded === 'string' ? decoded : String(value);\n      }\n    } catch (error) {\n      console.warn('Unable to read storage key for backup', candidateKey, error);\n      downgradeSafeLocalStorageToMemory('read access', error, storage);\n    }\n  }\n  return null;\n}\n\nfunction parseStoredBoolean(value) {\n  if (value === null || value === undefined) {\n    return null;\n  }\n\n  if (typeof value === 'boolean') {\n    return value;\n  }\n\n  if (typeof value === 'number') {\n    if (Number.isNaN(value)) {\n      return null;\n    }\n    return value !== 0;\n  }\n\n  const normalized = String(value).trim().toLowerCase();\n  if (!normalized) {\n    return null;\n  }\n\n  if (normalized === 'true'\n    || normalized === '1'\n    || normalized === 'yes'\n    || normalized === 'on') {\n    return true;\n  }\n\n  if (normalized === 'false'\n    || normalized === '0'\n    || normalized === 'no'\n    || normalized === 'off') {\n    return false;\n  }\n\n  return null;\n}\n\nfunction interpretPrintPreferencesValue(rawValue) {\n  if (rawValue === null || rawValue === undefined) {\n    return null;\n  }\n\n  let serialized = null;\n  let candidate = rawValue;\n\n  if (typeof rawValue === 'string') {\n    const trimmed = rawValue.trim();\n    if (!trimmed) {\n      return null;\n    }\n    serialized = trimmed;\n    try {\n      candidate = JSON.parse(trimmed);\n    } catch (parseError) {\n      void parseError;\n      return { normalized: null, serialized };\n    }\n  }\n\n  if (!candidate || typeof candidate !== 'object') {\n    if (serialized) {\n      return { normalized: null, serialized };\n    }\n    return null;\n  }\n\n  const hasSectionsContainer =\n    typeof candidate.sections === 'object' && candidate.sections !== null;\n  const sectionsSource = hasSectionsContainer ? candidate.sections : candidate;\n  const sections = {};\n\n  if (sectionsSource && typeof sectionsSource === 'object') {\n    const sectionKeys = Object.keys(sectionsSource);\n    for (let index = 0; index < sectionKeys.length; index += 1) {\n      const sectionKey = sectionKeys[index];\n      const sectionValue = sectionsSource[sectionKey];\n      if (typeof sectionValue === 'boolean') {\n        sections[sectionKey] = sectionValue;\n      }\n    }\n  }\n\n  let layout = null;\n  if (typeof candidate.layout === 'string') {\n    const trimmedLayout = candidate.layout.trim();\n    if (trimmedLayout) {\n      layout = trimmedLayout;\n    }\n  }\n\n  if (!layout) {\n    layout = hasSectionsContainer ? 'standard' : 'rental';\n  }\n\n  const normalized = {\n    sections,\n    layout,\n  };\n\n  if (hasSectionsContainer) {\n    const candidateKeys = Object.keys(candidate);\n    for (let index = 0; index < candidateKeys.length; index += 1) {\n      const key = candidateKeys[index];\n      if (key === 'sections' || key === 'layout') {\n        continue;\n      }\n      normalized[key] = storageJsonDeepClone(candidate[key]);\n    }\n  }\n\n  return {\n    normalized,\n    serialized,\n  };\n}\n\nfunction collectPreferenceSnapshot() {\n  const preferences = {};\n\n  const darkMode = parseStoredBoolean(readLocalStorageValue('darkMode'));\n  if (darkMode !== null) {\n    preferences.darkMode = darkMode;\n  }\n\n  const pinkMode = parseStoredBoolean(readLocalStorageValue('pinkMode'));\n  if (pinkMode !== null) {\n    preferences.pinkMode = pinkMode;\n  }\n\n  const highContrast = parseStoredBoolean(readLocalStorageValue('highContrast'));\n  if (highContrast !== null) {\n    preferences.highContrast = highContrast;\n  }\n\n  const reduceMotion = parseStoredBoolean(readLocalStorageValue('reduceMotion'));\n  if (reduceMotion !== null) {\n    preferences.reduceMotion = reduceMotion;\n  }\n\n  const relaxedSpacing = parseStoredBoolean(readLocalStorageValue('relaxedSpacing'));\n  if (relaxedSpacing !== null) {\n    preferences.relaxedSpacing = relaxedSpacing;\n  }\n\n  const showAutoBackups = parseStoredBoolean(readLocalStorageValue('showAutoBackups'));\n  if (showAutoBackups !== null) {\n    preferences.showAutoBackups = showAutoBackups;\n  }\n\n  const accentColor = readLocalStorageValue('accentColor');\n  if (accentColor) {\n    preferences.accentColor = accentColor;\n  }\n\n  const fontSize = readLocalStorageValue('fontSize');\n  if (fontSize) {\n    preferences.fontSize = fontSize;\n  }\n\n  const fontFamily = readLocalStorageValue('fontFamily');\n  if (fontFamily) {\n    preferences.fontFamily = fontFamily;\n  }\n\n  const language = readLocalStorageValue('language');\n  if (language) {\n    preferences.language = language;\n  }\n\n  const mountVoltageKey = getMountVoltageStorageKeyName();\n  const mountVoltages = readLocalStorageValue(mountVoltageKey);\n  if (mountVoltages) {\n    if (mountVoltages === '[object Object]') {\n      if (typeof DEFAULT_MOUNT_VOLTAGES !== 'undefined') {\n        preferences.mountVoltages = DEFAULT_MOUNT_VOLTAGES;\n      } else {\n        preferences.mountVoltages = {\n          'V-Mount': { high: 14.4, low: 12 },\n          'Gold-Mount': { high: 14.4, low: 12 },\n          'B-Mount': { high: 33.6, low: 21.6 }\n        };\n      }\n    } else {\n      try {\n        preferences.mountVoltages = JSON.parse(mountVoltages);\n      } catch (voltageParseError) {\n        console.warn('Failed to parse stored mount voltages for backup', voltageParseError);\n        preferences.mountVoltages = mountVoltages;\n      }\n    }\n  }\n\n  const iosPwaHelpShown = parseStoredBoolean(readLocalStorageValue('iosPwaHelpShown'));\n  if (iosPwaHelpShown !== null) {\n    preferences.iosPwaHelpShown = iosPwaHelpShown;\n  }\n\n  const temperatureUnit = readLocalStorageValue(TEMPERATURE_UNIT_STORAGE_KEY_NAME);\n  if (temperatureUnit) {\n    preferences.temperatureUnit = temperatureUnit;\n  }\n\n  const focusScale = readLocalStorageValue(FOCUS_SCALE_STORAGE_KEY_NAME);\n  if (focusScale) {\n    preferences.focusScale = focusScale;\n  }\n\n  const cameraColorsRaw = readLocalStorageValue(CAMERA_COLOR_STORAGE_KEY);\n  if (cameraColorsRaw) {\n    let parsedCameraColors = null;\n    if (typeof cameraColorsRaw === 'string') {\n      const trimmedCameraColors = cameraColorsRaw.trim();\n      if (trimmedCameraColors) {\n        try {\n          parsedCameraColors = JSON.parse(trimmedCameraColors);\n        } catch (cameraColorParseError) {\n          console.warn('Failed to parse stored camera color preferences for backup', cameraColorParseError);\n          parsedCameraColors = null;\n        }\n      }\n    }\n\n    if (parsedCameraColors && typeof parsedCameraColors === 'object') {\n      preferences.cameraColors = storageJsonDeepClone(parsedCameraColors);\n    } else if (typeof cameraColorsRaw === 'string' && cameraColorsRaw.trim()) {\n      preferences.cameraColors = cameraColorsRaw;\n    }\n  }\n\n  const printPreferencesRaw = readLocalStorageValue(PRINT_PREFERENCES_STORAGE_KEY);\n  if (printPreferencesRaw !== null && printPreferencesRaw !== undefined) {\n    const interpretedPrintPreferences = interpretPrintPreferencesValue(printPreferencesRaw);\n    if (interpretedPrintPreferences) {\n      if (interpretedPrintPreferences.normalized) {\n        preferences[PRINT_PREFERENCES_STORAGE_KEY] = storageJsonDeepClone(\n          interpretedPrintPreferences.normalized,\n        );\n      } else if (interpretedPrintPreferences.serialized) {\n        preferences[PRINT_PREFERENCES_STORAGE_KEY] = interpretedPrintPreferences.serialized;\n      }\n    }\n  }\n\n  return preferences;\n}\n\nfunction normalizeCustomFontEntries(entries) {\n  if (!Array.isArray(entries)) {\n    return [];\n  }\n  return entries\n    .map((entry) => ({\n      id: entry && typeof entry.id === 'string' ? entry.id : null,\n      name: entry && typeof entry.name === 'string' ? entry.name : '',\n      data: entry && typeof entry.data === 'string' ? entry.data : '',\n    }))\n    .filter((entry) => entry.id && entry.name && entry.data);\n}\n\nfunction readStoredCustomFonts() {\n  const raw = readLocalStorageValue(getCustomFontStorageKeyName());\n  if (!raw) {\n    return [];\n  }\n\n  try {\n    const parsed = JSON.parse(raw);\n    return normalizeCustomFontEntries(parsed);\n  } catch (error) {\n    console.warn('Failed to parse stored custom fonts for backup', error);\n    return [];\n  }\n}\n\nlet backupVaultRecordCache = [];\n\nfunction normalizeBackupVaultMetadata(metadata) {\n  if (!metadata || typeof metadata !== 'object') {\n    return null;\n  }\n  const normalized = {};\n  if (typeof metadata.source === 'string' && metadata.source) {\n    normalized.source = metadata.source;\n  }\n  if (typeof metadata.reason === 'string' && metadata.reason) {\n    normalized.reason = metadata.reason;\n  }\n  if (typeof metadata.permissionState === 'string' && metadata.permissionState) {\n    normalized.permissionState = metadata.permissionState;\n  }\n  return Object.keys(normalized).length ? normalized : null;\n}\n\nfunction normalizeBackupVaultRecord(record) {\n  if (!record || typeof record !== 'object') {\n    return null;\n  }\n  const id = typeof record.id === 'string' ? record.id.trim() : '';\n  if (!id) {\n    return null;\n  }\n  const fileName = typeof record.fileName === 'string' && record.fileName\n    ? record.fileName\n    : 'cine-power-planner-backup.json';\n  const createdAtMs = typeof record.createdAtMs === 'number' && Number.isFinite(record.createdAtMs)\n    ? record.createdAtMs\n    : null;\n  const createdAt = typeof record.createdAt === 'string' && record.createdAt\n    ? record.createdAt\n    : (createdAtMs !== null ? new Date(createdAtMs).toISOString() : null);\n  let normalizedCreatedAtMs = createdAtMs;\n  if (normalizedCreatedAtMs === null && createdAt) {\n    const parsedTime = Date.parse(createdAt);\n    if (Number.isFinite(parsedTime)) {\n      normalizedCreatedAtMs = parsedTime;\n    }\n  }\n  if (normalizedCreatedAtMs === null) {\n    normalizedCreatedAtMs = Date.now();\n  }\n  const metadata = normalizeBackupVaultMetadata(record.metadata);\n  return {\n    id,\n    fileName,\n    payload: record.payload,\n    createdAt: createdAt || new Date(normalizedCreatedAtMs).toISOString(),\n    createdAtMs: normalizedCreatedAtMs,\n    metadata: metadata || {},\n  };\n}\n\nfunction normalizeBackupVaultRecordList(records) {\n  if (!records) {\n    return [];\n  }\n  let parsed = records;\n  if (typeof records === 'string') {\n    const parsedResult = tryParseJSONLike(records);\n    if (parsedResult && parsedResult.success) {\n      parsed = parsedResult.parsed;\n    }\n  }\n  const list = Array.isArray(parsed) ? parsed : [];\n  const normalized = [];\n  list.forEach((entry) => {\n    const normalizedEntry = normalizeBackupVaultRecord(entry);\n    if (normalizedEntry) {\n      normalized.push(normalizedEntry);\n    }\n  });\n  return normalized;\n}\n\nfunction scoreBackupVaultRecord(record) {\n  if (!record) {\n    return 0;\n  }\n  let score = 0;\n  if (record.payload !== null && record.payload !== undefined) {\n    score += 3;\n  }\n  if (typeof record.fileName === 'string' && record.fileName) {\n    score += 1;\n  }\n  if (typeof record.createdAt === 'string' && record.createdAt) {\n    score += 1;\n  }\n  if (typeof record.createdAtMs === 'number' && Number.isFinite(record.createdAtMs)) {\n    score += 1;\n  }\n  if (record.metadata && typeof record.metadata === 'object') {\n    score += 1;\n  }\n  return score;\n}\n\nfunction mergeBackupVaultRecords(existingList, incomingList) {\n  const merged = new Map();\n  const mergeList = (records) => {\n    if (!Array.isArray(records)) {\n      return;\n    }\n    records.forEach((record) => {\n      const normalized = normalizeBackupVaultRecord(record);\n      if (!normalized) {\n        return;\n      }\n      const existing = merged.get(normalized.id);\n      if (!existing || scoreBackupVaultRecord(normalized) >= scoreBackupVaultRecord(existing)) {\n        merged.set(normalized.id, normalized);\n      }\n    });\n  };\n  mergeList(existingList);\n  mergeList(incomingList);\n  return Array.from(merged.values());\n}\n\nfunction readBackupVaultFallbackRecords() {\n  const raw = readLocalStorageValue('cineBackupVaultFallbackRecords');\n  return normalizeBackupVaultRecordList(raw);\n}\n\nfunction resolveBackupVaultApi() {\n  if (GLOBAL_SCOPE && GLOBAL_SCOPE.cineFeatureBackup && typeof GLOBAL_SCOPE.cineFeatureBackup === 'object') {\n    return GLOBAL_SCOPE.cineFeatureBackup;\n  }\n  if (GLOBAL_SCOPE && typeof GLOBAL_SCOPE.getQueuedBackupPayloads === 'function') {\n    return GLOBAL_SCOPE;\n  }\n  return null;\n}\n\nfunction refreshBackupVaultRecordCache() {\n  const api = resolveBackupVaultApi();\n  if (!api) {\n    return;\n  }\n  const loader = typeof api.listBackupVaultRecords === 'function'\n    ? api.listBackupVaultRecords\n    : typeof api.getQueuedBackupPayloads === 'function'\n      ? api.getQueuedBackupPayloads\n      : null;\n  if (!loader) {\n    return;\n  }\n  let response = null;\n  try {\n    response = loader();\n  } catch (error) {\n    console.warn('Unable to load backup vault records for export', error);\n    return;\n  }\n  if (Array.isArray(response)) {\n    backupVaultRecordCache = normalizeBackupVaultRecordList(response);\n    return;\n  }\n  if (response && typeof response.then === 'function') {\n    return response.then((records) => {\n      backupVaultRecordCache = normalizeBackupVaultRecordList(records);\n      return backupVaultRecordCache;\n    }).catch((error) => {\n      console.warn('Unable to load backup vault records for export', error);\n      return [];\n    });\n  }\n  return Promise.resolve(backupVaultRecordCache);\n}\n\nasync function prepareBackupForExport() {\n  const records = await refreshBackupVaultRecordCache();\n  return records;\n}\n\nfunction exportAllData() {\n  refreshBackupVaultRecordCache();\n  const payload = {\n    devices: loadDeviceData(),\n    setups: loadSetups(),\n    session: loadSessionState(),\n    feedback: loadFeedback(),\n    project: loadProject(),\n    favorites: loadFavorites(),\n    contacts: loadContacts(),\n    ownGear: loadOwnGear(),\n    userProfile: null,\n    autoGearRules: loadAutoGearRules(),\n    autoGearBackups: loadAutoGearBackups(),\n    autoGearSeeded: loadAutoGearSeedFlag(),\n    autoGearPresets: loadAutoGearPresets(),\n    autoGearMonitorDefaults: loadAutoGearMonitorDefaults(),\n    autoGearActivePresetId: loadAutoGearActivePresetId(),\n    autoGearAutoPresetId: loadAutoGearAutoPresetId(),\n    autoGearShowBackups: loadAutoGearBackupVisibility(),\n    autoGearBackupRetention: loadAutoGearBackupRetention(),\n    fullBackupHistory: loadFullBackupHistory(),\n  };\n\n  const documentationTracker = loadDocumentationTracker();\n  if (\n    documentationTracker &&\n    Array.isArray(documentationTracker.releases) &&\n    documentationTracker.releases.length\n  ) {\n    payload.documentationTracker = documentationTracker;\n  }\n\n  const preferences = collectPreferenceSnapshot();\n  if (Object.keys(preferences).length) {\n    payload.preferences = preferences;\n  }\n\n  const profile = loadUserProfile();\n  if (\n    profile\n    && typeof profile === 'object'\n    && (\n      (typeof profile.name === 'string' && profile.name)\n      || (typeof profile.role === 'string' && profile.role)\n      || (typeof profile.avatar === 'string' && profile.avatar)\n      || (typeof profile.phone === 'string' && profile.phone)\n      || (typeof profile.email === 'string' && profile.email)\n    )\n  ) {\n    payload.userProfile = profile;\n  } else {\n    delete payload.userProfile;\n  }\n\n  const customLogo = readLocalStorageValue(CUSTOM_LOGO_STORAGE_KEY);\n  if (customLogo) {\n    payload.customLogo = customLogo;\n  }\n\n  const customFonts = readStoredCustomFonts();\n  if (customFonts.length) {\n    payload.customFonts = customFonts;\n  }\n\n  const schemaCache = readLocalStorageValue(DEVICE_SCHEMA_CACHE_KEY);\n  if (schemaCache !== null && schemaCache !== undefined) {\n    payload.schemaCache = schemaCache;\n  }\n\n  const fallbackVaultRecords = readBackupVaultFallbackRecords();\n  const combinedVaultRecords = mergeBackupVaultRecords(\n    backupVaultRecordCache,\n    fallbackVaultRecords,\n  );\n  if (combinedVaultRecords.length) {\n    payload.backupVaultRecords = combinedVaultRecords.map((record) => storageJsonDeepClone(record));\n  }\n\n  return payload;\n}\n\nfunction safeSetLocalStorage(key, value) {\n  const storage = getSafeLocalStorage();\n  if (!storage) return;\n  const useBackup = RAW_STORAGE_BACKUP_KEYS.has(key);\n  const backupKey = `${key}${STORAGE_BACKUP_SUFFIX}`;\n  try {\n    if (value === null || value === undefined) {\n      storage.removeItem(key);\n      if (useBackup) {\n        try {\n          storage.removeItem(backupKey);\n        } catch (backupError) {\n          console.warn('Unable to remove backup key during import', backupKey, backupError);\n          downgradeSafeLocalStorageToMemory('deletion', backupError, storage);\n        }\n      }\n    } else {\n      const storedValue = String(value);\n\n      // [Agent Refactor] Intercept & Persist Branding Keys\n      if (key === CUSTOM_FONT_STORAGE_KEY_DEFAULT) { customFontsCache = storedValue; }\n      if (key === CUSTOM_LOGO_STORAGE_KEY) { customLogoCache = storedValue; }\n      if (key === CAMERA_COLOR_STORAGE_KEY) { cameraColorsCache = storedValue; }\n      if (key === PRINT_PREFERENCES_STORAGE_KEY) { printPreferencesCache = storedValue; }\n      if (key === CONTACTS_STORAGE_KEY) { contactsCache = storedValue; }\n      if (key === OWN_GEAR_STORAGE_KEY) { ownGearCache = storedValue; }\n      if (key === USER_PROFILE_STORAGE_KEY) { userProfileCache = storedValue; }\n      if (key === FAVORITES_STORAGE_KEY) { favoritesCache = storedValue; }\n      if (key === TEMPERATURE_UNIT_STORAGE_KEY_NAME) { temperatureUnitCache = storedValue; }\n      if (key === FOCUS_SCALE_STORAGE_KEY_NAME) { focusScaleCache = storedValue; }\n      if (key === getMountVoltageStorageKeyName()) { mountVoltagesCache = storedValue; }\n\n      if (storageRepo) {\n        storageRepo.setItem(key, storedValue).catch(e => console.warn('Failed to save key to repo', key, e));\n        // Skip legacy write if IndexedDB is active\n        const isIndexedDB = storageRepo.driver && storageRepo.driver.constructor && storageRepo.driver.constructor.name === 'IndexedDBAdapter';\n        if (isIndexedDB) return;\n      }\n\n      storage.setItem(key, storedValue);\n      if (useBackup) {\n        try {\n          storage.setItem(backupKey, storedValue);\n        } catch (backupError) {\n          console.warn('Unable to update backup key during import', backupKey, backupError);\n          downgradeSafeLocalStorageToMemory('write access', backupError, storage);\n          alertStorageError();\n        }\n      }\n    }\n  } catch (error) {\n    console.warn('Unable to persist storage key during import', key, error);\n    downgradeSafeLocalStorageToMemory('write access', error, storage);\n    if (useBackup) {\n      alertStorageError();\n    }\n  }\n}\n\nfunction normalizeImportedBoolean(value) {\n  if (typeof value === \"boolean\") {\n    return value;\n  }\n\n  if (typeof value === \"string\") {\n    const normalized = value.trim().toLowerCase();\n    if (!normalized) {\n      return null;\n    }\n    if (normalized === \"true\" || normalized === \"1\" || normalized === \"yes\" || normalized === \"on\") {\n      return true;\n    }\n    if (normalized === \"false\" || normalized === \"0\" || normalized === \"no\" || normalized === \"off\") {\n      return false;\n    }\n    return null;\n  }\n\n  if (typeof value === \"number\") {\n    if (Number.isNaN(value)) {\n      return null;\n    }\n    return value !== 0;\n  }\n\n  if (Array.isArray(value)) {\n    for (let i = 0; i < value.length; i += 1) {\n      const normalized = normalizeImportedBoolean(value[i]);\n      if (normalized !== null) {\n        return normalized;\n      }\n    }\n    return null;\n  }\n\n  if (isPlainObject(value)) {\n    if (Object.prototype.hasOwnProperty.call(value, \"value\")) {\n      return normalizeImportedBoolean(value.value);\n    }\n    if (Object.prototype.hasOwnProperty.call(value, \"enabled\")) {\n      return normalizeImportedBoolean(value.enabled);\n    }\n  }\n\n  return null;\n}\n\nfunction normalizeImportedArray(value, fallbackKeys = [], filterFn = null) {\n  if (isMapLike(value)) {\n    const converted = convertMapLikeToObject(value);\n    if (converted) {\n      return normalizeImportedArray(converted, fallbackKeys, filterFn);\n    }\n    return [];\n  }\n\n  if (Array.isArray(value)) {\n    return filterFn\n      ? value.filter((entry) => filterFn(entry))\n      : value.filter((entry) => entry !== null && entry !== undefined);\n  }\n\n  if (typeof value === \"string\") {\n    const parsed = tryParseJSONLike(value);\n    if (parsed.success) {\n      return normalizeImportedArray(parsed.parsed, fallbackKeys, filterFn);\n    }\n    return [];\n  }\n\n  if (isPlainObject(value)) {\n    for (let i = 0; i < fallbackKeys.length; i += 1) {\n      const key = fallbackKeys[i];\n      if (!Object.prototype.hasOwnProperty.call(value, key)) {\n        continue;\n      }\n      const extracted = normalizeImportedArray(value[key], fallbackKeys, filterFn);\n      if (extracted.length) {\n        return extracted;\n      }\n    }\n\n    const entries = Object.values(value);\n    if (entries.length) {\n      return filterFn\n        ? entries.filter((entry) => filterFn(entry))\n        : entries.filter((entry) => entry !== null && entry !== undefined);\n    }\n  }\n\n  return [];\n}\n\nfunction normalizeImportedContacts(value) {\n  const entries = normalizeImportedArray(\n    value,\n    ['contacts', 'entries', 'items', 'list', 'values', 'data'],\n    (entry) => entry && typeof entry === 'object',\n  );\n  if (!Array.isArray(entries)) {\n    return [];\n  }\n  return normalizeContactsList(entries);\n}\n\nfunction normalizeImportedAutoGearRules(value) {\n  const rules = normalizeImportedArray(\n    value,\n    [\"rules\", \"items\", \"entries\", \"list\", \"values\", \"data\"],\n    (entry) => entry !== null && typeof entry === \"object\",\n  );\n  if (!Array.isArray(rules)) {\n    return [];\n  }\n  return normalizeLegacyLongGopStructure(rules);\n}\n\nfunction normalizeImportedAutoGearBackups(value) {\n  const backups = normalizeImportedArray(\n    value,\n    [\"backups\", \"entries\", \"items\", \"list\", \"values\", \"data\"],\n    (entry) => entry !== null && typeof entry === \"object\",\n  );\n  if (!Array.isArray(backups)) {\n    return [];\n  }\n  const { normalized } = normalizeLegacyLongGopBackups(backups);\n  return normalized;\n}\n\nfunction normalizeImportedAutoGearBackupRetention(value) {\n  if (value === null || value === undefined) {\n    return null;\n  }\n  if (typeof value === 'number') {\n    return clampAutoGearBackupRetention(value);\n  }\n  if (typeof value === 'string') {\n    const trimmed = value.trim();\n    if (!trimmed) {\n      return null;\n    }\n    const direct = Number(trimmed);\n    if (Number.isFinite(direct)) {\n      return clampAutoGearBackupRetention(direct);\n    }\n    const parsed = tryParseJSONLike(trimmed);\n    if (parsed && parsed.success) {\n      return normalizeImportedAutoGearBackupRetention(parsed.parsed);\n    }\n    return null;\n  }\n  if (Array.isArray(value)) {\n    for (let i = 0; i < value.length; i += 1) {\n      const candidate = normalizeImportedAutoGearBackupRetention(value[i]);\n      if (typeof candidate === 'number') {\n        return candidate;\n      }\n    }\n    return null;\n  }\n  if (isPlainObject(value)) {\n    const candidateKeys = ['value', 'retention', 'limit', 'count'];\n    for (let i = 0; i < candidateKeys.length; i += 1) {\n      const key = candidateKeys[i];\n      if (!Object.prototype.hasOwnProperty.call(value, key)) {\n        continue;\n      }\n      const candidate = normalizeImportedAutoGearBackupRetention(value[key]);\n      if (typeof candidate === 'number') {\n        return candidate;\n      }\n    }\n    return null;\n  }\n  if (typeof value === 'boolean') {\n    return value ? AUTO_GEAR_BACKUP_RETENTION_MIN : null;\n  }\n  return null;\n}\n\nfunction normalizeImportedAutoGearPresets(value) {\n  const presets = normalizeImportedArray(\n    value,\n    [\"presets\", \"entries\", \"items\", \"list\", \"values\", \"data\"],\n    (entry) => entry !== null && typeof entry === \"object\",\n  );\n  if (!Array.isArray(presets)) {\n    return [];\n  }\n  return normalizeLegacyLongGopStructure(presets);\n}\n\nfunction normalizeImportedAutoGearMonitorDefaults(value) {\n  if (!value || typeof value !== 'object') {\n    return {};\n  }\n  const normalized = {};\n  Object.entries(value).forEach(([key, val]) => {\n    if (typeof val !== 'string') return;\n    const trimmed = val.trim();\n    if (!trimmed) return;\n    normalized[key] = trimmed;\n  });\n  const legacyNormalized = normalizeLegacyLongGopStructure(normalized);\n  return isPlainObject(legacyNormalized) ? legacyNormalized : normalized;\n}\n\nfunction normalizeImportedPresetId(value) {\n  if (typeof value === \"string\") {\n    return value;\n  }\n  if (typeof value === \"number\") {\n    return Number.isNaN(value) ? \"\" : String(value);\n  }\n  if (Array.isArray(value)) {\n    for (let i = 0; i < value.length; i += 1) {\n      const candidate = normalizeImportedPresetId(value[i]);\n      if (candidate) {\n        return candidate;\n      }\n    }\n    return \"\";\n  }\n  if (isPlainObject(value)) {\n    if (typeof value.id === \"string\" && value.id) {\n      return value.id;\n    }\n    if (typeof value.value === \"string\") {\n      return value.value;\n    }\n    if (Object.prototype.hasOwnProperty.call(value, \"name\")) {\n      return normalizeImportedPresetId(value.name);\n    }\n  }\n  return \"\";\n}\n\nfunction normalizeImportedBackupVaultRecords(value) {\n  const records = normalizeImportedArray(\n    value,\n    ['backupVaultRecords', 'backupVault', 'vault', 'records', 'entries', 'items', 'list', 'values', 'data'],\n    (entry) => entry && typeof entry === 'object',\n  );\n  return normalizeBackupVaultRecordList(records);\n}\n\nfunction importBackupVaultRecords(records) {\n  const normalized = normalizeBackupVaultRecordList(records);\n  if (!normalized.length) {\n    return;\n  }\n\n  const existingFallback = readBackupVaultFallbackRecords();\n  const mergedFallback = mergeBackupVaultRecords(existingFallback, normalized);\n  try {\n    safeSetLocalStorage('cineBackupVaultFallbackRecords', JSON.stringify(mergedFallback));\n  } catch (storageError) {\n    console.warn('Unable to persist imported backup vault fallback records', storageError);\n  }\n\n  const api = resolveBackupVaultApi();\n  if (!api || typeof api.queueBackupPayloadForVault !== 'function') {\n    return;\n  }\n\n  const queueRecord = (record) => {\n    api.queueBackupPayloadForVault(\n      record.fileName,\n      record.payload,\n      {\n        id: record.id,\n        createdAt: record.createdAt,\n        createdAtMs: record.createdAtMs,\n        source: record.metadata && record.metadata.source ? record.metadata.source : undefined,\n        reason: record.metadata && record.metadata.reason ? record.metadata.reason : undefined,\n        permissionState: record.metadata && record.metadata.permissionState\n          ? record.metadata.permissionState\n          : undefined,\n      },\n    );\n  };\n\n  const loader = typeof api.listBackupVaultRecords === 'function'\n    ? api.listBackupVaultRecords\n    : typeof api.getQueuedBackupPayloads === 'function'\n      ? api.getQueuedBackupPayloads\n      : null;\n\n  if (!loader) {\n    normalized.forEach(queueRecord);\n    return;\n  }\n\n  try {\n    const response = loader();\n    if (Array.isArray(response)) {\n      const existingIds = new Set(response.map((entry) => (entry && entry.id ? entry.id : null)));\n      normalized.forEach((record) => {\n        if (!existingIds.has(record.id)) {\n          queueRecord(record);\n        }\n      });\n      return;\n    }\n    if (response && typeof response.then === 'function') {\n      response.then((existing) => {\n        const existingIds = new Set(\n          Array.isArray(existing)\n            ? existing.map((entry) => (entry && entry.id ? entry.id : null))\n            : [],\n        );\n        normalized.forEach((record) => {\n          if (!existingIds.has(record.id)) {\n            queueRecord(record);\n          }\n        });\n      }).catch((error) => {\n        console.warn('Unable to inspect backup vault before import', error);\n        normalized.forEach(queueRecord);\n      });\n      return;\n    }\n    normalized.forEach(queueRecord);\n  } catch (error) {\n    console.warn('Unable to import backup vault records via backup module', error);\n    normalized.forEach(queueRecord);\n  }\n}\n\nfunction getSnapshotKeyVariants(key) {\n  return getStorageKeyVariants(key);\n}\n\nfunction readSnapshotEntry(snapshot, key) {\n  if (!isPlainObject(snapshot)) {\n    return null;\n  }\n\n  const variants = getSnapshotKeyVariants(key);\n  for (let i = 0; i < variants.length; i += 1) {\n    const candidate = variants[i];\n    if (Object.prototype.hasOwnProperty.call(snapshot, candidate)) {\n      return { key: candidate, value: snapshot[candidate], type: 'primary' };\n    }\n  }\n\n  for (let i = 0; i < variants.length; i += 1) {\n    const candidate = `${variants[i]}${STORAGE_BACKUP_SUFFIX}`;\n    if (Object.prototype.hasOwnProperty.call(snapshot, candidate)) {\n      return { key: candidate, value: snapshot[candidate], type: 'backup' };\n    }\n  }\n\n  for (let i = 0; i < variants.length; i += 1) {\n    const candidate = `${variants[i]}${STORAGE_MIGRATION_BACKUP_SUFFIX}`;\n    if (Object.prototype.hasOwnProperty.call(snapshot, candidate)) {\n      return { key: candidate, value: snapshot[candidate], type: 'migration-backup' };\n    }\n  }\n\n  return null;\n}\n\nfunction extractSnapshotStoredValue(entry) {\n  if (!entry) {\n    return undefined;\n  }\n\n  let raw = entry.value;\n  if (entry.type === 'migration-backup') {\n    try {\n      const parsed = typeof raw === 'string' ? JSON.parse(raw) : raw;\n      if (parsed && typeof parsed === 'object') {\n        const compressionToken = typeof parsed.compression === 'string' ? parsed.compression.trim() : '';\n        const encodingToken = typeof parsed.encoding === 'string' ? parsed.encoding.trim() : '';\n        const isModernCompression =\n          compressionToken === MIGRATION_BACKUP_COMPRESSION_ALGORITHM\n          && encodingToken === MIGRATION_BACKUP_COMPRESSION_ENCODING;\n        const isLegacyLongGopCompression =\n          LEGACY_LONG_GOP_TOKEN_REGEX.test(compressionToken)\n          || LEGACY_LONG_GOP_TOKEN_REGEX.test(encodingToken);\n\n        if ((isModernCompression || isLegacyLongGopCompression) && typeof parsed.data === 'string') {\n          if (canUseMigrationBackupCompression()) {\n            let preferredVariant = typeof parsed.compressionVariant === 'string'\n              && parsed.compressionVariant\n              ? parsed.compressionVariant\n              : null;\n            if (!preferredVariant) {\n              if (isLegacyLongGopCompression) {\n                preferredVariant = inferLegacyLongGopCompressionVariant(encodingToken)\n                  || inferLegacyLongGopCompressionVariant(compressionToken)\n                  || 'utf16';\n              } else {\n                preferredVariant = 'utf16';\n              }\n            }\n            const decoded = tryDecompressWithStrategies(\n              parsed.data,\n              MIGRATION_BACKUP_COMPRESSION_VARIANTS,\n              preferredVariant,\n              'migration backup entry',\n            );\n            if (decoded.success && typeof decoded.value === 'string') {\n              try {\n                const payload = JSON.parse(decoded.value);\n                if (payload && typeof payload === 'object' && Object.prototype.hasOwnProperty.call(payload, 'data')) {\n                  raw = payload.data;\n                } else {\n                  raw = null;\n                }\n              } catch (parseError) {\n                console.warn('Unable to parse migration backup entry during import', entry.key, parseError);\n                raw = null;\n              }\n            } else {\n              console.warn('Unable to decompress migration backup entry during import', entry && entry.key, decoded.error);\n              raw = null;\n            }\n          } else {\n            console.warn('Compression support is unavailable while reading migration backup entry', entry && entry.key);\n            raw = null;\n          }\n        } else if (Object.prototype.hasOwnProperty.call(parsed, 'data')) {\n          raw = parsed.data;\n        } else {\n          raw = null;\n        }\n      } else {\n        raw = null;\n      }\n    } catch (error) {\n      console.warn('Unable to parse migration backup entry during import', entry.key, error);\n      raw = null;\n    }\n  }\n\n  return raw;\n}\n\nfunction parseSnapshotJSONValue(entry) {\n  const raw = extractSnapshotStoredValue(entry);\n  if (raw === undefined) {\n    return undefined;\n  }\n  if (raw === null) {\n    return null;\n  }\n  if (typeof raw === 'string') {\n    const decoded = decodeStoredValue(raw);\n    if (decoded === null) {\n      return null;\n    }\n    if (decoded === undefined) {\n      return undefined;\n    }\n    if (typeof decoded !== 'string') {\n      return decoded;\n    }\n    const trimmed = decoded.trim();\n    if (!trimmed) {\n      return '';\n    }\n    try {\n      return JSON.parse(trimmed);\n    } catch {\n      return decoded;\n    }\n  }\n  return raw;\n}\n\nfunction parseSnapshotStringValue(entry) {\n  const raw = extractSnapshotStoredValue(entry);\n  if (raw === undefined) {\n    return undefined;\n  }\n  if (raw === null) {\n    return null;\n  }\n  if (typeof raw === 'string') {\n    const decoded = decodeStoredValue(raw);\n    if (decoded === null) {\n      return null;\n    }\n    if (decoded === undefined) {\n      return undefined;\n    }\n    if (typeof decoded === 'string') {\n      return decoded;\n    }\n    if (typeof decoded === 'number' || typeof decoded === 'boolean') {\n      return String(decoded);\n    }\n    if (Array.isArray(decoded) || (decoded && typeof decoded === 'object')) {\n      try {\n        return JSON.stringify(decoded);\n      } catch (serializationError) {\n        console.warn('Unable to serialize snapshot entry during import', entry && entry.key, serializationError);\n        return null;\n      }\n    }\n    return null;\n  }\n  if (typeof raw === 'number' || typeof raw === 'boolean') {\n    return String(raw);\n  }\n  if (Array.isArray(raw) || (raw && typeof raw === 'object')) {\n    try {\n      return JSON.stringify(raw);\n    } catch (serializationError) {\n      console.warn('Unable to serialize snapshot entry during import', entry && entry.key, serializationError);\n      return null;\n    }\n  }\n  return null;\n}\n\nfunction convertStorageSnapshotToData(snapshot) {\n  if (!isPlainObject(snapshot)) {\n    return null;\n  }\n\n  const exportStructureKeys = [\n    'devices',\n    'setups',\n    'session',\n    'feedback',\n    'favorites',\n    'contacts',\n    'preferences',\n    'project',\n    'projects',\n    'autoGearRules',\n    'autoGearBackups',\n    'autoGearPresets',\n    'autoGearMonitorDefaults',\n    'autoGearSeeded',\n    'autoGearActivePresetId',\n    'autoGearAutoPresetId',\n    'autoGearBackupRetention',\n    'autoGearShowBackups',\n    'fullBackupHistory',\n    'fullBackups',\n    'backupVaultRecords',\n  ];\n\n  const resemblesExportPayload = exportStructureKeys.some((key) =>\n    Object.prototype.hasOwnProperty.call(snapshot, key),\n  );\n\n  if (resemblesExportPayload) {\n    return null;\n  }\n\n  const data = {};\n  let hasAssignments = false;\n  let hasSnapshotKeys = false;\n\n  const preferenceKeys = [\n    'darkMode',\n    'pinkMode',\n    'highContrast',\n    'reduceMotion',\n    'relaxedSpacing',\n    'showAutoBackups',\n    'accentColor',\n    'fontSize',\n    'fontFamily',\n    'language',\n    'iosPwaHelpShown',\n    CAMERA_COLOR_STORAGE_KEY,\n    PRINT_PREFERENCES_STORAGE_KEY,\n  ];\n\n  const mountVoltageKeyName = getMountVoltageStorageKeyName();\n  const simpleSnapshotKeys = new Set(\n    [CUSTOM_LOGO_STORAGE_KEY, ...preferenceKeys, mountVoltageKeyName].filter(\n      (key) => typeof key === 'string' && key,\n    ),\n  );\n\n  const booleanPreferenceKeys = new Set([\n    'darkMode',\n    'pinkMode',\n    'highContrast',\n    'reduceMotion',\n    'relaxedSpacing',\n    'showAutoBackups',\n    'iosPwaHelpShown',\n  ]);\n\n  const markSnapshotEntry = (entry) => {\n    if (!entry || typeof entry.key !== 'string') {\n      return;\n    }\n    if (\n      entry.key.startsWith('cameraPowerPlanner_') ||\n      entry.key.startsWith('cinePowerPlanner_') ||\n      entry.key.endsWith(STORAGE_BACKUP_SUFFIX) ||\n      entry.key.endsWith(STORAGE_MIGRATION_BACKUP_SUFFIX)\n    ) {\n      hasSnapshotKeys = true;\n      return;\n    }\n\n    const normalizedKey = entry.key.replace(/(?:__backup|__legacyMigrationBackup)$/u, '');\n    if (simpleSnapshotKeys.has(normalizedKey)) {\n      hasSnapshotKeys = true;\n    }\n  };\n\n  const assignJSONValue = (storageKey, targetKey) => {\n    const entry = readSnapshotEntry(snapshot, storageKey);\n    if (!entry) {\n      return;\n    }\n    markSnapshotEntry(entry);\n    const value = parseSnapshotJSONValue(entry);\n    if (value === undefined) {\n      return;\n    }\n    data[targetKey] = value;\n    hasAssignments = true;\n  };\n\n  assignJSONValue(DEVICE_STORAGE_KEY, 'devices');\n  assignJSONValue(SETUP_STORAGE_KEY, 'setups');\n  assignJSONValue(SESSION_STATE_KEY, 'session');\n  assignJSONValue(FEEDBACK_STORAGE_KEY, 'feedback');\n  assignJSONValue(PROJECT_STORAGE_KEY, 'project');\n  assignJSONValue(FAVORITES_STORAGE_KEY, 'favorites');\n  assignJSONValue(CONTACTS_STORAGE_KEY, 'contacts');\n  assignJSONValue(OWN_GEAR_STORAGE_KEY, 'ownGear');\n  assignJSONValue(USER_PROFILE_STORAGE_KEY, 'userProfile');\n  assignJSONValue(DOCUMENTATION_TRACKER_STORAGE_KEY, 'documentationTracker');\n  assignJSONValue(AUTO_GEAR_RULES_STORAGE_KEY, 'autoGearRules');\n  assignJSONValue(AUTO_GEAR_BACKUPS_STORAGE_KEY, 'autoGearBackups');\n  assignJSONValue(AUTO_GEAR_PRESETS_STORAGE_KEY, 'autoGearPresets');\n  assignJSONValue(AUTO_GEAR_MONITOR_DEFAULTS_STORAGE_KEY, 'autoGearMonitorDefaults');\n  assignJSONValue(AUTO_GEAR_BACKUP_RETENTION_STORAGE_KEY, 'autoGearBackupRetention');\n\n  const schemaEntry = readSnapshotEntry(snapshot, DEVICE_SCHEMA_CACHE_KEY);\n  if (schemaEntry) {\n    markSnapshotEntry(schemaEntry);\n    const cacheValue = parseSnapshotStringValue(schemaEntry);\n    if (cacheValue !== undefined) {\n      data.schemaCache = cacheValue;\n      hasAssignments = true;\n    }\n  }\n\n  const customFontsEntry = readSnapshotEntry(snapshot, getCustomFontStorageKeyName());\n  if (customFontsEntry) {\n    markSnapshotEntry(customFontsEntry);\n    const fontsValue = parseSnapshotJSONValue(customFontsEntry);\n    if (fontsValue !== undefined) {\n      data.customFonts = fontsValue;\n      hasAssignments = true;\n    }\n  }\n\n  const customLogoEntry = readSnapshotEntry(snapshot, CUSTOM_LOGO_STORAGE_KEY);\n  if (customLogoEntry) {\n    markSnapshotEntry(customLogoEntry);\n    const logoValue = parseSnapshotStringValue(customLogoEntry);\n    if (logoValue !== undefined) {\n      data.customLogo = logoValue;\n      hasAssignments = true;\n    }\n  }\n\n  const seedEntry = readSnapshotEntry(snapshot, AUTO_GEAR_SEEDED_STORAGE_KEY);\n  if (seedEntry) {\n    markSnapshotEntry(seedEntry);\n    data.autoGearSeeded = extractSnapshotStoredValue(seedEntry);\n    hasAssignments = true;\n  }\n\n  const activePresetEntry = readSnapshotEntry(snapshot, AUTO_GEAR_ACTIVE_PRESET_STORAGE_KEY);\n  if (activePresetEntry) {\n    markSnapshotEntry(activePresetEntry);\n    data.autoGearActivePresetId = parseSnapshotStringValue(activePresetEntry);\n    hasAssignments = true;\n  }\n\n  const autoPresetEntry = readSnapshotEntry(snapshot, AUTO_GEAR_AUTO_PRESET_STORAGE_KEY);\n  if (autoPresetEntry) {\n    markSnapshotEntry(autoPresetEntry);\n    data.autoGearAutoPresetId = parseSnapshotStringValue(autoPresetEntry);\n    hasAssignments = true;\n  }\n\n  const backupsVisibilityEntry = readSnapshotEntry(snapshot, AUTO_GEAR_BACKUP_VISIBILITY_STORAGE_KEY);\n  if (backupsVisibilityEntry) {\n    markSnapshotEntry(backupsVisibilityEntry);\n    data.autoGearShowBackups = extractSnapshotStoredValue(backupsVisibilityEntry);\n    hasAssignments = true;\n  }\n\n  const preferences = {};\n\n  preferenceKeys.forEach((key) => {\n    const entry = readSnapshotEntry(snapshot, key);\n    if (!entry) {\n      return;\n    }\n    markSnapshotEntry(entry);\n    if (key === PRINT_PREFERENCES_STORAGE_KEY) {\n      const snapshotPrintValue = parseSnapshotStringValue(entry);\n      if (snapshotPrintValue !== undefined) {\n        const interpretedPreferences = interpretPrintPreferencesValue(snapshotPrintValue);\n        if (interpretedPreferences) {\n          if (interpretedPreferences.normalized) {\n            preferences[key] = storageJsonDeepClone(interpretedPreferences.normalized);\n            hasAssignments = true;\n            return;\n          }\n          if (interpretedPreferences.serialized) {\n            preferences[key] = interpretedPreferences.serialized;\n            hasAssignments = true;\n            return;\n          }\n        }\n      }\n      return;\n    }\n    const raw = extractSnapshotStoredValue(entry);\n    if (booleanPreferenceKeys.has(key)) {\n      const normalized = normalizeImportedBoolean(raw);\n      if (normalized !== null) {\n        preferences[key] = normalized;\n        hasAssignments = true;\n        return;\n      }\n    }\n    const stringValue = parseSnapshotStringValue(entry);\n    if (stringValue !== undefined) {\n      preferences[key] = stringValue;\n      hasAssignments = true;\n    }\n  });\n\n  const temperatureUnitEntry = readSnapshotEntry(snapshot, TEMPERATURE_UNIT_STORAGE_KEY_NAME);\n  if (temperatureUnitEntry) {\n    markSnapshotEntry(temperatureUnitEntry);\n    const storedUnit = parseSnapshotStringValue(temperatureUnitEntry);\n    if (typeof storedUnit === 'string') {\n      const normalizedUnit = storedUnit.trim();\n      if (normalizedUnit) {\n        preferences.temperatureUnit = normalizedUnit;\n        hasAssignments = true;\n      }\n    }\n  }\n\n  const focusScaleEntry = readSnapshotEntry(snapshot, FOCUS_SCALE_STORAGE_KEY_NAME);\n  if (focusScaleEntry) {\n    markSnapshotEntry(focusScaleEntry);\n    const storedScale = parseSnapshotStringValue(focusScaleEntry);\n    if (typeof storedScale === 'string') {\n      const normalizedScale = storedScale.trim();\n      if (normalizedScale) {\n        preferences.focusScale = normalizedScale;\n        hasAssignments = true;\n      }\n    }\n  }\n\n  const cameraColorsEntry = readSnapshotEntry(snapshot, CAMERA_COLOR_STORAGE_KEY);\n  if (cameraColorsEntry) {\n    markSnapshotEntry(cameraColorsEntry);\n    const storedCameraColors = parseSnapshotJSONValue(cameraColorsEntry);\n    if (storedCameraColors !== undefined) {\n      preferences.cameraColors = storedCameraColors;\n      hasAssignments = true;\n    }\n  }\n\n  const mountVoltageEntry = readSnapshotEntry(snapshot, mountVoltageKeyName);\n  if (mountVoltageEntry) {\n    markSnapshotEntry(mountVoltageEntry);\n    const storedVoltages = parseSnapshotJSONValue(mountVoltageEntry);\n    if (storedVoltages !== undefined) {\n      preferences.mountVoltages = storedVoltages;\n      hasAssignments = true;\n    }\n  }\n\n  if (Object.keys(preferences).length > 0) {\n    data.preferences = preferences;\n  }\n\n  if (!hasAssignments || !hasSnapshotKeys) {\n    return null;\n  }\n\n  return data;\n}\n\nfunction importAllData(allData, options = {}) {\n  if (Array.isArray(allData)) {\n    importProjectCollection(allData, () => createProjectImporter());\n    return;\n  }\n\n  if (!isPlainObject(allData)) {\n    return;\n  }\n\n  const { skipSnapshotConversion = false } = options || {};\n\n  if (!skipSnapshotConversion) {\n    const converted = convertStorageSnapshotToData(allData);\n    if (converted) {\n      importAllData(converted, { skipSnapshotConversion: true });\n      return;\n    }\n  }\n\n  const hasOwn = (key) => Object.prototype.hasOwnProperty.call(allData, key);\n  const mountVoltageKeyName = getMountVoltageStorageKeyName();\n  const cameraColorKeyName = CAMERA_COLOR_STORAGE_KEY;\n\n  if (hasOwn('devices')) {\n    saveDeviceData(allData.devices);\n  }\n  if (hasOwn('setups')) {\n    saveSetups(allData.setups);\n  }\n  if (hasOwn('session')) {\n    saveSessionState(allData.session, { disableCompression: true });\n  }\n  if (hasOwn('feedback')) {\n    saveFeedback(allData.feedback);\n  }\n  if (hasOwn('favorites')) {\n    saveFavorites(allData.favorites);\n  }\n  if (hasOwn('contacts')) {\n    if (allData.contacts === null) {\n      saveContacts(null);\n    } else {\n      const contacts = normalizeImportedContacts(allData.contacts);\n      saveContacts(contacts);\n    }\n  }\n  if (hasOwn('ownGear')) {\n    const entries = normalizeImportedArray(\n      allData.ownGear,\n      ['items', 'entries', 'list', 'values', 'data'],\n      (entry) => entry && typeof entry === 'object',\n    );\n    saveOwnGear(entries);\n  }\n  if (hasOwn('userProfile')) {\n    if (allData.userProfile === null) {\n      saveUserProfile(null);\n    } else if (isPlainObject(allData.userProfile)) {\n      const profile = normalizeUserProfile(allData.userProfile);\n      if (profile) {\n        saveUserProfile(profile);\n      } else {\n        saveUserProfile(null);\n      }\n    }\n  }\n  if (isPlainObject(allData.preferences)) {\n    const prefs = allData.preferences;\n    const booleanPrefs = [\n      'darkMode',\n      'pinkMode',\n      'highContrast',\n      'reduceMotion',\n      'relaxedSpacing',\n      'showAutoBackups',\n      'iosPwaHelpShown',\n    ];\n    booleanPrefs.forEach((key) => {\n      if (Object.prototype.hasOwnProperty.call(prefs, key) && typeof prefs[key] === 'boolean') {\n        safeSetLocalStorage(key, prefs[key]);\n      }\n    });\n    const stringPrefs = ['accentColor', 'fontSize', 'fontFamily', 'language'];\n    stringPrefs.forEach((key) => {\n      if (Object.prototype.hasOwnProperty.call(prefs, key)) {\n        const value = prefs[key];\n        if (typeof value === 'string' && value) {\n          safeSetLocalStorage(key, value);\n        }\n      }\n    });\n\n    if (Object.prototype.hasOwnProperty.call(prefs, 'temperatureUnit')) {\n      const unit = prefs.temperatureUnit;\n      if (typeof unit === 'string') {\n        const normalizedUnit = unit.trim();\n        if (normalizedUnit) {\n          safeSetLocalStorage(TEMPERATURE_UNIT_STORAGE_KEY_NAME, normalizedUnit);\n        }\n      } else if (unit === null) {\n        safeSetLocalStorage(TEMPERATURE_UNIT_STORAGE_KEY_NAME, null);\n      }\n    }\n    if (Object.prototype.hasOwnProperty.call(prefs, 'focusScale')) {\n      const scale = prefs.focusScale;\n      if (typeof scale === 'string') {\n        const normalizedScale = scale.trim();\n        if (normalizedScale) {\n          safeSetLocalStorage(FOCUS_SCALE_STORAGE_KEY_NAME, normalizedScale);\n          if (typeof window !== 'undefined' && typeof window.applyFocusScalePreference === 'function') {\n            try {\n              window.applyFocusScalePreference(normalizedScale, { persist: false, forceUpdate: true });\n            } catch (focusScaleError) {\n              console.warn('Unable to apply imported focus scale preference', focusScaleError);\n            }\n          }\n        }\n      } else if (scale === null) {\n        safeSetLocalStorage(FOCUS_SCALE_STORAGE_KEY_NAME, null);\n      }\n    }\n    if (Object.prototype.hasOwnProperty.call(prefs, PRINT_PREFERENCES_STORAGE_KEY)) {\n      const rawPrintPreferences = prefs[PRINT_PREFERENCES_STORAGE_KEY];\n      if (rawPrintPreferences === null) {\n        safeSetLocalStorage(PRINT_PREFERENCES_STORAGE_KEY, null);\n      } else {\n        const interpretedPreferences = interpretPrintPreferencesValue(rawPrintPreferences);\n        if (interpretedPreferences) {\n          if (interpretedPreferences.normalized) {\n            const normalizedPrintPreferences = storageJsonDeepClone(\n              interpretedPreferences.normalized,\n            );\n            let serializedPrintPreferences = null;\n            try {\n              serializedPrintPreferences = JSON.stringify(normalizedPrintPreferences);\n            } catch (printPreferenceSerializationError) {\n              console.warn(\n                'Unable to serialize imported print preferences',\n                printPreferenceSerializationError,\n              );\n              serializedPrintPreferences = null;\n            }\n            if (serializedPrintPreferences !== null) {\n              try {\n                safeSetLocalStorage(PRINT_PREFERENCES_STORAGE_KEY, serializedPrintPreferences);\n              } catch (printPreferencePersistError) {\n                console.warn(\n                  'Unable to persist imported print preferences',\n                  printPreferencePersistError,\n                );\n              }\n            }\n            if (typeof window !== 'undefined' && typeof window.savePrintPreferences === 'function') {\n              try {\n                window.savePrintPreferences(normalizedPrintPreferences);\n              } catch (printPreferenceApplyError) {\n                console.warn(\n                  'Unable to apply imported print preferences',\n                  printPreferenceApplyError,\n                );\n              }\n            }\n          } else if (interpretedPreferences.serialized) {\n            try {\n              safeSetLocalStorage(\n                PRINT_PREFERENCES_STORAGE_KEY,\n                interpretedPreferences.serialized,\n              );\n            } catch (printPreferenceStringPersistError) {\n              console.warn(\n                'Unable to store imported print preferences string value',\n                printPreferenceStringPersistError,\n              );\n            }\n          }\n        }\n      }\n    }\n    if (Object.prototype.hasOwnProperty.call(prefs, 'mountVoltages')) {\n      const rawVoltages = prefs.mountVoltages;\n      if (rawVoltages && typeof rawVoltages === 'object') {\n        try {\n          safeSetLocalStorage(mountVoltageKeyName, JSON.stringify(rawVoltages));\n        } catch (voltStoreError) {\n          console.warn('Unable to store imported mount voltages', voltStoreError);\n        }\n        if (typeof window !== 'undefined' && typeof window.applyMountVoltagePreferences === 'function') {\n          window.applyMountVoltagePreferences(rawVoltages, { persist: false, triggerUpdate: true });\n        }\n      } else if (typeof rawVoltages === 'string') {\n        safeSetLocalStorage(mountVoltageKeyName, rawVoltages);\n        if (typeof window !== 'undefined' && typeof window.parseStoredMountVoltages === 'function') {\n          try {\n            const parsedVoltages = window.parseStoredMountVoltages(rawVoltages);\n            if (parsedVoltages && typeof window.applyMountVoltagePreferences === 'function') {\n              window.applyMountVoltagePreferences(parsedVoltages, { persist: false, triggerUpdate: true });\n            }\n          } catch (voltParseError) {\n            console.warn('Unable to parse imported mount voltages', voltParseError);\n          }\n        }\n      } else if (rawVoltages === null) {\n        safeSetLocalStorage(mountVoltageKeyName, null);\n        if (typeof window !== 'undefined' && typeof window.resetMountVoltagePreferences === 'function') {\n          window.resetMountVoltagePreferences({ persist: false, triggerUpdate: true });\n        }\n      }\n    }\n    if (Object.prototype.hasOwnProperty.call(prefs, 'cameraColors')) {\n      const rawCameraColors = prefs.cameraColors;\n      const applyImportedCameraColors = (palette) => {\n        if (!palette || typeof palette !== 'object') {\n          return false;\n        }\n\n        let applied = false;\n        if (typeof window !== 'undefined' && window && typeof window.setCameraLetterColors === 'function') {\n          try {\n            window.setCameraLetterColors(palette);\n            applied = true;\n          } catch (cameraColorApplyError) {\n            console.warn('Unable to apply imported camera color preferences', cameraColorApplyError);\n            applied = false;\n          }\n        }\n\n        let serializedPalette = null;\n        try {\n          serializedPalette = JSON.stringify(palette);\n        } catch (cameraColorSerializeError) {\n          console.warn('Unable to serialize imported camera color preferences', cameraColorSerializeError);\n          serializedPalette = null;\n        }\n\n        if (serializedPalette) {\n          try {\n            safeSetLocalStorage(cameraColorKeyName, serializedPalette);\n          } catch (cameraColorPersistError) {\n            console.warn('Unable to persist imported camera color preferences', cameraColorPersistError);\n          }\n        }\n\n        return applied;\n      };\n\n      if (rawCameraColors && typeof rawCameraColors === 'object') {\n        applyImportedCameraColors(rawCameraColors);\n      } else if (typeof rawCameraColors === 'string') {\n        const trimmedCameraColors = rawCameraColors.trim();\n        if (trimmedCameraColors) {\n          let parsedCameraColors = null;\n          try {\n            parsedCameraColors = JSON.parse(trimmedCameraColors);\n          } catch (cameraColorParseError) {\n            console.warn('Unable to parse imported camera color palette', cameraColorParseError);\n            parsedCameraColors = null;\n          }\n          if (parsedCameraColors && typeof parsedCameraColors === 'object') {\n            applyImportedCameraColors(parsedCameraColors);\n          } else {\n            try {\n              safeSetLocalStorage(cameraColorKeyName, trimmedCameraColors);\n            } catch (cameraColorStoreError) {\n              console.warn('Unable to store raw imported camera color palette', cameraColorStoreError);\n            }\n          }\n        }\n      } else if (rawCameraColors === null) {\n        safeSetLocalStorage(cameraColorKeyName, null);\n      }\n    }\n  }\n  if (Object.prototype.hasOwnProperty.call(allData, 'customLogo')) {\n    const logo = allData.customLogo;\n    if (typeof logo === 'string' && logo) {\n      safeSetLocalStorage(CUSTOM_LOGO_STORAGE_KEY, logo);\n    } else {\n      safeSetLocalStorage(CUSTOM_LOGO_STORAGE_KEY, null);\n    }\n  }\n  if (Object.prototype.hasOwnProperty.call(allData, 'customFonts')) {\n    const fonts = normalizeCustomFontEntries(allData.customFonts);\n    if (fonts.length) {\n      try {\n        safeSetLocalStorage(\n          getCustomFontStorageKeyName(),\n          JSON.stringify(fonts)\n        );\n      } catch (error) {\n        console.warn('Unable to store imported custom fonts', error);\n      }\n    } else {\n      safeSetLocalStorage(getCustomFontStorageKeyName(), null);\n    }\n  }\n  if (Object.prototype.hasOwnProperty.call(allData, 'schemaCache')) {\n    const cache = allData.schemaCache;\n    if (typeof cache === 'string' || cache === null) {\n      safeSetLocalStorage(DEVICE_SCHEMA_CACHE_KEY, cache);\n    } else if (cache && typeof cache === 'object') {\n      try {\n        safeSetLocalStorage(DEVICE_SCHEMA_CACHE_KEY, JSON.stringify(cache));\n      } catch (schemaError) {\n        console.warn('Unable to store imported schema cache', schemaError);\n      }\n    }\n  }\n  if (Object.prototype.hasOwnProperty.call(allData, 'documentationTracker')) {\n    const trackerState = normalizeDocumentationTrackerState(allData.documentationTracker);\n    saveDocumentationTracker(trackerState);\n  } else if (Object.prototype.hasOwnProperty.call(allData, 'documentationLogs')) {\n    const trackerFromLogs = normalizeDocumentationTrackerState({ releases: allData.documentationLogs });\n    saveDocumentationTracker(trackerFromLogs);\n  } else if (Object.prototype.hasOwnProperty.call(allData, 'documentationUpdateLog')) {\n    const trackerFromLegacy = normalizeDocumentationTrackerState(allData.documentationUpdateLog);\n    saveDocumentationTracker(trackerFromLegacy);\n  }\n  if (Object.prototype.hasOwnProperty.call(allData, 'autoGearRules')) {\n    const rules = normalizeImportedAutoGearRules(allData.autoGearRules);\n    saveAutoGearRules(rules);\n  }\n  if (Object.prototype.hasOwnProperty.call(allData, 'autoGearBackups')) {\n    const backups = normalizeImportedAutoGearBackups(allData.autoGearBackups);\n    saveAutoGearBackups(backups);\n  }\n  if (Object.prototype.hasOwnProperty.call(allData, 'autoGearSeeded')) {\n    const flag = normalizeImportedBoolean(allData.autoGearSeeded);\n    if (flag === null) {\n      saveAutoGearSeedFlag(false);\n    } else {\n      saveAutoGearSeedFlag(flag);\n    }\n  }\n  if (Object.prototype.hasOwnProperty.call(allData, 'autoGearPresets')) {\n    const presets = normalizeImportedAutoGearPresets(allData.autoGearPresets);\n    saveAutoGearPresets(presets);\n  }\n  if (Object.prototype.hasOwnProperty.call(allData, 'autoGearMonitorDefaults')) {\n    const defaults = normalizeImportedAutoGearMonitorDefaults(allData.autoGearMonitorDefaults);\n    saveAutoGearMonitorDefaults(defaults);\n  }\n  if (Object.prototype.hasOwnProperty.call(allData, 'autoGearActivePresetId')) {\n    const presetId = normalizeImportedPresetId(allData.autoGearActivePresetId);\n    saveAutoGearActivePresetId(typeof presetId === 'string' ? presetId : '');\n  }\n  if (Object.prototype.hasOwnProperty.call(allData, 'autoGearAutoPresetId')) {\n    saveAutoGearAutoPresetId(\n      typeof allData.autoGearAutoPresetId === 'string' ? allData.autoGearAutoPresetId : ''\n    );\n  }\n  if (Object.prototype.hasOwnProperty.call(allData, 'autoGearShowBackups')) {\n    const visibility = normalizeImportedBoolean(allData.autoGearShowBackups);\n    if (visibility === null) {\n      saveAutoGearBackupVisibility(false);\n    } else {\n      saveAutoGearBackupVisibility(visibility);\n    }\n  }\n  if (Object.prototype.hasOwnProperty.call(allData, 'autoGearBackupRetention')) {\n    const retention = normalizeImportedAutoGearBackupRetention(allData.autoGearBackupRetention);\n    if (typeof retention === 'number' && Number.isFinite(retention)) {\n      saveAutoGearBackupRetention(retention);\n    }\n  }\n\n  if (Object.prototype.hasOwnProperty.call(allData, 'fullBackupHistory')) {\n    const history = normalizeImportedFullBackupHistory(allData.fullBackupHistory);\n    saveFullBackupHistory(history);\n  } else if (Object.prototype.hasOwnProperty.call(allData, 'fullBackups')) {\n    const history = normalizeImportedFullBackupHistory(allData.fullBackups);\n    saveFullBackupHistory(history);\n  }\n  if (Object.prototype.hasOwnProperty.call(allData, 'backupVaultRecords')) {\n    const backupRecords = normalizeImportedBackupVaultRecords(allData.backupVaultRecords);\n    importBackupVaultRecords(backupRecords);\n  } else if (Object.prototype.hasOwnProperty.call(allData, 'backupVault')) {\n    const backupRecords = normalizeImportedBackupVaultRecords(allData.backupVault);\n    importBackupVaultRecords(backupRecords);\n  }\n\n  let importProjectEntry = null;\n  const ensureProjectImporter = () => {\n    if (!importProjectEntry) {\n      importProjectEntry = createProjectImporter();\n    }\n    return importProjectEntry;\n  };\n\n  let projectImported = false;\n  const getTrackedImporter = () => {\n    const importer = ensureProjectImporter();\n    return (name, project, fallback) => {\n      projectImported = true;\n      importer(name, project, fallback);\n    };\n  };\n\n  const importTrackedCollection = (collection, fallbackLabel) => {\n    const wrapped = () => getTrackedImporter();\n    const result = importProjectCollection(collection, wrapped, fallbackLabel);\n    if (result) {\n      projectImported = true;\n    }\n    return result;\n  };\n\n  if (allData.project) {\n    importTrackedCollection(allData.project, \"\");\n  }\n  if (allData.projects) {\n    // Legacy plural key. Accept object map or array of named projects.\n    importTrackedCollection(allData.projects);\n  } else if (!allData.project && typeof allData.gearList === \"string\") {\n    // Legacy export format stored just the gear list HTML\n    getTrackedImporter()(\"\", { gearList: allData.gearList });\n    projectImported = true;\n  }\n\n  if (!projectImported) {\n    const legacyCollections = collectLegacyProjectCollections(allData);\n    legacyCollections.forEach((collection, index) => {\n      if (collection && typeof collection === \"object\" && !Array.isArray(collection)) {\n        const normalized = isNormalizedProjectEntry(collection)\n          ? collection\n          : normalizeProject(collection);\n        if (normalized && isNormalizedProjectEntry(normalized)) {\n          getTrackedImporter()(\"\", normalized, `Imported project ${index + 1}`);\n          projectImported = true;\n          return;\n        }\n      }\n\n      const imported = importProjectCollection(\n        collection,\n        () => getTrackedImporter(),\n        `Imported project ${index + 1}`,\n      );\n      if (imported) {\n        projectImported = true;\n      }\n    });\n  }\n}\n\nvar STORAGE_API = {\n  getSafeLocalStorage,\n  loadDeviceData,\n  saveDeviceData,\n  loadSetups,\n  saveSetups,\n  saveSetup,\n  loadSetup,\n  deleteSetup,\n  renameSetup,\n  safeSetLocalStorage,\n  readLocalStorageValue,\n  getMountVoltageStorageKeyName,\n  getMountVoltageStorageBackupKeyName,\n  getProjectStorageRevisionKeyName,\n  loadProjectStorageRevision,\n  loadProject,\n  loadProjectMetadata,\n  saveProject,\n  deleteProject,\n  renameProject,\n  createProjectDeletionBackup,\n  loadSessionState,\n  saveSessionState,\n  loadFavorites,\n  saveFavorites,\n  loadContacts,\n  saveContacts,\n  loadOwnGear,\n  saveOwnGear,\n  loadUserProfile,\n  saveUserProfile,\n  loadDocumentationTracker,\n  saveDocumentationTracker,\n  loadAutoGearBackups,\n  saveAutoGearBackups,\n  loadFeedback,\n  saveFeedback,\n  clearAllData,\n  exportAllData,\n  prepareBackupForExport,\n  importAllData,\n  loadAutoGearRules,\n  saveAutoGearRules,\n  loadAutoGearSeedFlag,\n  saveAutoGearSeedFlag,\n  loadAutoGearPresets,\n  saveAutoGearPresets,\n  loadAutoGearMonitorDefaults,\n  saveAutoGearMonitorDefaults,\n  loadAutoGearActivePresetId,\n  saveAutoGearActivePresetId,\n  loadAutoGearAutoPresetId,\n  saveAutoGearAutoPresetId,\n  loadAutoGearBackupVisibility,\n  saveAutoGearBackupVisibility,\n  loadAutoGearBackupRetention,\n  saveAutoGearBackupRetention,\n  getAutoGearBackupRetentionDefault,\n  loadFullBackupHistory,\n  saveFullBackupHistory,\n  recordFullBackupHistoryEntry,\n  requestPersistentStorage,\n  clearUiCacheStorageEntries,\n  ensureCriticalStorageBackups,\n  getLastCriticalStorageGuardResult,\n  decodeStoredValue,\n  getCompressionLogSnapshot,\n  setActiveProjectCompressionHold,\n  clearActiveProjectCompressionHold,\n  invalidateProjectReadCache,\n  storageRepo,\n};\n\nvar TEST_ONLY_AUTO_BACKUP_COMPRESSION_CACHE = {\n  flag: AUTO_BACKUP_PAYLOAD_COMPRESSION_FLAG,\n  read: readAutoBackupCompressionCache,\n  write: writeAutoBackupCompressionCache,\n  clear: resetAutoBackupCompressionCache,\n};\n\ntry {\n  Object.defineProperty(STORAGE_API, '__testAutoBackupCompressionCache', {\n    configurable: false,\n    enumerable: false,\n    writable: false,\n    value: TEST_ONLY_AUTO_BACKUP_COMPRESSION_CACHE,\n  });\n} catch (testHelperDefinitionError) {\n  STORAGE_API.__testAutoBackupCompressionCache = TEST_ONLY_AUTO_BACKUP_COMPRESSION_CACHE;\n  void testHelperDefinitionError;\n}\n\nif (typeof module !== \"undefined\" && module.exports) {\n  module.exports = STORAGE_API;\n}\n\nconsole.log('DEBUG: storage.js: starting global export loop');\nif (GLOBAL_SCOPE && typeof GLOBAL_SCOPE === 'object') {\n\n  Object.keys(STORAGE_API).forEach((key) => {\n    const value = STORAGE_API[key];\n    if (typeof value !== 'function') {\n      return;\n    }\n    if (typeof GLOBAL_SCOPE[key] === 'function') {\n      return;\n    }\n    try {\n      GLOBAL_SCOPE[key] = value;\n    } catch (assignmentError) {\n      void assignmentError;\n      try {\n        Object.defineProperty(GLOBAL_SCOPE, key, {\n          configurable: true,\n          writable: true,\n          value,\n        });\n      } catch (definitionError) {\n        if (typeof console !== 'undefined' && typeof console.warn === 'function') {\n          console.warn(`Unable to expose storage helper ${key} globally.`, definitionError);\n        }\n      }\n    }\n  });\n\n  try {\n    if (typeof GLOBAL_SCOPE.recordFullBackupHistoryEntry !== 'function') {\n      GLOBAL_SCOPE.recordFullBackupHistoryEntry = recordFullBackupHistoryEntry;\n    }\n    if (typeof GLOBAL_SCOPE.loadFullBackupHistory !== 'function') {\n      GLOBAL_SCOPE.loadFullBackupHistory = loadFullBackupHistory;\n    }\n  } catch (ex) {\n    void ex;\n  }\n}\n\nif (GLOBAL_SCOPE) {\n  try {\n    Object.defineProperty(GLOBAL_SCOPE, '__cineStorageApi', {\n      configurable: true,\n      writable: true,\n      value: STORAGE_API,\n    });\n  } catch (storageApiExposeError) {\n    GLOBAL_SCOPE.__cineStorageApi = STORAGE_API;\n    void storageApiExposeError;\n  }\n}\n\nconsole.log('DEBUG: storage.js execution finished');\n// }) ();\n\nexport const cineStorage = STORAGE_API;\nexport default STORAGE_API;\n\n\n\n","/**\n * The persistence module centralises every interaction with the underlying\n * storage helpers. The goal is to make it obvious which execution context is\n * currently responsible for safeguarding the project data. By explaining each\n * discovery step we help future maintainers reason about why data looks for a\n * specific bridge or linker before touching user content.\n */\n\nimport cineModules from './registry.js';\nimport * as cineStorage from '../storage.js';\nimport { detectGlobalScope } from './helpers/scope-utils.js';\n\n/**\n * DEEP DIVE: Persistence Layer vs Storage Layer\n *\n * It is crucial to distinguish `persistence.js` from `storage.js`:\n *\n * 1. storage.js (The \"Driver\"):\n *    - Handles raw I/O (localStorage.getItem, JSON.parse).\n *    - Doesn't know *when* or *why* to save, only *how*.\n *\n * 2. persistence.js (The \"Manager\"):\n *    - Defines the POLICY (Auto-save on change? Throttle saves? Retry on failure?).\n *    - Orchestrates the flow between the application state and the storage driver.\n *    - Handles cross-cutting concerns like migration triggers and error boundaries.\n */\nconst FALLBACK_SCOPE = detectGlobalScope();\n\n/**\n * Locate the module linker that wires the loosely coupled runtime together.\n * We rely on global scope injection for legacy linker support.\n */\nfunction resolveModuleLinker(scope) {\n  const candidates = [scope];\n  if (typeof globalThis !== 'undefined' && candidates.indexOf(globalThis) === -1) candidates.push(globalThis);\n  if (typeof window !== 'undefined' && candidates.indexOf(window) === -1) candidates.push(window);\n  if (typeof self !== 'undefined' && candidates.indexOf(self) === -1) candidates.push(self);\n  if (typeof global !== 'undefined' && candidates.indexOf(global) === -1) candidates.push(global);\n\n  for (let index = 0; index < candidates.length; index += 1) {\n    const candidate = candidates[index];\n    try {\n      const linker = candidate && candidate.cineModuleLinker;\n      if (linker && typeof linker === 'object') {\n        return linker;\n      }\n    } catch (error) {\n      void error;\n    }\n  }\n\n  return null;\n}\n\n/**\n * If the linker cannot provide an environment instance we still want to keep\n * the storage layer operational. The fallback loader walks through familiar\n * scopes and reuses the environment that was already injected there.\n */\nfunction fallbackLoadModuleEnvironment(scope) {\n  const candidates = [scope];\n  if (typeof globalThis !== 'undefined' && candidates.indexOf(globalThis) === -1) candidates.push(globalThis);\n  if (typeof window !== 'undefined' && candidates.indexOf(window) === -1) candidates.push(window);\n  if (typeof self !== 'undefined' && candidates.indexOf(self) === -1) candidates.push(self);\n  if (typeof global !== 'undefined' && candidates.indexOf(global) === -1) candidates.push(global);\n\n  for (let index = 0; index < candidates.length; index += 1) {\n    const candidate = candidates[index];\n    if (candidate && typeof candidate.cineModuleEnvironment === 'object') {\n      return candidate.cineModuleEnvironment;\n    }\n  }\n\n  return null;\n}\n\n/**\n * The environment bridge contains helpers for cross-context communication.\n * When it is not injected by the linker we replicate the same discovery\n * strategy as with the environment itself so offline mode keeps functioning.\n */\nfunction fallbackLoadEnvironmentBridge(scope) {\n  const candidates = [scope];\n  if (typeof globalThis !== 'undefined' && candidates.indexOf(globalThis) === -1) candidates.push(globalThis);\n  if (typeof window !== 'undefined' && candidates.indexOf(window) === -1) candidates.push(window);\n  if (typeof self !== 'undefined' && candidates.indexOf(self) === -1) candidates.push(self);\n  if (typeof global !== 'undefined' && candidates.indexOf(global) === -1) candidates.push(global);\n\n  for (let index = 0; index < candidates.length; index += 1) {\n    const candidate = candidates[index];\n    if (candidate && typeof candidate.cineEnvironmentBridge === 'object') {\n      return candidate.cineEnvironmentBridge;\n    }\n  }\n\n  return null;\n}\n\nconst MODULE_LINKER = resolveModuleLinker(FALLBACK_SCOPE);\n\nconst MODULE_ENV = MODULE_LINKER && typeof MODULE_LINKER.getModuleEnvironment === 'function'\n  ? MODULE_LINKER.getModuleEnvironment()\n  : fallbackLoadModuleEnvironment(FALLBACK_SCOPE);\n\nconst ENV_BRIDGE = MODULE_LINKER && typeof MODULE_LINKER.getEnvironmentBridge === 'function'\n  ? MODULE_LINKER.getEnvironmentBridge()\n  : fallbackLoadEnvironmentBridge(FALLBACK_SCOPE);\n\nconst GLOBAL_SCOPE = (MODULE_LINKER && typeof MODULE_LINKER.getGlobalScope === 'function'\n  ? MODULE_LINKER.getGlobalScope()\n  : null)\n  || (ENV_BRIDGE && typeof ENV_BRIDGE.getGlobalScope === 'function'\n    ? ENV_BRIDGE.getGlobalScope()\n    : null)\n  || (MODULE_ENV && typeof MODULE_ENV.getGlobalScope === 'function'\n    ? MODULE_ENV.getGlobalScope()\n    : null)\n  || FALLBACK_SCOPE;\n\n/**\n * Module globals store shared singletons such as the persistence registry.\n * Accessing them through this helper keeps accidental global mutations away\n * from user projects because we never touch a missing object directly.\n */\nfunction fallbackResolveModuleGlobals() {\n  const candidates = [GLOBAL_SCOPE];\n  if (typeof globalThis !== 'undefined' && candidates.indexOf(globalThis) === -1) candidates.push(globalThis);\n  if (typeof window !== 'undefined' && candidates.indexOf(window) === -1) candidates.push(window);\n  if (typeof self !== 'undefined' && candidates.indexOf(self) === -1) candidates.push(self);\n  if (typeof global !== 'undefined' && candidates.indexOf(global) === -1) candidates.push(global);\n\n  for (let index = 0; index < candidates.length; index += 1) {\n    const candidate = candidates[index];\n    if (candidate && typeof candidate.cineModuleGlobals === 'object') {\n      return candidate.cineModuleGlobals;\n    }\n  }\n\n  return null;\n}\n\nconst MODULE_GLOBALS = (MODULE_LINKER && typeof MODULE_LINKER.getModuleGlobals === 'function'\n  ? MODULE_LINKER.getModuleGlobals()\n  : null)\n  || fallbackResolveModuleGlobals();\n\n/**\n * Let the runtime know which APIs are available so other modules can reuse\n * them without creating duplicate instances. The explicit guard rails ensure\n * the registration is a no-op when the host does not support bookkeeping.\n */\nfunction informModuleGlobals(name, api) {\n  if (MODULE_LINKER && typeof MODULE_LINKER.recordModule === 'function') {\n    MODULE_LINKER.recordModule(name, api);\n  }\n\n  if (!MODULE_GLOBALS || typeof MODULE_GLOBALS.recordModule !== 'function') {\n    return;\n  }\n\n  try {\n    MODULE_GLOBALS.recordModule(name, api);\n  } catch (error) {\n    void error;\n  }\n}\n\nfunction fallbackTryRequire(modulePath) {\n  // ESM cannot support synchronous dynamic require.\n  // This fallback assumes the module is not available if not imported via ESM.\n  return null;\n}\n\nconst tryRequire = (function resolveTryRequire() {\n  if (MODULE_LINKER && typeof MODULE_LINKER.tryRequire === 'function') {\n    return MODULE_LINKER.tryRequire;\n  }\n\n  if (MODULE_GLOBALS && typeof MODULE_GLOBALS.tryRequire === 'function') {\n    return MODULE_GLOBALS.tryRequire;\n  }\n\n  if (ENV_BRIDGE && typeof ENV_BRIDGE.tryRequire === 'function') {\n    return function bridgeTryRequire(modulePath) {\n      const result = ENV_BRIDGE.tryRequire(modulePath);\n      return typeof result === 'undefined' ? fallbackTryRequire(modulePath) : result;\n    };\n  }\n\n  if (MODULE_ENV && typeof MODULE_ENV.tryRequire === 'function') {\n    return MODULE_ENV.tryRequire;\n  }\n\n  return fallbackTryRequire;\n})();\n\nfunction resolveModuleRegistry(scope) {\n  const targetScope = scope || GLOBAL_SCOPE;\n\n  if (MODULE_LINKER && typeof MODULE_LINKER.getModuleRegistry === 'function') {\n    const linked = MODULE_LINKER.getModuleRegistry(targetScope);\n    if (linked) {\n      return linked;\n    }\n  }\n\n  if (MODULE_GLOBALS && typeof MODULE_GLOBALS.resolveModuleRegistry === 'function') {\n    try {\n      const resolved = MODULE_GLOBALS.resolveModuleRegistry(targetScope);\n      if (resolved) {\n        return resolved;\n      }\n    } catch (error) {\n      void error;\n    }\n  }\n\n  if (ENV_BRIDGE && typeof ENV_BRIDGE.getModuleRegistry === 'function') {\n    try {\n      const bridged = ENV_BRIDGE.getModuleRegistry(targetScope);\n      if (bridged) {\n        return bridged;\n      }\n    } catch (error) {\n      void error;\n    }\n  }\n\n  if (MODULE_ENV && typeof MODULE_ENV.resolveModuleRegistry === 'function') {\n    try {\n      const provided = MODULE_ENV.resolveModuleRegistry(targetScope);\n      if (provided) {\n        return provided;\n      }\n    } catch (error) {\n      void error;\n    }\n  }\n\n  // Use imported cineModules if available\n  if (cineModules && typeof cineModules === 'object') {\n    return cineModules;\n  }\n\n\n  const scopes = [targetScope];\n  if (typeof globalThis !== 'undefined' && scopes.indexOf(globalThis) === -1) scopes.push(globalThis);\n  if (typeof window !== 'undefined' && scopes.indexOf(window) === -1) scopes.push(window);\n  if (typeof self !== 'undefined' && scopes.indexOf(self) === -1) scopes.push(self);\n  if (typeof global !== 'undefined' && scopes.indexOf(global) === -1) scopes.push(global);\n\n  for (let index = 0; index < scopes.length; index += 1) {\n    const candidate = scopes[index];\n    if (candidate && typeof candidate.cineModules === 'object') {\n      return candidate.cineModules;\n    }\n  }\n\n  return null;\n}\n\nconst MODULE_REGISTRY = (function () {\n  if (MODULE_LINKER && typeof MODULE_LINKER.getModuleRegistry === 'function') {\n    const linkedRegistry = MODULE_LINKER.getModuleRegistry(GLOBAL_SCOPE);\n    if (linkedRegistry) {\n      return linkedRegistry;\n    }\n  }\n\n  if (MODULE_GLOBALS && typeof MODULE_GLOBALS.getModuleRegistry === 'function') {\n    try {\n      const shared = MODULE_GLOBALS.getModuleRegistry(GLOBAL_SCOPE);\n      if (shared) {\n        return shared;\n      }\n    } catch (error) {\n      void error;\n    }\n  }\n\n  if (ENV_BRIDGE && typeof ENV_BRIDGE.getModuleRegistry === 'function') {\n    try {\n      const bridged = ENV_BRIDGE.getModuleRegistry(GLOBAL_SCOPE);\n      if (bridged) {\n        return bridged;\n      }\n    } catch (error) {\n      void error;\n    }\n  }\n\n  if (MODULE_ENV && typeof MODULE_ENV.getModuleRegistry === 'function') {\n    try {\n      const provided = MODULE_ENV.getModuleRegistry(GLOBAL_SCOPE);\n      if (provided) {\n        return provided;\n      }\n    } catch (error) {\n      void error;\n    }\n  }\n\n  return resolveModuleRegistry(GLOBAL_SCOPE);\n})();\n\nconst PENDING_QUEUE_KEY = (function resolvePendingKey() {\n  if (MODULE_LINKER && typeof MODULE_LINKER.getPendingQueueKey === 'function') {\n    const linkedKey = MODULE_LINKER.getPendingQueueKey();\n    if (typeof linkedKey === 'string' && linkedKey) {\n      return linkedKey;\n    }\n  }\n\n  if (MODULE_GLOBALS && typeof MODULE_GLOBALS.getPendingQueueKey === 'function') {\n    try {\n      const sharedKey = MODULE_GLOBALS.getPendingQueueKey();\n      if (typeof sharedKey === 'string' && sharedKey) {\n        return sharedKey;\n      }\n    } catch (error) {\n      void error;\n    }\n  }\n\n  if (ENV_BRIDGE && typeof ENV_BRIDGE.getPendingQueueKey === 'function') {\n    try {\n      const bridgedKey = ENV_BRIDGE.getPendingQueueKey();\n      if (typeof bridgedKey === 'string' && bridgedKey) {\n        return bridgedKey;\n      }\n    } catch (error) {\n      void error;\n    }\n  }\n\n  if (MODULE_ENV && typeof MODULE_ENV.PENDING_QUEUE_KEY === 'string') {\n    return MODULE_ENV.PENDING_QUEUE_KEY;\n  }\n\n  return '__cinePendingModuleRegistrations__';\n})();\n\nfunction cloneOptions(options) {\n  if (!options || typeof options !== 'object') {\n    return {};\n  }\n\n  const copy = {};\n  const keys = Object.keys(options);\n  for (let index = 0; index < keys.length; index += 1) {\n    const key = keys[index];\n    copy[key] = options[key];\n  }\n\n  return copy;\n}\n\nfunction queueModuleRegistration(name, api, options) {\n  if (MODULE_GLOBALS && typeof MODULE_GLOBALS.queueModuleRegistration === 'function') {\n    try {\n      if (MODULE_GLOBALS.queueModuleRegistration(name, api, options, GLOBAL_SCOPE)) {\n        return true;\n      }\n    } catch (error) {\n      void error;\n    }\n  }\n\n  if (ENV_BRIDGE && typeof ENV_BRIDGE.queueModuleRegistration === 'function') {\n    try {\n      const bridged = ENV_BRIDGE.queueModuleRegistration(name, api, options);\n      if (bridged) {\n        return true;\n      }\n    } catch (error) {\n      void error;\n    }\n  }\n\n  if (MODULE_ENV && typeof MODULE_ENV.queueModuleRegistration === 'function') {\n    return MODULE_ENV.queueModuleRegistration(name, api, options, GLOBAL_SCOPE);\n  }\n\n  if (!GLOBAL_SCOPE || typeof GLOBAL_SCOPE !== 'object') {\n    return false;\n  }\n\n  const payload = Object.freeze({\n    name,\n    api,\n    options: Object.freeze(cloneOptions(options)),\n  });\n\n  let queue = GLOBAL_SCOPE[PENDING_QUEUE_KEY];\n  if (!Array.isArray(queue)) {\n    try {\n      Object.defineProperty(GLOBAL_SCOPE, PENDING_QUEUE_KEY, {\n        configurable: true,\n        enumerable: false,\n        writable: true,\n        value: [],\n      });\n      queue = GLOBAL_SCOPE[PENDING_QUEUE_KEY];\n    } catch (error) {\n      void error;\n      try {\n        if (!Array.isArray(GLOBAL_SCOPE[PENDING_QUEUE_KEY])) {\n          GLOBAL_SCOPE[PENDING_QUEUE_KEY] = [];\n        }\n        queue = GLOBAL_SCOPE[PENDING_QUEUE_KEY];\n      } catch (assignmentError) {\n        void assignmentError;\n        return false;\n      }\n    }\n  }\n\n  try {\n    queue.push(payload);\n  } catch (error) {\n    void error;\n    queue[queue.length] = payload;\n  }\n\n  return true;\n}\n\nfunction fallbackRegisterOrQueue(name, api, options, onError) {\n  if (MODULE_REGISTRY && typeof MODULE_REGISTRY.register === 'function') {\n    try {\n      MODULE_REGISTRY.register(name, api, options);\n      return true;\n    } catch (error) {\n      if (typeof onError === 'function') {\n        try {\n          onError(error);\n        } catch (callbackError) {\n          void callbackError;\n        }\n      } else {\n        void error;\n      }\n    }\n  }\n\n  queueModuleRegistration(name, api, options);\n  return false;\n}\n\nconst registerOrQueueModule = (function resolveRegisterOrQueue() {\n  if (MODULE_GLOBALS && typeof MODULE_GLOBALS.registerOrQueueModule === 'function') {\n    return function registerOrQueueModule(name, api, options, onError) {\n      try {\n        const registered = MODULE_GLOBALS.registerOrQueueModule(\n          name,\n          api,\n          options,\n          onError,\n          GLOBAL_SCOPE,\n          MODULE_REGISTRY,\n        );\n        if (registered) {\n          return true;\n        }\n      } catch (error) {\n        void error;\n      }\n\n      return fallbackRegisterOrQueue(name, api, options, onError);\n    };\n  }\n\n  if (ENV_BRIDGE && typeof ENV_BRIDGE.registerOrQueueModule === 'function') {\n    return function registerOrQueueModule(name, api, options, onError) {\n      try {\n        const bridged = ENV_BRIDGE.registerOrQueueModule(name, api, options, onError, GLOBAL_SCOPE, MODULE_REGISTRY);\n        if (bridged) {\n          return true;\n        }\n      } catch (error) {\n        void error;\n      }\n\n      return fallbackRegisterOrQueue(name, api, options, onError);\n    };\n  }\n\n  if (MODULE_ENV && typeof MODULE_ENV.registerOrQueueModule === 'function') {\n    return function registerOrQueueModule(name, api, options, onError) {\n      return MODULE_ENV.registerOrQueueModule(name, api, options, onError, GLOBAL_SCOPE, MODULE_REGISTRY);\n    };\n  }\n\n  return fallbackRegisterOrQueue;\n})();\n\n\n\nfunction isNodeProcessReference(value) {\n  if (!value) {\n    return false;\n  }\n\n  if (typeof process === 'undefined' || !process) {\n    return false;\n  }\n\n  if (value === process) {\n    return true;\n  }\n\n  if (typeof value === 'object') {\n    try {\n      if (value.constructor && value.constructor.name === 'process') {\n        return true;\n      }\n    } catch (processInspectionError) {\n      void processInspectionError;\n    }\n\n    if (\n      typeof value.pid === 'number' &&\n      typeof value.nextTick === 'function' &&\n      typeof value.emit === 'function' &&\n      typeof value.binding === 'function'\n    ) {\n      return true;\n    }\n  }\n\n  if (typeof value === 'function') {\n    if (\n      value === process.binding ||\n      value === process._linkedBinding ||\n      value === process.dlopen\n    ) {\n      return true;\n    }\n\n    try {\n      const functionName = value.name || '';\n      if (functionName && (functionName === 'binding' || functionName === 'dlopen')) {\n        const source = Function.prototype.toString.call(value);\n        if (source && source.indexOf('[native code]') !== -1) {\n          return true;\n        }\n      }\n    } catch (functionInspectionError) {\n      void functionInspectionError;\n    }\n  }\n\n  return false;\n}\n\nfunction shouldBypassDeepFreeze(value) {\n  if (!value || typeof value === 'function' || (typeof value !== 'object' && typeof value !== 'function')) {\n    return false;\n  }\n\n  if (isNodeProcessReference(value)) {\n    return true;\n  }\n\n  if (\n    typeof process !== 'undefined' &&\n    process &&\n    process.release &&\n    process.release.name === 'node'\n  ) {\n    return true;\n  }\n\n  try {\n    if (typeof value.pipe === 'function' && typeof value.unpipe === 'function') {\n      return true;\n    }\n\n    if (typeof value.on === 'function' && typeof value.emit === 'function') {\n      if (typeof value.write === 'function' || typeof value.read === 'function') {\n        return true;\n      }\n\n      const ctorName = value.constructor && value.constructor.name;\n      if (ctorName && /Stream|Emitter|Port/i.test(ctorName)) {\n        return true;\n      }\n    }\n\n    if (typeof Symbol !== 'undefined' && value[Symbol.toStringTag]) {\n      const tag = value[Symbol.toStringTag];\n      if (typeof tag === 'string' && /Stream|Port/i.test(tag)) {\n        return true;\n      }\n    }\n  } catch (inspectionError) {\n    void inspectionError;\n  }\n\n  return false;\n}\n\nfunction fallbackResolveSeenTracker(seen) {\n  if (seen && typeof seen.has === 'function' && typeof seen.add === 'function') {\n    return seen;\n  }\n\n  if (Array.isArray(seen)) {\n    return {\n      has(value) {\n        return seen.indexOf(value) !== -1;\n      },\n      add(value) {\n        if (seen.indexOf(value) === -1) {\n          seen.push(value);\n        }\n      },\n    };\n  }\n\n  if (typeof WeakSet === 'function') {\n    try {\n      return new WeakSet();\n    } catch (trackerError) {\n      void trackerError;\n    }\n  }\n\n  const tracked = [];\n  return {\n    has(value) {\n      return tracked.indexOf(value) !== -1;\n    },\n    add(value) {\n      if (tracked.indexOf(value) === -1) {\n        tracked.push(value);\n      }\n    },\n  };\n}\n\nfunction fallbackFreezeDeep(value, seen) {\n  if (!value || typeof value === 'function' || (typeof value !== 'object' && typeof value !== 'function')) {\n    return value;\n  }\n\n  if (shouldBypassDeepFreeze(value)) {\n    return value;\n  }\n\n  if (typeof process !== 'undefined' && process && process.env && process.env.JEST_WORKER_ID) {\n    try {\n      if (typeof Object.freeze === 'function') {\n        Object.freeze(value);\n      }\n    } catch (freezeError) {\n      void freezeError;\n    }\n    return value;\n  }\n\n  const tracker = fallbackResolveSeenTracker(seen);\n\n  if (tracker.has(value)) {\n    return value;\n  }\n\n  tracker.add(value);\n\n  const keys = Object.getOwnPropertyNames(value);\n  for (let index = 0; index < keys.length; index += 1) {\n    const key = keys[index];\n    let child;\n    try {\n      child = value[key];\n    } catch (accessError) {\n      void accessError;\n      child = undefined;\n    }\n    if (!child || typeof child === 'function' || (typeof child !== 'object' && typeof child !== 'function')) {\n      continue;\n    }\n    fallbackFreezeDeep(child, tracker);\n  }\n\n  try {\n    return Object.freeze(value);\n  } catch (freezeError) {\n    void freezeError;\n    return value;\n  }\n}\n\nconst freezeDeep = (function resolveFreezeDeep() {\n  if (MODULE_GLOBALS && typeof MODULE_GLOBALS.freezeDeep === 'function') {\n    return MODULE_GLOBALS.freezeDeep;\n  }\n\n  if (ENV_BRIDGE && typeof ENV_BRIDGE.freezeDeep === 'function') {\n    return function bridgeFreezeDeep(value, seen) {\n      try {\n        return ENV_BRIDGE.freezeDeep(value, seen);\n      } catch (error) {\n        void error;\n        return fallbackFreezeDeep(value, seen);\n      }\n    };\n  }\n\n  if (MODULE_ENV && typeof MODULE_ENV.freezeDeep === 'function') {\n    return MODULE_ENV.freezeDeep;\n  }\n\n  return fallbackFreezeDeep;\n})();\n\nfunction fallbackSafeWarn(message, detail) {\n  if (typeof console === 'undefined' || typeof console.warn !== 'function') {\n    return;\n  }\n\n  try {\n    if (typeof detail === 'undefined') {\n      console.warn(message);\n    } else {\n      console.warn(message, detail);\n    }\n  } catch (error) {\n    void error;\n  }\n}\n\nconst safeWarn = (function resolveSafeWarn() {\n  if (MODULE_GLOBALS && typeof MODULE_GLOBALS.safeWarn === 'function') {\n    return MODULE_GLOBALS.safeWarn;\n  }\n\n  if (ENV_BRIDGE && typeof ENV_BRIDGE.safeWarn === 'function') {\n    return function bridgeSafeWarn(message, detail) {\n      try {\n        ENV_BRIDGE.safeWarn(message, detail);\n      } catch (error) {\n        void error;\n        fallbackSafeWarn(message, detail);\n      }\n    };\n  }\n\n  if (MODULE_ENV && typeof MODULE_ENV.safeWarn === 'function') {\n    return MODULE_ENV.safeWarn;\n  }\n\n  return fallbackSafeWarn;\n})();\n\nfunction fallbackExposeGlobal(name, value) {\n  if (!GLOBAL_SCOPE || typeof GLOBAL_SCOPE !== 'object') {\n    return false;\n  }\n  try {\n    Object.defineProperty(GLOBAL_SCOPE, name, {\n      configurable: true,\n      enumerable: false,\n      value,\n      writable: false,\n    });\n    return true;\n  } catch (error) {\n    void error;\n    try {\n      GLOBAL_SCOPE[name] = value;\n      return true;\n    } catch (assignmentError) {\n      void assignmentError;\n      return false;\n    }\n  }\n}\n\nconst exposeGlobal = (function resolveExposeGlobal() {\n  if (MODULE_GLOBALS && typeof MODULE_GLOBALS.exposeGlobal === 'function') {\n    return function moduleGlobalsExpose(name, value, options) {\n      try {\n        return MODULE_GLOBALS.exposeGlobal(name, value, options);\n      } catch (error) {\n        void error;\n        return fallbackExposeGlobal(name, value);\n      }\n    };\n  }\n\n  if (ENV_BRIDGE && typeof ENV_BRIDGE.exposeGlobal === 'function') {\n    return function bridgeExposeGlobal(name, value, options) {\n      try {\n        return ENV_BRIDGE.exposeGlobal(name, value, options);\n      } catch (error) {\n        void error;\n        return fallbackExposeGlobal(name, value);\n      }\n    };\n  }\n\n  if (MODULE_ENV && typeof MODULE_ENV.exposeGlobal === 'function') {\n    return function exposeGlobal(name, value, options) {\n      return MODULE_ENV.exposeGlobal(name, value, GLOBAL_SCOPE, options);\n    };\n  }\n\n  return fallbackExposeGlobal;\n})();\n\nconst providerModules = [];\n\nfunction addProviderModule(reference, label) {\n  if (!reference || typeof reference !== 'object') {\n    return;\n  }\n\n  providerModules.push({\n    ref: reference,\n    name: label || null,\n  });\n}\n\naddProviderModule(GLOBAL_SCOPE, 'global');\n\n// Import and register Storage as a provider\nif (cineStorage && typeof cineStorage === 'object') {\n  addProviderModule(cineStorage, 'storage');\n}\n\n\n// We no longer require these via tryRequire inside ESM\n// Instead, we assume they might be present in GLOBAL_SCOPE if they are legacy scripts.\n// If they are converted to ESM, we should import them.\n// Currently assuming they are either globals or not present.\n// If existing global objects are found, we add them.\n// (e.g. if loader.js loaded them).\n\nif (GLOBAL_SCOPE.cineAppSession) {\n  addProviderModule(GLOBAL_SCOPE.cineAppSession, 'session');\n}\n\nif (GLOBAL_SCOPE.cineAppSetups) {\n  addProviderModule(GLOBAL_SCOPE.cineAppSetups, 'setups');\n}\n\n\nconst bindingState = Object.create(null);\nconst bindingNames = [];\n\nfunction identifyProvider(providerEntry) {\n  if (!providerEntry) {\n    return null;\n  }\n\n  if (providerEntry.name) {\n    return providerEntry.name;\n  }\n\n  const ref = providerEntry.ref;\n  if (!ref || typeof ref !== 'object') {\n    return null;\n  }\n\n  if (ref === GLOBAL_SCOPE) {\n    return 'global';\n  }\n\n  if (typeof ref.constructor === 'function' && ref.constructor.name) {\n    return ref.constructor.name;\n  }\n\n  return null;\n}\n\nfunction ensureBindingEntry(bindingKey, implementationName) {\n  const key = String(bindingKey);\n  let entry = bindingState[key];\n  if (!entry) {\n    entry = {\n      name: key,\n      implementationName: implementationName || key,\n      available: false,\n      providerIndex: -1,\n      providerName: null,\n      lastChecked: null,\n      implementation: null,\n    };\n    bindingState[key] = entry;\n    bindingNames.push(key);\n  } else if (implementationName && entry.implementationName !== implementationName) {\n    entry.implementationName = implementationName;\n  }\n\n  return entry;\n}\n\nfunction resolveBinding(name, options = {}) {\n  const refresh = options && Object.prototype.hasOwnProperty.call(options, 'refresh')\n    ? options.refresh\n    : true;\n\n  const entry = ensureBindingEntry(name);\n  const implementationName = entry.implementationName || String(name);\n  if (!refresh && entry.implementation && typeof entry.implementation === 'function') {\n    return entry;\n  }\n\n  let resolved = null;\n\n  for (let index = 0; index < providerModules.length; index += 1) {\n    const providerEntry = providerModules[index];\n    const provider = providerEntry && providerEntry.ref;\n    if (!provider || typeof provider !== 'object') {\n      continue;\n    }\n\n    const candidate = provider[implementationName];\n    if (typeof candidate === 'function') {\n      resolved = {\n        implementation: candidate,\n        providerIndex: index,\n        providerName: identifyProvider(providerEntry),\n      };\n      break;\n    }\n  }\n\n  entry.available = !!resolved;\n  entry.providerIndex = resolved ? resolved.providerIndex : -1;\n  entry.providerName = resolved ? resolved.providerName : null;\n  entry.lastChecked = Date.now();\n  entry.implementation = resolved ? resolved.implementation : null;\n\n  return entry;\n}\n\nfunction requireBinding(name) {\n  const detail = resolveBinding(name, { refresh: true });\n  if (!detail || typeof detail.implementation !== 'function') {\n    const error = new Error(`cinePersistence could not resolve function \"${name}\".`);\n    error.code = 'CINE_PERSISTENCE_BINDING_MISSING';\n    error.binding = name;\n    error.detail = {\n      name,\n      available: detail ? detail.available : false,\n      providerName: detail ? detail.providerName : null,\n    };\n    throw error;\n  }\n  return detail.implementation;\n}\n\nfunction snapshotBinding(detail) {\n  if (!detail) {\n    return null;\n  }\n\n  return Object.freeze({\n    name: detail.name,\n    available: !!detail.available,\n    providerIndex: typeof detail.providerIndex === 'number' ? detail.providerIndex : -1,\n    providerName: detail.providerName || null,\n    lastChecked: detail.lastChecked || null,\n    implementation: detail.implementationName || detail.name,\n  });\n}\n\nfunction createWrapper(name, alias) {\n  const bindingKey = alias || name;\n  ensureBindingEntry(bindingKey, name);\n  return function persistenceWrapper() {\n    const fn = requireBinding(bindingKey);\n    return fn.apply(this, arguments);\n  };\n}\n\nfunction inspectBinding(name, options = {}) {\n  const normalized = String(name);\n  const refresh = options && Object.prototype.hasOwnProperty.call(options, 'refresh')\n    ? options.refresh\n    : true;\n  const detail = resolveBinding(normalized, { refresh });\n  return snapshotBinding(detail);\n}\n\nfunction inspectAllBindings(options = {}) {\n  const refresh = options && Object.prototype.hasOwnProperty.call(options, 'refresh')\n    ? options.refresh\n    : true;\n\n  if (refresh) {\n    for (let index = 0; index < bindingNames.length; index += 1) {\n      resolveBinding(bindingNames[index], { refresh: true });\n    }\n  }\n\n  const snapshot = {};\n  for (let index = 0; index < bindingNames.length; index += 1) {\n    const name = bindingNames[index];\n    snapshot[name] = snapshotBinding(bindingState[name]);\n  }\n  return freezeDeep(snapshot);\n}\n\nfunction listBindings() {\n  return bindingNames.slice();\n}\n\nconst persistenceAPI = {\n  bindings: {\n    saveSession: createWrapper('saveCurrentSession', 'saveSession'),\n    autoSaveSetup: createWrapper('autoSaveCurrentSetup', 'autoSaveSetup'),\n    saveGearList: createWrapper('saveCurrentGearList', 'saveGearList'),\n    restoreSessionState: createWrapper('restoreSessionState'),\n    collectFullBackupData: createWrapper('collectFullBackupData'),\n    createSettingsBackup: createWrapper('createSettingsBackup'),\n    captureStorageSnapshot: createWrapper('captureStorageSnapshot'),\n    sanitizeBackupPayload: createWrapper('sanitizeBackupPayload'),\n    autoBackup: createWrapper('autoBackup'),\n    formatFullBackupFilename: createWrapper('formatFullBackupFilename'),\n    downloadPayload: createWrapper('downloadBackupPayload', 'downloadPayload'),\n    recordFullBackupHistoryEntry: createWrapper('recordFullBackupHistoryEntry'),\n    encodeSharedSetup: createWrapper('encodeSharedSetup'),\n    decodeSharedSetup: createWrapper('decodeSharedSetup'),\n    applySharedSetup: createWrapper('applySharedSetup'),\n    applySharedSetupFromUrl: createWrapper('applySharedSetupFromUrl'),\n    downloadProject: createWrapper('downloadSharedProject', 'downloadProject'),\n    saveProject: createWrapper('saveProject'),\n    proceed: createWrapper('handleRestoreRehearsalProceed', 'proceed'),\n    abort: createWrapper('handleRestoreRehearsalAbort', 'abort'),\n  },\n  storage: {\n    loadDeviceData: createWrapper('loadDeviceData'),\n    saveDeviceData: createWrapper('saveDeviceData'),\n    loadSetups: createWrapper('loadSetups'),\n    saveSetups: createWrapper('saveSetups'),\n    saveSetup: createWrapper('saveSetup'),\n    loadSetup: createWrapper('loadSetup'),\n    deleteSetup: createWrapper('deleteSetup'),\n    renameSetup: createWrapper('renameSetup'),\n    loadSessionState: createWrapper('loadSessionState'),\n    saveSessionState: createWrapper('saveSessionState'),\n    loadFeedback: createWrapper('loadFeedback'),\n    saveFeedback: createWrapper('saveFeedback'),\n    saveProject: createWrapper('saveProject'),\n    loadProject: createWrapper('loadProject'),\n    deleteProject: createWrapper('deleteProject'),\n    loadFavorites: createWrapper('loadFavorites'),\n    saveFavorites: createWrapper('saveFavorites'),\n    exportAllData: createWrapper('exportAllData'),\n    importAllData: createWrapper('importAllData'),\n    clearAllData: createWrapper('clearAllData'),\n    loadAutoGearRules: createWrapper('loadAutoGearRules'),\n    saveAutoGearRules: createWrapper('saveAutoGearRules'),\n    loadAutoGearBackups: createWrapper('loadAutoGearBackups'),\n    saveAutoGearBackups: createWrapper('saveAutoGearBackups'),\n    loadAutoGearSeedFlag: createWrapper('loadAutoGearSeedFlag'),\n    saveAutoGearSeedFlag: createWrapper('saveAutoGearSeedFlag'),\n    loadAutoGearBackupRetention: createWrapper('loadAutoGearBackupRetention'),\n    saveAutoGearBackupRetention: createWrapper('saveAutoGearBackupRetention'),\n    getAutoGearBackupRetentionDefault: createWrapper('getAutoGearBackupRetentionDefault'),\n    loadAutoGearPresets: createWrapper('loadAutoGearPresets'),\n    saveAutoGearPresets: createWrapper('saveAutoGearPresets'),\n    loadAutoGearActivePresetId: createWrapper('loadAutoGearActivePresetId'),\n    saveAutoGearActivePresetId: createWrapper('saveAutoGearActivePresetId'),\n    loadAutoGearAutoPresetId: createWrapper('loadAutoGearAutoPresetId'),\n    saveAutoGearAutoPresetId: createWrapper('saveAutoGearAutoPresetId'),\n    loadAutoGearMonitorDefaults: createWrapper('loadAutoGearMonitorDefaults'),\n    saveAutoGearMonitorDefaults: createWrapper('saveAutoGearMonitorDefaults'),\n    loadAutoGearBackupVisibility: createWrapper('loadAutoGearBackupVisibility'),\n    saveAutoGearBackupVisibility: createWrapper('saveAutoGearBackupVisibility'),\n    loadFullBackupHistory: createWrapper('loadFullBackupHistory'),\n    saveFullBackupHistory: createWrapper('saveFullBackupHistory'),\n    recordFullBackupHistoryEntry: createWrapper('recordFullBackupHistoryEntry'),\n    requestPersistentStorage: createWrapper('requestPersistentStorage'),\n    clearUiCacheStorageEntries: createWrapper('clearUiCacheStorageEntries'),\n    ensureCriticalStorageBackups: createWrapper('ensureCriticalStorageBackups'),\n    getLastCriticalStorageGuardResult: createWrapper('getLastCriticalStorageGuardResult'),\n    saveSession: createWrapper('saveCurrentSession', 'saveSession'),\n    autoSaveSetup: createWrapper('autoSaveCurrentSetup', 'autoSaveSetup'),\n    proceed: createWrapper('handleRestoreRehearsalProceed', 'proceed'),\n    abort: createWrapper('handleRestoreRehearsalAbort', 'abort'),\n  },\n  autosave: {\n    saveSession: createWrapper('saveCurrentSession', 'saveSession'),\n    autoSaveSetup: createWrapper('autoSaveCurrentSetup', 'autoSaveSetup'),\n    saveGearList: createWrapper('saveCurrentGearList', 'saveGearList'),\n    restoreSessionState: createWrapper('restoreSessionState'),\n  },\n  backups: {\n    collectFullBackupData: createWrapper('collectFullBackupData'),\n    createSettingsBackup: createWrapper('createSettingsBackup'),\n    captureStorageSnapshot: createWrapper('captureStorageSnapshot'),\n    sanitizeBackupPayload: createWrapper('sanitizeBackupPayload'),\n    autoBackup: createWrapper('autoBackup'),\n    formatFullBackupFilename: createWrapper('formatFullBackupFilename'),\n    downloadPayload: createWrapper('downloadBackupPayload', 'downloadPayload'),\n    recordFullBackupHistoryEntry: createWrapper('recordFullBackupHistoryEntry'),\n  },\n  restore: {\n    proceed: createWrapper('handleRestoreRehearsalProceed', 'proceed'),\n    abort: createWrapper('handleRestoreRehearsalAbort', 'abort'),\n  },\n  share: {\n    downloadProject: createWrapper('downloadSharedProject', 'downloadProject'),\n    encodeSharedSetup: createWrapper('encodeSharedSetup'),\n    decodeSharedSetup: createWrapper('decodeSharedSetup'),\n    applySharedSetup: createWrapper('applySharedSetup'),\n    applySharedSetupFromUrl: createWrapper('applySharedSetupFromUrl'),\n  },\n\n  __internal: freezeDeep({\n    listBindings,\n    inspectBinding(name, options) {\n      return inspectBinding(name, options) || null;\n    },\n    inspectAllBindings,\n  }),\n};\n\nfreezeDeep(persistenceAPI);\n\naddProviderModule(persistenceAPI.bindings, 'bindings');\ninformModuleGlobals('cinePersistence', persistenceAPI);\n\nregisterOrQueueModule('cinePersistence', persistenceAPI, {\n  category: 'persistence',\n  description: 'Data integrity facade for storage, autosave, backups, restore, and share flows.',\n  replace: true,\n  connections: ['cineModuleGlobals', 'cineModuleEnvironment', 'cineEnvironmentBridge', 'cineModuleContext'],\n}, (error) => {\n  safeWarn('Unable to register cinePersistence module.', error);\n});\n\nif (GLOBAL_SCOPE && typeof GLOBAL_SCOPE === 'object') {\n  let existingPersistence = null;\n  try {\n    existingPersistence = GLOBAL_SCOPE.cinePersistence || null;\n  } catch (error) {\n    void error;\n    existingPersistence = null;\n  }\n\n  if (existingPersistence !== persistenceAPI) {\n    const exposed = exposeGlobal('cinePersistence', persistenceAPI, {\n      configurable: true,\n      enumerable: false,\n      writable: false,\n    });\n\n    if (!exposed && typeof console !== 'undefined' && typeof console.warn === 'function') {\n      console.warn('Unable to expose cinePersistence globally.');\n    }\n  }\n}\n\nexport const cinePersistence = persistenceAPI;\n"],"file":"core-modules-C8doLRdR.js"}