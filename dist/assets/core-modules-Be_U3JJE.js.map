{"version":3,"mappings":"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B,CACjB,qBACA,mBACA,wBACA,aACA,sBAEF,yBAA0B,CACxB,6BACA,+BACA,sCACA,6BACA,sCAEF,wBAAyB,CACvB,iBACA,wBACA,UACA,YACA,aAEF,yBAA0B,CACxB,iBACA,eACA,uBACA,uBACA,2BAEF,sBAAuB,CACrB,OACA,QACA,QACA,SACA,SAEF,wBAAyB,CACvB,4BACA,sBACA,8BACA,8BACA,+BAEF,4BAA6B,CAC3B,cACA,eACA,cACA,gBACA,OAEF,yBAA0B,CACxB,UACA,OACA,OACA,OACA,SAEF,YAAa,CAAC,SAAU,gBAAiB,SAAU,WAAY,UAAW,WAAY,cAAc,EACpG,KAAM,CAAC,OAAQ,OAAQ,SAAU,SAAU,QAAQ,EACnD,SAAU,CACR,YACA,YACA,uBACA,sBACA,0BAEF,aAAc,CACZ,gBACA,WACA,oBACA,iBACA,qBAEF,WAAY,CACV,cACA,eACA,uBACA,qBACA,0BAEF,mBAAoB,CAClB,sBACA,yBACA,0BACA,wBACA,2BAEF,oBAAqB,CACnB,uBACA,oBACA,8BACA,0BACA,gCAEF,8BAA+B,CAC7B,mCACA,8BACA,yCACA,0CACA,4CAEF,YAAa,CACX,eACA,mBACA,iBACA,sBACA,WAEF,MAAO,CAAC,QAAS,QAAS,QAAS,QAAS,OAAO,EACnD,cAAe,CACb,kBACA,kBACA,kBACA,iBACA,mBAEF,wBAAyB,CACvB,8BACA,4BACA,6BACA,iCACA,+BAEF,mBAAoB,CAClB,uBACA,mBACA,2BACA,yBACA,+BAEF,6BAA8B,CAC5B,mCACA,6BACA,sCACA,yCACA,2CAEF,WAAY,CACV,cACA,cACA,eACA,iBACA,oBAEF,qBAAsB,CACpB,0BACA,wBACA,0BACA,iCACA,gCAEF,sBAAuB,CACrB,2BACA,6BACA,4BACA,sCACA,uBAEF,OAAQ,CAAC,SAAU,YAAa,WAAY,UAAW,WAAW,EAClE,kBAAmB,CACjB,qBACA,gBACA,mBACA,wBACA,qBAEF,aAAc,CACZ,gBACA,mBACA,iBACA,uBACA,mBAEF,oBAAqB,CACnB,uBACA,sBACA,mBACA,qBACA,mBAEF,0BAA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","names":["globalScope","VALID_ICON_FONTS","keys","fonts","font","toCodePointChar","value","radix","codePoint","normalizeGlyphChar","char","trimmed","unicodeMatch","decoded","unicodeBraceMatch","hexEntityMatch","decimalEntityMatch","iconGlyph","defaultFont","requestedFont","normalizedFont","glyph","resolveIconGlyph","size","fontKey","className","ensureSvgHasAriaHidden","markup","applyIconGlyph","element","resolved","cls","iconMarkup","parts","finalClass","svg","fontAttr","formatSvgCoordinate","rounded","positionSvgMarkup","centerX","centerY","half","x","y","width","height","match","attrs","attrText","additions","STAR_ICON_SVG","ICON_GLYPHS","detectGlobalScope","isObjectLike","freezeArray","array","cloneArray","clone","index","createPrimaryCache","getPrimaryCacheEntry","cache","primary","entry","key","pushUnique","target","BASE_SCOPES","scopes","EMPTY_EXTRAS","SUPPORTS_WEAKMAP","DETECT_CACHE","sanitizeExtras","extras","sanitized","computeCandidateScopes","detectFn","extrasList","detected","getExtrasCache","detectEntry","extrasEntry","getDetectEntry","collectInternal","cacheEntry","primaryEntry","computed","computedFallback","createCollector","options","collectCandidateScopes","getBaseScopes","GLOBAL_SCOPE","DEFAULT_PENDING_QUEUE_KEY","fallbackDetectGlobalScope","installSafeConsoleGuards","scope","targetScope","consoleRef","methods","originals","method","candidate","guarded","createScopeCollector","DEFAULT_EXTRAS_KEY","HELPER_COLLECTOR_CACHE","BASE_SCOPE_EXTRAS_CACHE","resolveExtrasForBaseScope","baseScope","resolveHelperCollector","extrasKey","collector","fallbackCollectCandidateScopes","resolvedBaseScope","pushScope","fallbackTryRequire","modulePath","fallbackDefineHiddenProperty","name","fallbackEnsureQueue","queueKey","queue","BUILTIN_IMMUTABILITY","registryKey","isEthereumProviderCandidate","PRIMARY_SCOPE","inspectionError","ctorName","isNodeProcessReference","functionName","source","shouldBypassDeepFreeze","tag","fallbackResolveSeenTracker","seen","tracked","fallbackFreezeDeep","tracker","descriptor","child","fallbackSafeWarn","message","detail","fallbackResolveModuleRegistry","fallbackQueueModuleRegistration","api","payload","createFallbackKernel","primaryScope","resolveArchitectureKernel","LOCAL_SCOPE","RESOLVED_KERNEL","ACTIVE_KERNEL","scoped","PENDING_QUEUE_KEY","collected","baseTryRequire","result","baseResolveModuleRegistry","required","cachedModuleRegistry","hasResolvedRegistry","getModuleRegistry","ensureQueue","queueModuleRegistration","baseRegisterOrQueueModule","registry","onError","error","baseFreezeDeep","baseSafeWarn","exposeGlobal","baseApi","moduleRegistry","ensureConsoleMethodsWritable","QUEUE_FLUSH_TIMER_KEY","moduleMap","metadataMap","registryReference","resolveImmutability","createFallbackImmutability","shouldBypass","freeze","FALLBACK_IMMUTABILITY","activeImmutability","getImmutability","freezeDeep","provider","normalizeName","normalizeConnections","entries","normalized","raw","register","moduleApi","normalizedName","existing","get","has","list","describe","meta","normalizeNameCollection","normalizeCategoryCollection","describeAll","normalizedNames","normalizedCategories","namesFilter","categoryFilter","snapshot","sourceNames","left","right","assertRegistered","names","missing","present","resetForTests","getTimerDescriptor","assignHidden","cancelPendingFlush","clearTimer","schedulePendingFlush","scheduleFromScope","clearFromScope","timerId","flushPendingRegistrations","pending","collectQueueScopes","preferredScope","readQueueFromScope","ensureQueueOnScope","resolveQueueDescriptor","queueRegistrationPayload","record","queueScope","createBlueprint","normalizedCategory","normalizedDescription","freezeByDefault","normalizedConnections","factory","staticApi","metadata","cachedApi","instantiated","instantiateError","buildRegistrationOptions","overrides","base","instantiate","context","produced","invocationContext","frozenContext","registerBlueprint","resolvedRegistry","registrationOptions","deferOnError","targetRegistry","blueprint","baseDetectGlobalScope","FALLBACK_SCOPE","safeAssign","detect","append","tryRequire","resolveFromScopes","propertyName","settings","predicate","candidates","getCachedGlobalValue","VIDEO_OUTPUT_TYPES","NORMALIZED_FLAG_KEY","memoizeNormalization","fn","str","VIDEO_TYPE_PATTERNS","normalizeVideoType","_","needles","n","FIZ_CONNECTOR_MAP","createMapNormalizer","map","normalizeFizConnectorType","VIEWFINDER_TYPE_MAP","normalizeViewfinderType","POWER_PORT_TYPE_MAP","mapPowerPortOne","normalizePowerPortType","type","toArray","val","piece","ensureList","defaults","item","fixPowerInput","dev","input","normalizeEntry","it","pType","tType","rest","typeField","applyFixPowerInput","collection","hasNormalizedDevicesMarker","bundle","markDevicesNormalized","unifyDevices","devicesData","cam","m","mount","notes","vo","count","norm","parsedCount","num","fc","vf","lm","idx","arr","o","lens","normalizeMountEntry","status","existingMountOptions","normalizedOptions","pushNormalizedEntry","mountType","dedupedOptions","opt","mountState","safeMountOptions","mountOptions","primaryType","fizGroups","c","p","normalizeDevicesForPersistence","loggingResolveStructuredClone","loggingJsonDeepClone","LOGGING_DEEP_CLONE","structuredCloneImpl","fallbackLoadModuleEnvironment","fallbackLoadEnvironmentBridge","fallbackResolveModuleGlobals","MODULE_ENV","ENV_BRIDGE","MODULE_GLOBALS","structuredCloneCandidates","addCandidate","cachedStructuredCloneCandidate","tryStructuredCloneValue","cloned","resolveModuleRegistry","bridged","cineModules","MODULE_REGISTRY","shared","provided","registerOrQueueModule","registered","ctor","visited","define_process_env_default","freezeError","safeWarn","CONSOLE_METHODS","CONSOLE_PROXY_FLAG","ORIGINAL_CONSOLE_FUNCTIONS","store","consoleProxyInstalled","consoleProxyInstallationAttempted","consoleProxyInstallationFailed","lastConsoleCaptureState","consoleProxyWarningIssued","consoleProxyGuardDepth","informModuleGlobals","LOG_LEVEL_MAP","LOG_LEVELS","LEVEL_COUNTER_KEYS","createLevelCounters","counters","resetLevelCounters","resolveLevelKey","level","getCounterValue","applyLevelCounterDelta","delta","next","applyLevelCounterDeltaForEntries","summariseEntriesByLevel","summary","accumulateLevelSummary","increment","current","cloneLevelSummary","freezeLevelSummary","HISTORY_MIN_LIMIT","HISTORY_ABSOLUTE_MIN_LIMIT","HISTORY_MAX_LIMIT","HISTORY_STORAGE_KEY","CONFIG_STORAGE_KEY","ERROR_EVENT_FLAG","DEFAULT_CONFIG_VALUES","DEFAULT_CONFIG","SERVICE_WORKER_LOG_CHANNEL","SERVICE_WORKER_LOG_ENTRY_TYPE","SERVICE_WORKER_LOG_STATE_REQUEST","SERVICE_WORKER_LOG_STATE_RESPONSE","SERVICE_WORKER_LOG_REQUEST_TIMEOUT","SERVICE_WORKER_LOG_POLL_INTERVAL","SERVICE_WORKER_LOG_HISTORY_LIMIT","cloneDefaultConfig","activeConfig","logHistory","logSubscribers","configSubscribers","attachedErrorTargets","runtimeEntryCount","emittedLevelCounters","retainedLevelCounters","droppedLevelCounters","totalEntriesDropped","lastHistoryDrop","serviceWorkerBridgeState","normalizeLevel","fallbackLevel","fallback","getLevelPriority","booleanFromValue","clampHistoryLimit","effectiveMinimum","absolute","parsed","coerceMessage","sanitizeForLog","depth","nextDepth","valueType","errorOutput","collectedErrors","truncatedErrors","appendErrorDetail","rawErrors","iterator","symbolIterator","maxPreview","length","preview","previewLength","mapCtor","mapValue","mapKey","setCtor","items","urlParamsCtor","params","truncated","pair","len","output","maxKeys","symbols","symbolLength","symbolKey","symbolName","structuredCloneResult","normaliseStackTrace","stackValue","maxLength","charTruncated","limitedStack","rawLines","frameLimit","frames","frameTruncated","line","normaliseOriginSnapshot","origin","stackSummary","frame","getSessionStorage","storage","clearStoredHistory","persistConfigSafe","persistHistorySafe","getEffectiveHistoryLimit","recordHistoryDrop","removedEntries","limit","removedSummary","oldestEntry","newestEntry","dropTimestamp","dropIsoTimestamp","enforceHistoryLimit","overflow","shouldRecord","shouldOutputToConsole","getLevelState","normalizedLevel","consoleEnabled","historyEnabled","isLevelEnabled","state","checkConsole","checkHistory","createEntryId","timestamp","pushEntryToHistory","appendEntry","notifyLogSubscribers","listeners","listener","getHistorySnapshot","effectiveLimit","start","slice","notifyConfigSubscribers","arrayFromArrayLike","safeArrayPush","getConsoleLevelForMethod","getStoredConsoleFunction","stored","invokeConsoleMethod","args","receiver","finalArgs","recordConsoleMessage","rawArgs","messageParts","sanitizedArguments","detailPayload","errorEntries","sanitizedArray","rawValue","sanitizedValue","isErrorInstance","hasSanitizedErrorShape","valueClone","coercedMessage","rawType","contextMeta","metaKeys","errorIndices","errorEntry","primaryError","forceStackCapture","contextOptions","logInternal","installConsoleProxies","installedAny","proxy","argsArray","firstArg","recordError","removeConsoleProxies","restoredAny","original","syncConsoleCaptureState","buildConsoleCaptureDetail","isConsoleCaptureActive","overrideKeys","enableConsoleCapture","setConfig","disableConsoleCapture","shouldCaptureOrigin","override","captureLogOrigin","stackSource","detailStack","stackMessage","captureError","isoTimestamp","captureContext","namespace","sanitizedDetail","internalOptions","methodName","prefixParts","consoleArgs","debug","info","warn","getConfigSnapshot","getHistory","cloneLastDropSnapshot","getStats","clearHistory","subscribe","subscribeConfig","mergeMeta","baseMeta","merged","baseKeys","createLogger","normalizedNamespace","logWithNamespace","mergedMeta","optionOverrides","markEventHandled","event","flag","handleGlobalError","handleUnhandledRejection","markTargetAttached","attachGlobalErrorListeners","applyConfig","changed","captureChanged","limitChanged","consoleCaptureChanged","nextPersistSession","nextLevel","nextHistoryLevel","nextLimit","nextConsole","nextCapture","nextConsoleCapture","nextStackTraces","previousCapture","previousConsoleCapture","resolveConfigPresetFromScopes","scopeIndex","keyIndex","applyConfigFromStorage","applyConfigFromQuery","search","updates","hasUpdates","assignUpdate","part","eqIndex","normaliseStoredEntry","normalizedMessage","normalizedId","getGlobalNavigator","getNavigatorServiceWorker","nav","markServiceWorkerEntrySeen","id","mergeServiceWorkerEntryMeta","snapshotMeta","channel","importServiceWorkerLogEntries","rawEntry","entryId","finalizeServiceWorkerLogRequest","requestId","scheduleServiceWorkerLogPoll","requestServiceWorkerLogSnapshot","ensureServiceWorkerBroadcastChannel","handleServiceWorkerLogMessage","data","reason","serviceWorker","closeMessageChannel","readyPromise","registration","worker","controller","targetWorker","settled","finalize","finalizeWithPoll","handleResponse","handleChannelError","postWithoutChannel","setupServiceWorkerLogBridge","loadPersistedHistory","initialiseConfig","preset","loggingAPI","baseConsole","consoleDescriptor","requestedMethods","unique","i","methodNames","property","resolveModuleBase","MODULE_BASE","push","resolveLoggingFromScope","logging","resolveLogging","cloneMeta","resolveConsoleMethod","fallbackWarningIssued","createConsoleFallbackLogger","consoleMethod","resolveLogger","logger","resolverApi","queueError","CONTACTS_STORAGE_KEY","resolveLocalStorage","generateContactId","sanitizeContactValue","primitive","stringified","normalizeContactEntry","role","phone","email","website","avatar","createdAt","updatedAt","sortContacts","a","b","nameA","nameB","loadStoredContacts","storageKey","saveContactsToStorage","contacts","exposedViaModuleBase","StorageInterface","LocalStorageAdapter","e","UserContext","uuid","deviceId","userContext","SYNC_METADATA_VERSION","SyncStatus","LockStatus","nowISO","generateDocId","prefix","random","createSyncMetadata","identity","now","updateSyncMetadata","existingMeta","markAsSynced","serverTimestamp","markAsConflict","errorMessage","wrapWithMetadata","unwrapMetadata","wrapped","hasMetadata","LOCK_CHANNEL_NAME","HEARTBEAT_INTERVAL_MS","LOCK_TIMEOUT_MS","LOCK_STORAGE_PREFIX","LockEvent","ProjectLockService","err","projectId","existingLock","lock","callback","intervalId","oldLock","projectLockService","PROJECT_KEY_PREFIX","StorageRepository","newDriver","scopedKey","deletionPromises","k","allKeys","projectKey","projectData","lockInfo","__vitePreload","dataVault","DataVault$1","projects","projectIndexKeys","prefixedKeys","rawKey","migrated","prefixedKey","migrationError","storageRepo","IndexedDBAdapter","compressed","decompressed","LZString","set","del","clear","MIGRATION_FLAG_KEY","StorageMigrationService","keysToMigrate","UserContext$1","importError","itemError","setSafely","adapter","migrationService","OWN_GEAR_KEY","GearRepository","query","q","gearRepo","DataVault","filename","safeFilename","writable","files","handle","text","file","projectMemoryCache","isProjectCacheHydrated","hydrateProjectCache","projectKeys","monolithKey","monolithValue","shardKeys","rawIndex","PROJECT_INDEX_KEY","normalizedIndex","normalizeProjectIndexForCache","projectIndexCache","AUTO_GEAR_MONITOR_DEFAULTS_STORAGE_KEY","autoGearMonitorDefaultsCache","AUTO_GEAR_ACTIVE_PRESET_STORAGE_KEY","autoGearActivePresetIdCache","AUTO_GEAR_AUTO_PRESET_STORAGE_KEY","autoGearAutoPresetIdCache","AUTO_GEAR_BACKUPS_STORAGE_KEY","autoGearBackupsCache","AUTO_GEAR_BACKUP_RETENTION_STORAGE_KEY","autoGearBackupRetentionCache","AUTO_GEAR_BACKUP_VISIBILITY_STORAGE_KEY","autoGearBackupVisibilityCache","CUSTOM_FONT_STORAGE_KEY_DEFAULT","customFontsCache","CUSTOM_LOGO_STORAGE_KEY","customLogoCache","CAMERA_COLOR_STORAGE_KEY","cameraColorsCache","PRINT_PREFERENCES_STORAGE_KEY","printPreferencesCache","contactsCache","OWN_GEAR_STORAGE_KEY","ownGearCache","USER_PROFILE_STORAGE_KEY","userProfileCache","FAVORITES_STORAGE_KEY","favoritesCache","TEMPERATURE_UNIT_STORAGE_KEY_NAME","temperatureUnitCache","FOCUS_SCALE_STORAGE_KEY_NAME","focusScaleCache","getMountVoltageStorageKeyName","mountVoltagesCache","FULL_BACKUP_HISTORY_STORAGE_KEY","fullBackupHistoryCache","monoErr","shardPromises","shardErr","FORCE_STORAGE_REINITIALIZE","FACTORY_RESET_LOCK_KEY","LIFECYCLE_CHANNEL_NAME","lifecycleChannel","isJestWorker","lockError","lockValue","invalidateProjectReadCache","scopeList","justReset","s","shouldHydrateProjectCache","isNative","prefixMigrationOutcome","migrateProjectKeyPrefixOnStartup","updateProjectIndex","getSafeLocalStorage","indexRefreshError","closeStorageLifecycle","storageManualDeepClone","references","referenceStore","clonedDate","timeValue","storageJsonDeepClone","storageResolveStructuredClone","storageCreateResilientDeepClone","STORAGE_DEEP_CLONE","knownSessionStorages","registerKnownSessionStorage","resolveSessionStorageFromScope","resolveLocalStorageFromScope","collectLocalStorageCandidates","isFactoryResetActive","readFlag","fallbackScopes","DEVICE_STORAGE_KEY","DEVICE_STORAGE_KEY_VARIANTS","SETUP_STORAGE_KEY","SESSION_STATE_KEY","FEEDBACK_STORAGE_KEY","PROJECT_STORAGE_KEY","PROJECT_STORAGE_REV_KEY","DOCUMENTATION_TRACKER_STORAGE_KEY","DEVICE_SCHEMA_CACHE_KEY","LEGACY_SCHEMA_CACHE_KEY","MOUNT_VOLTAGE_STORAGE_KEY_FALLBACK","MOUNT_VOLTAGE_STORAGE_KEY_SYMBOL","PROJECT_STORAGE_READ_CACHE","STORAGE_CACHE_SYMBOL","PROJECT_SHARD_PREFIX","STORAGE_STATE_CACHE_WEAKMAP","CONTACTS_MODULE_API","CONTACTS_MODULE_RESOLUTION_ATTEMPTED","COMPRESSION_STRATEGY_CACHE","COMPRESSION_STRATEGY_CACHE_KEYS","COMPRESSION_STRATEGY_CACHE_LIMIT","COMPRESSION_CANDIDATE_CACHE_MISS","STORAGE_COMPRESSION_CANDIDATE_CACHE","createCompressionCandidateCache","MIGRATION_BACKUP_COMPRESSION_CANDIDATE_CACHE","AUTO_BACKUP_COMPRESSION_CACHE","AUTO_BACKUP_COMPRESSION_CACHE_KEYS","AUTO_BACKUP_COMPRESSION_CACHE_LIMIT","cloneAutoBackupCompressionValue","readAutoBackupCompressionCache","signature","cached","writeAutoBackupCompressionCache","compression","isCompressedAutoBackupSnapshotPayload","existingIndex","oldest","resetAutoBackupCompressionCache","COMPRESSION_WARNING_LIMIT","COMPRESSION_WARNING_BATCH_SIZE","COMPRESSION_LOG_SUMMARY_WINDOW_MS","compressionWarningRegistry","storageLoggingResolverCache","storageLoggerCache","storageLoggerResolutionAttempted","consoleHelpersImport","consoleHelpersImport.ensureConsoleMethodsWritable","ACTIVE_PROJECT_COMPRESSION_HOLD_KEY","ACTIVE_PROJECT_COMPRESSION_HOLD_ENABLED","collectStorageLoggingScopes","enqueue","resolveStorageLoggingResolver","loggingResolverImport","resolver","resolveStorageLogger","sanitizeStorageError","getActiveStorageType","safeLocalStorageInfo","logStorageEvent","consoleCallback","handled","resolvedMeta","metaIndex","metaKey","getCompressionLogTimestamp","logCompressionSavingsEvent","kind","identifier","savings","percent","entryKey","keyLabel","consoleLogger","shouldSummarize","getCompressionLogSnapshot","getCompressionStrategyCacheKey","variants","segments","variant","compressName","decompressName","readCompressionStrategyCache","cacheKey","lzReference","pruneCompressionStrategyCache","oldestKey","writeCompressionStrategyCache","strategies","computeStorageCompressionWrapperBaseLength","skeleton","STORAGE_COMPRESSION_FLAG_KEY","STORAGE_COMPRESSION_VERSION","STORAGE_COMPRESSION_ALGORITHM","STORAGE_COMPRESSION_NAMESPACE","serialized","emptyLiteralLength","numericLimit","cloneCompressionCandidate","touchCompressionCandidateCacheKey","readCompressionCandidateCacheEntry","writeCompressionCandidateCacheEntry","getStorageStateCacheMap","createIfMissing","assigned","getCachedStorageEntry","clearCachedStorageEntry","cloneValueForCache","cloneCachedEntryValue","cloneLookupMap","copy","cloneProjectLookupSnapshotForReturn","lookup","captureProjectLookupSnapshotForCache","freezeProjectSnapshotProjects","isPlainObject","frozen","setProjectReadCacheSnapshot","getProjectReadCacheClone","safeStorage","currentRaw","forMutation","normalizeProjectStorageRevisionValue","getProjectStorageRevisionKeyName","loadProjectStorageRevision","storageOverride","loadJSONFromStorage","bumpProjectStorageRevision","saveJSONToStorage","cacheStorageValue","normalizedValue","cachedValue","tryGetCachedStorageValue","primaryRaw","rawStored","readGlobalStringValue","directValue","symbolValue","exposeGlobalStringValue","symbolAssigned","resolveMountVoltageStorageKeyName","exposed","MOUNT_VOLTAGE_STORAGE_KEY_NAME","refreshMountVoltageStorageKeyName","RAW_STORAGE_BACKUP_KEYS","getStorageKeyVariants","getMountVoltageStorageBackupKeyName","ensureCustomFontStorageKeyName","existingName","getCustomFontStorageKeyName","TEMPERATURE_UNIT_STORAGE_KEY_DEFAULT","FOCUS_SCALE_STORAGE_KEY_DEFAULT","resolveTemperatureUnitStorageKey","assignError","defineError","AUTO_GEAR_RULES_STORAGE_KEY","AUTO_GEAR_SEEDED_STORAGE_KEY","AUTO_GEAR_PRESETS_STORAGE_KEY","STORAGE_AUTO_BACKUP_NAME_PREFIX","STORAGE_AUTO_BACKUP_DELETION_PREFIX","STORAGE_AUTO_BACKUP_RENAMED_FLAG","AUTO_BACKUP_METADATA_PROPERTY","AUTO_BACKUP_SNAPSHOT_PROPERTY","AUTO_BACKUP_SNAPSHOT_VERSION","AUTO_BACKUP_PAYLOAD_COMPRESSION_FLAG","AUTO_BACKUP_CYCLE_PLACEHOLDER","projectActivityTimestamps","forcedCompressedProjectKeys","AUTO_BACKUP_PAYLOAD_COMPRESSION_MIN_LENGTH","isAutoBackupStorageKey","MAX_AUTO_BACKUPS","MAX_DELETION_BACKUPS","AUTO_GEAR_BACKUP_RETENTION_DEFAULT_VALUE","AUTO_GEAR_BACKUP_RETENTION_MIN","AUTO_GEAR_BACKUP_RETENTION_MAX","ensureGlobalAutoGearBackupDefaults","cloneAutoBackupMetadata","cloneAutoBackupValue","defineAutoBackupMetadata","clonedMetadata","getAutoBackupMetadata","copyAutoBackupMetadata","opts","cloneState","handleCircularClone","compute","cloneAutoBackupValueWithLegacyNormalization","normalizeLegacyLongGopStructure","prepareAutoBackupSnapshotPayloadForStorage","contextName","shouldReport","computedSignature","createStableValueSignature","signatureError","existingSignature","reusedPayload","reusedCompression","decodedExisting","decodeCompressedJsonStorageValue","resolvedSignature","createCompressedJsonStorageCandidate","compressedPayload","compressionInfo","label","restoreAutoBackupSnapshotPayload","rawPayload","details","deriveAutoBackupCreatedAt","fallbackDate","parseAutoBackupKey","sourceDate","detectCyclicAutoBackupReference","path","maxSteps","steps","currentName","currentMetadata","baseName","baseEntry","promoteAutoBackupMetadataToFull","expandAutoBackupEntries","container","isAutoBackupKey","filter","shouldIncludeEntry","include","resolve","stack","restored","restoreCompressedProjectEntry","clonedValue","fallbackPayload","payloadKeys","payloadSignature","payloadInfo","cycleSignatureError","cyclePayloadError","snapshotType","baseValue","payloadError","changedKeys","removedKeys","expanded","payloadSignatureError","computeAutoBackupDiff","currentValue","currentKeys","hasCurrent","hasBase","currentEntry","currentSignature","baseSignature","serializeAutoBackupEntries","entryNames","latestAutoBackupNames","groups","parsedKey","groupKey","disableCompressionForName","prepared","normalizedBase","diff","SETUP_STORAGE_KEY_VARIANTS","getDeviceStorageKeyVariants","isDeviceStorageKeyVariant","shouldAllowCriticalSweepPrimaryInspection","inspectSetupStorageForQuotaRecovery","skipKeysSet","skipSet","STORAGE_BACKUP_SUFFIX","MAX_SAVE_ATTEMPTS","MAX_QUOTA_RECOVERY_STEPS","STORAGE_MIGRATION_BACKUP_SUFFIX","CRITICAL_BACKUP_KEY_PROVIDERS","readAllProjectsFromStorage","createCriticalStorageEntry","backupKey","resolvedBackupKey","gatherCriticalStorageEntries","pushEntry","expectedBaseBackupKey","variantKey","variantEntry","storageId","providerError","providerDetail","lastCriticalStorageGuardResult","registerCriticalStorageGuardResult","ensureCriticalStorageBackups","guardError","guardDetail","targetStorage","primaryValue","readError","primaryReadDetail","backupValue","backupReadError","backupReadDetail","stringPrimaryValue","tryStoreBackup","mirrorDetail","shouldAttemptCompression","candidateValue","writeResult","isQuotaExceededError","compressedCandidate","skipKeys","shouldInspectPrimaryDuringSweep","sweepResult","attemptStorageCompressionSweep","alertStorageError","ensuredDetail","mirroredDetails","errorDetail","getLastCriticalStorageGuardResult","MAX_MIGRATION_BACKUP_CLEANUP_STEPS","MIGRATION_BACKUP_COMPRESSION_ALGORITHM","MIGRATION_BACKUP_COMPRESSION_ENCODING","MIGRATION_BACKUP_COMPRESSION_VARIANTS","LEGACY_STORAGE_COMPRESSION_ALGORITHM","STORAGE_COMPRESSION_VARIANTS","STORAGE_COMPRESSION_ALGORITHM_LITERAL","STORAGE_COMPRESSION_NAMESPACE_LITERAL","STORAGE_COMPRESSION_WRAPPER_BASE_LENGTH","storageCompressionPatchedStorages","STORAGE_COMPRESSION_SWEEP_LIMIT","STORAGE_COMPRESSION_SWEEP_MIN_SAVINGS","STORAGE_RAW_GET_ITEM_PROPERTY","STORAGE_PROACTIVE_COMPRESSION_MIN_LENGTH","STORAGE_PROACTIVE_COMPRESSION_MIN_SAVINGS","STORAGE_PROACTIVE_COMPRESSION_MIN_RATIO","getAvailableLZStringCompressionStrategies","cachedStrategies","available","compressFn","decompressFn","variantLiteral","variantLiteralLength","tryDecompressWithStrategies","preferredVariant","contextLabel","attempts","preferred","j","lastError","strategy","canUseMigrationBackupCompression","tryCreateCompressedMigrationBackupCandidate","serializedPayload","bestCandidate","compressionError","serializedCompressedPayload","serializationError","parseMigrationBackupMetadata","MIGRATION_BACKUP_LEGACY_CREATED_AT_KEYS","canUseJsonValueCompression","baseWrapperLength","best","bestSerialized","bestCompressedLiteral","bestVariantLiteral","originalLengthDigits","compressedLiteral","compressedLiteralError","candidateSerialized","candidateLength","compressedLengthDigits","legacyWrapper","finalVariantLiteral","serializedWrapper","parseError","markProjectActivity","recordTime","normalizeProjectStorageKey","markProjectCollectionActivity","removeProjectActivity","normalizeForcedProjectCompressionKey","isForcedProjectCompressionLocked","ensureProjectEntryUncompressed","ensureProjectEntriesUncompressed","registerActiveSetupStorageSkipKeys","keysToSkip","registerProtectedCompressionSkipKeys","keysToProtect","variantIndex","maybeDecompressStoredString","isSessionStorageInstance","minSavings","minSavingsThreshold","total","upperLimit","compressedCount","freedCharacters","decodeStoredValue","patchIndividualStorageGetItem","originalGetItem","rawGetItem","patchedGetItem","suppressDefineWarning","suppressAssignWarning","patchStorageGetItemForCompression","prototype","patchError","getRawStorageGetter","direct","readRawStorageValue","rawGetterOverride","getter","collectMigrationBackupEntriesForCleanup","excludeKey","snapshotStorageEntries","pruneMigrationBackupEntriesForCleanup","attemptMigrationBackupQuotaRecovery","tryWrite","removedBackups","attemptWrite","clearUiCacheStorageEntries","cleared","clearError","retryAfterClear","attempt","removed","retry","ensurePreWriteMigrationBackup","parsedValue","normalizedRawValue","createStorageMigrationBackup","MIGRATION_BACKUP_LEGACY_DATA_KEYS","trySerializeMigrationBackupValue","normalizeLegacyMigrationBackupCreatedAt","fallbackIso","numeric","iso","time","normalizeLegacyMigrationBackupValue","listChanged","normalizedList","hasData","itemCreatedAt","normalizedDate","dateChanged","usedKey","rawCreatedAt","createdAtSourceKey","createdAtChanged","upgradeLegacyMigrationBackupEntry","originalValue","hasExistingBackup","fallbackCreatedAt","existingRaw","existingData","jsonError","newEntry","MAX_BACKUP_HISTORY","tryStoreList","candidateList","recovery","appendError","tryStoreSerialized","logCompression","storedLength","rawSavings","standardCandidate","standardResult","handleFailure","runRecoveryWith","fallbackError","errorToReport","compressedResult","PRIMARY_STORAGE_KEYS","SIMPLE_STORAGE_KEYS","STORAGE_ALERT_FLAG_NAME","SESSION_FALLBACK_ALERT_FLAG_NAME","storageErrorAlertShown","sessionFallbackAlertShown","DEVICE_COLLECTION_KEYS","FIZ_COLLECTION_KEYS","ACCESSORY_COLLECTION_KEYS","getStorageManager","STORAGE_TEST_KEY","QUOTA_ERROR_NAMES","QUOTA_ERROR_CODES","QUOTA_ERROR_NUMBERS","hasStoredEntries","lengthError","candidateKey","iterationError","verifyStorage","cleanupError","createMemoryStorage","memoryStore","initializeSafeLocalStorage","localCandidates","lastFailedUpgradeCandidate","alertSessionFallback","migrateSnapshotToStorage","migratedKeys","failedKeys","existingRead","writeError","clearMigratedKeys","keysToRemove","rollbackMigratedKeys","suppressAlerts","captureKey","updateGlobalSafeLocalStorageReference","downgradeSafeLocalStorageToMemory","failingStorage","activeStorage","snapshotError","fallbackStorage","fallbackType","sessionScopes","verified","sessionError","copyError","fallbackDescription","attemptLocalStorageUpgrade","currentStorage","selectedCandidate","verifiedStorage","verificationError","persistentStorageRequestPromise","requestPersistentStorage","storageManager","trackedPromise","alreadyGranted","supportsPersistedCheck","persistedError","granted","verifyError","isMapLike","convertMapLikeKey","json","convertMapLikeToObject","mapLike","assignEntry","iterated","step","LEGACY_LONG_GOP_TOKEN_REGEX","inferLegacyLongGopCompressionVariant","lower","normalizeLegacyLongGopString","normalizeLegacyLongGopKey","normalizedArray","normalizedItem","normalizedObject","normalizedKey","normalizeLegacyLongGopBackups","backups","normalizedEntry","parseWithPrefix","yearPart","monthPart","dayPart","hourPart","minutePart","year","month","day","hour","minute","includeSeconds","seconds","labelStartIndex","secondsCandidate","collectAutoBackupEntries","markAutoBackupValueAsRenamed","isAutoBackupValueRenamed","isRenamedAutoBackupEntry","getAutoBackupLabelKey","getAutoBackupEntrySignature","preparedValue","cloneForSignature","signatureState","seenSet","handleCircularSignature","signatureParseError","removeSingleDuplicateAutoBackupEntry","seenSignaturesByLabel","labelKey","labelSignatures","removeDuplicateAutoBackupEntries","removedKey","pruneAutoBackupEntries","duplicateBuckets","bucketKey","removable","indexes","enforceAutoBackupLimits","autoBackups","deletionBackups","removeOldestAutoBackupEntry","force","removeFromEntries","respectRename","hasValue","duplicateAutoBackupKey","duplicateDeletionBackupKey","oldestDeletionBackupKey","oldestAutoBackupKey","describeAutoGearBackupEntry","trimmedNote","trimmedTimestamp","removeOldestAutoGearBackupEntry","removeAt","cleanupAutoGearBackupMigrationCopies","migrationBackupKey","pruned","clearCachedPlannerDataForAutoGearBackups","shouldDisplayStorageAlert","msg","texts","currentLang","lang","getWindowStorage","collectUniqueStorages","storages","migrateKeyBetweenStorages","legacyKey","modernKey","keepLegacy","legacyValue","destination","removeError","migrateKeyInStorages","preferredTarget","migrateLegacyStorageKeys","localStorages","sessionStorages","legacyPrefix","legacy","modern","includeSession","updateFontKey","migratedLocal","applyLegacyStorageMigrations","safeLocal","defaultValue","disableBackup","validate","restoreIfMissing","alertOnFailure","fallbackKey","useBackup","skipBackupRecovery","allowBackupRecovery","allowMigrationBackupRecovery","migrationBackupCandidates","pushCandidate","rawGetter","rawStoredValue","shouldAlert","parseRawValue","normalizedRaw","cachedPrimary","normalizedForCache","rawForCache","missingPrimary","attemptMigrationBackupRecovery","migrationRaw","migrationRawStored","migrationReadError","rawSource","extracted","extractSnapshotStoredValue","serializedCandidate","restoredRawValue","shouldEscalate","payloadToStore","recompressed","restoreError","shouldAttemptBackup","backupRaw","backupRawStored","backup","recompressSource","normalizedBackup","fallbackRawForCache","shouldAttemptMigrationBackup","migrationRecovery","cleanupKey","cleanupErr","onQuotaExceeded","enableCompressionSweep","disableCompression","forceCompressionOnQuota","sessionScopedStorage","compressionBlocked","allowQuotaCompression","loadRawValue","targetKey","standardSerializedCache","standardSerializationComputed","compressionCandidate","useCompressedSerialization","compressionAttempted","compressionLogged","resetSerializationState","computeStandardSerialized","computeCompressedSerialized","baseline","getSerializedForAttempt","standard","tryEnableCompression","forcing","logCompressionIfNeeded","originalLength","wrappedLength","maybeEnableProactiveCompression","rawExisting","preservedBackupValue","hasPreservedBackup","removedBackupDuringRetry","quotaRecoverySteps","quotaRecoveryFailed","compressionSweepAttempted","registerQuotaRecoveryStep","attemptStorageCleanup","freed","cleaned","attemptHandleQuota","handlerError","skipKeysCleanup","cleanupResult","normalizedSerialized","normalizedString","skipPrimaryWrite","existingBackupValue","existingBackupRaw","observedPrimaryRawValue","observedBackupRawValue","existingValue","existingRawValue","inspectError","backupCandidates","standardSerialized","preferredBackupCandidate","backupMatchesPreferred","backupRawForCache","backupResult","backupError","backupRemovedForRetry","lastCandidate","tryStoreCandidate","normalizedForBackup","deleteFromStorage","disableMigrationCleanup","UI_CACHE_STORAGE_KEYS","UI_CACHE_STORAGE_ACCESS_WARNINGS","collectUiCacheStorages","seenScopes","readProperty","inspectScope","nested","loadFlagFromStorage","saveFlagToStorage","loadWithMigration","primaryLoadMsg","fallbackLoadMsg","saveMsg","deleteMsg","loadOptions","fallbackOptions","generateUniqueName","usedNames","trimmedBase","suffix","ensureImportedProjectBaseName","rawName","importedMatch","resolveImportedProjectNamingContext","parsedSuffix","suffixStart","generateImportedProjectName","normalizedCandidate","ensureUpdatedProjectBaseName","generateUpdatedProjectName","collectStringValues","arraysEqual","normalizeDiagramPositions","positions","diagramPositionsEqual","keysA","keysB","valueA","valueB","normalizeSessionStatePayload","normalizeStringField","mergeArrayField","legacyKeys","values","hadLegacyData","hasTargetKey","normalizedPositions","normalizedState","loadSessionState","saveSessionState","saveOptions","loadAutoGearBackups","normalizeDeviceDataPayload","rawData","ensureObject","loadDeviceData","parsedData","saveDeviceData","deviceData","normalizedDeviceData","dataToPersist","normalizeSetups","obj","used","loadSetups","setups","saveSetups","normalizedSetups","serializedSetups","updateSetups","saveSetup","setup","loadSetup","deleteSetup","renameSetup","oldName","newName","movedValue","wasAutoBackup","targetIsAutoBackup","REQUIREMENT_FIELDS_KEEP_NEWLINES","LEGACY_PROJECT_FIELD_LABELS","PRODUCTION_COMPANY_FIELD_ORDER","normalizeProjectFieldLabel","getProductionCompanyLabelSets","projectLabels","labelSets","textsObj","fallbackProjectLabels","addLabel","legacyLabels","expandCombinedProductionCompanyInfo","rawText","normalizedText","segment","firstLine","metadataLines","collectedFromMetadata","fields","field","streetParts","secondary","streetTwo","joinCollected","combined","activeField","normalizedLine","matchedField","streetLines","LEGACY_PROJECT_LABEL_FIELD_MAP","normalize","labels","HTML_ENTITY_MAP","decodeHtmlEntities","entity","code","mapped","stripHtmlTags","previous","normalizeRequirementValueFromHtml","rawHtml","fieldName","normalizedBreaks","extractRequirementValueMetadata","spanRegex","lines","content","fieldsAttrMatch","singleFieldMatch","rawFields","mapLegacyRequirementLabel","labelText","extractProjectInfoFromHtml","html","gridOpenMatch","gridStartIndex","headingMatch","projectName","gridHtml","boxRegex","globalLang","boxHtml","fieldMatch","labelMatch","valueMatch","rawField","valueToStore","expandedField","expandedValue","cloneProjectData","cloneProjectInfo","projectInfo","sanitizeImportedCrewEntries","sanitizeImportedValue","note","sanitizeImportedProjectInfo","fallbackLensNames","fallbackLensNameSet","addFallbackLensName","registerFallbackLensNames","converted","deriveLensSelectionsFromNameMap","selection","normalizeProjectLensNameCandidate","extractLensNamesFromSource","crew","normalizeProjectLensNamesField","normalizeProjectLensSelectionsFromSources","derived","cloneAutoGearRules","rules","cloneDiagramPositionsForStorage","PROJECT_FILTER_DEFAULT_SIZE","normalizeImportedFilterValues","tryParseJSONLike","normalizeImportedFilterEntry","typePart","sizePart","rawValues","typeCandidate","sizeCandidate","valuesCandidate","hasExplicitValues","typeKeys","sizeKeys","valueKeys","serializeNormalizedFilterEntry","token","normalizeImportedFilterValue","singleEntry","normalizeImportedProjectFilters","normalizedFilter","cloneProjectGearSelectors","selectors","cloneSelectorValue","nestedValue","clonedNestedValue","normalizeProjectPowerSelection","normalizeString","cloneProjectPowerSelection","LEGACY_LENS_SELECTION_META_KEYS","isLikelyLensNameKey","deriveLensNameKeysFromObject","nameCandidates","keyDerivedNames","nestedName","nestedEntries","keyNames","isNormalized","normalizeProjectLensSelectionEntry","mountValue","mountCandidates","trimmedMount","directNameCandidates","mountFields","sources","fallbackNames","sourceList","seenNames","addSelection","entryChanged","processSourceValue","mappedSelections","fallbackName","normalizeProject","projectContainer","projectInfoSource","normalizedProjectInfo","parsedInfo","nestedProjectInfo","parsedProjectInfo","normalizedAutoGearRules","assignAutoGearRules","convertedRules","parsedRules","gearListSource","convertedGearList","normalizedGearList","normalizedGearSelectors","gearSelectorsSource","parsedSelectors","powerSelectionSource","normalizedPowerSelection","parsedGear","diagramSource","normalizedDiagramPositions","nestedDiagramSource","htmlSources","nestedSelectorsSource","nestedPowerSelection","recovered","recoveredClone","normalizedClone","lensSelectionSources","lensSelectionResult","derivedGenerationFlag","normalizedInfo","normalizedRules","normalizedSelectors","normalizedDiagram","normalizedPower","parsedProject","LEGACY_PROJECT_ROOT_KEYS","NORMALIZED_PROJECT_KEYS","isNormalizedProjectEntry","gearList","powerSelection","setActiveProjectCompressionHold","clearActiveProjectCompressionHold","resolveProjectKey","rawMap","normalizedMap","exact","firstExisting","buildProjectLookupFromProjects","rawKeyLookup","normalizedKeyLookup","forceRefresh","skipMigrations","skipAutoBackupExpansion","projectsSnapshot","lookupSnapshot","storageRaw","combinedRawEntries","rawVal","parsedVal","inputForExpansion","expandOptions","expandedParsed","usedProjectNames","normalizedProjectNames","markProjectNameUsed","registerLookupKey","storedKey","effectiveKey","createLookupSnapshot","suggestedName","updatedName","trimmedKey","originalEntry","needsUpgrade","requiresContentUpdate","normalizedSignature","originalSignature","finalKey","innerName","pruneOrphanProjectShards","keysToDelete","cleanupMonolithicProjectStorage","persistProjectShard","project","skipCompression","shardKey","victimKey","persistAllProjects","indexError","entryModified","existingModified","buildProjectIndexForRepo","prefixed","storedIndex","indexKeys","migrationResult","prefixedIndex","readProjectIndex","isIndexedDB","loadProject","resolvedKey","mutableProjects","loadProjectMetadata","cachedIndex","loaded","sanitizeProjectNameForBackup","collapsed","formatAutoBackupTimestamp","date","pad","generateDeletionBackupMetadata","sanitizedName","cloneProjectEntryForBackup","maybeCreateProjectDeletionBackup","backupName","createProjectDeletionBackup","backupOutcome","generateOverwriteBackupMetadata","maybeCreateProjectOverwriteBackup","backupSource","saveProject","skipOverwriteBackup","requestedKey","preferredKey","initialSnapshot","initialProjects","initialResolvedKey","initialExistingEntry","initialExistingSignature","latestSnapshot","renamedFromKey","existingKey","hasExistingEntry","existingEntry","nextSignature","shouldDelete","manualRenamedFrom","resolvedOld","shardSuccess","deleteProject","storagesToPrune","backupSuffix","uiCacheError","currentSafeStorage","potentialShardKey","renameProject","targetName","createProjectImporter","defaultName","normalizedProject","uniqueName","firstChar","lastChar","expectedClosing","importProjectCollection","ensureImporter","fallbackLabel","proj","importProject","collectLegacyProjectCollections","collections","addCollection","plannerData","loadFavorites","saveFavorites","favs","resolveContactsModuleApi","contactsModuleImport","moduleBase","fallbackSanitizeContactValue","fallbackGenerateContactId","generated","fallbackNormalizeContactEntry","sanitize","avatarSource","fallbackSortContacts","createdA","createdB","normalizeContactsList","sorted","normalizer","loadContacts","saveContacts","loadOwnGear","saveOwnGear","normalizeUserProfileField","normalizeUserProfile","loadUserProfile","saveUserProfile","profile","loadFeedback","saveFeedback","feedback","normalizeFullBackupHistoryEntry","loadFullBackupHistory","saveFullBackupHistory","safeEntries","recordFullBackupHistoryEntry","history","normalizeImportedFullBackupHistory","results","nestedValues","DOCUMENTATION_TRACKER_SCHEMA_VERSION","generateDocumentationTrackerId","normalizeDocumentationTrackerStatusEntry","completed","timestampCandidate","normalizeDocumentationTrackerStatusMap","keyString","normalizeDocumentationTrackerStatuses","normalizeDocumentationTrackerRelease","targetDate","archived","normalizedStatus","statuses","normalizeDocumentationTrackerState","rawState","loadDocumentationTracker","saveDocumentationTracker","loadAutoGearRules","saveAutoGearRules","defaultsApplied","withDefaults","rule","skipNormalization","safeRules","normalizedCached","saveAutoGearBackups","normalizedBackups","safeBackups","attemptedMigrationCleanup","attemptedCacheCleanup","isIndexedDBActive","removal","loadAutoGearSeedFlag","saveAutoGearSeedFlag","loadAutoGearPresets","presets","presetArray","saveAutoGearPresets","readActiveAutoGearPresetIds","ids","pushId","loadAutoGearActivePresetId","loadAutoGearAutoPresetId","disableCompressionOverride","safePresets","normalizedPresets","activePresetIds","loadAutoGearMonitorDefaults","monitorDefaults","normalizedDefaults","saveAutoGearMonitorDefaults","safeDefaults","removeAutoGearPresetFromStorage","presetId","rawPresets","parsedPresets","normalizedRawPresets","filteredPresets","saveAutoGearActivePresetId","saveAutoGearAutoPresetId","previousPresetId","existingId","loadAutoGearBackupVisibility","saveAutoGearBackupVisibility","getAutoGearBackupRetentionUpperBound","clampAutoGearBackupRetention","getAutoGearBackupRetentionDefault","upperBound","normalizeAutoGearBackupRetentionValue","maybeJson","candidateKeys","loadAutoGearBackupRetention","retention","saveAutoGearBackupRetention","clearAllData","clearVaultFn","vaultDbNames","db","listError","dbName","request","deleteError","vaultError","clearStorageFully","storageName","objectKeys","objKeysError","iterateError","sessionCacheKeys","ensureStoragePruned","cacheKeys","cacheError","onboardingStorageKeys","clearOnboardingTutorialState","storageCandidates","sessionCandidates","loggingError","windowNameError","registrations","swError","readLocalStorageValue","decodedBackup","parseStoredBoolean","interpretPrintPreferencesValue","hasSectionsContainer","sectionsSource","sections","sectionKeys","sectionKey","sectionValue","layout","trimmedLayout","collectPreferenceSnapshot","preferences","darkMode","pinkMode","highContrast","reduceMotion","relaxedSpacing","showAutoBackups","accentColor","fontSize","fontFamily","language","mountVoltageKey","mountVoltages","voltageParseError","iosPwaHelpShown","temperatureUnit","focusScale","cameraColorsRaw","parsedCameraColors","trimmedCameraColors","cameraColorParseError","printPreferencesRaw","interpretedPrintPreferences","normalizeCustomFontEntries","readStoredCustomFonts","backupVaultRecordCache","normalizeBackupVaultMetadata","normalizeBackupVaultRecord","fileName","createdAtMs","normalizedCreatedAtMs","parsedTime","normalizeBackupVaultRecordList","records","parsedResult","scoreBackupVaultRecord","score","mergeBackupVaultRecords","existingList","incomingList","mergeList","readBackupVaultFallbackRecords","resolveBackupVaultApi","refreshBackupVaultRecordCache","loader","response","prepareBackupForExport","exportAllData","documentationTracker","customLogo","customFonts","schemaCache","fallbackVaultRecords","combinedVaultRecords","safeSetLocalStorage","clearCacheForKey","writeLegacyStorage","storedValue","legacyError","normalizeImportedBoolean","normalizeImportedArray","fallbackKeys","filterFn","normalizeImportedContacts","normalizeImportedAutoGearRules","normalizeImportedAutoGearBackups","normalizeImportedAutoGearBackupRetention","normalizeImportedAutoGearPresets","normalizeImportedAutoGearMonitorDefaults","legacyNormalized","normalizeImportedPresetId","normalizeImportedBackupVaultRecords","importBackupVaultRecords","existingFallback","mergedFallback","storageError","queueRecord","existingIds","getSnapshotKeyVariants","readSnapshotEntry","compressionToken","encodingToken","isModernCompression","isLegacyLongGopCompression","parseSnapshotJSONValue","parseSnapshotStringValue","convertStorageSnapshotToData","hasAssignments","hasSnapshotKeys","preferenceKeys","mountVoltageKeyName","simpleSnapshotKeys","booleanPreferenceKeys","markSnapshotEntry","assignJSONValue","schemaEntry","cacheValue","customFontsEntry","fontsValue","customLogoEntry","logoValue","seedEntry","activePresetEntry","autoPresetEntry","backupsVisibilityEntry","snapshotPrintValue","interpretedPreferences","stringValue","temperatureUnitEntry","storedUnit","normalizedUnit","focusScaleEntry","storedScale","normalizedScale","cameraColorsEntry","storedCameraColors","mountVoltageEntry","storedVoltages","importAllData","allData","skipSnapshotConversion","hasOwn","cameraColorKeyName","prefs","unit","scale","focusScaleError","rawPrintPreferences","normalizedPrintPreferences","serializedPrintPreferences","printPreferenceSerializationError","printPreferencePersistError","printPreferenceApplyError","printPreferenceStringPersistError","rawVoltages","voltStoreError","parsedVoltages","voltParseError","rawCameraColors","applyImportedCameraColors","palette","applied","cameraColorApplyError","serializedPalette","cameraColorSerializeError","cameraColorPersistError","cameraColorStoreError","logo","schemaError","trackerState","trackerFromLogs","trackerFromLegacy","visibility","backupRecords","importProjectEntry","ensureProjectImporter","projectImported","getTrackedImporter","importer","importTrackedCollection","getProjectMemoryCache","STORAGE_API","TEST_ONLY_AUTO_BACKUP_COMPRESSION_CACHE","definitionError","cineStorage","resolveModuleLinker","linker","MODULE_LINKER","linked","linkedRegistry","linkedKey","sharedKey","bridgedKey","cloneOptions","fallbackRegisterOrQueue","fallbackExposeGlobal","providerModules","addProviderModule","reference","bindingState","bindingNames","identifyProvider","providerEntry","ref","ensureBindingEntry","bindingKey","implementationName","resolveBinding","refresh","requireBinding","snapshotBinding","createWrapper","alias","inspectBinding","inspectAllBindings","listBindings","persistenceAPI","existingPersistence","ProjectService","newProject","sourceId","cleanSourceId","sourceProject","existingNames","counter","newData","projectService"],"ignoreList":[],"sources":["../../src/scripts/modules/icons.js","../../src/scripts/modules/helpers/scope-collector.js","../../src/scripts/modules/base.js","../../src/scripts/modules/registry.js","../../src/scripts/modules/helpers/scope-utils.js","../../src/scripts/modules/device-normalization.js","../../src/scripts/modules/logging.js","../../src/scripts/console-helpers.js","../../src/scripts/modules/logging-resolver.js","../../src/scripts/modules/features/contacts.js","../../src/scripts/modules/storage/StorageInterface.js","../../src/scripts/modules/storage/drivers/LocalStorageAdapter.js","../../src/scripts/modules/core/UserContext.js","../../src/scripts/modules/storage/SyncMetadata.js","../../src/scripts/modules/storage/ProjectLockService.js","../../src/scripts/modules/storage/StorageRepository.js","../../src/scripts/modules/storage/drivers/IndexedDBAdapter.js","../../src/scripts/modules/storage/StorageMigrationService.js","../../src/scripts/modules/gear/GearRepository.js","../../src/scripts/modules/storage/DataVault.js","../../src/scripts/storage.js","../../src/scripts/modules/persistence.js","../../src/scripts/modules/persistence/ProjectService.js"],"sourcesContent":["/* global ICON_FONT_KEYS */\n// Removed IIFE wrapper for ES Module conversion\n// (function createCineIconsModule() {\n\nconst globalScope =\n    (typeof globalThis !== 'undefined' && globalThis) ||\n    (typeof window !== 'undefined' && window) ||\n    (typeof self !== 'undefined' && self) ||\n    (typeof global !== 'undefined' && global) ||\n    {};\n\nconst VALID_ICON_FONTS = (function createValidIconFontSet() {\n    // Ensure ICON_FONT_KEYS is available\n    const keys = globalScope.ICON_FONT_KEYS || (typeof ICON_FONT_KEYS !== 'undefined' ? ICON_FONT_KEYS : null);\n\n    if (typeof keys !== 'object' || !keys) {\n        return new Set();\n    }\n    const fonts = Object.values(keys).filter(\n        font => typeof font === 'string' && font,\n    );\n    return new Set(fonts);\n})();\n\nfunction toCodePointChar(value, radix) {\n    const codePoint = parseInt(value, radix);\n    if (!Number.isFinite(codePoint) || codePoint < 0) {\n        return '';\n    }\n    if (typeof String.fromCodePoint === 'function') {\n        try {\n            return String.fromCodePoint(codePoint);\n        } catch (rangeError) {\n            void rangeError;\n        }\n    }\n    if (codePoint <= 0xffff) {\n        return String.fromCharCode(codePoint);\n    }\n    return '';\n}\n\nfunction normalizeGlyphChar(char) {\n    if (typeof char !== 'string') {\n        return '';\n    }\n    const trimmed = char.trim();\n    if (!trimmed) {\n        return '';\n    }\n    const unicodeMatch = trimmed.match(/^(?:\\\\)+u([0-9A-Fa-f]{4})$/);\n    if (unicodeMatch) {\n        const decoded = toCodePointChar(unicodeMatch[1], 16);\n        if (decoded) {\n            return decoded;\n        }\n    }\n    const unicodeBraceMatch = trimmed.match(/^(?:\\\\)+u\\{([0-9A-Fa-f]+)\\}$/);\n    if (unicodeBraceMatch) {\n        const decoded = toCodePointChar(unicodeBraceMatch[1], 16);\n        if (decoded) {\n            return decoded;\n        }\n    }\n    const hexEntityMatch = trimmed.match(/^&#x([0-9A-Fa-f]+);$/i);\n    if (hexEntityMatch) {\n        const decoded = toCodePointChar(hexEntityMatch[1], 16);\n        if (decoded) {\n            return decoded;\n        }\n    }\n    const decimalEntityMatch = trimmed.match(/^&#(\\d+);$/);\n    if (decimalEntityMatch) {\n        const decoded = toCodePointChar(decimalEntityMatch[1], 10);\n        if (decoded) {\n            return decoded;\n        }\n    }\n    return trimmed;\n}\n\nfunction iconGlyph(char, font) {\n    // Resolve font keys dynamically to handle load order\n    const keys = globalScope.ICON_FONT_KEYS || (typeof ICON_FONT_KEYS !== 'undefined' ? ICON_FONT_KEYS : { UICONS: 'uicons' });\n    const defaultFont = keys.UICONS || 'uicons';\n    const requestedFont = font || defaultFont;\n\n    const normalizedFont = VALID_ICON_FONTS.has(requestedFont) ? requestedFont : defaultFont;\n    const normalizedChar = normalizeGlyphChar(char);\n    const glyph = {\n        char: normalizedChar,\n        font: normalizedFont,\n    };\n    return typeof Object.freeze === 'function' ? Object.freeze(glyph) : glyph;\n}\n\nfunction resolveIconGlyph(glyph) {\n    const keys = globalScope.ICON_FONT_KEYS || (typeof ICON_FONT_KEYS !== 'undefined' ? ICON_FONT_KEYS : { UICONS: 'uicons' });\n    const defaultFont = keys.UICONS || 'uicons';\n\n    if (!glyph) {\n        return {\n            char: '',\n            font: defaultFont,\n            className: '',\n            size: undefined,\n        };\n    }\n    if (glyph.markup) {\n        const size = Number.isFinite(glyph.size) ? glyph.size : undefined;\n        return {\n            markup: glyph.markup,\n            className: glyph.className || '',\n            font: defaultFont,\n            size,\n        };\n    }\n    if (typeof glyph === 'string') {\n        return {\n            char: normalizeGlyphChar(glyph),\n            font: defaultFont,\n            className: '',\n            size: undefined,\n        };\n    }\n    if (typeof glyph === 'object') {\n        const char = typeof glyph.char === 'string' ? normalizeGlyphChar(glyph.char) : '';\n        const fontKey = glyph.font && VALID_ICON_FONTS.has(glyph.font) ? glyph.font : defaultFont;\n        const className = typeof glyph.className === 'string' ? glyph.className : '';\n        const size = Number.isFinite(glyph.size) ? glyph.size : undefined;\n        if (glyph.markup) {\n            return {\n                markup: glyph.markup,\n                className,\n                font: fontKey,\n                size,\n            };\n        }\n        return {\n            char,\n            font: fontKey,\n            className,\n            size,\n        };\n    }\n    return {\n        char: '',\n        font: defaultFont,\n        className: '',\n        size: undefined,\n    };\n}\n\nfunction ensureSvgHasAriaHidden(markup) {\n    if (typeof markup !== 'string') return '';\n    if (markup.indexOf('aria-hidden=\"true\"') !== -1) return markup;\n    return markup.replace('<svg', '<svg aria-hidden=\"true\"');\n}\n\nfunction applyIconGlyph(element, glyph) {\n    if (!element) return;\n    const resolved = resolveIconGlyph(glyph);\n    if (resolved.markup) {\n        element.innerHTML = ensureSvgHasAriaHidden(resolved.markup);\n        element.setAttribute('aria-hidden', 'true');\n        if (resolved.className) {\n            resolved.className\n                .split(/\\s+/)\n                .filter(Boolean)\n                .forEach(cls => element.classList.add(cls));\n        }\n        element.removeAttribute('data-icon-font');\n        return;\n    }\n    const char = resolved.char || '';\n    element.textContent = char;\n    if (char) {\n        element.setAttribute('data-icon-font', resolved.font);\n    } else {\n        element.removeAttribute('data-icon-font');\n    }\n}\n\nfunction iconMarkup(glyph, className) {\n    const resolved = resolveIconGlyph(glyph);\n    const parts = [];\n    if (resolved.className) parts.push(resolved.className);\n    if (className) parts.push(className);\n    const finalClass = parts.join(' ');\n\n    if (resolved.markup) {\n        let svg = ensureSvgHasAriaHidden(resolved.markup);\n        if (finalClass) {\n            if (svg.indexOf('class=\"') !== -1) {\n                svg = svg.replace('class=\"', `class=\"${finalClass} `);\n            } else {\n                svg = svg.replace('<svg', `<svg class=\"${finalClass}\"`);\n            }\n        }\n        return svg;\n    }\n\n    const fontAttr = resolved.char ? `data-icon-font=\"${resolved.font}\"` : '';\n    return `<span class=\"icon-glyph ${finalClass}\" aria-hidden=\"true\" ${fontAttr}>${resolved.char}</span>`;\n}\n\nfunction formatSvgCoordinate(value) {\n    if (!Number.isFinite(value)) return '0';\n    const rounded = Math.round(value * 100) / 100;\n    if (Number.isInteger(rounded)) return String(rounded);\n    return rounded.toFixed(2).replace(/0+$/, '').replace(/\\.$/, '');\n}\n\nfunction positionSvgMarkup(markup, centerX, centerY, size = 24) {\n    if (typeof markup !== 'string') {\n        return { markup: '', x: '0', y: '0' };\n    }\n    const trimmed = markup.trim();\n    if (!trimmed) {\n        return { markup: '', x: '0', y: '0' };\n    }\n    const half = size / 2;\n    const x = formatSvgCoordinate(centerX);\n    const y = formatSvgCoordinate(centerY);\n    const width = formatSvgCoordinate(size);\n    const height = formatSvgCoordinate(size);\n    const cleaned = trimmed.replace(/<svg\\b([^>]*)>/i, (match, attrs = '') => {\n        let attrText = attrs\n            .replace(/\\s+x\\s*=\\s*\"[^\"]*\"/gi, '')\n            .replace(/\\s+y\\s*=\\s*\"[^\"]*\"/gi, '')\n            .trim();\n        const additions = [];\n        if (!/(?:^|\\s)width\\s*=/i.test(attrText)) additions.push(`width=\"${width}\"`);\n        if (!/(?:^|\\s)height\\s*=/i.test(attrText)) additions.push(`height=\"${height}\"`);\n        additions.push(`x=\"-${formatSvgCoordinate(half)}\"`);\n        additions.push(`y=\"-${formatSvgCoordinate(half)}\"`);\n        attrText = [attrText].concat(additions).filter(Boolean).join(' ').trim();\n        return attrText ? `<svg ${attrText}>` : '<svg>';\n    });\n    return { markup: cleaned, x, y };\n}\n\nconst STAR_ICON_SVG = `\n<svg viewBox=\"0 0 24 24\" xmlns=\"http://www.w3.org/2000/svg\">\n  <path\n    d=\"M12 17.25 6.545 20.2 7.9 13.975 3 9.45l6.272-.7L12 3l2.728 5.75L21 9.45l-4.9 4.525 1.355 6.225Z\"\n    fill=\"currentColor\"\n    stroke=\"currentColor\"\n    stroke-width=\"0\"\n  />\n</svg>\n`.trim();\n\n// We need to access ICON_FONT_KEYS from the global scope or where it's defined\nconst keys = globalScope.ICON_FONT_KEYS || (typeof ICON_FONT_KEYS !== 'undefined' ? ICON_FONT_KEYS : {\n    UICONS: 'uicons',\n    ESSENTIAL: 'essential',\n    GADGET: 'gadget',\n    FILM: 'film',\n    TEXT: 'text'\n});\n\nconst ICON_GLYPHS = Object.freeze({\n    batteryBolt: iconGlyph('\\uE1A6', keys.UICONS),\n    batteryFull: iconGlyph('\\uE1A9', keys.UICONS),\n    bolt: iconGlyph('\\uF1F8', keys.ESSENTIAL),\n    plug: iconGlyph('\\uEE75', keys.UICONS),\n    sliders: iconGlyph('\\uF143', keys.ESSENTIAL),\n    screen: iconGlyph('\\uF11D', keys.GADGET),\n    brightness: iconGlyph('\\uE2B3', keys.UICONS),\n    wifi: iconGlyph('\\uF4AC', keys.UICONS),\n    gears: iconGlyph('\\uE8AF', keys.UICONS),\n    controller: iconGlyph('\\uF117', keys.GADGET),\n    distance: iconGlyph('\\uEFB9', keys.UICONS),\n    sensor: iconGlyph('\\uEC2B', keys.UICONS),\n    viewfinder: iconGlyph('\\uF114', keys.FILM),\n    camera: iconGlyph('\\uE333', keys.UICONS),\n    trash: iconGlyph('\\uF254', keys.ESSENTIAL),\n    reload: iconGlyph('\\uF202', keys.ESSENTIAL),\n    load: iconGlyph('\\uE0E0', keys.UICONS),\n    installApp: iconGlyph('\\uE9D4', keys.UICONS),\n    add: Object.freeze({ char: '+', font: keys.TEXT, className: 'icon-text' }),\n    minus: Object.freeze({ char: '', font: keys.TEXT, className: 'icon-text' }),\n    arrowLeft: Object.freeze({ char: '', font: keys.TEXT, className: 'icon-text' }),\n    check: iconGlyph('\\uE3D8', keys.UICONS),\n    fileExport: iconGlyph('\\uE7AB', keys.UICONS),\n    fileImport: iconGlyph('\\uE7C7', keys.UICONS),\n    save: iconGlyph('\\uF207', keys.ESSENTIAL),\n    share: iconGlyph('\\uF219', keys.ESSENTIAL),\n    paperPlane: iconGlyph('\\uED67', keys.UICONS),\n    magnet: iconGlyph('\\uF1B5', keys.ESSENTIAL),\n    codec: iconGlyph('\\uE4CD', keys.UICONS),\n    timecode: iconGlyph('\\uF10E', keys.FILM),\n    audioIn: iconGlyph('\\uF1C3', keys.ESSENTIAL),\n    audioOut: iconGlyph('\\uF22F', keys.ESSENTIAL),\n    note: iconGlyph('\\uF13E', keys.ESSENTIAL),\n    overview: iconGlyph('\\uF1F5', keys.UICONS),\n    gearList: iconGlyph('\\uE467', keys.UICONS),\n    contacts: iconGlyph('\\uF404', keys.UICONS),\n    feedback: iconGlyph('\\uE791', keys.UICONS),\n    resetView: iconGlyph('\\uEB6D', keys.UICONS),\n    pin: iconGlyph('\\uF1EF', keys.ESSENTIAL),\n    sun: iconGlyph('\\uF1FE', keys.UICONS),\n    moon: iconGlyph('\\uEC7E', keys.UICONS),\n    circleX: iconGlyph('\\uF131', keys.ESSENTIAL),\n    settingsGeneral: iconGlyph('\\uE5A3', keys.UICONS),\n    settingsAutoGear: iconGlyph('\\uE8AF', keys.UICONS),\n    settingsAccessibility: iconGlyph('\\uF392', keys.UICONS),\n    settingsBackup: iconGlyph('\\uE5BD', keys.UICONS),\n    settingsData: iconGlyph('\\uE5C7', keys.UICONS),\n    settingsAbout: iconGlyph('\\uEA4F', keys.UICONS),\n    star: Object.freeze({ markup: STAR_ICON_SVG, className: 'icon-svg favorite-star-icon' }),\n    warning: iconGlyph('\\uF26F', keys.ESSENTIAL),\n});\n\n// Expose to global scope for legacy compatibility\nglobalScope.cineIcons = {\n    VALID_ICON_FONTS,\n    toCodePointChar,\n    normalizeGlyphChar,\n    iconGlyph,\n    resolveIconGlyph,\n    applyIconGlyph,\n    iconMarkup,\n    formatSvgCoordinate,\n    positionSvgMarkup,\n    STAR_ICON_SVG,\n    ICON_GLYPHS,\n};\n\n// Expose individual functions for backward compatibility if needed, \n// or just use cineIcons namespace. \n// Based on app-core-new-1.js usage, these seem to be expected in the scope.\nglobalScope.iconGlyph = iconGlyph;\nglobalScope.resolveIconGlyph = resolveIconGlyph;\nglobalScope.applyIconGlyph = applyIconGlyph;\nglobalScope.iconMarkup = iconMarkup;\nglobalScope.formatSvgCoordinate = formatSvgCoordinate;\nglobalScope.positionSvgMarkup = positionSvgMarkup;\nglobalScope.STAR_ICON_SVG = STAR_ICON_SVG;\nglobalScope.ICON_GLYPHS = ICON_GLYPHS;\n\n// Export as ES Module\nexport const cineIcons = globalScope.cineIcons;\nexport {\n    VALID_ICON_FONTS,\n    toCodePointChar,\n    normalizeGlyphChar,\n    iconGlyph,\n    resolveIconGlyph,\n    applyIconGlyph,\n    iconMarkup,\n    formatSvgCoordinate,\n    positionSvgMarkup,\n    STAR_ICON_SVG,\n    ICON_GLYPHS,\n};\n","function detectGlobalScope() {\n  if (typeof globalThis !== 'undefined') {\n    return globalThis;\n  }\n  if (typeof window !== 'undefined') {\n    return window;\n  }\n  if (typeof self !== 'undefined') {\n    return self;\n  }\n  if (typeof global !== 'undefined') {\n    return global;\n  }\n  return {};\n}\n\nfunction isObjectLike(value) {\n  return !!value && (typeof value === 'object' || typeof value === 'function');\n}\n\nfunction freezeArray(array) {\n  if (typeof Object.freeze === 'function') {\n    try {\n      return Object.freeze(array);\n    } catch (error) {\n      void error;\n    }\n  }\n  return array;\n}\n\nfunction cloneArray(array) {\n  if (!array) {\n    return [];\n  }\n  try {\n    return Array.prototype.slice.call(array);\n  } catch (error) {\n    void error;\n  }\n  const clone = [];\n  for (let index = 0; index < array.length; index += 1) {\n    clone[index] = array[index];\n  }\n  return clone;\n}\n\nfunction createPrimaryCache() {\n  return {\n    objects: typeof WeakMap === 'function' ? new WeakMap() : null,\n    primitives: Object.create(null),\n    empty: null,\n  };\n}\n\nfunction getPrimaryCacheEntry(cache, primary) {\n  if (!cache) {\n    return null;\n  }\n\n  if (isObjectLike(primary)) {\n    if (!cache.objects) {\n      return null;\n    }\n    let entry = cache.objects.get(primary);\n    if (!entry) {\n      entry = { cached: false, value: null };\n      cache.objects.set(primary, entry);\n    }\n    return entry;\n  }\n\n  const key = typeof primary + ':' + String(primary);\n  let entry = cache.primitives[key];\n  if (!entry) {\n    entry = { cached: false, value: null };\n    cache.primitives[key] = entry;\n  }\n  return entry;\n}\n\nfunction pushUnique(target, value) {\n  if (!isObjectLike(value)) {\n    return;\n  }\n  if (target.indexOf(value) === -1) {\n    target.push(value);\n  }\n}\n\nconst BASE_SCOPES = (function buildBaseScopes() {\n  const scopes = [];\n  pushUnique(scopes, typeof globalThis !== 'undefined' ? globalThis : null);\n  pushUnique(scopes, typeof window !== 'undefined' ? window : null);\n  pushUnique(scopes, typeof self !== 'undefined' ? self : null);\n  pushUnique(scopes, typeof global !== 'undefined' ? global : null);\n  return freezeArray(scopes);\n})();\n\nconst EMPTY_EXTRAS = freezeArray([]);\nconst SUPPORTS_WEAKMAP = typeof WeakMap === 'function';\nconst DETECT_CACHE = SUPPORTS_WEAKMAP ? new WeakMap() : null;\n\nfunction sanitizeExtras(extras) {\n  if (!Array.isArray(extras) || extras.length === 0) {\n    return EMPTY_EXTRAS;\n  }\n\n  const sanitized = [];\n  for (let index = 0; index < extras.length; index += 1) {\n    pushUnique(sanitized, extras[index]);\n  }\n\n  if (sanitized.length === 0) {\n    return EMPTY_EXTRAS;\n  }\n\n  return freezeArray(sanitized);\n}\n\nfunction computeCandidateScopes(primary, detectFn, extrasList) {\n  const scopes = [];\n  pushUnique(scopes, primary);\n\n  let detected = null;\n  if (typeof detectFn === 'function') {\n    try {\n      detected = detectFn();\n    } catch (error) {\n      void error;\n      detected = null;\n    }\n  }\n  pushUnique(scopes, detected);\n\n  for (let index = 0; index < BASE_SCOPES.length; index += 1) {\n    pushUnique(scopes, BASE_SCOPES[index]);\n  }\n\n  if (Array.isArray(extrasList)) {\n    for (let index = 0; index < extrasList.length; index += 1) {\n      pushUnique(scopes, extrasList[index]);\n    }\n  }\n\n  return freezeArray(scopes);\n}\n\nfunction getExtrasCache(detectEntry, extrasList) {\n  if (!detectEntry) {\n    return null;\n  }\n\n  if (extrasList === EMPTY_EXTRAS) {\n    if (!detectEntry.empty) {\n      detectEntry.empty = createPrimaryCache();\n    }\n    return detectEntry.empty;\n  }\n\n  if (!detectEntry.extras) {\n    if (!SUPPORTS_WEAKMAP) {\n      return null;\n    }\n    detectEntry.extras = new WeakMap();\n  }\n\n  let extrasEntry = detectEntry.extras.get(extrasList);\n  if (!extrasEntry) {\n    extrasEntry = createPrimaryCache();\n    detectEntry.extras.set(extrasList, extrasEntry);\n  }\n  return extrasEntry;\n}\n\nfunction getDetectEntry(detectFn) {\n  if (!DETECT_CACHE) {\n    return null;\n  }\n\n  let entry = DETECT_CACHE.get(detectFn);\n  if (!entry) {\n    entry = { empty: null, extras: null };\n    DETECT_CACHE.set(detectFn, entry);\n  }\n  return entry;\n}\n\nfunction collectInternal(primary, detectFn, extrasList, cacheEntry) {\n  if (cacheEntry) {\n    const primaryEntry = getPrimaryCacheEntry(cacheEntry, primary);\n    if (primaryEntry) {\n      if (primaryEntry.cached) {\n        return cloneArray(primaryEntry.value);\n      }\n      const computed = computeCandidateScopes(primary, detectFn, extrasList);\n      primaryEntry.value = computed;\n      primaryEntry.cached = true;\n      return cloneArray(computed);\n    }\n  }\n\n  const computedFallback = computeCandidateScopes(primary, detectFn, extrasList);\n  return cloneArray(computedFallback);\n}\n\nexport function createCollector(options) {\n  const detectFn = options && typeof options.detectGlobalScope === 'function'\n    ? options.detectGlobalScope\n    : detectGlobalScope;\n  const extrasList = sanitizeExtras(options && options.additionalScopes);\n  const detectEntry = getDetectEntry(detectFn);\n  const cacheEntry = getExtrasCache(detectEntry, extrasList);\n\n  return function collectWithPreset(primary) {\n    return collectInternal(primary, detectFn, extrasList, cacheEntry);\n  };\n}\n\nexport function collectCandidateScopes(primary, options) {\n  const collector = createCollector(options || {});\n  return collector(primary);\n}\n\nexport function getBaseScopes() {\n  return cloneArray(BASE_SCOPES);\n}\n\n// Global Assignment for Legacy Compatibility\nconst GLOBAL_SCOPE = detectGlobalScope();\n\nif (GLOBAL_SCOPE && !GLOBAL_SCOPE.__cineScopeCollector) {\n  GLOBAL_SCOPE.__cineScopeCollector = {\n    collectCandidateScopes,\n    createCollector,\n    getBaseScopes,\n  };\n}\n","import { createCollector } from './helpers/scope-collector.js';\n\nconst DEFAULT_PENDING_QUEUE_KEY = '__cinePendingModuleRegistrations__';\n\nfunction fallbackDetectGlobalScope() {\n  if (typeof globalThis !== 'undefined') {\n    return globalThis;\n  }\n  if (typeof window !== 'undefined') {\n    return window;\n  }\n  if (typeof self !== 'undefined') {\n    return self;\n  }\n  if (typeof global !== 'undefined') {\n    return global;\n  }\n  return {};\n}\n\nfunction installSafeConsoleGuards(scope) {\n  const targetScope = scope || fallbackDetectGlobalScope();\n  if (!targetScope || (typeof targetScope !== 'object' && typeof targetScope !== 'function')) {\n    return;\n  }\n\n  let consoleRef = null;\n  try {\n    consoleRef = targetScope.console || null;\n  } catch (error) {\n    consoleRef = null;\n    void error;\n  }\n\n  if (!consoleRef || (typeof consoleRef !== 'object' && typeof consoleRef !== 'function')) {\n    return;\n  }\n\n  const methods = ['log', 'warn', 'error', 'info', 'debug'];\n  let originals = null;\n\n  try {\n    originals = consoleRef.__cineSafeConsoleOriginals || null;\n  } catch (error) {\n    originals = null;\n    void error;\n  }\n\n  if (!originals || typeof originals !== 'object') {\n    originals = {};\n    try {\n      Object.defineProperty(consoleRef, '__cineSafeConsoleOriginals', {\n        configurable: true,\n        enumerable: false,\n        writable: true,\n        value: originals,\n      });\n    } catch (defineError) {\n      try {\n        consoleRef.__cineSafeConsoleOriginals = originals;\n      } catch (assignError) {\n        void assignError;\n      }\n      void defineError;\n    }\n  }\n\n  for (let index = 0; index < methods.length; index += 1) {\n    const method = methods[index];\n    let candidate = null;\n    try {\n      candidate = consoleRef[method];\n    } catch (error) {\n      candidate = null;\n      void error;\n    }\n\n    if (typeof candidate !== 'function') {\n      continue;\n    }\n\n    if (candidate && candidate.__cineSafeConsoleGuard) {\n      continue;\n    }\n\n    if (!Object.prototype.hasOwnProperty.call(originals, method)) {\n      originals[method] = candidate;\n    }\n\n    const guarded = function cineSafeConsoleGuard() {\n      try {\n        return candidate.apply(consoleRef, arguments);\n      } catch (error) {\n        void error;\n      }\n      return undefined;\n    };\n\n    try {\n      Object.defineProperty(guarded, '__cineSafeConsoleGuard', {\n        configurable: true,\n        enumerable: false,\n        writable: false,\n        value: true,\n      });\n    } catch (defineError) {\n      guarded.__cineSafeConsoleGuard = true;\n      void defineError;\n    }\n\n    try {\n      consoleRef[method] = guarded;\n    } catch (error) {\n      void error;\n    }\n  }\n}\n\nconst createScopeCollector = createCollector;\n\nconst DEFAULT_EXTRAS_KEY = { key: 'defaultExtras' };\nconst HELPER_COLLECTOR_CACHE = [];\nconst BASE_SCOPE_EXTRAS_CACHE = typeof WeakMap === 'function' ? new WeakMap() : [];\n\nfunction resolveExtrasForBaseScope(baseScope) {\n  if (!baseScope || (typeof baseScope !== 'object' && typeof baseScope !== 'function')) {\n    return undefined;\n  }\n\n  if (BASE_SCOPE_EXTRAS_CACHE && typeof BASE_SCOPE_EXTRAS_CACHE.get === 'function') {\n    let extras = BASE_SCOPE_EXTRAS_CACHE.get(baseScope);\n    if (!extras) {\n      extras = [baseScope];\n      BASE_SCOPE_EXTRAS_CACHE.set(baseScope, extras);\n    }\n    return extras;\n  }\n\n  for (let index = 0; index < BASE_SCOPE_EXTRAS_CACHE.length; index += 1) {\n    const entry = BASE_SCOPE_EXTRAS_CACHE[index];\n    if (entry.scope === baseScope) {\n      return entry.extras;\n    }\n  }\n\n  const extras = [baseScope];\n  BASE_SCOPE_EXTRAS_CACHE.push({ scope: baseScope, extras });\n  return extras;\n}\n\nfunction resolveHelperCollector(detectFn, extras) {\n  if (!createScopeCollector) {\n    return null;\n  }\n\n  const extrasKey = Array.isArray(extras) ? extras : DEFAULT_EXTRAS_KEY;\n\n  for (let index = 0; index < HELPER_COLLECTOR_CACHE.length; index += 1) {\n    const entry = HELPER_COLLECTOR_CACHE[index];\n    if (entry.detect === detectFn && entry.extras === extrasKey) {\n      return entry.collector;\n    }\n  }\n\n  const collector = createScopeCollector({\n    detectGlobalScope: detectFn,\n    additionalScopes: Array.isArray(extras) ? extras : undefined,\n  });\n\n  if (collector) {\n    HELPER_COLLECTOR_CACHE.push({ detect: detectFn, extras: extrasKey, collector });\n    return collector;\n  }\n\n  return null;\n}\n\nfunction fallbackCollectCandidateScopes(primary, baseScope) {\n  const resolvedBaseScope = baseScope || fallbackDetectGlobalScope();\n  const extras = resolveExtrasForBaseScope(resolvedBaseScope);\n  const collector = resolveHelperCollector(fallbackDetectGlobalScope, extras);\n  if (collector) {\n    return collector(primary || resolvedBaseScope);\n  }\n\n  const scopes = [];\n\n  function pushScope(scope) {\n    if (!scope || (typeof scope !== 'object' && typeof scope !== 'function')) {\n      return;\n    }\n    if (scopes.indexOf(scope) === -1) {\n      scopes.push(scope);\n    }\n  }\n\n  pushScope(primary || resolvedBaseScope);\n  if (typeof globalThis !== 'undefined') pushScope(globalThis);\n  if (typeof window !== 'undefined') pushScope(window);\n  if (typeof self !== 'undefined') pushScope(self);\n  if (typeof global !== 'undefined') pushScope(global);\n\n  return scopes;\n}\n\nfunction fallbackTryRequire(modulePath) {\n  // In ESM build, require is not available dynamically in the same way.\n  // We return null to fallback to global resolution.\n  return null;\n}\n\nfunction fallbackDefineHiddenProperty(target, name, value) {\n  if (!target || (typeof target !== 'object' && typeof target !== 'function')) {\n    return false;\n  }\n\n  try {\n    Object.defineProperty(target, name, {\n      configurable: true,\n      enumerable: false,\n      writable: true,\n      value,\n    });\n    return true;\n  } catch (error) {\n    void error;\n  }\n\n  try {\n    target[name] = value;\n    return true;\n  } catch (assignmentError) {\n    void assignmentError;\n  }\n\n  return false;\n}\n\nfunction fallbackEnsureQueue(scope, key, baseScope) {\n  const targetScope = scope || baseScope;\n  const queueKey = typeof key === 'string' && key ? key : DEFAULT_PENDING_QUEUE_KEY;\n\n  if (!targetScope || typeof targetScope !== 'object') {\n    return null;\n  }\n\n  let queue = targetScope[queueKey];\n  if (Array.isArray(queue)) {\n    return queue;\n  }\n\n  if (!fallbackDefineHiddenProperty(targetScope, queueKey, [])) {\n    return null;\n  }\n\n  queue = targetScope[queueKey];\n  if (!Array.isArray(queue)) {\n    return null;\n  }\n\n  return queue;\n}\n\nconst BUILTIN_IMMUTABILITY = (function resolveBuiltinImmutability() {\n  const registryKey = '__cineBuiltinImmutabilityGuards__';\n  const scopes = fallbackCollectCandidateScopes(null, fallbackDetectGlobalScope());\n\n  // Require removed for ESM conversion\n\n  for (let index = 0; index < scopes.length; index += 1) {\n    const scope = scopes[index];\n    if (!scope || (typeof scope !== 'object' && typeof scope !== 'function')) {\n      continue;\n    }\n\n    try {\n      const candidate = scope[registryKey];\n      if (candidate && typeof candidate === 'object') {\n        return candidate;\n      }\n    } catch (error) {\n      void error;\n    }\n  }\n\n  return null;\n})();\n\nfunction isEthereumProviderCandidate(value) {\n  if (!value || typeof value === 'function' || (typeof value !== 'object' && typeof value !== 'function')) {\n    return false;\n  }\n\n  if (PRIMARY_SCOPE && typeof PRIMARY_SCOPE === 'object') {\n    try {\n      if (value === PRIMARY_SCOPE.ethereum) {\n        return true;\n      }\n    } catch (error) {\n      void error;\n      return true;\n    }\n  }\n\n  try {\n    if (value.isMetaMask === true) {\n      return true;\n    }\n  } catch (inspectionError) {\n    if (inspectionError && typeof inspectionError.message === 'string' && /metamask/i.test(inspectionError.message)) {\n      return true;\n    }\n  }\n\n  try {\n    if (typeof value.request === 'function' && typeof value.on === 'function') {\n      if (typeof value.removeListener === 'function' || typeof value.removeEventListener === 'function') {\n        return true;\n      }\n\n      const ctorName = value.constructor && value.constructor.name;\n      if (ctorName && /Ethereum|MetaMask|Provider/i.test(ctorName)) {\n        return true;\n      }\n    }\n  } catch (accessError) {\n    void accessError;\n    return true;\n  }\n\n  return false;\n}\n\nfunction isNodeProcessReference(value) {\n  if (!value) {\n    return false;\n  }\n\n  if (typeof process === 'undefined' || !process) {\n    return false;\n  }\n\n  if (value === process) {\n    return true;\n  }\n\n  if (typeof value === 'object') {\n    try {\n      if (value.constructor && value.constructor.name === 'process') {\n        return true;\n      }\n    } catch (processInspectionError) {\n      void processInspectionError;\n    }\n\n    if (\n      typeof value.pid === 'number' &&\n      typeof value.nextTick === 'function' &&\n      typeof value.emit === 'function' &&\n      typeof value.binding === 'function'\n    ) {\n      return true;\n    }\n  }\n\n  if (typeof value === 'function') {\n    if (\n      value === process.binding ||\n      value === process._linkedBinding ||\n      value === process.dlopen\n    ) {\n      return true;\n    }\n\n    try {\n      const functionName = value.name || '';\n      if (functionName && (functionName === 'binding' || functionName === 'dlopen')) {\n        const source = Function.prototype.toString.call(value);\n        if (source && source.indexOf('[native code]') !== -1) {\n          return true;\n        }\n      }\n    } catch (functionInspectionError) {\n      void functionInspectionError;\n    }\n  }\n\n  return false;\n}\n\nfunction shouldBypassDeepFreeze(value) {\n  if (!value || typeof value === 'function' || (typeof value !== 'object' && typeof value !== 'function')) {\n    return false;\n  }\n\n  if (isNodeProcessReference(value)) {\n    return true;\n  }\n\n  if (\n    typeof value === 'object' &&\n    value &&\n    typeof value.id === 'string' &&\n    typeof value.filename === 'string' &&\n    (typeof value.loaded === 'boolean' || Array.isArray(value.children))\n  ) {\n    return true;\n  }\n\n  if (\n    typeof process !== 'undefined' &&\n    process &&\n    process.release &&\n    process.release.name === 'node'\n  ) {\n    return true;\n  }\n\n  try {\n    if (\n      BUILTIN_IMMUTABILITY &&\n      typeof BUILTIN_IMMUTABILITY.isImmutableBuiltin === 'function' &&\n      BUILTIN_IMMUTABILITY.isImmutableBuiltin(value)\n    ) {\n      return true;\n    }\n\n    if (typeof value.pipe === 'function' && typeof value.unpipe === 'function') {\n      return true;\n    }\n\n    if (typeof value.on === 'function' && typeof value.emit === 'function') {\n      if (typeof value.write === 'function' || typeof value.read === 'function') {\n        return true;\n      }\n\n      const ctorName = value.constructor && value.constructor.name;\n      if (ctorName && /Stream|Emitter|Port/i.test(ctorName)) {\n        return true;\n      }\n    }\n\n    if (typeof Symbol !== 'undefined' && value[Symbol.toStringTag]) {\n      const tag = value[Symbol.toStringTag];\n      if (typeof tag === 'string' && /Stream|Port/i.test(tag)) {\n        return true;\n      }\n    }\n  } catch (inspectionError) {\n    void inspectionError;\n  }\n\n  return false;\n}\n\nfunction fallbackResolveSeenTracker(seen) {\n  if (seen && typeof seen.has === 'function' && typeof seen.add === 'function') {\n    return seen;\n  }\n\n  if (Array.isArray(seen)) {\n    return {\n      has(value) {\n        return seen.indexOf(value) !== -1;\n      },\n      add(value) {\n        if (seen.indexOf(value) === -1) {\n          seen.push(value);\n        }\n      },\n    };\n  }\n\n  if (typeof WeakSet === 'function') {\n    try {\n      return new WeakSet();\n    } catch (trackerError) {\n      void trackerError;\n    }\n  }\n\n  const tracked = [];\n  return {\n    has(value) {\n      return tracked.indexOf(value) !== -1;\n    },\n    add(value) {\n      if (tracked.indexOf(value) === -1) {\n        tracked.push(value);\n      }\n    },\n  };\n}\n\nfunction fallbackFreezeDeep(value, seen) {\n  if (!value || typeof value === 'function' || (typeof value !== 'object' && typeof value !== 'function')) {\n    return value;\n  }\n\n  if (shouldBypassDeepFreeze(value) || isEthereumProviderCandidate(value)) {\n    return value;\n  }\n\n  if (typeof value === 'function') {\n    try {\n      return Object.freeze(value);\n    } catch (freezeError) {\n      void freezeError;\n      return value;\n    }\n  }\n\n  const tracker = fallbackResolveSeenTracker(seen);\n\n  if (tracker.has(value)) {\n    return value;\n  }\n\n  tracker.add(value);\n\n  let keys;\n  try {\n    keys = Object.getOwnPropertyNames(value);\n  } catch (error) {\n    void error;\n    return value;\n  }\n  for (let index = 0; index < keys.length; index += 1) {\n    const key = keys[index];\n\n    let descriptor;\n    try {\n      descriptor = Object.getOwnPropertyDescriptor(value, key);\n    } catch (descriptorError) {\n      void descriptorError;\n      descriptor = null;\n    }\n\n    if (\n      descriptor &&\n      (typeof descriptor.get === 'function' || typeof descriptor.set === 'function')\n    ) {\n      continue;\n    }\n\n    let child;\n    try {\n      child = value[key];\n    } catch (accessError) {\n      void accessError;\n      child = undefined;\n    }\n    if (!child || typeof child === 'function' || (typeof child !== 'object' && typeof child !== 'function')) {\n      continue;\n    }\n\n    if (shouldBypassDeepFreeze(child) || isEthereumProviderCandidate(child)) {\n      continue;\n    }\n\n    fallbackFreezeDeep(child, tracker);\n  }\n\n  try {\n    return Object.freeze(value);\n  } catch (freezeError) {\n    void freezeError;\n    return value;\n  }\n}\n\nfunction fallbackSafeWarn(message, detail) {\n  if (typeof console === 'undefined' || typeof console.warn !== 'function') {\n    return;\n  }\n\n  try {\n    if (typeof detail === 'undefined') {\n      console.warn(message);\n    } else {\n      console.warn(message, detail);\n    }\n  } catch (error) {\n    void error;\n  }\n}\n\nfunction fallbackResolveModuleRegistry(scope, baseScope) {\n  const targetScope = scope || baseScope;\n\n  const required = fallbackTryRequire('./registry.js');\n  if (required && typeof required === 'object') {\n    return required;\n  }\n\n  const scopes = fallbackCollectCandidateScopes(targetScope, baseScope);\n  for (let index = 0; index < scopes.length; index += 1) {\n    const candidate = scopes[index];\n    if (candidate && typeof candidate.cineModules === 'object') {\n      return candidate.cineModules;\n    }\n  }\n\n  return null;\n}\n\nfunction fallbackQueueModuleRegistration(scope, name, api, options, baseScope) {\n  const targetScope = scope || baseScope;\n  const queue = fallbackEnsureQueue(targetScope, DEFAULT_PENDING_QUEUE_KEY, baseScope);\n  if (!queue) {\n    return false;\n  }\n\n  const payload = Object.freeze({\n    name,\n    api,\n    options: Object.freeze({ ...(options || {}) }),\n  });\n\n  try {\n    queue.push(payload);\n    return true;\n  } catch (error) {\n    void error;\n  }\n\n  try {\n    queue[queue.length] = payload;\n    return true;\n  } catch (assignmentError) {\n    void assignmentError;\n  }\n\n  return false;\n}\n\nfunction createFallbackKernel(primaryScope) {\n  const baseScope = primaryScope || fallbackDetectGlobalScope();\n\n  return {\n    detectGlobalScope: fallbackDetectGlobalScope,\n    getGlobalScope() {\n      return baseScope;\n    },\n    collectCandidateScopes(primary) {\n      return fallbackCollectCandidateScopes(primary || baseScope, baseScope);\n    },\n    tryRequire: fallbackTryRequire,\n    defineHiddenProperty: fallbackDefineHiddenProperty,\n    ensureQueue(scope, key) {\n      return fallbackEnsureQueue(scope || baseScope, key, baseScope);\n    },\n    freezeDeep: fallbackFreezeDeep,\n    safeWarn: fallbackSafeWarn,\n    resolveModuleRegistry(scope) {\n      return fallbackResolveModuleRegistry(scope || baseScope, baseScope);\n    },\n    queueModuleRegistration(scope, name, api, options) {\n      return fallbackQueueModuleRegistration(scope || baseScope, name, api, options, baseScope);\n    },\n    getPendingQueueKey() {\n      return DEFAULT_PENDING_QUEUE_KEY;\n    },\n  };\n}\n\nfunction resolveArchitectureKernel(scope) {\n  const targetScope = scope || fallbackDetectGlobalScope();\n\n  // Require removed for ESM conversion\n\n  if (targetScope && typeof targetScope.cineModuleArchitectureKernel === 'object') {\n    return targetScope.cineModuleArchitectureKernel;\n  }\n\n  return null;\n}\n\nconst LOCAL_SCOPE = fallbackDetectGlobalScope();\ninstallSafeConsoleGuards(LOCAL_SCOPE);\nconst RESOLVED_KERNEL = resolveArchitectureKernel(LOCAL_SCOPE);\nconst ACTIVE_KERNEL = RESOLVED_KERNEL || createFallbackKernel(LOCAL_SCOPE);\n\nfunction detectGlobalScope() {\n  if (ACTIVE_KERNEL && typeof ACTIVE_KERNEL.detectGlobalScope === 'function') {\n    try {\n      const detected = ACTIVE_KERNEL.detectGlobalScope();\n      if (detected) {\n        return detected;\n      }\n    } catch (error) {\n      void error;\n    }\n  }\n  return fallbackDetectGlobalScope();\n}\n\nconst PRIMARY_SCOPE =\n  ACTIVE_KERNEL && typeof ACTIVE_KERNEL.getGlobalScope === 'function'\n    ? (function resolvePrimaryScope() {\n      try {\n        const scoped = ACTIVE_KERNEL.getGlobalScope();\n        if (scoped) {\n          return scoped;\n        }\n      } catch (error) {\n        void error;\n      }\n      return detectGlobalScope();\n    })()\n    : detectGlobalScope();\n\nconst PENDING_QUEUE_KEY =\n  ACTIVE_KERNEL && typeof ACTIVE_KERNEL.getPendingQueueKey === 'function'\n    ? ACTIVE_KERNEL.getPendingQueueKey()\n    : DEFAULT_PENDING_QUEUE_KEY;\n\nfunction collectCandidateScopes(primary) {\n  if (ACTIVE_KERNEL && typeof ACTIVE_KERNEL.collectCandidateScopes === 'function') {\n    try {\n      const collected = ACTIVE_KERNEL.collectCandidateScopes(primary || PRIMARY_SCOPE);\n      if (Array.isArray(collected) && collected.length > 0) {\n        return collected;\n      }\n    } catch (error) {\n      void error;\n    }\n  }\n  return fallbackCollectCandidateScopes(primary || PRIMARY_SCOPE, PRIMARY_SCOPE);\n}\n\nfunction baseTryRequire(modulePath) {\n  if (ACTIVE_KERNEL && typeof ACTIVE_KERNEL.tryRequire === 'function') {\n    try {\n      const result = ACTIVE_KERNEL.tryRequire(modulePath);\n      if (typeof result !== 'undefined') {\n        return result;\n      }\n    } catch (error) {\n      void error;\n    }\n  }\n\n  return fallbackTryRequire(modulePath);\n}\n\nfunction baseResolveModuleRegistry(scope) {\n  const targetScope = scope || PRIMARY_SCOPE;\n\n  if (ACTIVE_KERNEL && typeof ACTIVE_KERNEL.resolveModuleRegistry === 'function') {\n    try {\n      const resolved = ACTIVE_KERNEL.resolveModuleRegistry(targetScope);\n      if (resolved && typeof resolved === 'object') {\n        return resolved;\n      }\n    } catch (error) {\n      void error;\n    }\n  }\n\n  const required = baseTryRequire('./registry.js');\n  if (required && typeof required === 'object') {\n    return required;\n  }\n\n  const scopes = collectCandidateScopes(targetScope);\n  for (let index = 0; index < scopes.length; index += 1) {\n    const candidate = scopes[index];\n    if (candidate && typeof candidate.cineModules === 'object') {\n      return candidate.cineModules;\n    }\n  }\n\n  return null;\n}\n\nlet cachedModuleRegistry = null;\nlet hasResolvedRegistry = false;\n\nfunction getModuleRegistry(scope) {\n  if (!hasResolvedRegistry || (scope && scope !== PRIMARY_SCOPE)) {\n    const resolved = baseResolveModuleRegistry(scope);\n    if (scope && scope !== PRIMARY_SCOPE) {\n      return resolved;\n    }\n    cachedModuleRegistry = resolved;\n    hasResolvedRegistry = true;\n  }\n\n  return cachedModuleRegistry;\n}\n\nfunction ensureQueue(scope) {\n  const targetScope = scope || PRIMARY_SCOPE;\n\n  if (ACTIVE_KERNEL && typeof ACTIVE_KERNEL.ensureQueue === 'function') {\n    try {\n      const queue = ACTIVE_KERNEL.ensureQueue(targetScope, PENDING_QUEUE_KEY);\n      if (Array.isArray(queue)) {\n        return queue;\n      }\n    } catch (error) {\n      void error;\n    }\n  }\n\n  return fallbackEnsureQueue(targetScope, PENDING_QUEUE_KEY, PRIMARY_SCOPE);\n}\n\nfunction queueModuleRegistration(scope, name, api, options) {\n  const targetScope = scope || PRIMARY_SCOPE;\n\n  if (ACTIVE_KERNEL && typeof ACTIVE_KERNEL.queueModuleRegistration === 'function') {\n    try {\n      if (ACTIVE_KERNEL.queueModuleRegistration(targetScope, name, api, options)) {\n        return true;\n      }\n    } catch (error) {\n      void error;\n    }\n  }\n\n  const queue = ensureQueue(targetScope);\n  if (!queue) {\n    return false;\n  }\n\n  const payload = Object.freeze({\n    name,\n    api,\n    options: Object.freeze({ ...(options || {}) }),\n  });\n\n  try {\n    queue.push(payload);\n  } catch (error) {\n    void error;\n    queue[queue.length] = payload;\n  }\n\n  return true;\n}\n\nfunction baseRegisterOrQueueModule(scope, registry, name, api, options, onError) {\n  if (registry && typeof registry.register === 'function') {\n    try {\n      registry.register(name, api, options);\n      return true;\n    } catch (error) {\n      if (typeof onError === 'function') {\n        onError(error);\n      } else {\n        void error;\n      }\n    }\n  }\n\n  queueModuleRegistration(scope, name, api, options);\n  return false;\n}\n\nfunction baseFreezeDeep(value) {\n  if (!value || typeof value === 'function' || (typeof value !== 'object' && typeof value !== 'function')) {\n    return value;\n  }\n\n  if (shouldBypassDeepFreeze(value) || isEthereumProviderCandidate(value)) {\n    return value;\n  }\n\n  if (ACTIVE_KERNEL && typeof ACTIVE_KERNEL.freezeDeep === 'function') {\n    try {\n      return ACTIVE_KERNEL.freezeDeep(value);\n    } catch (error) {\n      void error;\n    }\n  }\n\n  return fallbackFreezeDeep(value);\n}\n\nfunction baseSafeWarn(message, detail) {\n  if (ACTIVE_KERNEL && typeof ACTIVE_KERNEL.safeWarn === 'function') {\n    try {\n      ACTIVE_KERNEL.safeWarn(message, detail);\n      return;\n    } catch (error) {\n      void error;\n    }\n  }\n\n  fallbackSafeWarn(message, detail);\n}\n\nfunction exposeGlobal(name, value, scope, options = {}) {\n  const targetScope = scope || PRIMARY_SCOPE;\n  if (!targetScope || typeof targetScope !== 'object') {\n    return false;\n  }\n\n  const descriptor = {\n    configurable: options.configurable !== false,\n    enumerable: !!options.enumerable,\n    value,\n    writable: options.writable === true,\n  };\n\n  try {\n    Object.defineProperty(targetScope, name, descriptor);\n    return true;\n  } catch (error) {\n    void error;\n    try {\n      targetScope[name] = value;\n      return true;\n    } catch (assignmentError) {\n      void assignmentError;\n      return false;\n    }\n  }\n}\n\nconst baseApi = baseFreezeDeep({\n  getGlobalScope() {\n    return PRIMARY_SCOPE;\n  },\n  collectCandidateScopes,\n  tryRequire: baseTryRequire,\n  resolveModuleRegistry: baseResolveModuleRegistry,\n  getModuleRegistry,\n  queueModuleRegistration(name, api, options, scope) {\n    return queueModuleRegistration(scope || PRIMARY_SCOPE, name, api, options);\n  },\n  registerOrQueueModule(name, api, options, onError, scope, registry) {\n    const targetScope = scope || PRIMARY_SCOPE;\n    const moduleRegistry = registry || getModuleRegistry(targetScope);\n    return baseRegisterOrQueueModule(targetScope, moduleRegistry, name, api, options, onError);\n  },\n  freezeDeep: baseFreezeDeep,\n  safeWarn: baseSafeWarn,\n  exposeGlobal,\n  PENDING_QUEUE_KEY,\n});\n\nconst registry = getModuleRegistry();\nbaseRegisterOrQueueModule(\n  PRIMARY_SCOPE,\n  registry,\n  'cineModuleBase',\n  baseApi,\n  {\n    category: 'infrastructure',\n    description: 'Shared helpers for module registration, freezing and safe global exposure.',\n    replace: true,\n    connections: ['cineModuleArchitectureKernel', 'cineModuleArchitectureHelpers'],\n  },\n  (error) => {\n    baseSafeWarn('Unable to register cineModuleBase.', error);\n  },\n);\n\nexposeGlobal('cineModuleBase', baseApi, PRIMARY_SCOPE, { configurable: true, enumerable: false, writable: false });\n\nexport default baseApi;\nexport { baseApi as cineModuleBase };\n","/**\n * The registry is the shared phone book for every module that bootstraps the\n * planner. Comments throughout the file explain why we cache the lookups and\n * which safeguards keep user data utilities from being redefined by accident.\n */\nconst GLOBAL_SCOPE =\n  typeof globalThis !== 'undefined'\n    ? globalThis\n    : typeof window !== 'undefined'\n      ? window\n      : typeof self !== 'undefined'\n        ? self\n        : typeof global !== 'undefined'\n          ? global\n          : {};\n\nlet ensureConsoleMethodsWritable = null;\n\nif (\n  !ensureConsoleMethodsWritable\n  && GLOBAL_SCOPE\n  && typeof GLOBAL_SCOPE.__cineEnsureConsoleMethodsWritable === 'function'\n) {\n  ensureConsoleMethodsWritable = GLOBAL_SCOPE.__cineEnsureConsoleMethodsWritable;\n}\n\nif (typeof ensureConsoleMethodsWritable === 'function') {\n  ensureConsoleMethodsWritable(['warn', 'info']);\n}\n\nconst PENDING_QUEUE_KEY = '__cinePendingModuleRegistrations__';\nconst QUEUE_FLUSH_TIMER_KEY = '__cinePendingModuleRegistrationsTimer__';\n\nlet moduleMap = Object.create(null);\nlet metadataMap = Object.create(null);\nlet registryReference = null;\n\n/**\n * Discover the immutability helpers that freeze exported APIs. We perform the\n * same guarded probing used across the codebase so the registry works in\n * browsers, workers and tests without assuming a specific runtime.\n */\nfunction resolveImmutability(scope) {\n  const targetScope = scope || GLOBAL_SCOPE;\n\n  const scopes = [targetScope];\n  if (typeof globalThis !== 'undefined' && scopes.indexOf(globalThis) === -1) scopes.push(globalThis);\n  if (typeof window !== 'undefined' && scopes.indexOf(window) === -1) scopes.push(window);\n  if (typeof self !== 'undefined' && scopes.indexOf(self) === -1) scopes.push(self);\n  if (typeof global !== 'undefined' && scopes.indexOf(global) === -1) scopes.push(global);\n\n  for (let index = 0; index < scopes.length; index += 1) {\n    const candidate = scopes[index];\n    if (candidate && typeof candidate.cineModuleImmutability === 'object') {\n      return candidate.cineModuleImmutability;\n    }\n  }\n\n  return null;\n}\n\nconst BUILTIN_IMMUTABILITY = (function resolveBuiltinImmutability() {\n  // Built-in guards are cached on the global scope because they are reused by\n  // multiple modules. Documenting this avoids confusion when debugging deep\n  // freeze issues across different bundles.\n  const registryKey = '__cineBuiltinImmutabilityGuards__';\n  const scopes = [GLOBAL_SCOPE];\n  if (typeof globalThis !== 'undefined' && globalThis !== GLOBAL_SCOPE) scopes.push(globalThis);\n  if (typeof window !== 'undefined') scopes.push(window);\n  if (typeof self !== 'undefined') scopes.push(self);\n  if (typeof global !== 'undefined') scopes.push(global);\n\n  for (let index = 0; index < scopes.length; index += 1) {\n    const scope = scopes[index];\n    if (!scope || (typeof scope !== 'object' && typeof scope !== 'function')) {\n      continue;\n    }\n\n    try {\n      const candidate = scope[registryKey];\n      if (candidate && typeof candidate === 'object') {\n        return candidate;\n      }\n    } catch (error) {\n      void error;\n    }\n  }\n\n  return null;\n})();\n\nfunction createFallbackImmutability() {\n  // The fallback freeze logic imitates the helper shipped with the modern\n  // runtime. extensive inline comments make it clear why certain objects such\n  // as streams are excluded from freezing: mutating them is necessary for\n  // Node-based tooling and does not impact project persistence.\n  function shouldBypass(value) {\n    if (!value || typeof value === 'function' || (typeof value !== 'object' && typeof value !== 'function')) {\n      return false;\n    }\n\n    try {\n      if (\n        BUILTIN_IMMUTABILITY &&\n        typeof BUILTIN_IMMUTABILITY.isImmutableBuiltin === 'function' &&\n        BUILTIN_IMMUTABILITY.isImmutableBuiltin(value)\n      ) {\n        return true;\n      }\n\n      if (typeof value.pipe === 'function' && typeof value.unpipe === 'function') {\n        return true;\n      }\n\n      if (typeof value.on === 'function' && typeof value.emit === 'function') {\n        if (typeof value.write === 'function' || typeof value.read === 'function') {\n          return true;\n        }\n\n        const ctorName = value.constructor && value.constructor.name;\n        if (ctorName && /Stream|Emitter|Port/i.test(ctorName)) {\n          return true;\n        }\n      }\n\n      if (typeof Symbol !== 'undefined' && value[Symbol.toStringTag]) {\n        const tag = value[Symbol.toStringTag];\n        if (typeof tag === 'string' && /Stream|Port/i.test(tag)) {\n          return true;\n        }\n      }\n    } catch (inspectionError) {\n      void inspectionError;\n    }\n\n    return false;\n  }\n\n  function freeze(value, seen = new WeakSet()) {\n    if (!value || typeof value === 'function' || (typeof value !== 'object' && typeof value !== 'function')) {\n      return value;\n    }\n\n    if (shouldBypass(value)) {\n      return value;\n    }\n\n    if (seen.has(value)) {\n      return value;\n    }\n\n    seen.add(value);\n\n    const keys = Object.getOwnPropertyNames(value);\n    for (let index = 0; index < keys.length; index += 1) {\n      const key = keys[index];\n      let child;\n      try {\n        child = value[key];\n      } catch (accessError) {\n        void accessError;\n        child = undefined;\n      }\n      if (!child || typeof child === 'function' || (typeof child !== 'object' && typeof child !== 'function')) {\n        continue;\n      }\n      freeze(child, seen);\n    }\n\n    try {\n      return Object.freeze(value);\n    } catch (freezeError) {\n      void freezeError;\n      return value;\n    }\n  }\n\n  return {\n    shouldBypassDeepFreeze: shouldBypass,\n    freezeDeep: freeze,\n  };\n}\n\nconst FALLBACK_IMMUTABILITY = createFallbackImmutability();\nlet activeImmutability = resolveImmutability(GLOBAL_SCOPE) || FALLBACK_IMMUTABILITY;\n\nfunction getImmutability() {\n  if (activeImmutability !== FALLBACK_IMMUTABILITY) {\n    return activeImmutability;\n  }\n\n  const resolved = resolveImmutability(GLOBAL_SCOPE);\n  if (resolved && resolved !== activeImmutability) {\n    activeImmutability = resolved;\n  }\n\n  return activeImmutability;\n}\n\nfunction freezeDeep(value, seen) {\n  const provider = getImmutability();\n\n  try {\n    return provider.freezeDeep(value, seen);\n  } catch (error) {\n    void error;\n  }\n\n  return FALLBACK_IMMUTABILITY.freezeDeep(value, seen);\n}\n\nfunction normalizeName(name) {\n  if (typeof name === 'string') {\n    const trimmed = name.trim();\n    if (trimmed) {\n      return trimmed;\n    }\n  }\n  throw new TypeError('cineModules.register expected a non-empty string name.');\n}\n\nfunction normalizeConnections(value) {\n  if (value == null) {\n    return [];\n  }\n\n  const entries = Array.isArray(value)\n    ? value\n    : typeof value === 'string'\n      ? [value]\n      : typeof value[Symbol.iterator] === 'function'\n        ? Array.from(value)\n        : [value];\n\n  const seen = new Set();\n  const normalized = [];\n\n  for (let index = 0; index < entries.length; index += 1) {\n    const entry = entries[index];\n    let raw = null;\n\n    if (typeof entry === 'string') {\n      raw = entry;\n    } else if (entry && typeof entry.name === 'string') {\n      raw = entry.name;\n    }\n\n    if (!raw) {\n      continue;\n    }\n\n    const trimmed = raw.trim();\n    if (!trimmed || seen.has(trimmed)) {\n      continue;\n    }\n\n    seen.add(trimmed);\n    normalized.push(trimmed);\n  }\n\n  return normalized;\n}\n\n\n/**\n * Register a Module\n *\n * Publishes a module API to the central registry, making it available to `get()` callers.\n *\n * Mechanisms:\n * 1. NORMALIZATION: \"My Module \" becomes \"My Module\".\n * 2. IMMUTABILITY: By default, the API object is Deep Frozen to prevent other modules from accidentally mutating it.\n * 3. CONFLICT CHECK: Throws if a module with the same name exists (unless `replace: true` is specified), ensuring consistency.\n * 4. METADATA: Stores descriptive metadata (category, description, connections) separately from the runtime logic.\n *\n * @param {string} name - Unique identifier for the module.\n * @param {object} moduleApi - The public interface of the module.\n * @param {object} [options] - Configuration (freeze, replace, description, etc).\n * @returns {object} - The (potentially frozen) module API.\n */\nfunction register(name, moduleApi, options = {}) {\n  const normalizedName = normalizeName(name);\n\n  if (!moduleApi || (typeof moduleApi !== 'object' && typeof moduleApi !== 'function')) {\n    throw new TypeError(`cineModules.register(\"${normalizedName}\") expected an object or function.`);\n  }\n\n  const freeze = options.freeze !== false;\n  const descriptor = freeze && !Object.isFrozen(moduleApi)\n    ? freezeDeep(moduleApi)\n    : moduleApi;\n\n  if (Object.prototype.hasOwnProperty.call(moduleMap, normalizedName)) {\n    const existing = moduleMap[normalizedName];\n    if (existing === descriptor) {\n      return existing;\n    }\n\n    if (!options.replace) {\n      throw new Error(`cineModules: Module \"${normalizedName}\" is already registered. Use { replace: true } to overwrite.`);\n    }\n  }\n\n  moduleMap[normalizedName] = descriptor;\n  metadataMap[normalizedName] = {\n    description: typeof options.description === 'string' ? options.description.trim() : '',\n    category: typeof options.category === 'string' ? options.category.trim() : '',\n    registeredAt: Date.now(),\n    frozen: freeze,\n    connections: freezeDeep(normalizeConnections(\n      options.connections || options.links || options.dependencies || null,\n    )),\n  };\n\n  return descriptor;\n}\n\n/**\n * Retrieve a Registered Module\n *\n * This is the primary lookup method for inter-module dependencies.\n * - It normalizes names to prevent case/whitespace confusing bugs.\n * - It is O(1) via a hash map lookup (`moduleMap`).\n * - Ideally, consumers should cache the result if used in a hot loop, though the lookup itself is fast.\n *\n * @param {string} name - The name of the module to retrieve.\n * @returns {object|null} - The module API object if found, or null.\n */\nfunction get(name) {\n  const normalizedName = normalizeName(name);\n  return Object.prototype.hasOwnProperty.call(moduleMap, normalizedName)\n    ? moduleMap[normalizedName]\n    : null;\n}\n\nfunction has(name) {\n  const normalizedName = normalizeName(name);\n  return Object.prototype.hasOwnProperty.call(moduleMap, normalizedName);\n}\n\nfunction list() {\n  return Object.freeze(Object.keys(moduleMap).sort());\n}\n\nfunction describe(name) {\n  const normalizedName = normalizeName(name);\n  const meta = metadataMap[normalizedName];\n  if (!meta) {\n    return null;\n  }\n  return Object.freeze({\n    name: normalizedName,\n    description: meta.description,\n    category: meta.category,\n    registeredAt: meta.registeredAt,\n    frozen: meta.frozen,\n    connections: meta.connections || freezeDeep([]),\n  });\n}\n\nfunction normalizeNameCollection(value) {\n  if (value == null) {\n    return null;\n  }\n\n  const entries = Array.isArray(value)\n    ? value\n    : typeof value === 'string'\n      ? [value]\n      : typeof value[Symbol.iterator] === 'function'\n        ? Array.from(value)\n        : [value];\n\n  const normalized = [];\n  const seen = new Set();\n\n  for (let index = 0; index < entries.length; index += 1) {\n    const entry = entries[index];\n\n    try {\n      const normalizedName = normalizeName(entry);\n      if (!seen.has(normalizedName)) {\n        seen.add(normalizedName);\n        normalized.push(normalizedName);\n      }\n    } catch (error) {\n      void error;\n    }\n  }\n\n  return normalized.length > 0 ? normalized : null;\n}\n\nfunction normalizeCategoryCollection(value) {\n  if (value == null) {\n    return null;\n  }\n\n  const entries = Array.isArray(value)\n    ? value\n    : typeof value === 'string'\n      ? [value]\n      : typeof value[Symbol.iterator] === 'function'\n        ? Array.from(value)\n        : [value];\n\n  const normalized = [];\n  const seen = new Set();\n\n  for (let index = 0; index < entries.length; index += 1) {\n    const entry = entries[index];\n    if (typeof entry !== 'string') {\n      continue;\n    }\n\n    const trimmed = entry.trim();\n    if (!trimmed || seen.has(trimmed)) {\n      continue;\n    }\n\n    seen.add(trimmed);\n    normalized.push(trimmed);\n  }\n\n  return normalized.length > 0 ? normalized : null;\n}\n\nfunction describeAll(options = {}) {\n  const normalizedNames = normalizeNameCollection(options && options.names);\n  const normalizedCategories = normalizeCategoryCollection(\n    options && (options.categories || options.category || null),\n  );\n\n  const namesFilter = normalizedNames ? new Set(normalizedNames) : null;\n  const categoryFilter = normalizedCategories ? new Set(normalizedCategories) : null;\n\n  const snapshot = [];\n\n  const sourceNames = namesFilter ? normalizedNames : Object.keys(metadataMap);\n\n  for (let index = 0; index < sourceNames.length; index += 1) {\n    const name = sourceNames[index];\n    const meta = metadataMap[name];\n    if (!meta) {\n      continue;\n    }\n\n    if (categoryFilter && !categoryFilter.has(meta.category)) {\n      continue;\n    }\n\n    snapshot.push({\n      name,\n      description: meta.description,\n      category: meta.category,\n      registeredAt: meta.registeredAt,\n      frozen: meta.frozen,\n      connections: meta.connections || freezeDeep([]),\n    });\n  }\n\n  if (!namesFilter) {\n    const shouldSort = !options || options.sort !== false;\n    if (shouldSort) {\n      snapshot.sort((left, right) => left.name.localeCompare(right.name));\n    }\n  }\n\n  return freezeDeep(snapshot);\n}\n\nfunction assertRegistered(names) {\n  const entries = Array.isArray(names) ? names.slice() : [names];\n  const detail = {};\n  const missing = [];\n\n  for (let index = 0; index < entries.length; index += 1) {\n    const name = normalizeName(entries[index]);\n    const present = has(name);\n    detail[name] = present;\n    if (!present) {\n      missing.push(name);\n    }\n  }\n\n  return Object.freeze({\n    ok: missing.length === 0,\n    missing: Object.freeze(missing),\n    detail: Object.freeze(detail),\n  });\n}\n\nfunction resetForTests(options = {}) {\n  const isTestEnvironment =\n    typeof process !== 'undefined' &&\n    process &&\n    process.env &&\n    process.env.NODE_ENV === 'test';\n\n  if (!isTestEnvironment) {\n    throw new Error('cineModules.__internalResetForTests() is restricted to test environments.');\n  }\n\n  if (!options || options.force !== true) {\n    throw new Error('cineModules.__internalResetForTests() requires { force: true }.');\n  }\n\n  moduleMap = Object.create(null);\n  metadataMap = Object.create(null);\n\n  // Cancel any pending flushes and plain the queue\n  const scopes = [GLOBAL_SCOPE];\n  if (typeof globalThis !== 'undefined' && globalThis !== GLOBAL_SCOPE) scopes.push(globalThis);\n  if (typeof window !== 'undefined' && scopes.indexOf(window) === -1) scopes.push(window);\n  if (typeof self !== 'undefined' && scopes.indexOf(self) === -1) scopes.push(self);\n  if (typeof global !== 'undefined' && scopes.indexOf(global) === -1) scopes.push(global);\n\n  for (const scope of scopes) {\n    if (scope) {\n      cancelPendingFlush(scope);\n      if (Array.isArray(scope[PENDING_QUEUE_KEY])) {\n        scope[PENDING_QUEUE_KEY].length = 0;\n      }\n    }\n  }\n\n  return true;\n}\n\nfunction getTimerDescriptor(scope) {\n  if (!scope || typeof scope !== 'object') {\n    return null;\n  }\n\n  const descriptor = scope[QUEUE_FLUSH_TIMER_KEY];\n  return descriptor && typeof descriptor === 'object' ? descriptor : null;\n}\n\nfunction assignHidden(scope, key, value) {\n  if (!scope || (typeof scope !== 'object' && typeof scope !== 'function')) {\n    return false;\n  }\n\n  try {\n    Object.defineProperty(scope, key, {\n      configurable: true,\n      enumerable: false,\n      writable: true,\n      value,\n    });\n    return true;\n  } catch (error) {\n    void error;\n  }\n\n  try {\n    scope[key] = value;\n    return true;\n  } catch (assignmentError) {\n    void assignmentError;\n  }\n\n  return false;\n}\n\nfunction cancelPendingFlush(scope) {\n  const descriptor = getTimerDescriptor(scope);\n  if (!descriptor) {\n    return;\n  }\n\n  const clearTimer = descriptor && typeof descriptor.clear === 'function' ? descriptor.clear : null;\n  if (clearTimer && Object.prototype.hasOwnProperty.call(descriptor, 'id')) {\n    try {\n      clearTimer(descriptor.id);\n    } catch (error) {\n      void error;\n    }\n  }\n\n  assignHidden(scope, QUEUE_FLUSH_TIMER_KEY, null);\n}\n\nfunction schedulePendingFlush(scope) {\n  if (!scope || typeof scope !== 'object') {\n    return;\n  }\n\n  const queue = scope[PENDING_QUEUE_KEY];\n  if (!Array.isArray(queue) || queue.length === 0) {\n    cancelPendingFlush(scope);\n    return;\n  }\n\n  if (getTimerDescriptor(scope)) {\n    return;\n  }\n\n  const scheduleFromScope =\n    (typeof scope.setTimeout === 'function' && scope.setTimeout.bind(scope)) ||\n    (typeof GLOBAL_SCOPE.setTimeout === 'function' && GLOBAL_SCOPE.setTimeout.bind(GLOBAL_SCOPE)) ||\n    (typeof setTimeout === 'function' ? setTimeout : null);\n\n  if (typeof scheduleFromScope !== 'function') {\n    return;\n  }\n\n  const clearFromScope =\n    (typeof scope.clearTimeout === 'function' && scope.clearTimeout.bind(scope)) ||\n    (typeof GLOBAL_SCOPE.clearTimeout === 'function' && GLOBAL_SCOPE.clearTimeout.bind(GLOBAL_SCOPE)) ||\n    (typeof clearTimeout === 'function' ? clearTimeout : null);\n\n  const timerId = scheduleFromScope(function retryFlush() {\n    cancelPendingFlush(scope);\n    flushPendingRegistrations(scope);\n  }, 0);\n\n  assignHidden(scope, QUEUE_FLUSH_TIMER_KEY, {\n    id: timerId,\n    clear: typeof clearFromScope === 'function' ? clearFromScope : null,\n  });\n}\n\nfunction flushPendingRegistrations(scope) {\n  if (!scope || typeof scope !== 'object') {\n    return;\n  }\n\n  const queue = scope[PENDING_QUEUE_KEY];\n  if (!Array.isArray(queue) || queue.length === 0) {\n    cancelPendingFlush(scope);\n    return;\n  }\n\n  const pending = queue.slice();\n  queue.length = 0;\n\n  let requiresReschedule = false;\n\n  for (let index = 0; index < pending.length; index += 1) {\n    const entry = pending[index];\n    if (!entry || typeof entry !== 'object') {\n      continue;\n    }\n\n    const name = entry.name;\n    const api = entry.api;\n    const options = entry.options || {};\n\n    try {\n      registry.register(name, api, options);\n    } catch (error) {\n      // If the module fails to register, we log a warning and discard the pending entry.\n      // Retrying blindly causes infinite loops if the error is permanent (e.g. invalid name, conflict, etc).\n      if (typeof console !== 'undefined' && typeof console.warn === 'function') {\n        console.warn(`cineModules: discard pending registration for \"${name}\" due to error:`, error);\n      }\n      continue;\n    }\n  }\n\n  if (requiresReschedule || queue.length > 0) {\n    schedulePendingFlush(scope);\n  } else {\n    cancelPendingFlush(scope);\n  }\n}\n\nfunction collectQueueScopes(preferredScope) {\n  const scopes = [];\n\n  function pushScope(candidate) {\n    if (!candidate || (typeof candidate !== 'object' && typeof candidate !== 'function')) {\n      return;\n    }\n    if (scopes.indexOf(candidate) === -1) {\n      scopes.push(candidate);\n    }\n  }\n\n  pushScope(preferredScope);\n  pushScope(GLOBAL_SCOPE);\n  if (typeof globalThis !== 'undefined') pushScope(globalThis);\n  if (typeof window !== 'undefined') pushScope(window);\n  if (typeof self !== 'undefined') pushScope(self);\n  if (typeof global !== 'undefined') pushScope(global);\n\n  return scopes;\n}\n\nfunction readQueueFromScope(scope) {\n  if (!scope || (typeof scope !== 'object' && typeof scope !== 'function')) {\n    return null;\n  }\n\n  try {\n    const queue = scope[PENDING_QUEUE_KEY];\n    return Array.isArray(queue) ? queue : null;\n  } catch (error) {\n    void error;\n    return null;\n  }\n}\n\nfunction ensureQueueOnScope(scope) {\n  if (!scope || (typeof scope !== 'object' && typeof scope !== 'function')) {\n    return null;\n  }\n\n  let queue = readQueueFromScope(scope);\n  if (queue) {\n    return queue;\n  }\n\n  if (assignHidden(scope, PENDING_QUEUE_KEY, [])) {\n    queue = readQueueFromScope(scope);\n    if (queue) {\n      return queue;\n    }\n  }\n\n  try {\n    scope[PENDING_QUEUE_KEY] = [];\n    queue = readQueueFromScope(scope);\n    if (queue) {\n      return queue;\n    }\n  } catch (error) {\n    void error;\n  }\n\n  return null;\n}\n\nfunction resolveQueueDescriptor(preferredScope) {\n  const scopes = collectQueueScopes(preferredScope);\n\n  for (let index = 0; index < scopes.length; index += 1) {\n    const candidate = scopes[index];\n    const queue = ensureQueueOnScope(candidate);\n    if (queue) {\n      return { queue, scope: candidate };\n    }\n  }\n\n  return null;\n}\n\nfunction queueRegistrationPayload(scope, payload) {\n  const descriptor = resolveQueueDescriptor(scope || GLOBAL_SCOPE);\n  if (!descriptor || !descriptor.queue) {\n    return false;\n  }\n\n  const record = freezeDeep({\n    name: payload && payload.name ? normalizeName(payload.name) : null,\n    api: payload ? payload.api : null,\n    options: Object.freeze({ ...(payload && payload.options ? payload.options : {}) }),\n  });\n\n  const { queue, scope: queueScope } = descriptor;\n\n  try {\n    queue.push(record);\n  } catch (error) {\n    void error;\n    queue[queue.length] = record;\n  }\n\n  try {\n    schedulePendingFlush(queueScope);\n  } catch (error) {\n    void error;\n  }\n\n  return true;\n}\n\nfunction createBlueprint(options = {}) {\n  const normalizedName = normalizeName(options.name);\n  const normalizedCategory = typeof options.category === 'string' ? options.category.trim() : '';\n  if (!normalizedCategory) {\n    throw new TypeError(`cineModules.createBlueprint(\"${normalizedName}\") expected a non-empty category string.`);\n  }\n\n  const normalizedDescription = typeof options.description === 'string' ? options.description.trim() : '';\n  if (!normalizedDescription) {\n    throw new TypeError(`cineModules.createBlueprint(\"${normalizedName}\") expected a non-empty description.`);\n  }\n\n  const freezeByDefault = options.freeze !== false;\n  const normalizedConnections = freezeDeep(normalizeConnections(options.connections));\n\n  const factory = typeof options.factory === 'function' ? options.factory : null;\n  const staticApi = factory ? null : options.api;\n\n  if (!factory && (!staticApi || (typeof staticApi !== 'object' && typeof staticApi !== 'function'))) {\n    throw new TypeError(\n      `cineModules.createBlueprint(\"${normalizedName}\") expected an object API or factory function.`,\n    );\n  }\n\n  const metadata = Object.freeze({\n    name: normalizedName,\n    category: normalizedCategory,\n    description: normalizedDescription,\n    connections: normalizedConnections,\n    freeze: freezeByDefault,\n  });\n\n  let cachedApi = null;\n  let instantiated = false;\n  let instantiateError = null;\n\n  function buildRegistrationOptions(overrides) {\n    const base = {\n      category: metadata.category,\n      description: metadata.description,\n      connections: metadata.connections,\n      freeze: metadata.freeze,\n    };\n\n    if (!overrides || typeof overrides !== 'object') {\n      return Object.freeze({ ...base });\n    }\n\n    const normalized = { ...base };\n\n    if (Object.prototype.hasOwnProperty.call(overrides, 'category')) {\n      const candidate = typeof overrides.category === 'string' ? overrides.category.trim() : '';\n      if (candidate) {\n        normalized.category = candidate;\n      }\n    }\n\n    if (Object.prototype.hasOwnProperty.call(overrides, 'description')) {\n      const candidate = typeof overrides.description === 'string' ? overrides.description.trim() : '';\n      if (candidate) {\n        normalized.description = candidate;\n      }\n    }\n\n    if (Object.prototype.hasOwnProperty.call(overrides, 'connections')) {\n      normalized.connections = freezeDeep(normalizeConnections(overrides.connections));\n    }\n\n    if (Object.prototype.hasOwnProperty.call(overrides, 'freeze')) {\n      normalized.freeze = overrides.freeze !== false;\n    }\n\n    return Object.freeze(normalized);\n  }\n\n  function instantiate(context) {\n    if (instantiated) {\n      if (instantiateError) {\n        throw instantiateError;\n      }\n      return cachedApi;\n    }\n\n    instantiated = true;\n\n    let produced = staticApi;\n    if (factory) {\n      const invocationContext = context && typeof context === 'object' ? { ...context } : {};\n      const frozenContext = Object.freeze({\n        registry: registryReference || null,\n        metadata,\n        context: invocationContext,\n        freezeDeep,\n        normalizeConnections,\n      });\n\n      try {\n        produced = factory(frozenContext);\n      } catch (error) {\n        instantiateError = error instanceof Error ? error : new Error(String(error));\n        throw instantiateError;\n      }\n    }\n\n    if (!produced || (typeof produced !== 'object' && typeof produced !== 'function')) {\n      const error = new TypeError(\n        `cineModules.createBlueprint(\"${normalizedName}\") factory expected an object or function return value.`,\n      );\n      instantiateError = error;\n      throw error;\n    }\n\n    cachedApi = freezeByDefault && !Object.isFrozen(produced) ? freezeDeep(produced) : produced;\n    return cachedApi;\n  }\n\n  function registerBlueprint(options = {}) {\n    const resolvedRegistry =\n      options && typeof options.registry === 'object' && options.registry\n        ? options.registry\n        : registryReference;\n\n    const registrationOptions = buildRegistrationOptions(options && options.options);\n    const scope = options && options.scope ? options.scope : GLOBAL_SCOPE;\n    const deferOnError = options && Object.prototype.hasOwnProperty.call(options, 'defer') ? options.defer !== false : true;\n    const onError = options && typeof options.onError === 'function' ? options.onError : null;\n\n    const api = instantiate(options && options.context);\n\n    const targetRegistry =\n      resolvedRegistry && typeof resolvedRegistry.register === 'function' ? resolvedRegistry : registryReference;\n\n    if (!targetRegistry || typeof targetRegistry.register !== 'function') {\n      throw new TypeError('cineModules.createBlueprint register() requires a registry with a register() function.');\n    }\n\n    try {\n      return targetRegistry.register(metadata.name, api, registrationOptions);\n    } catch (error) {\n      if (deferOnError) {\n        queueRegistrationPayload(scope, {\n          name: metadata.name,\n          api,\n          options: registrationOptions,\n        });\n      }\n\n      if (onError) {\n        try {\n          onError(error);\n        } catch (handlerError) {\n          void handlerError;\n        }\n      }\n\n      throw error;\n    }\n  }\n\n  const blueprint = {\n    name: metadata.name,\n    category: metadata.category,\n    description: metadata.description,\n    connections: metadata.connections,\n    freeze: metadata.freeze,\n    instantiate,\n    register: registerBlueprint,\n    getMetadata() {\n      return metadata;\n    },\n    createRegistrationOptions: buildRegistrationOptions,\n    toJSON() {\n      return metadata;\n    },\n  };\n\n  return Object.freeze(blueprint);\n}\n\nconst registry = {};\nregistry.register = register;\nregistry.get = get;\nregistry.has = has;\nregistry.list = list;\nregistry.describe = describe;\nregistry.describeAll = describeAll;\nregistry.assertRegistered = assertRegistered;\nregistry.createBlueprint = createBlueprint;\nregistry.__internalResetForTests = resetForTests;\n\nregistryReference = registry;\n\nconst scopes = [GLOBAL_SCOPE];\nif (typeof globalThis !== 'undefined' && globalThis !== GLOBAL_SCOPE) scopes.push(globalThis);\nif (typeof window !== 'undefined' && scopes.indexOf(window) === -1) scopes.push(window);\nif (typeof self !== 'undefined' && scopes.indexOf(self) === -1) scopes.push(self);\nif (typeof global !== 'undefined' && scopes.indexOf(global) === -1) scopes.push(global);\n\nfor (let index = 0; index < scopes.length; index += 1) {\n  const scope = scopes[index];\n  if (!scope || typeof scope !== 'object') {\n    continue;\n  }\n\n  const existing = scope.cineModules;\n  if (existing !== registry) {\n    try {\n      Object.defineProperty(scope, 'cineModules', {\n        configurable: true,\n        enumerable: false,\n        value: registry,\n        writable: true,\n      });\n    } catch (error) {\n      void error;\n      try {\n        scope.cineModules = registry;\n      } catch (assignmentError) {\n        void assignmentError;\n      }\n    }\n  }\n\n  flushPendingRegistrations(scope);\n}\n\nexport default registry;\nexport const cineModules = registry;\n","function baseDetectGlobalScope() {\n  if (typeof globalThis !== 'undefined') {\n    return globalThis;\n  }\n  if (typeof window !== 'undefined') {\n    return window;\n  }\n  if (typeof self !== 'undefined') {\n    return self;\n  }\n  if (typeof global !== 'undefined') {\n    return global;\n  }\n  return {};\n}\n\nconst FALLBACK_SCOPE = baseDetectGlobalScope();\nconst DETECT_CACHE = { value: null, time: 0 };\n\nfunction safeAssign(target, key, value) {\n  if (!target || (typeof target !== 'object' && typeof target !== 'function')) {\n    return false;\n  }\n\n  try {\n    Object.defineProperty(target, key, {\n      configurable: true,\n      enumerable: false,\n      writable: true,\n      value,\n    });\n    return true;\n  } catch (defineError) {\n    void defineError;\n  }\n\n  try {\n    target[key] = value;\n    return true;\n  } catch (assignmentError) {\n    void assignmentError;\n  }\n\n  return false;\n}\n\nexport function detectGlobalScope() {\n  if (DETECT_CACHE.value && typeof DETECT_CACHE.value === 'object') {\n    return DETECT_CACHE.value;\n  }\n\n  try {\n    const detected = baseDetectGlobalScope();\n    if (detected && (typeof detected === 'object' || typeof detected === 'function')) {\n      DETECT_CACHE.value = detected;\n      DETECT_CACHE.time = Date.now();\n      return detected;\n    }\n  } catch (detectionError) {\n    void detectionError;\n  }\n\n  return FALLBACK_SCOPE;\n}\n\nexport function collectCandidateScopes(primary, extras, detect) {\n  const seen = [];\n  const append = (scope) => {\n    if (!scope || (typeof scope !== 'object' && typeof scope !== 'function')) {\n      return;\n    }\n    if (seen.indexOf(scope) === -1) {\n      seen.push(scope);\n    }\n  };\n\n  append(primary);\n\n  const detectFn = typeof detect === 'function' ? detect : detectGlobalScope;\n\n  try {\n    append(detectFn());\n  } catch (detectError) {\n    void detectError;\n  }\n\n  if (Array.isArray(extras)) {\n    for (let index = 0; index < extras.length; index += 1) {\n      append(extras[index]);\n    }\n  }\n\n  if (typeof globalThis !== 'undefined') append(globalThis);\n  if (typeof window !== 'undefined') append(window);\n  if (typeof self !== 'undefined') append(self);\n  if (typeof global !== 'undefined') append(global);\n\n  append(FALLBACK_SCOPE);\n\n  return seen.slice();\n}\n\nexport function tryRequire(modulePath) {\n  if (typeof require !== 'function') {\n    return null;\n  }\n\n  try {\n    return require(modulePath);\n  } catch (error) {\n    void error;\n    return null;\n  }\n}\n\nexport function resolveFromScopes(propertyName, options) {\n  const settings = options || {};\n  const predicate = typeof settings.predicate === 'function' ? settings.predicate : null;\n  const scoped = Array.isArray(settings.scopes) ? settings.scopes.slice() : [];\n  const candidates = collectCandidateScopes(\n    settings.primaryScope,\n    settings.additionalScopes,\n    settings.detect\n  );\n\n  for (let index = 0; index < candidates.length; index += 1) {\n    if (scoped.indexOf(candidates[index]) === -1) {\n      scoped.push(candidates[index]);\n    }\n  }\n\n  for (let index = 0; index < scoped.length; index += 1) {\n    const scope = scoped[index];\n    if (!scope || (typeof scope !== 'object' && typeof scope !== 'function')) {\n      continue;\n    }\n\n    if (predicate) {\n      try {\n        if (predicate(scope, propertyName)) {\n          return scope;\n        }\n      } catch (predicateError) {\n        void predicateError;\n      }\n    }\n\n    try {\n      if (propertyName in scope) {\n        return scope;\n      }\n    } catch (accessError) {\n      void accessError;\n    }\n  }\n\n  return null;\n}\n\nexport function getCachedGlobalValue(key, factory) {\n  if (!key) {\n    return typeof factory === 'function' ? factory() : factory;\n  }\n\n  const scope = detectGlobalScope();\n  if (scope && typeof scope === 'object') {\n    if (Object.prototype.hasOwnProperty.call(scope, key)) {\n      return scope[key];\n    }\n\n    const value = typeof factory === 'function' ? factory() : factory;\n    if (safeAssign(scope, key, value)) {\n      try {\n        return scope[key];\n      } catch (error) {\n        void error;\n      }\n    }\n    return value;\n  }\n\n  return typeof factory === 'function' ? factory() : factory;\n}\n\nconst api = {\n  baseDetectGlobalScope, // Exported as member of API object but generic\n  detectGlobalScope,\n  collectCandidateScopes,\n  tryRequire,\n  defineHiddenProperty: safeAssign,\n  resolveFromScopes,\n  getCachedGlobalValue,\n};\n\n// Global Assignment\nconst GLOBAL_SCOPE = detectGlobalScope();\n\nif (GLOBAL_SCOPE && !GLOBAL_SCOPE.cineScopeUtils) {\n  safeAssign(GLOBAL_SCOPE, 'cineScopeUtils', api);\n}\n\nexport {\n  baseDetectGlobalScope,\n  safeAssign as defineHiddenProperty,\n  api as cineScopeUtils\n};\n","const globalScope =\n    (typeof globalThis !== 'undefined' && globalThis) ||\n    (typeof window !== 'undefined' && window) ||\n    (typeof self !== 'undefined' && self) ||\n    (typeof global !== 'undefined' && global) ||\n    {};\n\n// Use a Set for O(1) lookups when validating video output types\nconst VIDEO_OUTPUT_TYPES = new Set([\n    '3G-SDI',\n    '6G-SDI',\n    '12G-SDI',\n    'Mini BNC',\n    'HDMI',\n    'Mini HDMI',\n    'Micro HDMI',\n    'DisplayPort'\n]);\n\nconst NORMALIZED_FLAG_KEY = '__normalized';\n\n/**\n * Memoize a normalisation function for repeated lookups.\n *\n * The provided function receives both the original trimmed string and a\n * lowercase key. Results are cached to avoid recomputing normalisations for\n * the same input.\n *\n * @param {(value: string, key: string) => string} fn - Function that performs\n *   normalisation.\n * @returns {(value: string) => string} Wrapped function with memoisation and\n *   empty-string fallback for falsy inputs.\n */\nfunction memoizeNormalization(fn) {\n    const cache = new Map();\n    return value => {\n        if (!value) return '';\n        const str = String(value)\n            .replace(/[]/g, '')\n            .trim();\n        const key = str.toLowerCase();\n        if (!cache.has(key)) cache.set(key, fn(str, key));\n        return cache.get(key);\n    };\n}\n\nconst VIDEO_TYPE_PATTERNS = [\n    { needles: ['12g'], value: '12G-SDI' },\n    { needles: ['6g'], value: '6G-SDI' },\n    { needles: ['3g'], value: '3G-SDI' },\n    // Accept both \"HD-SDI\" and \"HD SDI\" spellings\n    { needles: ['hd', 'sdi'], value: '3G-SDI' },\n    { needles: ['mini', 'bnc'], value: 'Mini BNC' },\n    { needles: ['micro', 'hdmi'], value: 'Micro HDMI' },\n    { needles: ['mini', 'hdmi'], value: 'Mini HDMI' },\n    { needles: ['hdmi'], value: 'HDMI' },\n    { needles: ['displayport'], value: 'DisplayPort' },\n    { needles: ['display', 'port'], value: 'DisplayPort' },\n    { needles: ['dp'], value: 'DisplayPort' }\n];\n\nconst normalizeVideoType = memoizeNormalization((_, key) => {\n    const match = VIDEO_TYPE_PATTERNS.find(({ needles }) =>\n        needles.every(n => key.includes(n))\n    );\n    return match ? match.value : '';\n});\n\nconst FIZ_CONNECTOR_MAP = {\n    'lemo 4-pin (lbus)': 'LBUS (LEMO 4-pin)',\n    'lbus (lemo 4-pin)': 'LBUS (LEMO 4-pin)',\n    'lbus (4-pin lemo)': 'LBUS (LEMO 4-pin)',\n    'lbus (4-pin lemo for motors)': 'LBUS (LEMO 4-pin)',\n    '4-pin lemo (lbus)': 'LBUS (LEMO 4-pin)',\n    'lemo 4-pin': 'LEMO 4-pin',\n    '4-pin lemo': 'LEMO 4-pin',\n    'lemo 7-pin': 'LEMO 7-pin',\n    'lemo 7-pin 1b': 'LEMO 7-pin',\n    '7-pin lemo': 'LEMO 7-pin',\n    '7-pin lemo (lcs)': 'LEMO 7-pin (LCS)',\n    '7-pin lemo (cam)': 'LEMO 7-pin (CAM)',\n    'ext (lemo 7-pin)': 'EXT LEMO 7-pin',\n    'hirose 12pin': 'Hirose 12-pin',\n    '12-pin hirose': 'Hirose 12-pin',\n    '12pin broadcast connector': 'Hirose 12-pin',\n    'lens 12 pin': 'Hirose 12-pin',\n    'lens terminal 12-pin': 'Hirose 12-pin',\n    'lens terminal 12-pin jack': 'Hirose 12-pin',\n    'lens terminal': 'Hirose 12-pin',\n    'usb type-c': 'USB-C',\n    'usb-c': 'USB-C',\n    'usb-c (usb 3.2 / 3.1 gen 1)': 'USB-C',\n    'usb-c / gigabit ethernet (via adapter)': 'USB-C',\n    'active ef mount': 'Active EF mount',\n    'lanc (2.5mm stereo mini jack)': 'LANC',\n    '2.5 mm sub-mini (lanc)': 'LANC',\n    'remote a (2.5mm)': 'REMOTE A connector',\n    'remote control terminal': 'REMOTE A connector',\n    'remote 8 pin': 'REMOTE B connector'\n};\n\nfunction createMapNormalizer(map) {\n    return memoizeNormalization((str, key) => map[key] || str);\n}\n\nconst normalizeFizConnectorType = createMapNormalizer(FIZ_CONNECTOR_MAP);\n\nconst VIEWFINDER_TYPE_MAP = {\n    'dsmc3 red touch 7\" lcd (optional)': 'RED Touch 7\" LCD (Optional)',\n    'red touch 7.0\" lcd (optional)': 'RED Touch 7\" LCD (Optional)',\n    'lcd touch panel': 'LCD touchscreen',\n    'lcd touchscreen': 'LCD touchscreen',\n    'native lcd capacitive touchscreen': 'LCD touchscreen',\n    'integrated touchscreen lcd': 'LCD touchscreen',\n    'free-angle lcd': 'Vari-angle LCD',\n    'lcd monitor (native)': 'Integrated LCD monitor',\n    'native lcd viewfinder': 'Integrated LCD monitor',\n    'lcd monitor lm-v2 (supplied)': 'LCD Monitor LM-V2',\n    'integrated main monitor': 'Integrated LCD monitor',\n    'optional evf-v70 viewfinder': 'EVF-V70 (Optional)',\n    'optional evf-v50': 'EVF-V50 (Optional)',\n    'optional oled viewfinder': 'OLED EVF (Optional)',\n    'blackmagic pocket cinema camera pro evf (optional)': 'Blackmagic Pro EVF (Optional)',\n    'external backlit lcd status display': 'LCD status display',\n    'built-in fold-out lcd': 'Fold-out LCD',\n    'oled lvf (live view finder)': 'OLED EVF',\n    'lcd capacitive touchscreen': 'LCD touchscreen',\n    'lemo 26 pin': 'LEMO 26-pin port'\n};\n\nconst normalizeViewfinderType = createMapNormalizer(VIEWFINDER_TYPE_MAP);\n\nconst POWER_PORT_TYPE_MAP = {\n    'lemo 8-pin (dc in / bat)': 'Bat LEMO 8-pin',\n    'lemo 8-pin (bat)': 'Bat LEMO 8-pin',\n    'bat (lemo 8-pin)': 'Bat LEMO 8-pin',\n    'lemo 8-pin': 'Bat LEMO 8-pin',\n    '2-pin dc-input': '2-pin DC-IN',\n    'dc-': 'DC IN',\n    'dc': 'DC IN',\n    '2-pin xlr': 'XLR 2-pin',\n    '2-pin locking connector': 'LEMO 2-pin',\n    '2-pin locking connector / 2-pin lemo': 'LEMO 2-pin',\n    '4-pin xlr / dc in 12v': 'XLR 4-pin',\n    '4-pin xlr / v-lock': 'XLR 4-pin',\n    'xlr 4-pin jack': 'XLR 4-pin',\n    'xlr 4-pin (main input)': 'XLR 4-pin',\n    'xlr-type 4 pin (male) / square-shaped 5 pin connector (battery)': 'XLR 4-pin / Square 5-pin',\n    '12-pin molex connector (at battery plate rear) / 4-pin xlr (external power)': 'Molex 12-pin / XLR 4-pin',\n    'battery slot': 'Battery Slot',\n    'usb-c': 'USB-C',\n    'usb type-c': 'USB-C',\n    'usb-c pd': 'USB-C PD',\n    'usb-c (power delivery)': 'USB-C PD',\n    'usb-c pd,dc coupler': 'USB-C PD / DC Coupler',\n    'dc coupler': 'DC Coupler',\n    'dc coupler (dr-e6c)': 'DC Coupler',\n    'dc input': 'DC IN',\n    'dc barrel': 'DC Barrel',\n    'dc (barrel)': 'DC Barrel',\n    'locking dc barrel': 'DC Barrel',\n    'dc 24v terminal': 'DC Barrel',\n    'weipu sf610/s2 (12vdc) input': 'Weipu SF610/S2',\n    '6-pin 1b dc-in / tb50 battery mount': '6-pin 1B DC-IN',\n    '6-pin 1b dc-,tb50': '6-pin 1B DC-IN'\n};\n\nconst mapPowerPortOne = createMapNormalizer(POWER_PORT_TYPE_MAP);\n\nfunction normalizePowerPortType(type) {\n    if (!type) return [];\n    const toArray = val => {\n        const normalized = mapPowerPortOne(val);\n        if (!normalized) return [];\n        return normalized\n            .split(/[/,]/)\n            .map(piece => mapPowerPortOne(piece.trim()))\n            .map(piece => (piece && piece.trim()) || '')\n            .filter(Boolean);\n    };\n    return Array.isArray(type) ? type.flatMap(toArray) : toArray(type);\n}\n\nfunction ensureList(list, defaults) {\n    if (!Array.isArray(list)) return [];\n    return list.map(item =>\n        typeof item === 'string'\n            ? { ...defaults, type: item }\n            : { ...defaults, ...(item || {}) }\n    );\n}\n\nfunction fixPowerInput(dev) {\n    if (!dev) return;\n    if (dev.powerInput && !dev.power?.input) {\n        dev.power = { ...(dev.power || {}), input: { type: normalizePowerPortType(dev.powerInput) } };\n        delete dev.powerInput;\n    }\n    const input = dev.power?.input;\n    if (!input) return;\n    const normalizeEntry = it => {\n        if (typeof it === 'string') {\n            return { type: normalizePowerPortType(it) };\n        }\n        if (it) {\n            const { portType: pType, type: tType, ...rest } = it;\n            const typeField = (!tType && pType) ? pType : tType;\n            return { ...rest, type: typeField ? normalizePowerPortType(typeField) : [] };\n        }\n        return { type: [] };\n    };\n    dev.power.input = Array.isArray(input) ? input.map(normalizeEntry) : normalizeEntry(input);\n}\n\nfunction applyFixPowerInput(collection) {\n    if (!collection || typeof collection !== 'object') return;\n    Object.values(collection).forEach(fixPowerInput);\n}\n\n\nfunction hasNormalizedDevicesMarker(bundle) {\n    return Boolean(\n        bundle &&\n        Object.prototype.hasOwnProperty.call(bundle, NORMALIZED_FLAG_KEY) &&\n        bundle[NORMALIZED_FLAG_KEY]\n    );\n}\n\nfunction markDevicesNormalized(bundle) {\n    if (!bundle || typeof bundle !== 'object') {\n        return bundle;\n    }\n    try {\n        Object.defineProperty(bundle, NORMALIZED_FLAG_KEY, {\n            configurable: true,\n            enumerable: false,\n            value: true,\n            writable: true\n        });\n    } catch (defineNormalizedError) {\n        void defineNormalizedError;\n        bundle[NORMALIZED_FLAG_KEY] = true;\n    }\n    return bundle;\n}\n\n\n// Normalize various camera properties so downstream logic works with\n// consistent structures and value formats.\nfunction unifyDevices(devicesData, options) {\n    if (!devicesData || typeof devicesData !== 'object') return devicesData;\n    const force = Boolean(options && options.force);\n    if (!force && hasNormalizedDevicesMarker(devicesData)) {\n        return devicesData;\n    }\n    Object.values(devicesData.cameras || {}).forEach(cam => {\n        if (cam.power?.input && cam.power.input.powerDrawWatts !== undefined) {\n            delete cam.power.input.powerDrawWatts;\n        }\n        fixPowerInput(cam);\n        if (Array.isArray(cam.power?.batteryPlateSupport)) {\n            cam.power.batteryPlateSupport = cam.power.batteryPlateSupport.map(it => {\n                if (typeof it === 'string') {\n                    const m = it.match(/([^()]+)(?:\\(([^)]+)\\))?(?:\\s*-\\s*(.*))?/);\n                    const type = m ? m[1].trim() : it;\n                    let mount = m && m[2] ? m[2].trim().toLowerCase() : '';\n                    if (!mount) {\n                        mount = /adapted|via adapter/i.test(it) ? 'adapted' : 'native';\n                    } else if (/via adapter/i.test(mount)) {\n                        mount = 'adapted';\n                    }\n                    const notes = m && m[3] ? m[3].trim() : (/via adapter/i.test(it) ? 'via adapter' : '');\n                    return { type, mount, notes };\n                }\n                return {\n                    type: it.type || '',\n                    mount: (it.mount ? it.mount : (it.native ? 'native' : (it.adapted ? 'adapted' : 'native'))).toLowerCase(),\n                    notes: it.notes || ''\n                };\n            });\n        }\n        if (cam.power) {\n            cam.power.powerDistributionOutputs = ensureList(cam.power.powerDistributionOutputs, {\n                type: '',\n                voltage: '',\n                current: '',\n                wattage: null,\n                notes: ''\n            });\n        }\n        cam.videoOutputs = ensureList(cam.videoOutputs, { type: '', notes: '' }).flatMap(vo => {\n            const { count, ...rest } = vo || {};\n            const norm = normalizeVideoType(rest.type);\n            if (!VIDEO_OUTPUT_TYPES.has(norm)) return [];\n            const parsedCount = parseInt(count, 10);\n            const num = Number.isFinite(parsedCount) && parsedCount > 0 ? parsedCount : 1;\n            const base = { ...rest, type: norm, notes: rest.notes || '' };\n            return Array.from({ length: num }, () => ({ ...base }));\n        });\n        cam.fizConnectors = ensureList(cam.fizConnectors, { type: '', notes: '' }).map(fc => {\n            const { type, ...rest } = fc || {};\n            return { ...rest, type: normalizeFizConnectorType(type) };\n        });\n        cam.viewfinder = ensureList(cam.viewfinder, { type: '', resolution: '', connector: '', notes: '' }).map(vf => {\n            const { type, ...rest } = vf || {};\n            return {\n                ...rest,\n                type: normalizeViewfinderType(type)\n            };\n        });\n        cam.recordingMedia = ensureList(cam.recordingMedia, { type: '', notes: '' }).map(m => {\n            let { type = '', notes = '' } = m || {};\n            const match = type.match(/^(.*?)(?:\\((.*)\\))?$/);\n            if (match) {\n                type = match[1].trim();\n                notes = notes || (match[2] ? match[2].trim() : '');\n            }\n            if (/^SD UHS-II$/i.test(type)) {\n                type = 'SD Card';\n                notes = notes ? `${notes}; UHS-II` : 'UHS-II';\n            } else if (/^SD \\(UHS-II\\/UHS-I\\)$/i.test(type)) {\n                type = 'SD Card';\n                notes = 'UHS-II/UHS-I';\n            } else if (type === 'CFast 2.0 card slots') {\n                type = 'CFast 2.0';\n                notes = notes || 'Dual Slots';\n            } else if (type === 'CFexpress Type B (Dual Slots)') {\n                type = 'CFexpress Type B';\n                notes = notes || 'Dual Slots';\n            } else if (type === 'CFexpress Type B (via adapter)') {\n                type = 'CFexpress Type B';\n                notes = notes || 'via adapter';\n            } else if (/^SD UHS-II \\(Dual Slots\\)$/i.test(type)) {\n                type = 'SD Card';\n                notes = notes ? `${notes}; UHS-II (Dual Slots)` : 'UHS-II (Dual Slots)';\n            } else if (type === 'SD Card (Dual Slots)') {\n                type = 'SD Card';\n                notes = notes || 'Dual Slots';\n            } else if (type === 'SD card slot (for proxy/backup)') {\n                type = 'SD Card';\n                notes = notes || 'for proxy/backup';\n            }\n            return { type, notes };\n        });\n        cam.timecode = ensureList(cam.timecode, { type: '', notes: '' });\n        cam.lensMount = ensureList(cam.lensMount, { type: '', mount: 'native', notes: '' })\n            .map(lm => ({\n                type: lm.type,\n                mount: (lm.mount ? lm.mount.toLowerCase() : 'native'),\n                notes: lm.notes || ''\n            }))\n            .filter((lm, idx, arr) =>\n                idx === arr.findIndex(o => o.type === lm.type && o.mount === lm.mount && o.notes === lm.notes)\n            );\n    });\n\n    Object.values(devicesData.lenses || {}).forEach(lens => {\n        if (!lens || typeof lens !== 'object') return;\n        const normalizeMountEntry = (entry) => {\n            if (!entry) return null;\n            if (typeof entry === 'string') {\n                const trimmed = entry.trim();\n                if (!trimmed) return null;\n                return { type: trimmed, mount: 'native' };\n            }\n            const type = typeof entry.type === 'string' ? entry.type.trim() : '';\n            if (!type) return null;\n            const status = typeof entry.mount === 'string' ? entry.mount.trim().toLowerCase() : '';\n            return { type, mount: status === 'adapted' ? 'adapted' : 'native' };\n        };\n\n        const existingMountOptions = lens.mountOptions;\n        const normalizedOptions = [];\n\n        const pushNormalizedEntry = (entry) => {\n            const normalized = normalizeMountEntry(entry);\n            if (normalized) {\n                normalizedOptions.push(normalized);\n            }\n        };\n\n        if (Array.isArray(existingMountOptions)) {\n            existingMountOptions.forEach(pushNormalizedEntry);\n        } else if (existingMountOptions && typeof existingMountOptions === 'object') {\n            pushNormalizedEntry(existingMountOptions);\n        }\n\n        if (!normalizedOptions.length && Array.isArray(lens.lensMount)) {\n            lens.lensMount.forEach(pushNormalizedEntry);\n            delete lens.lensMount;\n        }\n\n        if (!normalizedOptions.length) {\n            const mountType = typeof lens.mount === 'string' ? lens.mount.trim() : '';\n            if (mountType) {\n                pushNormalizedEntry({ type: mountType, mount: 'native' });\n            }\n        }\n\n        const dedupedOptions = [];\n        normalizedOptions.forEach(opt => {\n            if (!opt || !opt.type) return;\n            const mountState = opt.mount === 'adapted' ? 'adapted' : 'native';\n            const alreadyPresent = dedupedOptions.some(existing => (\n                existing.type === opt.type && existing.mount === mountState\n            ));\n            if (!alreadyPresent) {\n                dedupedOptions.push({ type: opt.type, mount: mountState });\n            }\n        });\n\n        const safeMountOptions = Array.isArray(dedupedOptions) ? dedupedOptions : [];\n        lens.mountOptions = safeMountOptions;\n\n        const mountOptions = Array.isArray(lens.mountOptions) ? lens.mountOptions : [];\n\n        if (mountOptions.length) {\n            const primary = mountOptions.find(opt => opt && opt.mount === 'native' && opt.type)\n                || mountOptions[0];\n            const primaryType = primary && primary.type ? primary.type : '';\n            if (primaryType) {\n                lens.mount = primaryType;\n            } else if (typeof lens.mount === 'string') {\n                lens.mount = lens.mount.trim();\n            }\n        } else if (typeof lens.mount === 'string') {\n            lens.mount = lens.mount.trim();\n            if (!lens.mount) {\n                delete lens.mount;\n            }\n        }\n    });\n\n    ['monitors', 'video', 'viewfinders'].forEach(key => {\n        applyFixPowerInput(devicesData[key]);\n    });\n\n    const fizGroups = devicesData.fiz || {};\n    ['motors', 'controllers', 'distance'].forEach(key => {\n        applyFixPowerInput(fizGroups[key]);\n    });\n\n    // Normalize FIZ motors\n    Object.values(devicesData.fiz?.motors || {}).forEach(m => {\n        if (!m) return;\n        if (m.connector && !m.fizConnector) {\n            m.fizConnector = m.connector;\n            delete m.connector;\n        }\n        if (m.fizConnector) {\n            m.fizConnector = normalizeFizConnectorType(m.fizConnector);\n        }\n    });\n\n    // Normalize FIZ controllers\n    Object.values(devicesData.fiz?.controllers || {}).forEach(c => {\n        if (!c) return;\n        if (c.FIZ_connector && !c.fizConnector && !c.fizConnectors) {\n            c.fizConnector = c.FIZ_connector;\n            delete c.FIZ_connector;\n        }\n        if (Array.isArray(c.fizConnectors)) {\n            c.fizConnectors = c.fizConnectors.map(fc => {\n                if (!fc) return { type: '' };\n                const type = normalizeFizConnectorType(fc.type || fc);\n                const notes = fc.notes || undefined;\n                return notes ? { type, notes } : { type };\n            });\n        } else if (c.fizConnector) {\n            const parts = String(c.fizConnector)\n                .split(',')\n                .map(s => s.trim())\n                .filter(Boolean);\n            c.fizConnectors = parts.map(p => ({ type: normalizeFizConnectorType(p) }));\n            delete c.fizConnector;\n        } else {\n            c.fizConnectors = [];\n        }\n    });\n\n    markDevicesNormalized(devicesData);\n    return devicesData;\n}\n\nfunction normalizeDevicesForPersistence(devicesData) {\n    return unifyDevices(devicesData, { force: true });\n}\n\n// Expose to global scope for legacy compatibility\nglobalScope.cineDeviceNormalization = {\n    unifyDevices,\n    normalizeDevicesForPersistence,\n    markDevicesNormalized,\n    hasNormalizedDevicesMarker,\n    fixPowerInput,\n    normalizeVideoType,\n    normalizeFizConnectorType,\n    normalizeViewfinderType,\n    normalizePowerPortType,\n    ensureList\n};\n\n// Expose individual functions for backward compatibility if needed\nglobalScope.unifyDevices = unifyDevices;\nglobalScope.normalizeDevicesForPersistence = normalizeDevicesForPersistence;\nglobalScope.markDevicesNormalized = markDevicesNormalized;\n\nexport const cineDeviceNormalization = globalScope.cineDeviceNormalization;\nexport {\n    unifyDevices,\n    normalizeDevicesForPersistence,\n    markDevicesNormalized,\n    hasNormalizedDevicesMarker,\n    fixPowerInput,\n    normalizeVideoType,\n    normalizeFizConnectorType,\n    normalizeViewfinderType,\n    normalizePowerPortType,\n    ensureList\n};\n","import cineModules from './registry.js';\n// (function () {\n\nfunction fallbackDetectGlobalScope() {\n  if (typeof globalThis !== 'undefined') {\n    return globalThis;\n  }\n  if (typeof window !== 'undefined') {\n    return window;\n  }\n  if (typeof self !== 'undefined') {\n    return self;\n  }\n  if (typeof global !== 'undefined') {\n    return global;\n  }\n  return {};\n}\n\nfunction fallbackCollectCandidateScopes(primary) {\n  const scopes = [];\n\n  function pushScope(scope) {\n    if (!scope || (typeof scope !== 'object' && typeof scope !== 'function')) {\n      return;\n    }\n    if (scopes.indexOf(scope) === -1) {\n      scopes.push(scope);\n    }\n  }\n\n  pushScope(primary);\n  if (typeof globalThis !== 'undefined') pushScope(globalThis);\n  if (typeof window !== 'undefined') pushScope(window);\n  if (typeof self !== 'undefined') pushScope(self);\n  if (typeof global !== 'undefined') pushScope(global);\n\n  return scopes;\n}\n\nfunction loggingResolveStructuredClone(scope) {\n  if (typeof structuredClone === 'function') {\n    return structuredClone;\n  }\n\n  if (scope && typeof scope.structuredClone === 'function') {\n    try {\n      return scope.structuredClone.bind(scope);\n    } catch (bindError) {\n      void bindError;\n    }\n  }\n\n  /* Node require removed for ESM conversion */\n\n  return null;\n}\n\nfunction loggingJsonDeepClone(value) {\n  if (value === null || typeof value !== 'object') {\n    return value;\n  }\n\n  try {\n    return JSON.parse(JSON.stringify(value));\n  } catch (jsonCloneError) {\n    void jsonCloneError;\n  }\n\n  return value;\n}\n\n/**\n * DEEP DIVE: Structured Clone Resolution\n *\n * Secure, deep copying of complex objects (Sets, Maps, etc.) is vital for logging\n * state without mutations affecting the live app.\n *\n * Strategy:\n * 1. Try Native `structuredClone`.\n * 2. Try Node.js `util.structuredClone` (if running in tests).\n * 3. Fallback to `JSON.parse(JSON.stringify(x))` (lossy but safe).\n *\n * This singleton pattern ensures we only pay the resolution cost once at startup.\n */\nconst LOGGING_DEEP_CLONE = (function resolveLoggingDeepClone() {\n  const scope = fallbackDetectGlobalScope();\n  if (scope && typeof scope.__cineDeepClone === 'function') {\n    return scope.__cineDeepClone;\n  }\n\n  const structuredCloneImpl = loggingResolveStructuredClone(scope);\n  if (!structuredCloneImpl) {\n    return loggingJsonDeepClone;\n  }\n\n  return function loggingResilientDeepClone(value) {\n    if (value === null || typeof value !== 'object') {\n      return value;\n    }\n\n    try {\n      return structuredCloneImpl(value);\n    } catch (structuredCloneError) {\n      void structuredCloneError;\n    }\n\n    return loggingJsonDeepClone(value);\n  };\n})();\n\nfunction fallbackLoadModuleEnvironment(scope) {\n  /* Require removed */\n\n  const candidates = fallbackCollectCandidateScopes(scope);\n\n  for (let index = 0; index < candidates.length; index += 1) {\n    const candidate = candidates[index];\n    if (candidate && typeof candidate.cineModuleEnvironment === 'object') {\n      return candidate.cineModuleEnvironment;\n    }\n  }\n\n  return null;\n}\n\nfunction fallbackLoadEnvironmentBridge(scope) {\n  /* Require removed */\n\n  const candidates = fallbackCollectCandidateScopes(scope);\n\n  for (let index = 0; index < candidates.length; index += 1) {\n    const candidate = candidates[index];\n    if (candidate && typeof candidate.cineEnvironmentBridge === 'object') {\n      return candidate.cineEnvironmentBridge;\n    }\n  }\n\n  return null;\n}\n\nfunction fallbackResolveModuleGlobals(scope) {\n  /* Require removed */\n\n  const candidates = fallbackCollectCandidateScopes(scope);\n\n  for (let index = 0; index < candidates.length; index += 1) {\n    const candidate = candidates[index];\n    if (candidate && typeof candidate.cineModuleGlobals === 'object') {\n      return candidate.cineModuleGlobals;\n    }\n  }\n\n  return null;\n}\n\nfunction fallbackTryRequire(modulePath) {\n  return null;\n}\n\nconst LOCAL_SCOPE = fallbackDetectGlobalScope();\nconst MODULE_ENV = fallbackLoadModuleEnvironment(LOCAL_SCOPE);\nconst ENV_BRIDGE = fallbackLoadEnvironmentBridge(LOCAL_SCOPE);\nconst MODULE_GLOBALS = fallbackResolveModuleGlobals(LOCAL_SCOPE);\nconst GLOBAL_SCOPE =\n  (ENV_BRIDGE && typeof ENV_BRIDGE.getGlobalScope === 'function'\n    ? ENV_BRIDGE.getGlobalScope()\n    : null)\n  || (MODULE_ENV && typeof MODULE_ENV.getGlobalScope === 'function'\n    ? MODULE_ENV.getGlobalScope()\n    : null)\n  || LOCAL_SCOPE;\n\nconst tryRequire = (function resolveTryRequire() {\n  if (MODULE_GLOBALS && typeof MODULE_GLOBALS.tryRequire === 'function') {\n    return MODULE_GLOBALS.tryRequire;\n  }\n\n  if (ENV_BRIDGE && typeof ENV_BRIDGE.tryRequire === 'function') {\n    return function bridgeTryRequire(modulePath) {\n      const result = ENV_BRIDGE.tryRequire(modulePath);\n      return typeof result === 'undefined' ? fallbackTryRequire(modulePath) : result;\n    };\n  }\n\n  if (MODULE_ENV && typeof MODULE_ENV.tryRequire === 'function') {\n    return MODULE_ENV.tryRequire;\n  }\n\n  return fallbackTryRequire;\n})();\n\nconst structuredCloneCandidates = (function collectStructuredCloneCandidates() {\n  const candidates = [];\n\n  function addCandidate(fn, scope) {\n    if (typeof fn !== 'function') {\n      return;\n    }\n    const alreadyPresent = candidates.some(candidate => candidate && candidate.fn === fn);\n    if (!alreadyPresent) {\n      candidates.push({ fn, scope: scope || null });\n    }\n  }\n\n  if (MODULE_GLOBALS) {\n    if (typeof MODULE_GLOBALS.structuredClone === 'function') {\n      addCandidate(MODULE_GLOBALS.structuredClone, MODULE_GLOBALS);\n    }\n    if (typeof MODULE_GLOBALS.getStructuredClone === 'function') {\n      try {\n        const resolved = MODULE_GLOBALS.getStructuredClone();\n        addCandidate(resolved, MODULE_GLOBALS);\n      } catch (error) {\n        void error;\n      }\n    }\n  }\n\n  if (ENV_BRIDGE) {\n    if (typeof ENV_BRIDGE.structuredClone === 'function') {\n      addCandidate(ENV_BRIDGE.structuredClone, ENV_BRIDGE);\n    }\n    if (typeof ENV_BRIDGE.getStructuredClone === 'function') {\n      try {\n        const resolved = ENV_BRIDGE.getStructuredClone();\n        addCandidate(resolved, ENV_BRIDGE);\n      } catch (error) {\n        void error;\n      }\n    }\n  }\n\n  if (MODULE_ENV) {\n    if (typeof MODULE_ENV.structuredClone === 'function') {\n      addCandidate(MODULE_ENV.structuredClone, MODULE_ENV);\n    }\n    if (typeof MODULE_ENV.getStructuredClone === 'function') {\n      try {\n        const resolved = MODULE_ENV.getStructuredClone();\n        addCandidate(resolved, MODULE_ENV);\n      } catch (error) {\n        void error;\n      }\n    }\n  }\n\n  const scopes = fallbackCollectCandidateScopes(GLOBAL_SCOPE);\n  for (let index = 0; index < scopes.length; index += 1) {\n    const scope = scopes[index];\n    if (!scope || (typeof scope !== 'object' && typeof scope !== 'function')) {\n      continue;\n    }\n    const candidate = scope.structuredClone;\n    if (typeof candidate === 'function') {\n      addCandidate(candidate, scope);\n    }\n  }\n\n  return candidates;\n})();\n\nlet cachedStructuredCloneCandidate = null;\n\nfunction tryStructuredCloneValue(value) {\n  if (cachedStructuredCloneCandidate) {\n    try {\n      const candidate = cachedStructuredCloneCandidate;\n      return {\n        success: true,\n        value: candidate.scope ? candidate.fn.call(candidate.scope, value) : candidate.fn(value),\n      };\n    } catch (error) {\n      void error;\n      cachedStructuredCloneCandidate = null;\n    }\n  }\n\n  for (let index = 0; index < structuredCloneCandidates.length; index += 1) {\n    const candidate = structuredCloneCandidates[index];\n    if (!candidate || typeof candidate.fn !== 'function') {\n      continue;\n    }\n    try {\n      const cloned = candidate.scope ? candidate.fn.call(candidate.scope, value) : candidate.fn(value);\n      cachedStructuredCloneCandidate = candidate;\n      return { success: true, value: cloned };\n    } catch (error) {\n      void error;\n    }\n  }\n\n  return { success: false, value: null };\n}\n\nfunction resolveModuleRegistry(scope) {\n  if (MODULE_GLOBALS && typeof MODULE_GLOBALS.resolveModuleRegistry === 'function') {\n    try {\n      const resolved = MODULE_GLOBALS.resolveModuleRegistry(scope || GLOBAL_SCOPE);\n      if (resolved) {\n        return resolved;\n      }\n    } catch (error) {\n      void error;\n    }\n  }\n\n  if (ENV_BRIDGE && typeof ENV_BRIDGE.getModuleRegistry === 'function') {\n    try {\n      const bridged = ENV_BRIDGE.getModuleRegistry(scope || GLOBAL_SCOPE);\n      if (bridged) {\n        return bridged;\n      }\n    } catch (error) {\n      void error;\n    }\n  }\n\n  if (MODULE_ENV && typeof MODULE_ENV.resolveModuleRegistry === 'function') {\n    try {\n      return MODULE_ENV.resolveModuleRegistry(scope || GLOBAL_SCOPE);\n    } catch (error) {\n      void error;\n    }\n  }\n\n  // Use imported cineModules if available\n  if (cineModules && typeof cineModules === 'object') {\n    return cineModules;\n  }\n\n  const scopes = fallbackCollectCandidateScopes(scope || GLOBAL_SCOPE);\n\n  for (let index = 0; index < scopes.length; index += 1) {\n    const candidate = scopes[index];\n    if (candidate && typeof candidate.cineModules === 'object') {\n      return candidate.cineModules;\n    }\n  }\n\n  return null;\n}\n\nconst MODULE_REGISTRY = (function resolveRegistry() {\n  if (MODULE_GLOBALS && typeof MODULE_GLOBALS.getModuleRegistry === 'function') {\n    try {\n      const shared = MODULE_GLOBALS.getModuleRegistry(GLOBAL_SCOPE);\n      if (shared) {\n        return shared;\n      }\n    } catch (error) {\n      void error;\n    }\n  }\n\n  if (ENV_BRIDGE && typeof ENV_BRIDGE.getModuleRegistry === 'function') {\n    try {\n      const bridged = ENV_BRIDGE.getModuleRegistry(GLOBAL_SCOPE);\n      if (bridged) {\n        return bridged;\n      }\n    } catch (error) {\n      void error;\n    }\n  }\n\n  if (MODULE_ENV && typeof MODULE_ENV.getModuleRegistry === 'function') {\n    try {\n      const provided = MODULE_ENV.getModuleRegistry(GLOBAL_SCOPE);\n      if (provided) {\n        return provided;\n      }\n    } catch (error) {\n      void error;\n    }\n  }\n\n  return resolveModuleRegistry();\n})();\n\nconst queueModuleRegistration = (function resolveQueueModuleRegistration() {\n  if (MODULE_GLOBALS && typeof MODULE_GLOBALS.queueModuleRegistration === 'function') {\n    return function queueModuleRegistration(name, api, options, scope) {\n      try {\n        return MODULE_GLOBALS.queueModuleRegistration(name, api, options, scope || GLOBAL_SCOPE);\n      } catch (error) {\n        void error;\n        return false;\n      }\n    };\n  }\n\n  if (ENV_BRIDGE && typeof ENV_BRIDGE.queueModuleRegistration === 'function') {\n    return function bridgeQueueModuleRegistration(name, api, options) {\n      try {\n        const bridged = ENV_BRIDGE.queueModuleRegistration(name, api, options);\n        return typeof bridged === 'undefined' ? false : bridged;\n      } catch (error) {\n        void error;\n        return false;\n      }\n    };\n  }\n\n  if (MODULE_ENV && typeof MODULE_ENV.queueModuleRegistration === 'function') {\n    return function envQueueModuleRegistration(name, api, options, scope) {\n      try {\n        return MODULE_ENV.queueModuleRegistration(name, api, options, scope || GLOBAL_SCOPE);\n      } catch (error) {\n        void error;\n        return false;\n      }\n    };\n  }\n\n  return function fallbackQueueModuleRegistration() {\n    return false;\n  };\n})();\n\nconst registerOrQueueModule = (function resolveRegisterOrQueue() {\n  if (MODULE_GLOBALS && typeof MODULE_GLOBALS.registerOrQueueModule === 'function') {\n    return function registerOrQueueModule(name, api, options, onError, scope, registry) {\n      try {\n        const registered = MODULE_GLOBALS.registerOrQueueModule(\n          name,\n          api,\n          options,\n          onError,\n          scope || GLOBAL_SCOPE,\n          registry || MODULE_REGISTRY,\n        );\n        return typeof registered === 'undefined' ? false : registered;\n      } catch (error) {\n        void error;\n        return false;\n      }\n    };\n  }\n\n  if (ENV_BRIDGE && typeof ENV_BRIDGE.registerOrQueueModule === 'function') {\n    return function bridgeRegisterOrQueueModule(name, api, options, onError, scope, registry) {\n      try {\n        const bridged = ENV_BRIDGE.registerOrQueueModule(\n          name,\n          api,\n          options,\n          onError,\n          scope || GLOBAL_SCOPE,\n          registry || MODULE_REGISTRY,\n        );\n        return typeof bridged === 'undefined' ? false : bridged;\n      } catch (error) {\n        void error;\n        return false;\n      }\n    };\n  }\n\n  if (MODULE_ENV && typeof MODULE_ENV.registerOrQueueModule === 'function') {\n    return function envRegisterOrQueueModule(name, api, options, onError, scope, registry) {\n      try {\n        return MODULE_ENV.registerOrQueueModule(\n          name,\n          api,\n          options,\n          onError,\n          scope || GLOBAL_SCOPE,\n          registry || MODULE_REGISTRY,\n        );\n      } catch (error) {\n        void error;\n        return false;\n      }\n    };\n  }\n\n  return function fallbackRegisterOrQueueModule(name, api, options, onError) {\n    if (typeof onError === 'function') {\n      try {\n        // Attempt global registry fallback\n        if (typeof window !== 'undefined' && window.cineModuleRegistry && typeof window.cineModuleRegistry.register === 'function') {\n          window.cineModuleRegistry.register(name, api, options);\n          return true;\n        }\n        // Instead of throwing (\"onError(new Error...\"), just warn to console.\n        // Identify that we are in a fallback state but don't crash.\n        console.warn('Logging module registration deferred - queue unavailable.');\n      } catch (error) {\n        void error;\n      }\n    }\n    void name;\n    void api;\n    void options;\n    return false;\n  };\n})();\n\n\n\nfunction isNodeProcessReference(value) {\n  if (!value) {\n    return false;\n  }\n\n  if (typeof process === 'undefined' || !process) {\n    return false;\n  }\n\n  if (value === process) {\n    return true;\n  }\n\n  if (typeof value === 'object') {\n    try {\n      if (value.constructor && value.constructor.name === 'process') {\n        return true;\n      }\n    } catch (processInspectionError) {\n      void processInspectionError;\n    }\n\n    if (\n      typeof value.pid === 'number' &&\n      typeof value.nextTick === 'function' &&\n      typeof value.emit === 'function' &&\n      typeof value.binding === 'function'\n    ) {\n      return true;\n    }\n  }\n\n  if (typeof value === 'function') {\n    if (\n      value === process.binding ||\n      value === process._linkedBinding ||\n      value === process.dlopen\n    ) {\n      return true;\n    }\n\n    try {\n      const functionName = value.name || '';\n      if (functionName && (functionName === 'binding' || functionName === 'dlopen')) {\n        const source = Function.prototype.toString.call(value);\n        if (source && source.indexOf('[native code]') !== -1) {\n          return true;\n        }\n      }\n    } catch (functionInspectionError) {\n      void functionInspectionError;\n    }\n  }\n\n  return false;\n}\n\nfunction shouldBypassDeepFreeze(value) {\n  if (!value || typeof value !== 'object') {\n    return true;\n  }\n\n  if (isNodeProcessReference(value)) {\n    return true;\n  }\n\n  if (\n    typeof process !== 'undefined' &&\n    process &&\n    process.release &&\n    process.release.name === 'node'\n  ) {\n    return true;\n  }\n\n\n  const ctor = value.constructor;\n  if (!ctor) {\n    return false;\n  }\n\n  if (\n    ctor === Number\n    || ctor === String\n    || ctor === Boolean\n    || ctor === Date\n    || ctor === RegExp\n    || ctor === Promise\n    || ctor === WeakMap\n    || ctor === WeakSet\n    || ctor === Map\n    || ctor === Set\n  ) {\n    return true;\n  }\n\n  const ctorName = typeof ctor.name === 'string' ? ctor.name : '';\n  if (ctorName && /Error|Event|Response|Request|Headers|Node|Element|Window|Document/.test(ctorName)) {\n    return true;\n  }\n\n  try {\n    if (typeof value.then === 'function' || typeof value.catch === 'function') {\n      return true;\n    }\n    if (typeof value.pipe === 'function' || typeof value.on === 'function') {\n      return true;\n    }\n    if (typeof value.write === 'function' || typeof value.read === 'function') {\n      return true;\n    }\n    if (typeof value.getReader === 'function' || typeof value.getWriter === 'function') {\n      return true;\n    }\n    if (typeof value[Symbol.iterator] === 'function' && !Array.isArray(value)) {\n      return true;\n    }\n    if (typeof Symbol !== 'undefined' && value[Symbol.toStringTag]) {\n      const tag = value[Symbol.toStringTag];\n      if (typeof tag === 'string' && /Stream|Port|Process/.test(tag)) {\n        return true;\n      }\n    }\n  } catch (inspectionError) {\n    void inspectionError;\n  }\n\n  return false;\n}\n\nfunction fallbackFreezeDeep(value, seen) {\n  const visited = seen || (typeof WeakSet === 'function' ? new WeakSet() : {\n    add() { },\n    has() {\n      return false;\n    },\n  });\n\n  if (!value || typeof value !== 'object') {\n    return value;\n  }\n\n  if (shouldBypassDeepFreeze(value)) {\n    return value;\n  }\n\n  if (typeof process !== 'undefined' && process && process.env && process.env.JEST_WORKER_ID) {\n    try {\n      if (typeof Object.freeze === 'function') {\n        Object.freeze(value);\n      }\n    } catch (freezeError) {\n      void freezeError;\n    }\n    return value;\n  }\n\n  if (typeof visited.has === 'function' && visited.has(value)) {\n    return value;\n  }\n\n  if (typeof visited.add === 'function') {\n    visited.add(value);\n  }\n\n  const keys = Object.getOwnPropertyNames(value);\n  for (let index = 0; index < keys.length; index += 1) {\n    const key = keys[index];\n    let child;\n    try {\n      child = value[key];\n    } catch (accessError) {\n      void accessError;\n      child = undefined;\n    }\n    if (!child || typeof child === 'function' || (typeof child !== 'object' && typeof child !== 'function')) {\n      continue;\n    }\n    fallbackFreezeDeep(child, visited);\n  }\n\n  try {\n    try {\n      return Object.freeze(value);\n    } catch (freezeError) {\n      void freezeError;\n      return value;\n    }\n  } catch (freezeError) {\n    void freezeError;\n    return value;\n  }\n}\n\nconst freezeDeep = (function resolveFreezeDeep() {\n  if (MODULE_GLOBALS && typeof MODULE_GLOBALS.freezeDeep === 'function') {\n    return MODULE_GLOBALS.freezeDeep;\n  }\n\n  if (ENV_BRIDGE && typeof ENV_BRIDGE.freezeDeep === 'function') {\n    return function bridgeFreezeDeep(value, seen) {\n      try {\n        return ENV_BRIDGE.freezeDeep(value, seen);\n      } catch (error) {\n        void error;\n        return fallbackFreezeDeep(value, seen);\n      }\n    };\n  }\n\n  if (MODULE_ENV && typeof MODULE_ENV.freezeDeep === 'function') {\n    return MODULE_ENV.freezeDeep;\n  }\n\n  return fallbackFreezeDeep;\n})();\n\nfunction fallbackSafeWarn(message, detail) {\n  if (typeof console === 'undefined' || typeof console.warn !== 'function') {\n    return;\n  }\n\n  try {\n    if (typeof detail === 'undefined') {\n      console.warn(message);\n    } else {\n      console.warn(message, detail);\n    }\n  } catch (error) {\n    void error;\n  }\n}\n\nconst safeWarn = (function resolveSafeWarn() {\n  if (MODULE_GLOBALS && typeof MODULE_GLOBALS.safeWarn === 'function') {\n    return MODULE_GLOBALS.safeWarn;\n  }\n\n  if (ENV_BRIDGE && typeof ENV_BRIDGE.safeWarn === 'function') {\n    return function bridgeSafeWarn(message, detail) {\n      try {\n        ENV_BRIDGE.safeWarn(message, detail);\n      } catch (error) {\n        void error;\n        fallbackSafeWarn(message, detail);\n      }\n    };\n  }\n\n  if (MODULE_ENV && typeof MODULE_ENV.safeWarn === 'function') {\n    return MODULE_ENV.safeWarn;\n  }\n\n  return fallbackSafeWarn;\n})();\n\nconst CONSOLE_METHODS = ['debug', 'info', 'warn', 'error', 'log'];\nconst CONSOLE_PROXY_FLAG = typeof Symbol === 'function'\n  ? Symbol.for('cineLoggingConsoleProxyInstalled')\n  : '__cineLoggingConsoleProxyInstalled__';\n\n/**\n * DEEP DIVE: Console Proxying\n *\n * Why do we proxy `console` methods?\n * 1. Centralized Control: Users can \"silence\" logs via settings without code changes.\n * 2. Log Levels: We implement standard levels (DEBUG, INFO, WARN, ERROR) over the raw console.\n * 3. Remote Telemetry (Future): Allows hooking into logs to send them to a server/service.\n *\n * Safety First: We capture the *original* console functions first so we never create infinite loops.\n */\nconst ORIGINAL_CONSOLE_FUNCTIONS = (function captureOriginalConsoleFunctions() {\n  const store = Object.create(null);\n  if (typeof console === 'undefined' || !console) {\n    return store;\n  }\n\n  for (let index = 0; index < CONSOLE_METHODS.length; index += 1) {\n    const method = CONSOLE_METHODS[index];\n    try {\n      const fn = console[method];\n      store[method] = typeof fn === 'function' ? fn : null;\n    } catch (error) {\n      store[method] = null;\n      void error;\n    }\n  }\n\n  return store;\n})();\n\nlet consoleProxyInstalled = false;\nlet consoleProxyInstallationAttempted = false;\nlet consoleProxyInstallationFailed = false;\nlet lastConsoleCaptureState = null;\nlet consoleProxyWarningIssued = false;\nlet consoleProxyGuardDepth = 0;\n\nconst exposeGlobal = (function resolveExposeGlobal() {\n  if (MODULE_GLOBALS && typeof MODULE_GLOBALS.exposeGlobal === 'function') {\n    return function exposeGlobal(name, value, options) {\n      try {\n        return MODULE_GLOBALS.exposeGlobal(name, value, options);\n      } catch (error) {\n        void error;\n        return false;\n      }\n    };\n  }\n\n  return function fallbackExposeGlobal(name, value) {\n    if (!GLOBAL_SCOPE || (typeof GLOBAL_SCOPE !== 'object' && typeof GLOBAL_SCOPE !== 'function')) {\n      return false;\n    }\n    try {\n      GLOBAL_SCOPE[name] = value;\n      return true;\n    } catch (error) {\n      void error;\n      return false;\n    }\n  };\n})();\n\nfunction informModuleGlobals(name, api) {\n  if (!MODULE_GLOBALS || typeof MODULE_GLOBALS.recordModule !== 'function') {\n    return;\n  }\n\n  try {\n    MODULE_GLOBALS.recordModule(name, api);\n  } catch (error) {\n    void error;\n  }\n}\n\nconst LOG_LEVEL_MAP = {\n  debug: { priority: 10, consoleMethod: 'debug' },\n  info: { priority: 20, consoleMethod: 'info' },\n  warn: { priority: 30, consoleMethod: 'warn' },\n  error: { priority: 40, consoleMethod: 'error' },\n};\n\nconst LOG_LEVELS = freezeDeep(LOG_LEVEL_MAP);\n\nconst LEVEL_COUNTER_KEYS = Object.freeze(Object.keys(LOG_LEVEL_MAP).concat(['other']));\n\nfunction createLevelCounters() {\n  const counters = Object.create(null);\n  for (let index = 0; index < LEVEL_COUNTER_KEYS.length; index += 1) {\n    const key = LEVEL_COUNTER_KEYS[index];\n    counters[key] = 0;\n  }\n  return counters;\n}\n\nfunction resetLevelCounters(counters) {\n  if (!counters || typeof counters !== 'object') {\n    return;\n  }\n\n  for (let index = 0; index < LEVEL_COUNTER_KEYS.length; index += 1) {\n    const key = LEVEL_COUNTER_KEYS[index];\n    counters[key] = 0;\n  }\n}\n\nfunction resolveLevelKey(level) {\n  if (typeof level === 'string' && level) {\n    if (Object.prototype.hasOwnProperty.call(LOG_LEVEL_MAP, level)) {\n      return level;\n    }\n    const trimmed = level.trim().toLowerCase();\n    if (Object.prototype.hasOwnProperty.call(LOG_LEVEL_MAP, trimmed)) {\n      return trimmed;\n    }\n  }\n  return 'other';\n}\n\nfunction getCounterValue(counters, key) {\n  if (!counters || typeof counters !== 'object') {\n    return 0;\n  }\n\n  const value = counters[key];\n  return typeof value === 'number' && Number.isFinite(value) && value > 0 ? value : 0;\n}\n\nfunction applyLevelCounterDelta(counters, level, delta) {\n  if (!counters || typeof counters !== 'object') {\n    return;\n  }\n\n  if (typeof delta !== 'number' || !Number.isFinite(delta) || delta === 0) {\n    return;\n  }\n\n  const key = resolveLevelKey(level);\n  const current = getCounterValue(counters, key);\n  const next = current + delta;\n  counters[key] = next > 0 ? next : 0;\n}\n\nfunction applyLevelCounterDeltaForEntries(counters, entries, delta) {\n  if (!Array.isArray(entries) || !entries.length) {\n    return;\n  }\n\n  if (typeof delta !== 'number' || !Number.isFinite(delta) || delta === 0) {\n    return;\n  }\n\n  for (let index = 0; index < entries.length; index += 1) {\n    const entry = entries[index];\n    const level = entry && entry.level;\n    applyLevelCounterDelta(counters, level, delta);\n  }\n}\n\nfunction summariseEntriesByLevel(entries) {\n  const summary = createLevelCounters();\n  applyLevelCounterDeltaForEntries(summary, entries, 1);\n  return summary;\n}\n\nfunction accumulateLevelSummary(target, summary) {\n  if (!target || typeof target !== 'object' || !summary || typeof summary !== 'object') {\n    return;\n  }\n\n  for (let index = 0; index < LEVEL_COUNTER_KEYS.length; index += 1) {\n    const key = LEVEL_COUNTER_KEYS[index];\n    const increment = getCounterValue(summary, key);\n    if (increment) {\n      const current = getCounterValue(target, key);\n      target[key] = current + increment;\n    }\n  }\n}\n\nfunction cloneLevelSummary(summary) {\n  const clone = createLevelCounters();\n  accumulateLevelSummary(clone, summary);\n  return clone;\n}\n\nfunction freezeLevelSummary(summary) {\n  return freezeDeep(cloneLevelSummary(summary));\n}\n\nconst HISTORY_MIN_LIMIT = 50;\nconst HISTORY_ABSOLUTE_MIN_LIMIT = 1;\nconst HISTORY_MAX_LIMIT = 5000;\nconst HISTORY_STORAGE_KEY = '__cineLoggingHistory';\nconst CONFIG_STORAGE_KEY = '__cineLoggingConfig';\nconst ERROR_EVENT_FLAG =\n  typeof Symbol === 'function' ? Symbol.for('cineLoggingHandled') : '__cineLoggingHandled__';\nconst DEFAULT_CONFIG_VALUES = {\n  level: 'warn',\n  historyLevel: 'info',\n  historyLimit: 1200,\n  consoleOutput: true,\n  persistSession: true,\n  captureGlobalErrors: true,\n  captureConsole: false,\n  stackTraces: true,\n};\n\nconst DEFAULT_CONFIG = freezeDeep(DEFAULT_CONFIG_VALUES);\n\nconst SERVICE_WORKER_LOG_CHANNEL = 'cine-sw-logs';\nconst SERVICE_WORKER_LOG_ENTRY_TYPE = 'cine-sw:log-entry';\nconst SERVICE_WORKER_LOG_STATE_REQUEST = 'cine-sw:log-state-request';\nconst SERVICE_WORKER_LOG_STATE_RESPONSE = 'cine-sw:log-state';\nconst SERVICE_WORKER_LOG_REQUEST_TIMEOUT = 5000;\nconst SERVICE_WORKER_LOG_POLL_INTERVAL = 60 * 1000;\nconst SERVICE_WORKER_LOG_HISTORY_LIMIT = 200;\n\nfunction cloneDefaultConfig() {\n  return {\n    level: DEFAULT_CONFIG_VALUES.level,\n    historyLevel: DEFAULT_CONFIG_VALUES.historyLevel,\n    historyLimit: DEFAULT_CONFIG_VALUES.historyLimit,\n    consoleOutput: DEFAULT_CONFIG_VALUES.consoleOutput,\n    persistSession: DEFAULT_CONFIG_VALUES.persistSession,\n    captureGlobalErrors: DEFAULT_CONFIG_VALUES.captureGlobalErrors,\n    captureConsole: DEFAULT_CONFIG_VALUES.captureConsole,\n    stackTraces: DEFAULT_CONFIG_VALUES.stackTraces,\n  };\n}\n\nlet activeConfig = cloneDefaultConfig();\nconst logHistory = [];\nconst logSubscribers = new Set();\nconst configSubscribers = new Set();\nconst attachedErrorTargets = typeof WeakSet === 'function' ? new WeakSet() : [];\nlet runtimeEntryCount = 0;\nconst emittedLevelCounters = createLevelCounters();\nconst retainedLevelCounters = createLevelCounters();\nconst droppedLevelCounters = createLevelCounters();\nlet totalEntriesDropped = 0;\nlet lastHistoryDrop = null;\nconst serviceWorkerBridgeState = {\n  initialised: false,\n  supported: false,\n  requestInFlight: false,\n  lastRequestId: null,\n  pollTimer: null,\n  requestTimer: null,\n  broadcastChannel: null,\n  broadcastFailed: false,\n  seenIds: typeof Set === 'function' ? new Set() : null,\n  fallbackSeenIds: typeof Set !== 'function' ? [] : null,\n  lastSnapshotMeta: null,\n};\n\nfunction normalizeLevel(value, fallbackLevel) {\n  const fallback = typeof fallbackLevel === 'string' ? fallbackLevel : activeConfig.level;\n\n  if (typeof value === 'string') {\n    const trimmed = value.trim().toLowerCase();\n    if (Object.prototype.hasOwnProperty.call(LOG_LEVEL_MAP, trimmed)) {\n      return trimmed;\n    }\n    if (trimmed === 'log' || trimmed === 'information') {\n      return 'info';\n    }\n    if (trimmed === 'warning') {\n      return 'warn';\n    }\n    if (trimmed === 'trace' || trimmed === 'verbose') {\n      return 'debug';\n    }\n    if (trimmed === 'fatal' || trimmed === 'critical') {\n      return 'error';\n    }\n  }\n\n  if (Object.prototype.hasOwnProperty.call(LOG_LEVEL_MAP, fallback)) {\n    return fallback;\n  }\n\n  return 'info';\n}\n\nfunction getLevelPriority(level) {\n  const normalized = normalizeLevel(level, 'info');\n  const descriptor = LOG_LEVEL_MAP[normalized];\n  return descriptor ? descriptor.priority : LOG_LEVEL_MAP.info.priority;\n}\n\nfunction booleanFromValue(value, fallback) {\n  if (typeof value === 'boolean') {\n    return value;\n  }\n  if (typeof value === 'number') {\n    if (!Number.isFinite(value)) {\n      return Boolean(fallback);\n    }\n    if (value === 1) {\n      return true;\n    }\n    if (value === 0) {\n      return false;\n    }\n    return value > 0;\n  }\n  if (typeof value === 'string') {\n    const normalized = value.trim().toLowerCase();\n    if (normalized === 'true' || normalized === '1' || normalized === 'yes' || normalized === 'on') {\n      return true;\n    }\n    if (normalized === 'false' || normalized === '0' || normalized === 'no' || normalized === 'off') {\n      return false;\n    }\n  }\n  return typeof fallback === 'boolean' ? fallback : false;\n}\n\nfunction clampHistoryLimit(value, options) {\n  const allowReducedMinimum =\n    options && options.allowReducedMin === true ? true : false;\n  const effectiveMinimum = allowReducedMinimum ? HISTORY_ABSOLUTE_MIN_LIMIT : HISTORY_MIN_LIMIT;\n\n  if (typeof value === 'number' && Number.isFinite(value)) {\n    const absolute = Math.abs(Math.floor(value));\n    if (!absolute) {\n      return activeConfig.historyLimit;\n    }\n    return Math.max(effectiveMinimum, Math.min(HISTORY_MAX_LIMIT, absolute));\n  }\n\n  if (typeof value === 'string' && value) {\n    const parsed = Number(value);\n    if (Number.isFinite(parsed)) {\n      return clampHistoryLimit(parsed, options);\n    }\n  }\n\n  return activeConfig.historyLimit;\n}\n\nfunction coerceMessage(value) {\n  if (typeof value === 'string') {\n    return value;\n  }\n  if (value instanceof Error) {\n    return value.message || value.name || 'Error';\n  }\n  if (value && typeof value === 'object') {\n    if (typeof value.message === 'string') {\n      return value.message;\n    }\n    const ctorName = value.constructor && value.constructor.name;\n    if (ctorName) {\n      return ctorName;\n    }\n  }\n  if (typeof value === 'number' || typeof value === 'boolean') {\n    return String(value);\n  }\n  if (typeof value === 'undefined' || value === null) {\n    return '';\n  }\n  try {\n    return String(value);\n  } catch (error) {\n    void error;\n  }\n  return Object.prototype.toString.call(value);\n}\n\nfunction sanitizeForLog(value, depth, seen) {\n  const nextDepth = typeof depth === 'number' ? depth : 0;\n  const visited = seen || (typeof WeakSet === 'function' ? new WeakSet() : null);\n\n  if (value === null || typeof value === 'undefined') {\n    return null;\n  }\n\n  const valueType = typeof value;\n\n  if (valueType === 'string' || valueType === 'number' || valueType === 'boolean') {\n    return value;\n  }\n\n  if (valueType === 'bigint') {\n    try {\n      return value.toString();\n    } catch (error) {\n      void error;\n      return 'BigInt';\n    }\n  }\n\n  if (valueType === 'symbol') {\n    try {\n      return value.toString();\n    } catch (error) {\n      void error;\n      return 'Symbol';\n    }\n  }\n\n  if (valueType === 'function') {\n    const name = value.name ? ` ${value.name}` : '';\n    return `[Function${name}]`;\n  }\n\n  if (value instanceof Date) {\n    try {\n      return value.toISOString();\n    } catch (error) {\n      void error;\n      return value.toString();\n    }\n  }\n\n  if (typeof RegExp !== 'undefined' && value instanceof RegExp) {\n    try {\n      return value.toString();\n    } catch (error) {\n      void error;\n    }\n    return '[RegExp]';\n  }\n\n  if (value instanceof Error) {\n    const errorOutput = {\n      name: value.name,\n      message: value.message,\n    };\n    if (value.stack) {\n      errorOutput.stack = String(value.stack);\n    }\n    if (typeof value.code !== 'undefined') {\n      errorOutput.code = value.code;\n    }\n    if (typeof value.status !== 'undefined') {\n      errorOutput.status = value.status;\n    }\n    if (typeof value.cause !== 'undefined' && value.cause !== null) {\n      errorOutput.cause = sanitizeForLog(value.cause, nextDepth + 1, visited);\n    }\n    if (typeof value.details !== 'undefined') {\n      errorOutput.details = sanitizeForLog(value.details, nextDepth + 1, visited);\n    }\n    if (typeof value.errors !== 'undefined' && value.errors !== null) {\n      const collectedErrors = [];\n      const maxErrors = 10;\n      let truncatedErrors = 0;\n\n      const appendErrorDetail = function appendErrorDetail(candidate) {\n        if (collectedErrors.length >= maxErrors) {\n          truncatedErrors += 1;\n          return;\n        }\n        try {\n          collectedErrors.push(sanitizeForLog(candidate, nextDepth + 1, visited));\n        } catch (error) {\n          collectedErrors.push(\n            error && error.message ? `[Unserializable error: ${error.message}]` : '[Unserializable error]'\n          );\n        }\n      };\n\n      const rawErrors = value.errors;\n      if (Array.isArray(rawErrors)) {\n        for (let index = 0; index < rawErrors.length; index += 1) {\n          appendErrorDetail(rawErrors[index]);\n        }\n        if (rawErrors.length > collectedErrors.length) {\n          truncatedErrors += rawErrors.length - collectedErrors.length;\n        }\n      } else if (rawErrors && typeof rawErrors === 'object') {\n        let iterator = null;\n        try {\n          const symbolIterator = typeof Symbol === 'function' ? Symbol.iterator : null;\n          if (symbolIterator && typeof rawErrors[symbolIterator] === 'function') {\n            iterator = rawErrors[symbolIterator].call(rawErrors);\n          }\n        } catch (iteratorError) {\n          iterator = null;\n          void iteratorError;\n        }\n\n        if (iterator && typeof iterator.next === 'function') {\n          let result = iterator.next();\n          let count = 0;\n          while (!result.done) {\n            if (count < maxErrors) {\n              appendErrorDetail(result.value);\n            } else {\n              truncatedErrors += 1;\n            }\n            count += 1;\n            try {\n              result = iterator.next();\n            } catch (iterationError) {\n              truncatedErrors += 1;\n              void iterationError;\n              break;\n            }\n          }\n        } else {\n          appendErrorDetail(rawErrors);\n        }\n      } else {\n        appendErrorDetail(rawErrors);\n      }\n\n      if (collectedErrors.length) {\n        errorOutput.errors = collectedErrors;\n        if (truncatedErrors > 0) {\n          errorOutput.errorsTruncated = truncatedErrors;\n        }\n      }\n    }\n    return errorOutput;\n  }\n\n  if (valueType === 'object') {\n    if (visited) {\n      try {\n        if (visited.has(value)) {\n          return '[Circular]';\n        }\n        visited.add(value);\n      } catch (error) {\n        void error;\n      }\n    }\n\n    if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n      return {\n        __type: 'ArrayBuffer',\n        byteLength: value.byteLength,\n      };\n    }\n\n    if (typeof DataView !== 'undefined' && value instanceof DataView) {\n      return {\n        __type: 'DataView',\n        byteOffset: value.byteOffset,\n        byteLength: value.byteLength,\n      };\n    }\n\n    if (\n      typeof ArrayBuffer !== 'undefined'\n      && typeof ArrayBuffer.isView === 'function'\n      && ArrayBuffer.isView(value)\n    ) {\n      const ctorName = value.constructor && value.constructor.name;\n      const maxPreview = 32;\n      const length = typeof value.length === 'number' ? value.length : 0;\n      const preview = [];\n      const previewLength = Math.min(length, maxPreview);\n      for (let index = 0; index < previewLength; index += 1) {\n        preview.push(value[index]);\n      }\n      const summary = {\n        __type: ctorName || 'TypedArray',\n        length,\n        byteOffset: typeof value.byteOffset === 'number' ? value.byteOffset : 0,\n        byteLength: typeof value.byteLength === 'number' ? value.byteLength : 0,\n      };\n      if (preview.length) {\n        summary.preview = preview;\n      }\n      if (length > maxPreview) {\n        summary.__truncatedItems = length - maxPreview;\n      }\n      return summary;\n    }\n\n    const mapCtor = typeof Map === 'function' ? Map : null;\n    if (mapCtor && value instanceof mapCtor) {\n      const entries = [];\n      const maxEntries = 30;\n      let index = 0;\n      value.forEach((mapValue, mapKey) => {\n        if (index < maxEntries) {\n          entries.push({\n            key: sanitizeForLog(mapKey, nextDepth + 1, visited),\n            value: sanitizeForLog(mapValue, nextDepth + 1, visited),\n          });\n        }\n        index += 1;\n      });\n      const result = {\n        __type: 'Map',\n        size: typeof value.size === 'number' ? value.size : index,\n        entries,\n      };\n      if (index > maxEntries) {\n        result.__truncatedEntries = index - maxEntries;\n      }\n      return result;\n    }\n\n    const setCtor = typeof Set === 'function' ? Set : null;\n    if (setCtor && value instanceof setCtor) {\n      const items = [];\n      const maxItems = 30;\n      let index = 0;\n      value.forEach(item => {\n        if (index < maxItems) {\n          items.push(sanitizeForLog(item, nextDepth + 1, visited));\n        }\n        index += 1;\n      });\n      const result = {\n        __type: 'Set',\n        size: typeof value.size === 'number' ? value.size : index,\n        values: items,\n      };\n      if (index > maxItems) {\n        result.__truncatedValues = index - maxItems;\n      }\n      return result;\n    }\n\n    const urlParamsCtor = typeof URLSearchParams === 'function' ? URLSearchParams : null;\n    if (urlParamsCtor && value instanceof urlParamsCtor) {\n      const params = [];\n      const iterator = typeof value.entries === 'function' ? value.entries() : null;\n      let truncated = 0;\n      if (iterator && typeof iterator.next === 'function') {\n        const maxPairs = 40;\n        let count = 0;\n        let next = iterator.next();\n        while (!next.done) {\n          if (count < maxPairs) {\n            const pair = next.value || [];\n            params.push({\n              key: sanitizeForLog(pair[0], nextDepth + 1, visited),\n              value: sanitizeForLog(pair[1], nextDepth + 1, visited),\n            });\n          }\n          count += 1;\n          next = iterator.next();\n        }\n        if (count > params.length) {\n          truncated = count - params.length;\n        }\n      }\n      const result = {\n        __type: 'URLSearchParams',\n        entries: params,\n      };\n      if (truncated > 0) {\n        result.__truncatedEntries = truncated;\n      }\n      return result;\n    }\n\n    if (typeof URL === 'function' && value instanceof URL) {\n      try {\n        return value.toString();\n      } catch (error) {\n        void error;\n      }\n    }\n\n    if (nextDepth >= 4) {\n      const ctorName = value.constructor && value.constructor.name;\n      return ctorName ? `[${ctorName}]` : Object.prototype.toString.call(value);\n    }\n\n    if (Array.isArray(value)) {\n      const maxItems = 20;\n      const result = [];\n      const len = Math.min(value.length, maxItems);\n      for (let index = 0; index < len; index += 1) {\n        result.push(sanitizeForLog(value[index], nextDepth + 1, visited));\n      }\n      if (value.length > maxItems) {\n        result.push(` (${value.length - maxItems} more)`);\n      }\n      return result;\n    }\n\n    const output = {};\n    const keys = Object.keys(value);\n    const maxKeys = 30;\n    const length = Math.min(keys.length, maxKeys);\n    for (let index = 0; index < length; index += 1) {\n      const key = keys[index];\n      try {\n        output[key] = sanitizeForLog(value[key], nextDepth + 1, visited);\n      } catch (error) {\n        output[key] = `[Threw: ${error && error.message ? error.message : 'error'}]`;\n      }\n    }\n    if (keys.length > maxKeys) {\n      output.__truncatedKeys = keys.length - maxKeys;\n    }\n\n    if (typeof Object.getOwnPropertySymbols === 'function') {\n      const symbols = Object.getOwnPropertySymbols(value);\n      const symbolLength = Math.min(symbols.length, 5);\n      for (let index = 0; index < symbolLength; index += 1) {\n        const symbolKey = symbols[index];\n        const symbolName = typeof symbolKey === 'symbol' ? symbolKey.toString() : String(symbolKey);\n        try {\n          output[symbolName] = sanitizeForLog(value[symbolKey], nextDepth + 1, visited);\n        } catch (error) {\n          output[symbolName] = `[Threw: ${error && error.message ? error.message : 'error'}]`;\n        }\n      }\n    }\n\n    if (!keys.length) {\n      const ctorName = value.constructor && value.constructor.name;\n      if (ctorName) {\n        output.__className = ctorName;\n      }\n    }\n\n    return output;\n  }\n\n  const structuredCloneResult = tryStructuredCloneValue(value);\n  if (structuredCloneResult.success) {\n    return structuredCloneResult.value;\n  }\n\n  try {\n    return LOGGING_DEEP_CLONE(value);\n  } catch (error) {\n    void error;\n  }\n\n  try {\n    return String(value);\n  } catch (stringifyError) {\n    void stringifyError;\n  }\n\n  return null;\n}\n\nfunction normaliseStackTrace(stackValue) {\n  if (typeof stackValue !== 'string') {\n    return null;\n  }\n\n  const trimmed = stackValue.replace(/\\r\\n?/g, '\\n').trim();\n  if (!trimmed) {\n    return null;\n  }\n\n  const maxLength = 5000;\n  const charTruncated = trimmed.length > maxLength;\n  const limitedStack = charTruncated ? trimmed.slice(0, maxLength) : trimmed;\n\n  const rawLines = trimmed.split('\\n');\n  const frameLimit = 40;\n  const frames = [];\n  let frameTruncated = false;\n  for (let index = 0; index < rawLines.length; index += 1) {\n    const line = rawLines[index].trim();\n    if (!line) {\n      continue;\n    }\n    if (frames.length < frameLimit) {\n      frames.push(line.length > 500 ? `${line.slice(0, 500)}\\u2026` : line);\n    } else {\n      frameTruncated = true;\n      break;\n    }\n  }\n\n  return {\n    stack: limitedStack,\n    frames,\n    truncated: charTruncated || frameTruncated,\n  };\n}\n\nfunction normaliseOriginSnapshot(origin) {\n  if (!origin || typeof origin !== 'object') {\n    return null;\n  }\n\n  const source = typeof origin.source === 'string' && origin.source\n    ? origin.source\n    : 'unknown';\n\n  let stackSummary = null;\n  if (typeof origin.stack === 'string' && origin.stack) {\n    stackSummary = normaliseStackTrace(origin.stack);\n  }\n\n  const frames = [];\n  if (Array.isArray(origin.frames)) {\n    for (let index = 0; index < origin.frames.length && frames.length < 40; index += 1) {\n      const frame = origin.frames[index];\n      if (typeof frame === 'string' && frame) {\n        frames.push(frame);\n      } else if (frame !== null && typeof frame !== 'undefined') {\n        frames.push(coerceMessage(frame));\n      }\n    }\n  } else if (stackSummary && Array.isArray(stackSummary.frames)) {\n    for (let index = 0; index < stackSummary.frames.length; index += 1) {\n      frames.push(stackSummary.frames[index]);\n    }\n  }\n\n  const truncated = origin.truncated === true\n    || (stackSummary ? stackSummary.truncated === true : false)\n    || (frames.length > 0 && frames.length >= 40);\n\n  const snapshot = {\n    source,\n    truncated,\n  };\n\n  if (stackSummary && stackSummary.stack) {\n    snapshot.stack = stackSummary.stack;\n  } else if (typeof origin.stack === 'string' && origin.stack) {\n    snapshot.stack = origin.stack;\n  } else {\n    snapshot.stack = null;\n  }\n\n  if (frames.length) {\n    snapshot.frames = frames;\n  }\n\n  if (!snapshot.stack && (!snapshot.frames || !snapshot.frames.length)) {\n    return null;\n  }\n\n  return freezeDeep(snapshot);\n}\n\nfunction getSessionStorage() {\n  const scopes = fallbackCollectCandidateScopes(GLOBAL_SCOPE);\n  for (let index = 0; index < scopes.length; index += 1) {\n    const scope = scopes[index];\n    if (!scope || (typeof scope !== 'object' && typeof scope !== 'function')) {\n      continue;\n    }\n    try {\n      const storage = scope.sessionStorage;\n      if (storage && typeof storage.getItem === 'function' && typeof storage.setItem === 'function') {\n        return storage;\n      }\n    } catch (error) {\n      void error;\n    }\n  }\n  return null;\n}\n\nfunction clearStoredHistory() {\n  const storage = getSessionStorage();\n  if (!storage) {\n    return;\n  }\n  try {\n    storage.removeItem(HISTORY_STORAGE_KEY);\n  } catch (error) {\n    void error;\n  }\n}\n\nfunction persistConfigSafe() {\n  const storage = getSessionStorage();\n  if (!storage) {\n    return;\n  }\n\n  if (!activeConfig.persistSession) {\n    try {\n      storage.removeItem(CONFIG_STORAGE_KEY);\n    } catch (error) {\n      void error;\n    }\n    return;\n  }\n\n  try {\n    storage.setItem(\n      CONFIG_STORAGE_KEY,\n      JSON.stringify({\n        level: activeConfig.level,\n        historyLevel: activeConfig.historyLevel,\n        historyLimit: activeConfig.historyLimit,\n        consoleOutput: activeConfig.consoleOutput,\n        persistSession: activeConfig.persistSession,\n        captureGlobalErrors: activeConfig.captureGlobalErrors,\n        captureConsole: activeConfig.captureConsole,\n        stackTraces: activeConfig.stackTraces,\n      }),\n    );\n  } catch (error) {\n    console.warn('cineLogging: Unable to persist logging config', error);\n  }\n}\n\nfunction persistHistorySafe() {\n  if (!activeConfig.persistSession) {\n    clearStoredHistory();\n    return;\n  }\n\n  const storage = getSessionStorage();\n  if (!storage) {\n    return;\n  }\n\n  try {\n    storage.setItem(HISTORY_STORAGE_KEY, JSON.stringify(logHistory));\n  } catch (error) {\n    if (error && (error.name === 'QuotaExceededError' || error.name === 'NS_ERROR_DOM_QUOTA_REACHED')) {\n      // Disable persistence for this session to prevent loop\n      activeConfig.persistSession = false;\n      try {\n        storage.removeItem(HISTORY_STORAGE_KEY);\n      } catch (e) { void e; }\n      // Do NOT log a warning here, as it might trigger the proxy and cause a loop\n      return;\n    }\n    console.warn('cineLogging: Unable to persist log history', error);\n  }\n}\n\nfunction getEffectiveHistoryLimit() {\n  const effectiveMinimum = activeConfig.persistSession === false\n    ? HISTORY_ABSOLUTE_MIN_LIMIT\n    : HISTORY_MIN_LIMIT;\n\n  return Math.max(\n    effectiveMinimum,\n    Math.min(HISTORY_MAX_LIMIT, Math.floor(activeConfig.historyLimit)),\n  );\n}\n\nfunction recordHistoryDrop(removedEntries, limit, options) {\n  if (!Array.isArray(removedEntries) || removedEntries.length === 0) {\n    return null;\n  }\n\n  totalEntriesDropped += removedEntries.length;\n  const removedSummary = summariseEntriesByLevel(removedEntries);\n\n  const source = options && typeof options.source === 'string' && options.source.trim()\n    ? options.source.trim()\n    : 'enforce';\n\n  const oldestEntry = removedEntries[0] || null;\n  const newestEntry = removedEntries[removedEntries.length - 1] || null;\n\n  const dropTimestamp = Date.now();\n  let dropIsoTimestamp = '';\n  try {\n    dropIsoTimestamp = new Date(dropTimestamp).toISOString();\n  } catch (error) {\n    void error;\n    dropIsoTimestamp = String(dropTimestamp);\n  }\n\n  lastHistoryDrop = freezeDeep({\n    count: removedEntries.length,\n    limit,\n    source,\n    timestamp: dropTimestamp,\n    isoTimestamp: dropIsoTimestamp,\n    oldestEntryId:\n      oldestEntry && typeof oldestEntry.id === 'string' ? oldestEntry.id : null,\n    oldestEntryTimestamp:\n      oldestEntry && typeof oldestEntry.timestamp === 'number'\n        ? oldestEntry.timestamp\n        : null,\n    oldestEntryIsoTimestamp:\n      oldestEntry && typeof oldestEntry.isoTimestamp === 'string'\n        ? oldestEntry.isoTimestamp\n        : null,\n    newestEntryId:\n      newestEntry && typeof newestEntry.id === 'string' ? newestEntry.id : null,\n    newestEntryTimestamp:\n      newestEntry && typeof newestEntry.timestamp === 'number'\n        ? newestEntry.timestamp\n        : null,\n    newestEntryIsoTimestamp:\n      newestEntry && typeof newestEntry.isoTimestamp === 'string'\n        ? newestEntry.isoTimestamp\n        : null,\n    levels: freezeLevelSummary(removedSummary),\n  });\n\n  if (ORIGINAL_CONSOLE_FUNCTIONS && typeof ORIGINAL_CONSOLE_FUNCTIONS.warn === 'function') {\n    try {\n      ORIGINAL_CONSOLE_FUNCTIONS.warn('cineLogging: history trimmed to enforce retention limit', {\n        limit,\n        removed: removedEntries.length,\n        source,\n        levels: cloneLevelSummary(removedSummary),\n      });\n    } catch (warnError) {\n      void warnError;\n    }\n  } else {\n    // Fallback if original console is somehow missing or we are in a weird state\n    // We purposefully avoid safeWarn here to prevent recursion\n    try {\n      if (typeof console !== 'undefined' && typeof console.warn === 'function') {\n        // If console.warn IS the proxy, we can't easily detect it without checking equality to the proxy function\n        // But avoiding safeWarn wrapper helps if safeWarn adds extra logic. \n        // Ideally we just stop if we can't find the original.\n      }\n    } catch (e) { void e; }\n  }\n\n  return removedSummary;\n}\n\nfunction enforceHistoryLimit(options) {\n  const limit = getEffectiveHistoryLimit();\n  if (logHistory.length <= limit) {\n    return 0;\n  }\n\n  const overflow = logHistory.length - limit;\n  const removedEntries = logHistory.splice(0, overflow);\n  applyLevelCounterDeltaForEntries(retainedLevelCounters, removedEntries, -1);\n  const removedSummary = recordHistoryDrop(removedEntries, limit, options);\n  if (removedSummary) {\n    accumulateLevelSummary(droppedLevelCounters, removedSummary);\n  }\n  return overflow;\n}\n\nfunction shouldRecord(level) {\n  return getLevelPriority(level) >= getLevelPriority(activeConfig.historyLevel);\n}\n\nfunction shouldOutputToConsole(level) {\n  if (!activeConfig.consoleOutput) {\n    return false;\n  }\n  return getLevelPriority(level) >= getLevelPriority(activeConfig.level);\n}\n\nfunction getLevelState(level) {\n  const normalizedLevel = normalizeLevel(level, 'info');\n  const consoleEnabled = shouldOutputToConsole(normalizedLevel);\n  const historyEnabled = shouldRecord(normalizedLevel);\n\n  return freezeDeep({\n    level: normalizedLevel,\n    enabled: consoleEnabled || historyEnabled,\n    console: consoleEnabled,\n    history: historyEnabled,\n    thresholds: freezeDeep({\n      console: normalizeLevel(activeConfig.level, DEFAULT_CONFIG_VALUES.level),\n      history: normalizeLevel(activeConfig.historyLevel, DEFAULT_CONFIG_VALUES.historyLevel),\n    }),\n  });\n}\n\nfunction isLevelEnabled(level, options) {\n  const state = getLevelState(level);\n\n  if (!options || typeof options !== 'object') {\n    return state.enabled;\n  }\n\n  const checkConsole = options.console !== false;\n  const checkHistory = options.history !== false;\n\n  if (!checkConsole && !checkHistory) {\n    return false;\n  }\n\n  if (options.requireAll === true) {\n    if (checkConsole && !state.console) {\n      return false;\n    }\n    if (checkHistory && !state.history) {\n      return false;\n    }\n    return true;\n  }\n\n  if (checkConsole && state.console) {\n    return true;\n  }\n\n  if (checkHistory && state.history) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction createEntryId(timestamp) {\n  return `log-${timestamp}-${Math.random().toString(36).slice(2, 10)}`;\n}\n\nfunction pushEntryToHistory(entry) {\n  if (!entry) {\n    return;\n  }\n\n  try {\n    logHistory.push(entry);\n  } catch (pushError) {\n    // If the history array is somehow frozen or non-extensible, we silently drop the entry\n    // to avoid crashing the entire application.\n    void pushError;\n    return;\n  }\n  applyLevelCounterDelta(retainedLevelCounters, entry.level, 1);\n}\n\nfunction appendEntry(entry) {\n  pushEntryToHistory(entry);\n  runtimeEntryCount += 1;\n  enforceHistoryLimit({ source: 'append' });\n  persistHistorySafe();\n  notifyLogSubscribers(entry);\n}\n\nfunction notifyLogSubscribers(entry) {\n  if (!logSubscribers.size) {\n    return;\n  }\n  const listeners = Array.from(logSubscribers);\n  for (let index = 0; index < listeners.length; index += 1) {\n    const listener = listeners[index];\n    if (typeof listener !== 'function') {\n      continue;\n    }\n    try {\n      listener(entry);\n    } catch (error) {\n      safeWarn('cineLogging listener execution failed', error);\n    }\n  }\n}\n\nfunction getHistorySnapshot(limit) {\n  const effectiveLimit = typeof limit === 'number' && Number.isFinite(limit)\n    ? Math.max(0, Math.floor(limit))\n    : logHistory.length;\n  if (!effectiveLimit) {\n    return Object.freeze([]);\n  }\n  const start = Math.max(0, logHistory.length - effectiveLimit);\n  const slice = logHistory.slice(start);\n  return Object.freeze(slice.slice());\n}\n\nfunction notifyConfigSubscribers(snapshot) {\n  if (!configSubscribers.size) {\n    return;\n  }\n  const listeners = Array.from(configSubscribers);\n  for (let index = 0; index < listeners.length; index += 1) {\n    const listener = listeners[index];\n    if (typeof listener !== 'function') {\n      continue;\n    }\n    try {\n      listener(snapshot);\n    } catch (error) {\n      safeWarn('cineLogging config listener failed', error);\n    }\n  }\n}\n\nfunction arrayFromArrayLike(value) {\n  if (!value || typeof value.length !== 'number') {\n    return [];\n  }\n\n  const length = value.length;\n  const result = new Array(length);\n  for (let index = 0; index < length; index += 1) {\n    result[index] = value[index];\n  }\n\n  return result;\n}\n\nfunction safeArrayPush(target, value) {\n  if (!Array.isArray(target)) {\n    return false;\n  }\n  try {\n    if (typeof Object.isExtensible === 'function' && !Object.isExtensible(target)) {\n      return false;\n    }\n    target.push(value);\n    return true;\n  } catch (error) {\n    void error;\n  }\n  return false;\n}\n\nfunction getConsoleLevelForMethod(method) {\n  if (method === 'error') {\n    return 'error';\n  }\n  if (method === 'warn') {\n    return 'warn';\n  }\n  if (method === 'info') {\n    return 'info';\n  }\n  return 'debug';\n}\n\nfunction getStoredConsoleFunction(method) {\n  if (typeof method !== 'string' || !method) {\n    return null;\n  }\n\n  if (Object.prototype.hasOwnProperty.call(ORIGINAL_CONSOLE_FUNCTIONS, method)) {\n    const stored = ORIGINAL_CONSOLE_FUNCTIONS[method];\n    if (typeof stored === 'function') {\n      return stored;\n    }\n  }\n\n  if (typeof console !== 'undefined' && console) {\n    let candidate = null;\n    try {\n      candidate = console[method];\n    } catch (error) {\n      candidate = null;\n      void error;\n    }\n    if (typeof candidate === 'function' && (!candidate || !candidate[CONSOLE_PROXY_FLAG])) {\n      return candidate;\n    }\n  }\n\n  if ((method === 'debug' || method === 'log') && typeof ORIGINAL_CONSOLE_FUNCTIONS.log === 'function') {\n    return ORIGINAL_CONSOLE_FUNCTIONS.log;\n  }\n\n  if (method === 'info') {\n    if (typeof ORIGINAL_CONSOLE_FUNCTIONS.info === 'function') {\n      return ORIGINAL_CONSOLE_FUNCTIONS.info;\n    }\n    if (typeof ORIGINAL_CONSOLE_FUNCTIONS.log === 'function') {\n      return ORIGINAL_CONSOLE_FUNCTIONS.log;\n    }\n  }\n\n  if (method === 'warn') {\n    if (typeof ORIGINAL_CONSOLE_FUNCTIONS.warn === 'function') {\n      return ORIGINAL_CONSOLE_FUNCTIONS.warn;\n    }\n    if (typeof ORIGINAL_CONSOLE_FUNCTIONS.error === 'function') {\n      return ORIGINAL_CONSOLE_FUNCTIONS.error;\n    }\n  }\n\n  if (method === 'error' && typeof ORIGINAL_CONSOLE_FUNCTIONS.error === 'function') {\n    return ORIGINAL_CONSOLE_FUNCTIONS.error;\n  }\n\n  return null;\n}\n\nfunction invokeConsoleMethod(method, args) {\n  const fn = getStoredConsoleFunction(method);\n  if (typeof fn !== 'function') {\n    return undefined;\n  }\n\n  const receiver = typeof console !== 'undefined' && console\n    ? console\n    : GLOBAL_SCOPE && GLOBAL_SCOPE.console\n      ? GLOBAL_SCOPE.console\n      : null;\n  const finalArgs = Array.isArray(args) ? args : arrayFromArrayLike(args);\n\n  try {\n    return fn.apply(receiver, finalArgs);\n  } catch (applyError) {\n    void applyError;\n    try {\n      return Function.prototype.apply.call(fn, receiver, finalArgs);\n    } catch (callError) {\n      void callError;\n    }\n  }\n\n  return undefined;\n}\n\nfunction recordConsoleMessage(method, args, meta) {\n  const level = getConsoleLevelForMethod(method);\n  const rawArgs = Array.isArray(args) ? args : arrayFromArrayLike(args);\n  const messageParts = [];\n\n  for (let index = 0; index < rawArgs.length; index += 1) {\n    const value = rawArgs[index];\n    const valueType = typeof value;\n    if (valueType === 'string') {\n      safeArrayPush(messageParts, value);\n    } else if (valueType === 'number' || valueType === 'boolean') {\n      safeArrayPush(messageParts, String(value));\n    } else if (valueType === 'symbol') {\n      try {\n        safeArrayPush(messageParts, value.toString());\n      } catch (symbolError) {\n        void symbolError;\n      }\n    }\n  }\n\n  let message = messageParts.join(' ').trim();\n  if (!message) {\n    message = `[console.${method || level}]`;\n  }\n\n  let sanitizedArguments = null;\n  let detailPayload = null;\n  if (rawArgs.length) {\n    try {\n      sanitizedArguments = sanitizeForLog(rawArgs);\n      detailPayload = { arguments: sanitizedArguments };\n    } catch (detailError) {\n      detailPayload = { arguments: rawArgs.slice() };\n      void detailError;\n    }\n  }\n\n  const errorEntries = [];\n  const sanitizedArray = Array.isArray(sanitizedArguments) ? sanitizedArguments : null;\n\n  for (let index = 0; index < rawArgs.length; index += 1) {\n    const rawValue = rawArgs[index];\n    const sanitizedValue = sanitizedArray ? sanitizedArray[index] : null;\n    const isErrorInstance = rawValue instanceof Error;\n\n    const hasSanitizedErrorShape =\n      sanitizedValue && typeof sanitizedValue === 'object' && sanitizedValue !== null\n        ? Boolean(\n          typeof sanitizedValue.stack === 'string'\n          || typeof sanitizedValue.message === 'string'\n          || typeof sanitizedValue.name === 'string'\n        )\n        : false;\n\n    if (!isErrorInstance && !hasSanitizedErrorShape) {\n      continue;\n    }\n\n    let snapshot = hasSanitizedErrorShape ? sanitizedValue : null;\n\n    if (!snapshot) {\n      try {\n        snapshot = sanitizeForLog(rawValue);\n      } catch (argumentSanitizeError) {\n        snapshot = null;\n        void argumentSanitizeError;\n      }\n    }\n\n    if (!snapshot && isErrorInstance) {\n      snapshot = {\n        name: rawValue.name || null,\n        message: rawValue.message || coerceMessage(rawValue) || null,\n      };\n      if (typeof rawValue.code !== 'undefined') {\n        snapshot.code = rawValue.code;\n      }\n      if (typeof rawValue.status !== 'undefined') {\n        snapshot.status = rawValue.status;\n      }\n      if (typeof rawValue.stack === 'string' && rawValue.stack) {\n        snapshot.stack = rawValue.stack;\n      }\n    }\n\n    let valueClone = snapshot;\n    if (valueClone && typeof valueClone === 'object') {\n      try {\n        valueClone = LOGGING_DEEP_CLONE(valueClone);\n      } catch (cloneError) {\n        void cloneError;\n        try {\n          valueClone = Object.assign({}, valueClone);\n        } catch (assignError) {\n          valueClone = snapshot;\n          void assignError;\n        }\n      }\n    }\n\n    const entry = { index };\n    if (valueClone && typeof valueClone === 'object') {\n      entry.value = valueClone;\n      if (typeof valueClone.name === 'string' && valueClone.name) {\n        entry.name = valueClone.name;\n      }\n      if (typeof valueClone.message === 'string' && valueClone.message) {\n        entry.message = valueClone.message;\n      }\n      if (typeof valueClone.code !== 'undefined') {\n        entry.code = valueClone.code;\n      }\n      if (typeof valueClone.status !== 'undefined') {\n        entry.status = valueClone.status;\n      }\n    } else if (typeof valueClone !== 'undefined') {\n      entry.value = valueClone;\n      const coercedMessage = coerceMessage(valueClone);\n      if (coercedMessage) {\n        entry.message = coercedMessage;\n      }\n    } else {\n      entry.value = null;\n    }\n\n    const rawType = rawValue === null ? 'null' : typeof rawValue;\n    if (rawType === 'object' || rawType === 'function') {\n      const ctorName = rawValue && rawValue.constructor && rawValue.constructor.name;\n      entry.argumentType = typeof ctorName === 'string' && ctorName ? ctorName : rawType;\n    } else {\n      entry.argumentType = rawType;\n    }\n\n    const stackSummary = isErrorInstance && typeof rawValue.stack === 'string' && rawValue.stack\n      ? normaliseStackTrace(rawValue.stack)\n      : valueClone && typeof valueClone === 'object' && typeof valueClone.stack === 'string'\n        ? normaliseStackTrace(valueClone.stack)\n        : null;\n\n    if (stackSummary) {\n      if (typeof stackSummary.stack === 'string') {\n        entry.stack = stackSummary.stack;\n      }\n      if (Array.isArray(stackSummary.frames) && stackSummary.frames.length) {\n        entry.frames = stackSummary.frames;\n      }\n      if (stackSummary.truncated) {\n        entry.stackTruncated = true;\n      }\n    }\n\n    safeArrayPush(errorEntries, entry);\n  }\n\n  const contextMeta = { channel: 'console', method: method || 'log' };\n  if (meta && typeof meta === 'object') {\n    const metaKeys = Object.keys(meta);\n    for (let index = 0; index < metaKeys.length; index += 1) {\n      const key = metaKeys[index];\n      try {\n        contextMeta[key] = sanitizeForLog(meta[key]);\n      } catch (metaError) {\n        contextMeta[key] = meta[key];\n        void metaError;\n      }\n    }\n  }\n\n  if (errorEntries.length) {\n    detailPayload = detailPayload || {};\n    const errorIndices = [];\n    for (let index = 0; index < errorEntries.length; index += 1) {\n      const errorEntry = errorEntries[index];\n      errorIndices.push(errorEntry.index);\n    }\n    detailPayload.errors = errorEntries;\n    detailPayload.errorCount = errorEntries.length;\n    detailPayload.errorIndices = errorIndices;\n    detailPayload.primaryError = errorEntries[0];\n\n    contextMeta.errorCount = errorEntries.length;\n    contextMeta.errorIndices = errorIndices;\n\n    const primaryError = errorEntries[0];\n    if (primaryError) {\n      if (typeof primaryError.name === 'string' && primaryError.name) {\n        contextMeta.primaryErrorName = primaryError.name;\n      }\n      if (typeof primaryError.message === 'string' && primaryError.message) {\n        contextMeta.primaryErrorMessage = primaryError.message;\n      }\n      if (typeof primaryError.code !== 'undefined') {\n        contextMeta.primaryErrorCode = primaryError.code;\n      }\n      if (typeof primaryError.status !== 'undefined') {\n        contextMeta.primaryErrorStatus = primaryError.status;\n      }\n      if (primaryError.stack) {\n        contextMeta.primaryErrorHasStack = true;\n      }\n    }\n  }\n\n  const forceStackCapture = method === 'error' || errorEntries.length > 0;\n  const contextOptions = { namespace: 'console', meta: contextMeta };\n  if (forceStackCapture) {\n    contextOptions.captureStack = true;\n  }\n\n  return logInternal(\n    level,\n    message,\n    detailPayload,\n    contextOptions,\n    { silentConsole: true },\n  );\n}\n\nfunction installConsoleProxies() {\n  if (consoleProxyInstalled) {\n    return true;\n  }\n\n  consoleProxyInstallationAttempted = true;\n\n  if (typeof console === 'undefined' || !console) {\n    consoleProxyInstallationFailed = true;\n    return false;\n  }\n\n  try {\n    if (console[CONSOLE_PROXY_FLAG]) {\n      consoleProxyInstalled = true;\n      consoleProxyInstallationFailed = false;\n      return true;\n    }\n  } catch (flagReadError) {\n    void flagReadError;\n  }\n\n  let installedAny = false;\n\n  for (let index = 0; index < CONSOLE_METHODS.length; index += 1) {\n    const method = CONSOLE_METHODS[index];\n    let base = getStoredConsoleFunction(method);\n\n    if (typeof base !== 'function') {\n      try {\n        const candidate = console[method];\n        if (typeof candidate === 'function' && (!candidate || !candidate[CONSOLE_PROXY_FLAG])) {\n          base = candidate;\n        }\n      } catch (resolveError) {\n        base = null;\n        void resolveError;\n      }\n    }\n\n    if (!Object.prototype.hasOwnProperty.call(ORIGINAL_CONSOLE_FUNCTIONS, method) || ORIGINAL_CONSOLE_FUNCTIONS[method] === null) {\n      ORIGINAL_CONSOLE_FUNCTIONS[method] = typeof base === 'function' ? base : ORIGINAL_CONSOLE_FUNCTIONS[method];\n    }\n\n    if (typeof base !== 'function') {\n      continue;\n    }\n\n    const proxy = function consoleProxy() {\n      const argsArray = arrayFromArrayLike(arguments);\n      consoleProxyGuardDepth += 1;\n      try {\n        if (consoleProxyGuardDepth === 1) {\n          const firstArg = argsArray.length ? argsArray[0] : null;\n          const skipCapture = typeof firstArg === 'string' && firstArg.indexOf('cineLogging:') === 0;\n          if (!skipCapture) {\n            try {\n              recordConsoleMessage(method, argsArray, { captured: true });\n            } catch (recordError) {\n              void recordError;\n            }\n          }\n        }\n        return invokeConsoleMethod(method, argsArray);\n      } finally {\n        consoleProxyGuardDepth -= 1;\n        if (consoleProxyGuardDepth < 0) {\n          consoleProxyGuardDepth = 0;\n        }\n      }\n    };\n\n    try {\n      Object.defineProperty(proxy, CONSOLE_PROXY_FLAG, {\n        configurable: true,\n        enumerable: false,\n        writable: false,\n        value: true,\n      });\n    } catch (defineError) {\n      proxy[CONSOLE_PROXY_FLAG] = true;\n      void defineError;\n    }\n\n    try {\n      console[method] = proxy;\n      installedAny = true;\n    } catch (assignError) {\n      void assignError;\n    }\n  }\n\n  if (installedAny) {\n    consoleProxyInstalled = true;\n    consoleProxyInstallationFailed = false;\n    try {\n      Object.defineProperty(console, CONSOLE_PROXY_FLAG, {\n        configurable: true,\n        enumerable: false,\n        writable: false,\n        value: true,\n      });\n    } catch (flagError) {\n      try {\n        console[CONSOLE_PROXY_FLAG] = true;\n      } catch (assignFlagError) {\n        void assignFlagError;\n      }\n      void flagError;\n    }\n  } else {\n    consoleProxyInstallationFailed = true;\n  }\n\n  return consoleProxyInstalled;\n}\n\nfunction removeConsoleProxies() {\n  if (!consoleProxyInstalled) {\n    return false;\n  }\n\n  if (typeof console === 'undefined' || !console) {\n    consoleProxyInstalled = false;\n    return false;\n  }\n\n  let restoredAny = false;\n\n  for (let index = 0; index < CONSOLE_METHODS.length; index += 1) {\n    const method = CONSOLE_METHODS[index];\n    const original = ORIGINAL_CONSOLE_FUNCTIONS[method];\n    try {\n      if (typeof original === 'function') {\n        console[method] = original;\n        restoredAny = true;\n      } else if (method !== 'log' && method !== 'info') {\n        delete console[method];\n      }\n    } catch (restoreError) {\n      void restoreError;\n    }\n  }\n\n  try {\n    if (console && console[CONSOLE_PROXY_FLAG]) {\n      if (typeof Object.defineProperty === 'function') {\n        Object.defineProperty(console, CONSOLE_PROXY_FLAG, {\n          configurable: true,\n          enumerable: false,\n          writable: true,\n          value: false,\n        });\n      } else {\n        console[CONSOLE_PROXY_FLAG] = false;\n      }\n    }\n  } catch (flagError) {\n    void flagError;\n  }\n\n  consoleProxyInstalled = false;\n  return restoredAny;\n}\n\nfunction syncConsoleCaptureState() {\n  if (!activeConfig.captureConsole) {\n    if (consoleProxyInstalled) {\n      removeConsoleProxies();\n    }\n    if (lastConsoleCaptureState !== 'disabled') {\n      logInternal(\n        'info',\n        'Console output capture disabled',\n        buildConsoleCaptureDetail({ status: 'disabled' }),\n        { namespace: 'logging', meta: { channel: 'console', lifecycle: 'sync' } },\n        { silentConsole: true },\n      );\n      lastConsoleCaptureState = 'disabled';\n    }\n    consoleProxyWarningIssued = false;\n    consoleProxyInstallationFailed = false;\n    return true;\n  }\n\n  const installed = installConsoleProxies();\n  if (!installed) {\n    if (!consoleProxyWarningIssued) {\n      const reason = typeof console === 'undefined' || !console\n        ? 'console-unavailable'\n        : 'installation-failed';\n      logInternal(\n        'warn',\n        'Console output capture failed',\n        buildConsoleCaptureDetail({ status: 'failed', reason }),\n        { namespace: 'logging', meta: { channel: 'console', lifecycle: 'sync' } },\n        { silentConsole: true },\n      );\n      safeWarn('cineLogging: Unable to capture console output for diagnostics.');\n      consoleProxyWarningIssued = true;\n    }\n    lastConsoleCaptureState = 'failed';\n    return false;\n  }\n\n  consoleProxyWarningIssued = false;\n\n  if (lastConsoleCaptureState !== 'enabled') {\n    logInternal(\n      'info',\n      'Console output capture enabled',\n      buildConsoleCaptureDetail({ status: 'enabled' }),\n      { namespace: 'logging', meta: { channel: 'console', lifecycle: 'sync' } },\n      { silentConsole: true },\n    );\n    lastConsoleCaptureState = 'enabled';\n  }\n\n  return true;\n}\n\nfunction isConsoleCaptureActive() {\n  return Boolean(activeConfig.captureConsole) && consoleProxyInstalled === true;\n}\n\nfunction buildConsoleCaptureDetail(overrides) {\n  const detail = {\n    configured: activeConfig.captureConsole === true,\n    installed: consoleProxyInstalled === true,\n    attempted: consoleProxyInstallationAttempted === true,\n    failed: consoleProxyInstallationFailed === true,\n  };\n\n  if (typeof console === 'undefined' || !console) {\n    detail.consoleAvailable = false;\n  }\n\n  if (overrides && typeof overrides === 'object') {\n    const overrideKeys = Object.keys(overrides);\n    for (let index = 0; index < overrideKeys.length; index += 1) {\n      const key = overrideKeys[index];\n      detail[key] = overrides[key];\n    }\n  }\n\n  return detail;\n}\n\nfunction enableConsoleCapture(options) {\n  const setOptions = options && typeof options === 'object' ? options : null;\n  setConfig({ captureConsole: true }, setOptions || undefined);\n  return isConsoleCaptureActive();\n}\n\nfunction disableConsoleCapture(options) {\n  const setOptions = options && typeof options === 'object' ? options : null;\n  setConfig({ captureConsole: false }, setOptions || undefined);\n  return isConsoleCaptureActive();\n}\n\nfunction shouldCaptureOrigin(level, detail, context) {\n  const override = context && Object.prototype.hasOwnProperty.call(context, 'captureStack')\n    ? context.captureStack\n    : null;\n\n  if (override === true) {\n    return true;\n  }\n\n  if (override === false) {\n    return false;\n  }\n\n  if (activeConfig.stackTraces !== true) {\n    return false;\n  }\n\n  if (detail instanceof Error) {\n    return true;\n  }\n\n  return getLevelPriority(level) >= getLevelPriority('warn');\n}\n\nfunction captureLogOrigin(level, message, detail, context) {\n  if (!shouldCaptureOrigin(level, detail, context)) {\n    return null;\n  }\n\n  let stackSource = 'generated';\n  let stackValue = '';\n\n  if (detail instanceof Error) {\n    const detailStack = detail.stack;\n    if (typeof detailStack === 'string' && detailStack) {\n      stackSource = 'detail';\n      stackValue = detailStack;\n    }\n  }\n\n  if (!stackValue) {\n    try {\n      const stackMessage = typeof message === 'string' && message\n        ? message\n        : `Log ${level}`;\n      const captureError = new Error(stackMessage);\n      if (typeof Error.captureStackTrace === 'function') {\n        Error.captureStackTrace(captureError, captureLogOrigin);\n      }\n      if (typeof captureError.stack === 'string' && captureError.stack) {\n        stackValue = captureError.stack;\n      }\n    } catch (stackError) {\n      void stackError;\n    }\n  }\n\n  const summary = normaliseStackTrace(stackValue);\n  if (!summary) {\n    return null;\n  }\n\n  const origin = {\n    source: stackSource,\n    stack: summary.stack,\n    truncated: summary.truncated,\n  };\n\n  if (Array.isArray(summary.frames) && summary.frames.length) {\n    origin.frames = summary.frames;\n  }\n\n  return freezeDeep(origin);\n}\n\nfunction logInternal(level, message, detail, context, options) {\n  const normalizedLevel = normalizeLevel(level, 'info');\n  const timestamp = Date.now();\n  let isoTimestamp = '';\n  try {\n    isoTimestamp = new Date(timestamp).toISOString();\n  } catch (error) {\n    void error;\n    isoTimestamp = String(timestamp);\n  }\n\n  const captureContext = context && typeof context === 'object' ? context : null;\n  const origin = captureLogOrigin(normalizedLevel, message, detail, captureContext);\n\n  const namespace = captureContext && typeof captureContext.namespace === 'string' && captureContext.namespace\n    ? context.namespace\n    : null;\n\n  const meta = captureContext && typeof captureContext.meta !== 'undefined'\n    ? sanitizeForLog(captureContext.meta)\n    : null;\n\n  const sanitizedDetail = typeof detail === 'undefined'\n    ? null\n    : sanitizeForLog(detail);\n\n  const entry = freezeDeep({\n    id: createEntryId(timestamp),\n    level: normalizedLevel,\n    message: coerceMessage(message),\n    namespace,\n    detail: sanitizedDetail,\n    meta,\n    timestamp,\n    isoTimestamp,\n    origin,\n  });\n\n  applyLevelCounterDelta(emittedLevelCounters, normalizedLevel, 1);\n\n  if (shouldRecord(normalizedLevel)) {\n    appendEntry(entry);\n  }\n\n  const internalOptions = options && typeof options === 'object' ? options : null;\n\n  if (shouldOutputToConsole(normalizedLevel) && (!internalOptions || internalOptions.silentConsole !== true)) {\n    const descriptor = LOG_LEVEL_MAP[normalizedLevel] || LOG_LEVEL_MAP.info;\n    const methodName = descriptor.consoleMethod;\n    const prefixParts = ['[cine]'];\n    if (namespace) {\n      prefixParts.push(`[${namespace}]`);\n    }\n    prefixParts.push(entry.isoTimestamp);\n    const prefix = prefixParts.join(' ');\n    const consoleArgs = [`${prefix} ${entry.message}`];\n    if (detail !== undefined) {\n      safeArrayPush(consoleArgs, detail);\n    } else if (entry.detail !== null) {\n      safeArrayPush(consoleArgs, entry.detail);\n    }\n    if (entry.meta !== null) {\n      safeArrayPush(consoleArgs, { meta: entry.meta });\n    }\n    if (origin) {\n      safeArrayPush(consoleArgs, { origin });\n    }\n    invokeConsoleMethod(methodName, consoleArgs);\n  }\n\n  return entry;\n}\n\nfunction debug(message, detail, context) {\n  return logInternal('debug', message, detail, context);\n}\n\nfunction info(message, detail, context) {\n  return logInternal('info', message, detail, context);\n}\n\nfunction warn(message, detail, context) {\n  return logInternal('warn', message, detail, context);\n}\n\nfunction error(message, detail, context) {\n  return logInternal('error', message, detail, context);\n}\n\nfunction getConfigSnapshot() {\n  return freezeDeep({\n    level: activeConfig.level,\n    historyLevel: activeConfig.historyLevel,\n    historyLimit: activeConfig.historyLimit,\n    consoleOutput: activeConfig.consoleOutput,\n    persistSession: activeConfig.persistSession,\n    captureGlobalErrors: activeConfig.captureGlobalErrors,\n    captureConsole: activeConfig.captureConsole,\n    stackTraces: activeConfig.stackTraces,\n  });\n}\n\nfunction getHistory(options) {\n  const limit = options && typeof options.limit !== 'undefined' ? options.limit : undefined;\n  return getHistorySnapshot(limit);\n}\n\nfunction cloneLastDropSnapshot() {\n  if (!lastHistoryDrop) {\n    return null;\n  }\n\n  return freezeDeep({\n    count: typeof lastHistoryDrop.count === 'number' ? lastHistoryDrop.count : 0,\n    limit: typeof lastHistoryDrop.limit === 'number'\n      ? lastHistoryDrop.limit\n      : getEffectiveHistoryLimit(),\n    source: typeof lastHistoryDrop.source === 'string' ? lastHistoryDrop.source : 'enforce',\n    timestamp:\n      typeof lastHistoryDrop.timestamp === 'number'\n        ? lastHistoryDrop.timestamp\n        : null,\n    isoTimestamp: typeof lastHistoryDrop.isoTimestamp === 'string'\n      ? lastHistoryDrop.isoTimestamp\n      : null,\n    oldestEntryId: typeof lastHistoryDrop.oldestEntryId === 'string'\n      ? lastHistoryDrop.oldestEntryId\n      : null,\n    oldestEntryTimestamp: typeof lastHistoryDrop.oldestEntryTimestamp === 'number'\n      ? lastHistoryDrop.oldestEntryTimestamp\n      : null,\n    oldestEntryIsoTimestamp: typeof lastHistoryDrop.oldestEntryIsoTimestamp === 'string'\n      ? lastHistoryDrop.oldestEntryIsoTimestamp\n      : null,\n    newestEntryId: typeof lastHistoryDrop.newestEntryId === 'string'\n      ? lastHistoryDrop.newestEntryId\n      : null,\n    newestEntryTimestamp: typeof lastHistoryDrop.newestEntryTimestamp === 'number'\n      ? lastHistoryDrop.newestEntryTimestamp\n      : null,\n    newestEntryIsoTimestamp: typeof lastHistoryDrop.newestEntryIsoTimestamp === 'string'\n      ? lastHistoryDrop.newestEntryIsoTimestamp\n      : null,\n    levels: lastHistoryDrop.levels\n      ? freezeLevelSummary(lastHistoryDrop.levels)\n      : freezeLevelSummary(createLevelCounters()),\n  });\n}\n\nfunction getStats() {\n  return freezeDeep({\n    runtimeEntries: runtimeEntryCount,\n    retainedEntries: logHistory.length,\n    droppedEntries: totalEntriesDropped,\n    historyLimit: getEffectiveHistoryLimit(),\n    lastDrop: cloneLastDropSnapshot(),\n    levels: freezeDeep({\n      emitted: freezeLevelSummary(emittedLevelCounters),\n      retained: freezeLevelSummary(retainedLevelCounters),\n      dropped: freezeLevelSummary(droppedLevelCounters),\n    }),\n    consoleCapture: freezeDeep({\n      configured: activeConfig.captureConsole === true,\n      installed: consoleProxyInstalled,\n      attempted: consoleProxyInstallationAttempted,\n      failed: consoleProxyInstallationFailed,\n    }),\n  });\n}\n\nfunction clearHistory(options) {\n  logHistory.length = 0;\n  resetLevelCounters(retainedLevelCounters);\n  if (!options || options.persist !== false) {\n    persistHistorySafe();\n  }\n  return true;\n}\n\nfunction subscribe(listener) {\n  if (typeof listener !== 'function') {\n    return function unsubscribeNoop() {\n      return false;\n    };\n  }\n  logSubscribers.add(listener);\n  return function unsubscribe() {\n    logSubscribers.delete(listener);\n    return true;\n  };\n}\n\nfunction subscribeConfig(listener) {\n  if (typeof listener !== 'function') {\n    return function unsubscribeConfigNoop() {\n      return false;\n    };\n  }\n  configSubscribers.add(listener);\n  return function unsubscribeConfig() {\n    configSubscribers.delete(listener);\n    return true;\n  };\n}\n\nfunction mergeMeta(baseMeta, meta) {\n  if (!baseMeta && !meta) {\n    return null;\n  }\n\n  if (!baseMeta) {\n    return sanitizeForLog(meta);\n  }\n\n  if (!meta) {\n    return baseMeta;\n  }\n\n  if (typeof baseMeta !== 'object' || typeof meta !== 'object') {\n    return sanitizeForLog(meta);\n  }\n\n  const merged = {};\n  const baseKeys = Object.keys(baseMeta);\n  for (let index = 0; index < baseKeys.length; index += 1) {\n    const key = baseKeys[index];\n    merged[key] = baseMeta[key];\n  }\n  const metaKeys = Object.keys(meta);\n  for (let index = 0; index < metaKeys.length; index += 1) {\n    const key = metaKeys[index];\n    merged[key] = sanitizeForLog(meta[key]);\n  }\n  return merged;\n}\n\nfunction createLogger(namespace, options) {\n  const normalizedNamespace = typeof namespace === 'string' && namespace.trim()\n    ? namespace.trim()\n    : 'app';\n\n  const baseMeta = options && typeof options.meta !== 'undefined'\n    ? sanitizeForLog(options.meta)\n    : null;\n\n  function logWithNamespace(level, message, detail, meta) {\n    const mergedMeta = mergeMeta(baseMeta, meta);\n    return logInternal(level, message, detail, {\n      namespace: normalizedNamespace,\n      meta: mergedMeta,\n    });\n  }\n\n  return freezeDeep({\n    namespace: normalizedNamespace,\n    log(level, message, detail, meta) {\n      return logWithNamespace(level, message, detail, meta);\n    },\n    debug(message, detail, meta) {\n      return logWithNamespace('debug', message, detail, meta);\n    },\n    info(message, detail, meta) {\n      return logWithNamespace('info', message, detail, meta);\n    },\n    warn(message, detail, meta) {\n      return logWithNamespace('warn', message, detail, meta);\n    },\n    error(message, detail, meta) {\n      return logWithNamespace('error', message, detail, meta);\n    },\n    getConfig: getConfigSnapshot,\n    isLevelEnabled(level, optionOverrides) {\n      return isLevelEnabled(level, optionOverrides);\n    },\n    getLevelState(level) {\n      return getLevelState(level);\n    },\n  });\n}\n\nfunction markEventHandled(event) {\n  if (!event || (typeof event !== 'object' && typeof event !== 'function')) {\n    return false;\n  }\n\n  const flag = ERROR_EVENT_FLAG;\n\n  try {\n    if (typeof flag === 'symbol') {\n      if (event[flag]) {\n        return true;\n      }\n      event[flag] = true;\n      return false;\n    }\n\n    if (Object.prototype.hasOwnProperty.call(event, flag) && event[flag]) {\n      return true;\n    }\n\n    Object.defineProperty(event, flag, {\n      configurable: true,\n      enumerable: false,\n      writable: true,\n      value: true,\n    });\n    return false;\n  } catch (error) {\n    void error;\n  }\n\n  return false;\n}\n\nfunction handleGlobalError(event) {\n  if (!activeConfig.captureGlobalErrors) {\n    return;\n  }\n\n  if (markEventHandled(event)) {\n    return;\n  }\n\n  const detail = {\n    message: event && typeof event.message === 'string' ? event.message : '',\n    filename: event ? event.filename || event.fileName || null : null,\n    lineno: event ? event.lineno || event.lineNumber || null : null,\n    colno: event ? event.colno || event.columnNumber || null : null,\n    error: event && event.error ? sanitizeForLog(event.error) : null,\n  };\n\n  if (event && typeof event.preventDefault === 'function' && event.defaultPrevented) {\n    detail.defaultPrevented = true;\n  }\n\n  logInternal('error', 'Global error captured', detail, { namespace: 'global' });\n}\n\nfunction handleUnhandledRejection(event) {\n  if (!activeConfig.captureGlobalErrors) {\n    return;\n  }\n\n  if (markEventHandled(event)) {\n    return;\n  }\n\n  const detail = {\n    reason: event ? sanitizeForLog(event.reason) : null,\n  };\n\n  if (event && event.promise) {\n    detail.promiseState = '[Promise]';\n  }\n\n  if (event && typeof event.preventDefault === 'function' && event.defaultPrevented) {\n    detail.defaultPrevented = true;\n  }\n\n  logInternal('error', 'Unhandled promise rejection captured', detail, { namespace: 'global' });\n}\n\nfunction markTargetAttached(target) {\n  if (!target || (typeof target !== 'object' && typeof target !== 'function')) {\n    return false;\n  }\n\n  if (attachedErrorTargets instanceof WeakSet) {\n    if (attachedErrorTargets.has(target)) {\n      return true;\n    }\n    attachedErrorTargets.add(target);\n    return false;\n  }\n\n  const list = attachedErrorTargets;\n  const index = list.indexOf(target);\n  if (index !== -1) {\n    return true;\n  }\n  list.push(target);\n  return false;\n}\n\nfunction attachGlobalErrorListeners() {\n  if (!activeConfig.captureGlobalErrors) {\n    return;\n  }\n\n  const scopes = fallbackCollectCandidateScopes(GLOBAL_SCOPE);\n  for (let index = 0; index < scopes.length; index += 1) {\n    const scope = scopes[index];\n    if (!scope || typeof scope.addEventListener !== 'function') {\n      continue;\n    }\n\n    if (markTargetAttached(scope)) {\n      continue;\n    }\n\n    try {\n      scope.addEventListener('error', handleGlobalError, true);\n    } catch (error) {\n      void error;\n    }\n\n    try {\n      scope.addEventListener('unhandledrejection', handleUnhandledRejection, true);\n    } catch (error) {\n      void error;\n    }\n  }\n}\n\nfunction applyConfig(overrides) {\n  if (!overrides || typeof overrides !== 'object') {\n    return { changed: false, captureChanged: false, limitChanged: false };\n  }\n\n  let changed = false;\n  let captureChanged = false;\n  let limitChanged = false;\n  let consoleCaptureChanged = false;\n\n  const nextPersistSession = Object.prototype.hasOwnProperty.call(overrides, 'persistSession')\n    ? booleanFromValue(overrides.persistSession, activeConfig.persistSession)\n    : activeConfig.persistSession;\n\n  if (Object.prototype.hasOwnProperty.call(overrides, 'level')) {\n    const nextLevel = normalizeLevel(overrides.level, activeConfig.level);\n    if (nextLevel !== activeConfig.level) {\n      activeConfig.level = nextLevel;\n      changed = true;\n    }\n  }\n\n  if (Object.prototype.hasOwnProperty.call(overrides, 'historyLevel')) {\n    const nextHistoryLevel = normalizeLevel(overrides.historyLevel, activeConfig.historyLevel);\n    if (nextHistoryLevel !== activeConfig.historyLevel) {\n      activeConfig.historyLevel = nextHistoryLevel;\n      changed = true;\n    }\n  }\n\n  if (Object.prototype.hasOwnProperty.call(overrides, 'historyLimit')) {\n    const nextLimit = clampHistoryLimit(overrides.historyLimit, {\n      allowReducedMin: nextPersistSession === false,\n    });\n    if (nextLimit !== activeConfig.historyLimit) {\n      activeConfig.historyLimit = nextLimit;\n      changed = true;\n      limitChanged = true;\n    }\n  }\n\n  if (Object.prototype.hasOwnProperty.call(overrides, 'consoleOutput')) {\n    const nextConsole = booleanFromValue(overrides.consoleOutput, activeConfig.consoleOutput);\n    if (nextConsole !== activeConfig.consoleOutput) {\n      activeConfig.consoleOutput = nextConsole;\n      changed = true;\n    }\n  }\n\n  if (Object.prototype.hasOwnProperty.call(overrides, 'persistSession')) {\n    if (nextPersistSession !== activeConfig.persistSession) {\n      activeConfig.persistSession = nextPersistSession;\n      changed = true;\n    }\n  }\n\n  if (activeConfig.persistSession && activeConfig.historyLimit < HISTORY_MIN_LIMIT) {\n    activeConfig.historyLimit = HISTORY_MIN_LIMIT;\n    changed = true;\n    limitChanged = true;\n  }\n\n  if (Object.prototype.hasOwnProperty.call(overrides, 'captureGlobalErrors')) {\n    const nextCapture = booleanFromValue(overrides.captureGlobalErrors, activeConfig.captureGlobalErrors);\n    if (nextCapture !== activeConfig.captureGlobalErrors) {\n      activeConfig.captureGlobalErrors = nextCapture;\n      changed = true;\n      captureChanged = true;\n    }\n  }\n\n  if (Object.prototype.hasOwnProperty.call(overrides, 'captureConsole')) {\n    const nextConsoleCapture = booleanFromValue(overrides.captureConsole, activeConfig.captureConsole);\n    if (nextConsoleCapture !== activeConfig.captureConsole) {\n      activeConfig.captureConsole = nextConsoleCapture;\n      changed = true;\n      consoleCaptureChanged = true;\n    }\n  }\n\n  if (Object.prototype.hasOwnProperty.call(overrides, 'stackTraces')) {\n    const nextStackTraces = booleanFromValue(overrides.stackTraces, activeConfig.stackTraces);\n    if (nextStackTraces !== activeConfig.stackTraces) {\n      activeConfig.stackTraces = nextStackTraces;\n      changed = true;\n    }\n  }\n\n  return { changed, captureChanged, limitChanged, consoleCaptureChanged };\n}\n\nfunction setConfig(overrides, options) {\n  const previousCapture = activeConfig.captureGlobalErrors;\n  const previousConsoleCapture = activeConfig.captureConsole;\n  const result = applyConfig(overrides);\n\n  if (result.limitChanged) {\n    enforceHistoryLimit({ source: 'config' });\n  }\n\n  if (result.changed && (!options || options.persist !== false)) {\n    persistConfigSafe();\n    persistHistorySafe();\n  }\n\n  if (!activeConfig.persistSession) {\n    clearStoredHistory();\n  }\n\n  if (!previousCapture && activeConfig.captureGlobalErrors) {\n    attachGlobalErrorListeners();\n  }\n\n  if (result.consoleCaptureChanged || previousConsoleCapture !== activeConfig.captureConsole) {\n    syncConsoleCaptureState();\n  }\n\n  if (result.changed) {\n    notifyConfigSubscribers(getConfigSnapshot());\n  }\n\n  return getConfigSnapshot();\n}\n\nfunction resolveConfigPresetFromScopes() {\n  const scopes = fallbackCollectCandidateScopes(GLOBAL_SCOPE);\n  const keys = ['__cineLoggingConfig', '__CINE_LOGGING_CONFIG', 'cineLoggingConfig'];\n\n  for (let scopeIndex = 0; scopeIndex < scopes.length; scopeIndex += 1) {\n    const scope = scopes[scopeIndex];\n    if (!scope || (typeof scope !== 'object' && typeof scope !== 'function')) {\n      continue;\n    }\n\n    for (let keyIndex = 0; keyIndex < keys.length; keyIndex += 1) {\n      const key = keys[keyIndex];\n      let value;\n      try {\n        value = scope[key];\n      } catch (error) {\n        void error;\n        value = null;\n      }\n      if (value && typeof value === 'object') {\n        return value;\n      }\n    }\n  }\n\n  return null;\n}\n\nfunction applyConfigFromStorage() {\n  const storage = getSessionStorage();\n  if (!storage) {\n    return;\n  }\n\n  let raw = '';\n  try {\n    raw = storage.getItem(CONFIG_STORAGE_KEY) || '';\n  } catch (error) {\n    void error;\n    return;\n  }\n\n  if (!raw) {\n    return;\n  }\n\n  try {\n    const parsed = JSON.parse(raw);\n    applyConfig(parsed);\n  } catch (error) {\n    safeWarn('cineLogging: Unable to restore logging config from storage', error);\n  }\n}\n\nfunction applyConfigFromQuery() {\n  if (!GLOBAL_SCOPE || !GLOBAL_SCOPE.location) {\n    return;\n  }\n\n  let search = '';\n  try {\n    search = GLOBAL_SCOPE.location.search || '';\n  } catch (error) {\n    void error;\n    return;\n  }\n\n  if (typeof search !== 'string' || !search) {\n    return;\n  }\n\n  let params = null;\n  if (typeof URLSearchParams === 'function') {\n    try {\n      params = new URLSearchParams(search);\n    } catch (error) {\n      void error;\n    }\n  }\n\n  const updates = {};\n  let hasUpdates = false;\n\n  function assignUpdate(key, value) {\n    updates[key] = value;\n    hasUpdates = true;\n  }\n\n  if (params) {\n    if (params.has('cineLogLevel')) {\n      assignUpdate('level', params.get('cineLogLevel'));\n    }\n    if (params.has('cineLogHistoryLevel')) {\n      assignUpdate('historyLevel', params.get('cineLogHistoryLevel'));\n    }\n    if (params.has('cineLogLimit')) {\n      assignUpdate('historyLimit', params.get('cineLogLimit'));\n    }\n    if (params.has('cineLogConsole')) {\n      assignUpdate('consoleOutput', params.get('cineLogConsole'));\n    }\n    if (params.has('cineLogPersist')) {\n      assignUpdate('persistSession', params.get('cineLogPersist'));\n    }\n    if (params.has('cineLogCapture')) {\n      assignUpdate('captureGlobalErrors', params.get('cineLogCapture'));\n    }\n    if (params.has('cineLogConsoleCapture')) {\n      assignUpdate('captureConsole', params.get('cineLogConsoleCapture'));\n    }\n    if (params.has('cineLogStackTraces')) {\n      assignUpdate('stackTraces', params.get('cineLogStackTraces'));\n    }\n  } else {\n    const query = search.charAt(0) === '?' ? search.slice(1) : search;\n    const parts = query.split('&');\n    for (let index = 0; index < parts.length; index += 1) {\n      const part = parts[index];\n      if (!part) {\n        continue;\n      }\n      const eqIndex = part.indexOf('=');\n      const key = eqIndex === -1 ? decodeURIComponent(part) : decodeURIComponent(part.slice(0, eqIndex));\n      const value = eqIndex === -1 ? '' : decodeURIComponent(part.slice(eqIndex + 1));\n      if (key === 'cineLogLevel') {\n        assignUpdate('level', value);\n      } else if (key === 'cineLogHistoryLevel') {\n        assignUpdate('historyLevel', value);\n      } else if (key === 'cineLogLimit') {\n        assignUpdate('historyLimit', value);\n      } else if (key === 'cineLogConsole') {\n        assignUpdate('consoleOutput', value);\n      } else if (key === 'cineLogPersist') {\n        assignUpdate('persistSession', value);\n      } else if (key === 'cineLogCapture') {\n        assignUpdate('captureGlobalErrors', value);\n      } else if (key === 'cineLogConsoleCapture') {\n        assignUpdate('captureConsole', value);\n      } else if (key === 'cineLogStackTraces') {\n        assignUpdate('stackTraces', value);\n      }\n    }\n  }\n\n  if (hasUpdates) {\n    applyConfig(updates);\n  }\n}\n\nfunction normaliseStoredEntry(entry) {\n  if (!entry || typeof entry !== 'object') {\n    return null;\n  }\n\n  const normalizedLevel = normalizeLevel(entry.level, 'info');\n  const timestamp = typeof entry.timestamp === 'number' && Number.isFinite(entry.timestamp)\n    ? entry.timestamp\n    : Date.now();\n\n  let isoTimestamp = '';\n  if (typeof entry.isoTimestamp === 'string' && entry.isoTimestamp) {\n    isoTimestamp = entry.isoTimestamp;\n  } else {\n    try {\n      isoTimestamp = new Date(timestamp).toISOString();\n    } catch (error) {\n      void error;\n      isoTimestamp = String(timestamp);\n    }\n  }\n\n  const normalizedMessage = typeof entry.message === 'string'\n    ? entry.message\n    : coerceMessage(entry.message);\n\n  const normalizedNamespace = typeof entry.namespace === 'string' && entry.namespace\n    ? entry.namespace\n    : null;\n\n  const normalizedId = typeof entry.id === 'string' && entry.id\n    ? entry.id\n    : createEntryId(timestamp);\n\n  return freezeDeep({\n    id: normalizedId,\n    level: normalizedLevel,\n    message: normalizedMessage,\n    namespace: normalizedNamespace,\n    detail: typeof entry.detail === 'undefined' ? null : sanitizeForLog(entry.detail),\n    meta: typeof entry.meta === 'undefined' ? null : sanitizeForLog(entry.meta),\n    timestamp,\n    isoTimestamp,\n    origin: typeof entry.origin === 'undefined' ? null : normaliseOriginSnapshot(entry.origin),\n  });\n}\n\nfunction getGlobalNavigator() {\n  if (GLOBAL_SCOPE && typeof GLOBAL_SCOPE.navigator === 'object' && GLOBAL_SCOPE.navigator) {\n    return GLOBAL_SCOPE.navigator;\n  }\n  if (typeof navigator !== 'undefined' && navigator) {\n    return navigator;\n  }\n  if (typeof globalThis !== 'undefined' && globalThis && typeof globalThis.navigator === 'object') {\n    return globalThis.navigator;\n  }\n  return null;\n}\n\nfunction getNavigatorServiceWorker() {\n  const nav = getGlobalNavigator();\n  if (!nav || typeof nav !== 'object') {\n    return null;\n  }\n  if (!nav.serviceWorker) {\n    return null;\n  }\n  return nav.serviceWorker;\n}\n\nfunction markServiceWorkerEntrySeen(id) {\n  if (!id) {\n    return true;\n  }\n\n  if (serviceWorkerBridgeState.seenIds) {\n    if (serviceWorkerBridgeState.seenIds.has(id)) {\n      return false;\n    }\n    serviceWorkerBridgeState.seenIds.add(id);\n    return true;\n  }\n\n  if (Array.isArray(serviceWorkerBridgeState.fallbackSeenIds)) {\n    if (serviceWorkerBridgeState.fallbackSeenIds.indexOf(id) !== -1) {\n      return false;\n    }\n    serviceWorkerBridgeState.fallbackSeenIds.push(id);\n    return true;\n  }\n\n  return true;\n}\n\nfunction mergeServiceWorkerEntryMeta(entry, snapshotMeta) {\n  const merged = {};\n\n  if (entry && typeof entry.meta !== 'undefined') {\n    if (entry.meta && typeof entry.meta === 'object') {\n      for (const key in entry.meta) {\n        if (Object.prototype.hasOwnProperty.call(entry.meta, key)) {\n          merged[key] = entry.meta[key];\n        }\n      }\n    } else {\n      merged.value = entry.meta;\n    }\n  }\n\n  const channel = entry && typeof entry.channel === 'string' && entry.channel\n    ? entry.channel\n    : merged.channel;\n  if (channel) {\n    merged.channel = channel;\n  } else {\n    merged.channel = 'service-worker';\n  }\n\n  if (snapshotMeta && typeof snapshotMeta === 'object') {\n    if (snapshotMeta.cacheName && !merged.cacheName) {\n      merged.cacheName = snapshotMeta.cacheName;\n    }\n    if (snapshotMeta.cacheVersion && !merged.cacheVersion) {\n      merged.cacheVersion = snapshotMeta.cacheVersion;\n    }\n    if (typeof snapshotMeta.generatedAt === 'number' && Number.isFinite(snapshotMeta.generatedAt)) {\n      if (!merged.snapshotTimestamp) {\n        merged.snapshotTimestamp = snapshotMeta.generatedAt;\n      }\n    }\n    if (typeof snapshotMeta.historyLength === 'number' && Number.isFinite(snapshotMeta.historyLength)) {\n      if (!merged.snapshotSize) {\n        merged.snapshotSize = snapshotMeta.historyLength;\n      }\n    }\n  }\n\n  return merged;\n}\n\nfunction importServiceWorkerLogEntries(entries, snapshotMeta) {\n  if (!Array.isArray(entries) || !entries.length) {\n    return;\n  }\n\n  for (let index = 0; index < entries.length; index += 1) {\n    const rawEntry = entries[index];\n    if (!rawEntry || typeof rawEntry !== 'object') {\n      continue;\n    }\n\n    const entryId = typeof rawEntry.id === 'string' && rawEntry.id ? rawEntry.id : null;\n    if (!markServiceWorkerEntrySeen(entryId)) {\n      continue;\n    }\n\n    const origin = rawEntry.origin && typeof rawEntry.origin === 'object'\n      ? rawEntry.origin\n      : { runtime: 'service-worker' };\n\n    const normalized = normaliseStoredEntry({\n      id: entryId || undefined,\n      level: rawEntry.level,\n      message: rawEntry.message,\n      namespace: typeof rawEntry.namespace === 'string' && rawEntry.namespace\n        ? rawEntry.namespace\n        : 'service-worker',\n      detail: typeof rawEntry.detail === 'undefined' ? null : rawEntry.detail,\n      meta: mergeServiceWorkerEntryMeta(rawEntry, snapshotMeta),\n      timestamp: rawEntry.timestamp,\n      isoTimestamp: rawEntry.isoTimestamp,\n      origin,\n    });\n\n    if (normalized) {\n      appendEntry(normalized);\n    }\n  }\n}\n\nfunction finalizeServiceWorkerLogRequest(requestId) {\n  if (!serviceWorkerBridgeState.requestInFlight) {\n    return;\n  }\n\n  if (requestId && serviceWorkerBridgeState.lastRequestId && requestId !== serviceWorkerBridgeState.lastRequestId) {\n    return;\n  }\n\n  serviceWorkerBridgeState.requestInFlight = false;\n  serviceWorkerBridgeState.lastRequestId = null;\n\n  if (serviceWorkerBridgeState.requestTimer && typeof clearTimeout === 'function') {\n    try {\n      clearTimeout(serviceWorkerBridgeState.requestTimer);\n    } catch (error) {\n      void error;\n    }\n  }\n\n  serviceWorkerBridgeState.requestTimer = null;\n}\n\nfunction scheduleServiceWorkerLogPoll() {\n  if (serviceWorkerBridgeState.broadcastChannel || serviceWorkerBridgeState.broadcastFailed) {\n    return;\n  }\n\n  if (serviceWorkerBridgeState.pollTimer || typeof setTimeout !== 'function') {\n    return;\n  }\n\n  try {\n    serviceWorkerBridgeState.pollTimer = setTimeout(() => {\n      serviceWorkerBridgeState.pollTimer = null;\n      requestServiceWorkerLogSnapshot('poll');\n    }, SERVICE_WORKER_LOG_POLL_INTERVAL);\n  } catch (error) {\n    void error;\n  }\n}\n\nfunction ensureServiceWorkerBroadcastChannel() {\n  if (serviceWorkerBridgeState.broadcastFailed) {\n    return null;\n  }\n\n  if (serviceWorkerBridgeState.broadcastChannel) {\n    return serviceWorkerBridgeState.broadcastChannel;\n  }\n\n  if (typeof BroadcastChannel !== 'function') {\n    serviceWorkerBridgeState.broadcastFailed = true;\n    return null;\n  }\n\n  try {\n    const channel = new BroadcastChannel(SERVICE_WORKER_LOG_CHANNEL);\n    channel.addEventListener('message', handleServiceWorkerLogMessage);\n    serviceWorkerBridgeState.broadcastChannel = channel;\n    if (serviceWorkerBridgeState.pollTimer && typeof clearTimeout === 'function') {\n      try {\n        clearTimeout(serviceWorkerBridgeState.pollTimer);\n      } catch (error) {\n        void error;\n      }\n      serviceWorkerBridgeState.pollTimer = null;\n    }\n    return channel;\n  } catch (error) {\n    serviceWorkerBridgeState.broadcastFailed = true;\n    safeWarn('cineLogging: Unable to open service worker diagnostics channel', error);\n    return null;\n  }\n}\n\nfunction handleServiceWorkerLogMessage(event) {\n  if (!event) {\n    return;\n  }\n\n  let data = null;\n  try {\n    data = event.data || null;\n  } catch (error) {\n    void error;\n    data = null;\n  }\n\n  if (!data || typeof data !== 'object') {\n    return;\n  }\n\n  if (data.type === SERVICE_WORKER_LOG_ENTRY_TYPE) {\n    importServiceWorkerLogEntries([data.entry], serviceWorkerBridgeState.lastSnapshotMeta);\n    scheduleServiceWorkerLogPoll();\n    return;\n  }\n\n  if (data.type === SERVICE_WORKER_LOG_STATE_RESPONSE) {\n    finalizeServiceWorkerLogRequest(data.requestId || null);\n\n    const state = data.state && typeof data.state === 'object' ? data.state : null;\n    if (!state) {\n      scheduleServiceWorkerLogPoll();\n      return;\n    }\n\n    serviceWorkerBridgeState.lastSnapshotMeta = {\n      cacheName: typeof state.cacheName === 'string' && state.cacheName ? state.cacheName : null,\n      cacheVersion: state.cacheVersion || null,\n      generatedAt: typeof state.generatedAt === 'number' && Number.isFinite(state.generatedAt)\n        ? state.generatedAt\n        : Date.now(),\n      historyLength: typeof state.historyLength === 'number' && Number.isFinite(state.historyLength)\n        ? state.historyLength\n        : null,\n    };\n\n    importServiceWorkerLogEntries(state.history, serviceWorkerBridgeState.lastSnapshotMeta);\n    scheduleServiceWorkerLogPoll();\n  }\n}\n\nfunction requestServiceWorkerLogSnapshot(reason) {\n  if (serviceWorkerBridgeState.requestInFlight) {\n    return;\n  }\n\n  const serviceWorker = getNavigatorServiceWorker();\n  if (!serviceWorker) {\n    return;\n  }\n\n  serviceWorkerBridgeState.supported = true;\n\n  const requestId = `sw-log-${Date.now()}-${Math.random().toString(36).slice(2, 10)}`;\n  serviceWorkerBridgeState.requestInFlight = true;\n  serviceWorkerBridgeState.lastRequestId = requestId;\n\n  const message = {\n    type: SERVICE_WORKER_LOG_STATE_REQUEST,\n    limit: SERVICE_WORKER_LOG_HISTORY_LIMIT,\n    reason: typeof reason === 'string' && reason ? reason : 'sync',\n    requestId,\n  };\n\n  const closeMessageChannel = channel => {\n    if (!channel) {\n      return;\n    }\n\n    try {\n      channel.port1.onmessage = null;\n    } catch (clearHandlerError) {\n      void clearHandlerError;\n    }\n\n    if (typeof channel.port1.onmessageerror !== 'undefined') {\n      try {\n        channel.port1.onmessageerror = null;\n      } catch (clearErrorHandlerError) {\n        void clearErrorHandlerError;\n      }\n    }\n\n    try {\n      channel.port1.close();\n    } catch (closePort1Error) {\n      void closePort1Error;\n    }\n\n    try {\n      channel.port2.close();\n    } catch (closePort2Error) {\n      void closePort2Error;\n    }\n  };\n\n  const readyPromise = serviceWorker.ready && typeof serviceWorker.ready.then === 'function'\n    ? serviceWorker.ready.then(registration => (registration && registration.active) || serviceWorker.controller || null)\n    : Promise.resolve(serviceWorker.controller || null);\n\n  Promise.resolve(readyPromise)\n    .then(worker => {\n      const controller = serviceWorker.controller || null;\n      const targetWorker = worker || controller;\n\n      if (!targetWorker || typeof targetWorker.postMessage !== 'function') {\n        finalizeServiceWorkerLogRequest(requestId);\n        scheduleServiceWorkerLogPoll();\n        return;\n      }\n\n      let settled = false;\n      let channel = null;\n\n      const finalize = () => {\n        if (settled) {\n          return;\n        }\n        settled = true;\n        closeMessageChannel(channel);\n        finalizeServiceWorkerLogRequest(requestId);\n      };\n\n      const finalizeWithPoll = () => {\n        finalize();\n        scheduleServiceWorkerLogPoll();\n      };\n\n      const handleResponse = event => {\n        finalize();\n        handleServiceWorkerLogMessage(event);\n      };\n\n      const handleChannelError = () => {\n        safeWarn('cineLogging: Service worker diagnostics channel closed before a response was received', { requestId });\n        finalizeWithPoll();\n      };\n\n      const postWithoutChannel = () => {\n        try {\n          targetWorker.postMessage(message);\n        } catch (error) {\n          safeWarn('cineLogging: Unable to post service worker diagnostics request', error);\n          finalizeWithPoll();\n          return;\n        }\n\n        if (typeof setTimeout === 'function') {\n          try {\n            serviceWorkerBridgeState.requestTimer = setTimeout(() => {\n              if (settled) {\n                return;\n              }\n              finalizeWithPoll();\n            }, SERVICE_WORKER_LOG_REQUEST_TIMEOUT);\n          } catch (error) {\n            void error;\n          }\n        }\n      };\n\n      const shouldUseMessageChannel = () => {\n        if (typeof MessageChannel !== 'function') {\n          return false;\n        }\n\n        if (!controller) {\n          return false;\n        }\n\n        return targetWorker === controller;\n      };\n\n      if (!shouldUseMessageChannel()) {\n        postWithoutChannel();\n        return;\n      }\n\n      channel = new MessageChannel();\n      channel.port1.onmessage = handleResponse;\n\n      if (typeof channel.port1.onmessageerror !== 'undefined') {\n        channel.port1.onmessageerror = handleChannelError;\n      }\n\n      if (typeof channel.port1.start === 'function') {\n        try {\n          channel.port1.start();\n        } catch (startError) {\n          void startError;\n        }\n      }\n\n      try {\n        targetWorker.postMessage(message, [channel.port2]);\n      } catch (error) {\n        closeMessageChannel(channel);\n        channel = null;\n        safeWarn('cineLogging: Unable to request service worker diagnostics', error);\n        postWithoutChannel();\n        return;\n      }\n\n      if (typeof setTimeout === 'function') {\n        try {\n          serviceWorkerBridgeState.requestTimer = setTimeout(() => {\n            if (settled) {\n              return;\n            }\n            handleChannelError();\n          }, SERVICE_WORKER_LOG_REQUEST_TIMEOUT);\n        } catch (error) {\n          void error;\n        }\n      }\n    })\n    .catch(error => {\n      finalizeServiceWorkerLogRequest(requestId);\n      safeWarn('cineLogging: Unable to await service worker for diagnostics', error);\n      scheduleServiceWorkerLogPoll();\n    });\n}\n\nfunction setupServiceWorkerLogBridge() {\n  if (serviceWorkerBridgeState.initialised) {\n    return;\n  }\n\n  serviceWorkerBridgeState.initialised = true;\n\n  const serviceWorker = getNavigatorServiceWorker();\n  if (!serviceWorker) {\n    return;\n  }\n\n  serviceWorkerBridgeState.supported = true;\n\n  ensureServiceWorkerBroadcastChannel();\n\n  if (typeof serviceWorker.addEventListener === 'function') {\n    try {\n      serviceWorker.addEventListener('message', handleServiceWorkerLogMessage);\n    } catch (error) {\n      safeWarn('cineLogging: Unable to attach service worker diagnostics listener', error);\n    }\n  } else if (typeof serviceWorker.onmessage === 'undefined') {\n    try {\n      serviceWorker.onmessage = handleServiceWorkerLogMessage;\n    } catch (error) {\n      void error;\n    }\n  }\n\n  requestServiceWorkerLogSnapshot('initial-sync');\n  if (!serviceWorkerBridgeState.broadcastChannel) {\n    scheduleServiceWorkerLogPoll();\n  }\n}\n\nfunction loadPersistedHistory() {\n  if (!activeConfig.persistSession) {\n    return;\n  }\n\n  const storage = getSessionStorage();\n  if (!storage) {\n    return;\n  }\n\n  let raw = '';\n  try {\n    raw = storage.getItem(HISTORY_STORAGE_KEY) || '';\n  } catch (error) {\n    void error;\n    return;\n  }\n\n  if (!raw) {\n    return;\n  }\n\n  try {\n    const parsed = JSON.parse(raw);\n    if (!Array.isArray(parsed)) {\n      return;\n    }\n    for (let index = 0; index < parsed.length; index += 1) {\n      const entry = normaliseStoredEntry(parsed[index]);\n      if (entry) {\n        pushEntryToHistory(entry);\n      }\n    }\n    enforceHistoryLimit({ source: 'restore' });\n  } catch (error) {\n    safeWarn('cineLogging: Unable to restore log history from storage', error);\n  }\n}\n\nfunction initialiseConfig() {\n  activeConfig = cloneDefaultConfig();\n\n  const preset = resolveConfigPresetFromScopes();\n  if (preset) {\n    applyConfig(preset);\n  }\n\n  applyConfigFromStorage();\n  applyConfigFromQuery();\n}\n\ninitialiseConfig();\nloadPersistedHistory();\nsetupServiceWorkerLogBridge();\n\nsyncConsoleCaptureState();\n\nif (activeConfig.captureGlobalErrors) {\n  attachGlobalErrorListeners();\n}\n\ndebug(\n  'cineLogging initialized',\n  { config: getConfigSnapshot(), stats: getStats() },\n  { namespace: 'logging', meta: { lifecycle: 'init' } },\n);\n\nconst loggingAPI = freezeDeep({\n  log: logInternal,\n  debug,\n  info,\n  warn,\n  error,\n  createLogger,\n  getHistory,\n  getStats,\n  clearHistory,\n  getConfig: getConfigSnapshot,\n  setConfig,\n  getLevelState,\n  isLevelEnabled,\n  subscribe,\n  subscribeConfig,\n  enableConsoleCapture,\n  disableConsoleCapture,\n  syncConsoleCapture: syncConsoleCaptureState,\n  isConsoleCaptureActive,\n  constants: freezeDeep({\n    LOG_LEVELS,\n    DEFAULT_CONFIG,\n  }),\n});\n\ninformModuleGlobals('cineLogging', loggingAPI);\n\nconst registrationOptions = {\n  category: 'diagnostics',\n  description: 'Structured logging utilities for debugging and diagnostics.',\n  replace: true,\n  connections: ['cineModuleGlobals', 'cineModuleEnvironment', 'cineEnvironmentBridge', 'cineModuleContext'],\n};\n\nconst registered = registerOrQueueModule(\n  'cineLogging',\n  loggingAPI,\n  registrationOptions,\n  function (error) {\n    safeWarn('Unable to register cineLogging module.', error);\n  },\n  GLOBAL_SCOPE,\n  MODULE_REGISTRY,\n);\n\nif (!registered) {\n  queueModuleRegistration('cineLogging', loggingAPI, registrationOptions, GLOBAL_SCOPE);\n}\n\nif (!exposeGlobal('cineLogging', loggingAPI, {\n  configurable: true,\n  enumerable: false,\n  writable: false,\n})) {\n  safeWarn('Unable to expose cineLogging globally.');\n}\n\n// if (typeof module !== 'undefined' && module && module.exports) {\n//   module.exports = loggingAPI;\n// }\n// }) ();\n\nexport const cineLogging = loggingAPI;\n\n","// console-helpers.js - Ensures console methods stay writable for diagnostics tooling.\nconst GLOBAL_SCOPE =\n  typeof globalThis !== 'undefined'\n    ? globalThis\n    : typeof window !== 'undefined'\n      ? window\n      : typeof self !== 'undefined'\n        ? self\n        : typeof global !== 'undefined'\n          ? global\n          : null;\n\nfunction ensureConsoleMethodsWritable(methods) {\n  const scope =\n    (GLOBAL_SCOPE && typeof GLOBAL_SCOPE === 'object' ? GLOBAL_SCOPE : null)\n    || (typeof globalThis !== 'undefined' ? globalThis : null);\n  if (!scope) {\n    return null;\n  }\n\n  let baseConsole;\n  let consoleDescriptor = null;\n  try {\n    baseConsole = scope.console;\n    consoleDescriptor = Object.getOwnPropertyDescriptor(scope, 'console');\n  } catch (consoleReadError) {\n    baseConsole = typeof console !== 'undefined' ? console : null;\n    void consoleReadError;\n  }\n\n  if (!baseConsole || typeof baseConsole !== 'object') {\n    return null;\n  }\n\n  let requestedMethods = [];\n  if (Array.isArray(methods)) {\n    requestedMethods = methods;\n  } else if (typeof methods === 'string' && methods) {\n    requestedMethods = [methods];\n  } else {\n    requestedMethods = ['warn', 'info'];\n  }\n\n  const unique = Object.create(null);\n  for (let i = 0; i < requestedMethods.length; i += 1) {\n    const methodName = requestedMethods[i];\n    if (typeof methodName === 'string' && methodName) {\n      unique[methodName] = true;\n    }\n  }\n\n  const methodNames = Object.keys(unique);\n  if (!methodNames.length) {\n    return baseConsole;\n  }\n\n  const storage = Object.create(null);\n  for (let i = 0; i < methodNames.length; i += 1) {\n    const methodName = methodNames[i];\n    let value = baseConsole[methodName];\n    try {\n      const descriptor = Object.getOwnPropertyDescriptor(baseConsole, methodName);\n      if (descriptor && Object.prototype.hasOwnProperty.call(descriptor, 'value')) {\n        value = descriptor.value;\n      }\n    } catch (descriptorError) {\n      void descriptorError;\n    }\n    if (typeof value === 'function') {\n      try {\n        storage[methodName] = value.bind(baseConsole);\n      } catch (bindError) {\n        storage[methodName] = value;\n        void bindError;\n      }\n    } else {\n      storage[methodName] = value;\n    }\n  }\n\n  const proxy = new Proxy(baseConsole, {\n    get(target, property, receiver) {\n      if (Object.prototype.hasOwnProperty.call(storage, property)) {\n        return storage[property];\n      }\n      return Reflect.get(target, property, receiver);\n    },\n    set(target, property, value, receiver) {\n      if (Object.prototype.hasOwnProperty.call(storage, property)) {\n        storage[property] = value;\n        return true;\n      }\n      try {\n        Reflect.set(target, property, value, receiver);\n        return true;\n      } catch (setError) {\n        void setError;\n      }\n      return false;\n    },\n    defineProperty(target, property, descriptor) {\n      if (Object.prototype.hasOwnProperty.call(storage, property)) {\n        if (descriptor && Object.prototype.hasOwnProperty.call(descriptor, 'value')) {\n          storage[property] = descriptor.value;\n        }\n        return true;\n      }\n      return Reflect.defineProperty(target, property, descriptor);\n    },\n    getOwnPropertyDescriptor(target, property) {\n      if (Object.prototype.hasOwnProperty.call(storage, property)) {\n        return {\n          configurable: true,\n          enumerable: true,\n          writable: true,\n          value: storage[property],\n        };\n      }\n      return Reflect.getOwnPropertyDescriptor(target, property);\n    },\n    ownKeys(target) {\n      const keys = Reflect.ownKeys(target);\n      for (let i = 0; i < methodNames.length; i += 1) {\n        if (keys.indexOf(methodNames[i]) === -1) {\n          keys.push(methodNames[i]);\n        }\n      }\n      return keys;\n    },\n  });\n\n  try {\n    Object.defineProperty(scope, 'console', {\n      configurable: true,\n      enumerable: consoleDescriptor ? consoleDescriptor.enumerable !== false : true,\n      writable: true,\n      value: proxy,\n    });\n  } catch (defineError) {\n    scope.console = proxy;\n    void defineError;\n  }\n\n  return proxy;\n}\n\nexport { ensureConsoleMethodsWritable };\n\nif (GLOBAL_SCOPE && typeof GLOBAL_SCOPE === 'object') {\n  try {\n    if (typeof GLOBAL_SCOPE.__cineEnsureConsoleMethodsWritable !== 'function') {\n      GLOBAL_SCOPE.__cineEnsureConsoleMethodsWritable = ensureConsoleMethodsWritable;\n    }\n  } catch (exposeError) {\n    void exposeError;\n  }\n}\n","import './base.js';\nimport './logging.js';\n\n/* global cineModuleBase */\n\n// ESM Wrapper replacement\n// (function () {\nfunction detectGlobalScope() {\n  if (typeof globalThis !== 'undefined') {\n    return globalThis;\n  }\n  if (typeof window !== 'undefined') {\n    return window;\n  }\n  if (typeof self !== 'undefined') {\n    return self;\n  }\n  if (typeof global !== 'undefined') {\n    return global;\n  }\n  return {};\n}\n\nconst GLOBAL_SCOPE = detectGlobalScope();\n\nfunction resolveModuleBase(scope) {\n  // if (baseApi) return baseApi;\n\n  if (typeof cineModuleBase === 'object' && cineModuleBase) {\n    return cineModuleBase;\n  }\n\n  if (scope && typeof scope.cineModuleBase === 'object') {\n    return scope.cineModuleBase;\n  }\n\n  return null;\n}\n\nconst MODULE_BASE = resolveModuleBase(GLOBAL_SCOPE);\n\nconst baseFreezeDeep = MODULE_BASE && typeof MODULE_BASE.freezeDeep === 'function'\n  ? MODULE_BASE.freezeDeep\n  : function identity(value) {\n    return value;\n  };\n\nconst freezeDeep = value => {\n  try {\n    return baseFreezeDeep(value);\n  } catch (error) {\n    void error;\n    return value;\n  }\n};\n\nfunction fallbackCollectCandidateScopes(primary) {\n  const scopes = [];\n\n  function push(scope) {\n    if (!scope || (typeof scope !== 'object' && typeof scope !== 'function')) {\n      return;\n    }\n    if (scopes.indexOf(scope) === -1) {\n      scopes.push(scope);\n    }\n  }\n\n  if (primary) push(primary);\n  if (typeof globalThis !== 'undefined') push(globalThis);\n  if (typeof window !== 'undefined') push(window);\n  if (typeof self !== 'undefined') push(self);\n  if (typeof global !== 'undefined') push(global);\n\n  return scopes;\n}\n\nconst collectCandidateScopes = MODULE_BASE && typeof MODULE_BASE.collectCandidateScopes === 'function'\n  ? function collect(primary) {\n    try {\n      const result = MODULE_BASE.collectCandidateScopes(primary, GLOBAL_SCOPE);\n      if (Array.isArray(result) && result.length) {\n        return result;\n      }\n    } catch (error) {\n      void error;\n    }\n    return fallbackCollectCandidateScopes(primary || GLOBAL_SCOPE);\n  }\n  : fallbackCollectCandidateScopes;\n\nfunction fallbackSafeWarn(message, detail) {\n  if (typeof console === 'undefined' || typeof console.warn !== 'function') {\n    return;\n  }\n\n  try {\n    if (typeof detail === 'undefined') {\n      console.warn(message);\n    } else {\n      console.warn(message, detail);\n    }\n  } catch (error) {\n    void error;\n  }\n}\n\nconst safeWarn = MODULE_BASE && typeof MODULE_BASE.safeWarn === 'function'\n  ? MODULE_BASE.safeWarn\n  : fallbackSafeWarn;\n\nfunction resolveLoggingFromScope(scope) {\n  if (!scope || (typeof scope !== 'object' && typeof scope !== 'function')) {\n    return null;\n  }\n\n  let logging = null;\n  try {\n    logging = scope.cineLogging || null;\n  } catch (error) {\n    void error;\n    logging = null;\n  }\n\n  if (logging && typeof logging === 'object') {\n    return logging;\n  }\n\n  return null;\n}\n\nfunction tryRequireLogging() {\n  // if (loggingApi && typeof loggingApi === 'object') {\n  //   return loggingApi;\n  // }\n  return null;\n}\n\nfunction resolveLogging(options = {}) {\n  const baseScope = options.baseScope || GLOBAL_SCOPE;\n  const allowRequire = options.allowRequire !== false;\n\n  if (allowRequire) {\n    const required = tryRequireLogging();\n    if (required) {\n      return required;\n    }\n  }\n\n  const scopes = collectCandidateScopes(baseScope);\n  for (let index = 0; index < scopes.length; index += 1) {\n    const logging = resolveLoggingFromScope(scopes[index]);\n    if (logging) {\n      return logging;\n    }\n  }\n\n  return null;\n}\n\nfunction cloneMeta(value, seen = new WeakMap()) {\n  if (value === null || typeof value !== 'object') {\n    return value;\n  }\n\n  if (seen.has(value)) {\n    return seen.get(value);\n  }\n\n  if (Array.isArray(value)) {\n    const clone = [];\n    seen.set(value, clone);\n    for (let index = 0; index < value.length; index += 1) {\n      clone[index] = cloneMeta(value[index], seen);\n    }\n    return clone;\n  }\n\n  const clone = {};\n  seen.set(value, clone);\n  const keys = Object.keys(value);\n  for (let index = 0; index < keys.length; index += 1) {\n    const key = keys[index];\n    clone[key] = cloneMeta(value[key], seen);\n  }\n  return clone;\n}\n\nfunction mergeMeta(baseMeta, meta) {\n  if (!baseMeta && !meta) {\n    return null;\n  }\n\n  if (!baseMeta) {\n    return cloneMeta(meta);\n  }\n\n  if (!meta) {\n    return cloneMeta(baseMeta);\n  }\n\n  if (typeof baseMeta !== 'object' || typeof meta !== 'object') {\n    return cloneMeta(meta);\n  }\n\n  const merged = cloneMeta(baseMeta);\n  const keys = Object.keys(meta);\n  for (let index = 0; index < keys.length; index += 1) {\n    const key = keys[index];\n    merged[key] = cloneMeta(meta[key]);\n  }\n  return merged;\n}\n\nfunction resolveConsoleMethod(level) {\n  if (typeof console === 'undefined' || !console) {\n    return null;\n  }\n\n  const normalized = typeof level === 'string' ? level.toLowerCase() : '';\n\n  if (normalized === 'error' && typeof console.error === 'function') {\n    return console.error.bind(console);\n  }\n  if (normalized === 'warn' && typeof console.warn === 'function') {\n    return console.warn.bind(console);\n  }\n  if (normalized === 'info' && typeof console.info === 'function') {\n    return console.info.bind(console);\n  }\n  if (normalized === 'debug' && typeof console.debug === 'function') {\n    return console.debug.bind(console);\n  }\n  if (typeof console.log === 'function') {\n    return console.log.bind(console);\n  }\n\n  return null;\n}\n\nlet fallbackWarningIssued = false;\n\nfunction createConsoleFallbackLogger(namespace, options = {}) {\n  const normalizedNamespace = typeof namespace === 'string' && namespace.trim()\n    ? namespace.trim()\n    : 'app';\n\n  const baseMeta = options && typeof options.meta !== 'undefined'\n    ? cloneMeta(options.meta)\n    : null;\n\n  function output(level, message, detail, meta) {\n    const consoleMethod = resolveConsoleMethod(level);\n    if (!consoleMethod) {\n      return null;\n    }\n\n    const prefixParts = ['[cine-fallback]'];\n    if (normalizedNamespace) {\n      prefixParts.push(`[${normalizedNamespace}]`);\n    }\n\n    const timestamp = new Date();\n    try {\n      prefixParts.push(timestamp.toISOString());\n    } catch (error) {\n      void error;\n      prefixParts.push(String(timestamp.getTime()));\n    }\n\n    const prefix = prefixParts.join(' ');\n    const resolvedMessage = typeof message === 'string' && message\n      ? message\n      : 'Log entry';\n\n    const args = [`${prefix} ${resolvedMessage}`];\n\n    if (typeof detail !== 'undefined') {\n      args.push(detail);\n    }\n\n    const mergedMeta = mergeMeta(baseMeta, meta);\n    if (mergedMeta) {\n      args.push({ meta: mergedMeta, source: 'console-fallback' });\n    }\n\n    try {\n      consoleMethod(...args);\n    } catch (error) {\n      void error;\n    }\n\n    if (!fallbackWarningIssued && typeof console !== 'undefined' && typeof console.warn === 'function') {\n      fallbackWarningIssued = true;\n      try {\n        console.warn('[cine-fallback] Structured logging unavailable, using console logger.');\n      } catch (warnError) {\n        void warnError;\n      }\n    }\n\n    return null;\n  }\n\n  const logger = {\n    namespace: normalizedNamespace,\n    log(level, message, detail, meta) {\n      return output(level, message, detail, meta);\n    },\n    debug(message, detail, meta) {\n      return output('debug', message, detail, meta);\n    },\n    info(message, detail, meta) {\n      return output('info', message, detail, meta);\n    },\n    warn(message, detail, meta) {\n      return output('warn', message, detail, meta);\n    },\n    error(message, detail, meta) {\n      return output('error', message, detail, meta);\n    },\n    getConfig() {\n      return null;\n    },\n    isLevelEnabled() {\n      return true;\n    },\n    getLevelState(level) {\n      return {\n        level: typeof level === 'string' && level ? level : 'all',\n        enabled: true,\n        source: 'console-fallback',\n      };\n    },\n    __cineLoggingFallback: true,\n  };\n\n  return freezeDeep(logger);\n}\n\nfunction resolveLogger(namespace, options = {}) {\n  const logging = resolveLogging(options);\n  const meta = options && typeof options.meta !== 'undefined' ? options.meta : undefined;\n\n  if (logging && typeof logging.createLogger === 'function') {\n    try {\n      const logger = logging.createLogger(namespace, typeof meta !== 'undefined' ? { meta } : undefined);\n      if (logger) {\n        return logger;\n      }\n    } catch (error) {\n      safeWarn('cineLoggingResolver: createLogger failed, falling back to console.', error);\n    }\n  }\n\n  if (options.allowConsoleFallback === false) {\n    return null;\n  }\n\n  return createConsoleFallbackLogger(namespace, { meta });\n}\n\nconst resolverApi = freezeDeep({\n  resolveLogging,\n  resolveLogger,\n  createConsoleFallbackLogger,\n});\n\nconst registry = MODULE_BASE && typeof MODULE_BASE.resolveModuleRegistry === 'function'\n  ? MODULE_BASE.resolveModuleRegistry(GLOBAL_SCOPE)\n  : null;\n\nif (MODULE_BASE && typeof MODULE_BASE.registerOrQueueModule === 'function') {\n  const registered = MODULE_BASE.registerOrQueueModule(\n    'cineLoggingResolver',\n    resolverApi,\n    {\n      category: 'diagnostics',\n      description: 'Helpers to resolve cineLogging instances and console fallbacks across runtimes.',\n      replace: true,\n      connections: ['cineLogging', 'cineModuleBase', 'cineEnvironmentBridge'],\n    },\n    (error) => {\n      safeWarn('Unable to register cineLoggingResolver module.', error);\n    },\n    GLOBAL_SCOPE,\n    registry,\n  );\n\n  if (!registered && typeof MODULE_BASE.queueModuleRegistration === 'function') {\n    try {\n      MODULE_BASE.queueModuleRegistration(\n        'cineLoggingResolver',\n        resolverApi,\n        {\n          category: 'diagnostics',\n          description: 'Helpers to resolve cineLogging instances and console fallbacks across runtimes.',\n          replace: true,\n        },\n        GLOBAL_SCOPE,\n      );\n    } catch (queueError) {\n      safeWarn('Unable to queue cineLoggingResolver registration.', queueError);\n    }\n  }\n}\n\nif (MODULE_BASE && typeof MODULE_BASE.exposeGlobal === 'function') {\n  MODULE_BASE.exposeGlobal('cineLoggingResolver', resolverApi, GLOBAL_SCOPE, {\n    configurable: true,\n    enumerable: false,\n    writable: false,\n  });\n} else {\n  try {\n    GLOBAL_SCOPE.cineLoggingResolver = resolverApi;\n  } catch (error) {\n    void error;\n  }\n}\n\n/*\nif (typeof module !== 'undefined' && module && module.exports) {\n  module.exports = resolverApi;\n}\n*/\n// ESM Export\nexport { resolverApi as cineLoggingResolver };\nexport default resolverApi;\n\n","/* global cineModuleBase */\n\n// ---------------------------------------------------------------------------\n// Contacts feature module\n// ---------------------------------------------------------------------------\n// The contacts helper keeps personal crew information alongside the power\n// planner project data. Because these records can include critical call sheet\n// notes we keep the implementation intentionally small and well documented.\n// The additional comments below explain how each helper works so that future\n// maintainers understand the user data safeguards without having to reverse\n// engineer the storage flow.\n\n// ESM Version\nfunction detectGlobalScope() {\n  if (typeof globalThis !== 'undefined') {\n    return globalThis;\n  }\n  if (typeof window !== 'undefined') {\n    return window;\n  }\n  if (typeof self !== 'undefined') {\n    return self;\n  }\n  if (typeof global !== 'undefined') {\n    return global;\n  }\n  return {};\n}\n\nconst GLOBAL_SCOPE = detectGlobalScope();\n\nconst MODULE_BASE =\n  (typeof cineModuleBase === 'object' && cineModuleBase)\n  || (GLOBAL_SCOPE && typeof GLOBAL_SCOPE.cineModuleBase === 'object' ? GLOBAL_SCOPE.cineModuleBase : null);\n\n// Prefer the runtime provided logging facade so that diagnostics remain\n// consistent across the application. Falling back to console.warn keeps the\n// module functional inside tests and legacy entry points.\nconst safeWarn = MODULE_BASE && typeof MODULE_BASE.safeWarn === 'function'\n  ? MODULE_BASE.safeWarn\n  : function fallbackWarn(message, error) {\n    if (typeof console === 'undefined' || !console || typeof console.warn !== 'function') {\n      return;\n    }\n    try {\n      if (typeof error === 'undefined') {\n        console.warn(message);\n      } else {\n        console.warn(message, error);\n      }\n    } catch (consoleError) {\n      void consoleError;\n    }\n  };\n\n// Contacts live under a dedicated storage key to avoid colliding with other\n// project level metadata. The name mirrors the legacy implementation so\n// existing backups import cleanly.\nconst CONTACTS_STORAGE_KEY = 'cameraPowerPlanner_contacts';\n\nfunction resolveLocalStorage(scope) {\n  // The helper intentionally accepts an optional scope so that callers can\n  // inject mocked storage instances during tests. When no override is\n  // provided we fall back to the detected global scope.\n  const target = scope || GLOBAL_SCOPE;\n  try {\n    if (target && typeof target.localStorage !== 'undefined') {\n      return target.localStorage;\n    }\n  } catch (error) {\n    safeWarn('cine.features.contacts could not access localStorage.', error);\n  }\n  return null;\n}\n\nfunction generateContactId() {\n  // Persisting a random suffix avoids accidental collisions when multiple\n  // contacts are created in quick succession before the autosave triggers.\n  return `contact-${Date.now().toString(36)}-${Math.random().toString(36).slice(2, 8)}`;\n}\n\nfunction sanitizeContactValue(value) {\n  // Every field in the contact form is stored as a trimmed string so backup\n  // exports stay compact and predictable. Numeric and boolean values from\n  // older backups are coerced to strings instead of being dropped so that no\n  // contact information is lost during migrations.\n  if (typeof value === 'string') {\n    return value.trim();\n  }\n\n  if (typeof value === 'number') {\n    if (!Number.isFinite(value)) {\n      return '';\n    }\n    return String(value).trim();\n  }\n\n  if (typeof value === 'bigint') {\n    try {\n      return value.toString();\n    } catch (bigintError) {\n      void bigintError;\n    }\n    return '';\n  }\n\n  if (typeof value === 'boolean') {\n    return value ? 'true' : 'false';\n  }\n\n  if (value && typeof value === 'object') {\n    try {\n      const primitive = value.valueOf();\n      if (primitive !== value) {\n        return sanitizeContactValue(primitive);\n      }\n\n      if (typeof value.toString === 'function') {\n        const stringified = value.toString();\n        if (typeof stringified === 'string' && stringified && stringified !== '[object Object]') {\n          return stringified.trim();\n        }\n      }\n    } catch (coercionError) {\n      void coercionError;\n    }\n  }\n\n  return '';\n}\n\nfunction normalizeContactEntry(entry) {\n  // The normalisation step ensures that manually constructed contacts (for\n  // example when importing older backups) adopt the latest schema without\n  // mutating the original payload. This is critical for preserving user data\n  // across application upgrades.\n  if (!entry || typeof entry !== 'object') {\n    return null;\n  }\n\n  const id = sanitizeContactValue(entry.id) || generateContactId();\n  const name = sanitizeContactValue(entry.name);\n  const role = sanitizeContactValue(entry.role);\n  const phone = sanitizeContactValue(entry.phone);\n  const email = sanitizeContactValue(entry.email);\n  const website = sanitizeContactValue(entry.website || entry.url);\n  const notes = sanitizeContactValue(entry.notes || entry.note || entry.text);\n  const avatar = typeof entry.avatar === 'string' && entry.avatar.startsWith('data:')\n    ? entry.avatar\n    : '';\n  const createdAt = Number.isFinite(entry.createdAt) ? entry.createdAt : Date.now();\n  const updatedAt = Number.isFinite(entry.updatedAt) ? entry.updatedAt : createdAt;\n\n  const normalized = { id, name, role, phone, email, website, notes, createdAt, updatedAt };\n  if (avatar) {\n    normalized.avatar = avatar;\n  }\n\n  return normalized;\n}\n\nfunction sortContacts(list) {\n  // Contacts are sorted alphabetically so that the UI provides a predictable\n  // reading order. When names are missing we fall back to creation time which\n  // keeps imported records stable.\n  return (Array.isArray(list) ? list.filter(Boolean) : [])\n    .map(normalizeContactEntry)\n    .filter(Boolean)\n    .sort((a, b) => {\n      const nameA = (a && a.name ? a.name : '').toLowerCase();\n      const nameB = (b && b.name ? b.name : '').toLowerCase();\n      if (nameA && nameB && nameA !== nameB) {\n        try {\n          return nameA.localeCompare(nameB);\n        } catch (error) {\n          safeWarn('cine.features.contacts could not sort contacts by locale.', error);\n        }\n      }\n      if (nameA && !nameB) {\n        return -1;\n      }\n      if (!nameA && nameB) {\n        return 1;\n      }\n      return (a && a.createdAt ? a.createdAt : 0) - (b && b.createdAt ? b.createdAt : 0);\n    });\n}\n\nfunction loadStoredContacts(options = {}) {\n  // The load helper wraps JSON.parse inside a try/catch so that a single\n  // corrupted entry never risks crashing the surrounding autosave recovery.\n  const storage = resolveLocalStorage(options.scope);\n  if (!storage || typeof storage.getItem !== 'function') {\n    return [];\n  }\n  const storageKey = typeof options.storageKey === 'string' && options.storageKey\n    ? options.storageKey\n    : CONTACTS_STORAGE_KEY;\n\n  try {\n    const raw = storage.getItem(storageKey);\n    if (!raw) {\n      return [];\n    }\n    const parsed = JSON.parse(raw);\n    if (!Array.isArray(parsed)) {\n      return [];\n    }\n    return sortContacts(parsed);\n  } catch (error) {\n    safeWarn('cine.features.contacts could not load contacts from storage.', error);\n    return [];\n  }\n}\n\nfunction saveContactsToStorage(contacts, options = {}) {\n  // We serialise the entire contact list in one go to avoid partial writes.\n  // This keeps backups and offline snapshots coherent even if the browser\n  // crashes mid-operation.\n  const storage = resolveLocalStorage(options.scope);\n  if (!storage || typeof storage.setItem !== 'function') {\n    return false;\n  }\n  const storageKey = typeof options.storageKey === 'string' && options.storageKey\n    ? options.storageKey\n    : CONTACTS_STORAGE_KEY;\n\n  try {\n    storage.setItem(storageKey, JSON.stringify(Array.isArray(contacts) ? contacts : []));\n    return true;\n  } catch (error) {\n    safeWarn('cine.features.contacts could not save contacts to storage.', error);\n    return false;\n  }\n}\n\nconst moduleApi = Object.freeze({\n  CONTACTS_STORAGE_KEY,\n  generateContactId,\n  sanitizeContactValue,\n  normalizeContactEntry,\n  sortContacts,\n  loadStoredContacts,\n  saveContactsToStorage,\n});\n\nif (MODULE_BASE && typeof MODULE_BASE.registerOrQueueModule === 'function') {\n  try {\n    MODULE_BASE.registerOrQueueModule(\n      'cine.features.contacts',\n      moduleApi,\n      {\n        category: 'features',\n        description: 'Shared helpers for contacts management.',\n        replace: true,\n        connections: ['cineModuleBase', 'cineModuleGlobals', 'cinePersistence'],\n      },\n      (error) => safeWarn('Unable to register cine.features.contacts module.', error),\n      GLOBAL_SCOPE,\n      MODULE_BASE.getModuleRegistry && MODULE_BASE.getModuleRegistry(GLOBAL_SCOPE),\n    );\n  } catch (error) {\n    safeWarn('cine.features.contacts registration failed.', error);\n  }\n}\n\nlet exposedViaModuleBase = false;\nif (MODULE_BASE && typeof MODULE_BASE.exposeGlobal === 'function') {\n  try {\n    MODULE_BASE.exposeGlobal('cineFeaturesContacts', moduleApi, GLOBAL_SCOPE, {\n      configurable: true,\n      enumerable: false,\n      writable: false,\n    });\n    exposedViaModuleBase = true;\n  } catch (error) {\n    safeWarn('cine.features.contacts could not expose global api.', error);\n  }\n}\n\nif (!exposedViaModuleBase) {\n  try {\n    GLOBAL_SCOPE.cineFeaturesContacts = moduleApi;\n  } catch (error) {\n    safeWarn('cine.features.contacts could not assign global api.', error);\n  }\n}\n\n// ESM Export\nexport default moduleApi;\n","/**\n * @interface StorageInterface\n * Defines the standard contract for all storage drivers (LocalStorage, IndexedDB, etc.).\n * All methods must return Promises to ensure future compatibility with asynchronous engines.\n */\nexport default class StorageInterface {\n    /**\n     * Initialize the storage driver\n     * @returns {Promise<void>}\n     */\n    async init() {\n        throw new Error('Method \"init()\" must be implemented.');\n    }\n\n    /**\n     * Retrieve an item by key\n     * @param {string} key \n     * @returns {Promise<any>} The parsed value or null\n     */\n    async getItem(key) {\n        throw new Error('Method \"getItem()\" must be implemented.');\n    }\n\n    /**\n     * Save an item by key\n     * @param {string} key \n     * @param {any} value \n     * @returns {Promise<void>}\n     */\n    async setItem(key, value) {\n        throw new Error('Method \"setItem()\" must be implemented.');\n    }\n\n    /**\n     * Remove an item by key\n     * @param {string} key \n     * @returns {Promise<void>}\n     */\n    async removeItem(key) {\n        throw new Error('Method \"removeItem()\" must be implemented.');\n    }\n\n    /**\n     * Clear all keys managed by this driver context\n     * @returns {Promise<void>}\n     */\n    async clear() {\n        throw new Error('Method \"clear()\" must be implemented.');\n    }\n\n    /**\n     * Get all keys stored by this driver\n     * @returns {Promise<string[]>}\n     */\n    async getKeys() {\n        throw new Error('Method \"getKeys()\" must be implemented.');\n    }\n}\n","import StorageInterface from '../StorageInterface.js';\n\n/**\n * @class LocalStorageAdapter\n * Adapts specific localStorage operations to the standard asynchronous StorageInterface.\n * Acts as a backward-compatibility layer.\n */\nexport default class LocalStorageAdapter extends StorageInterface {\n    constructor() {\n        super();\n        this.storage = window.localStorage;\n    }\n\n    /** @override */\n    async init() {\n        // LocalStorage is synchronous and always ready (if available)\n        if (!this.storage) {\n            throw new Error('LocalStorage is not supported in this environment.');\n        }\n        return Promise.resolve();\n    }\n\n    /** @override */\n    async getItem(key) {\n        try {\n            const raw = this.storage.getItem(key);\n            if (raw === null) return null;\n            // Attempt generic JSON parse, fallback to raw string if it's not JSON\n            try {\n                return JSON.parse(raw);\n            } catch {\n                return raw;\n            }\n        } catch (e) {\n            console.warn(`[LocalStorageAdapter] Failed to get item: ${key}`, e);\n            return null;\n        }\n    }\n\n    /** @override */\n    async setItem(key, value) {\n        try {\n            // Store strings directly, object/arrays as JSON\n            const payload = typeof value === 'string' ? value : JSON.stringify(value);\n            this.storage.setItem(key, payload);\n        } catch (e) {\n            console.error(`[LocalStorageAdapter] Failed to save item: ${key}`, e);\n            throw e; // Propagate error (e.g., QuotaExceededError)\n        }\n    }\n\n    /** @override */\n    async removeItem(key) {\n        try {\n            this.storage.removeItem(key);\n        } catch (e) {\n            console.warn(`[LocalStorageAdapter] Failed to remove item: ${key}`, e);\n        }\n    }\n\n    /** @override */\n    async clear() {\n        try {\n            this.storage.clear();\n        } catch (e) {\n            console.warn('[LocalStorageAdapter] Failed to clear storage', e);\n        }\n    }\n\n    /** @override */\n    async getKeys() {\n        return Object.keys(this.storage);\n    }\n}\n","/**\n * @class UserContext\n * Manages the current user identity (UUID) and device identity for sync/locks.\n * - userId: Persistent anonymous identifier for the user (survives factory reset on same device)\n * - deviceId: Per-browser-profile identifier for lock management\n * - sessionId: Per-tab identifier for fine-grained lock tracking\n */\nexport class UserContext {\n    constructor() {\n        this.userId = null;\n        this.deviceId = null;\n        this.sessionId = null;\n        this.storageKey = 'cine_user_uuid';\n        this.deviceStorageKey = 'cine_device_uuid';\n    }\n\n    /**\n     * Generates a cryptographically random UUID or fallback.\n     * @returns {string}\n     */\n    generateUUID() {\n        if (typeof crypto !== 'undefined' && crypto.randomUUID) {\n            return crypto.randomUUID();\n        }\n        // Fallback for older environments\n        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {\n            const r = (Math.random() * 16) | 0;\n            const v = c === 'x' ? r : (r & 0x3) | 0x8;\n            return v.toString(16);\n        });\n    }\n\n    /**\n     * Initializes the user context.\n     * Checks localStorage for existing UUID, otherwise generates one.\n     */\n    init() {\n        if (this.userId && this.deviceId && this.sessionId) return this.userId;\n\n        // User ID (persistent across sessions)\n        let uuid = localStorage.getItem(this.storageKey);\n        if (!uuid) {\n            uuid = this.generateUUID();\n            localStorage.setItem(this.storageKey, uuid);\n            console.log('[UserContext] Generated new User UUID:', uuid);\n        } else {\n            console.log('[UserContext] Loaded User UUID:', uuid);\n        }\n        this.userId = uuid;\n\n        // Device ID (persistent per browser profile, for cross-tab coordination)\n        let deviceId = localStorage.getItem(this.deviceStorageKey);\n        if (!deviceId) {\n            deviceId = this.generateUUID();\n            localStorage.setItem(this.deviceStorageKey, deviceId);\n            console.log('[UserContext] Generated new Device UUID:', deviceId);\n        }\n        this.deviceId = deviceId;\n\n        // Session ID (unique per tab, for lock granularity)\n        this.sessionId = this.generateUUID();\n        console.log('[UserContext] Session UUID:', this.sessionId);\n\n        return uuid;\n    }\n\n    getUserId() {\n        if (!this.userId) return this.init();\n        return this.userId;\n    }\n\n    /**\n     * Returns the device UUID (unique per browser profile).\n     * Used for cross-device lock detection via cloud sync.\n     */\n    getDeviceId() {\n        if (!this.deviceId) this.init();\n        return this.deviceId;\n    }\n\n    /**\n     * Returns the session UUID (unique per tab).\n     * Used for same-device, cross-tab lock coordination.\n     */\n    getSessionId() {\n        if (!this.sessionId) this.init();\n        return this.sessionId;\n    }\n\n    /**\n     * Scopes a storage key with the current user ID.\n     * @param {string} key \n     */\n    getScopedKey(key) {\n        const uuid = this.getUserId();\n        return `user_${uuid}_${key}`;\n    }\n\n    /**\n     * Returns a full identity object for sync metadata.\n     */\n    getIdentity() {\n        return {\n            userId: this.getUserId(),\n            deviceId: this.getDeviceId(),\n            sessionId: this.getSessionId(),\n        };\n    }\n\n    /**\n     * Clears the user identity (Factory Reset).\n     * Note: Does NOT clear deviceId to maintain device tracking.\n     */\n    reset() {\n        localStorage.removeItem(this.storageKey);\n        this.userId = null;\n        this.sessionId = null;\n    }\n}\n\nexport const userContext = new UserContext();\n\n","import { userContext } from '../core/UserContext.js';\n\n/**\n * @module SyncMetadata\n * \n * Provides metadata wrappers for all stored data to enable:\n * - Offline-first sync with Firebase\n * - Conflict detection and resolution\n * - Lock management timestamps\n * - Change tracking at document level\n * \n * All data stored through the sync-aware API gets wrapped with _meta.\n */\n\n// Schema version for future migrations\nconst SYNC_METADATA_VERSION = 1;\n\n// Sync status constants\nexport const SyncStatus = Object.freeze({\n    /** Data has been synced to cloud */\n    SYNCED: 'synced',\n    /** Data has local changes not yet synced */\n    PENDING: 'pending',\n    /** Data has conflicts that need resolution */\n    CONFLICT: 'conflict',\n    /** Data is being synced right now */\n    SYNCING: 'syncing',\n    /** Data has never been synced (new) */\n    LOCAL_ONLY: 'local_only',\n});\n\n// Lock status constants\nexport const LockStatus = Object.freeze({\n    /** No lock held */\n    UNLOCKED: 'unlocked',\n    /** Locked by current session */\n    LOCKED_BY_SELF: 'locked_by_self',\n    /** Locked by another session on same device */\n    LOCKED_BY_OTHER_TAB: 'locked_by_other_tab',\n    /** Locked by another device */\n    LOCKED_BY_OTHER_DEVICE: 'locked_by_other_device',\n});\n\n/**\n * Generates an ISO timestamp string.\n * @returns {string}\n */\nfunction nowISO() {\n    return new Date().toISOString();\n}\n\n/**\n * Generates a unique document ID.\n * @param {string} [prefix] - Optional prefix for the ID\n * @returns {string}\n */\nexport function generateDocId(prefix = 'doc') {\n    const timestamp = Date.now().toString(36);\n    const random = Math.random().toString(36).substring(2, 10);\n    return `${prefix}_${timestamp}_${random}`;\n}\n\n/**\n * Creates fresh sync metadata for a new document.\n * @param {Object} options - Options for metadata creation\n * @param {string} [options.docId] - Document ID (generated if not provided)\n * @param {string} [options.docType] - Type of document (e.g., 'project', 'settings')\n * @returns {Object} Fresh metadata object\n */\nexport function createSyncMetadata(options = {}) {\n    const identity = userContext.getIdentity();\n    const now = nowISO();\n\n    return {\n        version: SYNC_METADATA_VERSION,\n        docId: options.docId || generateDocId(options.docType || 'doc'),\n        docType: options.docType || 'unknown',\n\n        // Ownership\n        ownerId: identity.userId,\n\n        // Timestamps\n        createdAt: now,\n        updatedAt: now,\n\n        // Sync state\n        syncStatus: SyncStatus.LOCAL_ONLY,\n        syncedAt: null,\n        syncError: null,\n\n        // Change tracking\n        changeCount: 1,\n        lastChangeBy: identity.userId,\n        lastChangeDevice: identity.deviceId,\n        lastChangeSession: identity.sessionId,\n\n        // Lock state (for active editing)\n        lock: null, // Will be { deviceId, sessionId, acquiredAt, heartbeat } when locked\n\n        // Collaboration (future)\n        sharedWith: [], // Array of user IDs\n        permissions: {}, // { userId: 'read' | 'write' | 'admin' }\n    };\n}\n\n/**\n * Updates sync metadata when data is modified.\n * @param {Object} existingMeta - Current metadata\n * @returns {Object} Updated metadata\n */\nexport function updateSyncMetadata(existingMeta) {\n    if (!existingMeta || typeof existingMeta !== 'object') {\n        return createSyncMetadata();\n    }\n\n    const identity = userContext.getIdentity();\n    const now = nowISO();\n\n    return {\n        ...existingMeta,\n        version: SYNC_METADATA_VERSION,\n        updatedAt: now,\n        syncStatus: existingMeta.syncStatus === SyncStatus.SYNCED\n            ? SyncStatus.PENDING\n            : existingMeta.syncStatus,\n        changeCount: (existingMeta.changeCount || 0) + 1,\n        lastChangeBy: identity.userId,\n        lastChangeDevice: identity.deviceId,\n        lastChangeSession: identity.sessionId,\n    };\n}\n\n/**\n * Marks metadata as successfully synced.\n * @param {Object} existingMeta - Current metadata\n * @param {string} [serverTimestamp] - Server timestamp if available\n * @returns {Object} Updated metadata\n */\nexport function markAsSynced(existingMeta, serverTimestamp = null) {\n    if (!existingMeta || typeof existingMeta !== 'object') {\n        console.warn('[SyncMetadata] Cannot mark null metadata as synced');\n        return existingMeta;\n    }\n\n    return {\n        ...existingMeta,\n        syncStatus: SyncStatus.SYNCED,\n        syncedAt: serverTimestamp || nowISO(),\n        syncError: null,\n    };\n}\n\n/**\n * Marks metadata as having a sync conflict.\n * @param {Object} existingMeta - Current metadata\n * @param {string} errorMessage - Conflict description\n * @returns {Object} Updated metadata\n */\nexport function markAsConflict(existingMeta, errorMessage) {\n    if (!existingMeta || typeof existingMeta !== 'object') {\n        return existingMeta;\n    }\n\n    return {\n        ...existingMeta,\n        syncStatus: SyncStatus.CONFLICT,\n        syncError: errorMessage,\n    };\n}\n\n/**\n * Wraps raw data with sync metadata.\n * @param {any} data - The actual data to store\n * @param {Object} [existingMeta] - Existing metadata to update, or null for new\n * @param {Object} [options] - Options for new metadata\n * @returns {Object} Wrapped data with _meta\n */\nexport function wrapWithMetadata(data, existingMeta = null, options = {}) {\n    const meta = existingMeta\n        ? updateSyncMetadata(existingMeta)\n        : createSyncMetadata(options);\n\n    return {\n        _meta: meta,\n        data: data,\n    };\n}\n\n/**\n * Unwraps data from metadata wrapper.\n * @param {Object} wrapped - Data with _meta wrapper\n * @returns {{ data: any, meta: Object }} Separated data and metadata\n */\nexport function unwrapMetadata(wrapped) {\n    if (!wrapped || typeof wrapped !== 'object') {\n        return { data: wrapped, meta: null };\n    }\n\n    // Check if this is wrapped data\n    if (wrapped._meta && 'data' in wrapped) {\n        return { data: wrapped.data, meta: wrapped._meta };\n    }\n\n    // Legacy data without metadata wrapper\n    return { data: wrapped, meta: null };\n}\n\n/**\n * Checks if data has sync metadata.\n * @param {any} data - Data to check\n * @returns {boolean}\n */\nexport function hasMetadata(data) {\n    return data && typeof data === 'object' && '_meta' in data && 'data' in data;\n}\n\n/**\n * Determines the lock status of a document relative to current session.\n * @param {Object} meta - Document metadata\n * @returns {string} One of LockStatus values\n */\nexport function getLockStatus(meta) {\n    if (!meta || !meta.lock) {\n        return LockStatus.UNLOCKED;\n    }\n\n    const identity = userContext.getIdentity();\n    const lock = meta.lock;\n\n    // Check if lock has expired (30 second heartbeat timeout)\n    const lockAge = Date.now() - new Date(lock.heartbeat || lock.acquiredAt).getTime();\n    if (lockAge > 30000) {\n        return LockStatus.UNLOCKED; // Lock expired\n    }\n\n    // Check session ownership\n    if (lock.sessionId === identity.sessionId) {\n        return LockStatus.LOCKED_BY_SELF;\n    }\n\n    // Check device ownership\n    if (lock.deviceId === identity.deviceId) {\n        return LockStatus.LOCKED_BY_OTHER_TAB;\n    }\n\n    return LockStatus.LOCKED_BY_OTHER_DEVICE;\n}\n\n/**\n * Creates a lock object for the current session.\n * @returns {Object} Lock object\n */\nexport function createLock() {\n    const identity = userContext.getIdentity();\n    const now = nowISO();\n\n    return {\n        userId: identity.userId,\n        deviceId: identity.deviceId,\n        sessionId: identity.sessionId,\n        acquiredAt: now,\n        heartbeat: now,\n    };\n}\n\n/**\n * Updates the heartbeat timestamp of an existing lock.\n * @param {Object} lock - Existing lock object\n * @returns {Object} Updated lock object\n */\nexport function updateLockHeartbeat(lock) {\n    if (!lock) return createLock();\n\n    return {\n        ...lock,\n        heartbeat: nowISO(),\n    };\n}\n\n/**\n * Gets items that need syncing from an array of wrapped items.\n * @param {Array} items - Array of wrapped data items\n * @returns {Array} Items with pending sync status\n */\nexport function getPendingSyncItems(items) {\n    if (!Array.isArray(items)) return [];\n\n    return items.filter(item => {\n        if (!hasMetadata(item)) return false;\n        const { meta } = unwrapMetadata(item);\n        return meta && (\n            meta.syncStatus === SyncStatus.PENDING ||\n            meta.syncStatus === SyncStatus.LOCAL_ONLY\n        );\n    });\n}\n\nexport default {\n    SyncStatus,\n    LockStatus,\n    generateDocId,\n    createSyncMetadata,\n    updateSyncMetadata,\n    markAsSynced,\n    markAsConflict,\n    wrapWithMetadata,\n    unwrapMetadata,\n    hasMetadata,\n    getLockStatus,\n    createLock,\n    updateLockHeartbeat,\n    getPendingSyncItems,\n};\n","import { userContext } from '../core/UserContext.js';\nimport {\n    createLock,\n    updateLockHeartbeat,\n    getLockStatus,\n    LockStatus\n} from './SyncMetadata.js';\n\n/**\n * @class ProjectLockService\n * \n * Manages project edit locks to prevent simultaneous editing across:\n * - Multiple browser tabs (same device)\n * - Multiple devices (via cloud sync)\n * \n * Lock Strategy:\n * 1. BroadcastChannel for instant cross-tab coordination (same browser)\n * 2. localStorage/IndexedDB heartbeats for persistence (survives page refresh)\n * 3. Cloud lock document for cross-device coordination (future Firebase)\n * \n * Lock Lifecycle:\n * - Acquire: Check if unlocked  Set lock  Start heartbeat\n * - Heartbeat: Update timestamp every 5s to prove \"still alive\"\n * - Release: Clear lock on page unload or explicit release\n * - Takeover: Force acquire when user confirms takeover prompt\n * \n * Timeout: Lock expires if heartbeat not updated for 30 seconds\n */\n\nconst LOCK_CHANNEL_NAME = 'cine-project-locks';\nconst HEARTBEAT_INTERVAL_MS = 5000; // 5 seconds\nconst LOCK_TIMEOUT_MS = 30000; // 30 seconds\nconst LOCK_STORAGE_PREFIX = 'cine_project_lock_';\n\n// Event types for BroadcastChannel\nconst LockEvent = Object.freeze({\n    LOCK_ACQUIRED: 'lock_acquired',\n    LOCK_RELEASED: 'lock_released',\n    LOCK_HEARTBEAT: 'lock_heartbeat',\n    LOCK_TAKEOVER: 'lock_takeover',\n    LOCK_QUERY: 'lock_query',\n    LOCK_STATUS: 'lock_status',\n});\n\n/**\n * @typedef {Object} Lock\n * @property {string} projectId - The project being locked\n * @property {string} userId - Owner of the lock\n * @property {string} deviceId - Device holding the lock\n * @property {string} sessionId - Tab/session holding the lock\n * @property {string} acquiredAt - ISO timestamp when lock was acquired\n * @property {string} heartbeat - ISO timestamp of last heartbeat\n */\n\nclass ProjectLockService {\n    constructor() {\n        /** @type {BroadcastChannel|null} */\n        this.channel = null;\n\n        /** @type {Map<string, Lock>} Project ID -> Lock */\n        this.localLocks = new Map();\n\n        /** @type {Map<string, number>} Project ID -> Interval ID */\n        this.heartbeatIntervals = new Map();\n\n        /** @type {Set<Function>} */\n        this.lockChangeListeners = new Set();\n\n        /** @type {boolean} */\n        this.initialized = false;\n    }\n\n    /**\n     * Initializes the lock service.\n     * Must be called before using any lock operations.\n     */\n    init() {\n        if (this.initialized) return;\n\n        // Ensure UserContext is initialized\n        userContext.init();\n\n        // Setup BroadcastChannel for cross-tab coordination\n        if (typeof BroadcastChannel !== 'undefined') {\n            try {\n                this.channel = new BroadcastChannel(LOCK_CHANNEL_NAME);\n                this.channel.onmessage = (event) => this._handleChannelMessage(event);\n                console.log('[ProjectLockService] BroadcastChannel initialized');\n            } catch (err) {\n                console.warn('[ProjectLockService] BroadcastChannel not available:', err);\n            }\n        }\n\n        // Restore locks from localStorage (for page refresh scenarios)\n        this._restoreLocksFromStorage();\n\n        // Setup page unload handler to release locks\n        if (typeof window !== 'undefined') {\n            window.addEventListener('beforeunload', () => this._handlePageUnload());\n            window.addEventListener('pagehide', () => this._handlePageUnload());\n        }\n\n        this.initialized = true;\n        console.log('[ProjectLockService] Initialized');\n    }\n\n    /**\n     * Attempts to acquire a lock on a project.\n     * @param {string} projectId - Project to lock\n     * @param {Object} [options] - Lock options\n     * @param {boolean} [options.force] - Force takeover even if locked by another\n     * @returns {Promise<{ success: boolean, status: string, lock: Lock|null }>}\n     */\n    async acquireLock(projectId, options = {}) {\n        this.init();\n\n        const existingLock = this._getStoredLock(projectId);\n        const status = this._getLockStatusForLock(existingLock);\n\n        // Already locked by current session\n        if (status === LockStatus.LOCKED_BY_SELF) {\n            return { success: true, status, lock: existingLock };\n        }\n\n        // Locked by another and not forcing takeover\n        if (status !== LockStatus.UNLOCKED && !options.force) {\n            return { success: false, status, lock: existingLock };\n        }\n\n        // If forcing takeover, notify the other session\n        if (options.force && existingLock) {\n            this._broadcastTakeover(projectId, existingLock);\n        }\n\n        // Create and store the lock\n        const lock = this._createLockObject(projectId);\n        this._storeLock(projectId, lock);\n        this.localLocks.set(projectId, lock);\n\n        // Start heartbeat\n        this._startHeartbeat(projectId);\n\n        // Notify other tabs\n        this._broadcastLockAcquired(projectId, lock);\n\n        // Notify local listeners\n        this._notifyListeners(projectId, LockStatus.LOCKED_BY_SELF, lock);\n\n        console.log('[ProjectLockService] Lock acquired:', projectId);\n        return { success: true, status: LockStatus.LOCKED_BY_SELF, lock };\n    }\n\n    /**\n     * Releases a lock on a project.\n     * @param {string} projectId - Project to unlock\n     * @returns {Promise<boolean>} Whether release was successful\n     */\n    async releaseLock(projectId) {\n        this.init();\n\n        const existingLock = this._getStoredLock(projectId);\n        const status = this._getLockStatusForLock(existingLock);\n\n        // Can only release own locks\n        if (status !== LockStatus.LOCKED_BY_SELF) {\n            console.warn('[ProjectLockService] Cannot release lock not owned by this session');\n            return false;\n        }\n\n        // Stop heartbeat\n        this._stopHeartbeat(projectId);\n\n        // Remove lock\n        this._clearStoredLock(projectId);\n        this.localLocks.delete(projectId);\n\n        // Notify other tabs\n        this._broadcastLockReleased(projectId);\n\n        // Notify local listeners\n        this._notifyListeners(projectId, LockStatus.UNLOCKED, null);\n\n        console.log('[ProjectLockService] Lock released:', projectId);\n        return true;\n    }\n\n    /**\n     * Gets the current lock status for a project.\n     * @param {string} projectId - Project to check\n     * @returns {{ status: string, lock: Lock|null, isEditable: boolean }}\n     */\n    getLockInfo(projectId) {\n        this.init();\n\n        const lock = this._getStoredLock(projectId);\n        const status = this._getLockStatusForLock(lock);\n\n        return {\n            status,\n            lock: lock,\n            isEditable: status === LockStatus.UNLOCKED || status === LockStatus.LOCKED_BY_SELF,\n        };\n    }\n\n    /**\n     * Subscribes to lock change events.\n     * @param {Function} callback - Called with (projectId, status, lock)\n     * @returns {Function} Unsubscribe function\n     */\n    subscribe(callback) {\n        this.lockChangeListeners.add(callback);\n        return () => this.lockChangeListeners.delete(callback);\n    }\n\n    /**\n     * Refreshes the heartbeat for a lock.\n     * Called automatically, but can be triggered manually.\n     * @param {string} projectId \n     */\n    refreshHeartbeat(projectId) {\n        const lock = this.localLocks.get(projectId);\n        if (!lock) return;\n\n        const identity = userContext.getIdentity();\n\n        // Verify we still own this lock\n        if (lock.sessionId !== identity.sessionId) {\n            this._stopHeartbeat(projectId);\n            return;\n        }\n\n        // Update heartbeat\n        lock.heartbeat = new Date().toISOString();\n        this._storeLock(projectId, lock);\n\n        // Notify other tabs\n        this._broadcastHeartbeat(projectId, lock);\n    }\n\n    // --- Private Methods ---\n\n    _createLockObject(projectId) {\n        const identity = userContext.getIdentity();\n        const now = new Date().toISOString();\n\n        return {\n            projectId,\n            userId: identity.userId,\n            deviceId: identity.deviceId,\n            sessionId: identity.sessionId,\n            acquiredAt: now,\n            heartbeat: now,\n        };\n    }\n\n    _getStorageKey(projectId) {\n        return LOCK_STORAGE_PREFIX + projectId;\n    }\n\n    _storeLock(projectId, lock) {\n        try {\n            localStorage.setItem(this._getStorageKey(projectId), JSON.stringify(lock));\n        } catch (err) {\n            console.warn('[ProjectLockService] Failed to store lock:', err);\n        }\n    }\n\n    _getStoredLock(projectId) {\n        try {\n            const data = localStorage.getItem(this._getStorageKey(projectId));\n            if (!data) return null;\n\n            const lock = JSON.parse(data);\n\n            // Check if lock has expired\n            if (this._isLockExpired(lock)) {\n                this._clearStoredLock(projectId);\n                return null;\n            }\n\n            return lock;\n        } catch (err) {\n            console.warn('[ProjectLockService] Failed to read lock:', err);\n            return null;\n        }\n    }\n\n    _clearStoredLock(projectId) {\n        try {\n            localStorage.removeItem(this._getStorageKey(projectId));\n        } catch (err) {\n            console.warn('[ProjectLockService] Failed to clear lock:', err);\n        }\n    }\n\n    _isLockExpired(lock) {\n        if (!lock || !lock.heartbeat) return true;\n        const age = Date.now() - new Date(lock.heartbeat).getTime();\n        return age > LOCK_TIMEOUT_MS;\n    }\n\n    _getLockStatusForLock(lock) {\n        if (!lock || this._isLockExpired(lock)) {\n            return LockStatus.UNLOCKED;\n        }\n\n        const identity = userContext.getIdentity();\n\n        if (lock.sessionId === identity.sessionId) {\n            return LockStatus.LOCKED_BY_SELF;\n        }\n\n        if (lock.deviceId === identity.deviceId) {\n            return LockStatus.LOCKED_BY_OTHER_TAB;\n        }\n\n        return LockStatus.LOCKED_BY_OTHER_DEVICE;\n    }\n\n    _startHeartbeat(projectId) {\n        this._stopHeartbeat(projectId); // Clear any existing\n\n        const intervalId = setInterval(() => {\n            this.refreshHeartbeat(projectId);\n        }, HEARTBEAT_INTERVAL_MS);\n\n        this.heartbeatIntervals.set(projectId, intervalId);\n    }\n\n    _stopHeartbeat(projectId) {\n        const intervalId = this.heartbeatIntervals.get(projectId);\n        if (intervalId) {\n            clearInterval(intervalId);\n            this.heartbeatIntervals.delete(projectId);\n        }\n    }\n\n    _restoreLocksFromStorage() {\n        const identity = userContext.getIdentity();\n\n        try {\n            for (let i = 0; i < localStorage.length; i++) {\n                const key = localStorage.key(i);\n                if (!key || !key.startsWith(LOCK_STORAGE_PREFIX)) continue;\n\n                const projectId = key.slice(LOCK_STORAGE_PREFIX.length);\n                const lock = this._getStoredLock(projectId);\n\n                // Only restore locks owned by this session\n                if (lock && lock.sessionId === identity.sessionId) {\n                    this.localLocks.set(projectId, lock);\n                    this._startHeartbeat(projectId);\n                    console.log('[ProjectLockService] Restored lock:', projectId);\n                }\n            }\n        } catch (err) {\n            console.warn('[ProjectLockService] Failed to restore locks:', err);\n        }\n    }\n\n    _handlePageUnload() {\n        // Release all locks held by this session\n        for (const projectId of this.localLocks.keys()) {\n            this._stopHeartbeat(projectId);\n            this._clearStoredLock(projectId);\n            this._broadcastLockReleased(projectId);\n        }\n        this.localLocks.clear();\n    }\n\n    _notifyListeners(projectId, status, lock) {\n        for (const callback of this.lockChangeListeners) {\n            try {\n                callback(projectId, status, lock);\n            } catch (err) {\n                console.warn('[ProjectLockService] Listener error:', err);\n            }\n        }\n    }\n\n    // --- BroadcastChannel Methods ---\n\n    _broadcast(type, data) {\n        if (!this.channel) return;\n        try {\n            this.channel.postMessage({ type, ...data });\n        } catch (err) {\n            console.warn('[ProjectLockService] Broadcast failed:', err);\n        }\n    }\n\n    _broadcastLockAcquired(projectId, lock) {\n        this._broadcast(LockEvent.LOCK_ACQUIRED, { projectId, lock });\n    }\n\n    _broadcastLockReleased(projectId) {\n        this._broadcast(LockEvent.LOCK_RELEASED, { projectId });\n    }\n\n    _broadcastHeartbeat(projectId, lock) {\n        this._broadcast(LockEvent.LOCK_HEARTBEAT, { projectId, lock });\n    }\n\n    _broadcastTakeover(projectId, oldLock) {\n        this._broadcast(LockEvent.LOCK_TAKEOVER, { projectId, oldLock });\n    }\n\n    _handleChannelMessage(event) {\n        const { type, projectId, lock, oldLock } = event.data || {};\n        if (!projectId) return;\n\n        const identity = userContext.getIdentity();\n\n        switch (type) {\n            case LockEvent.LOCK_ACQUIRED:\n                // Another tab acquired a lock\n                if (lock && lock.sessionId !== identity.sessionId) {\n                    this._notifyListeners(projectId, this._getLockStatusForLock(lock), lock);\n                }\n                break;\n\n            case LockEvent.LOCK_RELEASED:\n                // Another tab released a lock\n                this._notifyListeners(projectId, LockStatus.UNLOCKED, null);\n                break;\n\n            case LockEvent.LOCK_TAKEOVER:\n                // Another tab is taking over our lock\n                if (oldLock && oldLock.sessionId === identity.sessionId) {\n                    console.warn('[ProjectLockService] Lock taken over by another tab:', projectId);\n                    this._stopHeartbeat(projectId);\n                    this.localLocks.delete(projectId);\n                    this._notifyListeners(projectId, LockStatus.LOCKED_BY_OTHER_TAB, null);\n                }\n                break;\n\n            case LockEvent.LOCK_HEARTBEAT:\n                // Update our knowledge of external lock heartbeat\n                if (lock && lock.sessionId !== identity.sessionId) {\n                    this._storeLock(projectId, lock);\n                }\n                break;\n        }\n    }\n\n    /**\n     * Cleanup method for testing or shutdown.\n     */\n    destroy() {\n        // Stop all heartbeats\n        for (const projectId of this.heartbeatIntervals.keys()) {\n            this._stopHeartbeat(projectId);\n        }\n\n        // Close channel\n        if (this.channel) {\n            this.channel.close();\n            this.channel = null;\n        }\n\n        this.localLocks.clear();\n        this.lockChangeListeners.clear();\n        this.initialized = false;\n    }\n}\n\n// Export singleton instance\nexport const projectLockService = new ProjectLockService();\n\nexport default projectLockService;\n","import LocalStorageAdapter from './drivers/LocalStorageAdapter.js';\nimport { userContext } from '../core/UserContext.js';\nimport {\n    wrapWithMetadata,\n    unwrapMetadata,\n    hasMetadata,\n    markAsSynced,\n    markAsConflict,\n    SyncStatus,\n    LockStatus,\n    generateDocId,\n} from './SyncMetadata.js';\nimport { projectLockService } from './ProjectLockService.js';\n\nconst PROJECT_KEY_PREFIX = 'cine_project:';\n\n/**\n * @class StorageRepository\n * The main entry point for data persistence.\n * \n * Features:\n * - User-scoped storage via UserContext\n * - Sync metadata wrapping for cloud-ready data\n * - Project locking integration for concurrent edit prevention\n * - Driver swapping (LocalStorage  IndexedDB)\n */\nexport class StorageRepository {\n    constructor() {\n        this.driver = new LocalStorageAdapter();\n        this.initialized = false;\n    }\n\n    /**\n     * Initializes the active storage driver.\n     */\n    async init() {\n        if (this.initialized) return;\n\n        // Default to LocalStorage\n        await this.driver.init();\n        console.log('[StorageRepository] Initialized with default driver:', this.driver.constructor.name);\n        this.initialized = true;\n\n        // Initialize project lock service\n        projectLockService.init();\n    }\n\n    /**\n     * Switches the underlying driver at runtime.\n     * Useful after migration completes.\n     * @param {StorageInterface} newDriver \n     */\n    async switchDriver(newDriver) {\n        console.log('[StorageRepository] Switching driver to:', newDriver.constructor.name);\n        await newDriver.init();\n        this.driver = newDriver;\n    }\n\n    // --- Core Storage Methods ---\n\n    async getItem(key) {\n        if (!this.initialized) await this.init();\n        const scopedKey = userContext.getScopedKey(key);\n        return this.driver.getItem(scopedKey);\n    }\n\n    async setItem(key, value) {\n        if (!this.initialized) await this.init();\n        const scopedKey = userContext.getScopedKey(key);\n        return this.driver.setItem(scopedKey, value);\n    }\n\n    async removeItem(key) {\n        if (!this.initialized) await this.init();\n        const scopedKey = userContext.getScopedKey(key);\n        return this.driver.removeItem(scopedKey);\n    }\n\n    async clear() {\n        if (!this.initialized) await this.init();\n        const keys = await this.driver.getKeys();\n        const prefix = `user_${userContext.getUserId()}_`;\n        const deletionPromises = keys\n            .filter(k => k.startsWith(prefix))\n            .map(k => this.driver.removeItem(k));\n        await Promise.all(deletionPromises);\n    }\n\n    async getKeys() {\n        if (!this.initialized) await this.init();\n        const allKeys = await this.driver.getKeys();\n        const prefix = `user_${userContext.getUserId()}_`;\n        return allKeys\n            .filter(k => k.startsWith(prefix))\n            .map(k => k.slice(prefix.length));\n    }\n\n    getProjectKeyPrefix() {\n        return PROJECT_KEY_PREFIX;\n    }\n\n    getProjectStorageKey(projectKey) {\n        return `${PROJECT_KEY_PREFIX}${projectKey}`;\n    }\n\n    getProjectKeyFromStorageKey(storageKey) {\n        if (typeof storageKey !== 'string') return storageKey;\n        if (!storageKey.startsWith(PROJECT_KEY_PREFIX)) {\n            return storageKey;\n        }\n        return storageKey.slice(PROJECT_KEY_PREFIX.length);\n    }\n\n    isProjectStorageKey(storageKey) {\n        return typeof storageKey === 'string' && storageKey.startsWith(PROJECT_KEY_PREFIX);\n    }\n\n    async getProjectKeys() {\n        const keys = await this.getKeys();\n        return keys\n            .filter(key => this.isProjectStorageKey(key))\n            .map(key => this.getProjectKeyFromStorageKey(key));\n    }\n\n    // --- Sync-Aware Project Methods ---\n\n    /**\n     * Loads a project with its sync metadata.\n     * @param {string} projectKey \n     * @returns {Promise<{ data: any, meta: Object|null }>}\n     */\n    async loadProject(projectKey) {\n        const storageKey = this.getProjectStorageKey(projectKey);\n        const raw = await this.getItem(storageKey);\n        return unwrapMetadata(raw);\n    }\n\n    /**\n     * Loads raw project data without unwrapping (legacy compatibility).\n     * @param {string} projectKey \n     * @returns {Promise<any>}\n     */\n    async loadProjectRaw(projectKey) {\n        const result = await this.loadProject(projectKey);\n        return result.data;\n    }\n\n    /**\n     * Saves a project with sync metadata.\n     * @param {string} projectKey - Unique project identifier\n     * @param {Object} projectData - The actual project data\n     * @param {Object} [existingMeta] - Existing metadata to update\n     * @returns {Promise<{ success: boolean, meta: Object }>}\n     */\n    async saveProject(projectKey, projectData, existingMeta = null) {\n        if (!this.initialized) await this.init();\n\n        // Check lock status\n        const lockInfo = projectLockService.getLockInfo(projectKey);\n        if (!lockInfo.isEditable) {\n            console.warn('[StorageRepository] Cannot save - project is locked by another session');\n            return {\n                success: false,\n                error: 'PROJECT_LOCKED',\n                lockInfo\n            };\n        }\n\n        // Wrap with metadata\n        const wrapped = wrapWithMetadata(projectData, existingMeta, {\n            docType: 'project',\n            docId: projectKey,\n        });\n\n        // Save to storage\n        const storageKey = this.getProjectStorageKey(projectKey);\n        await this.setItem(storageKey, wrapped);\n\n        // Best-effort OPFS DataVault snapshot: optional for local saves, never blocks the\n        // primary save path, and exists to strengthen offline recovery resilience.\n        import('./DataVault.js').then(({ dataVault }) => {\n            if (dataVault) {\n                dataVault.saveSnapshot(projectKey, wrapped).catch(err =>\n                    console.warn('Auto-backup failed', err)\n                );\n            }\n        });\n\n        console.log('[StorageRepository] Project saved with metadata:', projectKey);\n        return { success: true, meta: wrapped._meta };\n    }\n\n    /**\n     * Gets only the sync metadata for a project without loading full data.\n     * Useful for sync status checks.\n     * @param {string} projectKey \n     * @returns {Promise<Object|null>}\n     */\n    async getProjectMeta(projectKey) {\n        const storageKey = this.getProjectStorageKey(projectKey);\n        const raw = await this.getItem(storageKey);\n        if (!hasMetadata(raw)) return null;\n        return raw._meta;\n    }\n\n    /**\n     * Marks a project as synced with the cloud.\n     * @param {string} projectKey \n     * @param {string} [serverTimestamp] - Timestamp from server\n     * @returns {Promise<boolean>}\n     */\n    async markProjectSynced(projectKey, serverTimestamp = null) {\n        const storageKey = this.getProjectStorageKey(projectKey);\n        const raw = await this.getItem(storageKey);\n        if (!hasMetadata(raw)) {\n            console.warn('[StorageRepository] Cannot mark as synced - no metadata');\n            return false;\n        }\n\n        raw._meta = markAsSynced(raw._meta, serverTimestamp);\n        await this.setItem(storageKey, raw);\n        return true;\n    }\n\n    /**\n     * Marks a project as having a sync conflict.\n     * @param {string} projectKey \n     * @param {string} errorMessage \n     * @returns {Promise<boolean>}\n     */\n    async markProjectConflict(projectKey, errorMessage) {\n        const storageKey = this.getProjectStorageKey(projectKey);\n        const raw = await this.getItem(storageKey);\n        if (!hasMetadata(raw)) return false;\n\n        raw._meta = markAsConflict(raw._meta, errorMessage);\n        await this.setItem(storageKey, raw);\n        return true;\n    }\n\n    /**\n     * Gets all projects that need syncing.\n     * @returns {Promise<Array<{ key: string, meta: Object }>>}\n     */\n    async getPendingSyncProjects() {\n        const keys = await this.getProjectKeys();\n        const pending = [];\n\n        for (const key of keys) {\n            const meta = await this.getProjectMeta(key);\n            if (meta && (\n                meta.syncStatus === SyncStatus.PENDING ||\n                meta.syncStatus === SyncStatus.LOCAL_ONLY\n            )) {\n                pending.push({ key, meta });\n            }\n        }\n\n        return pending;\n    }\n\n    /**\n     * Lists all projects with their metadata.\n     * @returns {Promise<Array<{ key: string, data: any, meta: Object|null }>>}\n     */\n    async listProjects() {\n        const keys = await this.getProjectKeys();\n        const projects = [];\n\n        for (const key of keys) {\n            const { data, meta } = await this.loadProject(key);\n            // Filter to only items that look like projects (have metadata with docType)\n            if (meta && meta.docType === 'project') {\n                projects.push({ key, data, meta });\n            }\n        }\n\n        return projects;\n    }\n\n    // --- Lock Management Pass-through ---\n\n    /**\n     * Attempts to acquire an edit lock on a project.\n     * @param {string} projectKey \n     * @param {Object} [options] - { force: boolean }\n     * @returns {Promise<{ success: boolean, status: string }>}\n     */\n    async acquireProjectLock(projectKey, options = {}) {\n        if (!this.initialized) await this.init();\n        return projectLockService.acquireLock(projectKey, options);\n    }\n\n    /**\n     * Releases an edit lock on a project.\n     * @param {string} projectKey \n     * @returns {Promise<boolean>}\n     */\n    async releaseProjectLock(projectKey) {\n        return projectLockService.releaseLock(projectKey);\n    }\n\n    /**\n     * Gets lock info for a project.\n     * @param {string} projectKey \n     * @returns {{ status: string, isEditable: boolean }}\n     */\n    getProjectLockInfo(projectKey) {\n        return projectLockService.getLockInfo(projectKey);\n    }\n\n    /**\n     * Subscribe to lock changes.\n     * @param {Function} callback - (projectKey, status, lock) => void\n     * @returns {Function} Unsubscribe function\n     */\n    onLockChange(callback) {\n        return projectLockService.subscribe(callback);\n    }\n\n    async removeProject(projectKey) {\n        const storageKey = this.getProjectStorageKey(projectKey);\n        return this.removeItem(storageKey);\n    }\n\n    async migrateUnprefixedProjectRecords({ projectIndexKeys = [] } = {}) {\n        if (!this.initialized) await this.init();\n\n        const keys = await this.getKeys();\n        const prefixedKeys = new Set(keys.filter(key => this.isProjectStorageKey(key)));\n        const candidates = new Set();\n        const indexKeys = Array.isArray(projectIndexKeys) ? projectIndexKeys : [];\n\n        indexKeys.forEach((key) => {\n            const rawKey = this.getProjectKeyFromStorageKey(key);\n            if (typeof rawKey === 'string' && rawKey) {\n                candidates.add(rawKey);\n            }\n        });\n\n        for (const key of keys) {\n            if (this.isProjectStorageKey(key)) continue;\n            if (candidates.has(key)) continue;\n\n            const value = await this.getItem(key);\n            if (hasMetadata(value) && value._meta && value._meta.docType === 'project') {\n                candidates.add(key);\n            }\n        }\n\n        const migrated = [];\n\n        for (const rawKey of candidates) {\n            if (typeof rawKey !== 'string' || !rawKey) continue;\n            const prefixedKey = this.getProjectStorageKey(rawKey);\n            if (prefixedKeys.has(prefixedKey)) {\n                continue;\n            }\n\n            const value = await this.getItem(rawKey);\n            if (value === null || value === undefined) {\n                continue;\n            }\n\n            try {\n                await this.setItem(prefixedKey, value);\n                await this.removeItem(rawKey);\n                prefixedKeys.add(prefixedKey);\n                migrated.push(rawKey);\n            } catch (migrationError) {\n                console.warn(`[StorageRepository] Failed to migrate project key \"${rawKey}\"`, migrationError);\n            }\n        }\n\n        return { migratedKeys: migrated };\n    }\n}\n\n// Export a singleton instance\nexport const storageRepo = new StorageRepository();\n","import { get, set, del, clear, keys } from 'idb-keyval';\nimport LZString from 'lz-string';\nimport StorageInterface from '../StorageInterface.js';\n\n/**\n * @class IndexedDBAdapter\n * High-performance, asynchronous storage driver using IndexedDB.\n * Features transparent compression via LZ-String to maximize storage efficiency.\n */\nexport default class IndexedDBAdapter extends StorageInterface {\n    constructor() {\n        super();\n        this.name = 'IndexedDBAdapter';\n    }\n\n    /** @override */\n    async init() {\n        // IndexedDB/idb-keyval lazy-loads the DB connection on first request,\n        // so explicit init isn't strictly necessary but good for verification.\n        try {\n            if (typeof indexedDB === 'undefined') {\n                throw new Error('IndexedDB is not supported in this environment.');\n            }\n            return Promise.resolve();\n        } catch (e) {\n            console.warn('IndexedDB initialization failed:', e);\n            throw e;\n        }\n    }\n\n    /** @override */\n    async getItem(key) {\n        try {\n            const compressed = await get(key);\n            if (compressed === null || compressed === undefined) return null;\n\n            // Detect if the data is actually compressed or legacy uncompressed (migration safety)\n            // LZ-String compressed strings usually don't look like JSON.\n            // We attempt decompression first.\n            let decompressed = LZString.decompressFromUTF16(compressed);\n\n            // If decompression returns null (invalid/empty input) but we had data,\n            // it might be raw data (though we ensure we always compress on write).\n            // Or it might be that LZString returns null on failure.\n\n            const payload = decompressed !== null ? decompressed : compressed;\n\n            try {\n                return JSON.parse(payload);\n            } catch {\n                // If it's not JSON, return raw string (rare case for us)\n                return payload;\n            }\n        } catch (e) {\n            console.warn(`[IndexedDBAdapter] Failed to get/decompress item: ${key}`, e);\n            return null;\n        }\n    }\n\n    /** @override */\n    async setItem(key, value) {\n        try {\n            const stringified = typeof value === 'string' ? value : JSON.stringify(value);\n            const compressed = LZString.compressToUTF16(stringified);\n            await set(key, compressed);\n        } catch (e) {\n            console.error(`[IndexedDBAdapter] Failed to compress/save item: ${key}`, e);\n            throw e;\n        }\n    }\n\n    /** @override */\n    async removeItem(key) {\n        return del(key);\n    }\n\n    /** @override */\n    async clear() {\n        return clear();\n    }\n\n    /** @override */\n    async getKeys() {\n        return keys();\n    }\n}\n","import { storageRepo } from './StorageRepository.js';\nimport LocalStorageAdapter from './drivers/LocalStorageAdapter.js';\nimport IndexedDBAdapter from './drivers/IndexedDBAdapter.js';\n\nconst MIGRATION_FLAG_KEY = 'cine_storage_migrated_v2';\n\n/**\n * Service to handle the one-time migration from LocalStorage to IndexedDB.\n */\nexport class StorageMigrationService {\n    constructor() {\n        this.localStorage = new LocalStorageAdapter();\n        this.indexedDB = new IndexedDBAdapter();\n    }\n\n    /**\n     * Checks if migration is needed and executes it.\n     * @returns {Promise<boolean>} True if migration occurred, False otherwise.\n     */\n    async runMigrationIfNeeded() {\n        try {\n            await this.localStorage.init();\n            await this.indexedDB.init();\n\n            const alreadyMigrated = await this.localStorage.getItem(MIGRATION_FLAG_KEY);\n            if (alreadyMigrated === 'true') {\n                console.log('[MigrationService] Storage already migrated to IndexedDB.');\n                return false;\n            }\n\n            console.log('[MigrationService] Starting storage migration...');\n\n            const keys = await this.localStorage.getKeys();\n            if (keys.length === 0) {\n                console.log('[MigrationService] No local storage data found. safe to skip.');\n                await this.markAsMigrated();\n                return false;\n            }\n\n            // Filter out internal flags that don't need migration\n            const keysToMigrate = keys.filter(k => k !== MIGRATION_FLAG_KEY && k !== 'cine_user_uuid');\n\n            // [Update] Get User Context to scope the new keys in IDB\n            // We perform the scoping manual here because we are writing directly to the IDB driver\n            // via StorageRepository (which now scopes), OR we use the adapter directly?\n            // Wait, StorageRepository.setItem NOW uses UserContext.\n            // But MigrationService has `new IndexedDBAdapter()`.\n            // If we use adapter directly, we must manually scope.\n            // Let's use the `userContext` helper.\n\n            let userContext;\n            try {\n                const module = await import('../core/UserContext.js');\n                userContext = module.userContext;\n                if (!userContext) {\n                    throw new Error('UserContext module loaded but userContext export is missing');\n                }\n                userContext.init(); // Ensure user ID exists\n            } catch (importError) {\n                console.error('[MigrationService] Failed to load UserContext for scoping. Aborting migration to prevent data loss.', importError);\n                // We must abort if we can't scope correctly, otherwise we write unscoped data to IDB which V2 won't see.\n                return false;\n            }\n\n            for (const key of keysToMigrate) {\n                try {\n                    const value = await this.localStorage.getItem(key);\n                    if (value !== null) {\n                        // Scope the key for the IDB destination\n                        const scopedKey = userContext.getScopedKey(key);\n                        await this.indexedDB.setItem(scopedKey, value);\n                        console.log(`[MigrationService] Migrated key: ${key} -> ${scopedKey}`);\n                    }\n                } catch (itemError) {\n                    console.error(`[MigrationService] Failed to migrate key: ${key}`, itemError);\n                    // We continue migration even if one key fails, but we should probably alert the user in a real app.\n                    // For now, robust logging is key.\n                }\n            }\n\n            await this.markAsMigrated();\n            console.log('[MigrationService] Migration complete. IndexedDB is now the primary storage.');\n            return true;\n\n        } catch (e) {\n            console.error('[MigrationService] Critical migration failure:', e);\n            return false; // Safely fail, app will continue using whatever repo is set (default LocalStorage)\n        }\n    }\n\n    async markAsMigrated() {\n        // We set the flag in BOTH storages for safety.\n        // We use a robust approach: try both, log errors, but don't fail the operation\n        // if at least one succeeds (or even if both fail, we might want to continue, but let's try best effort).\n        const setSafely = async (adapter, name) => {\n            try {\n                await adapter.setItem(MIGRATION_FLAG_KEY, 'true');\n            } catch (e) {\n                console.warn(`[MigrationService] Failed to set migration flag in ${name}:`, e);\n            }\n        };\n\n        await Promise.all([\n            setSafely(this.localStorage, 'LocalStorage'),\n            setSafely(this.indexedDB, 'IndexedDB')\n        ]);\n    }\n\n    /**\n     * Checks if the migration flag is set in either storage.\n     * @returns {Promise<boolean>}\n     */\n    async isMigrated() {\n        try {\n            // Check LocalStorage first (faster)\n            const lsFlag = await this.localStorage.getItem(MIGRATION_FLAG_KEY);\n            if (lsFlag === 'true') return true;\n\n            // Fallback: Check IndexedDB (in case LS was wiped but IDB persists)\n            const idbFlag = await this.indexedDB.getItem(MIGRATION_FLAG_KEY);\n            return idbFlag === 'true';\n        } catch (e) {\n            console.warn('[MigrationService] Failed to check migration status:', e);\n            return false;\n        }\n    }\n}\n\nexport const migrationService = new StorageMigrationService();\n","import { storageRepo } from '../storage/StorageRepository.js';\n\nconst OWN_GEAR_KEY = 'cameraPowerPlanner_ownGear';\n\n/**\n * @class GearRepository\n * Unifies access to built-in device library and user's \"Own Gear\".\n * Migrates \"Own Gear\" to IndexedDB/StorageRepository.\n */\nclass GearRepository {\n    constructor() {\n        this.memoryCache = null;\n    }\n\n    /**\n     * Loads user-defined gear.\n     * Uses the central StorageRepository (which now uses IndexedDB).\n     * @returns {Promise<Array>}\n     */\n    async getOwnGear() {\n        if (this.memoryCache) return this.memoryCache;\n\n        try {\n            const data = await storageRepo.getItem(OWN_GEAR_KEY);\n\n            // Normalize data structure\n            // Format: { items: [...] } or [...]\n            if (!data) return [];\n\n            if (Array.isArray(data)) {\n                this.memoryCache = data;\n            } else if (data.items && Array.isArray(data.items)) {\n                this.memoryCache = data.items;\n            } else {\n                this.memoryCache = [];\n            }\n        } catch (e) {\n            console.warn('[GearRepository] Failed to load own gear:', e);\n            this.memoryCache = [];\n        }\n\n        return this.memoryCache;\n    }\n\n    /**\n     * Saves user-defined gear.\n     * @param {Array} items \n     */\n    async saveOwnGear(items) {\n        if (!Array.isArray(items)) {\n            console.error('[GearRepository] saveOwnGear expects an array');\n            return;\n        }\n\n        this.memoryCache = items;\n\n        // Wrap in object if needed or store as array.\n        // Legacy storage used { items: [...] } sometimes, but let's standardize.\n        // However, to keep compatibility with old JSON format, maybe stick to array if that's what was used.\n        // storage.js used to store it as entries directly or wrapped.\n        // Let's store as is.\n        await storageRepo.setItem(OWN_GEAR_KEY, items);\n    }\n\n    /**\n     * Add a single item to own gear.\n     * @param {Object} item \n     */\n    async addOwnGearItem(item) {\n        const items = await this.getOwnGear();\n        items.push(item);\n        await this.saveOwnGear(items);\n    }\n\n    /**\n   * Returns the static global device library.\n   * Assumes global object 'deviceLibrary' exists (loaded via script).\n   * @returns {Object}\n   */\n    getLibrary() {\n        if (typeof window !== 'undefined' && window.deviceLibrary) {\n            return window.deviceLibrary;\n        }\n        if (typeof globalThis !== 'undefined' && globalThis.deviceLibrary) {\n            return globalThis.deviceLibrary;\n        }\n        return {};\n    }\n\n    /**\n     * Unified search for gear.\n     * Searches both static library and own gear.\n     * @param {string} query \n     * @returns {Promise<Array>}\n     */\n    async searchGear(query) {\n        if (!query) return [];\n        const q = query.toLowerCase();\n\n        // 1. Search Own Gear\n        const ownGear = await this.getOwnGear();\n        const ownMatches = ownGear.filter(item =>\n            (item.name && item.name.toLowerCase().includes(q)) ||\n            (item.brand && item.brand.toLowerCase().includes(q))\n        );\n\n        // 2. Search Static Library\n        // This requires traversing the complex deviceLibrary object structure\n        // We'll skip deep traversal for now as V1 had specific search logic we might want to reuse.\n        // For now, returning ownMatches is a good start.\n\n        return ownMatches;\n    }\n}\n\nexport const gearRepo = new GearRepository();\n","/**\n * @class DataVault\n * Manages long-term file storage using the Origin Private File System (OPFS).\n * Provides a \"Vault\" for immutable checkpoints and backups.\n */\nexport class DataVault {\n    constructor() {\n        this.root = null;\n        this.initialized = false;\n    }\n\n    async init() {\n        if (this.initialized) return;\n        try {\n            if (!navigator.storage || !navigator.storage.getDirectory) {\n                console.warn('[DataVault] OPFS is not supported in this browser.');\n                return;\n            }\n            this.root = await navigator.storage.getDirectory();\n            this.initialized = true;\n        } catch (e) {\n            console.error('[DataVault] Failed to initialize OPFS:', e);\n        }\n    }\n\n    /**\n     * Saves a project snapshot to the vault.\n     * @param {string} filename \n     * @param {Object} data \n     */\n    async saveSnapshot(filename, data) {\n        if (!this.initialized) await this.init();\n        if (!this.root) throw new Error('OPFS not available');\n\n        try {\n            // Sanitize filename to strict alphanumeric + safe chars to avoid path separators\n            const safeFilename = filename.replace(/[^a-z0-9_\\-\\.\\s]/gi, '_');\n            const fileHandle = await this.root.getFileHandle(safeFilename + '.json', { create: true });\n\n            // Create a writable stream\n            const writable = await fileHandle.createWritable();\n\n            // Write data (JSON stringified)\n            await writable.write(JSON.stringify(data));\n\n            // Close the file\n            await writable.close();\n\n            console.log(`[DataVault] Saved snapshot: ${filename}`);\n            return true;\n        } catch (e) {\n            console.error(`[DataVault] Failed to save snapshot ${filename}:`, e);\n            throw e;\n        }\n    }\n\n    /**\n     * Lists all available snapshots in the vault.\n     * @returns {Promise<string[]>} List of filenames\n     */\n    async listSnapshots() {\n        if (!this.initialized) await this.init();\n        if (!this.root) return [];\n\n        const files = [];\n        try {\n            // Iterate over entries\n            // Note: OPFS iteration syntax varies slightly by browser, but standard is async iterator\n            for await (const [name, handle] of this.root.entries()) {\n                if (handle.kind === 'file' && name.endsWith('.json')) {\n                    files.push(name);\n                }\n            }\n        } catch (e) {\n            console.error('[DataVault] Failed to list snapshots:', e);\n        }\n        return files.sort().reverse(); // Newest first (assuming timestamped names)\n    }\n\n    /**\n     * Reads a snapshot from the vault.\n     * @param {string} filename \n     * @returns {Promise<Object>} The parsed data\n     */\n    async restoreSnapshot(filename) {\n        if (!this.initialized) await this.init();\n        if (!this.root) throw new Error('OPFS not available');\n\n        try {\n            const fileHandle = await this.root.getFileHandle(filename);\n            const file = await fileHandle.getFile();\n            const text = await file.text();\n            return JSON.parse(text);\n        } catch (e) {\n            console.error(`[DataVault] Failed to restore snapshot ${filename}:`, e);\n            throw e;\n        }\n    }\n\n    /**\n     * Deletes a snapshot.\n     * @param {string} filename \n     */\n    async deleteSnapshot(filename) {\n        if (!this.initialized) await this.init();\n        if (!this.root) return;\n\n        try {\n            await this.root.removeEntry(filename);\n            console.log(`[DataVault] Deleted snapshot: ${filename}`);\n        } catch (e) {\n            console.warn(`[DataVault] Failed to delete snapshot ${filename}:`, e);\n        }\n    }\n\n    /**\n     * Wipes the entire vault (Factory Reset).\n     */\n    async clear() {\n        if (!this.initialized) await this.init();\n        if (!this.root) return;\n\n        try {\n            const files = await this.listSnapshots();\n            for (const file of files) {\n                await this.root.removeEntry(file);\n            }\n            console.log('[DataVault] All data wiped.');\n        } catch (e) {\n            console.error('[DataVault] Failed to wipe vault:', e);\n        }\n    }\n}\n\nexport const dataVault = new DataVault();\n","\n/**\n * Cine Power Planner - Storage Orchestration\n * \n * This module manages all persistence operations, project indexing, and data backups.\n * It implements a hybrid architecture:\n * 1. Synchronous Memory Cache: For near-instant reads and Auto-Gear compatibility.\n * 2. Asynchronous Storage Drivers: Leveraging LocalStorage (legacy) and IndexedDB (modern).\n * 3. Cross-Tab Coordination: synchronizing state across multiple open tabs via BroadcastChannel.\n * \n * The module also handles the critical migration path from monolithic LocalStorage \n * to granular IndexedDB shards to ensure no data loss during application updates.\n */\nconsole.log('DEBUG: storage.js execution started');\n// storage.js - Handles reading from and writing to localStorage.\nimport * as consoleHelpersImport from './console-helpers.js';\nimport loggingResolverImport from './modules/logging-resolver.js';\nimport contactsModuleImport from './modules/features/contacts.js';\nimport { storageRepo } from './modules/storage/StorageRepository.js';\nimport { migrationService } from './modules/storage/StorageMigrationService.js';\nimport IndexedDBAdapter from './modules/storage/drivers/IndexedDBAdapter.js';\nimport { gearRepo } from './modules/gear/GearRepository.js';\nimport { userContext } from './modules/core/UserContext.js';\nimport { dataVault } from './modules/storage/DataVault.js';\n\nimport LZString from 'lz-string';\n\n// [Refactor] In-Memory Cache for Synchronous Read Capability (Hybrid IDB)\nlet projectMemoryCache = {};\nlet isProjectCacheHydrated = false;\n\n// Helper to hydrate cache from StorageRepository\n/**\n * Synchronous Project Cache Hydration\n * \n * RATIONALE: Certain application features (like Auto-Gear) require synchronous \n * access to project data. Since modern storage (IndexedDB) is inherently asynchronous, \n * we hydrate an in-memory cache on startup to provide the necessary performance \n * and compatibility guarantees.\n */\nasync function hydrateProjectCache() {\n  if (isProjectCacheHydrated) return;\n  console.log('[storage.js] Hydrating project cache from storage...');\n\n  try {\n    const projectKeys =\n      storageRepo && typeof storageRepo.getProjectKeys === 'function'\n        ? await storageRepo.getProjectKeys()\n        : [];\n    // [Agent Implementation] Actual Hydration Logic with Deterministic Ordering (Monolith First -> Shards Overwrite)\n    const monolithKey = 'cameraPowerPlanner_project';\n    let monolithValue = null;\n    const shardKeys = projectKeys.slice();\n\n    if (storageRepo && typeof storageRepo.getItem === 'function') {\n      const rawIndex = await storageRepo.getItem(PROJECT_INDEX_KEY);\n      const normalizedIndex = normalizeProjectIndexForCache(rawIndex);\n      if (normalizedIndex) {\n        projectIndexCache = normalizedIndex;\n      }\n\n      storageRepo.getItem(AUTO_GEAR_MONITOR_DEFAULTS_STORAGE_KEY).then(val => { if (val) autoGearMonitorDefaultsCache = val; });\n      storageRepo.getItem(AUTO_GEAR_ACTIVE_PRESET_STORAGE_KEY).then(val => { if (val) autoGearActivePresetIdCache = val; });\n      storageRepo.getItem(AUTO_GEAR_AUTO_PRESET_STORAGE_KEY).then(val => { if (val) autoGearAutoPresetIdCache = val; });\n      storageRepo.getItem(AUTO_GEAR_BACKUPS_STORAGE_KEY).then(val => {\n        if (Array.isArray(val)) {\n          autoGearBackupsCache = val;\n        }\n      });\n      storageRepo.getItem(AUTO_GEAR_BACKUP_RETENTION_STORAGE_KEY).then(val => { if (val) autoGearBackupRetentionCache = val; });\n      storageRepo.getItem(AUTO_GEAR_BACKUP_VISIBILITY_STORAGE_KEY).then(val => { if (val) autoGearBackupVisibilityCache = val; });\n      storageRepo.getItem(CUSTOM_FONT_STORAGE_KEY_DEFAULT).then(val => { if (val) customFontsCache = val; });\n      storageRepo.getItem(CUSTOM_LOGO_STORAGE_KEY).then(val => { if (val) customLogoCache = val; });\n      storageRepo.getItem(CAMERA_COLOR_STORAGE_KEY).then(val => { if (val) cameraColorsCache = val; });\n      storageRepo.getItem(PRINT_PREFERENCES_STORAGE_KEY).then(val => { if (val) printPreferencesCache = val; });\n      storageRepo.getItem(CONTACTS_STORAGE_KEY).then(val => { if (val) contactsCache = val; });\n      storageRepo.getItem(OWN_GEAR_STORAGE_KEY).then(val => { if (val) ownGearCache = val; });\n      storageRepo.getItem(USER_PROFILE_STORAGE_KEY).then(val => { if (val) userProfileCache = val; });\n      storageRepo.getItem(FAVORITES_STORAGE_KEY).then(val => { if (val) favoritesCache = val; });\n      storageRepo.getItem(TEMPERATURE_UNIT_STORAGE_KEY_NAME).then(val => { if (val) temperatureUnitCache = val; });\n      storageRepo.getItem(FOCUS_SCALE_STORAGE_KEY_NAME).then(val => { if (val) focusScaleCache = val; });\n      storageRepo.getItem(getMountVoltageStorageKeyName()).then(val => { if (val) mountVoltagesCache = val; });\n      storageRepo.getItem(FULL_BACKUP_HISTORY_STORAGE_KEY).then(val => { if (val) fullBackupHistoryCache = val; });\n\n      monolithValue = await storageRepo.getItem(monolithKey);\n    }\n\n    // 1. Load Monolith (if exists)\n    if (monolithValue && typeof monolithValue === 'object') {\n      try {\n        Object.assign(projectMemoryCache, monolithValue);\n      } catch (monoErr) {\n        console.warn('[hydrate] Failed to load monolith', monoErr);\n      }\n    }\n\n    // 2. Load Shards (Parallel) - Overwrites monolith entries if collision\n    const shardPromises = shardKeys.map(async (key) => {\n      try {\n        const val = await storageRepo.loadProjectRaw(key);\n        if (val) {\n          projectMemoryCache[key] = val;\n        }\n      } catch (shardErr) {\n        console.warn('[hydrate] Failed to load shard', key, shardErr);\n      }\n    });\n\n    await Promise.all(shardPromises);\n    isProjectCacheHydrated = true;\n    console.log('[storage.js] Project cache hydrated. Keys:', Object.keys(projectMemoryCache).length);\n  } catch (e) {\n    console.warn('Cache hydration failed', e);\n  }\n}\n\n// (function initializeStorageModule() {\n\nconst GLOBAL_SCOPE =\n\n\n  typeof globalThis !== 'undefined'\n    ? globalThis\n    : typeof window !== 'undefined'\n      ? window\n      : typeof global !== 'undefined'\n        ? global\n        : typeof self !== 'undefined'\n          ? self\n          : null;\n\n// Test suites and certain recovery tools need a way to force the storage\n// module to rebuild itself. This flag lets those callers opt-in without\n// impacting normal user sessions.\nconst FORCE_STORAGE_REINITIALIZE =\n  typeof process !== 'undefined' &&\n  process &&\n  process.env &&\n  (process.env.JEST_WORKER_ID || process.env.CINE_FORCE_STORAGE_REINIT);\n\n\n\nconst FACTORY_RESET_LOCK_KEY = 'cine_factory_reset_lock';\n\n\nif (GLOBAL_SCOPE && GLOBAL_SCOPE.__cineStorageInitialized) {\n  if (FORCE_STORAGE_REINITIALIZE) {\n    try {\n      delete GLOBAL_SCOPE.__cineStorageInitialized;\n    } catch (resetInitFlagError) {\n      GLOBAL_SCOPE.__cineStorageInitialized = false;\n      void resetInitFlagError;\n    }\n\n    try {\n      delete GLOBAL_SCOPE.__cineStorageApi;\n    } catch (resetApiError) {\n      GLOBAL_SCOPE.__cineStorageApi = null;\n      void resetApiError;\n    }\n\n    try {\n      delete GLOBAL_SCOPE.__cineMonolithicProjectCleanupDone;\n    } catch (resetCleanupFlagError) {\n      GLOBAL_SCOPE.__cineMonolithicProjectCleanupDone = false;\n      void resetCleanupFlagError;\n    }\n  } else {\n    if (\n      typeof module !== 'undefined' &&\n      module.exports &&\n      GLOBAL_SCOPE.__cineStorageApi &&\n      typeof GLOBAL_SCOPE.__cineStorageApi === 'object'\n    ) {\n      module.exports = GLOBAL_SCOPE.__cineStorageApi;\n    }\n    // ESM: Cannot use top-level return, so we set a flag to skip main logic\n\n  }\n}\n\n// [Added by Agent] Lifecycle channel for cross-tab coordination\n/**\n * Lifecycle Channel (Cross-Tab Coordination)\n * \n * RATIONALE: To ensure a consistent user experience when multiple tabs are open, \n * this channel broadcasts critical events like factory resets or project changes. \n * This prevents data corruption and ensures that all instances of the app \n * reflect the same underlying state.\n */\nconst LIFECYCLE_CHANNEL_NAME = 'cine-power-planner-lifecycle';\nlet lifecycleChannel = null;\nconst isJestWorker = typeof process !== 'undefined' && process && process.env && process.env.JEST_WORKER_ID;\nif (typeof BroadcastChannel !== 'undefined' && !isJestWorker) {\n  try {\n    lifecycleChannel = new BroadcastChannel(LIFECYCLE_CHANNEL_NAME);\n    if (lifecycleChannel) {\n      lifecycleChannel.onmessage = (event) => {\n        if (event && event.data === 'factory-reset') {\n          if (GLOBAL_SCOPE) {\n            GLOBAL_SCOPE.__cameraPowerPlannerFactoryResetting = true;\n            try {\n              if (typeof sessionStorage !== 'undefined') {\n                sessionStorage.setItem(FACTORY_RESET_LOCK_KEY, 'true');\n              }\n              if (typeof localStorage !== 'undefined') {\n                localStorage.setItem(FACTORY_RESET_LOCK_KEY, 'true');\n              }\n            } catch (lockError) {\n              void lockError;\n            }\n            // Clear session storage locally before reload to ensure it doesn't survive\n            // since page reload alone might preserve it in some browsers.\n            if (typeof sessionStorage !== 'undefined' && typeof sessionStorage.clear === 'function') {\n              try {\n                // We must preserve the lock key if we just set it\n                const lockValue = sessionStorage.getItem(FACTORY_RESET_LOCK_KEY);\n                sessionStorage.clear();\n                if (lockValue) {\n                  sessionStorage.setItem(FACTORY_RESET_LOCK_KEY, lockValue);\n                }\n              } catch (e) {\n                void e;\n              }\n            }\n            if (typeof GLOBAL_SCOPE.location !== 'undefined' && typeof GLOBAL_SCOPE.location.reload === 'function') {\n              GLOBAL_SCOPE.location.reload();\n            }\n          }\n        } else if (event.data === 'project-shards-changed') {\n          invalidateProjectReadCache();\n        }\n      };\n    }\n  } catch (channelError) {\n    // BroadcastChannel might be restricted in some environments\n    void channelError;\n  }\n}\n\nif (GLOBAL_SCOPE) {\n  try {\n    // Clear any lingering factory reset lock on initialization\n    const scopeList = [\n      typeof window !== 'undefined' ? window : null,\n      typeof sessionStorage !== 'undefined' ? sessionStorage : null,\n      typeof localStorage !== 'undefined' ? localStorage : null\n    ];\n\n    // [Agent Change] Check if we are freshly returning from a factory reset.\n    // We set a flag so that loadJSONFromStorage knows to skip backup recovery\n    // for this session, allowing a clean slate.\n    let justReset = false;\n    scopeList.forEach(s => {\n      if (s && typeof s.getItem === 'function') {\n        try {\n          if (s.getItem(FACTORY_RESET_LOCK_KEY)) justReset = true;\n        } catch (e) { void e; }\n      }\n    });\n    if (justReset) {\n      GLOBAL_SCOPE.__cineJustFactoryReset = true;\n    }\n\n    scopeList.forEach(s => {\n      if (s && typeof s.removeItem === 'function') {\n        try { s.removeItem(FACTORY_RESET_LOCK_KEY); } catch (e) { void e; }\n      }\n    });\n\n    Object.defineProperty(GLOBAL_SCOPE, '__cineStorageInitialized', {\n      configurable: true,\n      writable: true,\n      value: true,\n    });\n\n    /**\n     * Storage Migration and Driver Initialization\n     * \n     * RATIONALE: We fire the migration asynchronously to avoid blocking the main \n     * thread during UI boot. The StorageRepository defaults to LocalStorage \n     * for immediate availability, then upgrades to IndexedDB once the migration \n     * (the \"sharding\" process) is safely completed.\n     */\n    (async () => {\n      try {\n        let shouldHydrateProjectCache = false;\n        if (migrationService && typeof migrationService.runMigrationIfNeeded === 'function') {\n          const migrated = await migrationService.runMigrationIfNeeded();\n          const isNative = await migrationService.isMigrated();\n          if (migrated || isNative) {\n            if (migrated) console.log('[storage.js] Migration successful. Switching to IndexedDB.');\n            else console.log('[storage.js] Native IndexedDB mode active.');\n\n            await storageRepo.switchDriver(new IndexedDBAdapter());\n            shouldHydrateProjectCache = true;\n          }\n        } else if (migrationService && typeof migrationService.init === 'function') {\n          // Fallback for V2 init method\n          const migrated = await migrationService.init();\n          // We can try to guess if we should be native here too, but legacy service might lack isMigrated\n          let isNative = false;\n          if (typeof migrationService.isMigrated === 'function') {\n            isNative = await migrationService.isMigrated();\n          }\n\n          if (migrated || isNative) {\n            await storageRepo.switchDriver(new IndexedDBAdapter());\n            shouldHydrateProjectCache = true;\n          }\n        }\n\n        const prefixMigrationOutcome = await migrateProjectKeyPrefixOnStartup();\n\n        if (shouldHydrateProjectCache) {\n          await hydrateProjectCache();\n          if (\n            (!prefixMigrationOutcome.hasIndex || !projectIndexCache)\n            && isProjectCacheHydrated\n            && projectMemoryCache\n            && Object.keys(projectMemoryCache).length > 0\n          ) {\n            try {\n              updateProjectIndex(projectMemoryCache, getSafeLocalStorage());\n            } catch (indexRefreshError) {\n              console.warn('Failed to refresh project index after migration', indexRefreshError);\n            }\n          }\n        }\n      } catch (migrationError) {\n        console.warn('[storage.js] Migration service failed:', migrationError);\n      }\n    })();\n\n  } catch (storageInitFlagError) {\n    GLOBAL_SCOPE.__cineStorageInitialized = true;\n    void storageInitFlagError;\n  }\n}\n\n// [Added by Agent] Expose a teardown method for tests to close the channel\n// and allow the process to exit cleanly.\nfunction closeStorageLifecycle() {\n  if (lifecycleChannel) {\n    try {\n      lifecycleChannel.close();\n    } catch (closeError) {\n      void closeError;\n    }\n    lifecycleChannel = null;\n  }\n}\n// Export it if we are in a testing environment (implied by module.exports existence)\nif (typeof module !== 'undefined' && module.exports) {\n  module.exports.closeStorageLifecycle = closeStorageLifecycle;\n}\n\n// Perform a defensive deep clone that keeps us safe even when the runtime\n// does not provide a structured clone implementation. JSON serialization is\n// attempted first, but this manual path is the resilient safety net that\n// prevents backup/restore data from being mutated when serialization fails.\nfunction storageManualDeepClone(value, references) {\n  if (value === null || typeof value !== 'object') {\n    return value;\n  }\n\n  let referenceStore = references;\n  if (!referenceStore) {\n    referenceStore =\n      typeof WeakMap === 'function'\n        ? new WeakMap()\n        : [];\n  }\n\n  if (typeof referenceStore.has === 'function' && typeof referenceStore.get === 'function') {\n    if (referenceStore.has(value)) {\n      return referenceStore.get(value);\n    }\n  } else if (Array.isArray(referenceStore)) {\n    for (let index = 0; index < referenceStore.length; index += 1) {\n      const entry = referenceStore[index];\n      if (entry && entry[0] === value) {\n        return entry[1];\n      }\n    }\n  }\n\n  const valueTag = Object.prototype.toString.call(value);\n  if (valueTag === '[object Date]') {\n    let clonedDate;\n    try {\n      const timeValue = typeof value.getTime === 'function' ? value.getTime() : value.valueOf();\n      clonedDate = new Date(timeValue);\n    } catch (dateCloneError) {\n      clonedDate = new Date(value);\n      void dateCloneError;\n    }\n\n    if (typeof referenceStore.set === 'function') {\n      referenceStore.set(value, clonedDate);\n    } else if (Array.isArray(referenceStore)) {\n      referenceStore.push([value, clonedDate]);\n    }\n\n    return clonedDate;\n  }\n\n  const clone = Array.isArray(value) ? [] : {};\n\n  if (typeof referenceStore.set === 'function') {\n    referenceStore.set(value, clone);\n  } else if (Array.isArray(referenceStore)) {\n    referenceStore.push([value, clone]);\n  }\n\n  if (Array.isArray(value)) {\n    for (let index = 0; index < value.length; index += 1) {\n      clone[index] = storageManualDeepClone(value[index], referenceStore);\n    }\n  } else {\n    const keys = Object.keys(value);\n    for (let index = 0; index < keys.length; index += 1) {\n      const key = keys[index];\n      clone[key] = storageManualDeepClone(value[key], referenceStore);\n    }\n  }\n\n  return clone;\n}\n\n// Try to clone via JSON first so we get predictable behaviour when the data\n// is serializable. If that throws, we fall back to the manual deep clone to\n// keep user backups and restore payloads protected from mutation.\nfunction storageJsonDeepClone(value) {\n  if (value === null || typeof value !== 'object') {\n    return value;\n  }\n\n  try {\n    return JSON.parse(JSON.stringify(value));\n  } catch (jsonCloneError) {\n    void jsonCloneError;\n  }\n\n  return storageManualDeepClone(value, null);\n}\n\n// Try to locate a built-in structuredClone implementation on whichever\n// runtime we are executing in. This is intentionally exhaustive because the\n// application must behave identically in browsers, service workers and\n// automated test environments.\nfunction storageResolveStructuredClone(scope) {\n  if (typeof structuredClone === 'function') {\n    return structuredClone;\n  }\n\n  if (scope && typeof scope.structuredClone === 'function') {\n    try {\n      return scope.structuredClone.bind(scope);\n    } catch (bindError) {\n      void bindError;\n    }\n  }\n\n  /* REMOVED node:util require for ESM\n  if (typeof require === 'function') {\n    try {\n      const nodeUtil = require('node:util');\n      if (nodeUtil && typeof nodeUtil.structuredClone === 'function') {\n        return nodeUtil.structuredClone.bind(nodeUtil);\n      }\n    } catch (nodeUtilError) {\n      void nodeUtilError;\n    }\n \n    try {\n      const legacyUtil = require('util');\n      if (legacyUtil && typeof legacyUtil.structuredClone === 'function') {\n        return legacyUtil.structuredClone.bind(legacyUtil);\n      }\n    } catch (legacyUtilError) {\n      void legacyUtilError;\n    }\n  }\n  */\n\n  return null;\n}\n\n// Wrap the structuredClone implementation in a safety net. If the platform\n// throws (for example because of cloning functions), we gracefully fall back\n// to the JSON based strategy so that persistence keeps working.\nfunction storageCreateResilientDeepClone(scope) {\n  const structuredCloneImpl = storageResolveStructuredClone(scope);\n\n  if (!structuredCloneImpl) {\n    return storageJsonDeepClone;\n  }\n\n  /**\n   * Resilient Deep Clone Strategy\n   * \n   * RATIONALE: Persistence operations frequently involve creating snapshots of large \n   * project objects. To prevent accidental mutations of shared state, we use a \n   * resilient cloning strategy that prioritizes native structuredClone, \n   * falls back to JSON serialization, and finally uses a manual deep clone for \n   * complex objects that cannot be normally serialized.\n   */\n  return function storageResilientDeepClone(value) {\n    if (value === null || typeof value !== 'object') {\n      return value;\n    }\n\n    try {\n      return structuredCloneImpl(value);\n    } catch (structuredCloneError) {\n      void structuredCloneError;\n    }\n\n    return storageJsonDeepClone(value);\n  };\n}\n\nconst STORAGE_DEEP_CLONE =\n  GLOBAL_SCOPE && typeof GLOBAL_SCOPE.__cineDeepClone === 'function'\n    ? GLOBAL_SCOPE.__cineDeepClone\n    : storageCreateResilientDeepClone(GLOBAL_SCOPE);\n\n// Track sessionStorage instances we have already vetted. This allows us to\n// reuse safe handles even when multiple windows or execution contexts are\n// interacting with the planner simultaneously.\nconst knownSessionStorages =\n  typeof WeakSet === 'function' ? new WeakSet() : null;\n\n// Register a sessionStorage reference that we know is safe to use. The\n// WeakSet ensures we do not keep windows alive longer than necessary.\nfunction registerKnownSessionStorage(storage) {\n  if (\n    !knownSessionStorages\n    || typeof knownSessionStorages.add !== 'function'\n    || !storage\n  ) {\n    return;\n  }\n\n  try {\n    knownSessionStorages.add(storage);\n  } catch (error) {\n    void error;\n  }\n}\n\n// Resolve the sessionStorage object from a candidate scope while silently\n// handling cross-origin access errors. We prefer returning null over\n// throwing so that autosave logic can continue without interruption.\nfunction resolveSessionStorageFromScope(scope) {\n  if (!scope || (typeof scope !== 'object' && typeof scope !== 'function')) {\n    return null;\n  }\n\n  try {\n    const candidate = scope.sessionStorage;\n    if (candidate && typeof candidate.getItem === 'function') {\n      return candidate;\n    }\n  } catch (error) {\n    void error;\n  }\n\n  return null;\n}\n\n// Attempt to discover sessionStorage references across all known scopes once\n// during module initialisation. This keeps read/write operations snappy later\n// on and avoids repeated try/catch cost when autosave is active.\n(function primeSessionStorageCandidates() {\n  const scopes = [\n    GLOBAL_SCOPE,\n    GLOBAL_SCOPE && GLOBAL_SCOPE.window ? GLOBAL_SCOPE.window : null,\n    GLOBAL_SCOPE && GLOBAL_SCOPE.__cineGlobal\n      ? GLOBAL_SCOPE.__cineGlobal\n      : null,\n    typeof window !== 'undefined' ? window : null,\n    typeof self !== 'undefined' ? self : null,\n    typeof global !== 'undefined' ? global : null,\n  ];\n\n  for (let index = 0; index < scopes.length; index += 1) {\n    const candidate = resolveSessionStorageFromScope(scopes[index]);\n    if (candidate) {\n      registerKnownSessionStorage(candidate);\n    }\n  }\n\n  if (typeof sessionStorage !== 'undefined') {\n    try {\n      registerKnownSessionStorage(sessionStorage);\n    } catch (error) {\n      void error;\n    }\n  }\n})();\n\nfunction resolveLocalStorageFromScope(scope) {\n  if (!scope || (typeof scope !== 'object' && typeof scope !== 'function')) {\n    return null;\n  }\n\n  try {\n    const candidate = scope.localStorage;\n    if (candidate && typeof candidate.getItem === 'function') {\n      return candidate;\n    }\n  } catch (error) {\n    void error;\n  }\n\n  return null;\n}\n\nfunction collectLocalStorageCandidates() {\n  const scopes = [\n    GLOBAL_SCOPE,\n    GLOBAL_SCOPE && GLOBAL_SCOPE.window ? GLOBAL_SCOPE.window : null,\n    GLOBAL_SCOPE && GLOBAL_SCOPE.__cineGlobal ? GLOBAL_SCOPE.__cineGlobal : null,\n    typeof window !== 'undefined' ? window : null,\n    typeof globalThis !== 'undefined' ? globalThis : null,\n    typeof self !== 'undefined' ? self : null,\n    typeof global !== 'undefined' ? global : null,\n  ];\n\n  const candidates = [];\n  const seen = typeof WeakSet === 'function' ? new WeakSet() : null;\n\n  for (let index = 0; index < scopes.length; index += 1) {\n    const candidate = resolveLocalStorageFromScope(scopes[index]);\n    if (!candidate) {\n      continue;\n    }\n\n    if (seen) {\n      try {\n        if (seen.has(candidate)) {\n          continue;\n        }\n        seen.add(candidate);\n      } catch (error) {\n        void error;\n      }\n    } else if (candidates.indexOf(candidate) !== -1) {\n      continue;\n    }\n\n    candidates.push(candidate);\n  }\n\n  return candidates;\n}\n\nif (GLOBAL_SCOPE && typeof GLOBAL_SCOPE.__cineDeepClone !== 'function') {\n  try {\n    GLOBAL_SCOPE.__cineDeepClone = STORAGE_DEEP_CLONE;\n  } catch (storageDeepCloneError) {\n    void storageDeepCloneError;\n  }\n}\n\nfunction isFactoryResetActive() {\n  const readFlag = (scope) => {\n    if (!scope || (typeof scope !== 'object' && typeof scope !== 'function')) {\n      return false;\n    }\n    try {\n      return scope.__cameraPowerPlannerFactoryResetting === true;\n    } catch (error) {\n      void error;\n      return false;\n    }\n  };\n\n  if (readFlag(GLOBAL_SCOPE)) {\n    return true;\n  }\n\n  const fallbackScopes = [\n    typeof window !== 'undefined' ? window : null,\n    typeof self !== 'undefined' ? self : null,\n    typeof global !== 'undefined' ? global : null,\n  ];\n\n  for (let index = 0; index < fallbackScopes.length; index += 1) {\n    const scope = fallbackScopes[index];\n    if (scope && scope !== GLOBAL_SCOPE && readFlag(scope)) {\n      return true;\n    }\n  }\n\n  try {\n    if (\n      (typeof sessionStorage !== 'undefined' && sessionStorage.getItem(FACTORY_RESET_LOCK_KEY)) ||\n      (typeof localStorage !== 'undefined' && localStorage.getItem(FACTORY_RESET_LOCK_KEY))\n    ) {\n      return true;\n    }\n  } catch (storageError) {\n    void storageError;\n  }\n\n  return false;\n}\n\nvar DEVICE_STORAGE_KEY = 'cameraPowerPlanner_devices';\nvar DEVICE_STORAGE_KEY_VARIANTS = null;\nvar SETUP_STORAGE_KEY = 'cameraPowerPlanner_setups';\nvar SESSION_STATE_KEY = 'cameraPowerPlanner_session';\nvar FEEDBACK_STORAGE_KEY = 'cameraPowerPlanner_feedback';\nvar PROJECT_STORAGE_KEY = 'cameraPowerPlanner_project';\nvar PROJECT_STORAGE_REV_KEY = 'cameraPowerPlanner_project_rev';\nvar FAVORITES_STORAGE_KEY = 'cameraPowerPlanner_favorites';\nvar CONTACTS_STORAGE_KEY = 'cameraPowerPlanner_contacts';\nvar OWN_GEAR_STORAGE_KEY = 'cameraPowerPlanner_ownGear';\nvar USER_PROFILE_STORAGE_KEY = 'cameraPowerPlanner_userProfile';\nvar DOCUMENTATION_TRACKER_STORAGE_KEY = 'cameraPowerPlanner_documentationTracker';\nvar DEVICE_SCHEMA_CACHE_KEY = 'cameraPowerPlanner_schemaCache';\nvar LEGACY_SCHEMA_CACHE_KEY = 'cinePowerPlanner_schemaCache';\nvar CUSTOM_FONT_STORAGE_KEY_DEFAULT = 'cameraPowerPlanner_customFonts';\nvar MOUNT_VOLTAGE_STORAGE_KEY_FALLBACK = 'cameraPowerPlanner_mountVoltages';\nvar CAMERA_COLOR_STORAGE_KEY = 'cameraPowerPlanner_cameraColors';\nvar PRINT_PREFERENCES_STORAGE_KEY = 'cineRentalPrintSections';\nvar PROJECT_INDEX_KEY = 'cameraPowerPlanner_projectIndex';\nvar MOUNT_VOLTAGE_STORAGE_KEY_SYMBOL =\n  typeof Symbol === 'function'\n    ? Symbol.for('cinePowerPlanner.mountVoltageKey')\n    : null;\n\nvar PROJECT_STORAGE_READ_CACHE = null;\n\nvar STORAGE_CACHE_SYMBOL =\n  typeof Symbol === 'function'\n    ? Symbol.for('cinePowerPlanner.storageCache')\n    : '__cineStorageStateCache';\n\nvar PROJECT_SHARD_PREFIX = 'cameraPowerPlanner_prj_';\n\nvar STORAGE_STATE_CACHE_WEAKMAP =\n  typeof WeakMap === 'function' && typeof Map === 'function'\n    ? new WeakMap()\n    : null;\n\nvar CONTACTS_MODULE_API = null;\nvar CONTACTS_MODULE_RESOLUTION_ATTEMPTED = false;\n\nvar COMPRESSION_STRATEGY_CACHE =\n  typeof Map === 'function'\n    ? new Map()\n    : null;\nvar COMPRESSION_STRATEGY_CACHE_KEYS = [];\nvar COMPRESSION_STRATEGY_CACHE_LIMIT = 6;\nvar COMPRESSION_CANDIDATE_CACHE_MISS =\n  typeof Object.freeze === 'function'\n    ? Object.freeze({ __cineCompressionMiss: true })\n    : { __cineCompressionMiss: true };\nvar STORAGE_COMPRESSION_CANDIDATE_CACHE = createCompressionCandidateCache(8);\nvar MIGRATION_BACKUP_COMPRESSION_CANDIDATE_CACHE = createCompressionCandidateCache(6);\n\nvar AUTO_BACKUP_COMPRESSION_CACHE =\n  typeof Map === 'function'\n    ? new Map()\n    : null;\nvar AUTO_BACKUP_COMPRESSION_CACHE_KEYS = [];\nvar AUTO_BACKUP_COMPRESSION_CACHE_LIMIT = 16;\n\n// Compression payloads are reused frequently while we keep the UI responsive.\n// We clone objects before storing them so that later mutations never corrupt\n// previous snapshots.\nfunction cloneAutoBackupCompressionValue(value) {\n  if (!value || typeof value !== 'object') {\n    return value;\n  }\n\n  if (Array.isArray(value)) {\n    return value.slice();\n  }\n\n  var clone = {};\n  var keys = Object.keys(value);\n  for (var index = 0; index < keys.length; index += 1) {\n    var key = keys[index];\n    var original = value[key];\n    clone[key] = Array.isArray(original) ? original.slice() : original;\n  }\n\n  return clone;\n}\n\n// Retrieve a previously cached compression payload. Returning a shallow clone\n// protects the caller from mutating the cache entry by accident.\nfunction readAutoBackupCompressionCache(signature) {\n  if (!AUTO_BACKUP_COMPRESSION_CACHE || typeof signature !== 'string' || !signature) {\n    return null;\n  }\n\n  var cached;\n  try {\n    cached = AUTO_BACKUP_COMPRESSION_CACHE.get(signature);\n  } catch (cacheReadError) {\n    cached = null;\n    void cacheReadError;\n  }\n\n  if (!cached || !cached.payload) {\n    return null;\n  }\n\n  return {\n    payload: cloneAutoBackupCompressionValue(cached.payload),\n    compression: cached.compression\n      ? cloneAutoBackupCompressionValue(cached.compression)\n      : null,\n  };\n}\n\n// Store compression metadata for automatic backups. The cache is intentionally\n// size-limited to keep memory predictable during long offline sessions.\nfunction writeAutoBackupCompressionCache(signature, payload, compression) {\n  if (\n    !AUTO_BACKUP_COMPRESSION_CACHE\n    || typeof signature !== 'string'\n    || !signature\n    || !isCompressedAutoBackupSnapshotPayload(payload)\n  ) {\n    return;\n  }\n\n  var entry = {\n    payload: cloneAutoBackupCompressionValue(payload),\n    compression: compression ? cloneAutoBackupCompressionValue(compression) : null,\n  };\n\n  try {\n    AUTO_BACKUP_COMPRESSION_CACHE.set(signature, entry);\n  } catch (cacheStoreError) {\n    void cacheStoreError;\n    return;\n  }\n\n  var existingIndex = AUTO_BACKUP_COMPRESSION_CACHE_KEYS.indexOf(signature);\n  if (existingIndex !== -1) {\n    AUTO_BACKUP_COMPRESSION_CACHE_KEYS.splice(existingIndex, 1);\n  }\n\n  AUTO_BACKUP_COMPRESSION_CACHE_KEYS.push(signature);\n\n  while (AUTO_BACKUP_COMPRESSION_CACHE_KEYS.length > AUTO_BACKUP_COMPRESSION_CACHE_LIMIT) {\n    var oldest = AUTO_BACKUP_COMPRESSION_CACHE_KEYS.shift();\n    if (!oldest || oldest === signature) {\n      continue;\n    }\n\n    try {\n      AUTO_BACKUP_COMPRESSION_CACHE.delete(oldest);\n    } catch (cacheDeleteError) {\n      void cacheDeleteError;\n    }\n  }\n}\n\nfunction resetAutoBackupCompressionCache() {\n  if (AUTO_BACKUP_COMPRESSION_CACHE && typeof AUTO_BACKUP_COMPRESSION_CACHE.clear === 'function') {\n    try {\n      AUTO_BACKUP_COMPRESSION_CACHE.clear();\n    } catch (cacheClearError) {\n      void cacheClearError;\n    }\n  }\n\n  AUTO_BACKUP_COMPRESSION_CACHE_KEYS.length = 0;\n}\n\n// Allow unlimited compression warnings so diagnostics are never suppressed.\nvar COMPRESSION_WARNING_LIMIT = Number.POSITIVE_INFINITY;\nvar COMPRESSION_WARNING_BATCH_SIZE = 8;\nvar COMPRESSION_LOG_SUMMARY_WINDOW_MS = 60 * 1000;\nvar compressionWarningRegistry = {\n  entries: Object.create(null),\n  totalWarnings: 0,\n  suppressionNoticeShown: false,\n};\nvar ensureConsoleMethodsWritable = null;\nvar storageLoggingResolverCache = null;\nvar storageLoggerCache = null;\nvar storageLoggerResolutionAttempted = false;\nif (consoleHelpersImport && typeof consoleHelpersImport.ensureConsoleMethodsWritable === 'function') {\n  ensureConsoleMethodsWritable = consoleHelpersImport.ensureConsoleMethodsWritable;\n}\n\nvar ACTIVE_PROJECT_COMPRESSION_HOLD_KEY = '';\nvar ACTIVE_PROJECT_COMPRESSION_HOLD_ENABLED = false;\n\nif (\n  !ensureConsoleMethodsWritable\n  && GLOBAL_SCOPE\n  && typeof GLOBAL_SCOPE.__cineEnsureConsoleMethodsWritable === 'function'\n) {\n  ensureConsoleMethodsWritable = GLOBAL_SCOPE.__cineEnsureConsoleMethodsWritable;\n}\n\nif (typeof ensureConsoleMethodsWritable === 'function') {\n  ensureConsoleMethodsWritable(['warn', 'info']);\n}\n\nfunction collectStorageLoggingScopes() {\n  var scopes = [];\n\n  var enqueue = function enqueue(scope) {\n    if (!scope || (typeof scope !== 'object' && typeof scope !== 'function')) {\n      return;\n    }\n    if (scopes.indexOf(scope) === -1) {\n      scopes.push(scope);\n    }\n  };\n\n  enqueue(GLOBAL_SCOPE);\n  enqueue(typeof globalThis !== 'undefined' ? globalThis : null);\n  enqueue(typeof window !== 'undefined' ? window : null);\n  enqueue(typeof self !== 'undefined' ? self : null);\n  enqueue(typeof global !== 'undefined' ? global : null);\n\n  return scopes;\n}\n\nfunction resolveStorageLoggingResolver() {\n  if (storageLoggingResolverCache) {\n    return storageLoggingResolverCache;\n  }\n\n  if (loggingResolverImport && typeof loggingResolverImport.resolveLogger === 'function') {\n    storageLoggingResolverCache = loggingResolverImport;\n    return storageLoggingResolverCache;\n  }\n\n  var scopes = collectStorageLoggingScopes();\n  for (var index = 0; index < scopes.length; index += 1) {\n    var scope = scopes[index];\n    if (!scope || (typeof scope !== 'object' && typeof scope !== 'function')) {\n      continue;\n    }\n\n    try {\n      var resolver = scope.cineLoggingResolver;\n      if (resolver && typeof resolver.resolveLogger === 'function') {\n        storageLoggingResolverCache = resolver;\n        return storageLoggingResolverCache;\n      }\n    } catch (scopeResolverError) {\n      void scopeResolverError;\n    }\n  }\n\n  storageLoggingResolverCache = null;\n  return storageLoggingResolverCache;\n}\n\nfunction resolveStorageLogger() {\n  if (storageLoggerCache || storageLoggerResolutionAttempted) {\n    return storageLoggerCache;\n  }\n\n  storageLoggerResolutionAttempted = true;\n\n  var resolver = resolveStorageLoggingResolver();\n  if (resolver && typeof resolver.resolveLogger === 'function') {\n    try {\n      var logger = resolver.resolveLogger('storage', { meta: { source: 'storage-module' } });\n      if (logger) {\n        storageLoggerCache = logger;\n        return storageLoggerCache;\n      }\n    } catch (resolverError) {\n      void resolverError;\n    }\n  }\n\n  storageLoggerCache = null;\n  return storageLoggerCache;\n}\n\nfunction sanitizeStorageError(error) {\n  if (!error) {\n    return null;\n  }\n\n  if (typeof error === 'string') {\n    return { message: error };\n  }\n\n  var result = {};\n  if (typeof error.name === 'string' && error.name) {\n    result.name = error.name;\n  }\n  if (typeof error.message === 'string' && error.message) {\n    result.message = error.message;\n  }\n  if (typeof error.stack === 'string' && error.stack) {\n    result.stack = error.stack;\n  }\n\n  if (!Object.keys(result).length) {\n    try {\n      result.message = String(error);\n    } catch (stringifyError) {\n      void stringifyError;\n      return null;\n    }\n  }\n\n  return result;\n}\n\nfunction getActiveStorageType(storage) {\n  if (storage && typeof safeLocalStorageInfo !== 'undefined' && safeLocalStorageInfo && safeLocalStorageInfo.storage === storage) {\n    return safeLocalStorageInfo && typeof safeLocalStorageInfo.type === 'string'\n      ? safeLocalStorageInfo.type\n      : 'unknown';\n  }\n\n  if (storage && GLOBAL_SCOPE) {\n    try {\n      if (GLOBAL_SCOPE.localStorage && storage === GLOBAL_SCOPE.localStorage) {\n        return 'local';\n      }\n    } catch (localStorageCompareError) {\n      void localStorageCompareError;\n    }\n    try {\n      if (GLOBAL_SCOPE.sessionStorage && storage === GLOBAL_SCOPE.sessionStorage) {\n        return 'session';\n      }\n    } catch (sessionStorageCompareError) {\n      void sessionStorageCompareError;\n    }\n  }\n\n  if (typeof safeLocalStorageInfo !== 'undefined' && safeLocalStorageInfo && typeof safeLocalStorageInfo.type === 'string') {\n    return safeLocalStorageInfo.type;\n  }\n\n  return 'unknown';\n}\n\nfunction logStorageEvent(level, message, detail, meta, consoleCallback) {\n  var normalizedLevel = typeof level === 'string' && level ? level.toLowerCase() : 'info';\n  var normalizedMessage = typeof message === 'string' && message ? message : 'Storage event';\n  var logger = resolveStorageLogger();\n  var handled = false;\n  var resolvedMeta = { module: 'storage' };\n\n  if (meta && typeof meta === 'object') {\n    resolvedMeta = { module: 'storage' };\n    var metaKeys = Object.keys(meta);\n    for (var metaIndex = 0; metaIndex < metaKeys.length; metaIndex += 1) {\n      var metaKey = metaKeys[metaIndex];\n      resolvedMeta[metaKey] = meta[metaKey];\n    }\n  }\n\n  if (logger) {\n    if (typeof logger[normalizedLevel] === 'function') {\n      try {\n        logger[normalizedLevel](normalizedMessage, detail, resolvedMeta);\n        handled = true;\n      } catch (loggingError) {\n        handled = false;\n        void loggingError;\n      }\n    } else if (typeof logger.log === 'function') {\n      try {\n        logger.log(normalizedLevel, normalizedMessage, detail, resolvedMeta);\n        handled = true;\n      } catch (loggerLogError) {\n        handled = false;\n        void loggerLogError;\n      }\n    }\n  }\n\n  if (typeof consoleCallback === 'function') {\n    try {\n      consoleCallback();\n    } catch (consoleCallbackError) {\n      void consoleCallbackError;\n    }\n    return handled;\n  }\n\n  if (typeof console === 'undefined' || !console) {\n    return handled;\n  }\n\n  var fallback = null;\n  if (normalizedLevel === 'error' && typeof console.error === 'function') {\n    fallback = console.error;\n  } else if (normalizedLevel === 'warn' && typeof console.warn === 'function') {\n    fallback = console.warn;\n  } else if (normalizedLevel === 'info' && typeof console.info === 'function') {\n    fallback = console.info;\n  } else if (normalizedLevel === 'debug' && typeof console.debug === 'function') {\n    fallback = console.debug;\n  } else if (typeof console.log === 'function') {\n    fallback = console.log;\n  }\n\n  if (typeof fallback === 'function') {\n    try {\n      fallback.call(console, normalizedMessage, detail || null);\n    } catch (fallbackError) {\n      void fallbackError;\n    }\n  }\n\n  return handled;\n}\n\nfunction getCompressionLogTimestamp() {\n  if (typeof Date === 'undefined') {\n    return null;\n  }\n\n  if (typeof Date.now === 'function') {\n    return Date.now();\n  }\n\n  try {\n    return new Date().getTime();\n  } catch (timestampError) {\n    void timestampError;\n  }\n\n  return null;\n}\n\nfunction logCompressionSavingsEvent(kind, identifier, message, savings, percent) {\n  var entryKey = typeof kind === 'string' && kind ? kind : 'generic';\n  var keyLabel = null;\n  if (typeof identifier === 'string' && identifier) {\n    keyLabel = identifier;\n  } else if (identifier !== null && identifier !== undefined) {\n    try {\n      keyLabel = String(identifier);\n    } catch (stringifyError) {\n      keyLabel = null;\n      void stringifyError;\n    }\n  }\n\n  var detail = {\n    event: 'compression-savings',\n    kind: entryKey,\n    key: keyLabel,\n    storageType: getActiveStorageType(),\n  };\n  if (typeof savings === 'number' && Number.isFinite(savings)) {\n    detail.savings = savings;\n  }\n  if (typeof percent === 'number' && Number.isFinite(percent)) {\n    detail.percent = percent;\n  }\n\n  var consoleLogger = function logCompressionToConsole() {\n    if (typeof console === 'undefined') {\n      return;\n    }\n\n    var registry = compressionWarningRegistry;\n    var entry = registry.entries[entryKey];\n    var now = getCompressionLogTimestamp();\n\n    if (!entry) {\n      entry = {\n        kind: entryKey,\n        occurrences: 0,\n        totalSavings: 0,\n        lastPercent: null,\n        lastKey: null,\n        uniqueKeys: Object.create(null),\n        uniqueKeyCount: 0,\n        firstLoggedAt: now,\n        lastLoggedAt: now,\n        lastSummaryAt: null,\n        suppressedTotal: 0,\n        suppressedSinceSummary: 0,\n      };\n      registry.entries[entryKey] = entry;\n    }\n\n    entry.occurrences += 1;\n    entry.lastLoggedAt = now;\n    if (keyLabel) {\n      entry.lastKey = keyLabel;\n      if (!entry.uniqueKeys[keyLabel]) {\n        entry.uniqueKeys[keyLabel] = true;\n        entry.uniqueKeyCount += 1;\n      }\n    }\n\n    if (typeof savings === 'number' && Number.isFinite(savings)) {\n      entry.totalSavings += savings;\n    }\n    if (typeof percent === 'number' && Number.isFinite(percent)) {\n      entry.lastPercent = percent;\n    }\n\n    if (registry.totalWarnings < COMPRESSION_WARNING_LIMIT) {\n      if (typeof ensureConsoleMethodsWritable === 'function') {\n        ensureConsoleMethodsWritable('warn');\n      }\n      if (typeof console.warn === 'function' && message) {\n        console.warn(message);\n      }\n      registry.totalWarnings += 1;\n      return;\n    }\n\n    entry.suppressedTotal += 1;\n    entry.suppressedSinceSummary += 1;\n\n    if (!registry.suppressionNoticeShown && typeof console.info === 'function') {\n      if (typeof ensureConsoleMethodsWritable === 'function') {\n        ensureConsoleMethodsWritable('info');\n      }\n      console.info(\n        'Additional storage compression warnings are being batched to keep diagnostics readable.',\n        {\n          limit: COMPRESSION_WARNING_LIMIT,\n          batchSize: COMPRESSION_WARNING_BATCH_SIZE,\n        },\n      );\n      registry.suppressionNoticeShown = true;\n    }\n\n    var shouldSummarize = false;\n    if (!entry.lastSummaryAt) {\n      shouldSummarize = true;\n    } else if (entry.suppressedSinceSummary >= COMPRESSION_WARNING_BATCH_SIZE) {\n      shouldSummarize = true;\n    } else if (\n      now !== null &&\n      entry.lastSummaryAt !== null &&\n      entry.suppressedSinceSummary > 0 &&\n      now - entry.lastSummaryAt >= COMPRESSION_LOG_SUMMARY_WINDOW_MS\n    ) {\n      shouldSummarize = true;\n    }\n\n    if (shouldSummarize && typeof console.info === 'function') {\n      if (typeof ensureConsoleMethodsWritable === 'function') {\n        ensureConsoleMethodsWritable('info');\n      }\n      console.info('Suppressed repeated storage compression warnings.', {\n        kind: entry.kind,\n        mostRecentKey: entry.lastKey,\n        suppressedSinceSummary: entry.suppressedSinceSummary,\n        suppressedTotal: entry.suppressedTotal,\n        totalOccurrences: entry.occurrences,\n        totalSavings: entry.totalSavings,\n        lastPercent: entry.lastPercent,\n        uniqueKeys: entry.uniqueKeyCount,\n      });\n      entry.lastSummaryAt = now;\n      entry.suppressedSinceSummary = 0;\n    }\n  };\n\n  logStorageEvent('info', message, detail, { event: 'compression-savings', kind: entryKey }, consoleLogger);\n}\n\nfunction getCompressionLogSnapshot() {\n  var entries = {};\n  var keys = Object.keys(compressionWarningRegistry.entries);\n\n  for (var i = 0; i < keys.length; i += 1) {\n    var key = keys[i];\n    var source = compressionWarningRegistry.entries[key];\n    if (!source) {\n      continue;\n    }\n\n    entries[key] = {\n      kind: source.kind,\n      occurrences: source.occurrences,\n      totalSavings: source.totalSavings,\n      lastPercent: source.lastPercent,\n      lastKey: source.lastKey,\n      uniqueKeyCount: source.uniqueKeyCount,\n      firstLoggedAt: source.firstLoggedAt,\n      lastLoggedAt: source.lastLoggedAt,\n      lastSummaryAt: source.lastSummaryAt,\n      suppressedTotal: source.suppressedTotal,\n    };\n  }\n\n  return {\n    limit: COMPRESSION_WARNING_LIMIT,\n    batchSize: COMPRESSION_WARNING_BATCH_SIZE,\n    summaryWindowMs: COMPRESSION_LOG_SUMMARY_WINDOW_MS,\n    totalWarnings: compressionWarningRegistry.totalWarnings,\n    suppressionNoticeShown: compressionWarningRegistry.suppressionNoticeShown,\n    entries: entries,\n  };\n}\n\nfunction getCompressionStrategyCacheKey(variants) {\n  if (!Array.isArray(variants) || !variants.length) {\n    return null;\n  }\n\n  var segments = [];\n  for (var i = 0; i < variants.length; i += 1) {\n    var variant = variants[i] || {};\n    var name = typeof variant.variant === 'string' ? variant.variant : '';\n    var compressName = typeof variant.compress === 'string' ? variant.compress : '';\n    var decompressName = typeof variant.decompress === 'string' ? variant.decompress : '';\n    segments.push(name + ':' + compressName + ':' + decompressName);\n  }\n\n  return segments.join('|');\n}\n\nfunction readCompressionStrategyCache(cacheKey, lzReference) {\n  if (!COMPRESSION_STRATEGY_CACHE || !cacheKey) {\n    return null;\n  }\n\n  var cached;\n  try {\n    cached = COMPRESSION_STRATEGY_CACHE.get(cacheKey);\n  } catch (cacheReadError) {\n    cached = null;\n    void cacheReadError;\n  }\n\n  if (!cached || cached.lz !== lzReference) {\n    return null;\n  }\n\n  if (!Array.isArray(cached.strategies) || !cached.strategies.length) {\n    return Array.isArray(cached.strategies) ? [] : null;\n  }\n\n  return cached.strategies.slice();\n}\n\nfunction pruneCompressionStrategyCache(cacheKey) {\n  if (!COMPRESSION_STRATEGY_CACHE || !cacheKey) {\n    return;\n  }\n\n  var existingIndex = COMPRESSION_STRATEGY_CACHE_KEYS.indexOf(cacheKey);\n  if (existingIndex !== -1) {\n    COMPRESSION_STRATEGY_CACHE_KEYS.splice(existingIndex, 1);\n  }\n\n  COMPRESSION_STRATEGY_CACHE_KEYS.push(cacheKey);\n\n  while (COMPRESSION_STRATEGY_CACHE_KEYS.length > COMPRESSION_STRATEGY_CACHE_LIMIT) {\n    var oldestKey = COMPRESSION_STRATEGY_CACHE_KEYS.shift();\n    if (typeof COMPRESSION_STRATEGY_CACHE.delete === 'function') {\n      try {\n        COMPRESSION_STRATEGY_CACHE.delete(oldestKey);\n      } catch (cacheDeleteError) {\n        void cacheDeleteError;\n      }\n    }\n  }\n}\n\nfunction writeCompressionStrategyCache(cacheKey, lzReference, strategies) {\n  if (!COMPRESSION_STRATEGY_CACHE || !cacheKey) {\n    return;\n  }\n\n  var payload = {\n    lz: lzReference,\n    strategies: Array.isArray(strategies) ? strategies.slice() : [],\n  };\n\n  try {\n    COMPRESSION_STRATEGY_CACHE.set(cacheKey, payload);\n    pruneCompressionStrategyCache(cacheKey);\n  } catch (cacheStoreError) {\n    void cacheStoreError;\n  }\n}\n\nfunction computeStorageCompressionWrapperBaseLength() {\n  if (typeof JSON === 'undefined' || !JSON || typeof JSON.stringify !== 'function') {\n    return 0;\n  }\n\n  try {\n    var skeleton = {\n      [STORAGE_COMPRESSION_FLAG_KEY]: true,\n      version: STORAGE_COMPRESSION_VERSION,\n      algorithm: STORAGE_COMPRESSION_ALGORITHM,\n      namespace: STORAGE_COMPRESSION_NAMESPACE,\n      data: '',\n      originalLength: 0,\n      compressedPayloadLength: 0,\n      compressionVariant: '',\n    };\n\n    var serialized = JSON.stringify(skeleton);\n    if (typeof serialized !== 'string' || !serialized) {\n      return 0;\n    }\n\n    var emptyLiteralLength = JSON.stringify('').length;\n    if (!(emptyLiteralLength > 0)) {\n      return 0;\n    }\n\n    return serialized.length - emptyLiteralLength * 2 - String(0).length * 2;\n  } catch (wrapperLengthError) {\n    void wrapperLengthError;\n  }\n\n  return 0;\n}\n\nfunction createCompressionCandidateCache(limit) {\n  if (typeof Map !== 'function') {\n    return null;\n  }\n\n  var numericLimit = Number(limit);\n  if (!(numericLimit > 0)) {\n    return null;\n  }\n\n  return {\n    map: new Map(),\n    keys: [],\n    limit: Math.floor(numericLimit),\n  };\n}\n\nfunction cloneCompressionCandidate(candidate) {\n  if (!candidate || typeof candidate !== 'object') {\n    return null;\n  }\n\n  var clone = {};\n  var keys = Object.keys(candidate);\n  for (var i = 0; i < keys.length; i += 1) {\n    clone[keys[i]] = candidate[keys[i]];\n  }\n\n  return clone;\n}\n\nfunction touchCompressionCandidateCacheKey(cache, key) {\n  if (!cache || !Array.isArray(cache.keys)) {\n    return;\n  }\n\n  var existingIndex = cache.keys.indexOf(key);\n  if (existingIndex !== -1) {\n    cache.keys.splice(existingIndex, 1);\n  }\n\n  cache.keys.push(key);\n}\n\nfunction readCompressionCandidateCacheEntry(cache, key) {\n  if (!cache || !cache.map || typeof cache.map.get !== 'function') {\n    return { hit: false };\n  }\n\n  if (typeof key !== 'string' || !key) {\n    return { hit: false };\n  }\n\n  var entry;\n  try {\n    entry = cache.map.get(key);\n  } catch (cacheReadError) {\n    void cacheReadError;\n    return { hit: false };\n  }\n\n  if (entry === undefined) {\n    return { hit: false };\n  }\n\n  touchCompressionCandidateCacheKey(cache, key);\n\n  if (entry === COMPRESSION_CANDIDATE_CACHE_MISS) {\n    return { hit: true, candidate: null };\n  }\n\n  var cloned = cloneCompressionCandidate(entry);\n  if (!cloned) {\n    return { hit: true, candidate: null };\n  }\n\n  return { hit: true, candidate: cloned };\n}\n\nfunction writeCompressionCandidateCacheEntry(cache, key, candidate) {\n  if (!cache || !cache.map || typeof cache.map.set !== 'function') {\n    return;\n  }\n\n  if (typeof key !== 'string' || !key) {\n    return;\n  }\n\n  if (!cache.limit || cache.limit <= 0) {\n    return;\n  }\n\n  var entry = candidate && typeof candidate === 'object'\n    ? cloneCompressionCandidate(candidate)\n    : COMPRESSION_CANDIDATE_CACHE_MISS;\n\n  try {\n    cache.map.set(key, entry);\n  } catch (cacheStoreError) {\n    void cacheStoreError;\n    return;\n  }\n\n  touchCompressionCandidateCacheKey(cache, key);\n\n  while (cache.keys.length > cache.limit) {\n    var oldestKey = cache.keys.shift();\n    if (typeof oldestKey !== 'string' || oldestKey === key) {\n      continue;\n    }\n\n    try {\n      cache.map.delete(oldestKey);\n    } catch (cacheDeleteError) {\n      void cacheDeleteError;\n    }\n  }\n}\n\nfunction getStorageStateCacheMap(storage, createIfMissing) {\n  if (!storage || (typeof storage !== 'object' && typeof storage !== 'function')) {\n    return null;\n  }\n\n  let existing = null;\n  if (STORAGE_CACHE_SYMBOL) {\n    try {\n      existing = storage[STORAGE_CACHE_SYMBOL];\n    } catch (readError) {\n      existing = null;\n      void readError;\n    }\n  }\n\n  if (!existing && STORAGE_STATE_CACHE_WEAKMAP) {\n    try {\n      existing = STORAGE_STATE_CACHE_WEAKMAP.get(storage) || null;\n    } catch (weakMapReadError) {\n      existing = null;\n      void weakMapReadError;\n    }\n  }\n\n  if (existing || !createIfMissing) {\n    return existing || null;\n  }\n\n  const map = new Map();\n  let assigned = false;\n\n  if (STORAGE_CACHE_SYMBOL) {\n    try {\n      Object.defineProperty(storage, STORAGE_CACHE_SYMBOL, {\n        configurable: true,\n        writable: true,\n        value: map,\n      });\n      assigned = true;\n    } catch (defineError) {\n      void defineError;\n      try {\n        storage[STORAGE_CACHE_SYMBOL] = map;\n        assigned = true;\n      } catch (assignError) {\n        assigned = false;\n        void assignError;\n      }\n    }\n  }\n\n  if (!assigned && STORAGE_STATE_CACHE_WEAKMAP) {\n    try {\n      STORAGE_STATE_CACHE_WEAKMAP.set(storage, map);\n      assigned = true;\n    } catch (weakMapStoreError) {\n      assigned = false;\n      void weakMapStoreError;\n    }\n  }\n\n  return assigned ? map : null;\n}\n\nfunction getCachedStorageEntry(storage, key) {\n  const map = getStorageStateCacheMap(storage, false);\n  if (!map || typeof key !== 'string' || !key) {\n    return null;\n  }\n  return map.get(key) || null;\n}\n\nfunction clearCachedStorageEntry(storage, key) {\n  const map = getStorageStateCacheMap(storage, false);\n  if (!map || typeof key !== 'string' || !key) {\n    return;\n  }\n\n  if (typeof map.delete === 'function') {\n    map.delete(key);\n  }\n\n  if (map.size === 0) {\n    if (STORAGE_CACHE_SYMBOL) {\n      try {\n        if (storage && (typeof storage === 'object' || typeof storage === 'function')) {\n          if (Object.prototype.hasOwnProperty.call(storage, STORAGE_CACHE_SYMBOL)) {\n            delete storage[STORAGE_CACHE_SYMBOL];\n          }\n        }\n      } catch (clearError) {\n        void clearError;\n      }\n    }\n    if (STORAGE_STATE_CACHE_WEAKMAP) {\n      try {\n        STORAGE_STATE_CACHE_WEAKMAP.delete(storage);\n      } catch (weakMapDeleteError) {\n        void weakMapDeleteError;\n      }\n    }\n  }\n}\n\nfunction cloneValueForCache(value) {\n  if (value === null || typeof value !== 'object') {\n    return value;\n  }\n\n  try {\n    return STORAGE_DEEP_CLONE(value);\n  } catch (cloneError) {\n    void cloneError;\n  }\n\n  return value;\n}\n\nfunction cloneCachedEntryValue(entry) {\n  if (!entry) {\n    return undefined;\n  }\n\n  const { value } = entry;\n  if (value === null || typeof value !== 'object') {\n    return value;\n  }\n\n  return cloneValueForCache(value);\n}\n\nfunction cloneLookupMap(source, options) {\n  const map = new Map();\n  if (!source || typeof source.forEach !== 'function') {\n    return map;\n  }\n\n  const { freezeArray = false } = options || {};\n\n  source.forEach((value, key) => {\n    if (Array.isArray(value)) {\n      const copy = value.slice();\n      if (freezeArray) {\n        try {\n          Object.freeze(copy);\n        } catch (freezeError) {\n          void freezeError;\n        }\n      }\n      map.set(key, copy);\n    } else {\n      map.set(key, value);\n    }\n  });\n\n  return map;\n}\n\nfunction cloneProjectLookupSnapshotForReturn(lookup) {\n  if (!lookup || typeof lookup !== 'object') {\n    return { raw: new Map(), normalized: new Map() };\n  }\n\n  return {\n    raw: cloneLookupMap(lookup.raw),\n    normalized: cloneLookupMap(lookup.normalized),\n  };\n}\n\nfunction captureProjectLookupSnapshotForCache(lookup) {\n  if (!lookup || typeof lookup !== 'object') {\n    return { raw: new Map(), normalized: new Map() };\n  }\n\n  return {\n    raw: cloneLookupMap(lookup.raw),\n    normalized: cloneLookupMap(lookup.normalized, { freezeArray: true }),\n  };\n}\n\nfunction freezeProjectSnapshotProjects(projects) {\n  if (!isPlainObject(projects)) {\n    return {};\n  }\n\n  const frozen = {};\n  const keys = Object.keys(projects);\n  for (let index = 0; index < keys.length; index += 1) {\n    const key = keys[index];\n    const entry = projects[key];\n    if (entry && typeof entry === 'object') {\n      try {\n        Object.freeze(entry);\n      } catch (freezeError) {\n        void freezeError;\n      }\n    }\n    frozen[key] = entry;\n  }\n\n  try {\n    Object.freeze(frozen);\n  } catch (freezeRootError) {\n    void freezeRootError;\n  }\n\n  return frozen;\n}\n\nfunction setProjectReadCacheSnapshot(snapshot) {\n  if (!snapshot || typeof snapshot !== 'object') {\n    PROJECT_STORAGE_READ_CACHE = null;\n    return;\n  }\n\n  PROJECT_STORAGE_READ_CACHE = {\n    projects: freezeProjectSnapshotProjects(snapshot.projects),\n    changed: Boolean(snapshot.changed),\n    originalValue: snapshot.originalValue,\n    lookup: captureProjectLookupSnapshotForCache(snapshot.lookup),\n    rawValue: snapshot.rawValue === undefined ? undefined : snapshot.rawValue,\n  };\n}\n\nfunction getProjectReadCacheClone(options) {\n  if (!PROJECT_STORAGE_READ_CACHE) {\n    return null;\n  }\n\n  const safeStorage = getSafeLocalStorage();\n  let currentRaw = null;\n  if (safeStorage && typeof safeStorage.getItem === 'function') {\n    try {\n      currentRaw = safeStorage.getItem(PROJECT_STORAGE_KEY);\n    } catch (storageReadError) {\n      currentRaw = null;\n      void storageReadError;\n    }\n  }\n\n  if (\n    PROJECT_STORAGE_READ_CACHE.rawValue !== undefined\n    && PROJECT_STORAGE_READ_CACHE.rawValue !== currentRaw\n  ) {\n    PROJECT_STORAGE_READ_CACHE = null;\n    return null;\n  }\n\n  const { forMutation = false } = options || {};\n  const projects = forMutation\n    ? STORAGE_DEEP_CLONE(PROJECT_STORAGE_READ_CACHE.projects)\n    : PROJECT_STORAGE_READ_CACHE.projects;\n\n  return {\n    projects,\n    changed: PROJECT_STORAGE_READ_CACHE.changed,\n    originalValue: PROJECT_STORAGE_READ_CACHE.originalValue,\n    lookup: cloneProjectLookupSnapshotForReturn(PROJECT_STORAGE_READ_CACHE.lookup),\n  };\n}\n\nfunction invalidateProjectReadCache() {\n  PROJECT_STORAGE_READ_CACHE = null;\n}\n\nfunction normalizeProjectStorageRevisionValue(value) {\n  if (typeof value === 'number' && Number.isFinite(value)) {\n    return Math.max(0, Math.floor(value));\n  }\n  if (typeof value === 'string') {\n    const trimmed = value.trim();\n    if (!trimmed) {\n      return null;\n    }\n    const parsed = Number(trimmed);\n    if (Number.isFinite(parsed)) {\n      return Math.max(0, Math.floor(parsed));\n    }\n  }\n  return null;\n}\n\nfunction getProjectStorageRevisionKeyName() {\n  return PROJECT_STORAGE_REV_KEY;\n}\n\nfunction loadProjectStorageRevision(storageOverride) {\n  const storage = storageOverride || getSafeLocalStorage();\n  if (!storage || typeof storage.getItem !== 'function') {\n    return null;\n  }\n  const parsed = loadJSONFromStorage(\n    storage,\n    PROJECT_STORAGE_REV_KEY,\n    'Error reading project storage revision from localStorage:',\n    null,\n    { validate: (value) => value === null || typeof value === 'number' || typeof value === 'string' },\n  );\n  return normalizeProjectStorageRevisionValue(parsed);\n}\n\nfunction bumpProjectStorageRevision(storageOverride) {\n  const storage = storageOverride || getSafeLocalStorage();\n  if (!storage || typeof storage.setItem !== 'function') {\n    return null;\n  }\n  const current = loadProjectStorageRevision(storage);\n  const next = Number.isFinite(current) ? current + 1 : 1;\n  saveJSONToStorage(\n    storage,\n    PROJECT_STORAGE_REV_KEY,\n    next,\n    'Error saving project storage revision to localStorage:',\n    { disableCompression: true, enableCompressionSweep: false },\n  );\n  return next;\n}\n\nfunction cacheStorageValue(storage, key, rawValue, normalizedValue, value) {\n  if (typeof key !== 'string' || !key) {\n    return;\n  }\n\n  if (!storage || (typeof storage !== 'object' && typeof storage !== 'function')) {\n    return;\n  }\n\n  const map = getStorageStateCacheMap(storage, true);\n  if (!map) {\n    return;\n  }\n\n  const cachedValue = cloneValueForCache(value);\n  const normalized = typeof normalizedValue === 'string' && normalizedValue\n    ? normalizedValue\n    : typeof rawValue === 'string' && rawValue\n      ? rawValue\n      : null;\n\n  const cacheEntry = {\n    raw: typeof rawValue === 'string' && rawValue ? rawValue : null,\n    normalizedRaw: normalized,\n    value: cachedValue,\n  };\n\n  map.set(key, cacheEntry);\n}\n\nfunction tryGetCachedStorageValue(storage, key, primaryRaw, rawStored) {\n  const entry = getCachedStorageEntry(storage, key);\n  if (!entry) {\n    return { hit: false };\n  }\n\n  if (typeof rawStored === 'string' && rawStored) {\n    if (entry.raw && entry.raw === rawStored) {\n      return { hit: true, value: cloneCachedEntryValue(entry) };\n    }\n  }\n\n  if (typeof primaryRaw === 'string' && primaryRaw) {\n    if (entry.normalizedRaw && entry.normalizedRaw === primaryRaw) {\n      return { hit: true, value: cloneCachedEntryValue(entry) };\n    }\n    if (entry.raw && entry.raw === primaryRaw) {\n      return { hit: true, value: cloneCachedEntryValue(entry) };\n    }\n  }\n\n  return { hit: false };\n}\n\nfunction readGlobalStringValue(scope, key) {\n  if (!scope || typeof scope !== 'object') {\n    return '';\n  }\n\n  var descriptor;\n  try {\n    descriptor = Object.getOwnPropertyDescriptor(scope, key);\n  } catch (descriptorError) {\n    descriptor = null;\n    void descriptorError;\n  }\n\n  if (\n    descriptor &&\n    Object.prototype.hasOwnProperty.call(descriptor, 'value') &&\n    typeof descriptor.value === 'string' &&\n    descriptor.value\n  ) {\n    return descriptor.value;\n  }\n\n  var directValue;\n  try {\n    directValue = scope[key];\n  } catch (readError) {\n    directValue = '';\n    void readError;\n  }\n\n  if (typeof directValue === 'string' && directValue) {\n    return directValue;\n  }\n\n  if (key === 'MOUNT_VOLTAGE_STORAGE_KEY' && MOUNT_VOLTAGE_STORAGE_KEY_SYMBOL) {\n    try {\n      const symbolValue = scope[MOUNT_VOLTAGE_STORAGE_KEY_SYMBOL];\n      if (typeof symbolValue === 'string' && symbolValue) {\n        return symbolValue;\n      }\n    } catch (symbolReadError) {\n      void symbolReadError;\n    }\n  }\n\n  return '';\n}\n\nfunction exposeGlobalStringValue(scope, key, value) {\n  if (!scope || typeof scope !== 'object') {\n    return '';\n  }\n\n  if (key === 'MOUNT_VOLTAGE_STORAGE_KEY' && MOUNT_VOLTAGE_STORAGE_KEY_SYMBOL) {\n    try {\n      scope[MOUNT_VOLTAGE_STORAGE_KEY_SYMBOL] = value;\n      const symbolAssigned = scope[MOUNT_VOLTAGE_STORAGE_KEY_SYMBOL];\n      if (typeof symbolAssigned === 'string' && symbolAssigned) {\n        return symbolAssigned;\n      }\n    } catch (symbolExposeError) {\n      void symbolExposeError;\n    }\n  }\n\n  var descriptor;\n  try {\n    descriptor = Object.getOwnPropertyDescriptor(scope, key);\n  } catch (descriptorError) {\n    descriptor = null;\n    void descriptorError;\n  }\n\n  if (\n    descriptor &&\n    Object.prototype.hasOwnProperty.call(descriptor, 'value') &&\n    typeof descriptor.value === 'string' &&\n    descriptor.value\n  ) {\n    return descriptor.value;\n  }\n\n  if (descriptor && descriptor.configurable === false && descriptor.writable === false) {\n    return '';\n  }\n\n  var assigned = '';\n\n  try {\n    scope[key] = value;\n    assigned = scope[key];\n  } catch (assignError) {\n    assigned = '';\n    void assignError;\n  }\n\n  if (typeof assigned === 'string' && assigned) {\n    return assigned;\n  }\n\n  if (\n    key === 'MOUNT_VOLTAGE_STORAGE_KEY' &&\n    typeof console !== 'undefined' &&\n    typeof console.warn === 'function'\n  ) {\n    console.warn(\n      'Unable to expose mount voltage storage key globally. Using fallback only.'\n    );\n  }\n\n  return '';\n}\n\nfunction resolveMountVoltageStorageKeyName() {\n  if (!GLOBAL_SCOPE || typeof GLOBAL_SCOPE !== 'object') {\n    return MOUNT_VOLTAGE_STORAGE_KEY_FALLBACK;\n  }\n\n  var existing = readGlobalStringValue(GLOBAL_SCOPE, 'MOUNT_VOLTAGE_STORAGE_KEY');\n  if (existing) {\n    return existing;\n  }\n\n  var exposed = exposeGlobalStringValue(\n    GLOBAL_SCOPE,\n    'MOUNT_VOLTAGE_STORAGE_KEY',\n    MOUNT_VOLTAGE_STORAGE_KEY_FALLBACK\n  );\n  if (exposed) {\n    return exposed;\n  }\n\n  return MOUNT_VOLTAGE_STORAGE_KEY_FALLBACK;\n}\n\nvar MOUNT_VOLTAGE_STORAGE_KEY_NAME = resolveMountVoltageStorageKeyName();\n\nfunction refreshMountVoltageStorageKeyName() {\n  const resolved = resolveMountVoltageStorageKeyName();\n  if (resolved && resolved !== MOUNT_VOLTAGE_STORAGE_KEY_NAME) {\n    MOUNT_VOLTAGE_STORAGE_KEY_NAME = resolved;\n    if (GLOBAL_SCOPE) {\n      exposeGlobalStringValue(\n        GLOBAL_SCOPE,\n        'MOUNT_VOLTAGE_STORAGE_KEY',\n        resolved,\n      );\n    }\n    if (typeof RAW_STORAGE_BACKUP_KEYS !== 'undefined' && RAW_STORAGE_BACKUP_KEYS && typeof RAW_STORAGE_BACKUP_KEYS.add === 'function') {\n      RAW_STORAGE_BACKUP_KEYS.add(resolved);\n      const variants = getStorageKeyVariants(resolved);\n      for (let i = 0; i < variants.length; i += 1) {\n        const variant = variants[i];\n        if (typeof variant === 'string' && variant) {\n          RAW_STORAGE_BACKUP_KEYS.add(variant);\n        }\n      }\n    }\n  }\n  return MOUNT_VOLTAGE_STORAGE_KEY_NAME;\n}\n\nfunction getMountVoltageStorageKeyName() {\n  return refreshMountVoltageStorageKeyName();\n}\n\nfunction getMountVoltageStorageBackupKeyName() {\n  const key = refreshMountVoltageStorageKeyName();\n  return key ? `${key}__backup` : `${MOUNT_VOLTAGE_STORAGE_KEY_FALLBACK}__backup`;\n}\n\nfunction ensureCustomFontStorageKeyName() {\n  if (!GLOBAL_SCOPE) {\n    return CUSTOM_FONT_STORAGE_KEY_DEFAULT;\n  }\n\n  const existingName =\n    typeof GLOBAL_SCOPE.CUSTOM_FONT_STORAGE_KEY_NAME === 'string'\n      ? GLOBAL_SCOPE.CUSTOM_FONT_STORAGE_KEY_NAME\n      : typeof GLOBAL_SCOPE.CUSTOM_FONT_STORAGE_KEY === 'string'\n        ? GLOBAL_SCOPE.CUSTOM_FONT_STORAGE_KEY\n        : CUSTOM_FONT_STORAGE_KEY_DEFAULT;\n\n  let normalizedName = existingName;\n  if (existingName === 'cinePowerPlanner_customFonts') {\n    normalizedName = CUSTOM_FONT_STORAGE_KEY_DEFAULT;\n  }\n\n  if (GLOBAL_SCOPE.CUSTOM_FONT_STORAGE_KEY !== normalizedName) {\n    GLOBAL_SCOPE.CUSTOM_FONT_STORAGE_KEY = normalizedName;\n  }\n\n  if (GLOBAL_SCOPE.CUSTOM_FONT_STORAGE_KEY_NAME !== normalizedName) {\n    GLOBAL_SCOPE.CUSTOM_FONT_STORAGE_KEY_NAME = normalizedName;\n  }\n\n  return normalizedName;\n}\n\nfunction getCustomFontStorageKeyName() {\n  if (GLOBAL_SCOPE &&\n    typeof GLOBAL_SCOPE.CUSTOM_FONT_STORAGE_KEY_NAME === 'string') {\n    return GLOBAL_SCOPE.CUSTOM_FONT_STORAGE_KEY_NAME;\n  }\n\n  return ensureCustomFontStorageKeyName();\n}\n\nensureCustomFontStorageKeyName();\n\nvar CUSTOM_LOGO_STORAGE_KEY = 'customLogo';\nvar TEMPERATURE_UNIT_STORAGE_KEY_DEFAULT = 'cameraPowerPlanner_temperatureUnit';\nvar FOCUS_SCALE_STORAGE_KEY_DEFAULT = 'cameraPowerPlanner_focusScale';\n\nfunction resolveTemperatureUnitStorageKey() {\n  if (!GLOBAL_SCOPE) {\n    return TEMPERATURE_UNIT_STORAGE_KEY_DEFAULT;\n  }\n\n  const existing =\n    typeof GLOBAL_SCOPE.TEMPERATURE_UNIT_STORAGE_KEY === 'string'\n      ? GLOBAL_SCOPE.TEMPERATURE_UNIT_STORAGE_KEY\n      : TEMPERATURE_UNIT_STORAGE_KEY_DEFAULT;\n\n  if (GLOBAL_SCOPE.TEMPERATURE_UNIT_STORAGE_KEY !== existing) {\n    try {\n      GLOBAL_SCOPE.TEMPERATURE_UNIT_STORAGE_KEY = existing;\n    } catch (assignError) {\n      if (typeof console !== 'undefined' && typeof console.warn === 'function') {\n        console.warn('Unable to assign temperature unit storage key globally.', assignError);\n      }\n      try {\n        Object.defineProperty(GLOBAL_SCOPE, 'TEMPERATURE_UNIT_STORAGE_KEY', {\n          configurable: true,\n          writable: true,\n          value: existing,\n        });\n      } catch (defineError) {\n        if (typeof console !== 'undefined' && typeof console.warn === 'function') {\n          console.warn('Unable to expose temperature unit storage key globally.', defineError);\n        }\n      }\n    }\n  }\n\n  return existing;\n}\n\nvar TEMPERATURE_UNIT_STORAGE_KEY_NAME = resolveTemperatureUnitStorageKey();\nvar FOCUS_SCALE_STORAGE_KEY_NAME = (function resolveFocusScaleStorageKey() {\n  if (!GLOBAL_SCOPE) {\n    return FOCUS_SCALE_STORAGE_KEY_DEFAULT;\n  }\n\n  const existing =\n    typeof GLOBAL_SCOPE.FOCUS_SCALE_STORAGE_KEY === 'string'\n      ? GLOBAL_SCOPE.FOCUS_SCALE_STORAGE_KEY\n      : FOCUS_SCALE_STORAGE_KEY_DEFAULT;\n\n  if (GLOBAL_SCOPE.FOCUS_SCALE_STORAGE_KEY !== existing) {\n    try {\n      GLOBAL_SCOPE.FOCUS_SCALE_STORAGE_KEY = existing;\n    } catch (assignError) {\n      if (typeof console !== 'undefined' && typeof console.warn === 'function') {\n        console.warn('Unable to assign focus scale storage key globally.', assignError);\n      }\n    }\n  }\n\n  if (GLOBAL_SCOPE.FOCUS_SCALE_STORAGE_KEY_NAME !== existing) {\n    try {\n      GLOBAL_SCOPE.FOCUS_SCALE_STORAGE_KEY_NAME = existing;\n    } catch (defineError) {\n      if (typeof console !== 'undefined' && typeof console.warn === 'function') {\n        console.warn('Unable to expose focus scale storage key globally.', defineError);\n      }\n    }\n  }\n\n  return existing;\n})();\nvar AUTO_GEAR_RULES_STORAGE_KEY = 'cameraPowerPlanner_autoGearRules';\nvar AUTO_GEAR_SEEDED_STORAGE_KEY = 'cameraPowerPlanner_autoGearSeeded';\nvar AUTO_GEAR_BACKUPS_STORAGE_KEY = 'cameraPowerPlanner_autoGearBackups';\nvar AUTO_GEAR_PRESETS_STORAGE_KEY = 'cameraPowerPlanner_autoGearPresets';\nvar AUTO_GEAR_MONITOR_DEFAULTS_STORAGE_KEY = 'cameraPowerPlanner_autoGearMonitorDefaults';\nvar AUTO_GEAR_ACTIVE_PRESET_STORAGE_KEY = 'cameraPowerPlanner_autoGearActivePreset';\nvar AUTO_GEAR_AUTO_PRESET_STORAGE_KEY = 'cameraPowerPlanner_autoGearAutoPreset';\nvar AUTO_GEAR_BACKUP_VISIBILITY_STORAGE_KEY = 'cameraPowerPlanner_autoGearShowBackups';\nvar AUTO_GEAR_BACKUP_RETENTION_STORAGE_KEY = 'cameraPowerPlanner_autoGearBackupRetention';\nvar FULL_BACKUP_HISTORY_STORAGE_KEY = 'cameraPowerPlanner_fullBackups';\nvar STORAGE_AUTO_BACKUP_NAME_PREFIX = 'auto-backup-';\nvar STORAGE_AUTO_BACKUP_DELETION_PREFIX = 'auto-backup-before-delete-';\nvar STORAGE_AUTO_BACKUP_RENAMED_FLAG = '__cineAutoBackupRenamed';\nvar AUTO_BACKUP_METADATA_PROPERTY = '__cineAutoBackupMetadata';\nvar AUTO_BACKUP_SNAPSHOT_PROPERTY = '__cineAutoBackupSnapshot';\nvar AUTO_BACKUP_SNAPSHOT_VERSION = 1;\nvar AUTO_BACKUP_PAYLOAD_COMPRESSION_FLAG = '__cineAutoBackupCompressedPayload';\nvar AUTO_BACKUP_CYCLE_PLACEHOLDER = '__cineCircular__';\n\nvar projectActivityTimestamps = new Map();\nvar forcedCompressedProjectKeys = typeof Set === 'function' ? new Set() : null;\nvar AUTO_BACKUP_PAYLOAD_COMPRESSION_MIN_LENGTH = 2048;\n\nfunction isAutoBackupStorageKey(name) {\n  return typeof name === 'string'\n    && (name.startsWith(STORAGE_AUTO_BACKUP_NAME_PREFIX)\n      || name.startsWith(STORAGE_AUTO_BACKUP_DELETION_PREFIX));\n}\n\nif (GLOBAL_SCOPE && typeof GLOBAL_SCOPE === 'object') {\n  try {\n    if (!Object.prototype.hasOwnProperty.call(GLOBAL_SCOPE, '__CINE_AUTO_BACKUP_RENAMED_FLAG')) {\n      Object.defineProperty(GLOBAL_SCOPE, '__CINE_AUTO_BACKUP_RENAMED_FLAG', {\n        configurable: true,\n        writable: false,\n        value: STORAGE_AUTO_BACKUP_RENAMED_FLAG,\n      });\n    }\n  } catch (error) {\n    void error;\n    try {\n      GLOBAL_SCOPE.__CINE_AUTO_BACKUP_RENAMED_FLAG = STORAGE_AUTO_BACKUP_RENAMED_FLAG;\n    } catch (assignmentError) {\n      void assignmentError;\n    }\n  }\n}\nvar MAX_AUTO_BACKUPS = 240;\nvar MAX_DELETION_BACKUPS = 20;\nvar MAX_FULL_BACKUP_HISTORY_ENTRIES = 200;\nvar AUTO_GEAR_BACKUP_RETENTION_DEFAULT_VALUE = 36;\nvar AUTO_GEAR_BACKUP_RETENTION_MIN = 1;\nvar AUTO_GEAR_BACKUP_RETENTION_MAX = 120;\n\nfunction ensureGlobalAutoGearBackupDefaults() {\n  if (!GLOBAL_SCOPE || typeof GLOBAL_SCOPE !== 'object') {\n    return;\n  }\n\n  if (typeof GLOBAL_SCOPE.AUTO_GEAR_BACKUP_RETENTION_DEFAULT !== 'number') {\n    try {\n      GLOBAL_SCOPE.AUTO_GEAR_BACKUP_RETENTION_DEFAULT = AUTO_GEAR_BACKUP_RETENTION_DEFAULT_VALUE;\n    } catch (error) {\n      if (typeof console !== 'undefined' && typeof console.warn === 'function') {\n        console.warn('Unable to expose auto gear backup retention default globally.', error);\n      }\n    }\n  }\n\n  if (typeof GLOBAL_SCOPE.AUTO_GEAR_BACKUP_RETENTION_MIN !== 'number') {\n    try {\n      GLOBAL_SCOPE.AUTO_GEAR_BACKUP_RETENTION_MIN = AUTO_GEAR_BACKUP_RETENTION_MIN;\n    } catch (error) {\n      if (typeof console !== 'undefined' && typeof console.warn === 'function') {\n        console.warn('Unable to expose auto gear backup retention minimum globally.', error);\n      }\n    }\n  }\n}\n\nensureGlobalAutoGearBackupDefaults();\n\nfunction cloneAutoBackupMetadata(metadata) {\n  if (!metadata || typeof metadata !== 'object') {\n    return null;\n  }\n\n  return {\n    version: Number.isFinite(metadata.version) ? metadata.version : AUTO_BACKUP_SNAPSHOT_VERSION,\n    snapshotType: metadata.snapshotType === 'delta' ? 'delta' : 'full',\n    base: typeof metadata.base === 'string' ? metadata.base : null,\n    sequence: Number.isFinite(metadata.sequence) ? metadata.sequence : (metadata.snapshotType === 'delta' ? 1 : 0),\n    createdAt: typeof metadata.createdAt === 'string' ? metadata.createdAt : null,\n    changedKeys: Array.isArray(metadata.changedKeys) ? metadata.changedKeys.slice() : [],\n    removedKeys: Array.isArray(metadata.removedKeys) ? metadata.removedKeys.slice() : [],\n    payloadSignature: typeof metadata.payloadSignature === 'string'\n      ? metadata.payloadSignature\n      : null,\n    payloadCompression: isPlainObject(metadata.payloadCompression)\n      ? { ...metadata.payloadCompression }\n      : null,\n    compressedPayload: isPlainObject(metadata.compressedPayload)\n      ? cloneAutoBackupValue(metadata.compressedPayload, { stripMetadata: true })\n      : metadata.compressedPayload && typeof metadata.compressedPayload === 'string'\n        ? metadata.compressedPayload\n        : null,\n  };\n}\n\nfunction defineAutoBackupMetadata(target, metadata) {\n  if (!target || typeof target !== 'object') {\n    return;\n  }\n\n  const clonedMetadata = cloneAutoBackupMetadata(metadata);\n\n  try {\n    Object.defineProperty(target, AUTO_BACKUP_METADATA_PROPERTY, {\n      configurable: true,\n      enumerable: false,\n      writable: true,\n      value: clonedMetadata,\n    });\n  } catch (error) {\n    void error;\n    try {\n      target[AUTO_BACKUP_METADATA_PROPERTY] = clonedMetadata;\n    } catch (assignmentError) {\n      void assignmentError;\n    }\n  }\n}\n\nfunction getAutoBackupMetadata(value) {\n  if (!value || typeof value !== 'object') {\n    return null;\n  }\n\n  const metadata = value[AUTO_BACKUP_METADATA_PROPERTY];\n  if (!metadata || typeof metadata !== 'object') {\n    return null;\n  }\n\n  return metadata;\n}\n\nfunction copyAutoBackupMetadata(source, target) {\n  if (!target || typeof target !== 'object') {\n    return;\n  }\n\n  const metadata = getAutoBackupMetadata(source);\n  if (metadata) {\n    defineAutoBackupMetadata(target, metadata);\n  }\n}\n\nfunction cloneAutoBackupValue(value, options, state) {\n  const opts = options || {};\n  const cloneState = state || (typeof WeakSet === 'function'\n    ? { stack: new WeakSet(), reportedCycle: false }\n    : null);\n\n  const handleCircularClone = (input, compute) => {\n    if (!cloneState || !cloneState.stack) {\n      return compute();\n    }\n    if (cloneState.stack.has(input)) {\n      if (!cloneState.reportedCycle\n        && typeof console !== 'undefined'\n        && console\n        && typeof console.warn === 'function') {\n        try {\n          console.warn(\n            'Detected circular reference while cloning automatic backup data. Using a placeholder to keep serialization stable.',\n          );\n        } catch (e) {\n          void e;\n          // Ignore warning errors during recursion\n        }\n      }\n      if (cloneState) {\n        cloneState.reportedCycle = true;\n      }\n      return AUTO_BACKUP_CYCLE_PLACEHOLDER;\n    }\n    cloneState.stack.add(input);\n    try {\n      return compute();\n    } finally {\n      cloneState.stack.delete(input);\n    }\n  };\n\n  if (value === null || typeof value !== 'object') {\n    return value;\n  }\n\n  if (value instanceof Date) {\n    return new Date(value.getTime());\n  }\n\n  if (Array.isArray(value)) {\n    return handleCircularClone(value, () => value.map((item) => cloneAutoBackupValue(item, opts, cloneState)));\n  }\n\n  return handleCircularClone(value, () => {\n    const clone = {};\n    Object.keys(value).forEach((key) => {\n      if (opts.stripMetadata && key === AUTO_BACKUP_METADATA_PROPERTY) {\n        return;\n      }\n      clone[key] = cloneAutoBackupValue(value[key], opts, cloneState);\n    });\n\n    if (!opts.stripMetadata) {\n      const metadata = getAutoBackupMetadata(value);\n      if (metadata) {\n        defineAutoBackupMetadata(clone, metadata);\n      }\n    }\n\n    return clone;\n  });\n}\n\nfunction cloneAutoBackupValueWithLegacyNormalization(value, options) {\n  const cloneState = typeof WeakSet === 'function'\n    ? { stack: new WeakSet(), reportedCycle: false }\n    : null;\n  const cloned = cloneAutoBackupValue(value, options, cloneState);\n  const normalized = normalizeLegacyLongGopStructure(cloned);\n  return normalized !== cloned ? normalized : cloned;\n}\n\nfunction isCompressedAutoBackupSnapshotPayload(payload) {\n  if (!isPlainObject(payload)) {\n    return false;\n  }\n  if (payload[AUTO_BACKUP_PAYLOAD_COMPRESSION_FLAG] !== true) {\n    return false;\n  }\n  return typeof payload.data === 'string' && payload.data;\n}\n\nfunction prepareAutoBackupSnapshotPayloadForStorage(payload, contextName, options) {\n  if (!payload || typeof payload !== 'object') {\n    return {\n      payload,\n      compression: null,\n      compressed: false,\n      reused: false,\n      payloadSignature: null,\n    };\n  }\n\n  const opts = options || {};\n  if (opts.disableCompression) {\n    return {\n      payload,\n      compression: null,\n      compressed: false,\n      reused: false,\n      payloadSignature: typeof opts.payloadSignature === 'string'\n        ? opts.payloadSignature\n        : null,\n    };\n  }\n\n  const shouldReport = opts.reportCompression !== false;\n\n  let computedSignature = null;\n  try {\n    computedSignature = typeof opts.payloadSignature === 'string'\n      ? opts.payloadSignature\n      : createStableValueSignature(payload);\n  } catch (signatureError) {\n    computedSignature = null;\n    console.warn(\n      'Unable to compute stable signature for automatic backup payload before compression',\n      signatureError,\n    );\n  }\n\n  const existingSignature = typeof opts.existingPayloadSignature === 'string'\n    ? opts.existingPayloadSignature\n    : null;\n\n  if (\n    existingSignature\n    && computedSignature\n    && existingSignature === computedSignature\n    && isCompressedAutoBackupSnapshotPayload(opts.existingCompressedPayload)\n  ) {\n    const reusedPayload = cloneAutoBackupValue(opts.existingCompressedPayload, { stripMetadata: true });\n    const reusedCompression = isPlainObject(opts.existingPayloadCompression)\n      ? { ...opts.existingPayloadCompression }\n      : null;\n    if (\n      !opts.disableCompression\n      && typeof computedSignature === 'string'\n      && computedSignature\n    ) {\n      writeAutoBackupCompressionCache(computedSignature, reusedPayload, reusedCompression);\n    }\n    return {\n      payload: reusedPayload,\n      compression: reusedCompression,\n      compressed: true,\n      reused: true,\n      payloadSignature: computedSignature,\n    };\n  }\n\n  if (\n    !opts.disableCompression\n    && typeof computedSignature === 'string'\n    && computedSignature\n  ) {\n    const cached = readAutoBackupCompressionCache(computedSignature);\n    if (cached && cached.payload) {\n      return {\n        payload: cached.payload,\n        compression: cached.compression,\n        compressed: true,\n        reused: true,\n        payloadSignature: computedSignature,\n      };\n    }\n  }\n\n  let serialized;\n  try {\n    serialized = JSON.stringify(payload);\n  } catch (error) {\n    console.warn('Unable to serialize auto backup payload before compression', error);\n    return {\n      payload,\n      compression: null,\n      compressed: false,\n      reused: false,\n      payloadSignature: computedSignature,\n    };\n  }\n\n  if (typeof serialized !== 'string' || serialized.length < AUTO_BACKUP_PAYLOAD_COMPRESSION_MIN_LENGTH) {\n    return {\n      payload,\n      compression: null,\n      compressed: false,\n      reused: false,\n      payloadSignature: computedSignature,\n    };\n  }\n\n  if (\n    !opts.disableCompression\n    && isCompressedAutoBackupSnapshotPayload(opts.existingCompressedPayload)\n  ) {\n    const decodedExisting = decodeCompressedJsonStorageValue(\n      opts.existingCompressedPayload.data,\n    );\n    if (decodedExisting.success && typeof decodedExisting.value === 'string') {\n      if (decodedExisting.value === serialized) {\n        const reusedPayload = cloneAutoBackupValue(opts.existingCompressedPayload, {\n          stripMetadata: true,\n        });\n        const reusedCompression = isPlainObject(opts.existingPayloadCompression)\n          ? { ...opts.existingPayloadCompression }\n          : null;\n        const resolvedSignature = typeof computedSignature === 'string'\n          && computedSignature\n          ? computedSignature\n          : (typeof existingSignature === 'string' && existingSignature\n            ? existingSignature\n            : null);\n        if (resolvedSignature) {\n          writeAutoBackupCompressionCache(\n            resolvedSignature,\n            reusedPayload,\n            reusedCompression,\n          );\n        }\n        return {\n          payload: reusedPayload,\n          compression: reusedCompression,\n          compressed: true,\n          reused: true,\n          payloadSignature: resolvedSignature,\n        };\n      }\n    }\n  }\n\n  const candidate = createCompressedJsonStorageCandidate(serialized);\n  if (!candidate || typeof candidate.serialized !== 'string') {\n    return {\n      payload,\n      compression: null,\n      compressed: false,\n      reused: false,\n      payloadSignature: computedSignature,\n    };\n  }\n\n  const savings = candidate.originalLength - candidate.wrappedLength;\n  const compressedPayload = {\n    [AUTO_BACKUP_PAYLOAD_COMPRESSION_FLAG]: true,\n    data: candidate.serialized,\n    originalLength: candidate.originalLength,\n    compressedLength: candidate.wrappedLength,\n    compressionVariant: candidate.compressionVariant || null,\n  };\n\n  const compressionInfo =\n    typeof candidate.originalLength === 'number'\n      && Number.isFinite(candidate.originalLength)\n      && typeof candidate.wrappedLength === 'number'\n      && Number.isFinite(candidate.wrappedLength)\n      ? {\n        originalLength: candidate.originalLength,\n        compressedLength: candidate.wrappedLength,\n        compressionVariant: candidate.compressionVariant || null,\n      }\n      : null;\n\n  if (\n    !opts.disableCompression\n    && typeof computedSignature === 'string'\n    && computedSignature\n  ) {\n    writeAutoBackupCompressionCache(\n      computedSignature,\n      compressedPayload,\n      compressionInfo,\n    );\n  }\n\n  if (\n    shouldReport\n    && typeof console !== 'undefined'\n    && typeof console.warn === 'function'\n    && savings > 0\n  ) {\n    const label = typeof contextName === 'string' && contextName\n      ? `\"${contextName}\"`\n      : 'an automatic backup';\n    const percent = candidate.originalLength > 0\n      ? Math.round((savings / candidate.originalLength) * 100)\n      : 0;\n    const message = `Stored compressed payload for ${label} snapshot to reduce storage usage by ${savings} characters (${percent}%).`;\n    logCompressionSavingsEvent('auto-backup', contextName || label, message, savings, percent);\n  }\n\n  return {\n    payload: compressedPayload,\n    compression: {\n      originalLength: candidate.originalLength,\n      compressedLength: candidate.wrappedLength,\n      compressionVariant: candidate.compressionVariant || null,\n    },\n    compressed: true,\n    reused: false,\n    payloadSignature: computedSignature,\n  };\n}\n\nfunction restoreAutoBackupSnapshotPayload(snapshot, contextName) {\n  if (!snapshot || typeof snapshot !== 'object') {\n    return { payload: snapshot, compressed: false };\n  }\n\n  const rawPayload = snapshot.payload;\n  if (!isCompressedAutoBackupSnapshotPayload(rawPayload)) {\n    return { payload: rawPayload, compressed: false };\n  }\n\n  const decoded = decodeCompressedJsonStorageValue(rawPayload.data);\n  if (!decoded.success || typeof decoded.value !== 'string') {\n    const details = decoded && decoded.error ? decoded.error : null;\n    console.warn('Unable to decompress automatic backup payload.', contextName, details);\n    throw new Error('Failed to decompress automatic backup payload');\n  }\n\n  try {\n    const parsed = JSON.parse(decoded.value);\n    return { payload: parsed, compressed: true };\n  } catch (error) {\n    console.warn('Unable to parse decompressed automatic backup payload.', contextName, error);\n    throw error;\n  }\n}\n\nfunction deriveAutoBackupCreatedAt(name, fallbackDate) {\n  const info = parseAutoBackupKey(name);\n  if (info && Number.isFinite(info.timestamp) && info.timestamp > 0) {\n    try {\n      return new Date(info.timestamp).toISOString();\n    } catch (error) {\n      void error;\n    }\n  }\n\n  const sourceDate = fallbackDate instanceof Date ? fallbackDate : new Date();\n  try {\n    return sourceDate.toISOString();\n  } catch (error) {\n    void error;\n    return new Date().toISOString();\n  }\n}\n\nfunction detectCyclicAutoBackupReference(entries, name, metadata) {\n  if (!isPlainObject(entries) || !metadata || metadata.snapshotType !== 'delta') {\n    return { cycle: false, path: [] };\n  }\n\n  const visited = new Set();\n  const path = [];\n  const maxSteps = Math.max(10, Object.keys(entries).length + 5);\n  let steps = 0;\n  let currentName = name;\n  let currentMetadata = metadata;\n\n  while (currentMetadata && currentMetadata.snapshotType === 'delta') {\n    if (steps > maxSteps) {\n      return { cycle: true, path };\n    }\n\n    const baseName = typeof currentMetadata.base === 'string' ? currentMetadata.base : null;\n    if (!baseName) {\n      return { cycle: false, path };\n    }\n\n    if (!isAutoBackupStorageKey(baseName)) {\n      return { cycle: false, path };\n    }\n\n    if (visited.has(baseName)) {\n      path.push(baseName);\n      return { cycle: true, path };\n    }\n\n    visited.add(currentName);\n    path.push(currentName);\n\n    const baseEntry = Object.prototype.hasOwnProperty.call(entries, baseName)\n      ? entries[baseName]\n      : null;\n    if (!isPlainObject(baseEntry)) {\n      return { cycle: false, path };\n    }\n\n    currentName = baseName;\n    currentMetadata = getAutoBackupMetadata(baseEntry);\n    if (!currentMetadata) {\n      return { cycle: false, path };\n    }\n\n    steps += 1;\n  }\n\n  return { cycle: false, path };\n}\n\nfunction promoteAutoBackupMetadataToFull(metadata, name, value) {\n  if (!metadata || typeof metadata !== 'object') {\n    return;\n  }\n\n  metadata.snapshotType = 'full';\n  metadata.base = null;\n  metadata.sequence = 0;\n  metadata.removedKeys = [];\n\n  const keys = isPlainObject(value) ? Object.keys(value) : [];\n  metadata.changedKeys = keys.slice();\n\n  if (typeof metadata.createdAt !== 'string' || !metadata.createdAt) {\n    metadata.createdAt = deriveAutoBackupCreatedAt(name);\n  }\n}\n\nfunction expandAutoBackupEntries(container, options) {\n  if (!isPlainObject(container)) {\n    return container;\n  }\n\n  const result = {};\n  const cache = new Map();\n  const opts = options || {};\n  const isAutoBackupKey = typeof opts.isAutoBackupKey === 'function'\n    ? opts.isAutoBackupKey\n    : isAutoBackupStorageKey;\n  const filter = typeof opts.filter === 'function' ? opts.filter : null;\n\n  const shouldIncludeEntry = filter\n    ? (name) => {\n      let include = false;\n      try {\n        include = filter(name);\n      } catch (filterError) {\n        include = false;\n        void filterError;\n      }\n      return include;\n    }\n    : () => true;\n\n  const resolve = (name, stack) => {\n    if (cache.has(name)) {\n      return cache.get(name);\n    }\n\n    const rawValue = container[name];\n    const restored = restoreCompressedProjectEntry(rawValue, name);\n    const value = restored.restored ? restored.value : rawValue;\n    if (!isPlainObject(value)) {\n      const clonedValue = cloneAutoBackupValue(value);\n      cache.set(name, clonedValue);\n      return clonedValue;\n    }\n\n    const snapshot = value[AUTO_BACKUP_SNAPSHOT_PROPERTY];\n    if (snapshot && typeof snapshot === 'object') {\n      if (stack.has(name)) {\n        console.warn('Detected cyclic auto-backup reference while expanding snapshot', name);\n        let fallbackPayload = {};\n        let payloadKeys = [];\n        let payloadSignature = null;\n\n        try {\n          const payloadInfo = restoreAutoBackupSnapshotPayload(snapshot, name);\n          if (payloadInfo && isPlainObject(payloadInfo.payload)) {\n            fallbackPayload = cloneAutoBackupValue(payloadInfo.payload);\n            payloadKeys = Object.keys(payloadInfo.payload);\n            try {\n              payloadSignature = createStableValueSignature(payloadInfo.payload);\n            } catch (cycleSignatureError) {\n              payloadSignature = null;\n              console.warn(\n                'Unable to compute stable signature for automatic backup payload after detecting a cycle',\n                cycleSignatureError,\n              );\n            }\n          }\n        } catch (cyclePayloadError) {\n          console.warn(\n            'Failed to restore automatic backup payload after detecting a cyclic reference',\n            name,\n            cyclePayloadError,\n          );\n        }\n\n        const metadata = {\n          version: Number.isFinite(snapshot.version) ? snapshot.version : AUTO_BACKUP_SNAPSHOT_VERSION,\n          snapshotType: 'full',\n          base: null,\n          sequence: Number.isFinite(snapshot.sequence) ? snapshot.sequence : 0,\n          createdAt: typeof snapshot.createdAt === 'string'\n            ? snapshot.createdAt\n            : deriveAutoBackupCreatedAt(name),\n          changedKeys: payloadKeys.slice(),\n          removedKeys: [],\n          payloadSignature,\n        };\n\n        if (isCompressedAutoBackupSnapshotPayload(snapshot.payload)) {\n          metadata.compressedPayload = cloneAutoBackupValue(snapshot.payload, { stripMetadata: true });\n          metadata.payloadCompression = isPlainObject(snapshot.payloadCompression)\n            ? { ...snapshot.payloadCompression }\n            : null;\n        } else {\n          metadata.compressedPayload = null;\n          metadata.payloadCompression = null;\n        }\n\n        defineAutoBackupMetadata(fallbackPayload, metadata);\n        cache.set(name, fallbackPayload);\n        return fallbackPayload;\n      }\n\n      stack.add(name);\n\n      const snapshotType = snapshot.snapshotType === 'delta' ? 'delta' : 'full';\n      const baseName = snapshotType === 'delta' && typeof snapshot.base === 'string'\n        ? snapshot.base\n        : null;\n      const baseValue = baseName ? cloneAutoBackupValue(resolve(baseName, stack)) : {};\n      let payloadInfo;\n      try {\n        payloadInfo = restoreAutoBackupSnapshotPayload(snapshot, name);\n      } catch (payloadError) {\n        console.warn('Failed to restore automatic backup payload while expanding snapshot', name, payloadError);\n        throw payloadError;\n      }\n      const payload = isPlainObject(payloadInfo.payload) ? payloadInfo.payload : {};\n      const changedKeys = Array.isArray(snapshot.changedKeys) && snapshot.changedKeys.length\n        ? snapshot.changedKeys\n        : Object.keys(payload);\n      const removedKeys = Array.isArray(snapshot.removedKeys) ? snapshot.removedKeys : [];\n\n      const expanded = cloneAutoBackupValue(baseValue);\n\n      changedKeys.forEach((key) => {\n        if (Object.prototype.hasOwnProperty.call(payload, key)) {\n          if (expanded) {\n            expanded[key] = cloneAutoBackupValue(payload[key]);\n          }\n        }\n      });\n\n      removedKeys.forEach((key) => {\n        if (Object.prototype.hasOwnProperty.call(expanded, key)) {\n          delete expanded[key];\n        }\n      });\n\n      const metadata = {\n        version: Number.isFinite(snapshot.version) ? snapshot.version : AUTO_BACKUP_SNAPSHOT_VERSION,\n        snapshotType,\n        base: snapshotType === 'delta' ? baseName : null,\n        sequence: Number.isFinite(snapshot.sequence)\n          ? snapshot.sequence\n          : (snapshotType === 'delta' ? 1 : 0),\n        createdAt: typeof snapshot.createdAt === 'string'\n          ? snapshot.createdAt\n          : deriveAutoBackupCreatedAt(name),\n        changedKeys: changedKeys.slice(),\n        removedKeys: removedKeys.slice(),\n      };\n\n      try {\n        metadata.payloadSignature = createStableValueSignature(payload);\n      } catch (payloadSignatureError) {\n        metadata.payloadSignature = null;\n        console.warn(\n          'Unable to compute stable signature for automatic backup payload during expansion',\n          payloadSignatureError,\n        );\n      }\n\n      if (isCompressedAutoBackupSnapshotPayload(snapshot.payload)) {\n        metadata.compressedPayload = cloneAutoBackupValue(snapshot.payload, { stripMetadata: true });\n        metadata.payloadCompression = isPlainObject(snapshot.payloadCompression)\n          ? { ...snapshot.payloadCompression }\n          : null;\n      } else {\n        metadata.compressedPayload = null;\n        metadata.payloadCompression = null;\n      }\n\n      defineAutoBackupMetadata(expanded, metadata);\n      cache.set(name, expanded);\n      stack.delete(name);\n      return expanded;\n    }\n\n    const cloned = cloneAutoBackupValue(value);\n    if (isAutoBackupKey(name)) {\n      const metadata = {\n        version: AUTO_BACKUP_SNAPSHOT_VERSION,\n        snapshotType: 'full',\n        base: null,\n        sequence: 0,\n        createdAt: deriveAutoBackupCreatedAt(name),\n        changedKeys: Object.keys(cloned),\n        removedKeys: [],\n      };\n      defineAutoBackupMetadata(cloned, metadata);\n    }\n    cache.set(name, cloned);\n    return cloned;\n  };\n\n  Object.keys(container).forEach((name) => {\n    if (!shouldIncludeEntry(name)) {\n      return;\n    }\n    if (!isAutoBackupKey(name)) {\n      const value = container[name];\n      result[name] = isPlainObject(value)\n        ? cloneAutoBackupValue(value)\n        : value;\n      return;\n    }\n\n    result[name] = resolve(name, new Set());\n  });\n\n  return result;\n}\n\nfunction computeAutoBackupDiff(currentValue, baseValue) {\n  const payload = {};\n  const changedKeys = [];\n  const removedKeys = [];\n\n  const baseKeys = isPlainObject(baseValue) ? Object.keys(baseValue) : [];\n  const currentKeys = isPlainObject(currentValue) ? Object.keys(currentValue) : [];\n  const allKeys = new Set([...baseKeys, ...currentKeys]);\n\n  allKeys.forEach((key) => {\n    if (key === AUTO_BACKUP_METADATA_PROPERTY) {\n      return;\n    }\n\n    const hasCurrent = Object.prototype.hasOwnProperty.call(currentValue || {}, key);\n    const hasBase = Object.prototype.hasOwnProperty.call(baseValue || {}, key);\n\n    if (!hasCurrent && hasBase) {\n      removedKeys.push(key);\n      return;\n    }\n\n    if (!hasCurrent) {\n      return;\n    }\n\n    const currentEntry = currentValue ? currentValue[key] : undefined;\n    const baseEntry = hasBase ? baseValue[key] : undefined;\n\n    const currentSignature = createStableValueSignature(currentEntry);\n    const baseSignature = createStableValueSignature(baseEntry);\n\n    if (currentSignature !== baseSignature) {\n      changedKeys.push(key);\n      payload[key] = cloneAutoBackupValue(currentEntry, { stripMetadata: true });\n    }\n  });\n\n  return { payload, changedKeys, removedKeys };\n}\n\nfunction serializeAutoBackupEntries(entries, options) {\n  if (!isPlainObject(entries)) {\n    return entries;\n  }\n\n  const opts = options || {};\n  const isAutoBackupKey = typeof opts.isAutoBackupKey === 'function'\n    ? opts.isAutoBackupKey\n    : isAutoBackupStorageKey;\n\n  const serialized = {};\n  const entryNames = Object.keys(entries);\n\n  const latestAutoBackupNames = (() => {\n    const groups = new Map();\n    entryNames.forEach((name) => {\n      if (!isAutoBackupKey(name)) {\n        return;\n      }\n      const value = entries[name];\n      const metadata = getAutoBackupMetadata(value);\n      let timestamp = Number.NEGATIVE_INFINITY;\n      if (metadata && typeof metadata.createdAt === 'string') {\n        const parsed = Date.parse(metadata.createdAt);\n        if (!Number.isNaN(parsed)) {\n          timestamp = parsed;\n        }\n      }\n      if (!Number.isFinite(timestamp)) {\n        const parsedKey = parseAutoBackupKey(name);\n        if (parsedKey && Number.isFinite(parsedKey.timestamp)) {\n          timestamp = parsedKey.timestamp;\n        }\n      }\n      const groupKey = name.startsWith(STORAGE_AUTO_BACKUP_DELETION_PREFIX)\n        ? STORAGE_AUTO_BACKUP_DELETION_PREFIX\n        : STORAGE_AUTO_BACKUP_NAME_PREFIX;\n      const current = groups.get(groupKey);\n      if (\n        !current\n        || timestamp > current.timestamp\n        || (timestamp === current.timestamp && name.localeCompare(current.name) > 0)\n      ) {\n        groups.set(groupKey, { name, timestamp });\n      }\n    });\n    const result = new Set();\n    groups.forEach(({ name }) => {\n      if (typeof name === 'string' && name) {\n        result.add(name);\n      }\n    });\n    return result;\n  })();\n\n  entryNames.forEach((name) => {\n    const value = entries[name];\n    const normalizedValue = cloneAutoBackupValueWithLegacyNormalization(value, { stripMetadata: true });\n\n    if (!isAutoBackupKey(name) || !isPlainObject(normalizedValue)) {\n      serialized[name] = normalizedValue;\n      return;\n    }\n\n    const disableCompressionForName = latestAutoBackupNames.has(name);\n    const metadata = getAutoBackupMetadata(value);\n    if (metadata && metadata.snapshotType === 'delta') {\n      const cycleInfo = detectCyclicAutoBackupReference(entries, name, metadata);\n      if (cycleInfo.cycle) {\n        if (typeof console !== 'undefined' && typeof console.warn === 'function') {\n          console.warn(\n            'Detected cyclic automatic backup chain during serialization. Promoting to full snapshot.',\n            name,\n          );\n        }\n        promoteAutoBackupMetadataToFull(metadata, name, normalizedValue);\n      }\n    }\n    const createdAt = metadata && typeof metadata.createdAt === 'string'\n      ? metadata.createdAt\n      : deriveAutoBackupCreatedAt(name);\n\n    if (!metadata || metadata.snapshotType !== 'delta') {\n      serialized[name] = {};\n      const snapshot = {\n        version: AUTO_BACKUP_SNAPSHOT_VERSION,\n        snapshotType: 'full',\n        base: null,\n        sequence: 0,\n        createdAt,\n        changedKeys: Object.keys(normalizedValue || {}),\n        removedKeys: [],\n      };\n      let payloadSignature;\n      try {\n        payloadSignature = createStableValueSignature(normalizedValue);\n      } catch (signatureError) {\n        payloadSignature = null;\n        console.warn(\n          'Unable to compute stable signature for automatic backup payload before serialization',\n          signatureError,\n        );\n      }\n      const prepared = prepareAutoBackupSnapshotPayloadForStorage(normalizedValue, name, {\n        disableCompression: disableCompressionForName,\n        payloadSignature,\n        existingCompressedPayload: metadata ? metadata.compressedPayload : null,\n        existingPayloadCompression: metadata ? metadata.payloadCompression : null,\n        existingPayloadSignature: metadata ? metadata.payloadSignature : null,\n      });\n      snapshot.payload = prepared.payload;\n      if (prepared.compression) {\n        snapshot.payloadCompression = prepared.compression;\n      }\n      if (metadata) {\n        const resolvedSignature = typeof prepared.payloadSignature === 'string'\n          ? prepared.payloadSignature\n          : payloadSignature;\n        metadata.payloadSignature = resolvedSignature || null;\n        if (prepared.compressed) {\n          metadata.compressedPayload = cloneAutoBackupValue(prepared.payload, { stripMetadata: true });\n          metadata.payloadCompression = prepared.compression\n            ? { ...prepared.compression }\n            : null;\n        } else {\n          metadata.compressedPayload = null;\n          metadata.payloadCompression = null;\n        }\n      }\n      serialized[name][AUTO_BACKUP_SNAPSHOT_PROPERTY] = snapshot;\n      return;\n    }\n\n    const baseName = typeof metadata.base === 'string' ? metadata.base : null;\n    const baseValue = baseName && Object.prototype.hasOwnProperty.call(entries, baseName)\n      ? entries[baseName]\n      : null;\n\n    if (!baseValue || !isPlainObject(baseValue)) {\n      serialized[name] = {};\n      const snapshot = {\n        version: AUTO_BACKUP_SNAPSHOT_VERSION,\n        snapshotType: 'full',\n        base: null,\n        sequence: 0,\n        createdAt,\n        changedKeys: Object.keys(normalizedValue || {}),\n        removedKeys: [],\n      };\n      let payloadSignature;\n      try {\n        payloadSignature = createStableValueSignature(normalizedValue);\n      } catch (signatureError) {\n        payloadSignature = null;\n        console.warn(\n          'Unable to compute stable signature for automatic backup payload before serialization',\n          signatureError,\n        );\n      }\n      const prepared = prepareAutoBackupSnapshotPayloadForStorage(normalizedValue, name, {\n        disableCompression: disableCompressionForName,\n        payloadSignature,\n        existingCompressedPayload: metadata ? metadata.compressedPayload : null,\n        existingPayloadCompression: metadata ? metadata.payloadCompression : null,\n        existingPayloadSignature: metadata ? metadata.payloadSignature : null,\n      });\n      snapshot.payload = prepared.payload;\n      if (prepared.compression) {\n        snapshot.payloadCompression = prepared.compression;\n      }\n      if (metadata) {\n        const resolvedSignature = typeof prepared.payloadSignature === 'string'\n          ? prepared.payloadSignature\n          : payloadSignature;\n        metadata.payloadSignature = resolvedSignature || null;\n        if (prepared.compressed) {\n          metadata.compressedPayload = cloneAutoBackupValue(prepared.payload, { stripMetadata: true });\n          metadata.payloadCompression = prepared.compression\n            ? { ...prepared.compression }\n            : null;\n        } else {\n          metadata.compressedPayload = null;\n          metadata.payloadCompression = null;\n        }\n      }\n      serialized[name][AUTO_BACKUP_SNAPSHOT_PROPERTY] = snapshot;\n      return;\n    }\n\n    const normalizedBase = cloneAutoBackupValueWithLegacyNormalization(baseValue, { stripMetadata: true });\n    const diff = computeAutoBackupDiff(normalizedValue, normalizedBase);\n\n    serialized[name] = {};\n    const snapshot = {\n      version: Number.isFinite(metadata.version) ? metadata.version : AUTO_BACKUP_SNAPSHOT_VERSION,\n      snapshotType: 'delta',\n      base: baseName,\n      sequence: Number.isFinite(metadata.sequence) ? metadata.sequence : 1,\n      createdAt,\n      changedKeys: diff.changedKeys,\n      removedKeys: diff.removedKeys,\n    };\n    let payloadSignature;\n    try {\n      payloadSignature = createStableValueSignature(diff.payload);\n    } catch (signatureError) {\n      payloadSignature = null;\n      console.warn(\n        'Unable to compute stable signature for automatic backup delta payload before serialization',\n        signatureError,\n      );\n    }\n    const prepared = prepareAutoBackupSnapshotPayloadForStorage(diff.payload, name, {\n      disableCompression: disableCompressionForName,\n      payloadSignature,\n      existingCompressedPayload: metadata ? metadata.compressedPayload : null,\n      existingPayloadCompression: metadata ? metadata.payloadCompression : null,\n      existingPayloadSignature: metadata ? metadata.payloadSignature : null,\n    });\n    snapshot.payload = prepared.payload;\n    if (prepared.compression) {\n      snapshot.payloadCompression = prepared.compression;\n    }\n    if (metadata) {\n      const resolvedSignature = typeof prepared.payloadSignature === 'string'\n        ? prepared.payloadSignature\n        : payloadSignature;\n      metadata.payloadSignature = resolvedSignature || null;\n      if (prepared.compressed) {\n        metadata.compressedPayload = cloneAutoBackupValue(prepared.payload, { stripMetadata: true });\n        metadata.payloadCompression = prepared.compression\n          ? { ...prepared.compression }\n          : null;\n      } else {\n        metadata.compressedPayload = null;\n        metadata.payloadCompression = null;\n      }\n    }\n    serialized[name][AUTO_BACKUP_SNAPSHOT_PROPERTY] = snapshot;\n  });\n\n  return serialized;\n}\n\nfunction getStorageKeyVariants(key) {\n  if (typeof key !== 'string' || !key) {\n    return [key];\n  }\n\n  const variants = new Set([key]);\n\n  if (key.startsWith('cameraPowerPlanner_')) {\n    variants.add(`cinePowerPlanner_${key.slice('cameraPowerPlanner_'.length)}`);\n  } else if (key.startsWith('cinePowerPlanner_')) {\n    variants.add(`cameraPowerPlanner_${key.slice('cinePowerPlanner_'.length)}`);\n  }\n\n  return Array.from(variants);\n}\n\nvar SETUP_STORAGE_KEY_VARIANTS = new Set(getStorageKeyVariants(SETUP_STORAGE_KEY));\n\nfunction getDeviceStorageKeyVariants() {\n  if (\n    !DEVICE_STORAGE_KEY_VARIANTS\n    || typeof DEVICE_STORAGE_KEY_VARIANTS.has !== 'function'\n  ) {\n    DEVICE_STORAGE_KEY_VARIANTS = new Set(getStorageKeyVariants(DEVICE_STORAGE_KEY));\n  }\n  return DEVICE_STORAGE_KEY_VARIANTS;\n}\n\nfunction isDeviceStorageKeyVariant(key) {\n  if (typeof key !== 'string' || !key) {\n    return false;\n  }\n\n  const variants = getDeviceStorageKeyVariants();\n  if (variants && typeof variants.has === 'function') {\n    return variants.has(key);\n  }\n\n  return key === DEVICE_STORAGE_KEY;\n}\n\nfunction shouldAllowCriticalSweepPrimaryInspection(key) {\n  if (typeof key !== 'string' || !key) {\n    return false;\n  }\n\n  if (!SETUP_STORAGE_KEY_VARIANTS || typeof SETUP_STORAGE_KEY_VARIANTS.has !== 'function') {\n    return false;\n  }\n\n  if (!SETUP_STORAGE_KEY_VARIANTS.has(key)) {\n    return false;\n  }\n\n  if (ACTIVE_PROJECT_COMPRESSION_HOLD_ENABLED) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction inspectSetupStorageForQuotaRecovery(storage, skipKeysSet) {\n  if (!storage || typeof storage.getItem !== 'function') {\n    return;\n  }\n\n  if (!SETUP_STORAGE_KEY_VARIANTS || typeof SETUP_STORAGE_KEY_VARIANTS.forEach !== 'function') {\n    return;\n  }\n\n  const visited = new Set();\n  const skipSet = skipKeysSet && typeof skipKeysSet.has === 'function' ? skipKeysSet : null;\n\n  SETUP_STORAGE_KEY_VARIANTS.forEach((key) => {\n    if (typeof key !== 'string' || !key || visited.has(key)) {\n      return;\n    }\n\n    visited.add(key);\n\n    if (skipSet && skipSet.has(key)) {\n      return;\n    }\n\n    try {\n      storage.getItem(key);\n    } catch (inspectionError) {\n      void inspectionError;\n    }\n  });\n}\n\nvar STORAGE_BACKUP_SUFFIX = '__backup';\nvar MAX_SAVE_ATTEMPTS = 3;\nvar MAX_QUOTA_RECOVERY_STEPS = 100;\nvar STORAGE_MIGRATION_BACKUP_SUFFIX = '__legacyMigrationBackup';\nvar RAW_STORAGE_BACKUP_KEYS = new Set([\n  getCustomFontStorageKeyName(),\n  CUSTOM_LOGO_STORAGE_KEY,\n  DEVICE_SCHEMA_CACHE_KEY,\n  CONTACTS_STORAGE_KEY,\n  OWN_GEAR_STORAGE_KEY,\n  DOCUMENTATION_TRACKER_STORAGE_KEY,\n  MOUNT_VOLTAGE_STORAGE_KEY_NAME,\n  FOCUS_SCALE_STORAGE_KEY_NAME,\n  PRINT_PREFERENCES_STORAGE_KEY,\n]);\n\nArray.from(RAW_STORAGE_BACKUP_KEYS).forEach((key) => {\n  getStorageKeyVariants(key).forEach((variant) => {\n    if (typeof variant === 'string' && variant) {\n      RAW_STORAGE_BACKUP_KEYS.add(variant);\n    }\n  });\n});\n\nvar CRITICAL_BACKUP_KEY_PROVIDERS = [\n  () => ({ key: DEVICE_STORAGE_KEY }),\n  () => ({ key: SETUP_STORAGE_KEY }),\n  () => ({ key: SESSION_STATE_KEY }),\n  () => ({ key: FEEDBACK_STORAGE_KEY }),\n  () => ({\n    key: PROJECT_STORAGE_KEY,\n    valueProvider: () => {\n      // Since we sharded projects, the main PROJECT_STORAGE_KEY is likely empty or gone.\n      // We want to reconstruct the monolithic object so that the backup file contains\n      // all projects, acting as a \"full backup\" safety net.\n      if (typeof readAllProjectsFromStorage === 'function') {\n        try {\n          const { projects } = readAllProjectsFromStorage({ forMutation: false });\n          if (projects && typeof projects === 'object') {\n            // Serialize manually to string as ensureCriticalStorageBackups expects string-ish values\n            return JSON.stringify(projects);\n          }\n        } catch (e) {\n          if (typeof console !== 'undefined' && console.warn) {\n            console.warn('Failed to reconstruct monolithic project backup', e);\n          }\n        }\n      }\n      return null;\n    }\n  }),\n  () => ({ key: FAVORITES_STORAGE_KEY }),\n  () => ({ key: CONTACTS_STORAGE_KEY }),\n  () => ({ key: OWN_GEAR_STORAGE_KEY }),\n  () => ({ key: DOCUMENTATION_TRACKER_STORAGE_KEY }),\n  () => ({ key: DEVICE_SCHEMA_CACHE_KEY }),\n  () => ({ key: AUTO_GEAR_RULES_STORAGE_KEY }),\n  () => ({ key: AUTO_GEAR_SEEDED_STORAGE_KEY }),\n  () => ({ key: AUTO_GEAR_BACKUPS_STORAGE_KEY }),\n  () => ({ key: AUTO_GEAR_PRESETS_STORAGE_KEY }),\n  () => ({ key: AUTO_GEAR_ACTIVE_PRESET_STORAGE_KEY }),\n  () => ({ key: AUTO_GEAR_AUTO_PRESET_STORAGE_KEY }),\n  () => ({ key: AUTO_GEAR_BACKUP_VISIBILITY_STORAGE_KEY }),\n  () => ({ key: AUTO_GEAR_BACKUP_RETENTION_STORAGE_KEY }),\n  () => ({ key: AUTO_GEAR_MONITOR_DEFAULTS_STORAGE_KEY }),\n  () => ({ key: FULL_BACKUP_HISTORY_STORAGE_KEY }),\n  () => ({ key: CUSTOM_LOGO_STORAGE_KEY }),\n  () => ({ key: getCustomFontStorageKeyName() }),\n  () => ({ key: 'darkMode' }),\n  () => ({ key: 'pinkMode' }),\n  () => ({ key: 'highContrast' }),\n  () => ({ key: 'reduceMotion' }),\n  () => ({ key: 'relaxedSpacing' }),\n  () => ({ key: 'showAutoBackups' }),\n  () => ({ key: 'accentColor' }),\n  () => ({ key: 'fontSize' }),\n  () => ({ key: 'fontFamily' }),\n  () => ({ key: 'language' }),\n  () => ({ key: 'iosPwaHelpShown' }),\n  () => ({ key: PRINT_PREFERENCES_STORAGE_KEY }),\n  () => ({ key: TEMPERATURE_UNIT_STORAGE_KEY_NAME }),\n  () => ({ key: getMountVoltageStorageKeyName(), backupKey: getMountVoltageStorageBackupKeyName() }),\n];\n\nfunction createCriticalStorageEntry(candidate, options = {}) {\n  if (!candidate || typeof candidate !== 'object') {\n    return null;\n  }\n\n  const { key, backupKey, storage = null } = candidate;\n  if (typeof key !== 'string' || !key) {\n    return null;\n  }\n\n  const resolvedBackupKey = typeof backupKey === 'string' && backupKey\n    ? backupKey\n    : `${key}${STORAGE_BACKUP_SUFFIX}`;\n\n  return {\n    key,\n    backupKey: resolvedBackupKey,\n    storage,\n    label: typeof options.label === 'string' ? options.label : key,\n    valueProvider: typeof candidate.valueProvider === 'function' ? candidate.valueProvider : null,\n  };\n}\n\nfunction gatherCriticalStorageEntries(options = {}) {\n  const entries = [];\n  const seen = new Set();\n\n  const pushEntry = (entry) => {\n    if (!entry) {\n      return;\n    }\n\n    const variants = getStorageKeyVariants(entry.key);\n    const expectedBaseBackupKey = `${entry.key}${STORAGE_BACKUP_SUFFIX}`;\n\n    for (let index = 0; index < variants.length; index += 1) {\n      const variantKey = variants[index];\n      if (typeof variantKey !== 'string' || !variantKey) {\n        continue;\n      }\n\n      let resolvedBackupKey = entry.backupKey;\n      if (variantKey !== entry.key) {\n        if (entry.backupKey === expectedBaseBackupKey) {\n          resolvedBackupKey = `${variantKey}${STORAGE_BACKUP_SUFFIX}`;\n        }\n      }\n\n      const variantEntry = variantKey === entry.key\n        ? entry\n        : {\n          ...entry,\n          key: variantKey,\n          backupKey: resolvedBackupKey,\n        };\n\n      const storageId = variantEntry.storage || null;\n      const id = `${variantEntry.key}__${storageId ? String(storageId) : 'default'}`;\n      if (seen.has(id)) {\n        continue;\n      }\n\n      seen.add(id);\n      entries.push(variantEntry);\n    }\n  };\n\n  for (let i = 0; i < CRITICAL_BACKUP_KEY_PROVIDERS.length; i += 1) {\n    const provider = CRITICAL_BACKUP_KEY_PROVIDERS[i];\n    if (typeof provider !== 'function') {\n      continue;\n    }\n    let result;\n    try {\n      result = provider(options);\n    } catch (providerError) {\n      var providerDetail = {\n        event: 'critical-storage',\n        action: 'collect-keys',\n        reason: 'provider-error',\n        storageType: getActiveStorageType(options && options.storage ? options.storage : null),\n        error: sanitizeStorageError(providerError),\n      };\n      logStorageEvent(\n        'warn',\n        'Critical storage key provider failed',\n        providerDetail,\n        { event: 'critical-storage', stage: 'gather' },\n        function logProviderErrorToConsole() {\n          if (typeof console !== 'undefined' && typeof console.warn === 'function') {\n            console.warn('Critical storage key provider failed', providerError);\n          }\n        },\n      );\n      continue;\n    }\n    const entry = createCriticalStorageEntry(result, options);\n    if (entry) {\n      pushEntry(entry);\n    }\n  }\n\n  return entries;\n}\n\nlet lastCriticalStorageGuardResult = null;\n\nfunction registerCriticalStorageGuardResult(result) {\n  lastCriticalStorageGuardResult = result;\n  if (!GLOBAL_SCOPE || typeof GLOBAL_SCOPE !== 'object') {\n    return;\n  }\n\n  try {\n    GLOBAL_SCOPE.__cineCriticalStorageGuard = result;\n  } catch (exposeError) {\n    void exposeError;\n    try {\n      Object.defineProperty(GLOBAL_SCOPE, '__cineCriticalStorageGuard', {\n        configurable: true,\n        writable: true,\n        value: result,\n      });\n    } catch (definitionError) {\n      void definitionError;\n    }\n  }\n}\n\nfunction ensureCriticalStorageBackups(options = {}) {\n  let safeStorage = options && options.storage ? options.storage : null;\n  if (!safeStorage) {\n    try {\n      safeStorage = getSafeLocalStorage();\n    } catch (guardError) {\n      var guardDetail = {\n        event: 'critical-storage',\n        action: 'resolve-storage',\n        reason: 'resolve-failed',\n        storageType: getActiveStorageType(options && options.storage ? options.storage : null),\n        error: sanitizeStorageError(guardError),\n      };\n      logStorageEvent(\n        'warn',\n        'Unable to resolve safe storage while ensuring backups',\n        guardDetail,\n        { event: 'critical-storage', stage: 'ensure' },\n        function logGuardErrorToConsole() {\n          if (typeof console !== 'undefined' && typeof console.warn === 'function') {\n            console.warn('Unable to resolve safe storage while ensuring backups', guardError);\n          }\n        },\n      );\n      safeStorage = null;\n    }\n  }\n\n  const summary = {\n    ensured: [],\n    skipped: [],\n    errors: [],\n    timestamp: new Date().toISOString(),\n    storageType: safeLocalStorageInfo && safeLocalStorageInfo.type ? safeLocalStorageInfo.type : 'unknown',\n  };\n\n  const entries = gatherCriticalStorageEntries(options);\n  const targetStorage = safeStorage && typeof safeStorage.getItem === 'function'\n    ? safeStorage\n    : null;\n\n  for (let index = 0; index < entries.length; index += 1) {\n    const entry = entries[index];\n    const storage = entry.storage && typeof entry.storage.getItem === 'function'\n      ? entry.storage\n      : targetStorage;\n\n    if (!storage || typeof storage.getItem !== 'function' || typeof storage.setItem !== 'function') {\n      summary.skipped.push({ key: entry.key, reason: 'unavailable-storage' });\n      continue;\n    }\n\n    let primaryValue;\n    try {\n      if (entry.valueProvider) {\n        primaryValue = entry.valueProvider();\n      } else {\n        primaryValue = storage.getItem(entry.key);\n      }\n    } catch (readError) {\n      summary.errors.push({ key: entry.key, reason: 'read-failed', error: readError });\n      var primaryReadDetail = {\n        event: 'critical-storage',\n        action: 'inspect-primary',\n        key: entry.key,\n        storageType: getActiveStorageType(storage),\n        reason: 'read-failed',\n        error: sanitizeStorageError(readError),\n      };\n      logStorageEvent(\n        'warn',\n        'Critical storage guard could not inspect ' + entry.key,\n        primaryReadDetail,\n        { event: 'critical-storage', stage: 'ensure' },\n        function logPrimaryReadFailureToConsole() {\n          if (typeof console !== 'undefined' && typeof console.warn === 'function') {\n            console.warn('Critical storage guard could not inspect ' + entry.key, readError);\n          }\n        },\n      );\n      continue;\n    }\n\n    if (primaryValue === null || primaryValue === undefined) {\n      summary.skipped.push({ key: entry.key, reason: 'missing' });\n      continue;\n    }\n\n    let backupValue;\n    try {\n      backupValue = storage.getItem(entry.backupKey);\n    } catch (backupReadError) {\n      summary.errors.push({ key: entry.key, reason: 'backup-read-failed', error: backupReadError });\n      var backupReadDetail = {\n        event: 'critical-storage',\n        action: 'inspect-backup',\n        key: entry.key,\n        backupKey: entry.backupKey,\n        storageType: getActiveStorageType(storage),\n        reason: 'backup-read-failed',\n        error: sanitizeStorageError(backupReadError),\n      };\n      logStorageEvent(\n        'warn',\n        'Critical storage guard could not read backup for ' + entry.key,\n        backupReadDetail,\n        { event: 'critical-storage', stage: 'ensure' },\n        function logBackupReadFailureToConsole() {\n          if (typeof console !== 'undefined' && typeof console.warn === 'function') {\n            console.warn('Critical storage guard could not read backup for ' + entry.key, backupReadError);\n          }\n        },\n      );\n      continue;\n    }\n\n    if (typeof backupValue === 'string') {\n      summary.skipped.push({ key: entry.key, reason: 'exists' });\n      continue;\n    }\n\n    const stringPrimaryValue = typeof primaryValue === 'string'\n      ? primaryValue\n      : primaryValue === null || primaryValue === undefined\n        ? ''\n        : String(primaryValue);\n\n    const tryStoreBackup = (candidate) => {\n      try {\n        storage.setItem(entry.backupKey, candidate);\n        return { success: true, error: null };\n      } catch (error) {\n        return { success: false, error };\n      }\n    };\n\n    const recordError = (error, reason = 'backup-write-failed') => {\n      summary.errors.push({ key: entry.key, reason, error });\n      var mirrorDetail = {\n        event: 'critical-storage',\n        action: 'mirror-backup',\n        key: entry.key,\n        backupKey: entry.backupKey,\n        storageType: getActiveStorageType(storage),\n        reason: reason,\n        error: sanitizeStorageError(error),\n      };\n      if (compressionInfo) {\n        mirrorDetail.compressed = true;\n      }\n      logStorageEvent(\n        'error',\n        'Critical storage guard could not mirror ' + entry.key,\n        mirrorDetail,\n        { event: 'critical-storage', stage: 'ensure' },\n        function logMirrorErrorToConsole() {\n          if (typeof console !== 'undefined' && typeof console.error === 'function') {\n            console.error('Critical storage guard could not mirror ' + entry.key, error);\n          }\n        },\n      );\n    };\n\n    const shouldAttemptCompression = typeof stringPrimaryValue === 'string'\n      && stringPrimaryValue\n      && !stringPrimaryValue.includes(`\"${STORAGE_COMPRESSION_FLAG_KEY}\":true`)\n      && !isDeviceStorageKeyVariant(entry.key);\n\n    let candidateValue = stringPrimaryValue;\n    let compressionInfo = null;\n    let writeResult = tryStoreBackup(candidateValue);\n\n    if (!writeResult.success && writeResult.error) {\n      if (!isQuotaExceededError(writeResult.error)) {\n        recordError(writeResult.error);\n        continue;\n      }\n\n      if (shouldAttemptCompression) {\n        const compressedCandidate = createCompressedJsonStorageCandidate(stringPrimaryValue);\n        if (compressedCandidate && typeof compressedCandidate.serialized === 'string' && compressedCandidate.serialized) {\n          candidateValue = compressedCandidate.serialized;\n          compressionInfo = compressedCandidate;\n          writeResult = tryStoreBackup(candidateValue);\n        }\n      }\n\n      if (!writeResult.success && writeResult.error && isQuotaExceededError(writeResult.error)) {\n        const skipKeys = new Set();\n\n        if (typeof entry.backupKey === 'string' && entry.backupKey) {\n          skipKeys.add(entry.backupKey);\n        }\n\n        const shouldInspectPrimaryDuringSweep = shouldAllowCriticalSweepPrimaryInspection(entry.key);\n        if (!shouldInspectPrimaryDuringSweep && typeof entry.key === 'string' && entry.key) {\n          skipKeys.add(entry.key);\n        }\n\n        if (!shouldInspectPrimaryDuringSweep && !ACTIVE_PROJECT_COMPRESSION_HOLD_ENABLED) {\n          inspectSetupStorageForQuotaRecovery(storage, skipKeys);\n        }\n\n        const sweepResult = attemptStorageCompressionSweep(storage, { skipKeys: Array.from(skipKeys) });\n        if (sweepResult && sweepResult.success) {\n          writeResult = tryStoreBackup(candidateValue);\n        }\n      }\n\n      if (!writeResult.success) {\n        recordError(writeResult.error, isQuotaExceededError(writeResult.error) ? 'backup-quota-exceeded' : 'backup-write-failed');\n        if (isQuotaExceededError(writeResult.error)) {\n          alertStorageError('critical-backup-quota');\n        }\n        continue;\n      }\n    }\n\n    summary.ensured.push({\n      key: entry.key,\n      backupKey: entry.backupKey,\n      compressed: Boolean(compressionInfo),\n    });\n\n    if (\n      compressionInfo\n      && typeof compressionInfo.originalLength === 'number'\n      && typeof compressionInfo.wrappedLength === 'number'\n    ) {\n      const savings = compressionInfo.originalLength - compressionInfo.wrappedLength;\n      const percent = compressionInfo.originalLength > 0\n        ? Math.round((savings / compressionInfo.originalLength) * 100)\n        : 0;\n      const message = `Stored compressed critical backup for ${entry.key}, reducing storage usage by ${savings} characters (${percent}%).`;\n      logCompressionSavingsEvent('critical-backup', entry.key, message, savings, percent);\n    }\n  }\n\n  registerCriticalStorageGuardResult(summary);\n\n  if (summary.ensured.length) {\n    var ensuredDetail = {\n      event: 'critical-storage',\n      action: 'mirror-summary',\n      storageType: summary.storageType || getActiveStorageType(),\n      count: summary.ensured.length,\n      timestamp: summary.timestamp,\n      entries: summary.ensured.map(function mapEnsured(entry) {\n        return {\n          key: entry.key,\n          backupKey: entry.backupKey,\n          compressed: Boolean(entry.compressed),\n        };\n      }),\n    };\n    logStorageEvent(\n      'info',\n      'Critical storage guard mirrored backup copies',\n      ensuredDetail,\n      { event: 'critical-storage', stage: 'ensure' },\n      function logEnsuredSummaryToConsole() {\n        if (typeof console !== 'undefined' && typeof console.info === 'function') {\n          const mirroredDetails = summary.ensured.map((entry) => ({\n            key: entry.key,\n            backupKey: entry.backupKey,\n          }));\n          console.info('Critical storage guard mirrored backup copies', {\n            count: summary.ensured.length,\n            entries: mirroredDetails,\n          });\n        }\n      },\n    );\n  }\n\n  if (summary.errors.length) {\n    var errorDetail = {\n      event: 'critical-storage',\n      action: 'mirror-summary',\n      storageType: summary.storageType || getActiveStorageType(),\n      count: summary.errors.length,\n      timestamp: summary.timestamp,\n      reason: 'errors-detected',\n      entries: summary.errors.map(function mapErrors(entry) {\n        return {\n          key: entry && entry.key,\n          reason: entry && entry.reason,\n          error: sanitizeStorageError(entry && entry.error),\n        };\n      }),\n    };\n    logStorageEvent(\n      'warn',\n      'Critical storage guard encountered issues',\n      errorDetail,\n      { event: 'critical-storage', stage: 'ensure' },\n      function logErrorSummaryToConsole() {\n        if (typeof console !== 'undefined' && typeof console.warn === 'function') {\n          console.warn('Critical storage guard encountered issues', summary.errors);\n        }\n      },\n    );\n  }\n\n  return summary;\n}\n\nfunction getLastCriticalStorageGuardResult() {\n  return lastCriticalStorageGuardResult;\n}\n\nvar MAX_MIGRATION_BACKUP_CLEANUP_STEPS = 10;\nvar MIGRATION_BACKUP_COMPRESSION_ALGORITHM = 'lz-string';\nvar MIGRATION_BACKUP_COMPRESSION_ENCODING = 'json-string';\nvar MIGRATION_BACKUP_COMPRESSION_VARIANTS = [\n  { variant: 'utf16', compress: 'compressToUTF16', decompress: 'decompressFromUTF16' },\n  { variant: 'uri-component', compress: 'compressToEncodedURIComponent', decompress: 'decompressFromEncodedURIComponent' },\n  { variant: 'base64', compress: 'compressToBase64', decompress: 'decompressFromBase64' },\n];\n\nvar STORAGE_COMPRESSION_FLAG_KEY = '__cineStorageCompressed';\nvar STORAGE_COMPRESSION_VERSION = 1;\nvar STORAGE_COMPRESSION_ALGORITHM = 'lz-string';\nvar LEGACY_STORAGE_COMPRESSION_ALGORITHM = 'lz-string-utf16';\nvar STORAGE_COMPRESSION_VARIANTS = MIGRATION_BACKUP_COMPRESSION_VARIANTS;\nvar STORAGE_COMPRESSION_NAMESPACE = 'camera-power-planner:storage-compression';\nvar STORAGE_COMPRESSION_ALGORITHM_LITERAL =\n  typeof JSON !== 'undefined' && JSON && typeof JSON.stringify === 'function'\n    ? JSON.stringify(STORAGE_COMPRESSION_ALGORITHM)\n    : '\"'.concat(String(STORAGE_COMPRESSION_ALGORITHM || ''), '\"');\nvar STORAGE_COMPRESSION_NAMESPACE_LITERAL =\n  typeof JSON !== 'undefined' && JSON && typeof JSON.stringify === 'function'\n    ? JSON.stringify(STORAGE_COMPRESSION_NAMESPACE)\n    : '\"'.concat(String(STORAGE_COMPRESSION_NAMESPACE || ''), '\"');\nvar STORAGE_COMPRESSION_WRAPPER_BASE_LENGTH = computeStorageCompressionWrapperBaseLength();\nvar storageCompressionPatchedStorages = typeof WeakSet === 'function' ? new WeakSet() : null;\nvar STORAGE_COMPRESSION_SWEEP_LIMIT = 40;\nvar STORAGE_COMPRESSION_SWEEP_MIN_SAVINGS = 128;\nvar STORAGE_RAW_GET_ITEM_PROPERTY = '__cineRawGetItem';\nvar STORAGE_PROACTIVE_COMPRESSION_MIN_LENGTH = 1024;\nvar STORAGE_PROACTIVE_COMPRESSION_MIN_SAVINGS = 256;\nvar STORAGE_PROACTIVE_COMPRESSION_MIN_RATIO = 0.08;\n\nfunction getAvailableLZStringCompressionStrategies(variants) {\n  if (!Array.isArray(variants) || !variants.length) {\n    return [];\n  }\n\n  var lzReference = LZString;\n  if (!lzReference) {\n    return [];\n  }\n\n  var cacheKey = getCompressionStrategyCacheKey(variants);\n  var cachedStrategies = readCompressionStrategyCache(cacheKey, lzReference);\n  if (cachedStrategies !== null && cachedStrategies !== undefined) {\n    return cachedStrategies;\n  }\n\n  var available = [];\n  for (var i = 0; i < variants.length; i += 1) {\n    var variant = variants[i];\n    if (!variant) {\n      continue;\n    }\n\n    var compressFn = typeof lzReference[variant.compress] === 'function'\n      ? lzReference[variant.compress]\n      : null;\n    var decompressFn = typeof lzReference[variant.decompress] === 'function'\n      ? lzReference[variant.decompress]\n      : null;\n    var variantLiteral = null;\n    var variantLiteralLength = 0;\n    if (typeof JSON !== 'undefined' && JSON && typeof JSON.stringify === 'function') {\n      try {\n        variantLiteral = JSON.stringify(String(variant.variant || ''));\n        if (typeof variantLiteral === 'string' && variantLiteral) {\n          variantLiteralLength = variantLiteral.length;\n        } else {\n          variantLiteral = null;\n          variantLiteralLength = 0;\n        }\n      } catch (variantLiteralError) {\n        variantLiteral = null;\n        variantLiteralLength = 0;\n        void variantLiteralError;\n      }\n    }\n\n    if (compressFn && decompressFn) {\n      available.push({\n        variant: variant.variant,\n        compress: compressFn,\n        decompress: decompressFn,\n        variantLiteral: variantLiteralLength > 0 ? variantLiteral : null,\n        variantLiteralLength,\n      });\n    }\n  }\n\n  var result = available.length ? available.slice() : [];\n\n  if (cacheKey) {\n    writeCompressionStrategyCache(cacheKey, lzReference, result);\n  }\n\n  return result;\n}\n\nfunction tryDecompressWithStrategies(data, variants, preferredVariant, contextLabel) {\n  if (typeof data !== 'string' || !data) {\n    return { success: false };\n  }\n\n  var available = getAvailableLZStringCompressionStrategies(variants);\n  if (!available.length) {\n    return { success: false };\n  }\n\n  var attempts = [];\n  if (preferredVariant) {\n    var preferred = null;\n    for (var i = 0; i < available.length; i += 1) {\n      if (available[i].variant === preferredVariant) {\n        preferred = available[i];\n        break;\n      }\n    }\n    if (preferred) {\n      attempts.push(preferred);\n    } else if (typeof console !== 'undefined' && typeof console.warn === 'function') {\n      console.warn(\"Compression variant \"\n        .concat(preferredVariant, \" is unavailable while reading \"\n        ).concat(contextLabel || 'compressed payload', \".\"));\n    }\n  }\n\n  for (var j = 0; j < available.length; j += 1) {\n    if (!preferredVariant || available[j].variant !== preferredVariant) {\n      attempts.push(available[j]);\n    }\n  }\n\n  var lastError = null;\n  for (var k = 0; k < attempts.length; k += 1) {\n    var strategy = attempts[k];\n    try {\n      var decompressed = strategy.decompress(data);\n      if (typeof decompressed === 'string' && decompressed) {\n        return { success: true, value: decompressed, variant: strategy.variant };\n      }\n    } catch (error) {\n      lastError = error;\n      if (typeof console !== 'undefined' && typeof console.warn === 'function') {\n        console.warn(\"Unable to decompress \"\n          .concat(contextLabel || 'compressed payload', \" with \")\n          .concat(strategy.variant, \" variant\"), error);\n      }\n    }\n  }\n\n  return { success: false, error: lastError };\n}\n\nfunction canUseMigrationBackupCompression() {\n  return getAvailableLZStringCompressionStrategies(MIGRATION_BACKUP_COMPRESSION_VARIANTS).length > 0;\n}\n\nfunction tryCreateCompressedMigrationBackupCandidate(serializedPayload, createdAt) {\n  if (typeof serializedPayload !== 'string' || !serializedPayload) {\n    return null;\n  }\n  if (!canUseMigrationBackupCompression()) {\n    return null;\n  }\n\n  var cached = readCompressionCandidateCacheEntry(\n    MIGRATION_BACKUP_COMPRESSION_CANDIDATE_CACHE,\n    serializedPayload,\n  );\n  if (cached.hit) {\n    return cached.candidate;\n  }\n\n  var bestCandidate = null;\n  var strategies = getAvailableLZStringCompressionStrategies(MIGRATION_BACKUP_COMPRESSION_VARIANTS);\n\n  if (!strategies.length) {\n    return null;\n  }\n\n  for (var i = 0; i < strategies.length; i += 1) {\n    var strategy = strategies[i];\n    var compressed = null;\n    try {\n      compressed = strategy.compress(serializedPayload);\n    } catch (compressionError) {\n      console.warn(\"Unable to compress migration backup payload with \"\n        .concat(strategy.variant, \" variant\"), compressionError);\n      continue;\n    }\n\n    if (typeof compressed !== 'string' || !compressed || compressed.length >= serializedPayload.length) {\n      continue;\n    }\n\n    var record = {\n      createdAt: createdAt,\n      compression: MIGRATION_BACKUP_COMPRESSION_ALGORITHM,\n      compressionVariant: strategy.variant,\n      encoding: MIGRATION_BACKUP_COMPRESSION_ENCODING,\n      data: compressed,\n      originalSize: serializedPayload.length,\n      compressedSize: compressed.length,\n    };\n\n    var serializedCompressedPayload;\n    try {\n      serializedCompressedPayload = JSON.stringify(record);\n    } catch (serializationError) {\n      console.warn('Unable to serialize compressed migration backup payload', serializationError);\n      continue;\n    }\n\n    if (typeof serializedCompressedPayload !== 'string' || !serializedCompressedPayload) {\n      continue;\n    }\n\n    if (serializedCompressedPayload.length >= serializedPayload.length) {\n      continue;\n    }\n\n    if (!bestCandidate || serializedCompressedPayload.length < bestCandidate.serializedLength) {\n      bestCandidate = {\n        serialized: serializedCompressedPayload,\n        serializedLength: serializedCompressedPayload.length,\n        originalSize: serializedPayload.length,\n        compressedSize: compressed.length,\n        variant: strategy.variant,\n      };\n    }\n  }\n\n  writeCompressionCandidateCacheEntry(\n    MIGRATION_BACKUP_COMPRESSION_CANDIDATE_CACHE,\n    serializedPayload,\n    bestCandidate,\n  );\n\n  return bestCandidate;\n}\n\nfunction parseMigrationBackupMetadata(raw) {\n  if (typeof raw !== 'string' || !raw) {\n    return { createdAt: 0, size: typeof raw === 'string' ? raw.length : 0 };\n  }\n\n  const metadata = { createdAt: 0, size: raw.length };\n\n  try {\n    const parsed = JSON.parse(raw);\n    if (parsed && typeof parsed === 'object') {\n      let candidate = null;\n      if (typeof parsed.createdAt === 'string') {\n        candidate = parsed.createdAt.trim();\n      } else if (\n        typeof parsed.createdAt === 'number'\n        && Number.isFinite(parsed.createdAt)\n      ) {\n        metadata.createdAt = parsed.createdAt;\n      }\n\n      if (candidate) {\n        const timestamp = Date.parse(candidate);\n        if (!Number.isNaN(timestamp)) {\n          metadata.createdAt = timestamp;\n        }\n      } else {\n        for (let i = 0; i < MIGRATION_BACKUP_LEGACY_CREATED_AT_KEYS.length; i += 1) {\n          const key = MIGRATION_BACKUP_LEGACY_CREATED_AT_KEYS[i];\n          if (typeof parsed[key] === 'string') {\n            const trimmed = parsed[key].trim();\n            if (trimmed) {\n              const timestamp = Date.parse(trimmed);\n              if (!Number.isNaN(timestamp)) {\n                metadata.createdAt = timestamp;\n                break;\n              }\n            }\n          } else if (\n            typeof parsed[key] === 'number'\n            && Number.isFinite(parsed[key])\n          ) {\n            metadata.createdAt = parsed[key];\n            break;\n          }\n        }\n      }\n    }\n  } catch (error) {\n    void error;\n  }\n\n  return metadata;\n}\n\nfunction canUseJsonValueCompression() {\n  return canUseMigrationBackupCompression();\n}\n\nfunction createCompressedJsonStorageCandidate(serialized) {\n  if (typeof serialized !== 'string' || !serialized) {\n    return null;\n  }\n  if (!canUseJsonValueCompression()) {\n    return null;\n  }\n\n  var cached = readCompressionCandidateCacheEntry(STORAGE_COMPRESSION_CANDIDATE_CACHE, serialized);\n  if (cached.hit) {\n    return cached.candidate;\n  }\n\n  var strategies = getAvailableLZStringCompressionStrategies(STORAGE_COMPRESSION_VARIANTS);\n  if (!strategies.length) {\n    return null;\n  }\n\n  var baseWrapperLength =\n    typeof STORAGE_COMPRESSION_WRAPPER_BASE_LENGTH === 'number'\n      ? STORAGE_COMPRESSION_WRAPPER_BASE_LENGTH\n      : 0;\n  var best = null;\n  var bestSerialized = null;\n  var bestCompressedLiteral = null;\n  var bestVariantLiteral = null;\n  var originalLengthDigits = String(serialized.length).length;\n  for (var i = 0; i < strategies.length; i += 1) {\n    var strategy = strategies[i];\n    var compressed = null;\n    try {\n      compressed = strategy.compress(serialized);\n    } catch (compressionError) {\n      console.warn('Unable to compress storage payload with '\n        .concat(strategy.variant, ' variant'), compressionError);\n      continue;\n    }\n\n    if (typeof compressed !== 'string' || !compressed) {\n      continue;\n    }\n\n    var compressedLiteral;\n    try {\n      compressedLiteral = JSON.stringify(compressed);\n    } catch (compressedLiteralError) {\n      console.warn(\n        'Unable to serialize compressed storage payload candidate',\n        compressedLiteralError,\n      );\n      continue;\n    }\n\n    if (typeof compressedLiteral !== 'string' || !compressedLiteral) {\n      continue;\n    }\n\n    var variantLiteral =\n      typeof strategy.variantLiteral === 'string' && strategy.variantLiteral\n        ? strategy.variantLiteral\n        : null;\n    var variantLiteralLength =\n      typeof strategy.variantLiteralLength === 'number' && strategy.variantLiteralLength > 0\n        ? strategy.variantLiteralLength\n        : 0;\n    if (!variantLiteral) {\n      if (typeof JSON !== 'undefined' && JSON && typeof JSON.stringify === 'function') {\n        try {\n          variantLiteral = JSON.stringify(String(strategy.variant || ''));\n          variantLiteralLength =\n            typeof variantLiteral === 'string' && variantLiteral ? variantLiteral.length : 0;\n        } catch (variantLiteralError) {\n          variantLiteral = null;\n          variantLiteralLength = 0;\n          void variantLiteralError;\n        }\n      }\n    }\n\n    var candidateSerialized = null;\n    var candidateLength = Number.POSITIVE_INFINITY;\n\n    if (baseWrapperLength > 0 && variantLiteralLength > 0) {\n      var compressedLengthDigits = String(compressed.length).length;\n      candidateLength =\n        baseWrapperLength\n        + compressedLiteral.length\n        + originalLengthDigits\n        + compressedLengthDigits\n        + variantLiteralLength;\n    } else {\n      var legacyWrapper = {\n        [STORAGE_COMPRESSION_FLAG_KEY]: true,\n        version: STORAGE_COMPRESSION_VERSION,\n        algorithm: STORAGE_COMPRESSION_ALGORITHM,\n        namespace: STORAGE_COMPRESSION_NAMESPACE,\n        data: compressed,\n        originalLength: serialized.length,\n        compressedPayloadLength: compressed.length,\n        compressionVariant: strategy.variant,\n      };\n\n      try {\n        candidateSerialized = JSON.stringify(legacyWrapper);\n      } catch (serializationError) {\n        console.warn('Unable to serialize compressed storage payload wrapper', serializationError);\n        continue;\n      }\n\n      if (typeof candidateSerialized !== 'string' || !candidateSerialized) {\n        continue;\n      }\n\n      candidateLength = candidateSerialized.length;\n    }\n\n    if (!(candidateLength < serialized.length)) {\n      continue;\n    }\n\n    if (!best || candidateLength < best.wrappedLength) {\n      best = {\n        originalLength: serialized.length,\n        wrappedLength: candidateLength,\n        compressedPayloadLength: compressed.length,\n        compressionVariant: strategy.variant,\n      };\n      bestSerialized = candidateSerialized;\n      bestCompressedLiteral = compressedLiteral;\n      bestVariantLiteral = variantLiteral;\n    }\n  }\n\n  if (best && (!bestSerialized || typeof bestSerialized !== 'string')) {\n    if (typeof bestCompressedLiteral !== 'string' || !bestCompressedLiteral) {\n      best = null;\n    } else {\n      var finalVariantLiteral;\n      if (typeof bestVariantLiteral === 'string' && bestVariantLiteral) {\n        finalVariantLiteral = bestVariantLiteral;\n      } else if (typeof JSON !== 'undefined' && JSON && typeof JSON.stringify === 'function') {\n        try {\n          finalVariantLiteral = JSON.stringify(String(best.compressionVariant || ''));\n        } catch (variantLiteralError) {\n          finalVariantLiteral = null;\n          void variantLiteralError;\n        }\n      }\n\n      if (typeof finalVariantLiteral !== 'string' || !finalVariantLiteral) {\n        best = null;\n      } else {\n        var serializedWrapper =\n          '{\"'\n            .concat(STORAGE_COMPRESSION_FLAG_KEY, '\":true,\"version\":')\n            .concat(String(STORAGE_COMPRESSION_VERSION), ',\"algorithm\":')\n            .concat(STORAGE_COMPRESSION_ALGORITHM_LITERAL, ',\"namespace\":')\n            .concat(STORAGE_COMPRESSION_NAMESPACE_LITERAL, ',\"data\":')\n            .concat(bestCompressedLiteral, ',\"originalLength\":')\n            .concat(String(best.originalLength), ',\"compressedPayloadLength\":')\n            .concat(String(best.compressedPayloadLength), ',\"compressionVariant\":')\n            .concat(finalVariantLiteral, '}');\n\n        bestSerialized = serializedWrapper;\n      }\n    }\n  }\n\n  if (\n    best\n    && bestSerialized\n    && typeof bestSerialized === 'string'\n    && bestSerialized.length < best.originalLength\n  ) {\n    best.serialized = bestSerialized;\n    best.wrappedLength = bestSerialized.length;\n  } else {\n    best = null;\n  }\n\n  writeCompressionCandidateCacheEntry(STORAGE_COMPRESSION_CANDIDATE_CACHE, serialized, best);\n\n  return best;\n}\n\nfunction decodeCompressedJsonStorageValue(raw) {\n  if (typeof raw !== 'string') {\n    return { success: false };\n  }\n\n  if (!raw || raw.charCodeAt(0) !== 123) {\n    return { success: false };\n  }\n\n  if (\n    !raw.includes(`\"${STORAGE_COMPRESSION_FLAG_KEY}\":true`)\n    || !raw.includes(`\"namespace\":\"${STORAGE_COMPRESSION_NAMESPACE}`)\n  ) {\n    return { success: false };\n  }\n\n  let parsed;\n  try {\n    parsed = JSON.parse(raw);\n  } catch (parseError) {\n    return { success: false, error: parseError };\n  }\n\n  if (!parsed || parsed[STORAGE_COMPRESSION_FLAG_KEY] !== true) {\n    return { success: false };\n  }\n\n  if (parsed.namespace !== STORAGE_COMPRESSION_NAMESPACE) {\n    return { success: false };\n  }\n\n  if (parsed.version !== STORAGE_COMPRESSION_VERSION) {\n    console.warn('Unsupported storage compression version', parsed.version);\n    return { success: false };\n  }\n\n  if (\n    parsed.algorithm !== STORAGE_COMPRESSION_ALGORITHM\n    && parsed.algorithm !== LEGACY_STORAGE_COMPRESSION_ALGORITHM\n  ) {\n    console.warn('Unsupported storage compression algorithm', parsed.algorithm);\n    return { success: false };\n  }\n\n  if (typeof parsed.data !== 'string' || !parsed.data) {\n    return { success: false };\n  }\n\n  if (!canUseJsonValueCompression()) {\n    console.warn('Compressed storage payload detected but compression library is unavailable.');\n    return { success: false };\n  }\n\n  var preferredVariant = null;\n  if (typeof parsed.compressionVariant === 'string' && parsed.compressionVariant) {\n    preferredVariant = parsed.compressionVariant;\n  } else if (parsed.algorithm === LEGACY_STORAGE_COMPRESSION_ALGORITHM) {\n    preferredVariant = 'utf16';\n  }\n\n  var decoded = tryDecompressWithStrategies(parsed.data, STORAGE_COMPRESSION_VARIANTS, preferredVariant, 'storage payload');\n  if (!decoded.success) {\n    return { success: false, error: decoded.error };\n  }\n\n  if (!parsed.compressionVariant && decoded.variant) {\n    parsed.compressionVariant = decoded.variant;\n  }\n\n  return { success: true, value: decoded.value, metadata: parsed };\n}\n\nfunction restoreCompressedProjectEntry(value, contextName) {\n  if (typeof value === 'string') {\n    const decoded = decodeCompressedJsonStorageValue(value);\n    if (!decoded.success || typeof decoded.value !== 'string') {\n      return { restored: false, value };\n    }\n\n    try {\n      return { restored: true, value: JSON.parse(decoded.value) };\n    } catch (parseError) {\n      console.warn(\n        'Unable to parse decompressed project entry payload',\n        contextName || 'project entry',\n        parseError,\n      );\n      return { restored: false, value };\n    }\n  }\n\n  if (isPlainObject(value) && value[STORAGE_COMPRESSION_FLAG_KEY] === true) {\n    let serialized;\n    try {\n      serialized = JSON.stringify(value);\n    } catch (serializationError) {\n      console.warn(\n        'Unable to reserialize compressed project entry wrapper before restoration',\n        contextName || 'project entry',\n        serializationError,\n      );\n      return { restored: false, value };\n    }\n\n    if (typeof serialized === 'string' && serialized) {\n      return restoreCompressedProjectEntry(serialized, contextName);\n    }\n  }\n\n  return { restored: false, value };\n}\n\nfunction markProjectActivity(name, timestamp) {\n  if (typeof name !== 'string') {\n    return;\n  }\n\n  const recordTime = typeof timestamp === 'number' && Number.isFinite(timestamp)\n    ? timestamp\n    : Date.now();\n\n  const normalized = normalizeProjectStorageKey(name);\n  if (normalized) {\n    projectActivityTimestamps.set(normalized, recordTime);\n    if (normalized !== name) {\n      projectActivityTimestamps.set(name, recordTime);\n    }\n    return;\n  }\n\n  projectActivityTimestamps.set(name, recordTime);\n}\n\nfunction markProjectCollectionActivity(projects, timestamp) {\n  if (!projects || typeof projects !== 'object') {\n    return;\n  }\n\n  const recordTime = typeof timestamp === 'number' && Number.isFinite(timestamp)\n    ? timestamp\n    : Date.now();\n\n  Object.keys(projects).forEach((key) => {\n    if (typeof key !== 'string' || !key || isAutoBackupStorageKey(key)) {\n      return;\n    }\n\n    markProjectActivity(key, recordTime);\n  });\n}\n\nfunction removeProjectActivity(name) {\n  if (typeof name !== 'string') {\n    return;\n  }\n\n  const normalized = normalizeProjectStorageKey(name);\n  projectActivityTimestamps.delete(name);\n  if (normalized && normalized !== name) {\n    projectActivityTimestamps.delete(normalized);\n  }\n}\n\n\n\n\n\nfunction normalizeForcedProjectCompressionKey(name) {\n  if (typeof name !== 'string') {\n    return '';\n  }\n\n  const normalized = normalizeProjectStorageKey(name);\n  return typeof normalized === 'string' && normalized ? normalized : '';\n}\n\nfunction isForcedProjectCompressionLocked(name) {\n  if (!forcedCompressedProjectKeys || typeof forcedCompressedProjectKeys.has !== 'function') {\n    return false;\n  }\n\n  const normalized = normalizeForcedProjectCompressionKey(name);\n  if (!normalized) {\n    return false;\n  }\n\n  try {\n    return forcedCompressedProjectKeys.has(normalized);\n  } catch (error) {\n    void error;\n  }\n\n  return false;\n}\n\n\n\n\n\nfunction ensureProjectEntryUncompressed(value, contextName) {\n  const restored = restoreCompressedProjectEntry(value, contextName);\n  if (restored.restored) {\n    return restored.value;\n  }\n  return value;\n}\n\nfunction ensureProjectEntriesUncompressed(container) {\n  if (!isPlainObject(container)) {\n    return container;\n  }\n\n  Object.keys(container).forEach((key) => {\n    container[key] = ensureProjectEntryUncompressed(container[key], key);\n  });\n\n  return container;\n}\n\n\n\n\n\nfunction registerActiveSetupStorageSkipKeys(skipSet) {\n  if (!skipSet || typeof skipSet.add !== 'function') {\n    return;\n  }\n\n  const keysToSkip = [\n    PROJECT_STORAGE_KEY,\n    `${PROJECT_STORAGE_KEY}${STORAGE_BACKUP_SUFFIX}`,\n    SETUP_STORAGE_KEY,\n    `${SETUP_STORAGE_KEY}${STORAGE_BACKUP_SUFFIX}`,\n  ];\n\n  for (let i = 0; i < keysToSkip.length; i += 1) {\n    const key = keysToSkip[i];\n    if (typeof key === 'string' && key) {\n      skipSet.add(key);\n    }\n  }\n}\n\nfunction registerProtectedCompressionSkipKeys(skipSet) {\n  if (!skipSet || typeof skipSet.add !== 'function') {\n    return;\n  }\n\n  const keysToProtect = [\n    CONTACTS_STORAGE_KEY,\n    OWN_GEAR_STORAGE_KEY,\n    USER_PROFILE_STORAGE_KEY,\n    DEVICE_STORAGE_KEY,\n  ];\n\n  for (let index = 0; index < keysToProtect.length; index += 1) {\n    const key = keysToProtect[index];\n    if (typeof key !== 'string' || !key) {\n      continue;\n    }\n\n    const variants = getStorageKeyVariants(key);\n    for (let variantIndex = 0; variantIndex < variants.length; variantIndex += 1) {\n      const variant = variants[variantIndex];\n      if (typeof variant !== 'string' || !variant) {\n        continue;\n      }\n\n      skipSet.add(variant);\n\n      if (typeof STORAGE_BACKUP_SUFFIX === 'string' && STORAGE_BACKUP_SUFFIX) {\n        skipSet.add(`${variant}${STORAGE_BACKUP_SUFFIX}`);\n      }\n    }\n  }\n}\n\nfunction maybeDecompressStoredString(raw, options) {\n  if (typeof raw !== 'string') {\n    return raw;\n  }\n\n  const decoded = decodeCompressedJsonStorageValue(raw);\n  if (!decoded.success) {\n    return raw;\n  }\n\n  if (options && typeof options.onDecoded === 'function') {\n    try {\n      options.onDecoded(decoded);\n    } catch (callbackError) {\n      console.warn('Error while processing storage decompression callback', callbackError);\n    }\n  }\n\n  return decoded.value;\n}\n\nfunction attemptStorageCompressionSweep(storage, options) {\n  if (\n    !storage\n    || typeof storage.length !== 'number'\n    || typeof storage.key !== 'function'\n  ) {\n    return { success: false, compressed: 0, freed: 0 };\n  }\n\n  if (isSessionStorageInstance(storage)) {\n    // Session storage entries are intentionally left uncompressed to prioritize\n    // short-lived data integrity over quota recoveries. Compressing them risks\n    // losing user context during transient errors, so skip sweeps entirely.\n    return { success: false, compressed: 0, freed: 0 };\n  }\n\n  const { skipKeys = [], limit = STORAGE_COMPRESSION_SWEEP_LIMIT, minSavings = STORAGE_COMPRESSION_SWEEP_MIN_SAVINGS } = options || {};\n\n  const skipSet = new Set();\n  if (ACTIVE_PROJECT_COMPRESSION_HOLD_ENABLED && ACTIVE_PROJECT_COMPRESSION_HOLD_KEY) {\n    skipSet.add(ACTIVE_PROJECT_COMPRESSION_HOLD_KEY);\n  }\n  if (ACTIVE_PROJECT_COMPRESSION_HOLD_ENABLED) {\n    registerActiveSetupStorageSkipKeys(skipSet);\n  }\n  registerProtectedCompressionSkipKeys(skipSet);\n  if (Array.isArray(skipKeys)) {\n    for (let i = 0; i < skipKeys.length; i += 1) {\n      const key = skipKeys[i];\n      if (typeof key === 'string' && key) {\n        skipSet.add(key);\n      }\n    }\n  }\n\n  const minSavingsThreshold = typeof minSavings === 'number' && minSavings > 0 ? minSavings : 0;\n  const total = storage.length;\n  const candidates = [];\n\n  for (let index = 0; index < total; index += 1) {\n    let key;\n    try {\n      key = storage.key(index);\n    } catch (keyError) {\n      void keyError;\n      key = null;\n    }\n\n    if (typeof key !== 'string' || !key || skipSet.has(key)) {\n      continue;\n    }\n\n    let raw;\n    try {\n      raw = storage.getItem(key);\n    } catch (readError) {\n      void readError;\n      continue;\n    }\n\n    if (typeof raw !== 'string' || !raw) {\n      continue;\n    }\n\n    if (raw.includes(`\"${STORAGE_COMPRESSION_FLAG_KEY}\":true`)) {\n      continue;\n    }\n\n    const candidate = createCompressedJsonStorageCandidate(raw);\n    if (!candidate || typeof candidate.serialized !== 'string' || !candidate.serialized) {\n      continue;\n    }\n\n    const savings = typeof candidate.originalLength === 'number' && typeof candidate.wrappedLength === 'number'\n      ? candidate.originalLength - candidate.wrappedLength\n      : 0;\n    if (savings < minSavingsThreshold) {\n      continue;\n    }\n\n    candidates.push({\n      key,\n      serialized: candidate.serialized,\n      savings: savings > 0 ? savings : 0,\n      originalLength: typeof candidate.originalLength === 'number' ? candidate.originalLength : 0,\n    });\n  }\n\n  if (!candidates.length) {\n    return { success: false, compressed: 0, freed: 0 };\n  }\n\n  candidates.sort((a, b) => {\n    if (b.savings !== a.savings) {\n      return b.savings - a.savings;\n    }\n    return b.originalLength - a.originalLength;\n  });\n\n  const upperLimit = typeof limit === 'number' && limit > 0 ? Math.min(limit, candidates.length) : candidates.length;\n\n  let compressedCount = 0;\n  let freedCharacters = 0;\n\n  for (let index = 0; index < candidates.length && compressedCount < upperLimit; index += 1) {\n    const entry = candidates[index];\n    if (!entry || typeof entry.serialized !== 'string' || !entry.serialized) {\n      continue;\n    }\n\n    try {\n      storage.setItem(entry.key, entry.serialized);\n      compressedCount += 1;\n      freedCharacters += entry.savings;\n    } catch (writeError) {\n      void writeError;\n    }\n  }\n\n  if (compressedCount === 0) {\n    return { success: false, compressed: 0, freed: 0 };\n  }\n\n  if (typeof console !== 'undefined' && typeof console.warn === 'function') {\n    if (freedCharacters > 0) {\n      console.warn(\n        `Compressed ${compressedCount} stored entr${compressedCount === 1 ? 'y' : 'ies'} during quota recovery, freeing approximately ${freedCharacters} characters.`,\n      );\n    } else {\n      console.warn(`Compressed ${compressedCount} stored entr${compressedCount === 1 ? 'y' : 'ies'} during quota recovery.`);\n    }\n  }\n\n  return { success: true, compressed: compressedCount, freed: freedCharacters };\n}\n\nfunction decodeStoredValue(raw) {\n  if (raw === null || raw === undefined) {\n    return raw;\n  }\n  return maybeDecompressStoredString(raw);\n}\n\nfunction patchIndividualStorageGetItem(storage) {\n  if (!storage || typeof storage.getItem !== 'function') {\n    return;\n  }\n\n  if (\n    storageCompressionPatchedStorages\n    && typeof storageCompressionPatchedStorages.has === 'function'\n    && storageCompressionPatchedStorages.has(storage)\n  ) {\n    return;\n  }\n\n  const originalGetItem = storage.getItem;\n  const rawGetItem = typeof originalGetItem === 'function'\n    ? function rawStorageGetItem(key) {\n      return originalGetItem.call(this, key);\n    }\n    : null;\n  const patchedGetItem = function patchedStorageGetItem(key) {\n    const rawValue = rawGetItem ? rawGetItem.call(this, key) : undefined;\n    return maybeDecompressStoredString(rawValue);\n  };\n\n  try {\n    Object.defineProperty(storage, 'getItem', {\n      configurable: true,\n      writable: true,\n      value: patchedGetItem,\n    });\n  } catch (defineError) {\n    const suppressDefineWarning =\n      defineError\n      && typeof defineError.message === 'string'\n      && defineError.message.includes('Cannot redefine property');\n    if (!suppressDefineWarning) {\n      console.warn('Unable to redefine storage.getItem descriptor for compression support', defineError);\n    }\n    try {\n      storage.getItem = patchedGetItem;\n    } catch (assignError) {\n      const suppressAssignWarning =\n        assignError\n        && typeof assignError.message === 'string'\n        && assignError.message.includes('Cannot assign to read only property');\n      if (!suppressAssignWarning) {\n        console.warn('Unable to patch storage instance getItem for compression support', assignError);\n      }\n      if (suppressDefineWarning && suppressAssignWarning) {\n        return;\n      }\n      if (!suppressDefineWarning && !suppressAssignWarning) {\n        return;\n      }\n      return;\n    }\n  }\n\n  if (rawGetItem) {\n    try {\n      Object.defineProperty(storage, STORAGE_RAW_GET_ITEM_PROPERTY, {\n        configurable: true,\n        writable: true,\n        value: rawGetItem,\n      });\n    } catch (rawAssignError) {\n      try {\n        storage[STORAGE_RAW_GET_ITEM_PROPERTY] = rawGetItem;\n      } catch (rawStoreError) {\n        void rawStoreError;\n      }\n      void rawAssignError;\n    }\n  }\n\n  if (\n    storageCompressionPatchedStorages\n    && typeof storageCompressionPatchedStorages.add === 'function'\n  ) {\n    try {\n      storageCompressionPatchedStorages.add(storage);\n    } catch (trackError) {\n      void trackError;\n    }\n  }\n}\n\nfunction patchStorageGetItemForCompression() {\n  if (typeof Storage === 'undefined') {\n    const candidates = [];\n    if (GLOBAL_SCOPE && typeof GLOBAL_SCOPE === 'object') {\n      if (GLOBAL_SCOPE.localStorage) {\n        candidates.push(GLOBAL_SCOPE.localStorage);\n      }\n      if (GLOBAL_SCOPE.sessionStorage) {\n        candidates.push(GLOBAL_SCOPE.sessionStorage);\n      }\n    }\n    if (typeof global !== 'undefined' && global && global !== GLOBAL_SCOPE) {\n      if (global.localStorage) {\n        candidates.push(global.localStorage);\n      }\n      if (global.sessionStorage) {\n        candidates.push(global.sessionStorage);\n      }\n    }\n    candidates.forEach(patchIndividualStorageGetItem);\n    return;\n  }\n\n  const prototype = Storage.prototype;\n  if (!prototype || typeof prototype.getItem !== 'function') {\n    return;\n  }\n\n  if (prototype.__cineStorageCompressionPatched) {\n    return;\n  }\n\n  const originalGetItem = prototype.getItem;\n  const rawGetItem = function rawStorageGetItem(key) {\n    return originalGetItem.call(this, key);\n  };\n  const patchedGetItem = function patchedStorageGetItem(key) {\n    const rawValue = rawGetItem.call(this, key);\n    return maybeDecompressStoredString(rawValue);\n  };\n\n  try {\n    Object.defineProperty(prototype, 'getItem', {\n      configurable: true,\n      writable: true,\n      value: patchedGetItem,\n    });\n  } catch (patchError) {\n    console.warn('Unable to patch Storage.getItem for compression support', patchError);\n    return;\n  }\n\n  try {\n    Object.defineProperty(prototype, STORAGE_RAW_GET_ITEM_PROPERTY, {\n      configurable: true,\n      writable: false,\n      value: rawGetItem,\n    });\n  } catch (rawError) {\n    try {\n      prototype[STORAGE_RAW_GET_ITEM_PROPERTY] = rawGetItem;\n    } catch (assignError) {\n      void assignError;\n    }\n    void rawError;\n  }\n\n  try {\n    Object.defineProperty(prototype, '__cineStorageCompressionPatched', {\n      configurable: true,\n      writable: false,\n      value: true,\n    });\n  } catch (flagError) {\n    prototype.__cineStorageCompressionPatched = true;\n    void flagError;\n  }\n\n  const candidates = [];\n  if (GLOBAL_SCOPE && typeof GLOBAL_SCOPE === 'object') {\n    if (GLOBAL_SCOPE.localStorage) {\n      candidates.push(GLOBAL_SCOPE.localStorage);\n    }\n    if (GLOBAL_SCOPE.sessionStorage) {\n      candidates.push(GLOBAL_SCOPE.sessionStorage);\n    }\n  }\n  if (typeof global !== 'undefined' && global && global !== GLOBAL_SCOPE) {\n    if (global.localStorage) {\n      candidates.push(global.localStorage);\n    }\n    if (global.sessionStorage) {\n      candidates.push(global.sessionStorage);\n    }\n  }\n  candidates.forEach(patchIndividualStorageGetItem);\n}\n\nfunction getRawStorageGetter(storage) {\n  if (!storage || typeof storage !== 'object') {\n    return null;\n  }\n\n  const direct = storage[STORAGE_RAW_GET_ITEM_PROPERTY];\n  if (typeof direct === 'function') {\n    return direct;\n  }\n\n  const prototype = Object.getPrototypeOf(storage);\n  if (prototype && typeof prototype[STORAGE_RAW_GET_ITEM_PROPERTY] === 'function') {\n    return prototype[STORAGE_RAW_GET_ITEM_PROPERTY];\n  }\n\n  return null;\n}\n\nfunction readRawStorageValue(storage, key, rawGetterOverride) {\n  if (!storage || typeof key !== 'string' || !key) {\n    return null;\n  }\n\n  const getter = typeof rawGetterOverride === 'function'\n    ? rawGetterOverride\n    : getRawStorageGetter(storage);\n  if (typeof getter !== 'function') {\n    return null;\n  }\n\n  try {\n    return getter.call(storage, key);\n  } catch (error) {\n    void error;\n    return null;\n  }\n}\n\nfunction collectMigrationBackupEntriesForCleanup(storage, excludeKey) {\n  if (!storage) {\n    return [];\n  }\n\n  let snapshot;\n  try {\n    snapshot = snapshotStorageEntries(storage, { suppressAlerts: true });\n  } catch (error) {\n    console.warn('Unable to inspect storage while preparing migration backup cleanup', error);\n    return [];\n  }\n\n  if (!snapshot || typeof snapshot !== 'object') {\n    return [];\n  }\n\n  return Object.keys(snapshot)\n    .filter((candidate) => {\n      if (typeof candidate !== 'string' || !candidate) {\n        return false;\n      }\n      if (!candidate.endsWith(STORAGE_MIGRATION_BACKUP_SUFFIX)) {\n        return false;\n      }\n      if (excludeKey && candidate === excludeKey) {\n        return false;\n      }\n      return true;\n    })\n    .map((candidate) => {\n      const raw = snapshot[candidate];\n      const normalized = typeof raw === 'string' ? raw : raw === null || raw === undefined ? '' : String(raw);\n      const metadata = parseMigrationBackupMetadata(normalized);\n      return {\n        key: candidate,\n        createdAt: metadata.createdAt,\n        size: metadata.size,\n      };\n    })\n    .sort((a, b) => {\n      if (a.createdAt && b.createdAt && a.createdAt !== b.createdAt) {\n        return a.createdAt - b.createdAt;\n      }\n      if (a.createdAt && !b.createdAt) {\n        return -1;\n      }\n      if (!a.createdAt && b.createdAt) {\n        return 1;\n      }\n      if (a.size !== b.size) {\n        return b.size - a.size;\n      }\n      return a.key.localeCompare(b.key);\n    });\n}\n\nfunction pruneMigrationBackupEntriesForCleanup(storage, excludeKey) {\n  const entries = collectMigrationBackupEntriesForCleanup(storage, excludeKey);\n  if (!entries.length) {\n    return [];\n  }\n\n  const removedKeys = [];\n  const target = entries[0];\n  try {\n    storage.removeItem(target.key);\n    removedKeys.push(target.key);\n  } catch (error) {\n    console.warn(`Unable to remove migration backup ${target.key} during cleanup`, error);\n  }\n\n  return removedKeys;\n}\n\nfunction attemptMigrationBackupQuotaRecovery(storage, key, backupKey, tryWrite) {\n  if (!storage || typeof storage.setItem !== 'function') {\n    return { success: false, error: null };\n  }\n\n  const removedBackups = [];\n  let lastError = null;\n\n  if (typeof tryWrite !== 'function') {\n    return { success: false, error: null };\n  }\n\n  const attemptWrite = () => {\n    const result = tryWrite();\n    if (result && typeof result === 'object' && 'error' in result && result.error) {\n      lastError = result.error;\n    }\n    if (result && result.success) {\n      return { success: true, quota: false };\n    }\n    if (result && result.quota) {\n      return { success: false, quota: true, error: result.error || null };\n    }\n    return { success: false, quota: false, error: result && result.error ? result.error : null };\n  };\n\n  if (typeof clearUiCacheStorageEntries === 'function') {\n    let cleared = false;\n    try {\n      clearUiCacheStorageEntries();\n      cleared = true;\n    } catch (clearError) {\n      console.warn('Unable to clear cached UI storage entries before creating migration backup', clearError);\n    }\n\n    if (cleared) {\n      const retryAfterClear = attemptWrite();\n      if (retryAfterClear.success) {\n        console.warn(`Cleared cached planner data to free storage before creating migration backup for ${key}.`);\n        return { success: true, error: null };\n      }\n      if (!retryAfterClear.quota) {\n        return { success: false, error: retryAfterClear.error };\n      }\n    }\n  }\n\n  for (let attempt = 0; attempt < MAX_MIGRATION_BACKUP_CLEANUP_STEPS; attempt += 1) {\n    const removed = pruneMigrationBackupEntriesForCleanup(storage, backupKey);\n    if (!removed.length) {\n      break;\n    }\n    removedBackups.push(...removed);\n    const retry = attemptWrite();\n    if (retry.success) {\n      console.warn(\n        `Removed ${removedBackups.length} older migration backup${removedBackups.length > 1 ? 's' : ''} to free up storage before creating migration backup for ${key}.`,\n        removedBackups,\n      );\n      return { success: true, error: null };\n    }\n    if (!retry.quota) {\n      return { success: false, error: retry.error };\n    }\n  }\n\n  if (removedBackups.length > 0) {\n    console.warn(\n      `Removed ${removedBackups.length} older migration backup${removedBackups.length > 1 ? 's' : ''} while attempting to create migration backup for ${key}, but storage quota is still exceeded.`,\n      removedBackups,\n    );\n  }\n\n  return { success: false, error: lastError };\n}\n\nfunction ensurePreWriteMigrationBackup(storage, key) {\n  if (!storage || typeof storage.getItem !== 'function' || !key) {\n    return null;\n  }\n\n  let rawValue = null;\n  try {\n    rawValue = storage.getItem(key);\n  } catch (inspectionError) {\n    console.warn(`Unable to inspect existing value for ${key} before creating migration backup`, inspectionError);\n    return null;\n  }\n\n  if (rawValue === null || rawValue === undefined) {\n    return null;\n  }\n\n  let parsedValue = rawValue;\n  let normalizedRawValue = rawValue;\n  if (typeof rawValue === 'string' && rawValue) {\n    normalizedRawValue = maybeDecompressStoredString(rawValue);\n    if (typeof normalizedRawValue === 'string' && normalizedRawValue) {\n      try {\n        parsedValue = JSON.parse(normalizedRawValue);\n      } catch (parseError) {\n        void parseError;\n      }\n    } else {\n      parsedValue = normalizedRawValue;\n    }\n  }\n\n  if (\n    parsedValue &&\n    typeof parsedValue === 'object' &&\n    ((Array.isArray(parsedValue) && parsedValue.length === 0) ||\n      (!Array.isArray(parsedValue) && Object.keys(parsedValue).length === 0))\n  ) {\n    return parsedValue;\n  }\n\n  createStorageMigrationBackup(storage, key, parsedValue);\n  return parsedValue;\n}\n\nvar MIGRATION_BACKUP_LEGACY_DATA_KEYS = [\n  'payload',\n  'value',\n  'content',\n  'entries',\n  'snapshot',\n  'state',\n  'record',\n];\n\nvar MIGRATION_BACKUP_LEGACY_CREATED_AT_KEYS = ['iso', 'timestamp', 'time'];\n\nfunction trySerializeMigrationBackupValue(value) {\n  try {\n    return JSON.stringify(value);\n  } catch (serializationError) {\n    console.warn('Unable to serialize normalized migration backup payload', serializationError);\n    return null;\n  }\n}\n\nfunction normalizeLegacyMigrationBackupCreatedAt(value, fallbackIso) {\n  const fallback = typeof fallbackIso === 'string' && fallbackIso\n    ? fallbackIso\n    : null;\n\n  if (typeof value === 'string') {\n    const trimmed = value.trim();\n    if (!trimmed) {\n      return { value: fallback || new Date().toISOString(), changed: true };\n    }\n    const numeric = Number(trimmed);\n    if (!Number.isNaN(numeric) && Number.isFinite(numeric) && String(numeric) === trimmed) {\n      try {\n        return { value: new Date(numeric).toISOString(), changed: true };\n      } catch (error) {\n        void error;\n        return { value: fallback || new Date().toISOString(), changed: true };\n      }\n    }\n    const timestamp = Date.parse(trimmed);\n    if (!Number.isNaN(timestamp)) {\n      try {\n        const iso = new Date(timestamp).toISOString();\n        return { value: iso, changed: iso !== trimmed };\n      } catch (error) {\n        void error;\n        return { value: fallback || new Date().toISOString(), changed: true };\n      }\n    }\n    return { value: trimmed, changed: trimmed !== value };\n  }\n\n  if (typeof value === 'number' && Number.isFinite(value)) {\n    try {\n      return { value: new Date(value).toISOString(), changed: true };\n    } catch (error) {\n      void error;\n      return { value: fallback || new Date().toISOString(), changed: true };\n    }\n  }\n\n  if (value instanceof Date) {\n    const time = value.getTime();\n    if (Number.isFinite(time)) {\n      try {\n        return { value: value.toISOString(), changed: true };\n      } catch (error) {\n        void error;\n        return { value: fallback || new Date().toISOString(), changed: true };\n      }\n    }\n  }\n\n  if (fallback) {\n    return { value: fallback, changed: true };\n  }\n\n  const generated = new Date().toISOString();\n  return { value: generated, changed: true };\n}\n\nfunction normalizeLegacyMigrationBackupValue(rawValue, fallbackIso) {\n  if (typeof rawValue !== 'string' || !rawValue) {\n    return null;\n  }\n\n  const fallback = typeof fallbackIso === 'string' && fallbackIso\n    ? fallbackIso\n    : new Date().toISOString();\n\n  let parsed;\n  try {\n    parsed = JSON.parse(rawValue);\n  } catch (parseError) {\n    void parseError;\n    return trySerializeMigrationBackupValue({ createdAt: fallback, data: rawValue });\n  }\n\n  // If parsed is null/undefined or not object, wrap it\n  if (!parsed || typeof parsed !== 'object') {\n    const dataValue = parsed === undefined ? rawValue : parsed;\n    return trySerializeMigrationBackupValue({ createdAt: fallback, data: dataValue });\n  }\n\n  // If it's an array of backup entries, check if it is already in modern format\n  // If it's an array of backup entries, it's a valid modern format for history.\n  if (Array.isArray(parsed)) {\n    let listChanged = false;\n    const normalizedList = parsed.map((item) => {\n      if (!item || typeof item !== 'object') {\n        listChanged = true;\n        return { createdAt: fallback, data: item };\n      }\n\n      const hasData = Object.prototype.hasOwnProperty.call(item, 'data');\n      const itemCreatedAt = item.createdAt;\n      const { value: normalizedDate, changed: dateChanged } = normalizeLegacyMigrationBackupCreatedAt(\n        itemCreatedAt, fallback\n      );\n\n      if (!hasData) {\n        listChanged = true;\n        // Treat the whole item as data if it's not a valid envelope\n        return { createdAt: normalizedDate, data: item };\n      }\n\n      if (dateChanged || itemCreatedAt !== normalizedDate) {\n        listChanged = true;\n        return { ...item, createdAt: normalizedDate };\n      }\n\n      return item;\n    });\n\n    if (!listChanged) {\n      return null;\n    }\n    return trySerializeMigrationBackupValue(normalizedList);\n  }\n\n  let normalized;\n  let changed = false;\n\n  if (Object.prototype.hasOwnProperty.call(parsed, 'data')) {\n    normalized = { ...parsed };\n  } else {\n    let usedKey = null;\n    for (let i = 0; i < MIGRATION_BACKUP_LEGACY_DATA_KEYS.length; i += 1) {\n      const key = MIGRATION_BACKUP_LEGACY_DATA_KEYS[i];\n      if (Object.prototype.hasOwnProperty.call(parsed, key)) {\n        usedKey = key;\n        break;\n      }\n    }\n\n    if (usedKey) {\n      normalized = { ...parsed };\n      normalized.data = parsed[usedKey];\n      delete normalized[usedKey];\n      changed = true;\n    } else {\n      normalized = { data: parsed };\n      changed = true;\n    }\n  }\n\n  let rawCreatedAt = normalized.createdAt;\n  let createdAtSourceKey = 'createdAt';\n  if (rawCreatedAt === undefined) {\n    for (let i = 0; i < MIGRATION_BACKUP_LEGACY_CREATED_AT_KEYS.length; i += 1) {\n      const key = MIGRATION_BACKUP_LEGACY_CREATED_AT_KEYS[i];\n      if (Object.prototype.hasOwnProperty.call(parsed, key)) {\n        rawCreatedAt = parsed[key];\n        createdAtSourceKey = key;\n        break;\n      }\n    }\n  }\n\n  const { value: createdAt, changed: createdAtChanged } = normalizeLegacyMigrationBackupCreatedAt(\n    rawCreatedAt,\n    fallback,\n  );\n\n  normalized.createdAt = createdAt;\n  if (createdAtSourceKey !== 'createdAt' && createdAtSourceKey && Object.prototype.hasOwnProperty.call(normalized, createdAtSourceKey)) {\n    delete normalized[createdAtSourceKey];\n    changed = true;\n  }\n\n  if (createdAtChanged) {\n    changed = true;\n  }\n\n  if (!changed) {\n    return null;\n  }\n\n  return trySerializeMigrationBackupValue(normalized);\n}\n\nfunction upgradeLegacyMigrationBackupEntry(storage, backupKey, rawValue, fallbackIso) {\n  const normalized = normalizeLegacyMigrationBackupValue(rawValue, fallbackIso);\n  if (normalized === null) {\n    return true;\n  }\n  if (typeof normalized !== 'string' || !normalized) {\n    return false;\n  }\n  if (normalized === rawValue) {\n    return true;\n  }\n  try {\n    storage.setItem(backupKey, normalized);\n    return true;\n  } catch (error) {\n    console.warn(`Unable to normalize legacy migration backup for ${backupKey}`, error);\n    return false;\n  }\n}\n\nfunction createStorageMigrationBackup(storage, key, originalValue) {\n  if (!storage || typeof storage.setItem !== 'function') {\n    return;\n  }\n  if (originalValue === null || originalValue === undefined) {\n    return;\n  }\n\n  const backupKey = `${key}${STORAGE_MIGRATION_BACKUP_SUFFIX}`;\n  let hasExistingBackup = false;\n\n  if (typeof storage.getItem === 'function') {\n    try {\n      const existing = storage.getItem(backupKey);\n      if (existing !== null && existing !== undefined) {\n        hasExistingBackup = true;\n        const fallbackCreatedAt = new Date().toISOString();\n        upgradeLegacyMigrationBackupEntry(storage, backupKey, existing, fallbackCreatedAt);\n      }\n    } catch (inspectionError) {\n      console.warn(`Unable to inspect migration backup for ${key}`, inspectionError);\n    }\n  }\n\n  if (hasExistingBackup) {\n    // If we already have a backup, we append to a list to keep history.\n    try {\n      const existingRaw = storage.getItem(backupKey);\n      const decoded = decodeStoredValue(existingRaw);\n      let existingData = null;\n      try {\n        existingData = JSON.parse(decoded);\n      } catch (jsonError) {\n        void jsonError;\n        existingData = decoded;\n      }\n\n      let list = Array.isArray(existingData) ? existingData : [existingData];\n      const newEntry = { createdAt: new Date().toISOString(), data: originalValue };\n      list.push(newEntry);\n\n      // Limit history size to prevent indefinite growth\n      const MAX_BACKUP_HISTORY = 5;\n      if (list.length > MAX_BACKUP_HISTORY) {\n        list = list.slice(list.length - MAX_BACKUP_HISTORY);\n      }\n\n      const tryStoreList = (candidateList) => {\n        try {\n          storage.setItem(backupKey, JSON.stringify(candidateList));\n          return { success: true };\n        } catch (itemError) {\n          return { success: false, quota: isQuotaExceededError(itemError), error: itemError };\n        }\n      };\n\n      let result = tryStoreList(list);\n\n      // If quota exceeded, try to shrink the list further\n      while (!result.success && result.quota && list.length > 1) {\n        list.shift(); // Remove oldest\n        console.warn(`Pruning oldest migration backup for ${key} due to quota limit.`);\n        result = tryStoreList(list);\n      }\n\n      if (result.success) {\n        return;\n      }\n\n      // If still failing, try to prune OTHER backups\n      if (!result.success && result.quota) {\n        const recovery = attemptMigrationBackupQuotaRecovery(storage, key, backupKey, () => tryStoreList(list));\n        if (recovery && recovery.success) {\n          return;\n        }\n      }\n\n      console.warn('Unable to append to migration backup', result.error);\n      return;\n    } catch (appendError) {\n      console.warn('Unable to append to migration backup', appendError);\n      return;\n    }\n  }\n\n  let serialized;\n  const createdAt = new Date().toISOString();\n  try {\n    serialized = JSON.stringify({\n      createdAt,\n      data: originalValue,\n    });\n  } catch (serializationError) {\n    console.warn(`Unable to serialize migration backup for ${key}`, serializationError);\n    return;\n  }\n\n  const tryStoreSerialized = (candidate, options = {}) => {\n    const { logCompression = false, info = null } = options || {};\n    try {\n      storage.setItem(backupKey, candidate.serialized);\n      if (logCompression && info && !tryStoreSerialized.compressionLogged) {\n        tryStoreSerialized.compressionLogged = true;\n        const storedLength = typeof info.serializedLength === 'number'\n          ? info.serializedLength\n          : info.compressedSize;\n        const rawSavings = info.originalSize - storedLength;\n        const savings = rawSavings > 0 ? rawSavings : 0;\n        const percent = info.originalSize > 0\n          ? Math.round((savings / info.originalSize) * 100)\n          : 0;\n        const message = `Stored compressed migration backup for ${key} to reduce storage usage by ${savings} characters (${percent}%) using ${info.variant || 'unknown'} variant.`;\n        logCompressionSavingsEvent('migration-backup', key, message, savings, percent);\n      }\n      return { success: true, quota: false };\n    } catch (error) {\n      return { success: false, quota: isQuotaExceededError(error), error };\n    }\n  };\n  tryStoreSerialized.compressionLogged = tryStoreSerialized.compressionLogged || false;\n\n  const standardCandidate = { serialized };\n  const standardResult = tryStoreSerialized(standardCandidate);\n  if (standardResult.success) {\n    return;\n  }\n\n  const handleFailure = (error) => {\n    console.warn(`Unable to create migration backup for ${key}`, error);\n  };\n\n  if (!standardResult.quota) {\n    handleFailure(standardResult.error);\n    return;\n  }\n\n  const allowCompressedBackup = !isDeviceStorageKeyVariant(key);\n  const compressedCandidate = allowCompressedBackup\n    ? tryCreateCompressedMigrationBackupCandidate(serialized, createdAt)\n    : null;\n\n  const runRecoveryWith = (candidate, options, fallbackError) => {\n    const recovery = attemptMigrationBackupQuotaRecovery(storage, key, backupKey, () =>\n      tryStoreSerialized(candidate, options),\n    );\n    if (recovery && recovery.success) {\n      return true;\n    }\n    const errorToReport = recovery && recovery.error ? recovery.error : fallbackError;\n    handleFailure(errorToReport);\n    alertStorageError('migration-backup-quota');\n    return false;\n  };\n\n  if (compressedCandidate) {\n    const compressedResult = tryStoreSerialized(compressedCandidate, {\n      logCompression: true,\n      info: compressedCandidate,\n    });\n    if (compressedResult.success) {\n      return;\n    }\n    if (!compressedResult.quota) {\n      handleFailure(compressedResult.error);\n      return;\n    }\n    if (runRecoveryWith(compressedCandidate, { logCompression: true, info: compressedCandidate }, compressedResult.error)) {\n      return;\n    }\n    return;\n  }\n\n  if (runRecoveryWith(standardCandidate, {}, standardResult.error)) {\n    return;\n  }\n}\n\nvar PRIMARY_STORAGE_KEYS = [\n  DEVICE_STORAGE_KEY,\n  SETUP_STORAGE_KEY,\n  SESSION_STATE_KEY,\n  FEEDBACK_STORAGE_KEY,\n  PROJECT_STORAGE_KEY,\n  FAVORITES_STORAGE_KEY,\n  DEVICE_SCHEMA_CACHE_KEY,\n  AUTO_GEAR_RULES_STORAGE_KEY,\n  AUTO_GEAR_SEEDED_STORAGE_KEY,\n  AUTO_GEAR_BACKUPS_STORAGE_KEY,\n  AUTO_GEAR_PRESETS_STORAGE_KEY,\n  AUTO_GEAR_ACTIVE_PRESET_STORAGE_KEY,\n  AUTO_GEAR_AUTO_PRESET_STORAGE_KEY,\n  AUTO_GEAR_BACKUP_VISIBILITY_STORAGE_KEY,\n  AUTO_GEAR_MONITOR_DEFAULTS_STORAGE_KEY,\n  AUTO_GEAR_BACKUP_RETENTION_STORAGE_KEY,\n  FULL_BACKUP_HISTORY_STORAGE_KEY,\n];\n\nvar SIMPLE_STORAGE_KEYS = [\n  CUSTOM_LOGO_STORAGE_KEY,\n  getCustomFontStorageKeyName(),\n  'darkMode',\n  'pinkMode',\n  'highContrast',\n  'reduceMotion',\n  'relaxedSpacing',\n  'showAutoBackups',\n  'accentColor',\n  'fontSize',\n  'fontFamily',\n  'language',\n  'iosPwaHelpShown',\n  CAMERA_COLOR_STORAGE_KEY,\n  TEMPERATURE_UNIT_STORAGE_KEY_NAME,\n];\n\nvar STORAGE_ALERT_FLAG_NAME = '__cameraPowerPlannerStorageAlertShown';\nvar SESSION_FALLBACK_ALERT_FLAG_NAME = '__cameraPowerPlannerSessionFallbackAlertShown';\n\nvar storageErrorAlertShown = false;\nif (GLOBAL_SCOPE) {\n  if (typeof GLOBAL_SCOPE[STORAGE_ALERT_FLAG_NAME] === 'boolean') {\n    storageErrorAlertShown = GLOBAL_SCOPE[STORAGE_ALERT_FLAG_NAME];\n  } else {\n    GLOBAL_SCOPE[STORAGE_ALERT_FLAG_NAME] = false;\n  }\n}\n\nvar sessionFallbackAlertShown = false;\nif (GLOBAL_SCOPE) {\n  if (typeof GLOBAL_SCOPE[SESSION_FALLBACK_ALERT_FLAG_NAME] === 'boolean') {\n    sessionFallbackAlertShown = GLOBAL_SCOPE[SESSION_FALLBACK_ALERT_FLAG_NAME];\n  } else {\n    GLOBAL_SCOPE[SESSION_FALLBACK_ALERT_FLAG_NAME] = false;\n  }\n}\n\nvar DEVICE_COLLECTION_KEYS = [\n  'cameras',\n  'monitors',\n  'video',\n  'viewfinders',\n  'directorMonitors',\n  'iosVideo',\n  'videoAssist',\n  'media',\n  'lenses',\n  'batteries',\n  'batteryHotswaps',\n  'wirelessReceivers',\n];\n\nvar FIZ_COLLECTION_KEYS = ['motors', 'handUnits', 'controllers', 'distance'];\n\nvar ACCESSORY_COLLECTION_KEYS = [\n  'chargers',\n  'cages',\n  'powerPlates',\n  'cameraSupport',\n  'matteboxes',\n  'filters',\n  'rigging',\n  'batteries',\n  'cables',\n  'videoAssist',\n  'media',\n  'cardReaders',\n  'tripodHeads',\n  'tripods',\n  'sliders',\n  'cameraStabiliser',\n  'grip',\n  'carts',\n];\n\nvar getStorageManager = () =>\n  typeof navigator !== 'undefined' &&\n    navigator &&\n    typeof navigator.storage === 'object'\n    ? navigator.storage\n    : null;\n\n// Safely detect usable localStorage. Some environments (like private browsing)\n// may block access and throw errors. If unavailable, fall back to\n// sessionStorage when possible so data persists across reloads within the same\n// tab. When neither storage option is available we fall back to a simple\n// in-memory store to avoid runtime errors even though the data will be lost on\n// reload.\nvar STORAGE_TEST_KEY = '__storage_test__';\n\nvar QUOTA_ERROR_NAMES = new Set([\n  'QuotaExceededError',\n  'NS_ERROR_DOM_QUOTA_REACHED',\n]);\nvar QUOTA_ERROR_CODES = new Set([22, 1014]);\nvar QUOTA_ERROR_NUMBERS = new Set([22, 1014]);\n\nfunction isQuotaExceededError(error) {\n  if (!error || typeof error !== 'object') {\n    return false;\n  }\n  if (typeof error.code === 'number' && QUOTA_ERROR_CODES.has(error.code)) {\n    return true;\n  }\n  if (typeof error.number === 'number' && QUOTA_ERROR_NUMBERS.has(error.number)) {\n    return true;\n  }\n  if (typeof error.name === 'string' && QUOTA_ERROR_NAMES.has(error.name)) {\n    return true;\n  }\n  return false;\n}\n\nfunction hasStoredEntries(storage) {\n  if (!storage) return false;\n\n  try {\n    if (typeof storage.length === 'number' && storage.length > 0) {\n      return true;\n    }\n  } catch (lengthError) {\n    console.warn('Unable to read storage length after quota error', lengthError);\n  }\n\n  if (typeof storage.getItem === 'function') {\n    try {\n      for (let i = 0; i < PRIMARY_STORAGE_KEYS.length; i += 1) {\n        const key = PRIMARY_STORAGE_KEYS[i];\n        const variants = getStorageKeyVariants(key);\n        for (let j = 0; j < variants.length; j += 1) {\n          const candidateKey = variants[j];\n          if (storage.getItem(candidateKey) !== null) {\n            return true;\n          }\n          const backupKey = `${candidateKey}${STORAGE_BACKUP_SUFFIX}`;\n          if (storage.getItem(backupKey) !== null) {\n            return true;\n          }\n        }\n      }\n\n      for (let i = 0; i < SIMPLE_STORAGE_KEYS.length; i += 1) {\n        const key = SIMPLE_STORAGE_KEYS[i];\n        const variants = getStorageKeyVariants(key);\n        for (let j = 0; j < variants.length; j += 1) {\n          const candidateKey = variants[j];\n          if (storage.getItem(candidateKey) !== null) {\n            return true;\n          }\n          if (RAW_STORAGE_BACKUP_KEYS.has(candidateKey)) {\n            const backupKey = `${candidateKey}${STORAGE_BACKUP_SUFFIX}`;\n            if (storage.getItem(backupKey) !== null) {\n              return true;\n            }\n          }\n        }\n      }\n    } catch (inspectionError) {\n      console.warn('Unable to inspect known storage keys after quota error', inspectionError);\n    }\n  }\n\n  if (typeof storage.key === 'function') {\n    try {\n      const length = typeof storage.length === 'number' ? storage.length : 0;\n      for (let index = 0; index < length; index += 1) {\n        const candidate = storage.key(index);\n        if (typeof candidate === 'string' && candidate) {\n          return true;\n        }\n      }\n    } catch (iterationError) {\n      console.warn('Unable to iterate storage keys after quota error', iterationError);\n    }\n  }\n\n  return false;\n}\n\nfunction verifyStorage(storage) {\n  if (!storage) return null;\n  try {\n    storage.setItem(STORAGE_TEST_KEY, '1');\n  } catch (error) {\n    if (isQuotaExceededError(error) && hasStoredEntries(storage)) {\n      console.warn(\n        'localStorage quota exceeded. Existing planner data will remain available but new saves may fail.',\n        error,\n      );\n      return storage;\n    }\n    throw error;\n  }\n\n  try {\n    storage.removeItem(STORAGE_TEST_KEY);\n  } catch (cleanupError) {\n    console.warn('Unable to clean up storage test key', cleanupError);\n  }\n\n  return storage;\n}\n\nfunction createMemoryStorage() {\n  let memoryStore = {};\n  return {\n    get length() {\n      return Object.keys(memoryStore).length;\n    },\n    key(index) {\n      const keys = Object.keys(memoryStore);\n      return index >= 0 && index < keys.length ? keys[index] : null;\n    },\n    getItem(key) {\n      if (!Object.prototype.hasOwnProperty.call(memoryStore, key)) {\n        return null;\n      }\n      return maybeDecompressStoredString(memoryStore[key]);\n    },\n    setItem(key, value) {\n      memoryStore[key] = String(value);\n    },\n    removeItem(key) {\n      delete memoryStore[key];\n    },\n    clear() {\n      memoryStore = {};\n    },\n    keys() {\n      return Object.keys(memoryStore);\n    },\n  };\n}\n\nfunction initializeSafeLocalStorage() {\n  const localCandidates = collectLocalStorageCandidates();\n\n  for (let index = 0; index < localCandidates.length; index += 1) {\n    const candidate = localCandidates[index];\n    if (!candidate) {\n      continue;\n    }\n\n    try {\n      const storage = verifyStorage(candidate);\n      if (storage) {\n        lastFailedUpgradeCandidate = null;\n        return { storage, type: 'local' };\n      }\n    } catch (error) {\n      console.warn('localStorage is unavailable:', error);\n      lastFailedUpgradeCandidate = candidate;\n    }\n  }\n\n  if (typeof window !== 'undefined') {\n    try {\n      if ('sessionStorage' in window) {\n        const storage = verifyStorage(window.sessionStorage);\n        if (storage) {\n          registerKnownSessionStorage(storage);\n          console.warn('Falling back to sessionStorage; data persists for this tab only.');\n          alertSessionFallback();\n          return { storage, type: 'session' };\n        }\n      }\n    } catch (e) {\n      console.warn('sessionStorage fallback is unavailable:', e);\n    }\n  }\n\n  alertStorageError();\n  return { storage: createMemoryStorage(), type: 'memory' };\n}\n\nvar lastFailedUpgradeCandidate = null;\nvar safeLocalStorageInfo = initializeSafeLocalStorage();\n\nfunction migrateSnapshotToStorage(snapshot, target) {\n  const migratedKeys = [];\n  const failedKeys = [];\n\n  if (!snapshot || !target || typeof target.setItem !== 'function') {\n    return { migratedKeys, failedKeys };\n  }\n\n  Object.keys(snapshot).forEach((key) => {\n    const value = snapshot[key];\n    if (value === null || value === undefined) {\n      return;\n    }\n\n    let existing = null;\n    let existingRead = false;\n    try {\n      existing = target.getItem(key);\n      existingRead = true;\n    } catch (readError) {\n      console.warn('Unable to inspect localStorage during upgrade', key, readError);\n    }\n\n    if (existingRead && existing !== null && existing !== undefined && existing !== value) {\n      createStorageMigrationBackup(target, key, existing);\n    }\n\n    if (existingRead && existing === value) {\n      migratedKeys.push(key);\n      return;\n    }\n\n    try {\n      target.setItem(key, value);\n      migratedKeys.push(key);\n    } catch (writeError) {\n      console.warn('Unable to migrate storage key during upgrade', key, writeError);\n      failedKeys.push(key);\n    }\n  });\n\n  return { migratedKeys, failedKeys };\n}\n\nfunction clearMigratedKeys(snapshot, source, keysToRemove) {\n  if (!snapshot || !source || typeof source.removeItem !== 'function') {\n    return;\n  }\n\n  const keys = Array.isArray(keysToRemove) && keysToRemove.length > 0\n    ? keysToRemove\n    : Object.keys(snapshot);\n\n  keys.forEach((key) => {\n    try {\n      source.removeItem(key);\n    } catch (error) {\n      console.warn('Unable to remove migrated storage key from fallback', key, error);\n    }\n  });\n}\n\nfunction rollbackMigratedKeys(target, keys) {\n  if (!target || typeof target.removeItem !== 'function' || !Array.isArray(keys)) {\n    return;\n  }\n\n  keys.forEach((key) => {\n    try {\n      target.removeItem(key);\n    } catch (error) {\n      console.warn('Unable to roll back migrated storage key after upgrade failure', key, error);\n    }\n  });\n}\n\nfunction snapshotStorageEntries(storage, options = {}) {\n  const snapshot = Object.create(null);\n  if (!storage) {\n    return snapshot;\n  }\n\n  const { suppressAlerts = false } = options || {};\n\n  const captureKey = (key) => {\n    if (typeof key !== 'string' || !key) {\n      return;\n    }\n    let value;\n    try {\n      if (typeof storage.getItem === 'function') {\n        value = storage.getItem(key);\n      } else if (Object.prototype.hasOwnProperty.call(storage, key)) {\n        value = storage[key];\n      }\n    } catch (error) {\n      console.warn('Unable to read storage key during snapshot', key, error);\n      if (!suppressAlerts) {\n        alertStorageError('migration-read');\n      }\n      return;\n    }\n    if (value === null || value === undefined) {\n      return;\n    }\n    snapshot[key] = String(value);\n  };\n\n  if (typeof storage.key === 'function' && typeof storage.length === 'number') {\n    for (let index = 0; index < storage.length; index += 1) {\n      captureKey(storage.key(index));\n    }\n    return snapshot;\n  }\n\n  if (typeof storage.keys === 'function') {\n    try {\n      const keys = storage.keys();\n      if (Array.isArray(keys)) {\n        keys.forEach(captureKey);\n      }\n    } catch (error) {\n      console.warn('Unable to enumerate storage keys during snapshot', error);\n      if (!suppressAlerts) {\n        alertStorageError('migration-read');\n      }\n    }\n    return snapshot;\n  }\n\n  if (typeof storage.forEach === 'function') {\n    try {\n      storage.forEach((value, key) => {\n        if (typeof key !== 'string') {\n          return;\n        }\n        if (value === null || value === undefined) {\n          return;\n        }\n        snapshot[key] = String(value);\n      });\n    } catch (error) {\n      console.warn('Unable to iterate storage entries during snapshot', error);\n      if (!suppressAlerts) {\n        alertStorageError('migration-read');\n      }\n    }\n    return snapshot;\n  }\n\n  Object.keys(storage).forEach(captureKey);\n  return snapshot;\n}\n\nfunction updateGlobalSafeLocalStorageReference() {\n  if (!GLOBAL_SCOPE || typeof GLOBAL_SCOPE !== 'object') {\n    return;\n  }\n\n  try {\n    Object.defineProperty(GLOBAL_SCOPE, 'SAFE_LOCAL_STORAGE', {\n      configurable: true,\n      get: getSafeLocalStorage,\n    });\n    return;\n  } catch (defineError) {\n    void defineError;\n    try {\n      GLOBAL_SCOPE.SAFE_LOCAL_STORAGE = getSafeLocalStorage();\n      return;\n    } catch (assignError) {\n      console.warn('Unable to refresh SAFE_LOCAL_STORAGE global reference', assignError);\n    }\n  }\n}\n\nfunction downgradeSafeLocalStorageToMemory(reason, error, failingStorage) {\n  if (!safeLocalStorageInfo || safeLocalStorageInfo.type === 'memory') {\n    return;\n  }\n\n  const activeStorage = safeLocalStorageInfo.storage;\n  if (!activeStorage || (failingStorage && failingStorage !== activeStorage)) {\n    return;\n  }\n\n  let snapshot = Object.create(null);\n  try {\n    snapshot = snapshotStorageEntries(activeStorage, { suppressAlerts: true });\n  } catch (snapshotError) {\n    console.warn('Unable to capture storage snapshot during downgrade', snapshotError);\n  }\n\n  let fallbackStorage = null;\n  let fallbackType = 'memory';\n\n  if (safeLocalStorageInfo.type !== 'session') {\n    const sessionScopes = [\n      GLOBAL_SCOPE,\n      GLOBAL_SCOPE && GLOBAL_SCOPE.window ? GLOBAL_SCOPE.window : null,\n      GLOBAL_SCOPE && GLOBAL_SCOPE.__cineGlobal ? GLOBAL_SCOPE.__cineGlobal : null,\n      typeof window !== 'undefined' ? window : null,\n      typeof self !== 'undefined' ? self : null,\n      typeof global !== 'undefined' ? global : null,\n    ];\n\n    for (let index = 0; index < sessionScopes.length; index += 1) {\n      const candidate = resolveSessionStorageFromScope(sessionScopes[index]);\n      if (!candidate || candidate === activeStorage || (failingStorage && candidate === failingStorage)) {\n        continue;\n      }\n\n      try {\n        const verified = verifyStorage(candidate);\n        if (verified) {\n          fallbackStorage = verified;\n          fallbackType = 'session';\n          registerKnownSessionStorage(verified);\n          break;\n        }\n      } catch (sessionError) {\n        console.warn('Unable to activate sessionStorage fallback during downgrade', sessionError);\n      }\n    }\n  }\n\n  if (!fallbackStorage) {\n    fallbackStorage = createMemoryStorage();\n  }\n\n  Object.keys(snapshot).forEach((key) => {\n    const value = snapshot[key];\n    if (value === null || value === undefined) {\n      return;\n    }\n    try {\n      if (typeof fallbackStorage.setItem === 'function') {\n        fallbackStorage.setItem(key, value);\n      } else {\n        fallbackStorage[key] = value;\n      }\n    } catch (copyError) {\n      const label = fallbackType === 'session' ? 'sessionStorage' : 'memory';\n      console.warn(`Unable to copy storage entry to ${label} during downgrade`, key, copyError);\n    }\n  });\n\n  safeLocalStorageInfo = { storage: fallbackStorage, type: fallbackType };\n  lastFailedUpgradeCandidate = null;\n\n  const fallbackDescription = fallbackType === 'session' ? 'sessionStorage' : 'in-memory fallback';\n  console.warn(\n    reason\n      ? `Downgraded planner storage to ${fallbackDescription} after ${reason} errors.`\n      : `Downgraded planner storage to ${fallbackDescription} after storage errors.`,\n    error,\n  );\n\n  if (fallbackType === 'session') {\n    alertSessionFallback();\n  }\n\n  updateGlobalSafeLocalStorageReference();\n}\n\nfunction attemptLocalStorageUpgrade() {\n  if (!safeLocalStorageInfo || safeLocalStorageInfo.type === 'local') {\n    return safeLocalStorageInfo.storage;\n  }\n\n  const candidates = collectLocalStorageCandidates();\n  const currentStorage = safeLocalStorageInfo.storage;\n  let selectedCandidate = null;\n  let verifiedStorage = null;\n\n  for (let index = 0; index < candidates.length; index += 1) {\n    const candidate = candidates[index];\n    if (!candidate || candidate === currentStorage) {\n      continue;\n    }\n    if (candidate === lastFailedUpgradeCandidate) {\n      continue;\n    }\n\n    let verified;\n    try {\n      verified = verifyStorage(candidate);\n    } catch (verificationError) {\n      console.warn('localStorage upgrade verification failed', verificationError);\n      lastFailedUpgradeCandidate = candidate;\n      continue;\n    }\n\n    if (!verified || verified === currentStorage) {\n      if (!verified) {\n        lastFailedUpgradeCandidate = candidate;\n      }\n      continue;\n    }\n\n    selectedCandidate = candidate;\n    verifiedStorage = verified;\n    break;\n  }\n\n  if (!verifiedStorage) {\n    return currentStorage;\n  }\n\n  const snapshot = snapshotStorageEntries(currentStorage);\n  const { migratedKeys, failedKeys } = migrateSnapshotToStorage(snapshot, verifiedStorage);\n\n  if (failedKeys.length > 0) {\n    rollbackMigratedKeys(verifiedStorage, migratedKeys);\n    console.warn(\n      'Aborting localStorage upgrade because some entries could not be migrated. Continuing to use fallback storage.',\n      failedKeys,\n    );\n    alertStorageError('migration-write');\n    lastFailedUpgradeCandidate = selectedCandidate || verifiedStorage;\n    return currentStorage;\n  }\n\n  clearMigratedKeys(snapshot, currentStorage, migratedKeys);\n\n  safeLocalStorageInfo = { storage: verifiedStorage, type: 'local' };\n  lastFailedUpgradeCandidate = null;\n  return verifiedStorage;\n}\n\nfunction getSafeLocalStorage() {\n  // [Refactor] Delegate to the new StorageRepository driver if compatible\n  if (storageRepo && storageRepo.driver && storageRepo.driver.storage) {\n    return storageRepo.driver.storage;\n  }\n\n  if (!safeLocalStorageInfo || !safeLocalStorageInfo.storage) {\n    safeLocalStorageInfo = initializeSafeLocalStorage();\n    if (typeof console !== 'undefined' && console.log) {\n      console.log('DEBUG: storage initialized with type:', safeLocalStorageInfo.type);\n    }\n  }\n\n  if (safeLocalStorageInfo.type !== 'local') {\n    attemptLocalStorageUpgrade();\n  }\n\n  return safeLocalStorageInfo.storage;\n}\n\nupdateGlobalSafeLocalStorageReference();\npatchStorageGetItemForCompression();\n\nvar persistentStorageRequestPromise = null;\n\nfunction requestPersistentStorage() {\n  const storageManager = getStorageManager();\n  const supportsPersist =\n    storageManager && typeof storageManager.persist === 'function';\n\n  if (!supportsPersist) {\n    return Promise.resolve({\n      supported: false,\n      granted: false,\n      alreadyGranted: false,\n    });\n  }\n\n  if (persistentStorageRequestPromise) {\n    return persistentStorageRequestPromise;\n  }\n\n  const requestPromise = (async () => {\n    let alreadyGranted = false;\n    const supportsPersistedCheck = typeof storageManager.persisted === 'function';\n\n    if (supportsPersistedCheck) {\n      try {\n        alreadyGranted = await storageManager.persisted();\n      } catch (persistedError) {\n        console.warn('Unable to determine persistent storage state', persistedError);\n      }\n    }\n\n    if (alreadyGranted) {\n      return {\n        supported: true,\n        granted: true,\n        alreadyGranted: true,\n      };\n    }\n\n    try {\n      const granted = await storageManager.persist();\n      if (!granted && supportsPersistedCheck) {\n        try {\n          const persisted = await storageManager.persisted();\n          if (persisted) {\n            return {\n              supported: true,\n              granted: true,\n              alreadyGranted: true,\n            };\n          }\n        } catch (verifyError) {\n          console.warn('Unable to verify persistent storage after request', verifyError);\n        }\n      }\n\n      return {\n        supported: true,\n        granted,\n        alreadyGranted: false,\n      };\n    } catch (error) {\n      console.warn('Persistent storage request failed', error);\n      return {\n        supported: true,\n        granted: false,\n        alreadyGranted: false,\n        error,\n      };\n    }\n  })();\n\n  const trackedPromise = requestPromise.then(\n    (result) => {\n      if (!result || result.granted !== true) {\n        persistentStorageRequestPromise = null;\n      }\n      return result;\n    },\n    (error) => {\n      persistentStorageRequestPromise = null;\n      throw error;\n    },\n  );\n\n  persistentStorageRequestPromise = trackedPromise;\n  return trackedPromise;\n}\n\nif (typeof window !== 'undefined' && typeof navigator !== 'undefined') {\n  requestPersistentStorage();\n}\n\n// Helper to check for plain objects\nfunction isPlainObject(val) {\n  if (val === null || typeof val !== 'object') {\n    return false;\n  }\n  let prototype;\n  try {\n    prototype = Object.getPrototypeOf(val);\n  } catch {\n    return false;\n  }\n  if (prototype === null || prototype === Object.prototype) {\n    return true;\n  }\n  const secondLevel = Object.getPrototypeOf(prototype);\n  if (secondLevel === null && typeof prototype.constructor === 'function') {\n    const name = prototype.constructor.name;\n    return name === 'Object' || name === '';\n  }\n  return false;\n}\n\nfunction isMapLike(value) {\n  if (!value || typeof value !== 'object') {\n    return false;\n  }\n\n  const tag = Object.prototype.toString.call(value);\n  if (tag === '[object Map]') {\n    return true;\n  }\n\n  if (typeof Map !== 'undefined') {\n    try {\n      if (value instanceof Map) {\n        return true;\n      }\n    } catch (error) {\n      void error;\n    }\n  }\n\n  return (\n    typeof value.size === 'number'\n    && typeof value.entries === 'function'\n    && typeof value.forEach === 'function'\n    && typeof value.get === 'function'\n    && typeof value.set === 'function'\n  );\n}\n\nfunction convertMapLikeKey(key) {\n  if (typeof key === 'string') {\n    return key;\n  }\n  if (typeof key === 'number' || typeof key === 'boolean' || typeof key === 'bigint') {\n    return String(key);\n  }\n  if (typeof key === 'symbol') {\n    return key.description || key.toString();\n  }\n  if (key && typeof key === 'object') {\n    try {\n      const json = JSON.stringify(key);\n      if (json && json !== '{}') {\n        return json;\n      }\n    } catch (error) {\n      void error;\n    }\n  }\n  try {\n    return String(key);\n  } catch (error) {\n    void error;\n  }\n  return null;\n}\n\nfunction convertMapLikeToObject(mapLike) {\n  if (!isMapLike(mapLike)) {\n    return null;\n  }\n\n  const snapshot = Object.create(null);\n  const assignEntry = (rawKey, value) => {\n    const key = convertMapLikeKey(rawKey);\n    if (key === null || key === undefined) {\n      return;\n    }\n    if (Object.prototype.hasOwnProperty.call(snapshot, key)) {\n      return;\n    }\n    snapshot[key] = value;\n  };\n\n  let iterated = false;\n\n  if (typeof mapLike.entries === 'function') {\n    try {\n      const iterator = mapLike.entries();\n      if (iterator && typeof iterator.next === 'function') {\n        for (let step = iterator.next(); !step.done; step = iterator.next()) {\n          const entry = step && step.value;\n          if (Array.isArray(entry) && entry.length >= 2) {\n            assignEntry(entry[0], entry[1]);\n          }\n        }\n        iterated = true;\n      }\n    } catch (error) {\n      console.warn('Unable to iterate map-like value entries', error);\n    }\n  }\n\n  if (!iterated && typeof mapLike.forEach === 'function') {\n    try {\n      mapLike.forEach((value, key) => {\n        assignEntry(key, value);\n      });\n      iterated = true;\n    } catch (error) {\n      console.warn('Unable to iterate map-like value via forEach', error);\n    }\n  }\n\n  if (!Object.keys(snapshot).length && !iterated) {\n    return null;\n  }\n\n  return snapshot;\n}\n\nvar LEGACY_LONG_GOP_TOKEN_REGEX = /^long[\\s_-]?gop$/i;\n\nfunction inferLegacyLongGopCompressionVariant(value) {\n  if (typeof value !== 'string') {\n    return null;\n  }\n\n  var trimmed = value.trim();\n  if (!trimmed) {\n    return null;\n  }\n\n  var lower = trimmed.toLowerCase();\n  if (lower === 'utf16' || lower === 'utf-16') {\n    return 'utf16';\n  }\n  if (lower === 'uri-component' || lower === 'uri_component' || lower === 'encoded-uri-component' || lower === 'uri') {\n    return 'uri-component';\n  }\n  if (lower === 'base64') {\n    return 'base64';\n  }\n\n  if (LEGACY_LONG_GOP_TOKEN_REGEX.test(lower)) {\n    return 'utf16';\n  }\n\n  return null;\n}\n\nfunction normalizeLegacyLongGopString(value) {\n  if (typeof value !== 'string') {\n    return value;\n  }\n\n  const trimmed = value.trim();\n  if (LEGACY_LONG_GOP_TOKEN_REGEX.test(trimmed)) {\n    return 'long-gop';\n  }\n\n  return value;\n}\n\nfunction normalizeLegacyLongGopKey(key) {\n  if (typeof key !== 'string') {\n    return key;\n  }\n\n  return LEGACY_LONG_GOP_TOKEN_REGEX.test(key) ? 'long-gop' : key;\n}\n\nfunction normalizeLegacyLongGopStructure(value, visited) {\n  if (value === null || typeof value !== 'object') {\n    return normalizeLegacyLongGopString(value);\n  }\n\n  const seen = visited || new WeakSet();\n  if (seen.has(value)) {\n    return value;\n  }\n  seen.add(value);\n\n  if (Array.isArray(value)) {\n    let changed = false;\n    const normalizedArray = value.map((item) => {\n      const normalizedItem = normalizeLegacyLongGopStructure(item, seen);\n      if (normalizedItem !== item) {\n        changed = true;\n      }\n      return normalizedItem;\n    });\n    return changed ? normalizedArray : value;\n  }\n\n  if (isPlainObject(value)) {\n    let changed = false;\n    const normalizedObject = {};\n    Object.keys(value).forEach((key) => {\n      const normalizedKey = normalizeLegacyLongGopKey(key);\n      const originalValue = value[key];\n      const normalizedValue = normalizeLegacyLongGopStructure(originalValue, seen);\n      if (normalizedKey !== key || normalizedValue !== originalValue) {\n        changed = true;\n      }\n      normalizedObject[normalizedKey] = normalizedValue;\n    });\n    return changed ? normalizedObject : value;\n  }\n\n  return normalizeLegacyLongGopString(value);\n}\n\nfunction normalizeLegacyLongGopBackups(backups) {\n  if (!Array.isArray(backups)) {\n    return { normalized: Array.isArray(backups) ? backups : [], changed: false };\n  }\n\n  let changed = false;\n  const normalized = backups.map((entry) => {\n    if (entry === null || entry === undefined) {\n      return entry;\n    }\n    const normalizedEntry = normalizeLegacyLongGopStructure(entry);\n    if (normalizedEntry !== entry) {\n      changed = true;\n    }\n    return normalizedEntry;\n  });\n\n  return { normalized, changed };\n}\n\nfunction parseAutoBackupKey(name) {\n  if (typeof name !== 'string') {\n    return { timestamp: Number.NEGATIVE_INFINITY, label: '' };\n  }\n\n  const parseWithPrefix = (prefix, options = {}) => {\n    const remainder = name.slice(prefix.length);\n    const parts = remainder.split('-');\n    if (parts.length < 5) {\n      return null;\n    }\n\n    const [yearPart, monthPart, dayPart, hourPart, minutePart] = parts;\n    const year = Number.parseInt(yearPart, 10);\n    const month = Number.parseInt(monthPart, 10) - 1;\n    const day = Number.parseInt(dayPart, 10);\n    const hour = Number.parseInt(hourPart, 10);\n    const minute = Number.parseInt(minutePart, 10);\n\n    if ([year, month, day, hour, minute].some(value => Number.isNaN(value))) {\n      return null;\n    }\n\n    let includeSeconds = false;\n    let seconds = 0;\n    let labelStartIndex = 5;\n\n    if (parts.length > labelStartIndex) {\n      const secondsCandidate = parts[labelStartIndex];\n      if (/^\\d{1,2}$/u.test(secondsCandidate)) {\n        includeSeconds = true;\n        seconds = Number.parseInt(secondsCandidate, 10);\n        labelStartIndex += 1;\n      } else if (options.requireSeconds) {\n        return null;\n      }\n    } else if (options.requireSeconds) {\n      return null;\n    }\n\n    const label = parts.slice(labelStartIndex).join('-').trim();\n    const date = new Date(year, month, day, hour, minute, includeSeconds ? seconds : 0, 0);\n    const timestamp = date.getTime();\n\n    if (Number.isNaN(timestamp)) {\n      return null;\n    }\n\n    return { timestamp, label };\n  };\n\n  if (name.startsWith(STORAGE_AUTO_BACKUP_NAME_PREFIX)) {\n    const parsed = parseWithPrefix(STORAGE_AUTO_BACKUP_NAME_PREFIX);\n    if (parsed) {\n      return parsed;\n    }\n    return { timestamp: Number.NEGATIVE_INFINITY, label: '' };\n  }\n\n  if (name.startsWith(STORAGE_AUTO_BACKUP_DELETION_PREFIX)) {\n    const parsed = parseWithPrefix(STORAGE_AUTO_BACKUP_DELETION_PREFIX, { requireSeconds: false });\n    if (parsed) {\n      return parsed;\n    }\n    return { timestamp: Number.NEGATIVE_INFINITY, label: '' };\n  }\n\n  return { timestamp: Number.NEGATIVE_INFINITY, label: '' };\n}\n\nfunction collectAutoBackupEntries(container, prefix) {\n  if (!isPlainObject(container) || typeof prefix !== 'string') {\n    return [];\n  }\n\n  return Object.keys(container)\n    .filter((key) => typeof key === 'string' && key.startsWith(prefix))\n    .map((key) => {\n      const { timestamp, label } = parseAutoBackupKey(key);\n      return { key, timestamp, label };\n    })\n    .sort((a, b) => {\n      if (a.timestamp !== b.timestamp) {\n        return a.timestamp - b.timestamp;\n      }\n      return a.key.localeCompare(b.key);\n    });\n}\n\nfunction markAutoBackupValueAsRenamed(value) {\n  if (!value || typeof value !== 'object') {\n    return;\n  }\n\n  try {\n    value[STORAGE_AUTO_BACKUP_RENAMED_FLAG] = true;\n  } catch (assignmentError) {\n    void assignmentError;\n    try {\n      Object.defineProperty(value, STORAGE_AUTO_BACKUP_RENAMED_FLAG, {\n        configurable: true,\n        enumerable: true,\n        writable: true,\n        value: true,\n      });\n    } catch (definitionError) {\n      void definitionError;\n    }\n  }\n\n  if (isPlainObject(value.projectInfo)) {\n    try {\n      value.projectInfo[STORAGE_AUTO_BACKUP_RENAMED_FLAG] = true;\n    } catch (infoError) {\n      void infoError;\n    }\n  }\n}\n\nfunction isAutoBackupValueRenamed(value) {\n  if (!value || typeof value !== 'object') {\n    return false;\n  }\n  if (value[STORAGE_AUTO_BACKUP_RENAMED_FLAG] === true) {\n    return true;\n  }\n  if (\n    isPlainObject(value.projectInfo)\n    && value.projectInfo[STORAGE_AUTO_BACKUP_RENAMED_FLAG] === true\n  ) {\n    return true;\n  }\n  return false;\n}\n\nfunction isRenamedAutoBackupEntry(container, key) {\n  if (!isPlainObject(container) || typeof key !== 'string') {\n    return false;\n  }\n  return isAutoBackupValueRenamed(container[key]);\n}\n\nfunction getAutoBackupLabelKey(entry) {\n  if (!entry || typeof entry !== 'object') {\n    return '';\n  }\n  if (typeof entry.label === 'string') {\n    const trimmed = entry.label.trim();\n    if (trimmed) {\n      return trimmed;\n    }\n  }\n  if (typeof entry.key === 'string' && entry.key.trim()) {\n    const key = entry.key.trim();\n    if (\n      key.startsWith(STORAGE_AUTO_BACKUP_NAME_PREFIX)\n      || key.startsWith(STORAGE_AUTO_BACKUP_DELETION_PREFIX)\n    ) {\n      return '__auto-backup:unlabeled__';\n    }\n    return key;\n  }\n  return '__auto-backup:unlabeled__';\n}\n\nfunction getAutoBackupEntrySignature(container, entry) {\n  if (!isPlainObject(container) || !entry || typeof entry.key !== 'string') {\n    return 'undefined';\n  }\n  const value = Object.prototype.hasOwnProperty.call(container, entry.key)\n    ? container[entry.key]\n    : undefined;\n  try {\n    let preparedValue = value;\n    if (isPlainObject(value) && value[AUTO_BACKUP_SNAPSHOT_PROPERTY]) {\n      const cloneForSignature = cloneAutoBackupValue(value, { stripMetadata: true });\n      const snapshot = cloneForSignature[AUTO_BACKUP_SNAPSHOT_PROPERTY];\n      if (snapshot && typeof snapshot === 'object') {\n        try {\n          const restored = restoreAutoBackupSnapshotPayload(snapshot, entry.key);\n          snapshot.payload = restored.payload;\n          if (Object.prototype.hasOwnProperty.call(snapshot, 'payloadCompression')) {\n            delete snapshot.payloadCompression;\n          }\n        } catch (payloadError) {\n          console.warn('Failed to expand automatic backup payload for signature comparison', entry.key, payloadError);\n        }\n      }\n      preparedValue = cloneForSignature;\n    }\n\n    const normalizedValue = cloneAutoBackupValueWithLegacyNormalization(preparedValue, {\n      stripMetadata: true,\n    });\n    return createStableValueSignature(normalizedValue);\n  } catch (error) {\n    console.warn('Failed to create stable signature for automatic backup entry', error);\n    return 'undefined';\n  }\n}\n\nfunction createStableValueSignature(value, state) {\n  const signatureState = state || (typeof WeakSet === 'function'\n    ? { seen: new WeakSet(), reportedCycle: false }\n    : null);\n  const seenSet = signatureState && signatureState.seen ? signatureState.seen : null;\n\n  const handleCircularSignature = (input, compute) => {\n    if (!seenSet) {\n      return compute();\n    }\n    if (seenSet.has(input)) {\n      if (!signatureState.reportedCycle\n        && typeof console !== 'undefined'\n        && console\n        && typeof console.warn === 'function') {\n        console.warn(\n          'Detected circular reference while computing automatic backup signature. Using a placeholder token to keep backups stable.',\n        );\n      }\n      signatureState.reportedCycle = true;\n      return AUTO_BACKUP_CYCLE_PLACEHOLDER;\n    }\n    seenSet.add(input);\n    try {\n      return compute();\n    } finally {\n      seenSet.delete(input);\n    }\n  };\n\n  if (value === null) {\n    return 'null';\n  }\n  if (value === undefined) {\n    return 'undefined';\n  }\n  if (Array.isArray(value)) {\n    return handleCircularSignature(value, () => {\n      let signature = '[';\n      for (let index = 0; index < value.length; index += 1) {\n        if (index > 0) {\n          signature += ',';\n        }\n        signature += createStableValueSignature(value[index], signatureState);\n      }\n      signature += ']';\n      return signature;\n    });\n  }\n  if (value instanceof Date) {\n    return handleCircularSignature(value, () => {\n      const timestamp = value.getTime();\n      if (Number.isNaN(timestamp)) {\n        return 'date:invalid';\n      }\n      return `date:${timestamp}`;\n    });\n  }\n  if (isPlainObject(value)) {\n    return handleCircularSignature(value, () => {\n      const keys = Object.keys(value).sort();\n      let signature = '{';\n      for (let index = 0; index < keys.length; index += 1) {\n        const key = keys[index];\n        if (index > 0) {\n          signature += ',';\n        }\n        signature += `${JSON.stringify(key)}:${createStableValueSignature(value[key], signatureState)}`;\n      }\n      signature += '}';\n      return signature;\n    });\n  }\n  if (value && typeof value === 'object') {\n    return handleCircularSignature(value, () => `${typeof value}:${String(value)}`);\n  }\n  if (typeof value === 'number') {\n    if (Number.isNaN(value)) {\n      return 'number:NaN';\n    }\n    if (!Number.isFinite(value)) {\n      return value > 0 ? 'number:Infinity' : 'number:-Infinity';\n    }\n    return `number:${value}`;\n  }\n  if (typeof value === 'bigint') {\n    return `bigint:${value.toString()}`;\n  }\n  if (typeof value === 'boolean') {\n    return value ? 'boolean:true' : 'boolean:false';\n  }\n  if (typeof value === 'string') {\n    const decoded = decodeCompressedJsonStorageValue(value);\n    if (decoded.success && typeof decoded.value === 'string') {\n      try {\n        const parsed = JSON.parse(decoded.value);\n        return createStableValueSignature(parsed, signatureState);\n      } catch (signatureParseError) {\n        console.warn(\n          'Unable to decode compressed string while computing stable value signature',\n          signatureParseError,\n        );\n      }\n    }\n    return `string:${value}`;\n  }\n  if (typeof value === 'symbol') {\n    return `symbol:${String(value)}`;\n  }\n  if (typeof value === 'function') {\n    return `function:${value.name || 'anonymous'}`;\n  }\n  return `${typeof value}:${String(value)}`;\n}\n\nfunction removeSingleDuplicateAutoBackupEntry(container, entries) {\n  if (!isPlainObject(container) || !Array.isArray(entries) || entries.length < 2) {\n    return null;\n  }\n\n  const seenSignaturesByLabel = new Map();\n\n  for (let index = entries.length - 1; index >= 0; index -= 1) {\n    const entry = entries[index];\n    if (!entry || typeof entry.key !== 'string') {\n      continue;\n    }\n    if (isRenamedAutoBackupEntry(container, entry.key)) {\n      continue;\n    }\n\n    const labelKey = getAutoBackupLabelKey(entry);\n    let labelSignatures = seenSignaturesByLabel.get(labelKey);\n    if (!labelSignatures) {\n      labelSignatures = new Map();\n      seenSignaturesByLabel.set(labelKey, labelSignatures);\n    }\n\n    const value = Object.prototype.hasOwnProperty.call(container, entry.key)\n      ? container[entry.key]\n      : undefined;\n    const signature = createStableValueSignature(value);\n    const seen = labelSignatures.get(signature);\n\n    if (seen && typeof seen.key === 'string') {\n      delete container[entry.key];\n      entries.splice(index, 1);\n\n      if (\n        typeof console !== 'undefined'\n        && typeof console.info === 'function'\n      ) {\n        console.info('Removed duplicate automatic backup while preserving newer copy.', {\n          removedKey: entry.key,\n          preservedKey: seen.key,\n          label: labelKey,\n        });\n      }\n\n      return entry.key;\n    }\n\n    labelSignatures.set(signature, {\n      key: entry.key,\n      signature,\n    });\n  }\n\n  return null;\n}\n\nfunction removeDuplicateAutoBackupEntries(container, entries) {\n  const removedKeys = [];\n  while (true) {\n    const removedKey = removeSingleDuplicateAutoBackupEntry(container, entries);\n    if (!removedKey) {\n      break;\n    }\n    removedKeys.push(removedKey);\n  }\n  return removedKeys;\n}\n\nfunction pruneAutoBackupEntries(container, entries, limit, removedKeys) {\n  if (!isPlainObject(container) || !Array.isArray(entries) || entries.length <= limit) {\n    return;\n  }\n\n  const duplicateBuckets = new Map();\n  for (let index = 0; index < entries.length; index += 1) {\n    const entry = entries[index];\n    if (!entry || typeof entry.key !== 'string') {\n      continue;\n    }\n    const labelKey = getAutoBackupLabelKey(entry);\n    const signature = getAutoBackupEntrySignature(container, entry);\n    const bucketKey = `${labelKey}__${signature}`;\n    const existing = duplicateBuckets.get(bucketKey);\n    if (existing) {\n      existing.push(index);\n    } else {\n      duplicateBuckets.set(bucketKey, [index]);\n    }\n  }\n\n  const removable = Array.from(duplicateBuckets.values())\n    .filter(indexes => Array.isArray(indexes) && indexes.length > 1)\n    .flatMap(indexes => indexes.slice(0, -1))\n    .sort((a, b) => a - b);\n\n  if (!removable.length) {\n    if (entries.length > limit) {\n      console.warn(\n        'Skipped trimming automatic backups because all remaining versions are unique.',\n        { limit, total: entries.length },\n      );\n    }\n    return;\n  }\n\n  for (let i = removable.length - 1; i >= 0 && entries.length > limit; i -= 1) {\n    const index = removable[i];\n    const entry = entries[index];\n    if (!entry || typeof entry.key !== 'string') {\n      continue;\n    }\n    if (isRenamedAutoBackupEntry(container, entry.key)) {\n      continue;\n    }\n    delete container[entry.key];\n    entries.splice(index, 1);\n    removedKeys.push(entry.key);\n  }\n\n  if (entries.length > limit) {\n    console.warn(\n      'Unable to trim automatic backups down to the configured limit without losing unique data.',\n      { limit, remaining: entries.length },\n    );\n  }\n}\n\nfunction enforceAutoBackupLimits(container) {\n  if (!isPlainObject(container)) {\n    return [];\n  }\n\n  const removed = [];\n\n  const autoBackups = collectAutoBackupEntries(container, STORAGE_AUTO_BACKUP_NAME_PREFIX);\n  removed.push(...removeDuplicateAutoBackupEntries(container, autoBackups));\n  if (autoBackups.length > MAX_AUTO_BACKUPS) {\n    pruneAutoBackupEntries(container, autoBackups, MAX_AUTO_BACKUPS, removed);\n  }\n\n  const deletionBackups = collectAutoBackupEntries(container, STORAGE_AUTO_BACKUP_DELETION_PREFIX);\n  removed.push(...removeDuplicateAutoBackupEntries(container, deletionBackups));\n  if (deletionBackups.length > MAX_DELETION_BACKUPS) {\n    pruneAutoBackupEntries(container, deletionBackups, MAX_DELETION_BACKUPS, removed);\n  }\n\n  if (removed.length > 0) {\n    console.warn(\n      `Removed ${removed.length} older automatic backup${removed.length > 1 ? 's' : ''} to stay within storage limits.`,\n      removed,\n    );\n  }\n\n  return removed;\n}\n\nfunction removeOldestAutoBackupEntry(container, options = {}) {\n  if (!isPlainObject(container)) {\n    return null;\n  }\n\n  const { force = false } = options;\n\n  const removeFromEntries = (entries, { respectRename = true } = {}) => {\n    if (!Array.isArray(entries) || entries.length === 0) {\n      return null;\n    }\n\n    for (let index = 0; index < entries.length; index += 1) {\n      const entry = entries[index];\n      if (!entry || typeof entry.key !== 'string') {\n        continue;\n      }\n\n      const hasValue = Object.prototype.hasOwnProperty.call(container, entry.key);\n      const value = hasValue ? container[entry.key] : undefined;\n\n      if (!hasValue || value === undefined || value === null || typeof value !== 'object') {\n        delete container[entry.key];\n        return entry.key;\n      }\n\n      if (respectRename && isRenamedAutoBackupEntry(container, entry.key)) {\n        continue;\n      }\n\n      delete container[entry.key];\n      return entry.key;\n    }\n\n    return null;\n  };\n\n  const autoBackups = collectAutoBackupEntries(container, STORAGE_AUTO_BACKUP_NAME_PREFIX);\n  const duplicateAutoBackupKey = removeSingleDuplicateAutoBackupEntry(container, autoBackups);\n  if (duplicateAutoBackupKey) {\n    return duplicateAutoBackupKey;\n  }\n\n  const deletionBackups = collectAutoBackupEntries(container, STORAGE_AUTO_BACKUP_DELETION_PREFIX);\n  const duplicateDeletionBackupKey = removeSingleDuplicateAutoBackupEntry(container, deletionBackups);\n  if (duplicateDeletionBackupKey) {\n    return duplicateDeletionBackupKey;\n  }\n\n  const oldestDeletionBackupKey = removeFromEntries(deletionBackups, { respectRename: false });\n  if (oldestDeletionBackupKey) {\n    return oldestDeletionBackupKey;\n  }\n  if (deletionBackups.length > 0) {\n    console.warn(\n      'Unable to free space by removing pre-deletion backups because all copies appear to be protected.',\n    );\n  }\n\n  const oldestAutoBackupKey = removeFromEntries(autoBackups, { respectRename: !force });\n  if (oldestAutoBackupKey) {\n    return oldestAutoBackupKey;\n  }\n  if (autoBackups.length > 0) {\n    console.warn(\n      'Unable to free space by removing automatic backups because the remaining copies were renamed or protected.',\n    );\n  }\n\n  return null;\n}\n\n\n\nfunction describeAutoGearBackupEntry(entry) {\n  if (!entry || typeof entry !== 'object') {\n    return '';\n  }\n\n  if (typeof entry.note === 'string') {\n    const trimmedNote = entry.note.trim();\n    if (trimmedNote) {\n      return trimmedNote;\n    }\n  }\n\n  if (typeof entry.createdAt === 'string') {\n    const trimmedTimestamp = entry.createdAt.trim();\n    if (trimmedTimestamp) {\n      return trimmedTimestamp;\n    }\n  }\n\n  if (typeof entry.id === 'string') {\n    return entry.id;\n  }\n\n  return '';\n}\n\nfunction removeOldestAutoGearBackupEntry(backups) {\n  if (!Array.isArray(backups) || backups.length === 0) {\n    return null;\n  }\n\n  const removeAt = (index) => {\n    const [removed] = backups.splice(index, 1);\n    return {\n      removed,\n      label: describeAutoGearBackupEntry(removed),\n    };\n  };\n\n  for (let index = backups.length - 1; index >= 0; index -= 1) {\n    const entry = backups[index];\n    if (!entry || typeof entry !== 'object') {\n      return removeAt(index);\n    }\n    if (!Array.isArray(entry.rules)) {\n      return removeAt(index);\n    }\n  }\n\n  return removeAt(backups.length - 1);\n}\n\nfunction cleanupAutoGearBackupMigrationCopies(storage) {\n  if (!storage || typeof storage.getItem !== 'function' || typeof storage.removeItem !== 'function') {\n    return false;\n  }\n\n  const migrationBackupKey = `${AUTO_GEAR_BACKUPS_STORAGE_KEY}${STORAGE_MIGRATION_BACKUP_SUFFIX}`;\n  const removedKeys = [];\n\n  try {\n    const existing = storage.getItem(migrationBackupKey);\n    if (existing !== null && existing !== undefined) {\n      storage.removeItem(migrationBackupKey);\n      removedKeys.push(migrationBackupKey);\n    }\n  } catch (error) {\n    console.warn(\n      'Unable to inspect automatic gear backup migration snapshot while recovering storage quota.',\n      error,\n    );\n  }\n\n  try {\n    const pruned = pruneMigrationBackupEntriesForCleanup(storage, migrationBackupKey);\n    if (Array.isArray(pruned) && pruned.length > 0) {\n      removedKeys.push(...pruned);\n    }\n  } catch (error) {\n    console.warn('Unable to prune migration backups while recovering storage for automatic gear backups.', error);\n  }\n\n  if (removedKeys.length > 0) {\n    console.warn(\n      `Removed ${removedKeys.length} migration backup${removedKeys.length > 1 ? 's' : ''} while freeing storage for automatic gear backups.`,\n      removedKeys,\n    );\n    return true;\n  }\n\n  return false;\n}\n\nfunction clearCachedPlannerDataForAutoGearBackups() {\n  if (typeof clearUiCacheStorageEntries !== 'function') {\n    return false;\n  }\n\n  try {\n    clearUiCacheStorageEntries();\n    console.warn(\n      'Cleared cached planner data to free up storage space before saving automatic gear backups.',\n    );\n    return true;\n  } catch (error) {\n    console.warn(\n      'Unable to clear cached planner data while recovering storage for automatic gear backups.',\n      error,\n    );\n  }\n\n  return false;\n}\n\nfunction shouldDisplayStorageAlert(reason) {\n  if (!reason) {\n    return true;\n  }\n\n  if (reason === 'migration-read') {\n    if (typeof safeLocalStorageInfo !== 'undefined' && safeLocalStorageInfo) {\n      if (safeLocalStorageInfo.type && safeLocalStorageInfo.type !== 'memory') {\n        return false;\n      }\n    }\n  }\n\n  return true;\n}\n\nfunction alertStorageError(reason) {\n  if (!shouldDisplayStorageAlert(reason)) {\n    return;\n  }\n\n  if (GLOBAL_SCOPE && typeof GLOBAL_SCOPE[STORAGE_ALERT_FLAG_NAME] === 'boolean') {\n    storageErrorAlertShown = GLOBAL_SCOPE[STORAGE_ALERT_FLAG_NAME];\n  }\n\n  if (storageErrorAlertShown) {\n    return;\n  }\n\n  storageErrorAlertShown = true;\n  if (GLOBAL_SCOPE) {\n    GLOBAL_SCOPE[STORAGE_ALERT_FLAG_NAME] = true;\n  }\n\n  if (typeof window === 'undefined' || typeof window.alert !== 'function') return;\n  let msg = 'Storage error: Unable to access local data. Changes may not be saved.';\n  try {\n    if (typeof window !== 'undefined' && window.texts) {\n      const texts = window.texts;\n      const currentLang = window.currentLang || 'en';\n      const lang = texts[currentLang] ? currentLang : 'en';\n      msg = texts[lang]?.alertStorageError || msg;\n    }\n  } catch (err) {\n    void err;\n    // ignore and fall back to default\n  }\n  window.alert(msg);\n}\n\nfunction alertSessionFallback() {\n  if (sessionFallbackAlertShown) {\n    return;\n  }\n\n  sessionFallbackAlertShown = true;\n  if (GLOBAL_SCOPE) {\n    GLOBAL_SCOPE[SESSION_FALLBACK_ALERT_FLAG_NAME] = true;\n  }\n\n  if (typeof window === 'undefined' || typeof window.alert !== 'function') return;\n\n  let msg = 'Warning: Local storage is unavailable. Data will only persist for this browser tab.';\n  try {\n    if (typeof window !== 'undefined' && window.texts) {\n      const texts = window.texts;\n      const currentLang = window.currentLang || 'en';\n      const lang = texts[currentLang] ? currentLang : 'en';\n      msg = texts[lang]?.alertSessionFallback || msg;\n    }\n  } catch (err) {\n    void err;\n    // ignore and fall back to default\n  }\n\n  window.alert(msg);\n}\n\nfunction getWindowStorage(name) {\n  if (typeof window === 'undefined') {\n    return null;\n  }\n\n  try {\n    return window[name];\n  } catch (error) {\n    console.warn(`Unable to access ${name} during legacy migration`, error);\n    return null;\n  }\n}\n\nfunction collectUniqueStorages(storages) {\n  if (!Array.isArray(storages) || storages.length === 0) {\n    return [];\n  }\n\n  const unique = [];\n  const seen = new Set();\n\n  for (let i = 0; i < storages.length; i += 1) {\n    const storage = storages[i];\n    if (!storage || typeof storage.getItem !== 'function' || seen.has(storage)) {\n      continue;\n    }\n\n    seen.add(storage);\n    unique.push(storage);\n  }\n\n  return unique;\n}\n\nfunction migrateKeyBetweenStorages(source, target, legacyKey, modernKey, options = {}) {\n  if (!source || typeof source.getItem !== 'function') {\n    return false;\n  }\n\n  const { keepLegacy = false } = options;\n\n  let legacyValue;\n  try {\n    legacyValue = source.getItem(legacyKey);\n  } catch (error) {\n    console.warn(`Unable to read legacy storage key ${legacyKey}`, error);\n    alertStorageError('migration-read');\n    return false;\n  }\n\n  if (legacyValue === null || legacyValue === undefined) {\n    return false;\n  }\n\n  const destination = target && typeof target.setItem === 'function' ? target : source;\n\n  try {\n    const existing = destination.getItem(modernKey);\n    if (existing !== null && existing !== undefined) {\n      if (!keepLegacy && (source !== destination || legacyKey !== modernKey)) {\n        try {\n          source.removeItem(legacyKey);\n        } catch (removeError) {\n          console.warn(`Unable to remove legacy storage key ${legacyKey}`, removeError);\n        }\n      }\n      return false;\n    }\n  } catch (readError) {\n    console.warn(`Unable to inspect destination storage for ${modernKey}`, readError);\n  }\n\n  try {\n    destination.setItem(modernKey, legacyValue);\n  } catch (writeError) {\n    console.warn(`Unable to migrate legacy storage key ${legacyKey}`, writeError);\n    return false;\n  }\n\n  if (!keepLegacy) {\n    try {\n      source.removeItem(legacyKey);\n    } catch (removeError) {\n      console.warn(`Unable to remove legacy storage key ${legacyKey} after migration`, removeError);\n    }\n  }\n\n  return true;\n}\n\nfunction migrateKeyInStorages(storages, preferredTarget, legacyKey, modernKey, options) {\n  let migrated = false;\n  for (let i = 0; i < storages.length; i += 1) {\n    if (migrateKeyBetweenStorages(storages[i], preferredTarget, legacyKey, modernKey, options)) {\n      migrated = true;\n    }\n  }\n  return migrated;\n}\n\nfunction migrateLegacyStorageKeys() {\n  const safeStorage = getSafeLocalStorage();\n  const localStorages = collectUniqueStorages([\n    getWindowStorage('localStorage'),\n    safeStorage,\n  ]);\n  const sessionStorages = collectUniqueStorages([\n    getWindowStorage('sessionStorage'),\n    typeof sessionStorage !== 'undefined' ? sessionStorage : null,\n  ]);\n\n  const legacyPrefix = 'cinePowerPlanner_';\n\n  const mappings = [\n    { legacy: `${legacyPrefix}devices`, modern: DEVICE_STORAGE_KEY },\n    { legacy: `${legacyPrefix}setups`, modern: SETUP_STORAGE_KEY },\n    { legacy: `${legacyPrefix}session`, modern: SESSION_STATE_KEY, includeSession: true },\n    { legacy: `${legacyPrefix}feedback`, modern: FEEDBACK_STORAGE_KEY },\n    { legacy: `${legacyPrefix}project`, modern: PROJECT_STORAGE_KEY },\n    { legacy: `${legacyPrefix}projects`, modern: PROJECT_STORAGE_KEY },\n    { legacy: `${legacyPrefix}favorites`, modern: FAVORITES_STORAGE_KEY },\n    { legacy: `${legacyPrefix}ownGear`, modern: OWN_GEAR_STORAGE_KEY },\n    { legacy: `${legacyPrefix}schemaCache`, modern: DEVICE_SCHEMA_CACHE_KEY },\n    { legacy: `${legacyPrefix}autoGearRules`, modern: AUTO_GEAR_RULES_STORAGE_KEY },\n    { legacy: `${legacyPrefix}autoGearBackups`, modern: AUTO_GEAR_BACKUPS_STORAGE_KEY },\n    { legacy: `${legacyPrefix}autoGearSeeded`, modern: AUTO_GEAR_SEEDED_STORAGE_KEY },\n    { legacy: `${legacyPrefix}autoGearPresets`, modern: AUTO_GEAR_PRESETS_STORAGE_KEY },\n    { legacy: `${legacyPrefix}autoGearActivePreset`, modern: AUTO_GEAR_ACTIVE_PRESET_STORAGE_KEY },\n    { legacy: `${legacyPrefix}autoGearAutoPreset`, modern: AUTO_GEAR_AUTO_PRESET_STORAGE_KEY },\n    { legacy: `${legacyPrefix}autoGearShowBackups`, modern: AUTO_GEAR_BACKUP_VISIBILITY_STORAGE_KEY },\n    { legacy: `${legacyPrefix}autoGearBackupRetention`, modern: AUTO_GEAR_BACKUP_RETENTION_STORAGE_KEY },\n    { legacy: `${legacyPrefix}autoGearMonitorDefaults`, modern: AUTO_GEAR_MONITOR_DEFAULTS_STORAGE_KEY },\n    { legacy: `${legacyPrefix}customFonts`, modern: CUSTOM_FONT_STORAGE_KEY_DEFAULT, updateFontKey: true },\n  ];\n\n  mappings.forEach(({ legacy, modern, includeSession = false, updateFontKey = false }) => {\n    const migratedLocal = migrateKeyInStorages(localStorages, safeStorage, legacy, modern);\n    migrateKeyInStorages(\n      localStorages,\n      safeStorage,\n      `${legacy}${STORAGE_BACKUP_SUFFIX}`,\n      `${modern}${STORAGE_BACKUP_SUFFIX}`,\n    );\n\n    if (includeSession) {\n      migrateKeyInStorages(sessionStorages, null, legacy, modern);\n      migrateKeyInStorages(\n        sessionStorages,\n        null,\n        `${legacy}${STORAGE_BACKUP_SUFFIX}`,\n        `${modern}${STORAGE_BACKUP_SUFFIX}`,\n      );\n    }\n\n    if (updateFontKey && migratedLocal && GLOBAL_SCOPE) {\n      if (GLOBAL_SCOPE.CUSTOM_FONT_STORAGE_KEY === legacy) {\n        GLOBAL_SCOPE.CUSTOM_FONT_STORAGE_KEY = modern;\n      }\n      if (GLOBAL_SCOPE.CUSTOM_FONT_STORAGE_KEY_NAME === legacy) {\n        GLOBAL_SCOPE.CUSTOM_FONT_STORAGE_KEY_NAME = modern;\n      }\n    }\n  });\n}\n\nfunction applyLegacyStorageMigrations() {\n  migrateLegacyStorageKeys();\n}\n\n// Generic helpers for storage access\nfunction isSessionStorageInstance(storage) {\n  if (!storage || typeof storage.getItem !== 'function') {\n    return false;\n  }\n\n  if (\n    knownSessionStorages\n    && typeof knownSessionStorages.has === 'function'\n    && knownSessionStorages.has(storage)\n  ) {\n    return true;\n  }\n\n  if (\n    safeLocalStorageInfo\n    && safeLocalStorageInfo.type === 'session'\n    && safeLocalStorageInfo.storage === storage\n  ) {\n    registerKnownSessionStorage(storage);\n    return true;\n  }\n\n  const safeLocal = getSafeLocalStorage();\n  if (\n    safeLocal\n    && safeLocalStorageInfo\n    && safeLocalStorageInfo.type === 'session'\n    && safeLocal === storage\n  ) {\n    registerKnownSessionStorage(storage);\n    return true;\n  }\n\n  const scopes = [\n    GLOBAL_SCOPE,\n    GLOBAL_SCOPE && GLOBAL_SCOPE.__cineGlobal ? GLOBAL_SCOPE.__cineGlobal : null,\n    GLOBAL_SCOPE && GLOBAL_SCOPE.window ? GLOBAL_SCOPE.window : null,\n    typeof window !== 'undefined' ? window : null,\n    typeof self !== 'undefined' ? self : null,\n    typeof global !== 'undefined' ? global : null,\n  ];\n\n  for (let index = 0; index < scopes.length; index += 1) {\n    const candidate = resolveSessionStorageFromScope(scopes[index]);\n    if (candidate && candidate === storage) {\n      registerKnownSessionStorage(candidate);\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction loadJSONFromStorage(\n  storage,\n  key,\n  errorMessage,\n  defaultValue = null,\n  options = {},\n) {\n  if (!storage) return defaultValue;\n\n  const {\n    disableBackup = false,\n    backupKey,\n    validate,\n    restoreIfMissing = false,\n    alertOnFailure = null,\n    migrationBackupKey,\n  } = options || {};\n\n  const fallbackKey = typeof backupKey === 'string' && backupKey\n    ? backupKey\n    : `${key}${STORAGE_BACKUP_SUFFIX}`;\n  const useBackup = !disableBackup && fallbackKey && fallbackKey !== key;\n  const skipBackupRecovery = isFactoryResetActive() || (GLOBAL_SCOPE && GLOBAL_SCOPE.__cineJustFactoryReset);\n  const allowBackupRecovery = useBackup && !skipBackupRecovery;\n  const allowMigrationBackupRecovery = !skipBackupRecovery;\n\n  const migrationBackupCandidates = (() => {\n    const seen = new Set();\n    const candidates = [];\n\n    const pushCandidate = (candidate) => {\n      if (typeof candidate !== 'string' || !candidate || seen.has(candidate)) {\n        return;\n      }\n      seen.add(candidate);\n      candidates.push(candidate);\n    };\n\n    if (typeof migrationBackupKey === 'string' && migrationBackupKey) {\n      pushCandidate(migrationBackupKey);\n    }\n\n    const variants = getStorageKeyVariants(key);\n    for (let i = 0; i < variants.length; i += 1) {\n      pushCandidate(`${variants[i]}${STORAGE_MIGRATION_BACKUP_SUFFIX}`);\n    }\n\n    return candidates;\n  })();\n\n  const rawGetter = getRawStorageGetter(storage);\n  let rawStoredValue =\n    typeof rawGetter === 'function'\n      ? readRawStorageValue(storage, key, rawGetter)\n      : undefined;\n\n  let shouldAlert = false;\n\n  const parseRawValue = (raw, label) => {\n    if (raw === null || raw === undefined) {\n      return { ok: false, reason: 'missing' };\n    }\n    const normalizedRaw = typeof raw === 'string'\n      ? maybeDecompressStoredString(raw)\n      : raw;\n\n    if (\n      typeof raw === 'string'\n      && raw\n      && normalizedRaw === raw\n      && raw.includes(`\"${STORAGE_COMPRESSION_FLAG_KEY}\":true`)\n      && raw.includes(`\"namespace\":\"${STORAGE_COMPRESSION_NAMESPACE}`)\n    ) {\n      console.warn(\n        `${errorMessage} Compressed value could not be decoded${label ? ` (${label})` : ''}.`,\n      );\n      shouldAlert = true;\n      return { ok: false, reason: 'compressed' };\n    }\n    try {\n      const parsed = JSON.parse(normalizedRaw);\n      if (typeof validate === 'function' && !validate(parsed)) {\n        console.warn(`${errorMessage} Invalid data${label ? ` (${label})` : ''}.`);\n        shouldAlert = true;\n        return { ok: false, reason: 'invalid' };\n      }\n      return {\n        ok: true,\n        value: parsed,\n        raw,\n        normalizedRaw,\n      };\n    } catch (err) {\n      console.error(`${errorMessage}${label ? ` (${label})` : ''}`, err);\n      shouldAlert = true;\n      return { ok: false, reason: 'error' };\n    }\n  };\n\n  let primaryRaw = null;\n  try {\n    primaryRaw = storage.getItem(key);\n  } catch (err) {\n    console.error(`${errorMessage} (read)`, err);\n    downgradeSafeLocalStorageToMemory('read access', err, storage);\n    shouldAlert = true;\n  }\n\n  if (typeof rawStoredValue === 'undefined' && typeof rawGetter === 'function') {\n    rawStoredValue = readRawStorageValue(storage, key, rawGetter);\n  }\n\n  if (\n    (primaryRaw === null || primaryRaw === undefined)\n    && (rawStoredValue === null || rawStoredValue === undefined)\n  ) {\n    clearCachedStorageEntry(storage, key);\n  }\n\n  const cachedPrimary = tryGetCachedStorageValue(storage, key, primaryRaw, rawStoredValue);\n  if (cachedPrimary.hit) {\n    return cachedPrimary.value;\n  }\n\n  const primary = parseRawValue(primaryRaw, '');\n  if (primary.ok) {\n    const normalizedForCache = typeof primary.normalizedRaw === 'string' && primary.normalizedRaw\n      ? primary.normalizedRaw\n      : typeof primary.raw === 'string' && primary.raw\n        ? primary.raw\n        : null;\n    const rawForCache = typeof rawStoredValue === 'string' && rawStoredValue\n      ? rawStoredValue\n      : typeof primary.raw === 'string' && primary.raw\n        ? primary.raw\n        : null;\n    cacheStorageValue(storage, key, rawForCache, normalizedForCache, primary.value);\n    return primary.value;\n  }\n\n  const missingPrimary = !primary.ok && primary.reason === 'missing';\n\n  const attemptMigrationBackupRecovery = () => {\n    if (!migrationBackupCandidates.length) {\n      return { success: false, shouldAlert: false };\n    }\n\n    for (let i = 0; i < migrationBackupCandidates.length; i += 1) {\n      const candidateKey = migrationBackupCandidates[i];\n      let migrationRaw = null;\n      let migrationRawStored;\n\n      try {\n        migrationRaw = storage.getItem(candidateKey);\n      } catch (migrationReadError) {\n        console.error(`${errorMessage} (migration backup read)`, migrationReadError);\n        downgradeSafeLocalStorageToMemory('read access', migrationReadError, storage);\n        return { success: false, shouldAlert: true };\n      }\n\n      if (typeof rawGetter === 'function') {\n        migrationRawStored = readRawStorageValue(storage, candidateKey, rawGetter);\n      }\n\n      if (\n        (migrationRaw === null || migrationRaw === undefined)\n        && (migrationRawStored === null || migrationRawStored === undefined)\n      ) {\n        clearCachedStorageEntry(storage, candidateKey);\n        continue;\n      }\n\n      const rawSource = migrationRaw !== null && migrationRaw !== undefined\n        ? migrationRaw\n        : migrationRawStored;\n\n      const entry = { key: candidateKey, value: rawSource, type: 'migration-backup' };\n      const extracted = extractSnapshotStoredValue(entry);\n\n      if (typeof extracted === 'undefined') {\n        continue;\n      }\n\n      let candidateValue = extracted;\n      if (typeof candidateValue === 'string') {\n        const trimmed = candidateValue.trim();\n        if (trimmed) {\n          try {\n            candidateValue = JSON.parse(trimmed);\n          } catch (parseError) {\n            void parseError;\n          }\n        } else {\n          candidateValue = '';\n        }\n      }\n\n      if (typeof validate === 'function' && !validate(candidateValue)) {\n        console.warn(`Ignored migration backup for ${key} because it failed validation.`);\n        continue;\n      }\n\n      const migrationRawForCache = typeof migrationRawStored === 'string' && migrationRawStored\n        ? migrationRawStored\n        : typeof rawSource === 'string' && rawSource\n          ? rawSource\n          : null;\n      const normalizedMigrationRaw = typeof rawSource === 'string' && rawSource\n        ? rawSource\n        : typeof migrationRawStored === 'string' && migrationRawStored\n          ? migrationRawStored\n          : null;\n      cacheStorageValue(\n        storage,\n        candidateKey,\n        migrationRawForCache,\n        normalizedMigrationRaw,\n        candidateValue,\n      );\n\n      let serializedCandidate = null;\n      try {\n        serializedCandidate = JSON.stringify(candidateValue);\n      } catch (serializationError) {\n        console.warn(`Unable to serialize recovered migration backup for ${key}`, serializationError);\n        serializedCandidate = null;\n      }\n\n      let restoredRawValue = null;\n      let shouldEscalate = false;\n\n      if (serializedCandidate !== null) {\n        let payloadToStore = serializedCandidate;\n        const recompressed = typeof serializedCandidate === 'string'\n          ? createCompressedJsonStorageCandidate(serializedCandidate)\n          : null;\n        if (recompressed && typeof recompressed.serialized === 'string') {\n          payloadToStore = recompressed.serialized;\n        }\n\n        try {\n          storage.setItem(key, payloadToStore);\n          restoredRawValue = payloadToStore;\n        } catch (restoreError) {\n          console.warn(`Unable to restore primary copy for ${key} from migration backup`, restoreError);\n          downgradeSafeLocalStorageToMemory('write access', restoreError, storage);\n          shouldEscalate = true;\n        }\n      } else {\n        shouldEscalate = true;\n      }\n\n      if (restoredRawValue !== null) {\n        cacheStorageValue(storage, key, restoredRawValue, serializedCandidate, candidateValue);\n      } else if (serializedCandidate !== null) {\n        cacheStorageValue(storage, key, serializedCandidate, serializedCandidate, candidateValue);\n      } else {\n        cacheStorageValue(storage, key, null, null, candidateValue);\n      }\n\n      console.warn(\n        restoredRawValue !== null\n          ? `Recovered ${key} from migration backup copy.`\n          : `Recovered ${key} from migration backup copy but could not rewrite the primary entry.`,\n      );\n\n      // Remove the migration backup to prevent repeated recovery loops\n      try {\n        storage.removeItem(candidateKey);\n        clearCachedStorageEntry(storage, candidateKey);\n      } catch (removeError) {\n        console.warn(`Unable to remove migration backup ${candidateKey} after recovery`, removeError);\n      }\n\n      return { success: true, value: candidateValue, shouldAlert: shouldEscalate };\n    }\n\n    return { success: false, shouldAlert: false };\n  };\n\n  const shouldAttemptBackup =\n    allowBackupRecovery && (shouldAlert || restoreIfMissing || missingPrimary);\n\n  if (shouldAttemptBackup) {\n    let backupRaw = null;\n    try {\n      backupRaw = storage.getItem(fallbackKey);\n    } catch (err) {\n      console.error(`${errorMessage} (backup read)`, err);\n      downgradeSafeLocalStorageToMemory('read access', err, storage);\n      shouldAlert = true;\n    }\n\n    const backupRawStored = typeof rawGetter === 'function'\n      ? readRawStorageValue(storage, fallbackKey, rawGetter)\n      : undefined;\n    const backup = parseRawValue(backupRaw, 'backup');\n    if (backup.ok) {\n      if (shouldAlert || missingPrimary) {\n        console.warn(`Recovered ${key} from backup copy.`);\n      }\n      if (backup.raw !== null && backup.raw !== undefined) {\n        let restoredRawValue = null;\n        try {\n          if (typeof backup.raw === 'string') {\n            const recompressSource = typeof backup.normalizedRaw === 'string'\n              && backup.normalizedRaw\n              ? backup.normalizedRaw\n              : backup.raw;\n            const recompressed = createCompressedJsonStorageCandidate(recompressSource);\n            if (recompressed && typeof recompressed.serialized === 'string') {\n              storage.setItem(key, recompressed.serialized);\n              restoredRawValue = recompressed.serialized;\n            } else if (recompressSource !== backup.raw) {\n              storage.setItem(key, recompressSource);\n              restoredRawValue = recompressSource;\n            } else {\n              storage.setItem(key, backup.raw);\n              restoredRawValue = backup.raw;\n            }\n          } else {\n            storage.setItem(key, backup.raw);\n            restoredRawValue = typeof backup.raw === 'string' ? backup.raw : null;\n          }\n        } catch (restoreError) {\n          console.warn(`Unable to restore primary copy for ${key} from backup`, restoreError);\n          restoredRawValue = null;\n        }\n\n        const normalizedBackup = typeof backup.normalizedRaw === 'string' && backup.normalizedRaw\n          ? backup.normalizedRaw\n          : typeof backup.raw === 'string' && backup.raw\n            ? backup.raw\n            : null;\n        const fallbackRawForCache = typeof backupRawStored === 'string' && backupRawStored\n          ? backupRawStored\n          : typeof backup.raw === 'string' && backup.raw\n            ? backup.raw\n            : null;\n        cacheStorageValue(storage, fallbackKey, fallbackRawForCache, normalizedBackup, backup.value);\n        if (typeof restoredRawValue === 'string' && restoredRawValue) {\n          cacheStorageValue(storage, key, restoredRawValue, normalizedBackup, backup.value);\n        }\n        return backup.value;\n      }\n    }\n  }\n\n  const shouldAttemptMigrationBackup =\n    allowMigrationBackupRecovery\n    && migrationBackupCandidates.length > 0\n    && (missingPrimary || restoreIfMissing || shouldAlert);\n\n  if (shouldAttemptMigrationBackup) {\n    const migrationRecovery = attemptMigrationBackupRecovery();\n    if (migrationRecovery.success) {\n      if (migrationRecovery.shouldAlert) {\n        shouldAlert = true;\n      }\n\n      // Hard cleanup of migration key to ensure no loop\n      if (migrationBackupCandidates.length) {\n        const cleanupKey = migrationBackupCandidates[0].key;\n        try {\n          storage.removeItem(cleanupKey);\n          // Also force delete from internal fallback if present\n          if (storage[STORAGE_RAW_GET_ITEM_PROPERTY] && storage.removeItem) {\n            storage.removeItem(cleanupKey);\n          }\n        } catch (cleanupErr) {\n          console.warn('Post-migration cleanup error:', cleanupErr);\n        }\n      }\n\n      return migrationRecovery.value;\n    }\n    if (migrationRecovery.shouldAlert) {\n      shouldAlert = true;\n    }\n  }\n\n  if (shouldAlert) {\n    alertStorageError(alertOnFailure);\n  }\n\n  clearCachedStorageEntry(storage, key);\n  // Log why we are returning default\n  if (missingPrimary && !shouldAttemptBackup && !shouldAttemptMigrationBackup) {\n    console.debug(`[Storage] Returning default for ${key} (No primary, no backups found)`);\n  }\n  return defaultValue;\n}\n\nfunction saveJSONToStorage(\n  storage,\n  key,\n  value,\n  errorMessage,\n  options = {},\n) {\n  if (!storage) {\n    console.warn('DEBUG: saveJSONToStorage NO STORAGE');\n    return;\n  }\n  if (isFactoryResetActive()) {\n    console.warn('DEBUG: saveJSONToStorage RESET ACTIVE');\n    return;\n  }\n\n  const {\n    disableBackup = false,\n    backupKey,\n    onQuotaExceeded,\n    enableCompressionSweep = true,\n    disableCompression = false,\n    forceCompressionOnQuota = false,\n  } = options || {};\n  const fallbackKey = typeof backupKey === 'string' && backupKey\n    ? backupKey\n    : `${key}${STORAGE_BACKUP_SUFFIX}`;\n  const useBackup = !disableBackup && fallbackKey && fallbackKey !== key;\n  const sessionScopedStorage = isSessionStorageInstance(storage);\n  const compressionBlocked = sessionScopedStorage || Boolean(disableCompression);\n  const allowQuotaCompression =\n    sessionScopedStorage ? false : forceCompressionOnQuota === true;\n\n  const rawGetter = getRawStorageGetter(storage);\n  const loadRawValue = (targetKey) => readRawStorageValue(storage, targetKey, rawGetter);\n\n  let standardSerializedCache;\n  let standardSerializationComputed = false;\n  let compressionCandidate;\n  let useCompressedSerialization = false;\n  let compressionAttempted = false;\n  let compressionLogged = false;\n\n  const resetSerializationState = () => {\n    standardSerializedCache = undefined;\n    standardSerializationComputed = false;\n    compressionCandidate = undefined;\n    useCompressedSerialization = false;\n    compressionAttempted = false;\n    compressionLogged = false;\n  };\n\n  const computeStandardSerialized = () => {\n    if (standardSerializationComputed) {\n      return standardSerializedCache;\n    }\n    standardSerializationComputed = true;\n    try {\n      standardSerializedCache = JSON.stringify(value);\n    } catch (serializationError) {\n      standardSerializedCache = null;\n      console.error(errorMessage, serializationError);\n      alertStorageError();\n    }\n    return standardSerializedCache;\n  };\n\n  const computeCompressedSerialized = () => {\n    if (compressionCandidate !== undefined) {\n      return compressionCandidate && typeof compressionCandidate.serialized === 'string'\n        ? compressionCandidate.serialized\n        : null;\n    }\n\n    const baseline = computeStandardSerialized();\n    if (typeof baseline !== 'string' || !baseline) {\n      compressionCandidate = null;\n      return null;\n    }\n\n    const candidate = createCompressedJsonStorageCandidate(baseline);\n    if (!candidate || typeof candidate.serialized !== 'string') {\n      compressionCandidate = null;\n      return null;\n    }\n\n    compressionCandidate = candidate;\n    return candidate.serialized;\n  };\n\n  const getSerializedForAttempt = () => {\n    if (useCompressedSerialization) {\n      const compressed = computeCompressedSerialized();\n      if (typeof compressed === 'string') {\n        return compressed;\n      }\n      useCompressedSerialization = false;\n    }\n\n    const standard = computeStandardSerialized();\n    if (typeof standard === 'string') {\n      return standard;\n    }\n    return null;\n  };\n\n  const tryEnableCompression = ({ force = false } = {}) => {\n    const forcing = force && allowQuotaCompression;\n    if (compressionBlocked && !forcing) {\n      compressionAttempted = true;\n      return false;\n    }\n    if (useCompressedSerialization) {\n      return false;\n    }\n    if (compressionAttempted && !forcing) {\n      return false;\n    }\n    compressionAttempted = true;\n    const baseline = computeStandardSerialized();\n    if (typeof baseline !== 'string' || !baseline) {\n      return false;\n    }\n    const compressed = computeCompressedSerialized();\n    if (typeof compressed !== 'string' || !compressed) {\n      return false;\n    }\n    if (compressed.length >= baseline.length) {\n      return false;\n    }\n    useCompressedSerialization = true;\n    return true;\n  };\n\n  const logCompressionIfNeeded = () => {\n    if (!useCompressedSerialization || !compressionCandidate || compressionLogged) {\n      return;\n    }\n\n    const { originalLength, wrappedLength } = compressionCandidate;\n    if (\n      typeof originalLength === 'number'\n      && typeof wrappedLength === 'number'\n      && wrappedLength < originalLength\n    ) {\n      const savings = originalLength - wrappedLength;\n      const percent = originalLength > 0 ? Math.round((savings / originalLength) * 100) : 0;\n      const message = `Stored compressed value for ${key} to reduce storage usage by ${savings} characters (${percent}%).`;\n      logCompressionSavingsEvent('storage-value', key, message, savings, percent);\n    }\n\n    compressionLogged = true;\n  };\n\n  const maybeEnableProactiveCompression = () => {\n    if (compressionBlocked) {\n      compressionAttempted = true;\n      return;\n    }\n    if (useCompressedSerialization || compressionAttempted) {\n      return;\n    }\n\n    const baseline = computeStandardSerialized();\n    if (typeof baseline !== 'string' || !baseline) {\n      return;\n    }\n\n    if (baseline.length < STORAGE_PROACTIVE_COMPRESSION_MIN_LENGTH) {\n      return;\n    }\n\n    const compressed = computeCompressedSerialized();\n    if (typeof compressed !== 'string' || !compressed) {\n      return;\n    }\n\n    const savings = baseline.length - compressed.length;\n    if (savings < STORAGE_PROACTIVE_COMPRESSION_MIN_SAVINGS) {\n      return;\n    }\n\n    const ratio = baseline.length > 0 ? savings / baseline.length : 0;\n    if (ratio < STORAGE_PROACTIVE_COMPRESSION_MIN_RATIO) {\n      return;\n    }\n\n    const rawExisting = loadRawValue(key);\n    if (typeof rawExisting === 'string' && rawExisting === compressed) {\n      return;\n    }\n\n    useCompressedSerialization = true;\n    compressionAttempted = true;\n  };\n\n  let preservedBackupValue;\n  let hasPreservedBackup = false;\n  let removedBackupDuringRetry = false;\n  let quotaRecoverySteps = 0;\n  let quotaRecoveryFailed = false;\n  let compressionSweepAttempted = false;\n\n  maybeEnableProactiveCompression();\n\n  const registerQuotaRecoveryStep = () => {\n    quotaRecoverySteps += 1;\n    if (quotaRecoverySteps > MAX_QUOTA_RECOVERY_STEPS) {\n      quotaRecoveryFailed = true;\n      console.warn(`Exceeded maximum storage recovery attempts while saving ${key}.`);\n      return false;\n    }\n    return true;\n  };\n\n  const attemptStorageCleanup = (storage, options) => {\n    if (!storage || typeof storage.length !== 'number' || typeof storage.key !== 'function') {\n      return { success: false, freed: 0 };\n    }\n\n    const { skipKeys = [] } = options || {};\n    const skipSet = new Set(skipKeys);\n    if (ACTIVE_PROJECT_COMPRESSION_HOLD_ENABLED && ACTIVE_PROJECT_COMPRESSION_HOLD_KEY) {\n      skipSet.add(ACTIVE_PROJECT_COMPRESSION_HOLD_KEY);\n    }\n\n    const candidates = [];\n    const total = storage.length;\n\n    for (let i = 0; i < total; i += 1) {\n      let key;\n      try {\n        key = storage.key(i);\n      } catch {\n        continue;\n      }\n\n      if (!key || skipSet.has(key)) continue;\n\n      // Priority 1: Legacy migration backups (safest to delete)\n      if (key.endsWith('__legacyMigrationBackup')) {\n        candidates.push({ key, priority: 1, size: 0 }); // Size calc is expensive, do lazily if needed or just count on priority\n        continue;\n      }\n\n      // Priority 2: Standard backups (safe if we have primary)\n      if (key.endsWith('__backup')) {\n        candidates.push({ key, priority: 2, size: 0 });\n        continue;\n      }\n\n      // Priority 3: Caches (can be rebuilt)\n      if (key === DEVICE_SCHEMA_CACHE_KEY || key === LEGACY_SCHEMA_CACHE_KEY) {\n        candidates.push({ key, priority: 3, size: 0 });\n        continue;\n      }\n\n      // Priority 4: Auto-backup project shards (oldest first, safe to delete)\n      if (key.startsWith(PROJECT_SHARD_PREFIX) && key.includes('auto-backup-')) {\n        candidates.push({ key, priority: 4, size: 0 });\n        continue;\n      }\n    }\n\n    if (!candidates.length) {\n      return { success: false, freed: 0 };\n    }\n\n    // Sort by priority (ascending)\n    candidates.sort((a, b) => a.priority - b.priority);\n\n    let freed = 0;\n    let cleaned = 0;\n\n    for (let i = 0; i < candidates.length; i += 1) {\n      const candidate = candidates[i];\n      try {\n        const val = storage.getItem(candidate.key);\n        const size = val ? val.length : 0;\n        storage.removeItem(candidate.key);\n        clearCachedStorageEntry(storage, candidate.key);\n        freed += size;\n        cleaned += 1;\n        console.warn(`[Storage Cleanup] Removed ${candidate.key} to free ${size} chars.`);\n        // If we freed a significant amount, we might stop, but for now let's be aggressive\n        // to ensure the user's save succeeds.\n        if (freed > 500000) { // Arbitrary threshold to stop if we freed \"enough\"\n          break;\n        }\n      } catch (e) {\n        console.warn(`[Storage Cleanup] Failed to remove ${candidate.key}`, e);\n      }\n    }\n\n    return { success: cleaned > 0, freed };\n  };\n\n  const attemptHandleQuota = (error, context = {}) => {\n    if (!isQuotaExceededError(error)) {\n      return false;\n    }\n\n    if (typeof onQuotaExceeded === 'function') {\n      try {\n        if (\n          onQuotaExceeded(error, {\n            storage,\n            key,\n            value,\n            ...context,\n          }) === true\n        ) {\n          return true;\n        }\n      } catch (handlerError) {\n        const scope = context && context.isBackup ? ' (backup)' : '';\n        console.error(`Error while handling quota exceed for ${key}${scope}`, handlerError);\n      }\n    }\n\n    // First try compression\n    if (!compressionSweepAttempted && enableCompressionSweep !== false) {\n      compressionSweepAttempted = true;\n      const skipKeys = [key];\n      if (useBackup && typeof fallbackKey === 'string' && fallbackKey && fallbackKey !== key) {\n        skipKeys.push(fallbackKey);\n      }\n      if (context && typeof context.backupKey === 'string' && context.backupKey) {\n        skipKeys.push(context.backupKey);\n      }\n\n      const sweepResult = attemptStorageCompressionSweep(storage, { skipKeys });\n      if (sweepResult && sweepResult.success) {\n        return true;\n      }\n    }\n\n    // If compression failed or wasn't enough, try cleanup\n    const skipKeysCleanup = [key];\n    if (useBackup && typeof fallbackKey === 'string' && fallbackKey) {\n      skipKeysCleanup.push(fallbackKey);\n    }\n    const cleanupResult = attemptStorageCleanup(storage, { skipKeys: skipKeysCleanup });\n    return Boolean(cleanupResult && cleanupResult.success);\n  };\n\n  let attempts = 0;\n  while (attempts < MAX_SAVE_ATTEMPTS) {\n    attempts += 1;\n\n    const serialized = getSerializedForAttempt();\n    if (typeof serialized !== 'string') {\n      return;\n    }\n\n    const normalizedSerialized = computeStandardSerialized();\n    const normalizedString = typeof normalizedSerialized === 'string' && normalizedSerialized\n      ? normalizedSerialized\n      : null;\n\n    let skipPrimaryWrite = false;\n    let existingBackupValue;\n    let hasExistingBackup = false;\n    let existingBackupRaw = null;\n    let observedPrimaryRawValue = null;\n    let observedBackupRawValue = null;\n\n    if (typeof storage.getItem === 'function') {\n      try {\n        const existingValue = storage.getItem(key);\n        if (existingValue === serialized) {\n          skipPrimaryWrite = true;\n          observedPrimaryRawValue = serialized;\n        } else if (useCompressedSerialization) {\n          const existingRawValue = loadRawValue(key);\n          if (typeof existingRawValue === 'string') {\n            observedPrimaryRawValue = existingRawValue;\n            if (existingRawValue === serialized) {\n              skipPrimaryWrite = true;\n            }\n          }\n        } else if (typeof existingValue === 'string') {\n          observedPrimaryRawValue = existingValue;\n        }\n      } catch (inspectError) {\n        console.warn(`Unable to inspect existing value for ${key}`, inspectError);\n      }\n    }\n\n    if (useBackup && typeof storage.getItem === 'function') {\n      try {\n        existingBackupValue = storage.getItem(fallbackKey);\n        hasExistingBackup = typeof existingBackupValue === 'string';\n        if (hasExistingBackup && useCompressedSerialization) {\n          existingBackupRaw = loadRawValue(fallbackKey);\n          if (typeof existingBackupRaw === 'string') {\n            observedBackupRawValue = existingBackupRaw;\n          }\n        } else if (hasExistingBackup) {\n          observedBackupRawValue = existingBackupValue;\n        }\n      } catch (inspectError) {\n        console.warn(`Unable to inspect existing backup for ${key}`, inspectError);\n      }\n    }\n\n    if (!hasPreservedBackup && hasExistingBackup && typeof existingBackupValue === 'string') {\n      preservedBackupValue = existingBackupValue;\n      hasPreservedBackup = true;\n    }\n\n    const backupCandidates = (() => {\n      if (!useBackup) {\n        return [];\n      }\n\n      const candidates = [];\n\n      if (useCompressedSerialization) {\n        const standardSerialized = computeStandardSerialized();\n        if (typeof standardSerialized === 'string' && standardSerialized) {\n          candidates.push({ serialized: standardSerialized, compressed: false });\n        }\n\n        if (\n          typeof serialized === 'string'\n          && serialized\n          && (!candidates.length || candidates[candidates.length - 1].serialized !== serialized)\n        ) {\n          candidates.push({ serialized, compressed: true });\n        }\n      } else if (typeof serialized === 'string' && serialized) {\n        candidates.push({ serialized, compressed: false });\n      }\n\n      return candidates;\n    })();\n\n    const preferredBackupCandidate = backupCandidates.length ? backupCandidates[0] : null;\n\n    const backupMatchesPreferred = hasExistingBackup\n      && preferredBackupCandidate\n      && typeof preferredBackupCandidate.serialized === 'string'\n      && (\n        existingBackupValue === preferredBackupCandidate.serialized\n        || (\n          typeof existingBackupRaw === 'string'\n          && existingBackupRaw === preferredBackupCandidate.serialized\n        )\n      );\n\n    if (skipPrimaryWrite && (!useBackup || backupMatchesPreferred)) {\n      if (normalizedString) {\n        const rawForCacheUpdate = useCompressedSerialization\n          ? (typeof observedPrimaryRawValue === 'string' && observedPrimaryRawValue\n            ? observedPrimaryRawValue\n            : serialized)\n          : serialized;\n        cacheStorageValue(storage, key, rawForCacheUpdate, normalizedString, value);\n        if (useBackup && hasExistingBackup) {\n          const backupRawForCache = useCompressedSerialization\n            ? (typeof existingBackupRaw === 'string' && existingBackupRaw\n              ? existingBackupRaw\n              : observedBackupRawValue)\n            : observedBackupRawValue;\n          if (typeof backupRawForCache === 'string' && backupRawForCache) {\n            cacheStorageValue(storage, fallbackKey, backupRawForCache, normalizedString, value);\n          }\n        }\n      }\n      return;\n    }\n\n    if (!skipPrimaryWrite) {\n      try {\n        storage.setItem(key, serialized);\n        logCompressionIfNeeded();\n        if (normalizedString) {\n          cacheStorageValue(storage, key, serialized, normalizedString, value);\n        }\n      } catch (error) {\n        if (attemptHandleQuota(error)) {\n          resetSerializationState();\n          if (!registerQuotaRecoveryStep()) {\n            break;\n          }\n          if (attempts > 0) {\n            attempts -= 1;\n          }\n          continue;\n        }\n        if (!quotaRecoveryFailed && tryEnableCompression({ force: allowQuotaCompression })) {\n          if (!registerQuotaRecoveryStep()) {\n            break;\n          }\n          if (attempts > 0) {\n            attempts -= 1;\n          }\n          continue;\n        }\n        console.error(errorMessage, error);\n        downgradeSafeLocalStorageToMemory('write access', error, storage);\n        alertStorageError();\n        return;\n      }\n    }\n\n    if (!useBackup) {\n      return;\n    }\n\n    if (backupMatchesPreferred) {\n      if (normalizedString && hasExistingBackup) {\n        const backupRawForCache = useCompressedSerialization\n          ? (typeof existingBackupRaw === 'string' && existingBackupRaw\n            ? existingBackupRaw\n            : observedBackupRawValue)\n          : observedBackupRawValue;\n        if (typeof backupRawForCache === 'string' && backupRawForCache) {\n          cacheStorageValue(storage, fallbackKey, backupRawForCache, normalizedString, value);\n        }\n      }\n      return;\n    }\n\n    const attemptBackupWrite = () => {\n      const candidates = backupCandidates.length\n        ? backupCandidates\n        : [{ serialized, compressed: useCompressedSerialization }];\n\n      let backupError = null;\n      let backupRemovedForRetry = false;\n      let lastCandidate = null;\n\n      const tryStoreCandidate = (candidate) => {\n        try {\n          storage.setItem(fallbackKey, candidate.serialized);\n          if (candidate.compressed) {\n            logCompressionIfNeeded();\n          }\n          removedBackupDuringRetry = false;\n          return true;\n        } catch (error) {\n          backupError = error;\n          return false;\n        }\n      };\n\n      for (let index = 0; index < candidates.length; index += 1) {\n        const candidate = candidates[index];\n        lastCandidate = candidate;\n\n        if (tryStoreCandidate(candidate)) {\n          if (normalizedString) {\n            const normalizedForBackup = candidate.compressed && normalizedString\n              ? normalizedString\n              : candidate.serialized;\n            cacheStorageValue(storage, fallbackKey, candidate.serialized, normalizedForBackup, value);\n          }\n          return 'success';\n        }\n\n        if (!isQuotaExceededError(backupError)) {\n          break;\n        }\n\n        if (!backupRemovedForRetry && hasExistingBackup) {\n          try {\n            storage.removeItem(fallbackKey);\n            clearCachedStorageEntry(storage, fallbackKey);\n            backupRemovedForRetry = true;\n            removedBackupDuringRetry = true;\n            hasExistingBackup = false;\n            if (tryStoreCandidate(candidate)) {\n              if (normalizedString) {\n                const normalizedForBackup = candidate.compressed && normalizedString\n                  ? normalizedString\n                  : candidate.serialized;\n                cacheStorageValue(storage, fallbackKey, candidate.serialized, normalizedForBackup, value);\n              }\n              return 'success';\n            }\n          } catch (removeError) {\n            console.warn(`Unable to remove previous backup for ${key}`, removeError);\n          }\n        }\n      }\n\n      if (isQuotaExceededError(backupError)) {\n        if (attemptHandleQuota(backupError, {\n          serialized: lastCandidate && typeof lastCandidate.serialized === 'string'\n            ? lastCandidate.serialized\n            : serialized,\n          backupKey: fallbackKey,\n          isBackup: true,\n        })) {\n          resetSerializationState();\n          if (!registerQuotaRecoveryStep()) {\n            return 'failure';\n          }\n          return 'retry';\n        }\n\n        if (!quotaRecoveryFailed && tryEnableCompression({ force: allowQuotaCompression })) {\n          resetSerializationState();\n          if (!registerQuotaRecoveryStep()) {\n            return 'failure';\n          }\n          return 'retry';\n        }\n      }\n\n      if (backupRemovedForRetry && typeof existingBackupValue === 'string') {\n        try {\n          storage.setItem(fallbackKey, existingBackupValue);\n          if (normalizedString) {\n            cacheStorageValue(storage, fallbackKey, existingBackupValue, normalizedString, value);\n          }\n          removedBackupDuringRetry = false;\n        } catch (restoreError) {\n          console.warn(`Unable to restore previous backup for ${key}`, restoreError);\n        }\n      }\n\n      console.warn(`Unable to update backup copy for ${key}`, backupError);\n      alertStorageError();\n      return 'failure';\n    };\n\n    const backupResult = attemptBackupWrite();\n    if (backupResult === 'success') {\n      return;\n    }\n\n    if (backupResult === 'retry') {\n      if (attempts > 0) {\n        attempts -= 1;\n      }\n      continue;\n    }\n\n    if (quotaRecoveryFailed) {\n      break;\n    }\n\n    return;\n  }\n\n  if (hasPreservedBackup && removedBackupDuringRetry && typeof preservedBackupValue === 'string') {\n    try {\n      storage.setItem(fallbackKey, preservedBackupValue);\n      clearCachedStorageEntry(storage, fallbackKey);\n    } catch (restoreError) {\n      console.warn(`Unable to restore preserved backup for ${key}`, restoreError);\n    }\n  }\n\n  console.error(errorMessage, new Error('Unable to save value after multiple attempts.'));\n  alertStorageError();\n}\n\n// Generic helper to delete a key from storage with consistent error handling\nfunction deleteFromStorage(storage, key, errorMessage, options = {}) {\n  if (!storage) return;\n\n  // [Agent Refactor] Also clear from new repo (best effort, async)\n  if (storageRepo) {\n    storageRepo.removeItem(key).catch(() => { });\n  }\n\n  const { disableBackup = false, backupKey, disableMigrationCleanup = false } = options || {};\n  const fallbackKey = typeof backupKey === 'string' && backupKey\n    ? backupKey\n    : `${key}${STORAGE_BACKUP_SUFFIX}`;\n  const useBackup = !disableBackup && fallbackKey && fallbackKey !== key;\n\n  clearCachedStorageEntry(storage, key);\n  if (useBackup) {\n    clearCachedStorageEntry(storage, fallbackKey);\n  }\n\n  if (key === PROJECT_STORAGE_KEY) {\n    invalidateProjectReadCache();\n  }\n\n  try {\n    storage.removeItem(key);\n  } catch (e) {\n    console.error(errorMessage, e);\n    downgradeSafeLocalStorageToMemory('deletion', e, storage);\n    alertStorageError();\n  }\n\n  if (useBackup) {\n    try {\n      storage.removeItem(fallbackKey);\n    } catch (backupError) {\n      console.error(`${errorMessage} (backup)`, backupError);\n      downgradeSafeLocalStorageToMemory('deletion', backupError, storage);\n      alertStorageError();\n    }\n  }\n\n  if (!disableMigrationCleanup) {\n    const migrationBackupKey = `${key}${STORAGE_MIGRATION_BACKUP_SUFFIX}`;\n    try {\n      storage.removeItem(migrationBackupKey);\n    } catch (migrationError) {\n      console.warn(`Unable to remove migration backup for ${key}`, migrationError);\n    }\n  }\n}\n\nvar UI_CACHE_STORAGE_KEYS = [\n  DEVICE_SCHEMA_CACHE_KEY,\n  LEGACY_SCHEMA_CACHE_KEY,\n];\n\nvar UI_CACHE_STORAGE_ACCESS_WARNINGS = new Set();\n\nfunction collectUiCacheStorages() {\n  const candidates = [];\n  const seenScopes = new Set();\n\n  const pushCandidate = (candidate) => {\n    if (!candidate || typeof candidate.getItem !== 'function') {\n      return;\n    }\n    candidates.push(candidate);\n  };\n\n  const readProperty = (scope, property, label) => {\n    if (!scope || (typeof scope !== 'object' && typeof scope !== 'function')) {\n      return null;\n    }\n    try {\n      return scope[property];\n    } catch (error) {\n      if (label && !UI_CACHE_STORAGE_ACCESS_WARNINGS.has(label)) {\n        UI_CACHE_STORAGE_ACCESS_WARNINGS.add(label);\n        console.warn(`Unable to access ${label} while clearing UI caches`, error);\n      }\n      return null;\n    }\n  };\n\n  const inspectScope = (scope, label) => {\n    if (!scope || seenScopes.has(scope)) {\n      return;\n    }\n    seenScopes.add(scope);\n\n    pushCandidate(readProperty(scope, 'SAFE_LOCAL_STORAGE', `${label}.SAFE_LOCAL_STORAGE`));\n    pushCandidate(readProperty(scope, 'localStorage', `${label}.localStorage`));\n    pushCandidate(readProperty(scope, 'sessionStorage', `${label}.sessionStorage`));\n\n    const nested = readProperty(scope, '__cineGlobal', `${label}.__cineGlobal`);\n    if (nested && nested !== scope) {\n      inspectScope(nested, `${label}.__cineGlobal`);\n    }\n  };\n\n  inspectScope(typeof globalThis !== 'undefined' ? globalThis : null, 'globalThis');\n  inspectScope(typeof window !== 'undefined' ? window : null, 'window');\n  inspectScope(typeof self !== 'undefined' ? self : null, 'self');\n  inspectScope(typeof global !== 'undefined' ? global : null, 'global');\n  if (GLOBAL_SCOPE && GLOBAL_SCOPE.__cineGlobal) {\n    inspectScope(GLOBAL_SCOPE.__cineGlobal, '__cineGlobal');\n  }\n\n  if (safeLocalStorageInfo && safeLocalStorageInfo.storage) {\n    pushCandidate(safeLocalStorageInfo.storage);\n  }\n\n  if (typeof getSafeLocalStorage === 'function' && getSafeLocalStorage()) {\n    pushCandidate(getSafeLocalStorage());\n  }\n\n  try {\n    pushCandidate(getSafeLocalStorage());\n  } catch (error) {\n    if (!UI_CACHE_STORAGE_ACCESS_WARNINGS.has('getSafeLocalStorage')) {\n      UI_CACHE_STORAGE_ACCESS_WARNINGS.add('getSafeLocalStorage');\n      console.warn('Unable to access safe local storage while clearing UI caches', error);\n    }\n  }\n\n  pushCandidate(getWindowStorage('localStorage'));\n  pushCandidate(getWindowStorage('sessionStorage'));\n\n  if (typeof localStorage !== 'undefined') {\n    pushCandidate(localStorage);\n  }\n\n  if (typeof sessionStorage !== 'undefined') {\n    pushCandidate(sessionStorage);\n  }\n\n  return collectUniqueStorages(candidates);\n}\n\nfunction clearUiCacheStorageEntries() {\n  const storages = collectUiCacheStorages();\n  if (!storages.length) {\n    return;\n  }\n\n  UI_CACHE_STORAGE_KEYS.forEach((key) => {\n    // [Agent] Clean from new repo as well (async)\n    if (storageRepo) {\n      storageRepo.removeItem(key).catch(e => console.warn('Failed to clear UI cache from repo', e));\n    }\n\n    if (typeof key !== 'string' || !key) {\n      return;\n    }\n\n    storages.forEach((storage) => {\n      deleteFromStorage(storage, key, `Failed to clear UI cache entry ${key}`);\n    });\n  });\n}\n\nfunction loadFlagFromStorage(storage, key, errorMessage) {\n  if (!storage) return false;\n  try {\n    return storage.getItem(key) === '1';\n  } catch (e) {\n    console.error(errorMessage, e);\n    downgradeSafeLocalStorageToMemory('read access', e, storage);\n    alertStorageError();\n    return false;\n  }\n}\n\nfunction saveFlagToStorage(storage, key, value, errorMessage) {\n  if (!storage) return;\n  try {\n    if (value) {\n      storage.setItem(key, '1');\n    } else {\n      storage.removeItem(key);\n    }\n  } catch (e) {\n    console.error(errorMessage, e);\n    downgradeSafeLocalStorageToMemory('write access', e, storage);\n    alertStorageError();\n  }\n}\n\n// Attempt to load JSON from a primary storage. If missing, try a fallback\n// storage and migrate the data to the primary one. Useful for gradually moving\n// keys from sessionStorage to localStorage.\nfunction loadWithMigration(\n  primary,\n  fallback,\n  key,\n  primaryLoadMsg,\n  fallbackLoadMsg,\n  saveMsg,\n  deleteMsg,\n  loadOptions,\n) {\n  const value = loadJSONFromStorage(primary, key, primaryLoadMsg, null, loadOptions);\n  if (value !== null) return value;\n  if (!fallback) return null;\n  const fallbackOptions = {\n    ...(loadOptions || {}),\n    alertOnFailure: 'migration-read',\n  };\n  const migrated = loadJSONFromStorage(\n    fallback,\n    key,\n    fallbackLoadMsg,\n    null,\n    fallbackOptions,\n  );\n  if (migrated !== null) {\n    saveJSONToStorage(primary, key, migrated, saveMsg);\n    deleteFromStorage(fallback, key, deleteMsg);\n    return migrated;\n  }\n  return null;\n}\n\n// Generate a unique name by appending numeric suffixes if needed\n// Comparisons are case-insensitive and ignore surrounding whitespace.\n// Optionally accepts a set of normalized names to avoid recomputing the\n// normalised lookup on each call when generating many names in a loop.\nfunction generateUniqueName(base, usedNames, normalizedNames) {\n  const trimmedBase = base.trim();\n  let name = trimmedBase;\n  let suffix = 2;\n\n  const normalized = normalizedNames || new Set(\n    [...usedNames].map((n) => n.trim().toLowerCase()),\n  );\n  let candidate = trimmedBase.toLowerCase();\n  while (normalized.has(candidate)) {\n    name = `${trimmedBase} (${suffix++})`;\n    candidate = name.toLowerCase();\n  }\n  usedNames.add(name);\n  normalized.add(candidate);\n  return name;\n}\n\nfunction ensureImportedProjectBaseName(rawName) {\n  const trimmed = typeof rawName === \"string\" ? rawName.trim() : \"\";\n  if (!trimmed) {\n    return \"Project-imported\";\n  }\n\n  const importedMatch = trimmed.match(/^(.*?)-imported(?:-(\\d+))?$/i);\n  if (importedMatch) {\n    const prefix = typeof importedMatch[1] === \"string\"\n      ? importedMatch[1].trim()\n      : \"\";\n    return prefix ? `${prefix}-imported` : \"Project-imported\";\n  }\n\n  if (trimmed.toLowerCase().endsWith(\"-imported\")) {\n    return trimmed;\n  }\n\n  return `${trimmed}-imported`;\n}\n\nfunction resolveImportedProjectNamingContext(rawName) {\n  const trimmed = typeof rawName === \"string\" ? rawName.trim() : \"\";\n  const base = ensureImportedProjectBaseName(rawName);\n\n  if (!trimmed) {\n    return {\n      base,\n      initialCandidate: base,\n      suffixStart: 2,\n    };\n  }\n\n  const importedMatch = trimmed.match(/^(.*?)-imported(?:-(\\d+))?$/i);\n  const parsedSuffix = importedMatch && importedMatch[2]\n    ? Number(importedMatch[2])\n    : NaN;\n  const suffixStart = Number.isFinite(parsedSuffix) ? parsedSuffix + 1 : 2;\n\n  if (importedMatch) {\n    return {\n      base,\n      initialCandidate: trimmed,\n      suffixStart,\n    };\n  }\n\n  return {\n    base,\n    initialCandidate: base,\n    suffixStart: 2,\n  };\n}\n\nfunction generateImportedProjectName(baseName, usedNames, normalizedNames) {\n  const normalized = normalizedNames\n    || new Set(\n      [...usedNames]\n        .map((name) => (typeof name === \"string\" ? name.trim().toLowerCase() : \"\"))\n        .filter((name) => name),\n    );\n\n  const context = resolveImportedProjectNamingContext(baseName);\n  let candidate = typeof context.initialCandidate === \"string\"\n    ? context.initialCandidate.trim()\n    : \"\";\n\n  if (!candidate) {\n    candidate = context.base || \"Project-imported\";\n  }\n\n  let normalizedCandidate = candidate.trim().toLowerCase();\n  let suffix = context.suffixStart;\n  while (normalizedCandidate && normalized.has(normalizedCandidate)) {\n    const base = context.base || \"Project-imported\";\n    candidate = `${base}-${suffix++}`;\n    normalizedCandidate = candidate.trim().toLowerCase();\n  }\n\n  usedNames.add(candidate);\n  if (normalizedCandidate) {\n    normalized.add(normalizedCandidate);\n  }\n\n  return candidate;\n}\n\nfunction ensureUpdatedProjectBaseName(rawName) {\n  const trimmed = typeof rawName === \"string\" ? rawName.trim() : \"\";\n  if (!trimmed) {\n    return \"Project-updated\";\n  }\n  if (trimmed.toLowerCase().endsWith(\"-updated\")) {\n    return trimmed;\n  }\n  return `${trimmed}-updated`;\n}\n\nfunction generateUpdatedProjectName(baseName, usedNames, normalizedNames) {\n  const normalized = normalizedNames || new Set(\n    [...usedNames]\n      .map((name) => (typeof name === \"string\" ? name.trim().toLowerCase() : \"\"))\n      .filter((name) => name),\n  );\n  const base = ensureUpdatedProjectBaseName(baseName);\n  let candidate = base;\n  let suffix = 2;\n  let normalizedCandidate = candidate.trim().toLowerCase();\n  while (normalizedCandidate && normalized.has(normalizedCandidate)) {\n    candidate = `${base}-${suffix++}`;\n    normalizedCandidate = candidate.trim().toLowerCase();\n  }\n  return candidate;\n}\n\n// --- Session State Storage ---\n// Store the current session (unsaved setup) in localStorage so it survives\n// full app reloads.\nfunction collectStringValues(value) {\n  if (value === null || value === undefined) {\n    return [];\n  }\n  if (typeof value === 'string') {\n    const trimmed = value.trim();\n    return trimmed ? [trimmed] : [];\n  }\n  if (Array.isArray(value)) {\n    return value\n      .filter((item) => typeof item === 'string')\n      .map((item) => item.trim())\n      .filter((item) => item);\n  }\n  if (isPlainObject(value)) {\n    return Object.values(value)\n      .filter((item) => typeof item === 'string')\n      .map((item) => item.trim())\n      .filter((item) => item);\n  }\n  return [];\n}\n\nfunction arraysEqual(a, b) {\n  if (a === b) {\n    return true;\n  }\n  if (!Array.isArray(a) || !Array.isArray(b) || a.length !== b.length) {\n    return false;\n  }\n  for (let i = 0; i < a.length; i += 1) {\n    if (a[i] !== b[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction normalizeDiagramPositions(positions) {\n  if (!positions || typeof positions !== 'object') {\n    return {};\n  }\n  const normalized = {};\n  Object.keys(positions).forEach((key) => {\n    const value = positions[key];\n    if (!value || typeof value !== 'object') {\n      return;\n    }\n    const x = Number(value.x);\n    const y = Number(value.y);\n    if (!Number.isFinite(x) || !Number.isFinite(y)) {\n      return;\n    }\n    normalized[key] = { x, y };\n  });\n  return normalized;\n}\n\nfunction diagramPositionsEqual(a, b) {\n  const keysA = Object.keys(a || {});\n  const keysB = Object.keys(b || {});\n  if (keysA.length !== keysB.length) {\n    return false;\n  }\n  for (let i = 0; i < keysA.length; i += 1) {\n    const key = keysA[i];\n    if (!Object.prototype.hasOwnProperty.call(b || {}, key)) {\n      return false;\n    }\n    const valueA = a[key];\n    const valueB = b[key];\n    if (!valueA || typeof valueA !== 'object' || !valueB || typeof valueB !== 'object') {\n      return false;\n    }\n    if (Number(valueA.x) !== valueB.x || Number(valueA.y) !== valueB.y) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction normalizeSessionStatePayload(raw) {\n  if (!isPlainObject(raw)) {\n    return { state: null, changed: false };\n  }\n\n  const state = { ...raw };\n  let changed = false;\n\n  const normalizeStringField = (key) => {\n    if (!Object.prototype.hasOwnProperty.call(state, key)) {\n      return;\n    }\n    const value = state[key];\n    if (typeof value === 'string') {\n      const trimmed = value.trim();\n      if (trimmed !== value) {\n        state[key] = trimmed;\n        changed = true;\n      }\n      return;\n    }\n    if (value === null || value === undefined) {\n      state[key] = '';\n      changed = true;\n      return;\n    }\n    if (typeof value === 'number' || typeof value === 'boolean') {\n      state[key] = String(value);\n      changed = true;\n      return;\n    }\n    state[key] = '';\n    changed = true;\n  };\n\n  [\n    'setupName',\n    'setupSelect',\n    'camera',\n    'monitor',\n    'video',\n    'cage',\n    'distance',\n    'batteryPlate',\n    'battery',\n    'batteryHotswap',\n    'sliderBowl',\n    'easyrig',\n  ].forEach(normalizeStringField);\n\n  const mergeArrayField = (targetKey, legacyKeys = []) => {\n    const values = [];\n    const keys = [targetKey, ...legacyKeys];\n    let hadLegacyData = false;\n\n    keys.forEach((key) => {\n      if (Object.prototype.hasOwnProperty.call(state, key)) {\n        const collected = collectStringValues(state[key]);\n        if (key !== targetKey) {\n          hadLegacyData = true;\n        }\n        if (collected.length) {\n          values.push(...collected);\n        }\n      }\n    });\n\n    keys.slice(1).forEach((legacyKey) => {\n      if (Object.prototype.hasOwnProperty.call(state, legacyKey)) {\n        delete state[legacyKey];\n        changed = true;\n      }\n    });\n\n    const unique = [];\n    const seen = new Set();\n    values.forEach((val) => {\n      if (!seen.has(val)) {\n        seen.add(val);\n        unique.push(val);\n      }\n    });\n\n    const hasTargetKey = Object.prototype.hasOwnProperty.call(state, targetKey);\n    const existing = hasTargetKey && Array.isArray(state[targetKey])\n      ? state[targetKey].filter((item) => typeof item === 'string').map((item) => item.trim()).filter((item) => item)\n      : [];\n\n    if (!hasTargetKey && !hadLegacyData && unique.length === 0 && existing.length === 0) {\n      return;\n    }\n\n    if (!arraysEqual(existing, unique)) {\n      state[targetKey] = unique;\n      changed = true;\n    }\n  };\n\n  mergeArrayField('motors', ['motor', 'motorSelect']);\n  mergeArrayField('controllers', ['controller', 'controllerSelect']);\n\n  if (Object.prototype.hasOwnProperty.call(state, 'projectInfo') && !isPlainObject(state.projectInfo)) {\n    state.projectInfo = null;\n    changed = true;\n  }\n\n  if (Object.prototype.hasOwnProperty.call(state, 'autoGearHighlight')) {\n    const value = state.autoGearHighlight;\n    const normalized = value === true || value === 'true' || value === 1 || value === '1';\n    if (value !== normalized || typeof value !== 'boolean') {\n      state.autoGearHighlight = normalized;\n      changed = true;\n    }\n  }\n\n  if (Object.prototype.hasOwnProperty.call(state, 'diagramPositions')) {\n    const normalizedPositions = normalizeDiagramPositions(state.diagramPositions);\n    if (Object.keys(normalizedPositions).length === 0) {\n      delete state.diagramPositions;\n      changed = true;\n    } else if (!diagramPositionsEqual(state.diagramPositions, normalizedPositions)) {\n      state.diagramPositions = normalizedPositions;\n      changed = true;\n    }\n  }\n\n  const normalizedState = normalizeLegacyLongGopStructure(state);\n  if (normalizedState !== state) {\n    return { state: normalizedState, changed: true };\n  }\n\n  return { state, changed };\n}\n\nfunction loadSessionState() {\n  applyLegacyStorageMigrations();\n  const safeStorage = getSafeLocalStorage();\n  const raw = loadWithMigration(\n    safeStorage,\n    typeof sessionStorage !== 'undefined' ? sessionStorage : null,\n    SESSION_STATE_KEY,\n    \"Error loading session state from localStorage:\",\n    \"Error loading session state from sessionStorage:\",\n    \"Error saving session state to localStorage:\",\n    \"Error deleting session state from sessionStorage:\",\n    { validate: (value) => value === null || isPlainObject(value) },\n  );\n  if (raw === null) {\n    return null;\n  }\n\n  const { state, changed } = normalizeSessionStatePayload(raw);\n  if (!state) {\n    return null;\n  }\n\n  if (changed) {\n    createStorageMigrationBackup(safeStorage, SESSION_STATE_KEY, raw);\n    saveSessionState(state);\n  }\n\n  return state;\n}\n\nfunction saveSessionState(state, options = {}) {\n  const safeStorage = getSafeLocalStorage();\n  if (state === null || state === undefined) {\n    deleteFromStorage(\n      safeStorage,\n      SESSION_STATE_KEY,\n      \"Error deleting session state from localStorage:\",\n    );\n    return;\n  }\n\n  if (!isPlainObject(state)) {\n    console.warn('Ignoring invalid session state payload. Expected a plain object.');\n    return;\n  }\n\n  ensurePreWriteMigrationBackup(safeStorage, SESSION_STATE_KEY);\n  const normalizedState = normalizeLegacyLongGopStructure(state);\n  const normalizedOptions = isPlainObject(options) ? options : {};\n\n  // We default to disabling compression for session state to keep it human-readable\n  // and safer to edit manually if needed, BUT we must allow it if the user is\n  // running out of space.\n  const disableCompression = normalizedOptions.disableCompression !== false;\n\n  const saveOptions = {\n    ...normalizedOptions,\n    disableCompression,\n    forceCompressionOnQuota: true,\n    onQuotaExceeded: () => {\n      // If we hit a quota limit while saving the session, try to clear out\n      // old auto-backups or other non-essential data to make room.\n\n\n      // 1. Try clearing the oldest auto-gear backup first\n      if (typeof removeOldestAutoGearBackupEntry === 'function') {\n        // We need to load them first to find the oldest\n        const backups = loadAutoGearBackups();\n        if (removeOldestAutoGearBackupEntry(backups)) {\n          console.warn('Removed oldest automatic gear backup to free up space for session state.');\n          return true;\n        }\n      }\n\n      // 2. Try clearing cached planner data\n      if (typeof clearCachedPlannerDataForAutoGearBackups === 'function') {\n        if (clearCachedPlannerDataForAutoGearBackups()) {\n          console.warn('Cleared cached planner data to free up space for session state.');\n          return true;\n        }\n      }\n\n      return false;\n    },\n  };\n\n  saveJSONToStorage(\n    safeStorage,\n    SESSION_STATE_KEY,\n    normalizedState,\n    \"Error saving session state to localStorage:\",\n    saveOptions,\n  );\n}\n\n// --- Device Data Storage ---\nfunction normalizeDeviceDataPayload(rawData) {\n  if (!isPlainObject(rawData)) {\n    return { data: null, changed: false };\n  }\n\n  const data = { ...rawData };\n  let changed = false;\n\n  const ensureObject = (target, key) => {\n    if (!isPlainObject(target[key])) {\n      target[key] = {};\n      changed = true;\n    }\n    return target[key];\n  };\n\n  DEVICE_COLLECTION_KEYS.forEach((key) => {\n    ensureObject(data, key);\n  });\n\n  if (!isPlainObject(data.fiz)) {\n    data.fiz = {};\n    changed = true;\n  }\n  FIZ_COLLECTION_KEYS.forEach((key) => {\n    ensureObject(data.fiz, key);\n  });\n\n  if (!isPlainObject(data.accessories)) {\n    data.accessories = {};\n    changed = true;\n  }\n  ACCESSORY_COLLECTION_KEYS.forEach((key) => {\n    ensureObject(data.accessories, key);\n  });\n\n  if (!Array.isArray(data.filterOptions)) {\n    data.filterOptions = Array.isArray(rawData.filterOptions)\n      ? rawData.filterOptions.slice()\n      : [];\n    changed = true;\n  }\n\n  return { data, changed };\n}\n\nfunction loadDeviceData() {\n  applyLegacyStorageMigrations();\n  const safeStorage = getSafeLocalStorage();\n  const parsedData = loadJSONFromStorage(\n    safeStorage,\n    DEVICE_STORAGE_KEY,\n    \"Error loading device data from localStorage:\",\n    null,\n    { validate: (value) => value === null || isPlainObject(value) },\n  );\n  const { data, changed } = normalizeDeviceDataPayload(parsedData);\n  if (!data) {\n    return null;\n  }\n\n  if (changed) {\n    createStorageMigrationBackup(safeStorage, DEVICE_STORAGE_KEY, parsedData);\n    saveJSONToStorage(\n      safeStorage,\n      DEVICE_STORAGE_KEY,\n      data,\n      \"Error updating device data in localStorage during normalization:\",\n      {\n        disableCompression: true,\n        forceCompressionOnQuota: false,\n      },\n    );\n  }\n\n  return data;\n}\n\nfunction saveDeviceData(deviceData) {\n  const safeStorage = getSafeLocalStorage();\n  if (deviceData === null || deviceData === undefined) {\n    deleteFromStorage(\n      safeStorage,\n      DEVICE_STORAGE_KEY,\n      \"Error deleting device data from localStorage:\",\n    );\n    return;\n  }\n\n  if (!isPlainObject(deviceData)) {\n    console.warn('Ignoring invalid device data payload. Expected a plain object.');\n    return;\n  }\n\n  const { data: normalizedDeviceData } = normalizeDeviceDataPayload(deviceData);\n  const dataToPersist = normalizedDeviceData || deviceData;\n\n  ensurePreWriteMigrationBackup(safeStorage, DEVICE_STORAGE_KEY);\n  saveJSONToStorage(\n    safeStorage,\n    DEVICE_STORAGE_KEY,\n    dataToPersist,\n    \"Error saving device data to localStorage:\",\n    {\n      disableCompression: false,\n      forceCompressionOnQuota: true,\n    },\n  );\n}\n\n// --- Setup Data Storage ---\nfunction normalizeSetups(rawData) {\n  if (!rawData) {\n    return { data: {}, changed: false };\n  }\n\n  if (Array.isArray(rawData)) {\n    const obj = {};\n    const used = new Set();\n    const normalized = new Set();\n    for (let idx = 0; idx < rawData.length; idx += 1) {\n      const item = rawData[idx];\n      if (!isPlainObject(item)) {\n        continue;\n      }\n      const base = item.name || item.setupName || `Setup ${idx + 1}`;\n      const key = generateUniqueName(base, used, normalized);\n      obj[key] = item;\n    }\n    return { data: obj, changed: true };\n  }\n\n  if (!isPlainObject(rawData)) {\n    return { data: {}, changed: true };\n  }\n\n  const normalized = {};\n  let changed = false;\n  Object.keys(rawData).forEach((name) => {\n    const value = rawData[name];\n    if (isPlainObject(value)) {\n      const normalizedValue = normalizeLegacyLongGopStructure(value);\n      if (normalizedValue !== value) {\n        changed = true;\n      }\n      normalized[name] = normalizedValue;\n    } else {\n      changed = true;\n    }\n  });\n\n  if (!changed) {\n    return { data: rawData, changed: false };\n  }\n\n  return { data: normalized, changed: true };\n}\n\nfunction loadSetups() {\n  applyLegacyStorageMigrations();\n  const safeStorage = getSafeLocalStorage();\n  const parsedData = loadJSONFromStorage(\n    safeStorage,\n    SETUP_STORAGE_KEY,\n    \"Error loading setups from localStorage:\",\n    null,\n    {\n      validate: (value) =>\n        value === null || Array.isArray(value) || isPlainObject(value),\n    },\n  );\n  const { data: setups, changed } = normalizeSetups(parsedData);\n  if (changed) {\n    createStorageMigrationBackup(safeStorage, SETUP_STORAGE_KEY, parsedData);\n    saveJSONToStorage(\n      safeStorage,\n      SETUP_STORAGE_KEY,\n      setups,\n      \"Error updating setups in localStorage during normalization:\",\n    );\n  }\n\n  try {\n    return expandAutoBackupEntries(setups, {\n      isAutoBackupKey: (name) => typeof name === 'string'\n        && name.startsWith(STORAGE_AUTO_BACKUP_NAME_PREFIX),\n    });\n  } catch (error) {\n    console.warn('Failed to expand automatic backup entries while loading setups', error);\n    return cloneAutoBackupValue(setups);\n  }\n}\n\nfunction saveSetups(setups) {\n\n  const { data: normalizedSetups } = normalizeSetups(setups);\n  enforceAutoBackupLimits(normalizedSetups);\n  const serializedSetups = serializeAutoBackupEntries(normalizedSetups, {\n    isAutoBackupKey: (name) => typeof name === 'string'\n      && name.startsWith(STORAGE_AUTO_BACKUP_NAME_PREFIX),\n  });\n  ensureProjectEntriesUncompressed(serializedSetups);\n  const safeStorage = getSafeLocalStorage();\n\n  // [Fix] Maintain V2 Project Index for Dashboard Performance\n  // This ensures that when we save via legacy Shim, the optimized index used by V2 is also updated.\n  if (typeof updateProjectIndex === 'function') {\n    updateProjectIndex(normalizedSetups, safeStorage);\n  }\n\n  ensurePreWriteMigrationBackup(safeStorage, SETUP_STORAGE_KEY);\n  saveJSONToStorage(\n    safeStorage,\n    SETUP_STORAGE_KEY,\n    serializedSetups,\n    \"Error saving setups to localStorage:\",\n    {\n      disableCompression: false,\n      forceCompressionOnQuota: true,\n      onQuotaExceeded: () => {\n        const removedKey = removeOldestAutoBackupEntry(serializedSetups);\n        if (!removedKey) {\n          return false;\n        }\n        console.warn(\n          `Removed automatic backup \"${removedKey}\" to free up storage space before saving setups.`,\n        );\n        return true;\n      },\n    },\n  );\n}\n\nfunction updateSetups(callback) {\n  const setups = loadSetups();\n  const { result, changed = true } = callback(setups) || {};\n  if (changed) {\n    saveSetups(setups);\n  }\n  return result;\n}\n\nfunction saveSetup(name, setup) {\n  updateSetups((setups) => {\n    setups[name] = setup;\n    return { changed: true };\n  });\n}\n\nfunction loadSetup(name) {\n  const setups = loadSetups();\n  return setups[name];\n}\n\nfunction deleteSetup(name) {\n  updateSetups((setups) => {\n    if (Object.prototype.hasOwnProperty.call(setups, name)) {\n      delete setups[name];\n      return { changed: true };\n    }\n    return { changed: false };\n  });\n}\n\nfunction renameSetup(oldName, newName) {\n  return updateSetups((setups) => {\n    if (!Object.prototype.hasOwnProperty.call(setups, oldName)) {\n      return { result: null, changed: false };\n    }\n    const sanitized = newName.trim();\n    // Guard against empty or whitespace-only names. Renaming to such a value\n    // would create an empty key in the setups object. In that case simply keep\n    // the original name.\n    if (!sanitized) {\n      return { result: oldName, changed: false };\n    }\n    if (oldName.trim().toLowerCase() === sanitized.toLowerCase()) {\n      return { result: oldName, changed: false };\n    }\n    const used = new Set(Object.keys(setups));\n    used.delete(oldName);\n    const target = generateUniqueName(sanitized, used);\n    const movedValue = setups[oldName];\n    setups[target] = movedValue;\n    delete setups[oldName];\n    const wasAutoBackup = typeof oldName === 'string'\n      && oldName.startsWith(STORAGE_AUTO_BACKUP_NAME_PREFIX);\n    const targetIsAutoBackup = typeof target === 'string'\n      && target.startsWith(STORAGE_AUTO_BACKUP_NAME_PREFIX);\n    if (wasAutoBackup && targetIsAutoBackup) {\n      markAutoBackupValueAsRenamed(movedValue);\n    }\n    return { result: target, changed: true };\n  });\n}\n\n// --- Project Storage ---\nvar REQUIREMENT_FIELDS_KEEP_NEWLINES = new Set(['prepDays', 'shootingDays', 'returnDays', 'crew', 'productionCompany', 'productionCompanyAddress']);\n\nvar LEGACY_PROJECT_FIELD_LABELS = {\n  productionCompany: [\n    'Production Company',\n    'Produktionsfirma',\n    'Socit de production',\n    'Productora',\n    'Casa di produzione',\n  ],\n  productionCompanyAddress: [\n    'Production Company Address',\n    'Adresse der Produktionsfirma',\n    'Adresse de la socit de production',\n    'Direccin de la productora',\n    'Indirizzo della casa di produzione',\n  ],\n  productionCompanyStreet: [\n    'Street address',\n    'Strae und Hausnummer',\n    'Adresse',\n    'Direccin',\n    'Indirizzo',\n  ],\n  productionCompanyStreet2: [\n    'Address line 2',\n    'Adresszusatz',\n    \"Complment d'adresse\",\n    'Lnea 2 de direccin',\n    'Seconda linea indirizzo',\n  ],\n  productionCompanyCity: [\n    'City',\n    'Stadt',\n    'Ville',\n    'Ciudad',\n    'Citt',\n  ],\n  productionCompanyRegion: [\n    'State / Province / Region',\n    'Bundesland / Region',\n    'tat / Rgion / Dpartement',\n    'Estado / Provincia / Regin',\n    'Regione / Provincia / Stato',\n  ],\n  productionCompanyPostalCode: [\n    'Postal code',\n    'Postleitzahl',\n    'Code postal',\n    'Cdigo postal',\n    'CAP',\n  ],\n  productionCompanyCountry: [\n    'Country',\n    'Land',\n    'Pays',\n    'Pas',\n    'Paese',\n  ],\n  rentalHouse: ['Rental', 'Kameraverleih', 'Loueur', 'Noleggio', 'Verleih', 'Location', 'Rental House'],\n  crew: ['Crew', 'Team', 'quipe', 'Equipo', 'Troupe'],\n  prepDays: [\n    'Prep Days',\n    'Prep-Tage',\n    'Jours de prparation',\n    'Das de preparacin',\n    'Giorni di preparazione',\n  ],\n  shootingDays: [\n    'Shooting Days',\n    'Drehtage',\n    'Jours de tournage',\n    'Das de rodaje',\n    'Giorni di riprese',\n  ],\n  returnDays: [\n    'Return Days',\n    'Rckgabetage',\n    'Jours de restitution',\n    'Das de devolucin',\n    'Giorni di restituzione',\n  ],\n  deliveryResolution: [\n    'Delivery Resolution',\n    'Auslieferungsauflsung',\n    'Rsolution de livraison',\n    'Resolucin de entrega',\n    'Risoluzione di consegna',\n  ],\n  recordingResolution: [\n    'Recording Resolution',\n    'Aufnahmeauflsung',\n    'Rsolution denregistrement',\n    'Resolucin de grabacin',\n    'Risoluzione di registrazione',\n  ],\n  slowMotionRecordingResolution: [\n    'Slow Motion Recording Resolution',\n    'Zeitlupen-Aufnahmeauflsung',\n    'Rsolution denregistrement au ralenti',\n    'Resolucin de grabacin en cmara lenta',\n    'Risoluzione di registrazione slow motion',\n  ],\n  aspectRatio: [\n    'Aspect Ratio',\n    'Seitenverhltnis',\n    \"Format dimage\",\n    'Relacin de aspecto',\n    'Formato',\n  ],\n  codec: ['Codec', 'Codec', 'Codec', 'Cdec', 'Codec'],\n  baseFrameRate: [\n    'Base Frame Rate',\n    'Basis-Framerate',\n    'Cadence de base',\n    'Velocidad base',\n    'Frame rate base',\n  ],\n  slowMotionBaseFrameRate: [\n    'Slow Motion Base Frame Rate',\n    'Zeitlupen-Basis-Framerate',\n    'Cadence de base au ralenti',\n    'Velocidad base en cmara lenta',\n    'Frame rate base slow motion',\n  ],\n  recordingFrameRate: [\n    'Recording Frame Rate',\n    'Aufnahmebildrate',\n    'Cadence denregistrement',\n    'Velocidad de grabacin',\n    'Frame rate di registrazione',\n  ],\n  slowMotionRecordingFrameRate: [\n    'Slow Motion Recording Frame Rate',\n    'Zeitlupen-Aufnahmebildrate',\n    'Cadence denregistrement au ralenti',\n    'Velocidad de grabacin en cmara lenta',\n    'Frame rate di registrazione slow motion',\n  ],\n  sensorMode: [\n    'Sensor Mode',\n    'Sensormodus',\n    'Mode capteur',\n    'Modo de sensor',\n    'Modalit sensore',\n  ],\n  slowMotionSensorMode: [\n    'Slow Motion Sensor Mode',\n    'Zeitlupen-Sensormodus',\n    'Mode capteur au ralenti',\n    'Modo de sensor en cmara lenta',\n    'Modalit sensore slow motion',\n  ],\n  slowMotionAspectRatio: [\n    'Slow Motion Aspect Ratio',\n    'Zeitlupen-Seitenverhltnis',\n    \"Format dimage au ralenti\",\n    'Relacin de aspecto en cmara lenta',\n    'Formato slow motion',\n  ],\n  lenses: ['Lenses', 'Objektive', 'Optiques', 'pticas', 'Obiettivi'],\n  requiredScenarios: [\n    'Required Scenarios',\n    'Anforderungen',\n    'Scnarios requis',\n    'Escenarios requeridos',\n    'Scenari richiesti',\n  ],\n  cameraHandle: [\n    'Camera Handle',\n    'Kamera-Handgriff',\n    'Poigne camra',\n    'Empuadura de cmara',\n    'Maniglia camera',\n  ],\n  viewfinderExtension: [\n    'Viewfinder Extension',\n    'Sucher-Verlngerung',\n    'Extension viseur',\n    'Extensin de visor',\n    'Prolunga mirino',\n  ],\n  viewfinderEyeLeatherColor: [\n    'Viewfinder Eye Leather Color',\n    'Sucher-Augenmuschel-Farbe',\n    \"Couleur de lil du viseur\",\n    'Color del ocular del visor',\n    'Colore gomma mirino',\n  ],\n  mattebox: ['Mattebox', 'Matte-Box', 'Matte box', 'Matte box', 'Matte box'],\n  gimbal: [\n    'Gimbal',\n    'Gimbal-Stabilisator',\n    'Stabilisateur gimbal',\n    'Estabilizador gimbal',\n    'Stabilizzatore gimbal',\n  ],\n  videoDistribution: [\n    'Video Distribution',\n    'Videoverteilung',\n    'Distribution vido',\n    'Distribucin de vdeo',\n    'Distribuzione video',\n  ],\n  monitoringSupport: [\n    'Monitoring support',\n    'Monitoring-Support',\n    'Support de monitoring',\n    'Soporte de monitorizacin',\n    'Supporto monitoraggio',\n  ],\n  monitoringConfiguration: [\n    'Monitoring configuration',\n    'Monitoring-Konfiguration',\n    'Configuration de monitoring',\n    'Configuracin de monitorizacin',\n    'Configurazione monitoraggio',\n  ],\n  focusMonitor: [\n    'Focus Monitor',\n    'Fokusmonitor',\n    'Moniteur focus',\n    'Monitor de foco',\n    'Monitor fuoco',\n  ],\n  monitorUserButtons: [\n    'Onboard Monitor User Buttons',\n    'Onboard-Monitor-Buttons',\n    'Boutons personnaliss du moniteur',\n    'Botones de usuario del monitor integrado',\n    'Tasti monitor onboard',\n  ],\n  cameraUserButtons: [\n    'Camera User Buttons',\n    'Kamera-Buttons',\n    'Boutons personnaliss camra',\n    'Botones de usuario de la cmara',\n    'Tasti camera',\n  ],\n  viewfinderUserButtons: [\n    'Viewfinder User Buttons',\n    'Sucher-Buttons',\n    'Boutons personnaliss viseur',\n    'Botones de usuario del visor',\n    'Tasti mirino',\n  ],\n  tripodHeadBrand: [\n    'Tripod Head Brand',\n    'Kopfmarke',\n    'Marque de la tte',\n    'Marca de la cabeza',\n    'Marca della testa',\n  ],\n  tripodBowl: [\n    'Tripod Bowl',\n    'Schalentyp',\n    'Type de bol',\n    'Tipo de bowl',\n    'Tipo di bowl',\n  ],\n  tripodTypes: [\n    'Tripod Types',\n    'Stativtypen',\n    'Types de trpied',\n    'Tipos de trpode',\n    'Tipi di treppiede',\n  ],\n  tripodSpreader: [\n    'Tripod Spreader',\n    'Spreizer-Option',\n    'Type de spreader',\n    'Tipo de esparcidor',\n    'Tipo di spreader',\n  ],\n  sliderBowl: [\n    'Slider Bowl',\n    'Slider-Schale',\n    'Slider bowl',\n    'Bowl del slider',\n    'Slider bowl',\n  ],\n  easyrig: [\n    'Further Stabilisation',\n    'Weitere Stabilisierung',\n    'Stabilisation complmentaire',\n    'Estabilizacin adicional',\n    'Stabilizzazione aggiuntiva',\n  ],\n};\n\nvar PRODUCTION_COMPANY_FIELD_ORDER = [\n  'productionCompanyAddress',\n  'productionCompanyStreet',\n  'productionCompanyStreet2',\n  'productionCompanyCity',\n  'productionCompanyRegion',\n  'productionCompanyPostalCode',\n  'productionCompanyCountry',\n];\n\nfunction normalizeProjectFieldLabel(label) {\n  if (typeof label !== 'string') {\n    return '';\n  }\n  return label.trim().replace(/[:]\\s*$/, '').trim();\n}\n\nfunction getProductionCompanyLabelSets(projectLabels) {\n  var labelSets = {};\n  var textsObj = typeof window !== 'undefined' && window.texts ? window.texts : null;\n  var fallbackProjectLabels = (textsObj && textsObj.en && textsObj.en.projectFields) || {};\n  var allKeys = ['productionCompany'].concat(PRODUCTION_COMPANY_FIELD_ORDER);\n  allKeys.forEach(function (key) {\n    var set = new Set();\n    var addLabel = function (value) {\n      if (typeof value !== 'string') return;\n      var normalized = normalizeProjectFieldLabel(value);\n      if (normalized) {\n        set.add(normalized);\n      }\n    };\n    if (projectLabels && projectLabels[key]) {\n      addLabel(projectLabels[key]);\n    }\n    if (fallbackProjectLabels && fallbackProjectLabels[key]) {\n      addLabel(fallbackProjectLabels[key]);\n    }\n    var legacyLabels = LEGACY_PROJECT_FIELD_LABELS[key];\n    if (Array.isArray(legacyLabels)) {\n      legacyLabels.forEach(addLabel);\n    }\n    labelSets[key] = set;\n  });\n  return labelSets;\n}\n\nfunction expandCombinedProductionCompanyInfo(rawText, projectLabels, metadata) {\n  if (typeof rawText !== 'string') {\n    return null;\n  }\n  var normalizedText = rawText\n    .replace(/\\r\\n?/g, '\\n')\n    .split('\\n')\n    .map(function (segment) { return segment.trim(); })\n    .filter(function (segment) { return segment; });\n  if (!normalizedText.length) {\n    return null;\n  }\n  var labelSets = getProductionCompanyLabelSets(projectLabels);\n  var result = {};\n  var firstLine = normalizedText[0];\n  if (firstLine) {\n    result.productionCompany = firstLine;\n  }\n  var metadataLines = Array.isArray(metadata === null || metadata === void 0 ? void 0 : metadata.lines)\n    ? metadata.lines\n    : null;\n  if (metadataLines && metadataLines.length) {\n    var collectedFromMetadata = {};\n    metadataLines.forEach(function (entry) {\n      if (!entry || typeof entry.text !== 'string') return;\n      var text = entry.text.trim();\n      if (!text) return;\n      var fields = entry.fields;\n      if (typeof fields === 'string') {\n        fields = fields.split(/\\s+/);\n      }\n      if (!Array.isArray(fields) || !fields.length) return;\n      fields\n        .map(function (field) { return typeof field === 'string' ? field.trim() : ''; })\n        .filter(function (field) { return field && PRODUCTION_COMPANY_FIELD_ORDER.includes(field); })\n        .forEach(function (field) {\n          if (!collectedFromMetadata[field]) {\n            collectedFromMetadata[field] = [];\n          }\n          collectedFromMetadata[field].push(text);\n        });\n    });\n    if (Object.keys(collectedFromMetadata).length) {\n      if (collectedFromMetadata.productionCompanyAddress && collectedFromMetadata.productionCompanyAddress.length) {\n        result.productionCompanyAddress = collectedFromMetadata.productionCompanyAddress.join('\\n');\n      }\n      if (collectedFromMetadata.productionCompanyStreet && collectedFromMetadata.productionCompanyStreet.length) {\n        var streetParts = collectedFromMetadata.productionCompanyStreet;\n        result.productionCompanyStreet = streetParts[0];\n        if (streetParts.length > 1) {\n          var secondary = streetParts.slice(1).join('\\n');\n          if (secondary) {\n            result.productionCompanyStreet2 = secondary;\n          }\n        }\n      }\n      if (collectedFromMetadata.productionCompanyStreet2 && collectedFromMetadata.productionCompanyStreet2.length) {\n        var streetTwo = collectedFromMetadata.productionCompanyStreet2.join('\\n');\n        if (streetTwo) {\n          result.productionCompanyStreet2 = result.productionCompanyStreet2\n            ? result.productionCompanyStreet2 + '\\n' + streetTwo\n            : streetTwo;\n        }\n      }\n      var joinCollected = function (field) {\n        if (!collectedFromMetadata[field] || !collectedFromMetadata[field].length) return;\n        var combined = collectedFromMetadata[field].join(' ');\n        if (combined) {\n          result[field] = combined;\n        }\n      };\n      ['productionCompanyCity', 'productionCompanyRegion', 'productionCompanyPostalCode', 'productionCompanyCountry']\n        .forEach(joinCollected);\n      return result;\n    }\n  }\n  var collected = {};\n  var activeField = null;\n  normalizedText.slice(1).forEach(function (line) {\n    var normalizedLine = normalizeProjectFieldLabel(line);\n    var matchedField = null;\n    PRODUCTION_COMPANY_FIELD_ORDER.forEach(function (field) {\n      if (matchedField || !labelSets[field]) return;\n      if (labelSets[field].has(normalizedLine)) {\n        matchedField = field;\n      }\n    });\n    if (matchedField) {\n      activeField = matchedField;\n      if (!collected[activeField]) {\n        collected[activeField] = [];\n      }\n      return;\n    }\n    if (!activeField) {\n      if (result.productionCompany) {\n        result.productionCompany += '\\n' + line;\n      } else {\n        result.productionCompany = line;\n      }\n      return;\n    }\n    if (!collected[activeField]) {\n      collected[activeField] = [];\n    }\n    collected[activeField].push(line);\n  });\n\n  if (collected.productionCompanyAddress && collected.productionCompanyAddress.length) {\n    result.productionCompanyAddress = collected.productionCompanyAddress.join('\\n');\n  }\n  if (collected.productionCompanyStreet && collected.productionCompanyStreet.length) {\n    var streetLines = collected.productionCompanyStreet;\n    result.productionCompanyStreet = streetLines[0];\n    if (streetLines.length > 1) {\n      result.productionCompanyStreet2 = streetLines.slice(1).join('\\n');\n    }\n  }\n  if (collected.productionCompanyCity && collected.productionCompanyCity.length) {\n    result.productionCompanyCity = collected.productionCompanyCity.join(' ');\n  }\n  if (collected.productionCompanyRegion && collected.productionCompanyRegion.length) {\n    result.productionCompanyRegion = collected.productionCompanyRegion.join(' ');\n  }\n  if (collected.productionCompanyPostalCode && collected.productionCompanyPostalCode.length) {\n    result.productionCompanyPostalCode = collected.productionCompanyPostalCode.join(' ');\n  }\n  if (collected.productionCompanyCountry && collected.productionCompanyCountry.length) {\n    result.productionCompanyCountry = collected.productionCompanyCountry.join(' ');\n  }\n\n  return result;\n}\n\nvar LEGACY_PROJECT_LABEL_FIELD_MAP = (() => {\n  const map = new Map();\n  const normalize = (label) => {\n    if (typeof label !== 'string') return '';\n    return label\n      .normalize('NFD')\n      .replace(/[\\u0300-\\u036f]/g, '')\n      .replace(/[:]/g, '')\n      .replace(/[^a-zA-Z0-9]+/g, ' ')\n      .trim()\n      .toLowerCase();\n  };\n  Object.entries(LEGACY_PROJECT_FIELD_LABELS).forEach(([field, labels]) => {\n    labels.forEach((label) => {\n      const normalized = normalize(label);\n      if (normalized && !map.has(normalized)) {\n        map.set(normalized, field);\n      }\n    });\n  });\n  return map;\n})();\n\nvar HTML_ENTITY_MAP = {\n  amp: '&',\n  lt: '<',\n  gt: '>',\n  quot: '\"',\n  apos: \"'\",\n  nbsp: ' ',\n};\n\nfunction decodeHtmlEntities(value) {\n  if (typeof value !== 'string' || !value) {\n    return '';\n  }\n  return value.replace(/&(#x?[0-9a-fA-F]+|[a-zA-Z]+);/g, (match, entity) => {\n    if (!entity) return match;\n    if (entity[0] === '#') {\n      const code = entity[1] === 'x' || entity[1] === 'X'\n        ? parseInt(entity.slice(2), 16)\n        : parseInt(entity.slice(1), 10);\n      return Number.isFinite(code) ? String.fromCodePoint(code) : match;\n    }\n    const mapped = HTML_ENTITY_MAP[entity.toLowerCase()];\n    return mapped !== undefined ? mapped : match;\n  });\n}\n\nfunction stripHtmlTags(value) {\n  if (typeof value !== 'string') return '';\n  // Remove all HTML tags by repeatedly applying the regex until no tags remain.\n  let previous;\n  do {\n    previous = value;\n    value = value.replace(/<[^>]*>/g, '');\n  } while (value !== previous);\n  return value;\n}\n\nfunction normalizeRequirementValueFromHtml(rawHtml, fieldName) {\n  if (typeof rawHtml !== 'string') {\n    return '';\n  }\n  const normalizedBreaks = rawHtml\n    .replace(/<\\s*br\\s*\\/?\\s*>/gi, '\\n')\n    .replace(/<\\/(p|div|li|ul|ol)>/gi, '\\n')\n    .replace(/<li[^>]*>/gi, '');\n  const text = decodeHtmlEntities(stripHtmlTags(normalizedBreaks))\n    .replace(/\\r\\n/g, '\\n')\n    .replace(/\\r/g, '\\n');\n  const parts = text\n    .split('\\n')\n    .map((part) => part.replace(/\\s+/g, ' ').trim())\n    .filter((part) => part);\n  if (!parts.length) {\n    return '';\n  }\n  if (fieldName && REQUIREMENT_FIELDS_KEEP_NEWLINES.has(fieldName)) {\n    return parts.join('\\n');\n  }\n  return parts.join(', ');\n}\n\nfunction extractRequirementValueMetadata(rawHtml) {\n  if (typeof rawHtml !== 'string') {\n    return null;\n  }\n  const spanRegex = /<span([^>]*)>([\\s\\S]*?)<\\/span>/gi;\n  const lines = [];\n  let match;\n  while ((match = spanRegex.exec(rawHtml))) {\n    const attrs = match[1] || '';\n    if (!/class=[\"'][^\"']*req-sub-line[^\"']*[\"']/i.test(attrs)) {\n      continue;\n    }\n    const content = match[2] || '';\n    const text = decodeHtmlEntities(stripHtmlTags(content)).replace(/\\s+/g, ' ').trim();\n    if (!text) {\n      continue;\n    }\n    const fieldsAttrMatch = attrs.match(/data-fields=[\"']([^\"']+)[\"']/i);\n    const singleFieldMatch = fieldsAttrMatch\n      ? null\n      : attrs.match(/data-field=[\"']([^\"']+)[\"']/i);\n    const rawFields = fieldsAttrMatch ? fieldsAttrMatch[1] : singleFieldMatch ? singleFieldMatch[1] : '';\n    const fields = typeof rawFields === 'string'\n      ? rawFields.split(/\\s+/).map((field) => field.trim()).filter((field) => field)\n      : [];\n    lines.push({ text, fields });\n  }\n  return lines.length ? { lines } : null;\n}\n\nfunction mapLegacyRequirementLabel(labelText) {\n  if (typeof labelText !== 'string') {\n    return '';\n  }\n  const normalized = labelText\n    .normalize('NFD')\n    .replace(/[\\u0300-\\u036f]/g, '')\n    .replace(/[:]/g, '')\n    .replace(/[^a-zA-Z0-9]+/g, ' ')\n    .trim()\n    .toLowerCase();\n  if (!normalized) {\n    return '';\n  }\n  return LEGACY_PROJECT_LABEL_FIELD_MAP.get(normalized) || '';\n}\n\nfunction extractProjectInfoFromHtml(html) {\n  if (typeof html !== 'string') {\n    return null;\n  }\n  const trimmed = html.trim();\n  if (!trimmed) {\n    return null;\n  }\n  const info = {};\n  const gridOpenMatch = trimmed.match(/<div[^>]*class=[\"'][^\"']*requirements-grid[^\"']*[\"'][^>]*>/i);\n  const gridStartIndex = gridOpenMatch ? gridOpenMatch.index : -1;\n  if (gridStartIndex === -1) {\n    const headingMatch = trimmed.match(/<h2[^>]*>([\\s\\S]*?)<\\/h2>/i);\n    if (headingMatch) {\n      const title = decodeHtmlEntities(stripHtmlTags(headingMatch[1]));\n      const projectName = title.replace(/[\"']/g, '').trim();\n      if (projectName) {\n        info.projectName = projectName;\n      }\n    }\n    return Object.keys(info).length ? info : null;\n  }\n  const gridHtml = trimmed.slice(gridStartIndex);\n  const prefix = trimmed.slice(0, gridStartIndex);\n  const headingMatch = prefix.match(/<h2[^>]*>([\\s\\S]*?)<\\/h2>/i);\n  if (headingMatch) {\n    const title = decodeHtmlEntities(stripHtmlTags(headingMatch[1]));\n    const projectName = title.replace(/[\"']/g, '').trim();\n    if (projectName && !/gear list/i.test(projectName)) {\n      info.projectName = projectName;\n    }\n  }\n  const boxRegex = /<div[^>]*class=[\"'][^\"']*requirement-box[^\"']*[\"'][^>]*>[\\s\\S]*?<\\/div>/gi;\n  let match;\n  const textsObj = typeof window !== 'undefined' && window.texts ? window.texts : null;\n  const globalLang = typeof window !== 'undefined' && window.currentLang ? window.currentLang : null;\n  const lang = typeof globalLang === 'string' && textsObj && textsObj[globalLang] ? globalLang : 'en';\n  const projectLabels = textsObj && textsObj[lang] && textsObj[lang].projectFields\n    ? textsObj[lang].projectFields\n    : textsObj && textsObj.en && textsObj.en.projectFields\n      ? textsObj.en.projectFields\n      : {};\n  while ((match = boxRegex.exec(gridHtml))) {\n    const boxHtml = match[0];\n    const fieldMatch = boxHtml.match(/data-field=[\"']([^\"']+)[\"']/i);\n    const labelMatch = boxHtml.match(/<span[^>]*class=[\"'][^\"']*req-label[^\"']*[\"'][^>]*>([\\s\\S]*?)<\\/span>/i);\n    const valueMatch = boxHtml.match(/<span[^>]*class=[\"'][^\"']*req-value[^\"']*[\"'][^>]*>([\\s\\S]*)<\\/span\\s*>/i);\n    const rawField = fieldMatch ? fieldMatch[1].trim() : '';\n    const label = labelMatch ? decodeHtmlEntities(stripHtmlTags(labelMatch[1])) : '';\n    const fieldName = rawField || mapLegacyRequirementLabel(label);\n    if (!fieldName) {\n      continue;\n    }\n    const rawValue = valueMatch ? valueMatch[1] : '';\n    const normalizedValue = normalizeRequirementValueFromHtml(rawValue, fieldName);\n    if (!normalizedValue) {\n      continue;\n    }\n    let valueToStore = normalizedValue;\n    let metadata = null;\n    if (fieldName === 'productionCompany') {\n      metadata = extractRequirementValueMetadata(rawValue);\n      const expanded = expandCombinedProductionCompanyInfo(normalizedValue, projectLabels, metadata);\n      if (expanded && typeof expanded === 'object') {\n        if (expanded.productionCompany) {\n          valueToStore = expanded.productionCompany;\n        }\n        Object.entries(expanded).forEach(([expandedField, expandedValue]) => {\n          if (expandedField === 'productionCompany') {\n            return;\n          }\n          if (!Object.prototype.hasOwnProperty.call(info, expandedField)) {\n            info[expandedField] = expandedValue;\n          }\n        });\n      }\n    }\n    if (!Object.prototype.hasOwnProperty.call(info, fieldName)) {\n      info[fieldName] = valueToStore;\n    }\n  }\n  return Object.keys(info).length ? info : null;\n}\n\nfunction cloneProjectData(value) {\n  if (Array.isArray(value)) {\n    return value.map((item) => cloneProjectData(item));\n  }\n  if (isPlainObject(value)) {\n    const clone = {};\n    Object.entries(value).forEach(([key, val]) => {\n      clone[key] = cloneProjectData(val);\n    });\n    return clone;\n  }\n  return value;\n}\n\nfunction cloneProjectInfo(projectInfo) {\n  if (!isPlainObject(projectInfo)) {\n    return null;\n  }\n  try {\n    return STORAGE_DEEP_CLONE(projectInfo);\n  } catch (error) {\n    console.warn('Unable to serialize project info during normalization', error);\n    try {\n      return cloneProjectData(projectInfo);\n    } catch (fallbackError) {\n      console.warn('Unable to deep clone project info during normalization', fallbackError);\n      return { ...projectInfo };\n    }\n  }\n}\n\nfunction sanitizeImportedCrewEntries(entries) {\n  if (!Array.isArray(entries)) {\n    return [];\n  }\n  const sanitized = [];\n  entries.forEach((entry) => {\n    if (!isPlainObject(entry)) {\n      const normalized = sanitizeImportedValue(entry);\n      if (normalized !== null && normalized !== undefined) {\n        sanitized.push(normalized);\n      }\n      return;\n    }\n    const result = {};\n    const name = typeof entry.name === 'string' ? entry.name.trim() : '';\n    if (name) {\n      result.name = name;\n    }\n    const phone = typeof entry.phone === 'string' ? entry.phone.trim() : '';\n    if (phone) {\n      result.phone = phone;\n    }\n    const email = typeof entry.email === 'string' ? entry.email.trim() : '';\n    if (email) {\n      result.email = email;\n    }\n    const websiteValue =\n      typeof entry.website === 'string'\n        ? entry.website.trim()\n        : (typeof entry.url === 'string' ? entry.url.trim() : '');\n    const website = websiteValue;\n    if (website) {\n      result.website = website;\n    }\n    const note = typeof entry.text === 'string' ? entry.text.trim() : '';\n    if (note) {\n      result.text = note;\n    }\n    const role = typeof entry.role === 'string' ? entry.role.trim() : '';\n    if (role) {\n      result.role = role;\n    }\n    if (Object.keys(result).length) {\n      sanitized.push(result);\n    }\n  });\n  return sanitized;\n}\n\nfunction sanitizeImportedValue(value) {\n  if (value === null || value === undefined) {\n    return null;\n  }\n  if (typeof value === 'string') {\n    const trimmed = value.trim();\n    return trimmed ? trimmed : null;\n  }\n  if (typeof value === 'number') {\n    return Number.isNaN(value) ? null : value;\n  }\n  if (typeof value === 'boolean') {\n    return value ? true : null;\n  }\n  if (Array.isArray(value)) {\n    const sanitized = value\n      .map((item) => sanitizeImportedValue(item))\n      .filter((item) => item !== null && item !== undefined && !(typeof item === 'string' && !item));\n    return sanitized.length ? sanitized : null;\n  }\n  if (isPlainObject(value)) {\n    return sanitizeImportedProjectInfo(value);\n  }\n  return null;\n}\n\nfunction sanitizeImportedProjectInfo(info) {\n  if (!isPlainObject(info)) {\n    return null;\n  }\n  const normalized = {};\n  const fallbackLensNames = [];\n  const fallbackLensNameSet = new Set();\n  const addFallbackLensName = (name) => {\n    if (typeof name !== 'string') {\n      return;\n    }\n    const trimmed = name.trim();\n    if (!trimmed || fallbackLensNameSet.has(trimmed)) {\n      return;\n    }\n    fallbackLensNameSet.add(trimmed);\n    fallbackLensNames.push(trimmed);\n  };\n  const registerFallbackLensNames = (source, options = {}) => {\n    if (source === null || source === undefined) {\n      return;\n    }\n    if (options.fromSelections) {\n      const entries = Array.isArray(source) ? source : [source];\n      entries.forEach((entry) => {\n        if (isMapLike(entry)) {\n          const converted = convertMapLikeToObject(entry);\n          if (converted) {\n            registerFallbackLensNames(converted, { fromSelections: true });\n            return;\n          }\n        }\n        if (isPlainObject(entry)) {\n          const mapped = deriveLensSelectionsFromNameMap(entry);\n          if (mapped.length) {\n            mapped.forEach((selection) => {\n              if (selection && typeof selection.name === 'string') {\n                addFallbackLensName(selection.name);\n              }\n            });\n            return;\n          }\n        }\n        const candidate = normalizeProjectLensNameCandidate(entry);\n        if (candidate) {\n          addFallbackLensName(candidate);\n        }\n      });\n      return;\n    }\n    const names = extractLensNamesFromSource(source);\n    if (!names.length) {\n      return;\n    }\n    names.forEach((name) => {\n      addFallbackLensName(name);\n    });\n  };\n\n  registerFallbackLensNames(info.lenses);\n  if (Object.prototype.hasOwnProperty.call(info, 'lensSelections')) {\n    registerFallbackLensNames(info.lensSelections, { fromSelections: true });\n  }\n\n  Object.entries(info).forEach(([key, raw]) => {\n    if (raw === null || raw === undefined) {\n      return;\n    }\n    if (key === 'people') {\n      const crew = sanitizeImportedCrewEntries(raw);\n      if (crew.length) {\n        normalized.people = crew;\n      }\n      return;\n    }\n    if (key === 'lenses') {\n      const { names } = normalizeProjectLensNamesField(raw);\n      normalized.lenses = names.slice();\n      return;\n    }\n    if (key === 'lensSelections') {\n      const result = normalizeProjectLensSelectionsFromSources(raw, fallbackLensNames);\n      if (result.selections && result.selections.length) {\n        normalized.lensSelections = result.selections;\n      }\n      return;\n    }\n    const value = sanitizeImportedValue(raw);\n    if (value !== null && value !== undefined) {\n      normalized[key] = value;\n    }\n  });\n\n  if (!Object.prototype.hasOwnProperty.call(normalized, 'lenses') && fallbackLensNames.length) {\n    normalized.lenses = fallbackLensNames.slice();\n  }\n  if (\n    !Object.prototype.hasOwnProperty.call(normalized, 'lensSelections')\n    && fallbackLensNames.length\n  ) {\n    const derived = normalizeProjectLensSelectionsFromSources([], fallbackLensNames);\n    if (derived.selections && derived.selections.length) {\n      normalized.lensSelections = derived.selections;\n    }\n  }\n\n  if (!Object.keys(normalized).length) {\n    return null;\n  }\n\n  const normalizedWithLegacySupport = normalizeLegacyLongGopStructure(normalized);\n  return normalizedWithLegacySupport;\n}\n\nfunction cloneAutoGearRules(rules) {\n  if (!Array.isArray(rules) || !rules.length) {\n    return null;\n  }\n  try {\n    return STORAGE_DEEP_CLONE(rules);\n  } catch (error) {\n    console.warn('Unable to serialize automatic gear rules during normalization', error);\n    try {\n      return cloneProjectData(rules);\n    } catch (fallbackError) {\n      console.warn('Unable to deep clone automatic gear rules during normalization', fallbackError);\n      return rules.slice();\n    }\n  }\n}\n\nfunction cloneDiagramPositionsForStorage(positions) {\n  if (!isPlainObject(positions) || !Object.keys(positions).length) {\n    return {};\n  }\n  try {\n    return STORAGE_DEEP_CLONE(positions);\n  } catch (error) {\n    console.warn('Unable to serialize diagram positions during normalization', error);\n    try {\n      return cloneProjectData(positions);\n    } catch (fallbackError) {\n      console.warn('Unable to deep clone diagram positions during normalization', fallbackError);\n      return { ...positions };\n    }\n  }\n}\n\nvar PROJECT_FILTER_DEFAULT_SIZE = '4x5.65';\n\nfunction normalizeImportedFilterValues(raw) {\n  if (raw === null || raw === undefined) {\n    return [];\n  }\n\n  if (Array.isArray(raw)) {\n    const values = [];\n    raw.forEach((item) => {\n      if (item === null || item === undefined) {\n        return;\n      }\n      if (Array.isArray(item)) {\n        values.push(...normalizeImportedFilterValues(item));\n        return;\n      }\n      if (isMapLike(item)) {\n        const converted = convertMapLikeToObject(item);\n        if (converted) {\n          values.push(...normalizeImportedFilterValues(converted));\n          return;\n        }\n      }\n      if (typeof item === 'object') {\n        values.push(...normalizeImportedFilterValues(Object.values(item)));\n        return;\n      }\n      const normalized = String(item).trim();\n      if (normalized) {\n        values.push(normalized);\n      }\n    });\n    return values;\n  }\n\n  if (isMapLike(raw)) {\n    const converted = convertMapLikeToObject(raw);\n    if (converted) {\n      return normalizeImportedFilterValues(converted);\n    }\n  }\n\n  if (typeof raw === 'object') {\n    if (Object.prototype.hasOwnProperty.call(raw, 'values')) {\n      return normalizeImportedFilterValues(raw.values);\n    }\n    if (Object.prototype.hasOwnProperty.call(raw, 'selected')) {\n      return normalizeImportedFilterValues(raw.selected);\n    }\n    return normalizeImportedFilterValues(Object.values(raw));\n  }\n\n  if (typeof raw === 'string') {\n    const trimmed = raw.trim();\n    if (!trimmed || trimmed === '!') {\n      return [];\n    }\n    const parsed = tryParseJSONLike(trimmed);\n    if (parsed.success) {\n      return normalizeImportedFilterValues(parsed.parsed);\n    }\n    return trimmed\n      .split(/[|,]/)\n      .map((value) => value.trim())\n      .filter((value) => value);\n  }\n\n  const normalized = String(raw).trim();\n  return normalized ? [normalized] : [];\n}\n\nfunction normalizeImportedFilterEntry(entry, fallbackType = '') {\n  if (entry === null || entry === undefined) {\n    return null;\n  }\n\n  if (typeof entry === 'string') {\n    const trimmed = entry.trim();\n    if (!trimmed) {\n      return null;\n    }\n    const parsed = tryParseJSONLike(trimmed);\n    if (parsed.success) {\n      return normalizeImportedFilterEntry(parsed.parsed, fallbackType);\n    }\n    const parts = trimmed.split(':');\n    const typePart = parts.shift();\n    const type = typePart ? typePart.trim() : '';\n    if (!type) {\n      return null;\n    }\n    const sizePart = parts.shift();\n    const size = sizePart && sizePart.trim() ? sizePart.trim() : PROJECT_FILTER_DEFAULT_SIZE;\n    if (!parts.length) {\n      return { type, size, values: [], hasExplicitValues: false };\n    }\n    const rawValues = parts.join(':');\n    if (rawValues === '!') {\n      return { type, size, values: [], hasExplicitValues: true };\n    }\n    const values = normalizeImportedFilterValues(rawValues);\n    return {\n      type,\n      size,\n      values,\n      hasExplicitValues: true,\n    };\n  }\n\n  if (Array.isArray(entry)) {\n    if (!entry.length) {\n      return null;\n    }\n    if (entry.length === 1) {\n      return normalizeImportedFilterEntry(entry[0], fallbackType);\n    }\n    const [typeCandidate, sizeCandidate, valuesCandidate] = entry;\n    let type = typeof typeCandidate === 'string' ? typeCandidate.trim() : '';\n    if (!type && typeof fallbackType === 'string') {\n      type = fallbackType.trim();\n    }\n    if (!type) {\n      return null;\n    }\n    const size = typeof sizeCandidate === 'string' && sizeCandidate.trim()\n      ? sizeCandidate.trim()\n      : PROJECT_FILTER_DEFAULT_SIZE;\n    const hasExplicitValues = entry.length > 2;\n    const values = hasExplicitValues ? normalizeImportedFilterValues(valuesCandidate) : [];\n    return { type, size, values, hasExplicitValues };\n  }\n\n  if (isMapLike(entry)) {\n    const converted = convertMapLikeToObject(entry);\n    if (converted) {\n      return normalizeImportedFilterEntry(converted, fallbackType);\n    }\n  }\n\n  if (typeof entry === 'object') {\n    let type = '';\n    const typeKeys = ['type', 'filter', 'name', 'label'];\n    for (let i = 0; i < typeKeys.length; i += 1) {\n      const key = typeKeys[i];\n      if (typeof entry[key] === 'string') {\n        const candidate = entry[key].trim();\n        if (candidate) {\n          type = candidate;\n          break;\n        }\n      }\n    }\n    if (!type && typeof fallbackType === 'string' && fallbackType.trim()) {\n      type = fallbackType.trim();\n    }\n    if (!type) {\n      return null;\n    }\n\n    const sizeKeys = ['size', 'filterSize', 'format', 'dimension', 'dimensions', 'diameter'];\n    let size = '';\n    for (let i = 0; i < sizeKeys.length; i += 1) {\n      const key = sizeKeys[i];\n      if (typeof entry[key] === 'string') {\n        const candidate = entry[key].trim();\n        if (candidate) {\n          size = candidate;\n          break;\n        }\n      }\n    }\n    if (!size) {\n      size = PROJECT_FILTER_DEFAULT_SIZE;\n    }\n\n    const valueKeys = [\n      'values',\n      'value',\n      'strengths',\n      'strength',\n      'options',\n      'selected',\n      'selections',\n      'choices',\n    ];\n    let hasExplicitValues = false;\n    let values = [];\n    for (let i = 0; i < valueKeys.length; i += 1) {\n      const key = valueKeys[i];\n      if (Object.prototype.hasOwnProperty.call(entry, key)) {\n        hasExplicitValues = true;\n        values = normalizeImportedFilterValues(entry[key]);\n        break;\n      }\n    }\n\n    return { type, size, values, hasExplicitValues };\n  }\n\n  return null;\n}\n\nfunction serializeNormalizedFilterEntry(entry) {\n  if (!entry || !entry.type) {\n    return null;\n  }\n  const type = entry.type;\n  const size = entry.size && entry.size.trim() ? entry.size.trim() : PROJECT_FILTER_DEFAULT_SIZE;\n  let token = `${type}:${size}`;\n  const values = Array.isArray(entry.values)\n    ? Array.from(\n      new Set(\n        entry.values\n          .map((value) => (typeof value === 'string' ? value.trim() : String(value ?? '').trim()))\n          .filter((value) => value),\n      ),\n    )\n    : [];\n  if (entry.hasExplicitValues || values.length) {\n    token += values.length ? `:${values.join('|')}` : ':!';\n  }\n  return token;\n}\n\nfunction normalizeImportedFilterValue(value) {\n  if (value === undefined) {\n    return null;\n  }\n  if (value === null) {\n    return '';\n  }\n  if (typeof value === 'string') {\n    const trimmed = value.trim();\n    if (!trimmed) {\n      return '';\n    }\n    const parsed = tryParseJSONLike(trimmed);\n    if (parsed.success) {\n      return normalizeImportedFilterValue(parsed.parsed);\n    }\n    return trimmed;\n  }\n  if (Array.isArray(value)) {\n    const entries = value\n      .map((entry) => normalizeImportedFilterEntry(entry))\n      .filter(Boolean);\n    if (!entries.length) {\n      return '';\n    }\n    return entries\n      .map((entry) => serializeNormalizedFilterEntry(entry))\n      .filter(Boolean)\n      .join(',');\n  }\n  if (isMapLike(value)) {\n    const converted = convertMapLikeToObject(value);\n    if (converted) {\n      return normalizeImportedFilterValue(converted);\n    }\n  }\n  if (typeof value === 'object') {\n    const singleEntry = normalizeImportedFilterEntry(value);\n    if (singleEntry) {\n      const serialized = serializeNormalizedFilterEntry(singleEntry);\n      return serialized || '';\n    }\n    const entries = [];\n    Object.entries(value).forEach(([key, candidate]) => {\n      const normalized = normalizeImportedFilterEntry(candidate, key);\n      if (normalized) {\n        entries.push(normalized);\n      }\n    });\n    if (!entries.length) {\n      return '';\n    }\n    return entries\n      .map((entry) => serializeNormalizedFilterEntry(entry))\n      .filter(Boolean)\n      .join(',');\n  }\n  return String(value).trim();\n}\n\nfunction normalizeImportedProjectFilters(info) {\n  if (!isPlainObject(info)) {\n    return;\n  }\n\n  const normalizedFilter = normalizeImportedFilterValue(info.filter);\n  if (normalizedFilter !== null) {\n    if (normalizedFilter) {\n      info.filter = normalizedFilter;\n    } else {\n      delete info.filter;\n    }\n  } else {\n    const fallback = normalizeImportedFilterValue(info.filters);\n    if (fallback !== null) {\n      if (fallback) {\n        info.filter = fallback;\n      } else {\n        delete info.filter;\n      }\n    }\n  }\n\n  if (Object.prototype.hasOwnProperty.call(info, 'filters')) {\n    delete info.filters;\n  }\n}\n\nfunction cloneProjectGearSelectors(selectors) {\n  if (!isPlainObject(selectors)) {\n    return null;\n  }\n\n  const cloneSelectorValue = (value) => {\n    if (Array.isArray(value)) {\n      const result = value\n        .map((item) => cloneSelectorValue(item))\n        .filter((item) => item !== undefined);\n      return result;\n    }\n    if (isPlainObject(value)) {\n      const nested = {};\n      Object.entries(value).forEach(([key, nestedValue]) => {\n        if (typeof key !== 'string' || !key) {\n          return;\n        }\n        const clonedNestedValue = cloneSelectorValue(nestedValue);\n        if (clonedNestedValue !== undefined) {\n          nested[key] = clonedNestedValue;\n        }\n      });\n      return nested;\n    }\n    if (value === undefined || value === null) {\n      return '';\n    }\n    if (typeof value === 'string') {\n      return value;\n    }\n    if (typeof value === 'number' || typeof value === 'boolean') {\n      return String(value);\n    }\n    try {\n      return String(value);\n    } catch (stringifyError) {\n      void stringifyError;\n    }\n    return '';\n  };\n\n  const clone = {};\n  Object.entries(selectors).forEach(([id, value]) => {\n    if (typeof id !== 'string' || !id) {\n      return;\n    }\n    const clonedValue = cloneSelectorValue(value);\n    if (clonedValue !== undefined) {\n      clone[id] = clonedValue;\n    }\n  });\n  return Object.keys(clone).length ? clone : null;\n}\n\nfunction normalizeProjectPowerSelection(raw) {\n  if (raw == null) {\n    return null;\n  }\n  const normalizeString = (value) => {\n    if (typeof value === \"string\") {\n      return value.trim();\n    }\n    if (value === null || value === undefined) {\n      return \"\";\n    }\n    if (typeof value === \"number\" || typeof value === \"boolean\") {\n      return String(value);\n    }\n    return \"\";\n  };\n  if (!isPlainObject(raw)) {\n    return null;\n  }\n  const normalized = {\n    batteryPlate: normalizeString(raw.batteryPlate),\n    battery: normalizeString(raw.battery),\n    batteryHotswap: normalizeString(raw.batteryHotswap),\n  };\n  const hasValue = Object.keys(normalized).some((key) => normalized[key]);\n  return hasValue ? normalized : null;\n}\n\nfunction cloneProjectPowerSelection(selection) {\n  const normalized = normalizeProjectPowerSelection(selection);\n  if (!normalized) {\n    return null;\n  }\n  return {\n    batteryPlate: normalized.batteryPlate,\n    battery: normalized.battery,\n    batteryHotswap: normalized.batteryHotswap,\n  };\n}\n\nconst LEGACY_LENS_SELECTION_META_KEYS = new Set([\n  'name',\n  'lensname',\n  'label',\n  'title',\n  'text',\n  'lens',\n  'mount',\n  'mountlabel',\n  'mountname',\n  'mounts',\n  'note',\n  'notes',\n  'names',\n  'values',\n  'selection',\n  'legacyvalue',\n  'lensselections',\n  'selections',\n  'entries',\n  'items',\n  'options',\n  'meta',\n  'metadata',\n  'count',\n  'version',\n  'length',\n  'size',\n  'updated',\n  'created',\n  'createdat',\n  'timestamp',\n  'id',\n  'uuid',\n  'key',\n  'value',\n]);\n\nfunction isLikelyLensNameKey(key) {\n  if (typeof key !== 'string') {\n    return false;\n  }\n  const trimmed = key.trim();\n  if (!trimmed) {\n    return false;\n  }\n  if (/^[0-9]+$/u.test(trimmed)) {\n    return false;\n  }\n  const normalized = trimmed.toLowerCase();\n  if (normalized.startsWith('__proto__')) {\n    return false;\n  }\n  if (normalized === 'prototype' || normalized === 'constructor') {\n    return false;\n  }\n  if (LEGACY_LENS_SELECTION_META_KEYS.has(normalized)) {\n    return false;\n  }\n  return true;\n}\n\nfunction deriveLensNameKeysFromObject(value) {\n  if (!isPlainObject(value)) {\n    return [];\n  }\n  const keys = Object.keys(value);\n  const result = [];\n  keys.forEach((key) => {\n    if (!isLikelyLensNameKey(key)) {\n      return;\n    }\n    const trimmed = key.trim();\n    if (trimmed) {\n      result.push(trimmed);\n    }\n  });\n  return result;\n}\n\nfunction normalizeProjectLensNameCandidate(value) {\n  if (value === null || value === undefined) {\n    return '';\n  }\n\n  if (\n    typeof value === 'string'\n    || typeof value === 'number'\n    || typeof value === 'boolean'\n    || typeof value === 'bigint'\n  ) {\n    const stringValue = typeof value === 'string' ? value : String(value);\n    const trimmed = stringValue.trim();\n    return trimmed;\n  }\n\n  if (Array.isArray(value)) {\n    for (let index = 0; index < value.length; index += 1) {\n      const candidate = normalizeProjectLensNameCandidate(value[index]);\n      if (candidate) {\n        return candidate;\n      }\n    }\n    return '';\n  }\n\n  if (isMapLike(value)) {\n    const converted = convertMapLikeToObject(value);\n    if (converted) {\n      return normalizeProjectLensNameCandidate(converted);\n    }\n  }\n\n  if (isPlainObject(value)) {\n    const nameCandidates = [\n      value.name,\n      value.lensName,\n      value.label,\n      value.title,\n      value.text,\n      value.lens,\n    ];\n    for (let index = 0; index < nameCandidates.length; index += 1) {\n      const candidate = nameCandidates[index];\n      if (typeof candidate === 'string') {\n        const trimmed = candidate.trim();\n        if (trimmed) {\n          return trimmed;\n        }\n      }\n    }\n\n    const keyDerivedNames = deriveLensNameKeysFromObject(value);\n    if (keyDerivedNames.length) {\n      return keyDerivedNames[0];\n    }\n\n    if (Array.isArray(value.names) && value.names.length) {\n      const nestedName = normalizeProjectLensNameCandidate(value.names[0]);\n      if (nestedName) {\n        return nestedName;\n      }\n    }\n\n    if (Array.isArray(value.values) && value.values.length) {\n      const nestedValue = normalizeProjectLensNameCandidate(value.values[0]);\n      if (nestedValue) {\n        return nestedValue;\n      }\n    }\n\n    const nestedEntries = Object.values(value);\n    for (let index = 0; index < nestedEntries.length; index += 1) {\n      const nested = normalizeProjectLensNameCandidate(nestedEntries[index]);\n      if (nested) {\n        return nested;\n      }\n    }\n  }\n\n  return '';\n}\n\nfunction extractLensNamesFromSource(value) {\n  if (value === null || value === undefined) {\n    return [];\n  }\n\n  if (Array.isArray(value)) {\n    const names = [];\n    value.forEach((entry) => {\n      if (entry === null || entry === undefined) {\n        return;\n      }\n      if (typeof entry === 'string') {\n        const parsed = tryParseJSONLike(entry);\n        if (parsed.success) {\n          names.push(...extractLensNamesFromSource(parsed.parsed));\n          return;\n        }\n        const trimmed = entry.trim();\n        if (trimmed) {\n          names.push(trimmed);\n        }\n        return;\n      }\n      if (\n        typeof entry === 'number'\n        || typeof entry === 'boolean'\n        || typeof entry === 'bigint'\n      ) {\n        names.push(String(entry));\n        return;\n      }\n      const normalized = normalizeProjectLensNameCandidate(entry);\n      if (normalized) {\n        names.push(normalized);\n        return;\n      }\n      if (Array.isArray(entry)) {\n        names.push(...extractLensNamesFromSource(entry));\n        return;\n      }\n      if (isMapLike(entry)) {\n        const converted = convertMapLikeToObject(entry);\n        if (converted) {\n          names.push(...extractLensNamesFromSource(converted));\n        }\n        return;\n      }\n      if (isPlainObject(entry)) {\n        names.push(...extractLensNamesFromSource(Object.values(entry)));\n      }\n    });\n    return names;\n  }\n\n  if (\n    typeof value === 'number'\n    || typeof value === 'boolean'\n    || typeof value === 'bigint'\n  ) {\n    return [String(value)];\n  }\n\n  if (typeof value === 'string') {\n    const parsed = tryParseJSONLike(value);\n    if (parsed.success) {\n      return extractLensNamesFromSource(parsed.parsed);\n    }\n    return value\n      .split(/[\\n,;]/u)\n      .map((part) => part.trim())\n      .filter((part) => part);\n  }\n\n  if (isMapLike(value)) {\n    const converted = convertMapLikeToObject(value);\n    if (converted) {\n      return extractLensNamesFromSource(converted);\n    }\n  }\n\n  if (isPlainObject(value)) {\n    const keyNames = deriveLensNameKeysFromObject(value);\n    if (keyNames.length) {\n      return keyNames;\n    }\n    const direct = normalizeProjectLensNameCandidate(value);\n    if (direct) {\n      return [direct];\n    }\n    const collected = [];\n    if (Array.isArray(value.names)) {\n      collected.push(...extractLensNamesFromSource(value.names));\n    }\n    if (Array.isArray(value.values)) {\n      collected.push(...extractLensNamesFromSource(value.values));\n    }\n    if (!collected.length) {\n      collected.push(...extractLensNamesFromSource(Object.values(value)));\n    }\n    return collected;\n  }\n\n  return [];\n}\n\nfunction normalizeProjectLensNamesField(value) {\n  const names = extractLensNamesFromSource(value);\n  const isNormalized = Array.isArray(value)\n    && value.length === names.length\n    && value.every(\n      (entry, index) => typeof entry === 'string' && entry.trim() === names[index],\n    );\n  return { names, changed: !isNormalized };\n}\n\nfunction normalizeProjectLensSelectionEntry(entry) {\n  if (entry === null || entry === undefined) {\n    return { selection: null, changed: false };\n  }\n\n  if (\n    typeof entry === 'string'\n    || typeof entry === 'number'\n    || typeof entry === 'boolean'\n    || typeof entry === 'bigint'\n  ) {\n    const name = normalizeProjectLensNameCandidate(entry);\n    if (!name) {\n      return { selection: null, changed: true };\n    }\n    return { selection: { name, mount: '' }, changed: true };\n  }\n\n  if (isMapLike(entry)) {\n    const converted = convertMapLikeToObject(entry);\n    if (converted) {\n      return normalizeProjectLensSelectionEntry(converted);\n    }\n  }\n\n  if (Array.isArray(entry)) {\n    if (!entry.length) {\n      return { selection: null, changed: true };\n    }\n    const name = normalizeProjectLensNameCandidate(entry[0]);\n    if (!name) {\n      return { selection: null, changed: true };\n    }\n    const mountValue = entry.length > 1 ? entry[1] : '';\n    const mount = typeof mountValue === 'string' ? mountValue.trim() : '';\n    const normalized = { name };\n    normalized.mount = mount || '';\n    return { selection: normalized, changed: true };\n  }\n\n  if (isPlainObject(entry)) {\n    const normalized = { ...entry };\n    let changed = false;\n\n    const name = normalizeProjectLensNameCandidate(entry);\n    if (!name) {\n      return { selection: null, changed: true };\n    }\n    if (normalized.name !== name) {\n      normalized.name = name;\n      changed = true;\n    }\n    if (!Object.prototype.hasOwnProperty.call(normalized, 'name')) {\n      normalized.name = name;\n      changed = true;\n    }\n\n    const mountCandidates = [];\n    if (typeof entry.mount === 'string') {\n      mountCandidates.push(entry.mount);\n    }\n    if (typeof entry.mountLabel === 'string') {\n      mountCandidates.push(entry.mountLabel);\n    }\n    if (typeof entry.mountName === 'string') {\n      mountCandidates.push(entry.mountName);\n    }\n    if (Array.isArray(entry.mounts)) {\n      for (let index = 0; index < entry.mounts.length; index += 1) {\n        const candidate = entry.mounts[index];\n        if (typeof candidate === 'string' && candidate.trim()) {\n          mountCandidates.push(candidate);\n          break;\n        }\n      }\n    }\n\n    let mount = '';\n    for (let index = 0; index < mountCandidates.length; index += 1) {\n      const candidate = mountCandidates[index];\n      if (typeof candidate === 'string') {\n        const trimmed = candidate.trim();\n        if (trimmed) {\n          mount = trimmed;\n          break;\n        }\n      }\n    }\n\n    if (typeof normalized.mount === 'string') {\n      const trimmedMount = normalized.mount.trim();\n      if (trimmedMount !== normalized.mount) {\n        normalized.mount = trimmedMount;\n        changed = true;\n      }\n      if (!mount && trimmedMount) {\n        mount = trimmedMount;\n      }\n    }\n\n    if (!mount) {\n      mount = '';\n    }\n\n    if (normalized.mount !== mount) {\n      normalized.mount = mount;\n      changed = true;\n    }\n\n    if (!Object.prototype.hasOwnProperty.call(normalized, 'mount')) {\n      normalized.mount = mount;\n      changed = true;\n    }\n\n    return { selection: normalized, changed };\n  }\n\n  return { selection: null, changed: true };\n}\n\nfunction deriveLensSelectionsFromNameMap(source) {\n  if (!isPlainObject(source)) {\n    return [];\n  }\n\n  const directNameCandidates = [\n    source.name,\n    source.lensName,\n    source.label,\n    source.title,\n    source.text,\n    source.lens,\n  ];\n  for (let index = 0; index < directNameCandidates.length; index += 1) {\n    const candidate = directNameCandidates[index];\n    if (typeof candidate === 'string' && candidate.trim()) {\n      return [];\n    }\n  }\n\n  const derived = [];\n  Object.entries(source).forEach(([rawKey, rawValue]) => {\n    if (!isLikelyLensNameKey(rawKey)) {\n      return;\n    }\n    const name = rawKey.trim();\n    if (!name) {\n      return;\n    }\n\n    let value = rawValue;\n    if (isMapLike(value)) {\n      const converted = convertMapLikeToObject(value);\n      if (converted) {\n        value = converted;\n      }\n    }\n\n    if (isPlainObject(value)) {\n      const selection = { ...value };\n      selection.name = name;\n      let mount = '';\n      const mountFields = ['mount', 'mountLabel', 'mountName'];\n      for (let index = 0; index < mountFields.length; index += 1) {\n        const field = mountFields[index];\n        if (typeof selection[field] !== 'string') {\n          continue;\n        }\n        const candidate = selection[field].trim();\n        if (candidate && candidate.toLowerCase() !== name.toLowerCase()) {\n          mount = candidate;\n          break;\n        }\n      }\n      if (!mount && Array.isArray(selection.mounts)) {\n        const candidate = normalizeProjectLensNameCandidate(selection.mounts);\n        if (candidate && candidate.toLowerCase() !== name.toLowerCase()) {\n          mount = candidate;\n        }\n      }\n      selection.mount = typeof mount === 'string' ? mount : '';\n      derived.push(selection);\n      return;\n    }\n\n    if (Array.isArray(value)) {\n      const candidate = normalizeProjectLensNameCandidate(value);\n      const mount = candidate && candidate.toLowerCase() !== name.toLowerCase() ? candidate : '';\n      derived.push({ name, mount });\n      return;\n    }\n\n    if (\n      typeof value === 'string'\n      || typeof value === 'number'\n      || typeof value === 'boolean'\n      || typeof value === 'bigint'\n    ) {\n      const candidate = normalizeProjectLensNameCandidate(value);\n      const mount = candidate && candidate.toLowerCase() !== name.toLowerCase() ? candidate : '';\n      derived.push({ name, mount });\n      return;\n    }\n\n    if (value === null || value === undefined) {\n      derived.push({ name, mount: '' });\n      return;\n    }\n\n    const fallback = normalizeProjectLensNameCandidate(value);\n    const mount = fallback && fallback.toLowerCase() !== name.toLowerCase() ? fallback : '';\n    derived.push({ name, mount });\n  });\n  return derived;\n}\n\nfunction normalizeProjectLensSelectionsFromSources(sources, fallbackNames = []) {\n  const sourceList = Array.isArray(sources) ? sources : [sources];\n  const normalized = [];\n  const seenNames = new Set();\n  let changed = false;\n\n  const addSelection = (selection, entryChanged) => {\n    if (!selection || typeof selection !== 'object') {\n      if (entryChanged) {\n        changed = true;\n      }\n      return;\n    }\n\n    const clone = { ...selection };\n    const rawName = typeof clone.name === 'string' ? clone.name : '';\n    const name = rawName.trim();\n    if (!name) {\n      if (entryChanged) {\n        changed = true;\n      }\n      return;\n    }\n\n    if (clone.name !== name) {\n      clone.name = name;\n      entryChanged = true;\n    }\n\n    const rawMount = typeof clone.mount === 'string' ? clone.mount : '';\n    const mount = rawMount.trim();\n    if (clone.mount !== mount) {\n      clone.mount = mount;\n      entryChanged = true;\n    }\n    if (!Object.prototype.hasOwnProperty.call(clone, 'mount')) {\n      clone.mount = mount;\n      entryChanged = true;\n    }\n\n    if (Object.prototype.hasOwnProperty.call(clone, 'mountState')) {\n      const rawMountState = typeof clone.mountState === 'string' ? clone.mountState : '';\n      const mountState = rawMountState.trim();\n      if (clone.mountState !== mountState) {\n        clone.mountState = mountState;\n        entryChanged = true;\n      }\n      if (!mountState) {\n        delete clone.mountState;\n        entryChanged = true;\n      }\n    }\n\n    if (entryChanged) {\n      changed = true;\n    }\n\n    normalized.push(clone);\n    seenNames.add(name);\n  };\n\n  const processSourceValue = (source) => {\n    if (source === null || source === undefined) {\n      return;\n    }\n\n    if (typeof source === 'string') {\n      const parsed = tryParseJSONLike(source);\n      if (parsed.success) {\n        processSourceValue(parsed.parsed);\n        changed = true;\n        return;\n      }\n      const names = extractLensNamesFromSource(source);\n      if (names.length) {\n        names.forEach((name) => {\n          addSelection({ name, mount: '' }, true);\n        });\n      } else {\n        changed = true;\n      }\n      return;\n    }\n\n    if (\n      typeof source === 'number'\n      || typeof source === 'boolean'\n      || typeof source === 'bigint'\n    ) {\n      addSelection({ name: String(source), mount: '' }, true);\n      return;\n    }\n\n    if (Array.isArray(source)) {\n      if (\n        source.length\n        && source.length <= 2\n        && (\n          typeof source[0] === 'string'\n          || typeof source[0] === 'number'\n          || typeof source[0] === 'boolean'\n          || typeof source[0] === 'bigint'\n        )\n      ) {\n        const { selection, changed: entryChanged } = normalizeProjectLensSelectionEntry(source);\n        if (selection) {\n          addSelection(selection, entryChanged);\n          return;\n        }\n      }\n      source.forEach((entry) => {\n        const { selection, changed: entryChanged } = normalizeProjectLensSelectionEntry(entry);\n        if (selection) {\n          addSelection(selection, entryChanged);\n        } else if (entryChanged) {\n          changed = true;\n        }\n      });\n      return;\n    }\n\n    if (isMapLike(source)) {\n      const converted = convertMapLikeToObject(source);\n      if (converted) {\n        processSourceValue(converted);\n        changed = true;\n      }\n      return;\n    }\n\n    if (isPlainObject(source)) {\n      const mappedSelections = deriveLensSelectionsFromNameMap(source);\n      if (mappedSelections.length) {\n        mappedSelections.forEach((entry) => {\n          addSelection(entry, true);\n        });\n        return;\n      }\n      const { selection, changed: entryChanged } = normalizeProjectLensSelectionEntry(source);\n      if (selection) {\n        addSelection(selection, entryChanged);\n        return;\n      }\n      const values = Object.values(source);\n      if (values.length) {\n        processSourceValue(values);\n        changed = true;\n      }\n      return;\n    }\n\n    const fallbackName = normalizeProjectLensNameCandidate(source);\n    if (fallbackName) {\n      addSelection({ name: fallbackName, mount: '' }, true);\n    } else {\n      changed = true;\n    }\n  };\n\n  for (let index = 0; index < sourceList.length; index += 1) {\n    processSourceValue(sourceList[index]);\n  }\n\n  if (Array.isArray(fallbackNames)) {\n    fallbackNames.forEach((rawName) => {\n      if (typeof rawName !== 'string') {\n        return;\n      }\n      const name = rawName.trim();\n      if (!name || seenNames.has(name)) {\n        return;\n      }\n      normalized.push({ name, mount: '' });\n      seenNames.add(name);\n      changed = true;\n    });\n  }\n\n  if (!normalized.length) {\n    return { selections: null, changed };\n  }\n\n  return { selections: normalized, changed };\n}\n\nfunction normalizeProject(data) {\n  const restored = restoreCompressedProjectEntry(data);\n  if (restored.restored) {\n    return normalizeProject(restored.value);\n  }\n\n  if (typeof data === \"string\") {\n    const parsed = tryParseJSONLike(data);\n    if (parsed.success) {\n      const normalized = normalizeProject(parsed.parsed);\n      if (normalized) {\n        return normalized;\n      }\n    }\n    return normalizeProject({ gearList: data, projectInfo: null });\n  }\n  if (isMapLike(data)) {\n    const converted = convertMapLikeToObject(data);\n    if (converted) {\n      return normalizeProject(converted);\n    }\n    return null;\n  }\n  if (isPlainObject(data)) {\n    // New format { gearList, projectInfo }\n    if (Object.prototype.hasOwnProperty.call(data, \"gearList\") || Object.prototype.hasOwnProperty.call(data, \"projectInfo\")) {\n      const projectContainer = isMapLike(data.project)\n        ? convertMapLikeToObject(data.project)\n        : data.project;\n\n      let projectInfoSource = data.projectInfo;\n      if (isMapLike(projectInfoSource)) {\n        projectInfoSource = convertMapLikeToObject(projectInfoSource);\n      }\n\n      let normalizedProjectInfo = isPlainObject(projectInfoSource)\n        ? projectInfoSource\n        : null;\n      if (!normalizedProjectInfo && typeof projectInfoSource === \"string\") {\n        const parsedInfo = tryParseJSONLike(projectInfoSource);\n        if (parsedInfo.success && isPlainObject(parsedInfo.parsed)) {\n          normalizedProjectInfo = parsedInfo.parsed;\n        }\n      }\n      if (!normalizedProjectInfo && isPlainObject(projectContainer)) {\n        let nestedProjectInfo = projectContainer.projectInfo;\n        if (isMapLike(nestedProjectInfo)) {\n          nestedProjectInfo = convertMapLikeToObject(nestedProjectInfo);\n        }\n        if (isPlainObject(nestedProjectInfo)) {\n          normalizedProjectInfo = nestedProjectInfo;\n        } else if (typeof nestedProjectInfo === \"string\") {\n          const parsedProjectInfo = tryParseJSONLike(nestedProjectInfo);\n          if (parsedProjectInfo.success && isPlainObject(parsedProjectInfo.parsed)) {\n            normalizedProjectInfo = parsedProjectInfo.parsed;\n          }\n        }\n      }\n\n      let normalizedAutoGearRules = null;\n      const assignAutoGearRules = (source) => {\n        if (normalizedAutoGearRules && normalizedAutoGearRules.length) {\n          return;\n        }\n        if (source === null || source === undefined) {\n          return;\n        }\n        let candidate = source;\n        if (isMapLike(candidate)) {\n          const convertedRules = convertMapLikeToObject(candidate);\n          if (convertedRules) {\n            candidate = Object.values(convertedRules).filter((entry) => entry !== null && entry !== undefined);\n          }\n        }\n        if (Array.isArray(candidate) && candidate.length) {\n          normalizedAutoGearRules = candidate;\n          return;\n        }\n        if (isPlainObject(candidate)) {\n          const values = Object.values(candidate).filter((entry) => entry !== null && entry !== undefined);\n          if (values.length) {\n            normalizedAutoGearRules = values;\n            return;\n          }\n        }\n        if (typeof candidate === \"string\") {\n          const parsedRules = tryParseJSONLike(candidate);\n          if (parsedRules.success && Array.isArray(parsedRules.parsed) && parsedRules.parsed.length) {\n            normalizedAutoGearRules = parsedRules.parsed;\n          }\n        }\n      };\n\n      assignAutoGearRules(data.autoGearRules);\n      if (!normalizedAutoGearRules && isPlainObject(projectContainer)) {\n        assignAutoGearRules(projectContainer.autoGearRules);\n      }\n\n      let gearListSource = isMapLike(data.gearList)\n        ? convertMapLikeToObject(data.gearList)\n        : data.gearList;\n      if (\n        (gearListSource === null\n          || gearListSource === undefined\n          || (typeof gearListSource === \"string\" && !gearListSource))\n        && isPlainObject(projectContainer)\n        && Object.prototype.hasOwnProperty.call(projectContainer, \"gearList\")\n      ) {\n        gearListSource = projectContainer.gearList;\n      }\n      if (isMapLike(gearListSource)) {\n        const convertedGearList = convertMapLikeToObject(gearListSource);\n        if (convertedGearList) {\n          gearListSource = convertedGearList;\n        }\n      }\n\n      let normalizedGearList =\n        typeof gearListSource === \"string\" || (gearListSource && typeof gearListSource === \"object\")\n          ? gearListSource\n          : \"\";\n\n      let normalizedGearSelectors = null;\n      const gearSelectorsSource = isMapLike(data.gearSelectors)\n        ? convertMapLikeToObject(data.gearSelectors)\n        : data.gearSelectors;\n      if (isPlainObject(gearSelectorsSource)) {\n        normalizedGearSelectors = cloneProjectGearSelectors(gearSelectorsSource);\n      } else if (typeof gearSelectorsSource === \"string\") {\n        const parsedSelectors = tryParseJSONLike(gearSelectorsSource);\n        if (parsedSelectors.success && isPlainObject(parsedSelectors.parsed)) {\n          normalizedGearSelectors = cloneProjectGearSelectors(parsedSelectors.parsed);\n        }\n      }\n      const powerSelectionSource = isMapLike(data.powerSelection)\n        ? convertMapLikeToObject(data.powerSelection)\n        : data.powerSelection;\n      let normalizedPowerSelection = normalizeProjectPowerSelection(powerSelectionSource);\n      if (!normalizedPowerSelection && isPlainObject(powerSelectionSource)) {\n        normalizedPowerSelection = normalizeProjectPowerSelection(powerSelectionSource);\n      }\n\n      if (typeof normalizedGearList === \"string\") {\n        const parsedGear = tryParseJSONLike(normalizedGearList);\n        if (parsedGear.success) {\n          const nested = normalizeProject(parsedGear.parsed);\n          if (nested) {\n            normalizedGearList = nested.gearList;\n            if (!normalizedProjectInfo && nested.projectInfo) {\n              normalizedProjectInfo = nested.projectInfo;\n            }\n            if (\n              (!normalizedAutoGearRules || !normalizedAutoGearRules.length)\n              && Array.isArray(nested.autoGearRules)\n              && nested.autoGearRules.length\n            ) {\n              normalizedAutoGearRules = nested.autoGearRules;\n            }\n            if (!normalizedGearSelectors && isPlainObject(nested.gearSelectors)) {\n              normalizedGearSelectors = cloneProjectGearSelectors(nested.gearSelectors);\n            }\n            if (!normalizedPowerSelection && isPlainObject(nested.powerSelection)) {\n              normalizedPowerSelection = normalizeProjectPowerSelection(nested.powerSelection);\n            }\n          } else if (\n            typeof parsedGear.parsed === \"string\"\n            || (isPlainObject(parsedGear.parsed)\n              && Object.values(parsedGear.parsed).every((value) => typeof value === \"string\"))\n          ) {\n            normalizedGearList = parsedGear.parsed;\n          }\n        }\n      }\n\n      if (\n        normalizedGearList\n        && typeof normalizedGearList === \"object\"\n        && !isPlainObject(normalizedGearList)\n      ) {\n        normalizedGearList = \"\";\n      }\n\n      if (normalizedProjectInfo) {\n        normalizeImportedProjectFilters(normalizedProjectInfo);\n      }\n      if (normalizedProjectInfo) {\n        normalizedProjectInfo = sanitizeImportedProjectInfo(normalizedProjectInfo) || null;\n      }\n      if (normalizedProjectInfo) {\n        normalizeImportedProjectFilters(normalizedProjectInfo);\n      }\n\n      const normalized = {\n        gearList: Array.isArray(normalizedGearList) || isPlainObject(normalizedGearList)\n          ? cloneProjectData(normalizedGearList)\n          : normalizedGearList,\n        projectInfo: normalizedProjectInfo ? cloneProjectInfo(normalizedProjectInfo) : null,\n      };\n      const diagramSource = isMapLike(data.diagramPositions)\n        ? convertMapLikeToObject(data.diagramPositions)\n        : data.diagramPositions;\n      let normalizedDiagramPositions = normalizeDiagramPositions(diagramSource);\n      if (\n        Object.keys(normalizedDiagramPositions).length === 0\n        && isPlainObject(projectContainer)\n      ) {\n        const nestedDiagramSource = isMapLike(projectContainer.diagramPositions)\n          ? convertMapLikeToObject(projectContainer.diagramPositions)\n          : projectContainer.diagramPositions;\n        normalizedDiagramPositions = normalizeDiagramPositions(nestedDiagramSource);\n      }\n      if (Object.keys(normalizedDiagramPositions).length) {\n        normalized.diagramPositions = cloneDiagramPositionsForStorage(normalizedDiagramPositions);\n      }\n      const htmlSources = [];\n      if (typeof data.projectHtml === 'string') {\n        htmlSources.push(data.projectHtml);\n      }\n      if (typeof data.gearHtml === 'string') {\n        htmlSources.push(data.gearHtml);\n      }\n      if (isPlainObject(projectContainer)) {\n        if (typeof projectContainer.projectHtml === 'string') {\n          htmlSources.push(projectContainer.projectHtml);\n        }\n        if (typeof projectContainer.gearHtml === 'string') {\n          htmlSources.push(projectContainer.gearHtml);\n        }\n      }\n      if (isPlainObject(gearListSource) && typeof gearListSource.gearHtml === 'string') {\n        htmlSources.push(gearListSource.gearHtml);\n      }\n      if (isPlainObject(normalizedGearList)) {\n        if (typeof normalizedGearList.projectHtml === 'string') {\n          htmlSources.push(normalizedGearList.projectHtml);\n        }\n        if (typeof normalizedGearList.gearHtml === 'string') {\n          htmlSources.push(normalizedGearList.gearHtml);\n        }\n      } else if (typeof normalizedGearList === 'string') {\n        htmlSources.push(normalizedGearList);\n      }\n      if (!normalizedGearSelectors && isPlainObject(projectContainer)) {\n        const nestedSelectorsSource = isMapLike(projectContainer.gearSelectors)\n          ? convertMapLikeToObject(projectContainer.gearSelectors)\n          : projectContainer.gearSelectors;\n        if (isPlainObject(nestedSelectorsSource)) {\n          normalizedGearSelectors = cloneProjectGearSelectors(nestedSelectorsSource);\n        }\n      }\n      if (!normalizedGearSelectors && isPlainObject(normalizedGearList) && isPlainObject(normalizedGearList.gearSelectors)) {\n        normalizedGearSelectors = cloneProjectGearSelectors(normalizedGearList.gearSelectors);\n      }\n      if (!normalizedPowerSelection && isPlainObject(projectContainer)) {\n        const nestedPowerSelection = isMapLike(projectContainer.powerSelection)\n          ? convertMapLikeToObject(projectContainer.powerSelection)\n          : projectContainer.powerSelection;\n        if (isPlainObject(nestedPowerSelection)) {\n          normalizedPowerSelection = normalizeProjectPowerSelection(nestedPowerSelection);\n        }\n      }\n      if (!normalizedProjectInfo) {\n        for (let i = 0; i < htmlSources.length; i += 1) {\n          const recovered = extractProjectInfoFromHtml(htmlSources[i]);\n          if (recovered) {\n            normalized.projectInfo = cloneProjectInfo(recovered);\n            break;\n          }\n        }\n      } else if (htmlSources.length) {\n        for (let i = 0; i < htmlSources.length; i += 1) {\n          const recovered = extractProjectInfoFromHtml(htmlSources[i]);\n          if (recovered) {\n            const recoveredClone = cloneProjectInfo(recovered) || {};\n            const normalizedClone = cloneProjectInfo(normalizedProjectInfo) || {};\n            normalized.projectInfo = { ...recoveredClone, ...normalizedClone };\n            break;\n          }\n        }\n      }\n      const fallbackLensNames = [];\n      const fallbackLensNameSet = new Set();\n      const addFallbackLensName = (name) => {\n        if (typeof name !== 'string') {\n          return;\n        }\n        const trimmed = name.trim();\n        if (!trimmed || fallbackLensNameSet.has(trimmed)) {\n          return;\n        }\n        fallbackLensNameSet.add(trimmed);\n        fallbackLensNames.push(trimmed);\n      };\n      const registerFallbackLensNames = (source, options = {}) => {\n        if (source === null || source === undefined) {\n          return;\n        }\n        if (options.fromSelections) {\n          const entries = Array.isArray(source) ? source : [source];\n          entries.forEach((entry) => {\n            if (isMapLike(entry)) {\n              const converted = convertMapLikeToObject(entry);\n              if (converted) {\n                registerFallbackLensNames(converted, { fromSelections: true });\n                return;\n              }\n            }\n            if (isPlainObject(entry)) {\n              const mapped = deriveLensSelectionsFromNameMap(entry);\n              if (mapped.length) {\n                mapped.forEach((selection) => {\n                  if (selection && typeof selection.name === 'string') {\n                    addFallbackLensName(selection.name);\n                  }\n                });\n                return;\n              }\n            }\n            const candidate = normalizeProjectLensNameCandidate(entry);\n            if (candidate) {\n              addFallbackLensName(candidate);\n            }\n          });\n          return;\n        }\n        const names = extractLensNamesFromSource(source);\n        if (!names.length) {\n          return;\n        }\n        names.forEach((name) => {\n          addFallbackLensName(name);\n        });\n      };\n\n      if (\n        normalized.projectInfo\n        && Object.prototype.hasOwnProperty.call(normalized.projectInfo, 'lenses')\n      ) {\n        const { names } = normalizeProjectLensNamesField(normalized.projectInfo.lenses);\n        normalized.projectInfo = normalized.projectInfo && typeof normalized.projectInfo === 'object'\n          ? normalized.projectInfo\n          : {};\n        normalized.projectInfo.lenses = names.slice();\n        registerFallbackLensNames(names);\n      }\n\n      registerFallbackLensNames(data.lenses);\n      if (isPlainObject(projectContainer)) {\n        registerFallbackLensNames(projectContainer.lenses);\n      }\n      registerFallbackLensNames(gearListSource && gearListSource.lenses);\n      if (isPlainObject(normalizedGearList)) {\n        registerFallbackLensNames(normalizedGearList.lenses);\n      }\n\n      if (\n        (!normalized.projectInfo\n          || !Array.isArray(normalized.projectInfo.lenses)\n          || !normalized.projectInfo.lenses.length)\n        && fallbackLensNames.length\n      ) {\n        normalized.projectInfo = normalized.projectInfo && typeof normalized.projectInfo === 'object'\n          ? normalized.projectInfo\n          : {};\n        normalized.projectInfo.lenses = fallbackLensNames.slice();\n      }\n\n      const lensSelectionSources = [];\n      if (\n        normalized.projectInfo\n        && Object.prototype.hasOwnProperty.call(normalized.projectInfo, 'lensSelections')\n      ) {\n        registerFallbackLensNames(normalized.projectInfo.lensSelections, { fromSelections: true });\n        lensSelectionSources.push(normalized.projectInfo.lensSelections);\n      }\n      if (Object.prototype.hasOwnProperty.call(data, 'lensSelections')) {\n        registerFallbackLensNames(data.lensSelections, { fromSelections: true });\n        lensSelectionSources.push(data.lensSelections);\n      }\n      if (\n        isPlainObject(projectContainer)\n        && Object.prototype.hasOwnProperty.call(projectContainer, 'lensSelections')\n      ) {\n        registerFallbackLensNames(projectContainer.lensSelections, { fromSelections: true });\n        lensSelectionSources.push(projectContainer.lensSelections);\n      }\n      if (\n        isPlainObject(gearListSource)\n        && Object.prototype.hasOwnProperty.call(gearListSource, 'lensSelections')\n      ) {\n        registerFallbackLensNames(gearListSource.lensSelections, { fromSelections: true });\n        lensSelectionSources.push(gearListSource.lensSelections);\n      }\n      if (\n        isPlainObject(normalizedGearList)\n        && Object.prototype.hasOwnProperty.call(normalizedGearList, 'lensSelections')\n      ) {\n        registerFallbackLensNames(normalizedGearList.lensSelections, { fromSelections: true });\n        lensSelectionSources.push(normalizedGearList.lensSelections);\n      }\n\n      const lensSelectionResult = normalizeProjectLensSelectionsFromSources(\n        lensSelectionSources,\n        fallbackLensNames,\n      );\n\n      if (\n        lensSelectionResult\n        && lensSelectionResult.selections\n        && lensSelectionResult.selections.length\n      ) {\n        normalized.projectInfo = normalized.projectInfo && typeof normalized.projectInfo === 'object'\n          ? normalized.projectInfo\n          : {};\n        normalized.projectInfo.lensSelections = lensSelectionResult.selections;\n        if (\n          !Array.isArray(normalized.projectInfo.lenses)\n          || !normalized.projectInfo.lenses.length\n        ) {\n          normalized.projectInfo.lenses = lensSelectionResult.selections\n            .map((entry) => (typeof entry.name === 'string' ? entry.name : ''))\n            .filter((name) => name);\n        }\n      } else if (\n        lensSelectionResult\n        && lensSelectionResult.changed\n        && normalized.projectInfo\n        && Object.prototype.hasOwnProperty.call(normalized.projectInfo, 'lensSelections')\n      ) {\n        delete normalized.projectInfo.lensSelections;\n      }\n      const derivedGenerationFlag = typeof data.gearListAndProjectRequirementsGenerated === 'boolean'\n        ? data.gearListAndProjectRequirementsGenerated\n        : htmlSources.some((value) => typeof value === 'string' && value.trim());\n      normalized.gearListAndProjectRequirementsGenerated = derivedGenerationFlag;\n      if (normalizedAutoGearRules && normalizedAutoGearRules.length) {\n        normalized.autoGearRules = cloneAutoGearRules(normalizedAutoGearRules);\n      }\n      if (normalizedGearSelectors && Object.keys(normalizedGearSelectors).length) {\n        normalized.gearSelectors = normalizedGearSelectors;\n      }\n      if (normalizedPowerSelection) {\n        normalized.powerSelection = cloneProjectPowerSelection(normalizedPowerSelection);\n      }\n      copyAutoBackupMetadata(data, normalized);\n      if (normalized.projectInfo) {\n        normalizeImportedProjectFilters(normalized.projectInfo);\n      }\n      if (normalized.projectInfo) {\n        const normalizedInfo = normalizeLegacyLongGopStructure(normalized.projectInfo);\n        if (normalizedInfo !== normalized.projectInfo) {\n          normalized.projectInfo = normalizedInfo;\n        }\n      }\n      if (normalized.autoGearRules) {\n        const normalizedRules = normalizeLegacyLongGopStructure(normalized.autoGearRules);\n        if (normalizedRules !== normalized.autoGearRules) {\n          normalized.autoGearRules = normalizedRules;\n        }\n      }\n      if (normalized.gearSelectors) {\n        const normalizedSelectors = normalizeLegacyLongGopStructure(normalized.gearSelectors);\n        if (normalizedSelectors !== normalized.gearSelectors) {\n          normalized.gearSelectors = normalizedSelectors;\n        }\n      }\n      if (normalized.diagramPositions) {\n        const normalizedDiagram = normalizeLegacyLongGopStructure(normalized.diagramPositions);\n        if (normalizedDiagram !== normalized.diagramPositions) {\n          normalized.diagramPositions = normalizedDiagram;\n        }\n      }\n      if (normalized.powerSelection) {\n        const normalizedPower = normalizeLegacyLongGopStructure(normalized.powerSelection);\n        if (normalizedPower !== normalized.powerSelection) {\n          normalized.powerSelection = normalizedPower;\n        }\n      }\n      return normalized;\n    }\n    // Legacy format { projectHtml, gearHtml }\n    if (Object.prototype.hasOwnProperty.call(data, \"projectHtml\") || Object.prototype.hasOwnProperty.call(data, \"gearHtml\")) {\n      return {\n        gearList: { projectHtml: data.projectHtml || \"\", gearHtml: data.gearHtml || \"\" },\n        projectInfo: null,\n      };\n    }\n\n    if (isPlainObject(data.project)) {\n      const nested = normalizeProject(data.project);\n      if (nested) {\n        return nested;\n      }\n    } else if (typeof data.project === \"string\") {\n      const parsedProject = tryParseJSONLike(data.project);\n      if (parsedProject.success) {\n        const nested = normalizeProject(parsedProject.parsed);\n        if (nested) {\n          return nested;\n        }\n      }\n    }\n  }\n  return null;\n}\n\nvar LEGACY_PROJECT_ROOT_KEYS = new Set([\n  \"gearList\",\n  \"projectInfo\",\n  \"projectHtml\",\n  \"gearHtml\",\n  \"autoGearRules\",\n  \"powerSelection\",\n  \"gearListAndProjectRequirementsGenerated\",\n]);\n\nvar NORMALIZED_PROJECT_KEYS = new Set([\n  \"gearList\",\n  \"projectInfo\",\n  \"autoGearRules\",\n  \"diagramPositions\",\n  \"gearSelectors\",\n  \"powerSelection\",\n  \"gearListAndProjectRequirementsGenerated\",\n]);\n\nfunction isNormalizedProjectEntry(entry) {\n  if (!isPlainObject(entry)) {\n    return false;\n  }\n  const keys = Object.keys(entry);\n  if (!keys.every((key) => NORMALIZED_PROJECT_KEYS.has(key))) {\n    return false;\n  }\n  const { gearList, projectInfo } = entry;\n  if (\n    typeof gearList !== \"string\" &&\n    !(isPlainObject(gearList) &&\n      Object.keys(gearList).every((key) => typeof gearList[key] === \"string\"))\n  ) {\n    return false;\n  }\n  if (projectInfo !== null && !isPlainObject(projectInfo)) {\n    return false;\n  }\n  if (Object.prototype.hasOwnProperty.call(entry, \"autoGearRules\")) {\n    if (!Array.isArray(entry.autoGearRules) || !entry.autoGearRules.length) {\n      return false;\n    }\n  }\n  if (\n    Object.prototype.hasOwnProperty.call(entry, \"diagramPositions\")\n    && !isPlainObject(entry.diagramPositions)\n  ) {\n    return false;\n  }\n  if (\n    Object.prototype.hasOwnProperty.call(entry, \"gearSelectors\")\n    && !isPlainObject(entry.gearSelectors)\n  ) {\n    return false;\n  }\n  if (\n    Object.prototype.hasOwnProperty.call(entry, \"powerSelection\")\n  ) {\n    const powerSelection = entry.powerSelection;\n    if (!isPlainObject(powerSelection)) {\n      return false;\n    }\n  }\n  if (\n    Object.prototype.hasOwnProperty.call(entry, \"gearListAndProjectRequirementsGenerated\")\n    && typeof entry.gearListAndProjectRequirementsGenerated !== \"boolean\"\n  ) {\n    return false;\n  }\n  return true;\n}\n\nfunction normalizeProjectStorageKey(name) {\n  if (typeof name !== \"string\") {\n    return \"\";\n  }\n  return name.trim();\n}\n\nfunction setActiveProjectCompressionHold(name) {\n  if (name === null || name === undefined) {\n    ACTIVE_PROJECT_COMPRESSION_HOLD_KEY = '';\n    ACTIVE_PROJECT_COMPRESSION_HOLD_ENABLED = false;\n    return '';\n  }\n\n  const normalized = normalizeProjectStorageKey(name);\n  if (isForcedProjectCompressionLocked(normalized)) {\n    ACTIVE_PROJECT_COMPRESSION_HOLD_KEY = '';\n    ACTIVE_PROJECT_COMPRESSION_HOLD_ENABLED = false;\n    return normalized;\n  }\n  ACTIVE_PROJECT_COMPRESSION_HOLD_KEY = normalized;\n  ACTIVE_PROJECT_COMPRESSION_HOLD_ENABLED = true;\n  return normalized;\n}\n\nfunction clearActiveProjectCompressionHold(name) {\n  if (!ACTIVE_PROJECT_COMPRESSION_HOLD_ENABLED) {\n    return false;\n  }\n\n  if (name !== undefined) {\n    const normalized = normalizeProjectStorageKey(name);\n    if (normalized !== ACTIVE_PROJECT_COMPRESSION_HOLD_KEY) {\n      return false;\n    }\n  }\n\n  ACTIVE_PROJECT_COMPRESSION_HOLD_KEY = '';\n  ACTIVE_PROJECT_COMPRESSION_HOLD_ENABLED = false;\n  return true;\n}\n\n\n\nfunction resolveProjectKey(projects, lookup, name, options = {}) {\n  if (!projects || typeof projects !== \"object\") {\n    return null;\n  }\n\n  const rawName = typeof name === \"string\" ? name : \"\";\n  if (Object.prototype.hasOwnProperty.call(projects, rawName)) {\n    return rawName;\n  }\n\n  const normalizedName = normalizeProjectStorageKey(rawName);\n  if (\n    normalizedName\n    && normalizedName !== rawName\n    && Object.prototype.hasOwnProperty.call(projects, normalizedName)\n  ) {\n    return normalizedName;\n  }\n\n  if (!lookup || typeof lookup !== \"object\") {\n    return null;\n  }\n\n  const { raw: rawMap, normalized: normalizedMap } = lookup;\n\n  if (rawMap && typeof rawMap.get === \"function\" && rawMap.has(rawName)) {\n    const candidate = rawMap.get(rawName);\n    if (Object.prototype.hasOwnProperty.call(projects, candidate)) {\n      return candidate;\n    }\n  }\n\n  if (\n    normalizedMap\n    && typeof normalizedMap.get === \"function\"\n    && normalizedMap.has(normalizedName)\n  ) {\n    const candidates = normalizedMap.get(normalizedName);\n    if (Array.isArray(candidates)) {\n      if (options && options.preferExact && rawName) {\n        const exact = candidates.find(\n          (candidate) => candidate === rawName && Object.prototype.hasOwnProperty.call(projects, candidate),\n        );\n        if (exact) {\n          return exact;\n        }\n      }\n      const firstExisting = candidates.find((candidate) =>\n        Object.prototype.hasOwnProperty.call(projects, candidate)\n      );\n      if (firstExisting) {\n        return firstExisting;\n      }\n    } else if (\n      typeof candidates === \"string\"\n      && Object.prototype.hasOwnProperty.call(projects, candidates)\n    ) {\n      return candidates;\n    }\n  }\n\n  return null;\n}\n\nfunction buildProjectLookupFromProjects(projects = {}) {\n  const rawKeyLookup = new Map();\n  const normalizedKeyLookup = new Map();\n  const entries = projects && typeof projects === 'object' ? Object.keys(projects) : [];\n\n  entries.forEach((key) => {\n    if (typeof key !== 'string') {\n      return;\n    }\n    rawKeyLookup.set(key, key);\n    const normalized = normalizeProjectStorageKey(key);\n    if (!normalizedKeyLookup.has(normalized)) {\n      normalizedKeyLookup.set(normalized, []);\n    }\n    normalizedKeyLookup.get(normalized).push(key);\n  });\n\n  return { raw: rawKeyLookup, normalized: normalizedKeyLookup };\n}\n\nfunction readAllProjectsFromStorage(options = {}) {\n  const {\n    forceRefresh = false,\n    forMutation = false,\n    skipMigrations = false,\n    skipAutoBackupExpansion = false,\n  } = options || {};\n\n  if (!skipMigrations) {\n    applyLegacyStorageMigrations();\n  }\n\n  // [Refactor] Hybrid Approach: Use Memory Cache if Hydrated (IndexedDB active)\n  if (isProjectCacheHydrated && !forceRefresh) {\n    const projectsSnapshot = { ...projectMemoryCache };\n    const lookupSnapshot = buildProjectLookupFromProjects(projectsSnapshot);\n    return {\n      projects: projectsSnapshot,\n      changed: false,\n      originalValue: { ...projectMemoryCache },\n      lookup: cloneProjectLookupSnapshotForReturn(lookupSnapshot),\n    };\n  }\n\n  // Fallback to Legacy LocalStorage Logic\n  const safeStorage = getSafeLocalStorage();\n  let storageRaw = null;\n  if (safeStorage && typeof safeStorage.getItem === 'function') {\n    try {\n      storageRaw = safeStorage.getItem(PROJECT_STORAGE_KEY);\n    } catch (storageReadError) {\n      storageRaw = null;\n      void storageReadError;\n    }\n  }\n\n  const parsed = loadJSONFromStorage(\n    safeStorage,\n    PROJECT_STORAGE_KEY,\n    \"Error loading project from localStorage:\",\n    null,\n    {\n      validate: (value) =>\n        value === null\n        || typeof value === \"string\"\n        || Array.isArray(value)\n        || isPlainObject(value),\n    },\n  );\n  const originalValue = parsed;\n  let combinedRawEntries = null;\n\n  if (isPlainObject(parsed)) {\n    combinedRawEntries = { ...parsed };\n  } else {\n    combinedRawEntries = {};\n  }\n\n  if (safeStorage && typeof safeStorage.length === 'number') {\n    const count = safeStorage.length;\n    for (let i = 0; i < count; i++) {\n      const key = safeStorage.key(i);\n      if (!key || !key.startsWith(PROJECT_SHARD_PREFIX)) {\n        continue;\n      }\n      const rawName = key.substring(PROJECT_SHARD_PREFIX.length);\n      if (rawName === null || rawName === undefined) {\n        continue;\n      }\n      try {\n        const rawVal = safeStorage.getItem(key);\n        const parsedVal = JSON.parse(decodeStoredValue(rawVal));\n        // Store raw value to allow expansion of backups later\n        if (combinedRawEntries === null) {\n          combinedRawEntries = {};\n        }\n        combinedRawEntries[rawName] = parsedVal;\n      } catch (e) {\n        void e;\n      }\n    }\n  }\n\n  let inputForExpansion = parsed;\n  // preferring combined object if we have shards or if existing was object\n  if (combinedRawEntries !== null && Object.keys(combinedRawEntries).length > 0) {\n    inputForExpansion = combinedRawEntries;\n  } else if (isPlainObject(parsed)) {\n    inputForExpansion = combinedRawEntries;\n  }\n\n  const expandOptions = {\n    isAutoBackupKey: isAutoBackupStorageKey,\n  };\n  if (skipAutoBackupExpansion) {\n    expandOptions.filter = (name) => !isAutoBackupStorageKey(name);\n  }\n  const expandedParsed = expandAutoBackupEntries(inputForExpansion, expandOptions);\n  const projects = {};\n  let changed = false;\n  const usedProjectNames = new Set();\n  const normalizedProjectNames = new Set();\n  const markProjectNameUsed = (name) => {\n    if (typeof name !== \"string\") {\n      return;\n    }\n    usedProjectNames.add(name);\n    const trimmed = name.trim();\n    if (trimmed) {\n      normalizedProjectNames.add(trimmed.toLowerCase());\n    }\n  };\n\n  const rawKeyLookup = new Map();\n  const normalizedKeyLookup = new Map();\n  const registerLookupKey = (rawKey, storedKey) => {\n    if (typeof rawKey !== \"string\") {\n      return;\n    }\n    const effectiveKey = typeof storedKey === \"string\" ? storedKey : rawKey;\n    rawKeyLookup.set(rawKey, effectiveKey);\n    const normalized = normalizeProjectStorageKey(rawKey);\n    if (!normalizedKeyLookup.has(normalized)) {\n      normalizedKeyLookup.set(normalized, []);\n    }\n    normalizedKeyLookup.get(normalized).push(effectiveKey);\n  };\n\n  const createLookupSnapshot = () => ({\n    raw: cloneLookupMap(rawKeyLookup),\n    normalized: cloneLookupMap(normalizedKeyLookup),\n  });\n\n  const finalize = () => {\n\n    const snapshot = {\n      projects,\n      changed,\n      originalValue,\n      lookup: createLookupSnapshot(),\n      rawValue: storageRaw,\n    };\n\n    if (changed) {\n      setProjectReadCacheSnapshot(null);\n      if (forMutation) {\n        return {\n          projects: STORAGE_DEEP_CLONE(snapshot.projects),\n          changed: snapshot.changed,\n          originalValue: snapshot.originalValue,\n          lookup: cloneProjectLookupSnapshotForReturn(snapshot.lookup),\n        };\n      }\n      return snapshot;\n    }\n\n    const shouldUseCache = !forceRefresh;\n    if (!shouldUseCache) {\n      return snapshot;\n    }\n\n    setProjectReadCacheSnapshot(snapshot);\n    const cached = getProjectReadCacheClone({ forMutation });\n    return cached || snapshot;\n  };\n\n  if (expandedParsed === null || expandedParsed === undefined) {\n    return finalize();\n  }\n\n  if (typeof expandedParsed === \"string\") {\n    const normalized = normalizeProject(expandedParsed);\n    if (normalized) {\n      const suggestedName =\n        (normalized && normalized.projectInfo && typeof normalized.projectInfo.projectName === 'string')\n          ? normalized.projectInfo.projectName\n          : \"\";\n      const updatedName = generateUpdatedProjectName(suggestedName, usedProjectNames, normalizedProjectNames);\n      projects[updatedName] = normalized;\n      registerLookupKey(\"\", updatedName);\n      markProjectNameUsed(updatedName);\n    }\n    changed = true;\n    return finalize();\n  }\n\n  if (Array.isArray(expandedParsed)) {\n    const usedNames = usedProjectNames;\n    const normalizedNames = normalizedProjectNames;\n    expandedParsed.forEach((item, index) => {\n      const normalized = normalizeProject(item);\n      if (!normalized) {\n        changed = true;\n        return;\n      }\n      const baseName =\n        isPlainObject(item) && typeof item.name === \"string\"\n          ? item.name.trim()\n          : `Project ${index + 1}`;\n      const candidate = baseName || `Project ${index + 1}`;\n      const unique = generateUpdatedProjectName(candidate, usedNames, normalizedNames);\n      projects[unique] = normalized;\n      registerLookupKey(candidate, unique);\n      markProjectNameUsed(unique);\n    });\n    changed = true;\n    return finalize();\n  }\n\n  if (!isPlainObject(expandedParsed)) {\n    changed = true;\n    return finalize();\n  }\n\n  const keys = Object.keys(expandedParsed);\n  const maybeLegacy =\n    keys.length > 0 && keys.every((key) => LEGACY_PROJECT_ROOT_KEYS.has(key));\n\n  if (maybeLegacy) {\n    const normalized = normalizeProject(expandedParsed);\n    if (normalized) {\n      const updatedName = generateUpdatedProjectName(\"\", usedProjectNames, normalizedProjectNames);\n      projects[updatedName] = normalized;\n      registerLookupKey(\"\", updatedName);\n      markProjectNameUsed(updatedName);\n    }\n    changed = true;\n    return finalize();\n  }\n\n  keys.forEach((key) => {\n    if (isNormalizedProjectEntry(expandedParsed[key])) {\n      const trimmedKey = typeof key === \"string\" ? key.trim() : \"\";\n      if (trimmedKey) {\n        normalizedProjectNames.add(trimmedKey.toLowerCase());\n      }\n    }\n  });\n\n  keys.forEach((key) => {\n    const normalized = normalizeProject(expandedParsed[key]);\n    if (normalized) {\n      const originalEntry = expandedParsed[key];\n      const isNormalized = isNormalizedProjectEntry(originalEntry);\n      // console.log('DEBUG: readAllProjectsFromStorage key:', key, 'isNormalized:', isNormalized);\n      const needsUpgrade = !isNormalized;\n      let requiresContentUpdate = false;\n      if (!needsUpgrade) {\n        try {\n          const normalizedSignature = createStableValueSignature(normalized);\n          const originalSignature = createStableValueSignature(originalEntry);\n          if (normalizedSignature !== originalSignature) {\n            requiresContentUpdate = true;\n          }\n        } catch (signatureError) {\n          requiresContentUpdate = true;\n          console.warn(\n            'Unable to compare stored project entry during legacy long-GOP normalization check',\n            signatureError,\n          );\n        }\n      }\n      let finalKey = key;\n      if (needsUpgrade) {\n        const innerName = (normalized && normalized.projectInfo && typeof normalized.projectInfo.projectName === 'string' && normalized.projectInfo.projectName)\n          ? normalized.projectInfo.projectName\n          : key;\n        finalKey = generateUpdatedProjectName(innerName, usedProjectNames, normalizedProjectNames);\n        changed = true;\n      }\n      if (\n        finalKey !== key\n        && Object.prototype.hasOwnProperty.call(projects, finalKey)\n      ) {\n        const adjusted = generateUpdatedProjectName(finalKey, usedProjectNames, normalizedProjectNames);\n        finalKey = adjusted;\n      }\n      projects[finalKey] = normalized;\n      registerLookupKey(key, finalKey);\n      markProjectNameUsed(finalKey);\n      if (!needsUpgrade && requiresContentUpdate) {\n        changed = true;\n      }\n    } else {\n      changed = true;\n    }\n  });\n\n  return finalize();\n}\n\nfunction pruneOrphanProjectShards(storage, projects) {\n  if (!storage || typeof storage.length !== 'number' || !isPlainObject(projects)) {\n    return;\n  }\n  const projectKeys = new Set(\n    Object.keys(projects).map((name) => normalizeProjectStorageKey(name)),\n  );\n  const keysToDelete = [];\n  for (let i = 0; i < storage.length; i += 1) {\n    const key = storage.key(i);\n    if (key && key.startsWith(PROJECT_SHARD_PREFIX)) {\n      const rawName = key.substring(PROJECT_SHARD_PREFIX.length);\n      if (!projectKeys.has(rawName)) {\n        keysToDelete.push(key);\n      }\n    }\n  }\n  keysToDelete.forEach((key) =>\n    deleteFromStorage(storage, key, 'Pruning orphan project shard:'),\n  );\n}\n\nfunction cleanupMonolithicProjectStorage(storage) {\n  if (!storage) return;\n\n  // Skip if we've already handled the monolith this session\n  if (GLOBAL_SCOPE && GLOBAL_SCOPE.__cineMonolithicProjectCleanupDone) {\n    return;\n  }\n\n  const raw = storage.getItem(PROJECT_STORAGE_KEY);\n  // If it's already empty, mark as done and return.\n  if (!raw) {\n    if (GLOBAL_SCOPE) {\n      GLOBAL_SCOPE.__cineMonolithicProjectCleanupDone = true;\n    }\n    return;\n  }\n\n  // Ensure we have a migration backup before we delete the monolith\n  try {\n    const parsed = JSON.parse(decodeStoredValue(raw));\n    if (parsed) {\n      createStorageMigrationBackup(storage, PROJECT_STORAGE_KEY, parsed);\n    }\n  } catch (e) {\n    // If parsing fails, we skip migration backup but proceed with cleanup to prevent infinite loops\n    // if the data is corrupted and causing other issues.\n    void e;\n  }\n\n  deleteFromStorage(\n    storage,\n    PROJECT_STORAGE_KEY,\n    \"Error clearing project monolithic storage after sharding:\",\n    {\n      disableBackup: false,\n      disableMigrationCleanup: true\n    }\n  );\n\n  // Mark as done so we don't repeat this process\n  if (GLOBAL_SCOPE) {\n    GLOBAL_SCOPE.__cineMonolithicProjectCleanupDone = true;\n  }\n}\n\nfunction persistProjectShard(name, project, options = {}) {\n  if (name === null || name === undefined || project === undefined || project === null) {\n    return false;\n  }\n  const safeStorage = getSafeLocalStorage();\n  if (!safeStorage) {\n    return false;\n  }\n\n  const { skipCompression = false } = options || {};\n  const shardKey = PROJECT_SHARD_PREFIX + normalizeProjectStorageKey(name);\n\n  // Prepare a temporary object to use existing serialization logic\n  const entries = {};\n  entries[name] = project;\n\n  const serialized = serializeAutoBackupEntries(entries, {\n    isAutoBackupKey: isAutoBackupStorageKey,\n  });\n  const projectData = serialized[name];\n\n  const result = saveJSONToStorage(\n    safeStorage,\n    shardKey,\n    projectData,\n    `Error saving project shard \"${name}\":`,\n    {\n      disableCompression: skipCompression,\n      forceCompressionOnQuota: true,\n      disableBackup: true,\n      onQuotaExceeded: () => {\n        // Cross-shard quota recovery: try to prune the oldest auto-backup shard.\n        // Note: we don't want forMutation: true here because we are in the middle of a save.\n        const { projects } = readAllProjectsFromStorage({ forMutation: false, skipMigrations: true });\n        let removedKey = removeOldestAutoBackupEntry(projects);\n\n        if (!removedKey) {\n          removedKey = removeOldestAutoBackupEntry(projects, { force: true });\n        }\n\n        if (removedKey) {\n          const victimKey = PROJECT_SHARD_PREFIX + normalizeProjectStorageKey(removedKey);\n          deleteFromStorage(safeStorage, victimKey, `Pruning shard \"${removedKey}\" to recover space:`);\n          return true;\n        }\n        return false;\n      },\n    }\n  );\n\n  return result === 'success';\n}\n\nfunction persistAllProjects(projects, options = {}) {\n  const { skipCompression = false } = options || {};\n  const safeStorage = getSafeLocalStorage();\n\n  if (!projects || typeof projects !== 'object') return;\n\n  // Prune within the projects object first (handling auto-backup counts)\n  enforceAutoBackupLimits(projects);\n\n  // CRITICAL: Clean up orphan shards BEFORE persisting new ones.\n  // This frees storage space first, preventing quota exceeded errors\n  // when old auto-backup shards persist from previous sessions.\n  pruneOrphanProjectShards(safeStorage, projects);\n\n  // Persist each project as its own shard.\n  Object.keys(projects).forEach((name) => {\n    persistProjectShard(name, projects[name], { skipCompression });\n  });\n\n  // Monolithic key cleanup (migration from old format)\n  cleanupMonolithicProjectStorage(safeStorage);\n\n  bumpProjectStorageRevision(safeStorage);\n\n  // [Performance] Update the Project Index\n  try {\n    updateProjectIndex(projects, safeStorage);\n  } catch (indexError) {\n    console.warn('Failed to update project index', indexError);\n  }\n\n  invalidateProjectReadCache();\n  if (lifecycleChannel) {\n    try {\n      lifecycleChannel.postMessage('project-shards-changed');\n    } catch (e) {\n      void e;\n    }\n  }\n}\n\n/**\n * Reads, validates, and returns the project index from storage.\n * Returns null if missing or invalid.\n */\n// [Agent Refactor] Memory Cache for Project Index (Synchronous Read Support)\nlet projectIndexCache = null;\n\nfunction normalizeProjectIndexForCache(index) {\n  if (!index || typeof index !== 'object') {\n    return null;\n  }\n\n  const normalized = {};\n  const keys = Object.keys(index);\n  keys.forEach((key) => {\n    if (typeof key !== 'string') {\n      return;\n    }\n    const rawKey =\n      storageRepo && typeof storageRepo.getProjectKeyFromStorageKey === 'function'\n        ? storageRepo.getProjectKeyFromStorageKey(key)\n        : key;\n    if (rawKey === null || rawKey === undefined) {\n      return;\n    }\n    const entry = index[key];\n\n    if (!Object.prototype.hasOwnProperty.call(normalized, rawKey)) {\n      normalized[rawKey] = entry;\n      return;\n    }\n\n    const existing = normalized[rawKey];\n    const entryModified =\n      entry && typeof entry === 'object' && typeof entry.lastModified === 'number'\n        ? entry.lastModified\n        : null;\n    const existingModified =\n      existing && typeof existing === 'object' && typeof existing.lastModified === 'number'\n        ? existing.lastModified\n        : null;\n\n    if (\n      typeof entryModified === 'number'\n      && typeof existingModified === 'number'\n      && entryModified > existingModified\n    ) {\n      normalized[rawKey] = entry;\n    }\n  });\n\n  return Object.keys(normalized).length ? normalized : null;\n}\n\nfunction buildProjectIndexForRepo(index) {\n  if (!index || typeof index !== 'object') {\n    return null;\n  }\n  if (!storageRepo || typeof storageRepo.getProjectStorageKey !== 'function') {\n    return index;\n  }\n\n  const prefixed = {};\n  Object.keys(index).forEach((key) => {\n    if (typeof key !== 'string') {\n      return;\n    }\n    const storageKey = storageRepo.getProjectStorageKey(key);\n    prefixed[storageKey] = index[key];\n  });\n  return prefixed;\n}\n\nasync function migrateProjectKeyPrefixOnStartup() {\n  if (!storageRepo || typeof storageRepo.migrateUnprefixedProjectRecords !== 'function') {\n    return { migratedKeys: [], hasIndex: false };\n  }\n\n  try {\n    const storedIndex = await storageRepo.getItem(PROJECT_INDEX_KEY);\n    const indexKeys = storedIndex && typeof storedIndex === 'object'\n      ? Object.keys(storedIndex)\n      : [];\n    const normalizedIndex = normalizeProjectIndexForCache(storedIndex);\n    const migrationResult = await storageRepo.migrateUnprefixedProjectRecords({\n      projectIndexKeys: indexKeys,\n    });\n\n    if (normalizedIndex) {\n      projectIndexCache = normalizedIndex;\n      const prefixedIndex = buildProjectIndexForRepo(normalizedIndex);\n      if (prefixedIndex) {\n        await storageRepo.setItem(PROJECT_INDEX_KEY, prefixedIndex);\n      }\n    }\n\n    return { migratedKeys: migrationResult.migratedKeys || [], hasIndex: Boolean(normalizedIndex) };\n  } catch (migrationError) {\n    console.warn('[storage.js] Project prefix migration failed', migrationError);\n    return { migratedKeys: [], hasIndex: false };\n  }\n}\n\n/**\n * Reads, validates, and returns the project index from storage.\n * Returns null if missing or invalid.\n */\nfunction readProjectIndex() {\n  // Return cached version if available (hydrated from IDB)\n  if (projectIndexCache) {\n    return projectIndexCache;\n  }\n\n  // Fallback to legacy LocalStorage if cache not ready (rare, only during rapid boot)\n  const safeStorage = getSafeLocalStorage();\n  const isIndexedDB = storageRepo && storageRepo.driver && storageRepo.driver.constructor && storageRepo.driver.constructor.name === 'IndexedDBAdapter';\n\n  if (!safeStorage || typeof safeStorage.getItem !== 'function') return null;\n\n  // If we are strictly on IDB and cache is empty, we return null (assuming hydration handles it).\n  // But for safety during migration, we can check legacy one last time?\n  // No, if isIndexedDB is active, we should rely on cache.\n  if (isIndexedDB) {\n    return null;\n  }\n\n  try {\n    const raw = safeStorage.getItem(PROJECT_INDEX_KEY);\n    if (!raw) return null;\n\n    const index = JSON.parse(raw);\n    if (index && typeof index === 'object') {\n      return normalizeProjectIndexForCache(index) || index;\n    }\n  } catch (e) {\n    console.warn('Failed to read project index', e);\n  }\n  return null;\n}\n\n/**\n * Updates the persisted project index based on the full projects map.\n */\nfunction updateProjectIndex(projects, safeStorage) {\n  // if (!safeStorage || typeof safeStorage.setItem !== 'function') return; // Relaxed for repo support\n  if (!projects || typeof projects !== 'object') return;\n\n  const index = {};\n  Object.keys(projects).forEach(key => {\n    // Skip auto-backups in the index to keep it small\n    if (isAutoBackupStorageKey(key)) return;\n\n    const project = projects[key];\n    if (!project) return;\n\n    index[key] = {\n      color: project.color,\n      icon: project.icon,\n      lastModified: project.lastModified,\n      prepDays: project.prepDays,\n      shootingDays: project.shootingDays,\n      returnDays: project.returnDays,\n      archived: project.archived,\n      status: project.status\n    };\n  });\n\n  // [Agent Refactor] Update Cache & Repo\n  projectIndexCache = index;\n\n  const isIndexedDB = storageRepo && storageRepo.driver && storageRepo.driver.constructor && storageRepo.driver.constructor.name === 'IndexedDBAdapter';\n  if (storageRepo) {\n    // Async write to new storage\n    const prefixedIndex = buildProjectIndexForRepo(index);\n    storageRepo.setItem(PROJECT_INDEX_KEY, prefixedIndex).catch(e => console.warn('Failed to persist index to repo', e));\n  }\n\n  // Legacy writes only if NOT on IndexedDB\n  if (!isIndexedDB && safeStorage && typeof safeStorage.setItem === 'function') {\n    try {\n      safeStorage.setItem(PROJECT_INDEX_KEY, JSON.stringify(index));\n    } catch (e) {\n      console.warn('Failed to write project index', e);\n    }\n  }\n}\n\nfunction loadProject(name) {\n  const skipAutoBackupExpansion =\n    name !== undefined\n    && !(typeof name === 'string' && isAutoBackupStorageKey(name));\n\n  let { projects, changed, originalValue, lookup } = readAllProjectsFromStorage({\n    skipAutoBackupExpansion,\n  });\n  let resolvedKey = null;\n\n  if (name !== undefined) {\n    resolvedKey = resolveProjectKey(projects, lookup, name, { preferExact: true });\n    if (resolvedKey !== null && resolvedKey !== undefined) {\n      markProjectActivity(resolvedKey);\n    }\n  }\n\n  if (changed) {\n    const safeStorage = getSafeLocalStorage();\n    if (safeStorage) {\n      createStorageMigrationBackup(safeStorage, PROJECT_STORAGE_KEY, originalValue);\n    }\n    const mutableProjects = STORAGE_DEEP_CLONE(projects);\n    persistAllProjects(mutableProjects);\n    projects = mutableProjects;\n  }\n  if (name === undefined) {\n    markProjectCollectionActivity(projects);\n    return projects;\n  }\n  if (\n    resolvedKey !== null\n    && resolvedKey !== undefined\n    && Object.prototype.hasOwnProperty.call(projects, resolvedKey)\n  ) {\n    const project = projects[resolvedKey];\n    if (project && (!project.gearList || project.gearList === \"\")) {\n      const setups = loadSetups();\n      const setup = setups[resolvedKey];\n      if (setup) {\n        if (setup.gearList) {\n          project.gearList = setup.gearList;\n        }\n      }\n    }\n    return project;\n  }\n  return null;\n}\n\nfunction loadProjectMetadata() {\n  // 1. Try to load from optimized Index\n  const cachedIndex = readProjectIndex();\n  if (cachedIndex) {\n    return cachedIndex;\n  }\n\n  // 2. Fallback: Full Load (Slow)\n  // We also skip auto-backup expansion here to save memory/time\n  const loaded = readAllProjectsFromStorage({ forMutation: false, skipAutoBackupExpansion: true });\n  const result = {};\n\n  if (loaded && loaded.projects) {\n    const keys = Object.keys(loaded.projects);\n    for (let i = 0; i < keys.length; i++) {\n      const key = keys[i];\n\n      // Skip auto-backups if they leaked through\n      if (isAutoBackupStorageKey(key)) continue;\n\n      const project = loaded.projects[key];\n      if (!project) continue;\n\n      // Optimized metadata extraction\n      result[key] = {\n        color: project.color,\n        icon: project.icon,\n        lastModified: project.lastModified,\n        prepDays: project.prepDays,\n        shootingDays: project.shootingDays,\n        returnDays: project.returnDays,\n        archived: project.archived,\n        status: project.status\n      };\n    }\n\n    // 3. Self-Heal: Create the index for next time\n    const safeStorage = getSafeLocalStorage();\n    if (safeStorage) {\n      try {\n        updateProjectIndex(loaded.projects, safeStorage);\n      } catch (e) {\n        void e;\n      }\n    }\n  }\n  return result;\n}\n\nfunction sanitizeProjectNameForBackup(name) {\n  if (typeof name !== 'string') {\n    return '';\n  }\n  const collapsed = name.replace(/\\s+/g, ' ').trim();\n  if (!collapsed) {\n    return '';\n  }\n  if (collapsed.length <= 120) {\n    return collapsed;\n  }\n  return collapsed.slice(0, 120);\n}\n\nfunction formatAutoBackupTimestamp(date) {\n  const pad = (value) => String(value).padStart(2, '0');\n  return [\n    date.getFullYear(),\n    pad(date.getMonth() + 1),\n    pad(date.getDate()),\n    pad(date.getHours()),\n    pad(date.getMinutes()),\n    pad(date.getSeconds()),\n  ].join('-');\n}\n\nfunction generateDeletionBackupMetadata(projectName, projects) {\n  const now = new Date();\n  const timestamp = formatAutoBackupTimestamp(now);\n  const sanitizedName = sanitizeProjectNameForBackup(projectName);\n  const baseName = sanitizedName\n    ? `${STORAGE_AUTO_BACKUP_DELETION_PREFIX}${timestamp}-${sanitizedName}`\n    : `${STORAGE_AUTO_BACKUP_DELETION_PREFIX}${timestamp}`;\n  const usedNames = new Set(Object.keys(projects));\n  if (!usedNames.has(baseName)) {\n    return { name: baseName };\n  }\n  let suffix = 2;\n  let candidate = `${baseName}-${suffix}`;\n  while (usedNames.has(candidate)) {\n    suffix += 1;\n    candidate = `${baseName}-${suffix}`;\n  }\n  return { name: candidate };\n}\n\nfunction cloneProjectEntryForBackup(entry) {\n  if (entry === undefined) {\n    return undefined;\n  }\n  if (entry === null || typeof entry !== 'object') {\n    return entry;\n  }\n  try {\n    const cloned = STORAGE_DEEP_CLONE(entry);\n    const normalized = normalizeLegacyLongGopStructure(cloned);\n    return normalized !== cloned ? normalized : cloned;\n  } catch (error) {\n    console.warn('Unable to deep clone project for backup', error);\n    const fallback = { ...entry };\n    const normalized = normalizeLegacyLongGopStructure(fallback);\n    return normalized !== fallback ? normalized : fallback;\n  }\n}\n\nfunction maybeCreateProjectDeletionBackup(projects, key) {\n  if (!projects || !Object.prototype.hasOwnProperty.call(projects, key)) {\n    return { status: 'missing' };\n  }\n  if (typeof key === 'string' && key.startsWith(STORAGE_AUTO_BACKUP_NAME_PREFIX)) {\n    return { status: 'skipped' };\n  }\n  const entry = projects[key];\n  if (entry === undefined) {\n    return { status: 'missing' };\n  }\n  const { name: backupName } = generateDeletionBackupMetadata(key, projects);\n  if (!backupName) {\n    return { status: 'failed' };\n  }\n  const cloned = cloneProjectEntryForBackup(entry);\n  if (cloned === undefined) {\n    if (typeof console !== 'undefined' && typeof console.warn === 'function') {\n      console.warn(\n        `Skipping deletion backup for project \"${key}\" because no stored data was available during backup creation.`,\n      );\n    }\n    return { status: 'missing' };\n  }\n  projects[backupName] = cloned;\n  return { status: 'created', backupName };\n}\n\nfunction createProjectDeletionBackup(name) {\n  const { projects, changed, originalValue, lookup } = readAllProjectsFromStorage({ forMutation: true });\n  if (!projects || typeof projects !== 'object') {\n    return { status: 'invalid' };\n  }\n\n  const resolvedKey = resolveProjectKey(projects, lookup, name, { preferExact: true });\n  const normalizedName = normalizeProjectStorageKey(name);\n  const key =\n    resolvedKey !== null && resolvedKey !== undefined\n      ? resolvedKey\n      : normalizedName;\n\n  if (!Object.prototype.hasOwnProperty.call(projects, key)) {\n    return { status: 'missing' };\n  }\n\n  const backupOutcome = maybeCreateProjectDeletionBackup(projects, key);\n  if (backupOutcome.status !== 'created') {\n    return backupOutcome;\n  }\n\n  if (changed) {\n    const safeStorage = getSafeLocalStorage();\n    if (safeStorage) {\n      createStorageMigrationBackup(safeStorage, PROJECT_STORAGE_KEY, originalValue);\n    }\n  }\n\n  markProjectActivity(backupOutcome.backupName);\n  persistAllProjects(projects);\n  return backupOutcome;\n}\n\nfunction generateOverwriteBackupMetadata(projectName, projects) {\n  const timestamp = formatAutoBackupTimestamp(new Date());\n  const sanitizedName = sanitizeProjectNameForBackup(projectName);\n  const baseName = sanitizedName\n    ? `${STORAGE_AUTO_BACKUP_NAME_PREFIX}${timestamp}-${sanitizedName}`\n    : `${STORAGE_AUTO_BACKUP_NAME_PREFIX}${timestamp}`;\n  const usedNames = new Set(Object.keys(projects));\n  if (!usedNames.has(baseName)) {\n    return { name: baseName };\n  }\n  let suffix = 2;\n  let candidate = `${baseName}-${suffix}`;\n  while (usedNames.has(candidate)) {\n    suffix += 1;\n    candidate = `${baseName}-${suffix}`;\n  }\n  return { name: candidate };\n}\n\nfunction maybeCreateProjectOverwriteBackup(projects, key) {\n  if (!isPlainObject(projects) || typeof key !== 'string') {\n    return { status: 'invalid' };\n  }\n  if (!Object.prototype.hasOwnProperty.call(projects, key)) {\n    return { status: 'missing' };\n  }\n  if (\n    key.startsWith(STORAGE_AUTO_BACKUP_NAME_PREFIX)\n    || key.startsWith(STORAGE_AUTO_BACKUP_DELETION_PREFIX)\n  ) {\n    return { status: 'skipped' };\n  }\n\n  const backupSource = cloneProjectEntryForBackup(projects[key]);\n  if (backupSource === undefined) {\n    return { status: 'failed' };\n  }\n\n  const { name: backupName } = generateOverwriteBackupMetadata(key, projects);\n  if (!backupName) {\n    return { status: 'failed' };\n  }\n\n  projects[backupName] = backupSource;\n  return { status: 'created', backupName };\n}\n\n/**\n * Safe Project Persistence\n *\n * This function implements a robust \"safe save\" strategy to prevent data loss:\n * 1. NORMALIZATION: Ensures the project structure is valid and standardizes properties (e.g. trimming strings).\n * 2. MIGRATION BACKUP: If the storage snapshot has changed since the last read (detected via 'changed' flag),\n *    we create a safety backup of the PREVIOUS state before overwriting it. This protects against race conditions\n *    where two tabs might try to save, preserving the first tab's work in a backup file.\n * 3. OVERWRITE BACKUP: Before overwriting an existing project with the same name, we verify content diffs.\n *    If the content differs, we create a specific overwrite backup (e.g. \"MyProject-backup\").\n * 4. ATOMIC COMMIT: We finally write the new project data.\n *\n * @param {string} name - The intended name for the project.\n * @param {object} project - The project data object.\n * @param {object} [options] - Save options (e.g. skipOverwriteBackup, skipCompression).\n */\nfunction saveProject(name, project, options = {}) {\n  if (!isPlainObject(project)) return;\n\n  const normalized = normalizeProject(project);\n  if (!normalized) {\n    if (typeof console !== 'undefined' && typeof console.warn === 'function') {\n      console.warn(\n        `Skipped saving project \"${name || ''}\" because the payload could not be normalised.`,\n      );\n    }\n    return;\n  }\n  const skipOverwriteBackup = Boolean(options && options.skipOverwriteBackup);\n  const skipCompression = Boolean(options && options.skipCompression);\n\n  const requestedKey = typeof name === 'string' ? name : '';\n  const preferredKey = normalizeProjectStorageKey(requestedKey);\n\n  // Initial check: if what we are about to write will overwrite something that has changed\n  // on disk (via another tab), we must safeguard that data first.\n  const initialSnapshot = readAllProjectsFromStorage({ forMutation: true });\n  const initialProjects = isPlainObject(initialSnapshot.projects) ? initialSnapshot.projects : {};\n  if (initialSnapshot.changed) {\n    const safeStorage = getSafeLocalStorage();\n    if (safeStorage) {\n      // [SAFETY] Create a migration backup to preserve the state before this write.\n      createStorageMigrationBackup(safeStorage, PROJECT_STORAGE_KEY, initialSnapshot.originalValue);\n    }\n  }\n\n  const initialResolvedKey = resolveProjectKey(\n    initialProjects,\n    initialSnapshot.lookup,\n    requestedKey,\n    { preferExact: true },\n  );\n  const initialExistingEntry =\n    initialResolvedKey !== null\n      && initialResolvedKey !== undefined\n      && Object.prototype.hasOwnProperty.call(initialProjects, initialResolvedKey)\n      ? initialProjects[initialResolvedKey]\n      : null;\n  const initialExistingSignature = initialExistingEntry\n    ? createStableValueSignature(initialExistingEntry)\n    : null;\n\n  /*\n   * We re-read the projects after the initial snapshot because another tab can write to storage\n   * between our first check and this save. An offline-first app must treat that window as unsafe\n   * for user data, so we verify the latest state before touching anything.\n   *\n   * This second read mitigates cross-tab race conditions by ensuring we evaluate the most recent\n   * project list and signatures. It lets us detect late-arriving changes and take backup paths\n   * instead of overwriting or deleting user data from a different session.\n   *\n   * The resolveProjectKey lookup compares the requested name against the latest index so we know\n   * whether it is safe to overwrite, or if we should write to a preferred key and delete a rename.\n   * Signature comparisons then confirm that any overwrite or rename cleanup only happens when the\n   * entry we saw initially still matches the stored data, keeping backups intact and preventing\n   * data loss across tabs.\n   */\n\n  const latestSnapshot = readAllProjectsFromStorage({ forMutation: true });\n  const projects = isPlainObject(latestSnapshot.projects) ? latestSnapshot.projects : {};\n  if (latestSnapshot.changed) {\n    const safeStorage = getSafeLocalStorage();\n    if (safeStorage) {\n      // [SAFETY] Double-check safeguards if a race condition happened between the checks.\n      createStorageMigrationBackup(safeStorage, PROJECT_STORAGE_KEY, latestSnapshot.originalValue);\n    }\n  }\n\n  const resolvedKey = resolveProjectKey(projects, latestSnapshot.lookup, requestedKey, { preferExact: true });\n\n  let storageKey = resolvedKey;\n  let renamedFromKey = null;\n  if (\n    preferredKey\n    && preferredKey !== resolvedKey\n    && !Object.prototype.hasOwnProperty.call(projects, preferredKey)\n  ) {\n    storageKey = preferredKey;\n    renamedFromKey = resolvedKey;\n  }\n\n  if (storageKey === null || storageKey === undefined) {\n    storageKey = preferredKey;\n  }\n\n  if (!storageKey && storageKey !== '') {\n    storageKey = '';\n  }\n\n  const existingKey = renamedFromKey !== null && renamedFromKey !== undefined\n    ? renamedFromKey\n    : storageKey;\n  const hasExistingEntry =\n    existingKey !== null\n    && existingKey !== undefined\n    && Object.prototype.hasOwnProperty.call(projects, existingKey);\n  const existingEntry = hasExistingEntry ? projects[existingKey] : null;\n\n  if (hasExistingEntry && !skipOverwriteBackup) {\n    const existingSignature = createStableValueSignature(existingEntry);\n    const nextSignature = createStableValueSignature(normalized);\n    if (existingSignature !== nextSignature) {\n      // [SAFETY] Overwrite Protection: If we are modifying an existing project, create a specific backup.\n      const backupOutcome = maybeCreateProjectOverwriteBackup(projects, existingKey);\n      if (backupOutcome.status === 'failed') {\n        console.warn(\n          `Automatic backup before overwriting project \"${existingKey}\" failed. Proceeding with save.`,\n        );\n      }\n    }\n  }\n\n  if (\n    renamedFromKey !== null\n    && renamedFromKey !== undefined\n    && renamedFromKey !== storageKey\n  ) {\n    // Logic to safely handle renames by deleting the old key only if it hasn't changed.\n    let shouldDelete = Boolean(initialExistingSignature);\n    if (Object.prototype.hasOwnProperty.call(projects, renamedFromKey)) {\n      if (initialExistingSignature) {\n        const latestSignature = createStableValueSignature(projects[renamedFromKey]);\n        if (latestSignature !== initialExistingSignature) {\n          shouldDelete = false;\n        }\n      } else {\n        shouldDelete = false;\n      }\n    } else {\n      shouldDelete = false;\n    }\n\n    if (shouldDelete) {\n      delete projects[renamedFromKey];\n      removeProjectActivity(renamedFromKey);\n    } else if (typeof console !== 'undefined' && typeof console.warn === 'function') {\n      console.warn(\n        `Skipped removing \"${renamedFromKey}\" while saving \"${storageKey}\" because the original entry changed in another tab.`,\n      );\n    }\n  }\n\n  // Explicit rename handling from options (e.g. from handleSaveSetupClick)\n  const manualRenamedFrom = options && options.renamedFrom;\n  if (manualRenamedFrom && manualRenamedFrom !== storageKey) {\n    const resolvedOld = resolveProjectKey(projects, latestSnapshot.lookup, manualRenamedFrom, { preferExact: true });\n    if (resolvedOld && Object.prototype.hasOwnProperty.call(projects, resolvedOld)) {\n      delete projects[resolvedOld];\n      removeProjectActivity(resolvedOld);\n    }\n  }\n\n  const finalKey = storageKey || '';\n  projects[finalKey] = normalized;\n  markProjectActivity(finalKey);\n\n  // Prune within the projects object first (handling auto-backup counts)\n  enforceAutoBackupLimits(projects);\n\n  // [Agent Refactor] Dual-Write to StorageRepository & Memory Cache\n  // Keep the offline data sources aligned by writing both the durable repo (IndexedDB-backed)\n  // and the in-memory cache used for synchronous reads. This prevents drift between tabs/sessions\n  // and ensures autosave, backup, and restore flows always have the latest snapshot available.\n  if (storageRepo) {\n    storageRepo.saveProject(finalKey, normalized).catch(err => console.warn('[saveProject] Repo write failed', err));\n  }\n  if (isProjectCacheHydrated) {\n    projectMemoryCache[finalKey] = normalized;\n  }\n\n  // Instead of calling persistAllProjects(projects), which would trigger a massive monolithic rewrite,\n  // we now use sharded persistence for the specific project being saved.\n  // [Agent Refactor] Skip legacy LocalStorage write if we are using IndexedDB to avoid quota errors.\n  // When IndexedDB is active, we avoid a redundant monolithic LocalStorage write that risks quota\n  // exhaustion; we still preserve backups through the repository and the sharded persistence path.\n  // Shard persistence is preferred because it limits blast radius and avoids monolithic write failures.\n  const isIndexedDB = storageRepo && storageRepo.driver && storageRepo.driver.constructor && storageRepo.driver.constructor.name === 'IndexedDBAdapter';\n  let shardSuccess = true;\n\n  if (!isIndexedDB) {\n    shardSuccess = persistProjectShard(finalKey, normalized, { skipCompression });\n  }\n\n  if (shardSuccess) {\n    const safeStorage = getSafeLocalStorage();\n    // Clean up shards that are no longer in the projects map (renames or pruned backups)\n    pruneOrphanProjectShards(safeStorage, projects);\n    // Ensure migration from monolithic is finalized\n    cleanupMonolithicProjectStorage(safeStorage);\n\n    // Trigger cross-tab invalidation.\n    invalidateProjectReadCache();\n    if (lifecycleChannel) {\n      try {\n        lifecycleChannel.postMessage('project-shards-changed');\n      } catch (e) {\n        void e;\n      }\n    }\n    bumpProjectStorageRevision(safeStorage);\n  } else {\n    // Fallback for extreme cases (storage issues), though persistAllProjects would likely fail too.\n    persistAllProjects(projects, { skipCompression });\n  }\n}\n\nfunction deleteProject(name) {\n  if (name === undefined) {\n    // ... (Factory reset logic) ...\n    const storagesToPrune = [getSafeLocalStorage()];\n    if (typeof localStorage !== 'undefined' && storagesToPrune.indexOf(localStorage) === -1) {\n      storagesToPrune.push(localStorage);\n    }\n\n    storagesToPrune.forEach((storage) => {\n      // Force delete primary and backup keys directly first to ensure factory reset reliability\n      if (storage && typeof storage.removeItem === 'function') {\n        try {\n          storage.removeItem(PROJECT_STORAGE_KEY);\n          const backupSuffix = typeof STORAGE_BACKUP_SUFFIX === 'string' ? STORAGE_BACKUP_SUFFIX : '__backup';\n          storage.removeItem(`${PROJECT_STORAGE_KEY}${backupSuffix}`);\n          // Also remove hardcoded potential legacy/default backup key just in case\n          storage.removeItem('cameraPowerPlanner_project__backup');\n        } catch (e) {\n          console.warn(`[FactoryReset] Failed to force delete project keys`, e);\n        }\n      }\n\n      deleteFromStorage(\n        storage,\n        PROJECT_STORAGE_KEY,\n        \"Error deleting project from storage:\",\n      );\n\n      if (storage && typeof storage.length === 'number') {\n        const shardKeys = [];\n        for (let i = 0; i < storage.length; i++) {\n          const key = storage.key(i);\n          if (key && key.startsWith(PROJECT_SHARD_PREFIX)) {\n            shardKeys.push(key);\n          }\n        }\n        shardKeys.forEach((key) => deleteFromStorage(\n          storage,\n          key,\n          \"Error deleting project shard from storage:\",\n        ));\n      }\n    });\n\n    // [Refactor] Clear IndexedDB and OPFS Data Vault\n    // This ensures a true Factory Reset across all storage layers.\n    try {\n      if (storageRepo) {\n        storageRepo.clear().catch(e => console.warn('[FactoryReset] Failed to clear StorageRepository', e));\n      }\n      if (dataVault) {\n        dataVault.clear().catch(e => console.warn('[FactoryReset] Failed to clear DataVault', e));\n      }\n      if (userContext) {\n        userContext.reset();\n      }\n    } catch (e) {\n      console.warn('[FactoryReset] Error clearing modern storage', e);\n    }\n    // ... (Clear UI caches and notify tabs) ...\n    if (typeof clearUiCacheStorageEntries === 'function') {\n      try {\n        clearUiCacheStorageEntries();\n      } catch (uiCacheError) {\n        console.warn('Failed to clear UI cache during project deletion', uiCacheError);\n      }\n    }\n\n    invalidateProjectReadCache();\n    if (lifecycleChannel) { try { lifecycleChannel.postMessage('project-shards-changed'); } catch (e) { void e; } }\n    if (projectActivityTimestamps && typeof projectActivityTimestamps.clear === 'function') {\n      projectActivityTimestamps.clear();\n    }\n    const currentSafeStorage = getSafeLocalStorage();\n    if (currentSafeStorage) {\n      bumpProjectStorageRevision(currentSafeStorage);\n    }\n    return;\n  }\n\n  const { projects, changed, originalValue, lookup } = readAllProjectsFromStorage({ forMutation: true });\n  if (changed) {\n    const safeStorage = getSafeLocalStorage();\n    if (safeStorage) {\n      createStorageMigrationBackup(safeStorage, PROJECT_STORAGE_KEY, originalValue);\n    }\n  }\n  const resolvedKey = resolveProjectKey(projects, lookup, name, { preferExact: true });\n  const key =\n    resolvedKey !== null && resolvedKey !== undefined\n      ? resolvedKey\n      : normalizeProjectStorageKey(name);\n\n  if (!Object.prototype.hasOwnProperty.call(projects, key)) {\n    // If key not found in project map, try deleting potential orphan shard directly\n    const potentialShardKey = PROJECT_SHARD_PREFIX + normalizeProjectStorageKey(name);\n    const safeStorage = getSafeLocalStorage();\n    if (safeStorage) {\n      deleteFromStorage(safeStorage, potentialShardKey, \"Error deleting orphan project shard:\");\n    }\n    return;\n  }\n\n  // [SAFETY] Create a \"Deletion Backup\" (undoable operation support)\n  const backupOutcome = maybeCreateProjectDeletionBackup(projects, key);\n  if (backupOutcome.status === 'failed') {\n    console.warn(`Automatic backup before deleting project \"${key}\" failed. Deletion aborted.`);\n    alertStorageError();\n    return;\n  }\n  const shardKey = PROJECT_SHARD_PREFIX + normalizeProjectStorageKey(key);\n  const safeStorage = getSafeLocalStorage();\n  // [Agent Refactor] Skip legacy LocalStorage delete if we are using IndexedDB\n  const isIndexedDB = storageRepo && storageRepo.driver && storageRepo.driver.constructor && storageRepo.driver.constructor.name === 'IndexedDBAdapter';\n\n  if (safeStorage && !isIndexedDB) {\n    deleteFromStorage(safeStorage, shardKey, \"Error deleting project shard:\");\n  }\n  // Update Memory Cache\n  if (isProjectCacheHydrated) {\n    delete projectMemoryCache[key];\n  }\n\n  // Update StorageRepository (Async)\n  // We fire and forget the delete, but UI updates immediately via cache/events\n  if (storageRepo && typeof storageRepo.removeProject === 'function') {\n    storageRepo.removeProject(key).catch(e => console.warn('Failed to delete from repo', e));\n  } else if (storageRepo) {\n    storageRepo.removeItem(key).catch(e => console.warn('Failed to delete from repo', e));\n  }\n\n  delete projects[key];\n  removeProjectActivity(key);\n  // persistAllProjects(projects); // Legacy persistence\n\n  // Dispatch events\n  invalidateProjectReadCache();\n  if (lifecycleChannel) { try { lifecycleChannel.postMessage('project-shards-changed'); } catch (e) { void e; } }\n}\n\nfunction renameProject(oldName, newName) {\n  if (!oldName || !newName) return null;\n  // Use read logic to get current state (memory or storage)\n  const { projects } = readAllProjectsFromStorage({ forMutation: true });\n\n  // Resolve keys\n  const resolvedKey = resolveProjectKey(projects, null, oldName, { preferExact: true });\n  if (!resolvedKey || !projects[resolvedKey]) {\n    return null;\n  }\n\n  const targetName = newName.trim();\n  if (!targetName || targetName === resolvedKey) {\n    return resolvedKey;\n  }\n\n  const projectData = projects[resolvedKey];\n  projectData.name = targetName; // Update internal name\n  if (!isPlainObject(projectData.projectInfo)) {\n    projectData.projectInfo = {};\n  }\n  projectData.projectInfo.projectName = targetName;\n\n  // Update Memory Cache\n  if (isProjectCacheHydrated) {\n    delete projectMemoryCache[resolvedKey];\n    projectMemoryCache[targetName] = projectData;\n  } else {\n    // Legacy fallback: modify local map passed from readAllProjects\n    delete projects[resolvedKey];\n    projects[targetName] = projectData;\n  }\n\n  // Update Storage (Async)\n  if (storageRepo && typeof storageRepo.removeProject === 'function') {\n    storageRepo.removeProject(resolvedKey).catch(e => console.warn('Failed to delete old project key', e));\n  } else if (storageRepo) {\n    storageRepo.removeItem(resolvedKey).catch(e => console.warn('Failed to delete old project key', e));\n  }\n  // We use the new saveProject which handles repo save + cache update redundancy\n  saveProject(targetName, projectData);\n\n  // Dispatch events\n  invalidateProjectReadCache();\n  if (lifecycleChannel) { try { lifecycleChannel.postMessage('project-shards-changed'); } catch (e) { void e; } }\n\n  return targetName;\n}\n\nfunction createProjectImporter() {\n  const { projects, changed, originalValue } = readAllProjectsFromStorage({ forMutation: true });\n  if (changed) {\n    const safeStorage = getSafeLocalStorage();\n    if (safeStorage) {\n      createStorageMigrationBackup(safeStorage, PROJECT_STORAGE_KEY, originalValue);\n    }\n  }\n  const usedNames = new Set(Object.keys(projects));\n  const normalizedNames = new Set(\n    [...usedNames].map((name) => name.trim().toLowerCase()),\n  );\n  const defaultName = \"Imported project\";\n\n  return (rawName, project, fallbackName = defaultName) => {\n    const normalizedProject = normalizeProject(project);\n    if (!normalizedProject) return;\n\n    const originalHasGenerationFlag =\n      project\n      && typeof project === \"object\"\n      && Object.prototype.hasOwnProperty.call(project, \"gearListAndProjectRequirementsGenerated\")\n      && typeof project.gearListAndProjectRequirementsGenerated === \"boolean\";\n\n    if (\n      !originalHasGenerationFlag\n      && typeof normalizedProject.gearListAndProjectRequirementsGenerated !== 'boolean'\n    ) {\n      normalizedProject.gearListAndProjectRequirementsGenerated = false;\n    }\n\n    const candidates = [];\n    if (typeof rawName === \"string\") {\n      candidates.push(rawName.trim());\n    }\n    if (isPlainObject(project)) {\n      if (typeof project.name === \"string\") {\n        candidates.push(project.name.trim());\n      }\n      const info = project.projectInfo;\n      if (isPlainObject(info) && typeof info.projectName === \"string\") {\n        candidates.push(info.projectName.trim());\n      }\n    }\n\n\n    const fallback = typeof fallbackName === \"string\" && fallbackName.trim()\n      ? fallbackName.trim()\n      : defaultName;\n\n    const baseName = candidates.length > 0 ? candidates[0] : fallback;\n    const normalizedBase = typeof baseName === \"string\" ? baseName.trim().toLowerCase() : \"\";\n    const uniqueName = normalizedNames.has(normalizedBase)\n      ? generateImportedProjectName(baseName, usedNames, normalizedNames)\n      : generateUniqueName(baseName, usedNames, normalizedNames);\n    saveProject(uniqueName, normalizedProject, { skipCompression: false });\n    usedNames.add(uniqueName);\n    normalizedNames.add(uniqueName.trim().toLowerCase());\n  };\n}\n\nfunction tryParseJSONLike(value) {\n  if (typeof value !== \"string\") {\n    return { success: false, parsed: null };\n  }\n\n  const trimmed = value.trim();\n  if (!trimmed) {\n    return { success: false, parsed: null };\n  }\n\n  const firstChar = trimmed[0];\n  const lastChar = trimmed[trimmed.length - 1];\n  let expectedClosing = null;\n  if (firstChar === \"{\") {\n    expectedClosing = \"}\";\n  } else if (firstChar === \"[\") {\n    expectedClosing = \"]\";\n  } else if (firstChar === \"\\\"\") {\n    expectedClosing = \"\\\"\";\n  }\n\n  if (!expectedClosing || lastChar !== expectedClosing) {\n    return { success: false, parsed: null };\n  }\n\n  try {\n    return { success: true, parsed: JSON.parse(trimmed) };\n  } catch (error) {\n    void error;\n    return { success: false, parsed: null };\n  }\n}\n\nfunction importProjectCollection(collection, ensureImporter, fallbackLabel = \"Imported project\") {\n  if (typeof collection === \"string\") {\n    const parsed = tryParseJSONLike(collection);\n    if (parsed.success) {\n      return importProjectCollection(parsed.parsed, ensureImporter, fallbackLabel);\n    }\n\n    const importProject = ensureImporter();\n    importProject(fallbackLabel, collection, fallbackLabel);\n    return true;\n  }\n\n  if (isMapLike(collection)) {\n    const converted = convertMapLikeToObject(collection);\n    if (converted) {\n      return importProjectCollection(Object.entries(converted), ensureImporter, fallbackLabel);\n    }\n    return false;\n  }\n\n  if (Array.isArray(collection)) {\n    const entries = collection\n      .map((proj) => {\n        if (proj === null || proj === undefined) {\n          return null;\n        }\n        if (Array.isArray(proj) && proj.length >= 2) {\n          return { name: proj[0], project: proj[1] };\n        }\n        if (isPlainObject(proj) && typeof proj.name === \"string\") {\n          return { name: proj.name, project: proj };\n        }\n        return { name: '', project: proj };\n      })\n      .filter(Boolean);\n\n    if (!entries.length) {\n      return true;\n    }\n\n    const importProject = ensureImporter();\n    let count = 0;\n    entries.forEach(({ name, project }) => {\n      if (project === null || project === undefined) {\n        return;\n      }\n      count += 1;\n      let normalizedName = '';\n      if (typeof name === 'string') {\n        normalizedName = name;\n      } else if (typeof name === 'number' || typeof name === 'boolean' || typeof name === 'bigint') {\n        normalizedName = String(name);\n      } else if (typeof name === 'symbol') {\n        normalizedName = name.description || name.toString();\n      }\n      importProject(normalizedName, project, `${fallbackLabel} ${count}`);\n    });\n    return true;\n  }\n\n  if (isPlainObject(collection)) {\n    const importProject = ensureImporter();\n    Object.entries(collection).forEach(([name, proj]) => {\n      const normalizedName = typeof name === 'string' ? name : convertMapLikeKey(name);\n      importProject(\n        typeof normalizedName === 'string' && normalizedName\n          ? normalizedName\n          : fallbackLabel,\n        proj,\n        fallbackLabel,\n      );\n    });\n    return true;\n  }\n\n  return false;\n}\n\nfunction collectLegacyProjectCollections(container) {\n  if (!container || typeof container !== \"object\") {\n    return [];\n  }\n\n  const collections = [];\n  const addCollection = (value) => {\n    if (value === null || value === undefined) {\n      return;\n    }\n    collections.push(value);\n  };\n\n  const legacyKeys = [\n    \"projectData\",\n    \"projectCollection\",\n    \"projectEntries\",\n    \"legacyProjects\",\n    \"legacyProjectData\",\n  ];\n\n  legacyKeys.forEach((key) => {\n    if (Object.prototype.hasOwnProperty.call(container, key)) {\n      addCollection(container[key]);\n    }\n  });\n\n  if (isPlainObject(container.data)) {\n    if (Object.prototype.hasOwnProperty.call(container.data, \"project\")) {\n      addCollection(container.data.project);\n    }\n    if (Object.prototype.hasOwnProperty.call(container.data, \"projects\")) {\n      addCollection(container.data.projects);\n    }\n  }\n\n  const plannerData = container.plannerData;\n  if (Array.isArray(plannerData)) {\n    plannerData.forEach((entry) => {\n      if (Array.isArray(entry) && entry.length >= 2) {\n        const key = entry[0];\n        if (typeof key === \"string\" && key.toLowerCase().includes(\"project\")) {\n          addCollection(entry[1]);\n        }\n        return;\n      }\n\n      if (!entry || typeof entry !== \"object\") {\n        return;\n      }\n\n      const key = typeof entry.key === \"string\"\n        ? entry.key\n        : typeof entry.name === \"string\"\n          ? entry.name\n          : typeof entry.id === \"string\"\n            ? entry.id\n            : typeof entry.section === \"string\"\n              ? entry.section\n              : null;\n\n      if (!key || !key.toLowerCase().includes(\"project\")) {\n        return;\n      }\n\n      const value = Object.prototype.hasOwnProperty.call(entry, \"value\")\n        ? entry.value\n        : Object.prototype.hasOwnProperty.call(entry, \"data\")\n          ? entry.data\n          : Object.prototype.hasOwnProperty.call(entry, \"project\")\n            ? entry.project\n            : Object.prototype.hasOwnProperty.call(entry, \"projects\")\n              ? entry.projects\n              : null;\n\n      if (value !== null && value !== undefined) {\n        addCollection(value);\n      }\n    });\n  }\n\n  return collections;\n}\n\n// --- Favorites Storage ---\nfunction loadFavorites() {\n  applyLegacyStorageMigrations();\n  const safeStorage = getSafeLocalStorage();\n  const parsed = loadJSONFromStorage(\n    safeStorage,\n    FAVORITES_STORAGE_KEY,\n    \"Error loading favorites from localStorage:\",\n    {},\n    { validate: (value) => value === null || isPlainObject(value) },\n  );\n  return isPlainObject(parsed) ? parsed : {};\n}\n\nfunction saveFavorites(favs) {\n  const safeStorage = getSafeLocalStorage();\n  if (favs === null || favs === undefined) {\n    deleteFromStorage(\n      safeStorage,\n      FAVORITES_STORAGE_KEY,\n      \"Error deleting favorites from localStorage:\",\n    );\n    return;\n  }\n\n  if (!isPlainObject(favs)) {\n    console.warn('Ignoring invalid favorites payload. Expected a plain object.');\n    return;\n  }\n\n  ensurePreWriteMigrationBackup(safeStorage, FAVORITES_STORAGE_KEY);\n  saveJSONToStorage(\n    safeStorage,\n    FAVORITES_STORAGE_KEY,\n    favs,\n    \"Error saving favorites to localStorage:\",\n  );\n}\n\nfunction resolveContactsModuleApi() {\n  if (CONTACTS_MODULE_API) {\n    return CONTACTS_MODULE_API;\n  }\n\n  if (!CONTACTS_MODULE_RESOLUTION_ATTEMPTED) {\n    CONTACTS_MODULE_RESOLUTION_ATTEMPTED = true;\n    if (contactsModuleImport) {\n      CONTACTS_MODULE_API = contactsModuleImport;\n    }\n  }\n\n  if (CONTACTS_MODULE_API) {\n    return CONTACTS_MODULE_API;\n  }\n\n  const scope = GLOBAL_SCOPE && typeof GLOBAL_SCOPE === 'object' ? GLOBAL_SCOPE : null;\n  if (scope && scope.cineFeaturesContacts && typeof scope.cineFeaturesContacts === 'object') {\n    CONTACTS_MODULE_API = scope.cineFeaturesContacts;\n    return CONTACTS_MODULE_API;\n  }\n\n  const moduleBase = scope && typeof scope.cineModuleBase === 'object' ? scope.cineModuleBase : null;\n  if (moduleBase && typeof moduleBase.resolveModule === 'function') {\n    try {\n      const resolved = moduleBase.resolveModule('cine.features.contacts', scope);\n      if (resolved && typeof resolved === 'object') {\n        CONTACTS_MODULE_API = resolved;\n        return CONTACTS_MODULE_API;\n      }\n    } catch (error) {\n      void error;\n    }\n  }\n\n  return CONTACTS_MODULE_API;\n}\n\nfunction fallbackSanitizeContactValue(value) {\n  if (typeof value === 'string') {\n    return value.trim();\n  }\n\n  if (typeof value === 'number') {\n    if (!Number.isFinite(value)) {\n      return '';\n    }\n    return String(value).trim();\n  }\n\n  if (typeof value === 'bigint') {\n    try {\n      return value.toString();\n    } catch (bigintError) {\n      void bigintError;\n    }\n    return '';\n  }\n\n  if (typeof value === 'boolean') {\n    return value ? 'true' : 'false';\n  }\n\n  if (value && typeof value === 'object') {\n    try {\n      const primitive = value.valueOf();\n      if (primitive !== value) {\n        return fallbackSanitizeContactValue(primitive);\n      }\n\n      if (typeof value.toString === 'function') {\n        const stringified = value.toString();\n        if (typeof stringified === 'string' && stringified && stringified !== '[object Object]') {\n          return stringified.trim();\n        }\n      }\n    } catch (coercionError) {\n      void coercionError;\n    }\n  }\n\n  return '';\n}\n\nfunction fallbackGenerateContactId(moduleApi) {\n  if (moduleApi && typeof moduleApi.generateContactId === 'function') {\n    try {\n      const generated = moduleApi.generateContactId();\n      if (typeof generated === 'string' && generated) {\n        return generated;\n      }\n    } catch (error) {\n      void error;\n    }\n  }\n  return `contact-${Date.now().toString(36)}-${Math.random().toString(36).slice(2, 8)}`;\n}\n\nfunction fallbackNormalizeContactEntry(entry, moduleApi) {\n  if (!entry || typeof entry !== 'object') {\n    return null;\n  }\n\n  const sanitize = fallbackSanitizeContactValue;\n  const id = sanitize(entry.id) || fallbackGenerateContactId(moduleApi);\n  const name = sanitize(entry.name);\n  const role = sanitize(entry.role);\n  const phone = sanitize(entry.phone);\n  const email = sanitize(entry.email);\n  const website = sanitize(entry.website || entry.url);\n  const notes = sanitize(entry.notes || entry.note || entry.text);\n  const avatarSource = typeof entry.avatar === 'string' ? entry.avatar.trim() : '';\n  const avatar = avatarSource && avatarSource.startsWith('data:') ? avatarSource : '';\n  const createdAt = Number.isFinite(entry.createdAt) ? entry.createdAt : Date.now();\n  const updatedAt = Number.isFinite(entry.updatedAt) ? entry.updatedAt : createdAt;\n\n  const normalized = { id, name, role, phone, email, website, notes, createdAt, updatedAt };\n  if (avatar) {\n    normalized.avatar = avatar;\n  }\n\n  return normalized;\n}\n\nfunction fallbackSortContacts(list) {\n  if (!Array.isArray(list)) {\n    return [];\n  }\n\n  const cloned = list\n    .filter((entry) => entry && typeof entry === 'object')\n    .map((entry) => ({ ...entry }));\n\n  cloned.sort((a, b) => {\n    const nameA = (a && a.name ? a.name : '').toLowerCase();\n    const nameB = (b && b.name ? b.name : '').toLowerCase();\n    if (nameA && nameB && nameA !== nameB) {\n      try {\n        return nameA.localeCompare(nameB);\n      } catch (error) {\n        void error;\n      }\n    }\n    if (nameA && !nameB) {\n      return -1;\n    }\n    if (!nameA && nameB) {\n      return 1;\n    }\n    const createdA = a && typeof a.createdAt === 'number' ? a.createdAt : 0;\n    const createdB = b && typeof b.createdAt === 'number' ? b.createdAt : 0;\n    return createdA - createdB;\n  });\n\n  return cloned;\n}\n\nfunction normalizeContactsList(entries) {\n  if (!Array.isArray(entries)) {\n    return [];\n  }\n\n  const moduleApi = resolveContactsModuleApi();\n\n  if (moduleApi && typeof moduleApi.sortContacts === 'function') {\n    try {\n      const sorted = moduleApi.sortContacts(entries);\n      if (Array.isArray(sorted)) {\n        return sorted.filter((entry) => entry && typeof entry === 'object');\n      }\n    } catch (error) {\n      if (typeof console !== 'undefined' && typeof console.warn === 'function') {\n        console.warn('Error normalizing contacts via module.', error);\n      }\n    }\n  }\n\n  const normalizer = moduleApi && typeof moduleApi.normalizeContactEntry === 'function'\n    ? moduleApi.normalizeContactEntry\n    : null;\n\n  const normalized = [];\n  for (let index = 0; index < entries.length; index += 1) {\n    const entry = entries[index];\n    if (!entry) {\n      continue;\n    }\n\n    let normalizedEntry = null;\n    if (normalizer) {\n      try {\n        normalizedEntry = normalizer(entry);\n      } catch (error) {\n        if (typeof console !== 'undefined' && typeof console.warn === 'function') {\n          console.warn('Error normalizing contact entry via module.', error);\n        }\n        normalizedEntry = null;\n      }\n    }\n\n    if (!normalizedEntry) {\n      normalizedEntry = fallbackNormalizeContactEntry(entry, moduleApi);\n    }\n\n    if (normalizedEntry && typeof normalizedEntry === 'object') {\n      normalized.push(normalizedEntry);\n    }\n  }\n\n  return fallbackSortContacts(normalized);\n}\n\nfunction loadContacts() {\n  applyLegacyStorageMigrations();\n  const safeStorage = getSafeLocalStorage();\n  const parsed = loadJSONFromStorage(\n    safeStorage,\n    CONTACTS_STORAGE_KEY,\n    'Error loading contacts from localStorage:',\n    [],\n    { validate: (value) => value === null || Array.isArray(value) },\n  );\n  if (!Array.isArray(parsed)) {\n    return [];\n  }\n  return normalizeContactsList(parsed);\n}\n\nfunction saveContacts(contacts) {\n  const safeStorage = getSafeLocalStorage();\n  if (contacts === null || contacts === undefined) {\n    deleteFromStorage(\n      safeStorage,\n      CONTACTS_STORAGE_KEY,\n      'Error deleting contacts from localStorage:',\n    );\n    return;\n  }\n\n  if (!Array.isArray(contacts)) {\n    console.warn('Ignoring invalid contacts payload. Expected an array.');\n    return;\n  }\n\n  const normalized = normalizeContactsList(contacts);\n  ensurePreWriteMigrationBackup(safeStorage, CONTACTS_STORAGE_KEY);\n  saveJSONToStorage(\n    safeStorage,\n    CONTACTS_STORAGE_KEY,\n    normalized,\n    'Error saving contacts to localStorage:',\n    {\n      disableCompression: false,\n      forceCompressionOnQuota: true,\n    },\n  );\n}\n\n\n\nfunction loadOwnGear() {\n  return gearRepo.getOwnGear();\n}\n\nfunction saveOwnGear(data) {\n  return gearRepo.saveOwnGear(data);\n}\n\nfunction normalizeUserProfileField(value) {\n  if (typeof value === 'string') {\n    return value.trim();\n  }\n\n  if (typeof value === 'number' && Number.isFinite(value)) {\n    return String(value);\n  }\n\n  if (typeof value === 'bigint') {\n    return value.toString();\n  }\n\n  if (value && typeof value === 'object') {\n    try {\n      const primitive = value.valueOf();\n      if (primitive !== value) {\n        return normalizeUserProfileField(primitive);\n      }\n\n      if (typeof value.toString === 'function') {\n        const stringified = value.toString();\n        if (typeof stringified === 'string' && stringified && stringified !== '[object Object]') {\n          return stringified.trim();\n        }\n      }\n    } catch (coercionError) {\n      void coercionError;\n    }\n  }\n\n  return '';\n}\n\nfunction normalizeUserProfile(entry) {\n  if (!entry || typeof entry !== 'object') {\n    return null;\n  }\n\n  const name = normalizeUserProfileField(entry.name);\n  const role = normalizeUserProfileField(entry.role);\n  const avatarSource = normalizeUserProfileField(entry.avatar);\n  const avatar = avatarSource && avatarSource.toLowerCase().startsWith('data:')\n    ? avatarSource\n    : '';\n  const phone = normalizeUserProfileField(entry.phone);\n  const email = normalizeUserProfileField(entry.email);\n\n  if (!name && !role && !avatar && !phone && !email) {\n    return { name: '', role: '', avatar: '', phone: '', email: '' };\n  }\n\n  return { name, role, avatar, phone, email };\n}\n\nfunction loadUserProfile() {\n  applyLegacyStorageMigrations();\n  const safeStorage = getSafeLocalStorage();\n  const parsed = loadJSONFromStorage(\n    safeStorage,\n    USER_PROFILE_STORAGE_KEY,\n    'Error loading user profile from localStorage:',\n    null,\n    { validate: (value) => value === null || isPlainObject(value) },\n  );\n  if (!isPlainObject(parsed)) {\n    return { name: '', role: '', avatar: '', phone: '', email: '' };\n  }\n  return normalizeUserProfile(parsed) || { name: '', role: '', avatar: '', phone: '', email: '' };\n}\n\nfunction saveUserProfile(profile) {\n  const safeStorage = getSafeLocalStorage();\n  if (profile === null || profile === undefined) {\n    deleteFromStorage(\n      safeStorage,\n      USER_PROFILE_STORAGE_KEY,\n      'Error deleting user profile from localStorage:',\n    );\n    return;\n  }\n\n  const normalized = normalizeUserProfile(profile) || { name: '', role: '', avatar: '', phone: '', email: '' };\n  if (!normalized.name && !normalized.role && !normalized.avatar && !normalized.phone && !normalized.email) {\n    deleteFromStorage(\n      safeStorage,\n      USER_PROFILE_STORAGE_KEY,\n      'Error deleting user profile from localStorage:',\n    );\n    return;\n  }\n\n  ensurePreWriteMigrationBackup(safeStorage, USER_PROFILE_STORAGE_KEY);\n  saveJSONToStorage(\n    safeStorage,\n    USER_PROFILE_STORAGE_KEY,\n    normalized,\n    'Error saving user profile to localStorage:',\n    {\n      disableCompression: false,\n      forceCompressionOnQuota: true,\n      enableCompressionSweep: false,\n    },\n  );\n}\n\n// --- User Feedback Storage ---\nfunction loadFeedback() {\n  applyLegacyStorageMigrations();\n  const safeStorage = getSafeLocalStorage();\n  const parsed = loadJSONFromStorage(\n    safeStorage,\n    FEEDBACK_STORAGE_KEY,\n    \"Error loading feedback from localStorage:\",\n    null,\n    { validate: (value) => value === null || isPlainObject(value) },\n  );\n  if (isPlainObject(parsed)) {\n    return parsed;\n  }\n  return {};\n}\n\nfunction saveFeedback(feedback) {\n  const safeStorage = getSafeLocalStorage();\n  if (feedback === null || feedback === undefined) {\n    deleteFromStorage(\n      safeStorage,\n      FEEDBACK_STORAGE_KEY,\n      \"Error deleting feedback from localStorage:\",\n    );\n    return;\n  }\n\n  if (!isPlainObject(feedback)) {\n    console.warn('Ignoring invalid feedback payload. Expected a plain object.');\n    return;\n  }\n\n  ensurePreWriteMigrationBackup(safeStorage, FEEDBACK_STORAGE_KEY);\n  saveJSONToStorage(\n    safeStorage,\n    FEEDBACK_STORAGE_KEY,\n    feedback,\n    \"Error saving feedback to localStorage:\",\n  );\n}\n\nfunction normalizeFullBackupHistoryEntry(entry) {\n  if (!entry) {\n    return null;\n  }\n\n  if (typeof entry === 'string') {\n    const trimmed = entry.trim();\n    return trimmed ? { createdAt: trimmed } : null;\n  }\n\n  if (typeof entry === 'object') {\n    const createdAt = typeof entry.createdAt === 'string' && entry.createdAt.trim()\n      ? entry.createdAt.trim()\n      : typeof entry.iso === 'string' && entry.iso.trim()\n        ? entry.iso.trim()\n        : typeof entry.timestamp === 'string' && entry.timestamp.trim()\n          ? entry.timestamp.trim()\n          : null;\n    if (!createdAt) {\n      return null;\n    }\n    const normalized = { createdAt };\n    if (typeof entry.fileName === 'string' && entry.fileName.trim()) {\n      normalized.fileName = entry.fileName.trim();\n    } else if (typeof entry.name === 'string' && entry.name.trim()) {\n      normalized.fileName = entry.name.trim();\n    }\n    return normalized;\n  }\n\n  return null;\n}\n\nfunction loadFullBackupHistory() {\n  // [Migration] Use cache if available (hydrated from storageRepo)\n  if (fullBackupHistoryCache !== null) {\n    const cached = fullBackupHistoryCache;\n    if (Array.isArray(cached)) {\n      return cached.map(normalizeFullBackupHistoryEntry).filter(Boolean);\n    }\n  }\n\n  // Fallback to legacy localStorage for first load or if cache not yet hydrated\n  applyLegacyStorageMigrations();\n  const safeStorage = getSafeLocalStorage();\n  const parsed = loadJSONFromStorage(\n    safeStorage,\n    FULL_BACKUP_HISTORY_STORAGE_KEY,\n    \"Error loading full backup history from localStorage:\",\n    [],\n    { validate: (value) => value === null || Array.isArray(value) },\n  );\n  if (!Array.isArray(parsed)) {\n    return [];\n  }\n  const normalized = parsed.map(normalizeFullBackupHistoryEntry).filter(Boolean);\n\n  // Hydrate cache for future reads\n  fullBackupHistoryCache = normalized;\n\n  // Async persist to new storage system (fire-and-forget migration)\n  storageRepo.setItem(FULL_BACKUP_HISTORY_STORAGE_KEY, normalized).catch(err => {\n    console.warn('[storage.js] Failed to persist backup history to new storage:', err);\n  });\n\n  return normalized;\n}\n\nfunction saveFullBackupHistory(entries) {\n  const safeStorage = getSafeLocalStorage();\n\n  if (entries === null || entries === undefined) {\n    // Clear cache\n    fullBackupHistoryCache = [];\n\n    // Delete from legacy localStorage\n    deleteFromStorage(\n      safeStorage,\n      FULL_BACKUP_HISTORY_STORAGE_KEY,\n      \"Error deleting full backup history from localStorage:\",\n    );\n\n    // Delete from new storage (async, fire-and-forget)\n    storageRepo.removeItem(FULL_BACKUP_HISTORY_STORAGE_KEY).catch(err => {\n      console.warn('[storage.js] Failed to delete backup history from new storage:', err);\n    });\n    return;\n  }\n\n  if (!Array.isArray(entries)) {\n    console.warn('Ignoring invalid full backup history payload. Expected an array.');\n    return;\n  }\n\n  const safeEntries = entries\n    .map(normalizeFullBackupHistoryEntry)\n    .filter(Boolean);\n\n  if (!safeEntries.length) {\n    if (entries.length === 0) {\n      // Clear cache\n      fullBackupHistoryCache = [];\n\n      // Delete from legacy localStorage\n      deleteFromStorage(\n        safeStorage,\n        FULL_BACKUP_HISTORY_STORAGE_KEY,\n        \"Error deleting full backup history from localStorage:\",\n      );\n\n      // Delete from new storage (async, fire-and-forget)\n      storageRepo.removeItem(FULL_BACKUP_HISTORY_STORAGE_KEY).catch(err => {\n        console.warn('[storage.js] Failed to delete backup history from new storage:', err);\n      });\n    } else {\n      console.warn('Ignoring full backup history update because no valid entries were provided.');\n    }\n    return;\n  }\n\n  // Update in-memory cache first for immediate sync reads\n  fullBackupHistoryCache = safeEntries;\n\n  // Persist to legacy localStorage (sync)\n  ensurePreWriteMigrationBackup(safeStorage, FULL_BACKUP_HISTORY_STORAGE_KEY);\n  saveJSONToStorage(\n    safeStorage,\n    FULL_BACKUP_HISTORY_STORAGE_KEY,\n    safeEntries,\n    \"Error saving full backup history to localStorage:\",\n    {\n      disableCompression: false,\n      forceCompressionOnQuota: true,\n    },\n  );\n\n  // Persist to new storage system (async, fire-and-forget)\n  storageRepo.setItem(FULL_BACKUP_HISTORY_STORAGE_KEY, safeEntries).catch(err => {\n    console.warn('[storage.js] Failed to persist backup history to new storage:', err);\n  });\n}\n\nvar recordFullBackupHistoryEntry = entry => {\n  const normalized = normalizeFullBackupHistoryEntry(entry);\n  if (!normalized) {\n    return loadFullBackupHistory();\n  }\n  const history = loadFullBackupHistory();\n  history.push(normalized);\n  const trimmed = history.slice(-MAX_FULL_BACKUP_HISTORY_ENTRIES);\n  saveFullBackupHistory(trimmed);\n  return trimmed;\n};\n\nfunction normalizeImportedFullBackupHistory(value, visited, depth = 0) {\n  if (value === null || value === undefined) {\n    return [];\n  }\n\n  if (depth > 50) {\n    return [];\n  }\n\n  if (Array.isArray(value)) {\n    const results = [];\n    const count = value.length;\n    const seen = visited || new WeakSet();\n    if (seen.has(value)) {\n      return [];\n    }\n    seen.add(value);\n    for (let i = 0; i < count; i += 1) {\n      const item = value[i];\n      if (typeof item === 'object' && item !== null && seen.has(item)) {\n        continue;\n      }\n\n      if (Array.isArray(item)) {\n        const nested = normalizeImportedFullBackupHistory(item, seen, depth + 1);\n        if (nested && nested.length) {\n          for (let j = 0; j < nested.length; j += 1) {\n            results.push(nested[j]);\n          }\n        }\n      } else {\n        const entry = normalizeFullBackupHistoryEntry(item);\n        if (entry) {\n          results.push(entry);\n        }\n      }\n    }\n    return results;\n  }\n\n  const seen = visited || new WeakSet();\n  if (typeof value === 'object' && value !== null) {\n    if (seen.has(value)) {\n      return [];\n    }\n    seen.add(value);\n  }\n\n  if (isMapLike(value)) {\n    const converted = convertMapLikeToObject(value);\n    if (converted) {\n      return normalizeImportedFullBackupHistory(Object.values(converted), seen, depth + 1);\n    }\n    return [];\n  }\n\n  if (typeof value === 'string') {\n    const parsed = tryParseJSONLike(value);\n    if (parsed.success) {\n      return normalizeImportedFullBackupHistory(parsed.parsed, seen, depth + 1);\n    }\n    const entry = normalizeFullBackupHistoryEntry(value);\n    return entry ? [entry] : [];\n  }\n\n  // Arrays are handled at the top of the function\n  if (Array.isArray(value)) {\n    return [];\n  }\n\n  if (isPlainObject(value)) {\n    if (Array.isArray(value.history)) {\n      return normalizeImportedFullBackupHistory(value.history, seen, depth + 1);\n    }\n    if (Array.isArray(value.entries)) {\n      return normalizeImportedFullBackupHistory(value.entries, seen, depth + 1);\n    }\n    if (Array.isArray(value.list)) {\n      return normalizeImportedFullBackupHistory(value.list, seen, depth + 1);\n    }\n    const entry = normalizeFullBackupHistoryEntry(value);\n    if (entry) {\n      return [entry];\n    }\n    const nestedValues = Object.values(value);\n    if (nestedValues.length) {\n      return normalizeImportedFullBackupHistory(nestedValues, seen, depth + 1);\n    }\n  }\n\n  return [];\n}\n\n// --- Documentation Tracker Storage ---\nvar DOCUMENTATION_TRACKER_SCHEMA_VERSION = 1;\n\nfunction generateDocumentationTrackerId() {\n  var now = 0;\n  if (typeof Date !== 'undefined' && Date && typeof Date.now === 'function') {\n    now = Date.now();\n  } else {\n    try {\n      now = new Date().getTime();\n    } catch (timeError) {\n      now = Math.floor(Math.random() * 1e9);\n      void timeError;\n    }\n  }\n  var random = 0;\n  try {\n    random = Math.floor(Math.random() * 1e6);\n  } catch (randomError) {\n    random = now % 1e6;\n    void randomError;\n  }\n  return 'doc-tracker-' + now.toString(36) + '-' + random.toString(36);\n}\n\nfunction normalizeDocumentationTrackerStatusEntry(entry) {\n  var completed = false;\n  var updatedAt = null;\n\n  if (entry && typeof entry === 'object') {\n    if (typeof entry.completed === 'boolean') {\n      completed = entry.completed;\n    } else if (typeof entry.checked === 'boolean') {\n      completed = entry.checked;\n    } else if (typeof entry.value === 'boolean') {\n      completed = entry.value;\n    } else if (entry.done === true) {\n      completed = true;\n    }\n\n    var timestampCandidate = null;\n    if (typeof entry.updatedAt === 'string' && entry.updatedAt.trim()) {\n      timestampCandidate = entry.updatedAt.trim();\n    } else if (typeof entry.timestamp === 'string' && entry.timestamp.trim()) {\n      timestampCandidate = entry.timestamp.trim();\n    } else if (typeof entry.completedAt === 'string' && entry.completedAt.trim()) {\n      timestampCandidate = entry.completedAt.trim();\n    }\n    if (timestampCandidate) {\n      updatedAt = timestampCandidate;\n    }\n  } else if (typeof entry === 'boolean') {\n    completed = entry;\n  } else if (typeof entry === 'string') {\n    var normalized = entry.trim().toLowerCase();\n    if (normalized === 'true' || normalized === '1' || normalized === 'yes' || normalized === 'done') {\n      completed = true;\n    }\n  }\n\n  return {\n    completed: completed === true,\n    updatedAt: typeof updatedAt === 'string' ? updatedAt : null,\n  };\n}\n\nfunction normalizeDocumentationTrackerStatusMap(map) {\n  var normalized = {};\n\n  if (Array.isArray(map)) {\n    for (var index = 0; index < map.length; index += 1) {\n      var item = map[index];\n      if (item === null || item === undefined) {\n        continue;\n      }\n      if (typeof item === 'string' && item.trim()) {\n        normalized[item.trim()] = { completed: true, updatedAt: null };\n        continue;\n      }\n      if (typeof item === 'object') {\n        var key = null;\n        if (typeof item.id === 'string' && item.id.trim()) {\n          key = item.id.trim();\n        } else if (typeof item.key === 'string' && item.key.trim()) {\n          key = item.key.trim();\n        } else if (typeof item.name === 'string' && item.name.trim()) {\n          key = item.name.trim();\n        }\n        if (!key) {\n          continue;\n        }\n        normalized[key] = normalizeDocumentationTrackerStatusEntry(item);\n      }\n    }\n    return normalized;\n  }\n\n  if (map && (typeof map === 'object' || typeof map === 'function')) {\n    var keys = Object.keys(map);\n    for (var i = 0; i < keys.length; i += 1) {\n      var rawKey = keys[i];\n      if (rawKey === null || rawKey === undefined) {\n        continue;\n      }\n      var keyString = typeof rawKey === 'string' ? rawKey : String(rawKey);\n      if (!keyString) {\n        continue;\n      }\n      var trimmedKey = keyString.trim();\n      if (!trimmedKey) {\n        continue;\n      }\n      normalized[trimmedKey] = normalizeDocumentationTrackerStatusEntry(map[rawKey]);\n    }\n  }\n\n  return normalized;\n}\n\nfunction normalizeDocumentationTrackerStatuses(value) {\n  var normalized = {};\n  if (value && (typeof value === 'object' || typeof value === 'function')) {\n    var keys = Object.keys(value);\n    for (var i = 0; i < keys.length; i += 1) {\n      var key = keys[i];\n      if (!key) continue;\n      normalized[key] = normalizeDocumentationTrackerStatusMap(value[key]);\n    }\n  }\n  if (!normalized.locales) {\n    normalized.locales = {};\n  }\n  if (!normalized.helpTopics) {\n    normalized.helpTopics = {};\n  }\n  if (!normalized.printGuides) {\n    normalized.printGuides = {};\n  }\n  return normalized;\n}\n\nfunction normalizeDocumentationTrackerRelease(entry) {\n  if (!entry || (typeof entry !== 'object' && typeof entry !== 'function')) {\n    return null;\n  }\n\n  var id = null;\n  if (typeof entry.id === 'string' && entry.id.trim()) {\n    id = entry.id.trim();\n  }\n  if (!id && typeof entry.key === 'string' && entry.key.trim()) {\n    id = entry.key.trim();\n  }\n  if (!id) {\n    id = generateDocumentationTrackerId();\n  }\n\n  var name = '';\n  if (typeof entry.name === 'string') {\n    name = entry.name.trim();\n  } else if (typeof entry.title === 'string') {\n    name = entry.title.trim();\n  }\n\n  var targetDate = '';\n  if (typeof entry.targetDate === 'string' && entry.targetDate.trim()) {\n    targetDate = entry.targetDate.trim();\n  } else if (typeof entry.releaseDate === 'string' && entry.releaseDate.trim()) {\n    targetDate = entry.releaseDate.trim();\n  }\n\n  var createdAt = '';\n  if (typeof entry.createdAt === 'string' && entry.createdAt.trim()) {\n    createdAt = entry.createdAt.trim();\n  } else if (typeof entry.generatedAt === 'string' && entry.generatedAt.trim()) {\n    createdAt = entry.generatedAt.trim();\n  }\n  if (!createdAt) {\n    try {\n      createdAt = new Date().toISOString();\n    } catch (isoError) {\n      createdAt = '';\n      void isoError;\n    }\n  }\n\n  var updatedAt = null;\n  if (typeof entry.updatedAt === 'string' && entry.updatedAt.trim()) {\n    updatedAt = entry.updatedAt.trim();\n  } else if (typeof entry.modifiedAt === 'string' && entry.modifiedAt.trim()) {\n    updatedAt = entry.modifiedAt.trim();\n  } else if (typeof entry.lastUpdated === 'string' && entry.lastUpdated.trim()) {\n    updatedAt = entry.lastUpdated.trim();\n  } else if (typeof entry.timestamp === 'string' && entry.timestamp.trim()) {\n    updatedAt = entry.timestamp.trim();\n  }\n  if (!updatedAt) {\n    updatedAt = createdAt || null;\n  }\n\n  var notes = '';\n  if (typeof entry.notes === 'string') {\n    notes = entry.notes.trim();\n  } else if (typeof entry.summary === 'string') {\n    notes = entry.summary.trim();\n  }\n  if (notes && notes.length > 8000) {\n    notes = notes.slice(0, 8000);\n  }\n\n  var archived = false;\n  if (typeof entry.archived === 'boolean') {\n    archived = entry.archived;\n  } else if (typeof entry.status === 'string') {\n    var normalizedStatus = entry.status.trim().toLowerCase();\n    if (normalizedStatus === 'archived' || normalizedStatus === 'closed' || normalizedStatus === 'complete') {\n      archived = true;\n    }\n  }\n\n  var statuses = normalizeDocumentationTrackerStatuses(entry.statuses);\n\n  return {\n    id: id,\n    name: name,\n    targetDate: targetDate,\n    createdAt: typeof createdAt === 'string' ? createdAt : '',\n    updatedAt: typeof updatedAt === 'string' ? updatedAt : null,\n    statuses: statuses,\n    notes: notes,\n    archived: archived === true,\n  };\n}\n\nfunction normalizeDocumentationTrackerState(state) {\n  var normalized = {\n    version: DOCUMENTATION_TRACKER_SCHEMA_VERSION,\n    releases: [],\n  };\n\n  if (state === null || state === undefined) {\n    return normalized;\n  }\n\n  var rawState = state;\n  if (Array.isArray(rawState)) {\n    normalized.releases = rawState\n      .map(normalizeDocumentationTrackerRelease)\n      .filter(Boolean);\n    return normalized;\n  }\n\n  if (typeof rawState !== 'object' && typeof rawState !== 'function') {\n    return normalized;\n  }\n\n  if (typeof rawState.version === 'number' && Number.isFinite(rawState.version)) {\n    normalized.version = rawState.version;\n  }\n\n  var sourceList = null;\n  if (Array.isArray(rawState.releases)) {\n    sourceList = rawState.releases;\n  } else if (Array.isArray(rawState.entries)) {\n    sourceList = rawState.entries;\n  } else if (Array.isArray(rawState.logs)) {\n    sourceList = rawState.logs;\n  }\n\n  if (!sourceList && rawState && typeof rawState === 'object') {\n    var values = Object.values(rawState);\n    if (values.length && values.every(function (value) { return value && typeof value === 'object' && !Array.isArray(value); })) {\n      sourceList = values;\n    }\n  }\n\n  if (!sourceList || !Array.isArray(sourceList)) {\n    normalized.releases = [];\n  } else {\n    normalized.releases = sourceList\n      .map(normalizeDocumentationTrackerRelease)\n      .filter(Boolean);\n  }\n\n  return normalized;\n}\n\nfunction loadDocumentationTracker() {\n  applyLegacyStorageMigrations();\n  const safeStorage = getSafeLocalStorage();\n  const parsed = loadJSONFromStorage(\n    safeStorage,\n    DOCUMENTATION_TRACKER_STORAGE_KEY,\n    'Error loading documentation tracker from localStorage:',\n    null,\n    { validate: value => value === null || isPlainObject(value) || Array.isArray(value) },\n  );\n  if (!parsed) {\n    return {\n      version: DOCUMENTATION_TRACKER_SCHEMA_VERSION,\n      releases: [],\n    };\n  }\n  const normalized = normalizeDocumentationTrackerState(parsed);\n  if (!normalized || !Array.isArray(normalized.releases)) {\n    return {\n      version: DOCUMENTATION_TRACKER_SCHEMA_VERSION,\n      releases: [],\n    };\n  }\n  return normalized;\n}\n\nfunction saveDocumentationTracker(state) {\n  const safeStorage = getSafeLocalStorage();\n  if (state === null || state === undefined) {\n    deleteFromStorage(\n      safeStorage,\n      DOCUMENTATION_TRACKER_STORAGE_KEY,\n      'Error deleting documentation tracker from localStorage:',\n    );\n    return;\n  }\n\n  const normalized = normalizeDocumentationTrackerState(state);\n  if (!normalized.releases.length) {\n    deleteFromStorage(\n      safeStorage,\n      DOCUMENTATION_TRACKER_STORAGE_KEY,\n      'Error deleting documentation tracker from localStorage:',\n    );\n    return;\n  }\n\n  ensurePreWriteMigrationBackup(safeStorage, DOCUMENTATION_TRACKER_STORAGE_KEY);\n  saveJSONToStorage(\n    safeStorage,\n    DOCUMENTATION_TRACKER_STORAGE_KEY,\n    {\n      version: DOCUMENTATION_TRACKER_SCHEMA_VERSION,\n      releases: normalized.releases,\n    },\n    'Error saving documentation tracker to localStorage:',\n    { disableCompression: true },\n  );\n}\n\n// --- Automatic Gear Rules Storage ---\nfunction loadAutoGearRules() {\n  applyLegacyStorageMigrations();\n  const safeStorage = getSafeLocalStorage();\n  const parsed = loadJSONFromStorage(\n    safeStorage,\n    AUTO_GEAR_RULES_STORAGE_KEY,\n    \"Error loading automatic gear rules from localStorage:\",\n    [],\n    { validate: (value) => value === null || Array.isArray(value) },\n  );\n  const rules = Array.isArray(parsed) ? parsed : [];\n  const normalizedRules = Array.isArray(rules)\n    ? normalizeLegacyLongGopStructure(rules)\n    : [];\n  if (normalizedRules !== rules) {\n    saveAutoGearRules(normalizedRules, { skipNormalization: true });\n  }\n\n  if (Array.isArray(normalizedRules)) {\n    let defaultsApplied = false;\n    const withDefaults = normalizedRules.map(rule => {\n      if (rule && typeof rule === 'object' && typeof rule.enabled === 'undefined') {\n        defaultsApplied = true;\n        return { ...rule, enabled: true };\n      }\n      return rule;\n    });\n\n    if (defaultsApplied) {\n      return withDefaults;\n    }\n    return normalizedRules;\n  }\n\n  return [];\n}\n\nfunction saveAutoGearRules(rules, options = {}) {\n  const opts = options || {};\n  const { skipNormalization = false } = opts;\n  const safeRules = Array.isArray(rules) ? rules.slice() : [];\n  const normalizedRules = skipNormalization\n    ? safeRules\n    : (Array.isArray(safeRules) ? normalizeLegacyLongGopStructure(safeRules) : []);\n  const safeStorage = getSafeLocalStorage();\n  ensurePreWriteMigrationBackup(safeStorage, AUTO_GEAR_RULES_STORAGE_KEY);\n  saveJSONToStorage(\n    safeStorage,\n    AUTO_GEAR_RULES_STORAGE_KEY,\n    normalizedRules,\n    \"Error saving automatic gear rules to localStorage:\",\n    {\n      disableCompression: true,\n    },\n  );\n  return normalizedRules;\n}\n\nfunction loadAutoGearBackups() {\n  applyLegacyStorageMigrations();\n\n  if (Array.isArray(autoGearBackupsCache) && autoGearBackupsCache.length) {\n    const { normalized: normalizedCached, changed } = normalizeLegacyLongGopBackups(autoGearBackupsCache);\n    if (changed) {\n      saveAutoGearBackups(normalizedCached, { skipNormalization: true });\n    }\n    return normalizedCached;\n  }\n\n  // [Agent Migration] Read form Memory/IndexedDB first\n  // Note: Since this is a synchronous load for UI, and backups might be large,\n  // we rely on hydration if available, or force a sync read if possible/cached.\n  // For simplicity and safety in this transition, we will prioritize what's in memory/repo if hydrated.\n  // However, since StorageRepository is async, we can't block here easily without a pre-hydrated cache.\n  // Assuming 'hydrateProjectCache' or similar has run.\n  // BUT: Auto Gear Backups are NOT part of the critical hydration path in hydrateProjectCache currently.\n  // We should add a specific check or accept that this might return empty initially until async load completes?\n  // Actually, for now, let's keep the LocalStorage fallback as primary for *initial* load if not hydrated,\n  // BUT try to use the Repository if we can.\n  // A better approach for this legacy synchronous API is to rely on a module-level variable that gets hydrated.\n\n  // Checking if we have a global cache for this? No specific valid cache variable exposed yet for backups.\n  // We will assume that for V2, the async loaders in 'auto-gear/storage.js' should be used.\n  // For V1 legacy compatibility, we might need to stick to LocalStorage OR\n  // implement a synchronous cache if we want to move away from LS.\n\n  // DECISION: To ensure migration, we should look for a hydrated value. \n  // If not found, fall back to LS.\n  // Since we don't have a dedicated cache variable for this in storage.js yet (unlike presets),\n  // we will add a simple in-memory check if possible, or leave as is if V2 uses async.\n  // Re-reading 'storage.js' context: we added caches for presets but not backups.\n  // Backups are large. Storing them in LS is bad.\n  // Let's rely on the fact that we migrated 'save' to IDB.\n  // We need to implement a 'hydrateAutoGearBackups' or similar, but for this function:\n\n  const safeStorage = getSafeLocalStorage();\n  const parsed = loadJSONFromStorage(\n    safeStorage,\n    AUTO_GEAR_BACKUPS_STORAGE_KEY,\n    \"Error loading automatic gear rule backups from localStorage:\",\n    [],\n    { validate: (value) => value === null || Array.isArray(value) },\n  );\n\n  const backups = Array.isArray(parsed) ? parsed : [];\n  const { normalized: normalizedBackups, changed } = normalizeLegacyLongGopBackups(backups);\n  if (changed) {\n    saveAutoGearBackups(normalizedBackups, { skipNormalization: true });\n  }\n  autoGearBackupsCache = normalizedBackups;\n  return normalizedBackups;\n}\n\nfunction saveAutoGearBackups(backups, options = {}) {\n  const opts = options || {};\n  const { skipNormalization = false } = opts;\n  const safeBackups = Array.isArray(backups) ? backups.slice() : [];\n  const { normalized: normalizedBackups } = skipNormalization\n    ? { normalized: safeBackups, changed: false }\n    : normalizeLegacyLongGopBackups(safeBackups);\n  autoGearBackupsCache = normalizedBackups;\n  const safeStorage = getSafeLocalStorage();\n  ensurePreWriteMigrationBackup(safeStorage, AUTO_GEAR_BACKUPS_STORAGE_KEY);\n\n  let attemptedMigrationCleanup = false;\n  let attemptedCacheCleanup = false;\n\n  // [Agent Migration] Update In-Memory Cache and Persist to IndexedDB\n  if (typeof window !== 'undefined' && window.localStorage === safeStorage) { // Simple check if we are in a window context\n    // Note: Auto Gear Backups are large, so we might skip full in-memory caching if needed, \n    // but consistency suggests we should at least route writes properly.\n    // For now, we will piggyback on the existing pattern if a cache exists, \n    // or just ensure proper async persistence.\n\n    const isIndexedDBActive = typeof storageRepo !== 'undefined'\n      && storageRepo.driver\n      && storageRepo.driver.constructor.name === 'IndexedDBAdapter';\n\n    if (typeof storageRepo !== 'undefined') {\n      storageRepo.setItem(AUTO_GEAR_BACKUPS_STORAGE_KEY, normalizedBackups).catch(err => {\n        console.warn('[Storage] Failed to async persist Auto Gear Backups to IDB:', err);\n        if (isIndexedDBActive) {\n          try {\n            saveJSONToStorage(\n              safeStorage,\n              AUTO_GEAR_BACKUPS_STORAGE_KEY,\n              normalizedBackups,\n              \"Error saving automatic gear rule backups to localStorage:\",\n            );\n          } catch (fallbackError) {\n            console.warn('[Storage] Failed to persist Auto Gear Backups fallback to localStorage:', fallbackError);\n          }\n        }\n      });\n    }\n  }\n\n  // [Agent Migration] Conditional Skipping of Legacy Write\n  // If IndexedDB is active, we should skip writing to LocalStorage to save space.\n  const isIndexedDBActive = typeof storageRepo !== 'undefined' &&\n    storageRepo.driver &&\n    storageRepo.driver.constructor.name === 'IndexedDBAdapter';\n\n  if (isIndexedDBActive) {\n    // Skip legacy write to avoid quota issues\n    return;\n  }\n\n  saveJSONToStorage(\n    safeStorage,\n    AUTO_GEAR_BACKUPS_STORAGE_KEY,\n    normalizedBackups,\n    \"Error saving automatic gear rule backups to localStorage:\",\n    {\n      onQuotaExceeded: (error, context = {}) => {\n        const removal = removeOldestAutoGearBackupEntry(normalizedBackups);\n        if (removal) {\n          const label = removal.label;\n          if (label) {\n            console.warn(\n              `Removed automatic gear backup \"${label}\" to free up storage space before saving gear backups.`,\n            );\n          } else {\n            console.warn(\n              'Removed oldest automatic gear backup entry to free up storage space before saving gear backups.',\n            );\n          }\n          return true;\n        }\n\n        const storage = context && context.storage ? context.storage : safeStorage;\n\n        if (!attemptedMigrationCleanup) {\n          attemptedMigrationCleanup = true;\n          if (cleanupAutoGearBackupMigrationCopies(storage)) {\n            return true;\n          }\n        }\n\n        if (!attemptedCacheCleanup) {\n          attemptedCacheCleanup = true;\n          if (clearCachedPlannerDataForAutoGearBackups()) {\n            return true;\n          }\n        }\n\n        return false;\n      },\n    },\n  );\n  return normalizedBackups;\n}\n\nfunction loadAutoGearSeedFlag() {\n  applyLegacyStorageMigrations();\n  const safeStorage = getSafeLocalStorage();\n  return loadFlagFromStorage(\n    safeStorage,\n    AUTO_GEAR_SEEDED_STORAGE_KEY,\n    \"Error loading automatic gear seed flag from localStorage:\",\n  );\n}\n\nfunction saveAutoGearSeedFlag(flag) {\n  const safeStorage = getSafeLocalStorage();\n  saveFlagToStorage(\n    safeStorage,\n    AUTO_GEAR_SEEDED_STORAGE_KEY,\n    Boolean(flag),\n    \"Error saving automatic gear seed flag to localStorage:\",\n  );\n}\n\nfunction loadAutoGearPresets() {\n  applyLegacyStorageMigrations();\n  const safeStorage = getSafeLocalStorage();\n  const presets = loadJSONFromStorage(\n    safeStorage,\n    AUTO_GEAR_PRESETS_STORAGE_KEY,\n    \"Error loading automatic gear presets from localStorage:\",\n    [],\n    { validate: (value) => value === null || Array.isArray(value) },\n  );\n  const presetArray = Array.isArray(presets) ? presets : [];\n  const normalized = Array.isArray(presetArray)\n    ? normalizeLegacyLongGopStructure(presetArray)\n    : [];\n  if (normalized !== presetArray) {\n    saveAutoGearPresets(normalized, { skipNormalization: true });\n  }\n  return Array.isArray(normalized) ? normalized : [];\n}\n\n// [Agent Refactor] Memory Cache for Auto Gear\n\nlet autoGearMonitorDefaultsCache = null;\nlet autoGearActivePresetIdCache = null;\nlet autoGearAutoPresetIdCache = null;\nlet autoGearBackupsCache = null;\nlet autoGearBackupRetentionCache = null;\nlet autoGearBackupVisibilityCache = null;\nlet customFontsCache = null;\nlet customLogoCache = null;\nlet cameraColorsCache = null;\nlet printPreferencesCache = null;\nlet contactsCache = null;\nlet ownGearCache = null;\nlet userProfileCache = null;\nlet favoritesCache = null;\nlet temperatureUnitCache = null;\nlet focusScaleCache = null;\nlet mountVoltagesCache = null;\nlet fullBackupHistoryCache = null;\n\nfunction readActiveAutoGearPresetIds() {\n  const ids = new Set();\n  const pushId = (candidate) => {\n    if (typeof candidate === 'string') {\n      const trimmed = candidate.trim();\n      if (trimmed) {\n        ids.add(trimmed);\n      }\n    }\n  };\n\n  if (typeof loadAutoGearActivePresetId === 'function') {\n    try {\n      pushId(loadAutoGearActivePresetId());\n    } catch (error) {\n      console.warn('Unable to read automatic gear active preset id while evaluating compression policy.', error);\n    }\n  }\n\n  if (typeof loadAutoGearAutoPresetId === 'function') {\n    try {\n      pushId(loadAutoGearAutoPresetId());\n    } catch (error) {\n      console.warn('Unable to read automatic gear auto preset id while evaluating compression policy.', error);\n    }\n  }\n\n  return ids;\n}\n\nfunction saveAutoGearPresets(presets, options = {}) {\n  const opts = options || {};\n  const { skipNormalization = false, disableCompression: disableCompressionOverride } = opts;\n  const safePresets = Array.isArray(presets) ? presets.slice() : [];\n  const normalizedPresets = skipNormalization\n    ? safePresets\n    : (Array.isArray(safePresets) ? normalizeLegacyLongGopStructure(safePresets) : []);\n  const safeStorage = getSafeLocalStorage();\n  ensurePreWriteMigrationBackup(safeStorage, AUTO_GEAR_PRESETS_STORAGE_KEY);\n\n  let disableCompression = typeof disableCompressionOverride === 'boolean'\n    ? disableCompressionOverride\n    : false;\n\n  if (disableCompressionOverride === undefined) {\n    const activePresetIds = readActiveAutoGearPresetIds();\n    if (activePresetIds.size > 0) {\n      disableCompression = normalizedPresets.some(\n        (preset) => preset\n          && typeof preset === 'object'\n          && typeof preset.id === 'string'\n          && activePresetIds.has(preset.id),\n      );\n    }\n  }\n\n  // [Agent Refactor] Update Cache & Repo\n\n  if (storageRepo) {\n    storageRepo.setItem(AUTO_GEAR_PRESETS_STORAGE_KEY, normalizedPresets).catch(e => console.warn('Failed to save auto gear presets to repo', e));\n  }\n\n  const isIndexedDB = storageRepo && storageRepo.driver && storageRepo.driver.constructor && storageRepo.driver.constructor.name === 'IndexedDBAdapter';\n  if (!isIndexedDB) {\n    saveJSONToStorage(\n      safeStorage,\n      AUTO_GEAR_PRESETS_STORAGE_KEY,\n      normalizedPresets,\n      \"Error saving automatic gear presets to localStorage:\",\n      disableCompression ? { disableCompression: true } : undefined,\n    );\n  }\n  return normalizedPresets;\n}\n\nfunction loadAutoGearMonitorDefaults() {\n  // [Agent Refactor] Check Cache First\n  if (autoGearMonitorDefaultsCache) {\n    return autoGearMonitorDefaultsCache;\n  }\n\n  applyLegacyStorageMigrations();\n  const safeStorage = getSafeLocalStorage();\n  const defaults = loadJSONFromStorage(\n    safeStorage,\n    AUTO_GEAR_MONITOR_DEFAULTS_STORAGE_KEY,\n    \"Error loading automatic gear monitor defaults from localStorage:\",\n    {},\n    { validate: (value) => value === null || typeof value === 'object' },\n  );\n  const monitorDefaults = defaults && typeof defaults === 'object' ? defaults : {};\n  const normalizedDefaults = isPlainObject(monitorDefaults)\n    ? normalizeLegacyLongGopStructure(monitorDefaults)\n    : {};\n  if (normalizedDefaults !== monitorDefaults) {\n    saveAutoGearMonitorDefaults(normalizedDefaults, { skipNormalization: true });\n  }\n  return normalizedDefaults && typeof normalizedDefaults === 'object' ? normalizedDefaults : {};\n}\n\nfunction saveAutoGearMonitorDefaults(defaults, options = {}) {\n  const opts = options || {};\n  const { skipNormalization = false } = opts;\n  const safeDefaults = defaults && typeof defaults === 'object' ? { ...defaults } : {};\n  const normalizedDefaults = skipNormalization\n    ? safeDefaults\n    : (isPlainObject(safeDefaults) ? normalizeLegacyLongGopStructure(safeDefaults) : {});\n  const safeStorage = getSafeLocalStorage();\n  ensurePreWriteMigrationBackup(safeStorage, AUTO_GEAR_MONITOR_DEFAULTS_STORAGE_KEY);\n\n  // [Agent Refactor] Update Cache & Repo\n  autoGearMonitorDefaultsCache = normalizedDefaults;\n  if (storageRepo) {\n    storageRepo.setItem(AUTO_GEAR_MONITOR_DEFAULTS_STORAGE_KEY, normalizedDefaults).catch(e => console.warn('Failed to save monitor defaults to repo', e));\n  }\n\n  const isIndexedDB = storageRepo && storageRepo.driver && storageRepo.driver.constructor && storageRepo.driver.constructor.name === 'IndexedDBAdapter';\n  if (!isIndexedDB) {\n    saveJSONToStorage(\n      safeStorage,\n      AUTO_GEAR_MONITOR_DEFAULTS_STORAGE_KEY,\n      normalizedDefaults,\n      \"Error saving automatic gear monitor defaults to localStorage:\",\n    );\n  }\n  return normalizedDefaults;\n}\n\nfunction removeAutoGearPresetFromStorage(presetId, storage) {\n  if (!presetId) {\n    return;\n  }\n\n  const safeStorage = storage || getSafeLocalStorage();\n  if (!safeStorage) {\n    return;\n  }\n\n  let rawPresets;\n  try {\n    rawPresets = safeStorage.getItem(AUTO_GEAR_PRESETS_STORAGE_KEY);\n  } catch (error) {\n    console.error('Error loading automatic gear presets while removing autosaved preset from localStorage:', error);\n    downgradeSafeLocalStorageToMemory('read access', error, safeStorage);\n    alertStorageError();\n    return;\n  }\n\n  if (rawPresets === null || typeof rawPresets === 'undefined') {\n    return;\n  }\n\n  let parsedPresets;\n  let normalizedRawPresets = rawPresets;\n  if (typeof rawPresets === 'string' && rawPresets) {\n    normalizedRawPresets = maybeDecompressStoredString(rawPresets);\n  }\n  try {\n    parsedPresets = JSON.parse(normalizedRawPresets);\n  } catch (parseError) {\n    console.error('Error parsing automatic gear presets while removing autosaved preset from localStorage:', parseError);\n    return;\n  }\n\n  if (!Array.isArray(parsedPresets)) {\n    return;\n  }\n\n  const filteredPresets = parsedPresets.filter((preset) => {\n    if (!preset || typeof preset !== 'object') {\n      return true;\n    }\n    return preset.id !== presetId;\n  });\n\n  if (filteredPresets.length === parsedPresets.length) {\n    return;\n  }\n\n  // [Agent Refactor] Update Cache & Repo (Implicit via saveAutoGearPresets)\n  saveAutoGearPresets(filteredPresets, { skipNormalization: true });\n}\n\nfunction loadAutoGearActivePresetId() {\n  // [Agent Refactor] Check Cache First\n  if (autoGearActivePresetIdCache !== null) {\n    return typeof autoGearActivePresetIdCache === 'string' ? autoGearActivePresetIdCache : '';\n  }\n\n  applyLegacyStorageMigrations();\n  const safeStorage = getSafeLocalStorage();\n  if (!safeStorage || typeof safeStorage.getItem !== 'function') { // Added check\n    return '';\n  }\n  try {\n    const value = safeStorage.getItem(AUTO_GEAR_ACTIVE_PRESET_STORAGE_KEY);\n    return typeof value === 'string' ? value : '';\n  } catch (error) {\n    console.error('Error loading automatic gear active preset from localStorage:', error);\n    downgradeSafeLocalStorageToMemory('read access', error, safeStorage);\n    alertStorageError();\n    return '';\n  }\n}\n\nfunction saveAutoGearActivePresetId(presetId) {\n  // [Agent Refactor] Update Cache & Repo\n  autoGearActivePresetIdCache = presetId || '';\n  if (storageRepo) {\n    if (presetId) {\n      storageRepo.setItem(AUTO_GEAR_ACTIVE_PRESET_STORAGE_KEY, presetId).catch(e => console.warn('Failed to save active preset id', e));\n    } else {\n      storageRepo.removeItem(AUTO_GEAR_ACTIVE_PRESET_STORAGE_KEY).catch(e => console.warn('Failed to remove active preset id', e));\n    }\n  }\n\n  const isIndexedDB = storageRepo && storageRepo.driver && storageRepo.driver.constructor && storageRepo.driver.constructor.name === 'IndexedDBAdapter';\n  if (isIndexedDB) return;\n\n  const safeStorage = getSafeLocalStorage();\n  if (!safeStorage) {\n    return;\n  }\n  try {\n    if (presetId) {\n      safeStorage.setItem(AUTO_GEAR_ACTIVE_PRESET_STORAGE_KEY, presetId);\n    } else {\n      safeStorage.removeItem(AUTO_GEAR_ACTIVE_PRESET_STORAGE_KEY);\n    }\n  } catch (error) {\n    console.error('Error saving automatic gear active preset to localStorage:', error);\n    downgradeSafeLocalStorageToMemory('write access', error, safeStorage);\n    alertStorageError();\n  }\n}\n\nfunction loadAutoGearAutoPresetId() {\n  // [Agent Refactor] Check Cache First\n  if (autoGearAutoPresetIdCache !== null) {\n    return typeof autoGearAutoPresetIdCache === 'string' ? autoGearAutoPresetIdCache : '';\n  }\n\n  applyLegacyStorageMigrations();\n  const safeStorage = getSafeLocalStorage();\n  if (!safeStorage || typeof safeStorage.getItem !== 'function') { // Added check\n    return '';\n  }\n  try {\n    const value = safeStorage.getItem(AUTO_GEAR_AUTO_PRESET_STORAGE_KEY);\n    return typeof value === 'string' ? value : '';\n  } catch (error) {\n    console.error('Error loading automatic gear auto preset from localStorage:', error);\n    downgradeSafeLocalStorageToMemory('read access', error, safeStorage);\n    alertStorageError();\n    return '';\n  }\n}\n\nfunction saveAutoGearAutoPresetId(presetId) {\n  // [Agent Refactor] Update Cache & Repo\n  autoGearAutoPresetIdCache = presetId || '';\n  if (storageRepo) {\n    if (presetId) {\n      storageRepo.setItem(AUTO_GEAR_AUTO_PRESET_STORAGE_KEY, presetId).catch(e => console.warn('Failed to save auto preset id', e));\n    } else {\n      storageRepo.removeItem(AUTO_GEAR_AUTO_PRESET_STORAGE_KEY).catch(e => console.warn('Failed to remove auto preset id', e));\n    }\n  }\n\n  const isIndexedDB = storageRepo && storageRepo.driver && storageRepo.driver.constructor && storageRepo.driver.constructor.name === 'IndexedDBAdapter';\n  if (isIndexedDB) {\n    // If switching presets, we might need to remove old ones from legacy if we were dual-writing, but since we STOP writing to legacy, we don't need to complex manage legacy state here.\n    return;\n  }\n\n  const safeStorage = getSafeLocalStorage();\n  if (!safeStorage) {\n    return;\n  }\n  let previousPresetId = '';\n  // ... legacy logic continues ...\n  try {\n    const existingId = safeStorage.getItem(AUTO_GEAR_AUTO_PRESET_STORAGE_KEY);\n    if (typeof existingId === 'string' && existingId) {\n      previousPresetId = existingId;\n    }\n  } catch (inspectionError) {\n    console.error('Error inspecting automatic gear auto preset in localStorage:', inspectionError);\n    downgradeSafeLocalStorageToMemory('read access', inspectionError, safeStorage);\n  }\n  try {\n    if (presetId) {\n      safeStorage.setItem(AUTO_GEAR_AUTO_PRESET_STORAGE_KEY, presetId);\n      if (previousPresetId && previousPresetId !== presetId) {\n        removeAutoGearPresetFromStorage(previousPresetId, safeStorage);\n      }\n    } else {\n      safeStorage.removeItem(AUTO_GEAR_AUTO_PRESET_STORAGE_KEY);\n      if (previousPresetId) {\n        removeAutoGearPresetFromStorage(previousPresetId, safeStorage);\n      }\n    }\n  } catch (error) {\n    console.error('Error saving automatic gear auto preset to localStorage:', error);\n    downgradeSafeLocalStorageToMemory('write access', error, safeStorage);\n    alertStorageError();\n  }\n}\n\nfunction loadAutoGearBackupVisibility() {\n  // [Agent Refactor] Check Cache First\n  if (autoGearBackupVisibilityCache !== null) {\n    return !!autoGearBackupVisibilityCache;\n  }\n\n  applyLegacyStorageMigrations();\n  const safeStorage = getSafeLocalStorage();\n  return loadFlagFromStorage(\n    safeStorage,\n    AUTO_GEAR_BACKUP_VISIBILITY_STORAGE_KEY,\n    \"Error loading automatic gear backup visibility from localStorage:\",\n  );\n}\n\nfunction saveAutoGearBackupVisibility(flag) {\n  // [Agent Refactor] Update Cache & Repo\n  autoGearBackupVisibilityCache = !!flag;\n  if (storageRepo) {\n    storageRepo.setItem(AUTO_GEAR_BACKUP_VISIBILITY_STORAGE_KEY, !!flag).catch(e => console.warn('Failed to save visibility', e));\n  }\n\n  const isIndexedDB = storageRepo && storageRepo.driver && storageRepo.driver.constructor && storageRepo.driver.constructor.name === 'IndexedDBAdapter';\n  if (isIndexedDB) return;\n\n  const safeStorage = getSafeLocalStorage();\n  saveFlagToStorage(\n    safeStorage,\n    AUTO_GEAR_BACKUP_VISIBILITY_STORAGE_KEY,\n    Boolean(flag),\n    \"Error saving automatic gear backup visibility to localStorage:\",\n  );\n}\n\nfunction getAutoGearBackupRetentionUpperBound() {\n  const candidate = typeof AUTO_GEAR_BACKUP_RETENTION_MAX === 'number'\n    ? AUTO_GEAR_BACKUP_RETENTION_MAX\n    : MAX_AUTO_BACKUPS;\n  const numeric = Number(candidate);\n  if (!Number.isFinite(numeric)) {\n    return MAX_AUTO_BACKUPS;\n  }\n  const rounded = Math.round(numeric);\n  if (!Number.isFinite(rounded)) {\n    return MAX_AUTO_BACKUPS;\n  }\n  if (rounded < AUTO_GEAR_BACKUP_RETENTION_MIN) {\n    return AUTO_GEAR_BACKUP_RETENTION_MIN;\n  }\n  if (rounded > MAX_AUTO_BACKUPS) {\n    return MAX_AUTO_BACKUPS;\n  }\n  return rounded;\n}\n\nfunction clampAutoGearBackupRetention(value) {\n  const numeric = Number(value);\n  if (!Number.isFinite(numeric)) {\n    return getAutoGearBackupRetentionDefault();\n  }\n  const rounded = Math.round(numeric);\n  if (!Number.isFinite(rounded)) {\n    return getAutoGearBackupRetentionDefault();\n  }\n  if (rounded < AUTO_GEAR_BACKUP_RETENTION_MIN) {\n    return AUTO_GEAR_BACKUP_RETENTION_MIN;\n  }\n  const upperBound = getAutoGearBackupRetentionUpperBound();\n  if (rounded > upperBound) {\n    return upperBound;\n  }\n  return rounded;\n}\n\nfunction getAutoGearBackupRetentionDefault() {\n  const upperBound = getAutoGearBackupRetentionUpperBound();\n  if (GLOBAL_SCOPE && typeof GLOBAL_SCOPE.AUTO_GEAR_BACKUP_RETENTION_DEFAULT === 'number') {\n    const candidate = GLOBAL_SCOPE.AUTO_GEAR_BACKUP_RETENTION_DEFAULT;\n    if (Number.isFinite(candidate) && candidate >= AUTO_GEAR_BACKUP_RETENTION_MIN) {\n      const rounded = Math.round(candidate);\n      if (!Number.isFinite(rounded)) {\n        return upperBound;\n      }\n      if (rounded < AUTO_GEAR_BACKUP_RETENTION_MIN) {\n        return AUTO_GEAR_BACKUP_RETENTION_MIN;\n      }\n      if (rounded > upperBound) {\n        return upperBound;\n      }\n      return rounded;\n    }\n  }\n  const fallback = Math.round(AUTO_GEAR_BACKUP_RETENTION_DEFAULT_VALUE);\n  if (!Number.isFinite(fallback)) {\n    return AUTO_GEAR_BACKUP_RETENTION_MIN;\n  }\n  if (fallback > upperBound) {\n    return upperBound;\n  }\n  if (fallback < AUTO_GEAR_BACKUP_RETENTION_MIN) {\n    return AUTO_GEAR_BACKUP_RETENTION_MIN;\n  }\n  return fallback;\n}\n\nfunction normalizeAutoGearBackupRetentionValue(value, fallback = getAutoGearBackupRetentionDefault()) {\n  if (value === null || value === undefined) {\n    return fallback;\n  }\n  if (typeof value === 'number') {\n    return clampAutoGearBackupRetention(value);\n  }\n  if (typeof value === 'string') {\n    const trimmed = value.trim();\n    if (!trimmed) {\n      return fallback;\n    }\n    const parsed = Number(trimmed);\n    if (Number.isFinite(parsed)) {\n      return clampAutoGearBackupRetention(parsed);\n    }\n    const maybeJson = tryParseJSONLike(trimmed);\n    if (maybeJson && maybeJson.success) {\n      return normalizeAutoGearBackupRetentionValue(maybeJson.parsed, fallback);\n    }\n    return fallback;\n  }\n  if (Array.isArray(value)) {\n    for (let index = 0; index < value.length; index += 1) {\n      const candidate = normalizeAutoGearBackupRetentionValue(value[index], null);\n      if (typeof candidate === 'number' && Number.isFinite(candidate)) {\n        return clampAutoGearBackupRetention(candidate);\n      }\n    }\n    return fallback;\n  }\n  if (isPlainObject(value)) {\n    const candidateKeys = ['value', 'retention', 'limit', 'count'];\n    for (let i = 0; i < candidateKeys.length; i += 1) {\n      const key = candidateKeys[i];\n      if (!Object.prototype.hasOwnProperty.call(value, key)) {\n        continue;\n      }\n      const candidate = normalizeAutoGearBackupRetentionValue(value[key], null);\n      if (typeof candidate === 'number' && Number.isFinite(candidate)) {\n        return clampAutoGearBackupRetention(candidate);\n      }\n    }\n    return fallback;\n  }\n  return fallback;\n}\n\nfunction loadAutoGearBackupRetention() {\n  // [Agent Refactor] Check Cache First\n  if (autoGearBackupRetentionCache !== null) {\n    return autoGearBackupRetentionCache;\n  }\n\n  applyLegacyStorageMigrations();\n  const safeStorage = getSafeLocalStorage();\n  const retention = loadJSONFromStorage(\n    safeStorage,\n    AUTO_GEAR_BACKUP_RETENTION_STORAGE_KEY,\n    \"Error loading automatic gear backup retention from localStorage:\",\n    getAutoGearBackupRetentionDefault(),\n    {\n      validate: (value) =>\n        value === null\n        || typeof value === 'number'\n        || typeof value === 'string'\n        || Array.isArray(value)\n        || isPlainObject(value),\n    },\n  );\n  return normalizeAutoGearBackupRetentionValue(retention);\n}\n\nfunction saveAutoGearBackupRetention(retention) {\n  if (\n    retention === null\n    || retention === undefined\n    || typeof retention === 'function'\n    || (\n      typeof retention === 'object'\n      && !Array.isArray(retention)\n      && !isPlainObject(retention)\n    )\n  ) {\n    return;\n  }\n  const safeStorage = getSafeLocalStorage();\n  const normalized = normalizeAutoGearBackupRetentionValue(retention);\n\n  // [Agent Refactor] Update Cache & Repo\n  autoGearBackupRetentionCache = normalized;\n  if (storageRepo) {\n    storageRepo.setItem(AUTO_GEAR_BACKUP_RETENTION_STORAGE_KEY, normalized).catch(e => console.warn('Failed to save backup retention', e));\n  }\n\n  const isIndexedDB = storageRepo && storageRepo.driver && storageRepo.driver.constructor && storageRepo.driver.constructor.name === 'IndexedDBAdapter';\n  if (isIndexedDB) return;\n\n  ensurePreWriteMigrationBackup(safeStorage, AUTO_GEAR_BACKUP_RETENTION_STORAGE_KEY);\n  saveJSONToStorage(\n    safeStorage,\n    AUTO_GEAR_BACKUP_RETENTION_STORAGE_KEY,\n    normalized,\n    \"Error saving automatic gear backup retention to localStorage:\",\n  );\n}\n\n// --- Clear All Stored Data ---\nasync function clearAllData() {\n  try {\n    if (typeof globalThis !== 'undefined') globalThis.__cameraPowerPlannerFactoryResetting = true;\n    if (typeof global !== 'undefined') global.__cameraPowerPlannerFactoryResetting = true;\n    if (typeof window !== 'undefined') window.__cameraPowerPlannerFactoryResetting = true;\n    if (GLOBAL_SCOPE) {\n      GLOBAL_SCOPE.__cameraPowerPlannerFactoryResetting = true;\n      GLOBAL_SCOPE.__cineMonolithicProjectCleanupDone = false;\n    }\n    if (typeof sessionStorage !== 'undefined') sessionStorage.setItem(FACTORY_RESET_LOCK_KEY, 'true');\n    if (typeof localStorage !== 'undefined') localStorage.setItem(FACTORY_RESET_LOCK_KEY, 'true');\n  } catch (e) {\n    void e;\n  }\n\n  if (lifecycleChannel) {\n    try {\n      lifecycleChannel.postMessage('factory-reset');\n    } catch (e) {\n      void e;\n    }\n  }\n\n  const msg = \"Error clearing storage:\";\n  // Use the shared project deletion helper so all in-memory project caches and\n  // activity trackers, including auto backup metadata, are cleared alongside\n  // the stored data. Without this the factory reset could leave auto backup\n  // entries available until the next reload because the cache still referenced\n  // them.\n  try {\n    deleteProject();\n  } catch (error) {\n    console.warn('Unable to clear stored projects during factory reset', error);\n  }\n\n  // Explicitly invalidate caches regardless of deleteProject outcome\n  invalidateProjectReadCache();\n  if (AUTO_BACKUP_COMPRESSION_CACHE && typeof AUTO_BACKUP_COMPRESSION_CACHE.clear === 'function') {\n    AUTO_BACKUP_COMPRESSION_CACHE.clear();\n  }\n  if (Array.isArray(AUTO_BACKUP_COMPRESSION_CACHE_KEYS)) {\n    AUTO_BACKUP_COMPRESSION_CACHE_KEYS.length = 0;\n  }\n\n  // Attempt to clear all IndexedDB databases.\n  // We attempt to list databases if the browser supports it, otherwise we hit known ones.\n  try {\n    let clearVaultFn = null;\n    if (GLOBAL_SCOPE && typeof GLOBAL_SCOPE.clearBackupVault === 'function') {\n      clearVaultFn = GLOBAL_SCOPE.clearBackupVault;\n    } else if (typeof window !== 'undefined' && typeof window.clearBackupVault === 'function') {\n      clearVaultFn = window.clearBackupVault;\n    } else if (GLOBAL_SCOPE && GLOBAL_SCOPE.cineFeatureBackup && typeof GLOBAL_SCOPE.cineFeatureBackup.clearBackupVault === 'function') {\n      clearVaultFn = GLOBAL_SCOPE.cineFeatureBackup.clearBackupVault;\n    }\n\n    if (clearVaultFn) {\n      await clearVaultFn();\n    }\n\n    if (typeof indexedDB !== 'undefined') {\n      const vaultDbNames = ['cinePowerPlannerBackupVault', 'cinePowerPlanner', 'cameraPowerPlanner'];\n\n      // Try to get all database names if supported (Chrome, Edge, Firefox 125+, Safari 14+)\n      if (typeof indexedDB.databases === 'function') {\n        try {\n          const dbs = await indexedDB.databases();\n          dbs.forEach(db => {\n            if (db.name && !vaultDbNames.includes(db.name)) {\n              vaultDbNames.push(db.name);\n            }\n          });\n        } catch (listError) {\n          console.warn('Failed to list IndexedDB databases during factory reset', listError);\n        }\n      }\n\n      await Promise.all(vaultDbNames.map(dbName => {\n        return new Promise((resolve) => {\n          try {\n            const request = indexedDB.deleteDatabase(dbName);\n            request.addEventListener('success', () => resolve());\n            request.addEventListener('error', () => {\n              console.warn(`Failed to delete IndexedDB database \"${dbName}\" during factory reset`, request.error);\n              resolve();\n            });\n            request.addEventListener('blocked', () => {\n              console.warn(`Deletion of IndexedDB database \"${dbName}\" blocked during factory reset`);\n              resolve();\n            });\n          } catch (deleteError) {\n            console.warn(`Error initiating deletion of IndexedDB database \"${dbName}\"`, deleteError);\n            resolve();\n          }\n        });\n      }));\n    }\n  } catch (vaultError) {\n    console.warn('Failed to clear backup vault during factory reset', vaultError);\n  }\n\n  const safeStorage = getSafeLocalStorage();\n\n  const clearStorageFully = (storage, storageName) => {\n    if (!storage) {\n      return;\n    }\n\n    // First attempt a total clear\n    if (typeof storage.clear === 'function') {\n      try {\n        storage.clear();\n      } catch (clearError) {\n        console.warn(`Failed to clear ${storageName} using clear(), falling back to manual removal.`, clearError);\n      }\n    }\n\n    // Then iterate and remove EVERYTHING just to be absolutely sure,\n    // as clear() might be intercepted or only partially effective in some environments.\n    try {\n      const keysToRemove = [];\n\n      // Strategy A: Iterate by index\n      try {\n        const length = storage.length;\n        for (let i = 0; i < length; i++) {\n          const key = storage.key(i);\n          if (key) {\n            keysToRemove.push(key);\n          }\n        }\n      } catch (indexError) {\n        console.warn(`Failed to iterate ${storageName} by index`, indexError);\n      }\n\n      // Strategy B: Object.keys fallback (works for standard localStorage in many runtimes)\n      try {\n        const objectKeys = Object.keys(storage);\n        if (Array.isArray(objectKeys)) {\n          objectKeys.forEach(k => {\n            if (k && !keysToRemove.includes(k)) {\n              keysToRemove.push(k);\n            }\n          });\n        }\n      } catch (objKeysError) {\n        // Ignore, Object.keys might not work on all storage implementations\n        void objKeysError;\n      }\n\n      keysToRemove.forEach((key) => {\n        if (key === FACTORY_RESET_LOCK_KEY) return;\n        try {\n          storage.removeItem(key);\n        } catch (removeError) {\n          console.warn(`Failed to remove key ${key} from ${storageName}`, removeError);\n        }\n      });\n    } catch (iterateError) {\n      console.warn(`Failed to iterate ${storageName} for strict cleanup`, iterateError);\n    }\n  };\n\n  clearStorageFully(safeStorage, 'safeLocalStorage');\n\n  if (typeof localStorage !== 'undefined' && localStorage !== safeStorage) {\n    clearStorageFully(localStorage, 'localStorage');\n  }\n\n  if (typeof sessionStorage !== 'undefined') {\n    clearStorageFully(sessionStorage, 'sessionStorage');\n  }\n\n  const sessionCacheKeys = [\n    'settingsActiveTab',\n    typeof GLOBAL_SCOPE !== 'undefined'\n      && GLOBAL_SCOPE\n      && typeof GLOBAL_SCOPE.INSTALL_BANNER_DISMISSED_KEY === 'string'\n      ? GLOBAL_SCOPE.INSTALL_BANNER_DISMISSED_KEY\n      : 'cine_install_banner_dismissed',\n  ];\n\n  const ensureStoragePruned = (storage, storageName) => {\n    if (!storage || typeof storage.length !== 'number' || typeof storage.key !== 'function') {\n      return;\n    }\n    const keysToRemove = [];\n    const length = storage.length;\n    for (let i = 0; i < length; i++) {\n      const key = storage.key(i);\n      if (!key) {\n        continue;\n      }\n      // Remove all app-related keys and specific session cache keys\n      if (\n        key.startsWith('cameraPowerPlanner_') ||\n        key.startsWith('cine_') ||\n        key.startsWith('cinePowerPlanner_') ||\n        key.startsWith('cinePowerPlanner') ||\n        key.startsWith('cineRental') ||\n        key.startsWith('__cine') ||\n        key.startsWith('cine_') || // Includes FACTORY_RESET_LOCK_KEY, handled via explicit check\n        sessionCacheKeys.includes(key)\n      ) {\n        if (key !== FACTORY_RESET_LOCK_KEY) {\n          keysToRemove.push(key);\n        }\n      }\n    }\n\n    keysToRemove.forEach((key) => {\n      try {\n        storage.removeItem(key);\n      } catch (removeError) {\n        console.warn(`Failed to remove key ${key} from ${storageName}`, removeError);\n      }\n    });\n  };\n\n  // Pruning is redundant but provides a second pass if clearAll fails\n  ensureStoragePruned(safeStorage, 'safeLocalStorage');\n  if (typeof localStorage !== 'undefined' && localStorage !== safeStorage) {\n    ensureStoragePruned(localStorage, 'localStorage');\n  }\n  if (typeof sessionStorage !== 'undefined') {\n    ensureStoragePruned(sessionStorage, 'sessionStorage');\n  }\n\n  // Explicitly clear known keys and prefixes using the helper to ensure logging and safety\n  if (typeof clearUiCacheStorageEntries === 'function') {\n    try {\n      clearUiCacheStorageEntries();\n    } catch (e) {\n      void e;\n    }\n  }\n\n  const explicitKeys = [\n    'cineBackupVaultFallbackRecords',\n    DEVICE_STORAGE_KEY,\n    SETUP_STORAGE_KEY,\n    FEEDBACK_STORAGE_KEY,\n    PROJECT_STORAGE_KEY,\n    PROJECT_STORAGE_REV_KEY,\n    'cameraPowerPlanner_projects',\n    'cameraPowerPlanner_project_shards',\n    FAVORITES_STORAGE_KEY,\n    CONTACTS_STORAGE_KEY,\n    AUTO_GEAR_RULES_STORAGE_KEY,\n    AUTO_GEAR_BACKUPS_STORAGE_KEY,\n    AUTO_GEAR_SEEDED_STORAGE_KEY,\n    AUTO_GEAR_PRESETS_STORAGE_KEY,\n    AUTO_GEAR_ACTIVE_PRESET_STORAGE_KEY,\n    AUTO_GEAR_AUTO_PRESET_STORAGE_KEY,\n    AUTO_GEAR_BACKUP_VISIBILITY_STORAGE_KEY,\n    AUTO_GEAR_BACKUP_RETENTION_STORAGE_KEY,\n    AUTO_GEAR_MONITOR_DEFAULTS_STORAGE_KEY,\n    getCustomFontStorageKeyName(),\n    CUSTOM_LOGO_STORAGE_KEY,\n    DEVICE_SCHEMA_CACHE_KEY,\n    LEGACY_SCHEMA_CACHE_KEY,\n    OWN_GEAR_STORAGE_KEY,\n    USER_PROFILE_STORAGE_KEY,\n    DOCUMENTATION_TRACKER_STORAGE_KEY,\n    FULL_BACKUP_HISTORY_STORAGE_KEY,\n    STORAGE_COMPRESSION_FLAG_KEY,\n    STORAGE_TEST_KEY,\n    SESSION_STATE_KEY,\n    'cameraPowerPlanner_lastProject',\n    'cameraPowerPlanner_onboardingComplete',\n    'cameraPowerPlanner_tourShown',\n    'cameraPowerPlanner_v1_migration',\n    'cameraPowerPlanner_v2_migration',\n    'cameraPowerPlanner_sharded',\n    'cameraPowerPlanner_forceLegacyBundle',\n    'cameraPowerPlanner_forceLegacyBundleRetry',\n    typeof GLOBAL_SCOPE !== 'undefined' && GLOBAL_SCOPE.TEMPERATURE_UNIT_STORAGE_KEY,\n    typeof GLOBAL_SCOPE !== 'undefined' && GLOBAL_SCOPE.FOCUS_SCALE_STORAGE_KEY,\n    typeof GLOBAL_SCOPE !== 'undefined' && GLOBAL_SCOPE.INSTALL_BANNER_DISMISSED_KEY,\n    'cine_install_banner_dismissed',\n    // Explicitly target backup keys that might be missed by dynamic resolution\n    'cameraPowerPlanner_project__backup',\n    'cameraPowerPlanner_project__legacyMigrationBackup',\n    'cameraPowerPlanner_setups__backup',\n    'cameraPowerPlanner_setups__legacyMigrationBackup'\n  ];\n\n  explicitKeys.forEach(k => {\n    if (k) {\n      deleteFromStorage(safeStorage, k, msg);\n      // Also explicitly delete potential backup variants\n      if (typeof safeStorage.removeItem === 'function') {\n        safeStorage.removeItem(`${k}${STORAGE_BACKUP_SUFFIX}`);\n        safeStorage.removeItem(`${k}${STORAGE_MIGRATION_BACKUP_SUFFIX}`);\n      }\n    }\n  });\n\n  if (typeof sessionStorage !== 'undefined') {\n    deleteFromStorage(sessionStorage, SESSION_STATE_KEY, msg);\n    deleteFromStorage(sessionStorage, '__cineLoggingHistory', msg);\n    deleteFromStorage(sessionStorage, '__cineLoggingConfig', msg);\n    // Nuke everything in session storage too\n    try {\n      // Preserve lock if present\n      const lock = sessionStorage.getItem(FACTORY_RESET_LOCK_KEY);\n      sessionStorage.clear();\n      if (lock) sessionStorage.setItem(FACTORY_RESET_LOCK_KEY, lock);\n    } catch (e) { void e; }\n  }\n\n  // Clear Service Worker Caches\n  if (typeof caches !== 'undefined' && typeof caches.keys === 'function') {\n    try {\n      const cacheKeys = await caches.keys();\n      await Promise.all(\n        cacheKeys.map(function (key) {\n          return caches.delete(key);\n        })\n      );\n      if (typeof console !== 'undefined' && typeof console.log === 'function') {\n        console.log('Storage reset: Service Worker caches cleared.');\n      }\n    } catch (cacheError) {\n      if (typeof console !== 'undefined' && typeof console.warn === 'function') {\n        console.warn('Storage reset: Failed to clear Service Worker caches.', cacheError);\n      }\n    }\n  }\n\n  const preferenceKeys = [\n    'darkMode',\n    'pinkMode',\n    'highContrast',\n    'reduceMotion',\n    'relaxedSpacing',\n    'showAutoBackups',\n    'accentColor',\n    'fontSize',\n    'fontFamily',\n    'language',\n    'iosPwaHelpShown',\n    CAMERA_COLOR_STORAGE_KEY,\n    PRINT_PREFERENCES_STORAGE_KEY,\n  ];\n  preferenceKeys.forEach((key) => {\n    deleteFromStorage(safeStorage, key, msg, { disableBackup: true });\n    if (typeof safeStorage.removeItem === 'function') {\n      safeStorage.removeItem(`${key}${STORAGE_BACKUP_SUFFIX}`);\n    }\n  });\n\n  const onboardingStorageKeys = [\n    'cameraPowerPlanner_onboardingTutorial',\n    'cinePowerPlanner_onboardingTutorial',\n    'cameraPowerPlanner_onboardingComplete',\n    'cameraPowerPlanner_tourShown'\n  ];\n\n  const clearOnboardingTutorialState = (storage) => {\n    if (!storage) {\n      return;\n    }\n    for (let index = 0; index < onboardingStorageKeys.length; index += 1) {\n      const key = onboardingStorageKeys[index];\n      deleteFromStorage(storage, key, msg);\n      if (typeof storage.removeItem === 'function') {\n        storage.removeItem(`${key}${STORAGE_BACKUP_SUFFIX}`);\n      }\n    }\n  };\n\n  const storageCandidates = collectUniqueStorages([\n    safeStorage,\n    getSafeLocalStorage(),\n    getWindowStorage('localStorage'),\n    typeof localStorage !== 'undefined' ? localStorage : null,\n  ]);\n\n  for (let index = 0; index < storageCandidates.length; index += 1) {\n    clearOnboardingTutorialState(storageCandidates[index]);\n  }\n\n  const sessionCandidates = collectUniqueStorages([\n    typeof sessionStorage !== 'undefined' ? sessionStorage : null,\n    getWindowStorage('sessionStorage'),\n  ]);\n\n  for (let index = 0; index < sessionCandidates.length; index += 1) {\n    clearOnboardingTutorialState(sessionCandidates[index]);\n  }\n\n  try {\n    const logging = GLOBAL_SCOPE && GLOBAL_SCOPE.cineLogging ? GLOBAL_SCOPE.cineLogging : null;\n    if (logging && typeof logging.clearHistory === 'function') {\n      logging.clearHistory({ persist: false });\n    }\n  } catch (loggingError) {\n    console.warn('Unable to clear logging history during factory reset', loggingError);\n  }\n\n  // Explicitly wipe window.name to reset onboarding tour skip flags and other\n  // session-specific transient state that might persist across reloads.\n  try {\n    if (GLOBAL_SCOPE && typeof GLOBAL_SCOPE.name === 'string') {\n      GLOBAL_SCOPE.name = '';\n    }\n    if (typeof window !== 'undefined' && typeof window.name === 'string') {\n      window.name = '';\n    }\n  } catch (windowNameError) {\n    console.warn('Unable to reset window.name during factory reset', windowNameError);\n  }\n\n  // Unregister Service Workers and clear Cache API for a total factory state.\n  try {\n    if (typeof navigator !== 'undefined' && navigator.serviceWorker) {\n      const registrations = await navigator.serviceWorker.getRegistrations();\n      for (const registration of registrations) {\n        await registration.unregister();\n      }\n    }\n  } catch (swError) {\n    console.warn('Failed to unregister service workers', swError);\n  }\n\n  // We intentionally DO NOT reset the factory reset flag here.\n  // The page is about to reload, and we want to ensure that NO subsequent\n  // saves (triggered by UI resets, unload handlers, etc.) can occur\n  // between now and the reload. The flag will naturally be false on the\n  // next page load.\n  if (typeof console !== 'undefined' && typeof console.log === 'function') {\n    console.log('Factory reset cleanup complete. Waiting for reload.');\n  }\n}\n\n// --- Export/Import All Planner Data ---\nfunction readLocalStorageValue(key) {\n  // [Agent Refactor] Check Memory Caches First\n  if (key === CUSTOM_FONT_STORAGE_KEY_DEFAULT && customFontsCache) return customFontsCache;\n  if (key === CUSTOM_LOGO_STORAGE_KEY && customLogoCache) return customLogoCache;\n  if (key === CAMERA_COLOR_STORAGE_KEY && cameraColorsCache) return cameraColorsCache;\n  if (key === PRINT_PREFERENCES_STORAGE_KEY && printPreferencesCache) return printPreferencesCache;\n  if (key === CONTACTS_STORAGE_KEY && contactsCache) return contactsCache;\n  if (key === OWN_GEAR_STORAGE_KEY && ownGearCache) return ownGearCache;\n  if (key === USER_PROFILE_STORAGE_KEY && userProfileCache) return userProfileCache;\n\n  if (key === FAVORITES_STORAGE_KEY && favoritesCache) return favoritesCache;\n  if (key === TEMPERATURE_UNIT_STORAGE_KEY_NAME && temperatureUnitCache) return temperatureUnitCache;\n  if (key === FOCUS_SCALE_STORAGE_KEY_NAME && focusScaleCache) return focusScaleCache;\n  if (key === getMountVoltageStorageKeyName() && mountVoltagesCache) return mountVoltagesCache;\n\n  const storage = getSafeLocalStorage();\n  if (!storage || typeof storage.getItem !== 'function') return null;\n  const variants = getStorageKeyVariants(key);\n  for (let i = 0; i < variants.length; i += 1) {\n    const candidateKey = variants[i];\n    try {\n      const value = storage.getItem(candidateKey);\n      if (value === null || value === undefined) {\n        if (RAW_STORAGE_BACKUP_KEYS.has(candidateKey)) {\n          try {\n            const backupValue = storage.getItem(`${candidateKey}${STORAGE_BACKUP_SUFFIX}`);\n            if (backupValue !== null && backupValue !== undefined) {\n              const decodedBackup = decodeStoredValue(backupValue);\n              return typeof decodedBackup === 'string' ? decodedBackup : String(backupValue);\n            }\n          } catch (backupError) {\n            console.warn('Unable to read backup key for export', candidateKey, backupError);\n            downgradeSafeLocalStorageToMemory('read access', backupError, storage);\n          }\n        }\n      } else {\n        const decoded = decodeStoredValue(value);\n        return typeof decoded === 'string' ? decoded : String(value);\n      }\n    } catch (error) {\n      console.warn('Unable to read storage key for backup', candidateKey, error);\n      downgradeSafeLocalStorageToMemory('read access', error, storage);\n    }\n  }\n  return null;\n}\n\nfunction parseStoredBoolean(value) {\n  if (value === null || value === undefined) {\n    return null;\n  }\n\n  if (typeof value === 'boolean') {\n    return value;\n  }\n\n  if (typeof value === 'number') {\n    if (Number.isNaN(value)) {\n      return null;\n    }\n    return value !== 0;\n  }\n\n  const normalized = String(value).trim().toLowerCase();\n  if (!normalized) {\n    return null;\n  }\n\n  if (normalized === 'true'\n    || normalized === '1'\n    || normalized === 'yes'\n    || normalized === 'on') {\n    return true;\n  }\n\n  if (normalized === 'false'\n    || normalized === '0'\n    || normalized === 'no'\n    || normalized === 'off') {\n    return false;\n  }\n\n  return null;\n}\n\nfunction interpretPrintPreferencesValue(rawValue) {\n  if (rawValue === null || rawValue === undefined) {\n    return null;\n  }\n\n  let serialized = null;\n  let candidate = rawValue;\n\n  if (typeof rawValue === 'string') {\n    const trimmed = rawValue.trim();\n    if (!trimmed) {\n      return null;\n    }\n    serialized = trimmed;\n    try {\n      candidate = JSON.parse(trimmed);\n    } catch (parseError) {\n      void parseError;\n      return { normalized: null, serialized };\n    }\n  }\n\n  if (!candidate || typeof candidate !== 'object') {\n    if (serialized) {\n      return { normalized: null, serialized };\n    }\n    return null;\n  }\n\n  const hasSectionsContainer =\n    typeof candidate.sections === 'object' && candidate.sections !== null;\n  const sectionsSource = hasSectionsContainer ? candidate.sections : candidate;\n  const sections = {};\n\n  if (sectionsSource && typeof sectionsSource === 'object') {\n    const sectionKeys = Object.keys(sectionsSource);\n    for (let index = 0; index < sectionKeys.length; index += 1) {\n      const sectionKey = sectionKeys[index];\n      const sectionValue = sectionsSource[sectionKey];\n      if (typeof sectionValue === 'boolean') {\n        sections[sectionKey] = sectionValue;\n      }\n    }\n  }\n\n  let layout = null;\n  if (typeof candidate.layout === 'string') {\n    const trimmedLayout = candidate.layout.trim();\n    if (trimmedLayout) {\n      layout = trimmedLayout;\n    }\n  }\n\n  if (!layout) {\n    layout = hasSectionsContainer ? 'standard' : 'rental';\n  }\n\n  const normalized = {\n    sections,\n    layout,\n  };\n\n  if (hasSectionsContainer) {\n    const candidateKeys = Object.keys(candidate);\n    for (let index = 0; index < candidateKeys.length; index += 1) {\n      const key = candidateKeys[index];\n      if (key === 'sections' || key === 'layout') {\n        continue;\n      }\n      normalized[key] = storageJsonDeepClone(candidate[key]);\n    }\n  }\n\n  return {\n    normalized,\n    serialized,\n  };\n}\n\nfunction collectPreferenceSnapshot() {\n  const preferences = {};\n\n  const darkMode = parseStoredBoolean(readLocalStorageValue('darkMode'));\n  if (darkMode !== null) {\n    preferences.darkMode = darkMode;\n  }\n\n  const pinkMode = parseStoredBoolean(readLocalStorageValue('pinkMode'));\n  if (pinkMode !== null) {\n    preferences.pinkMode = pinkMode;\n  }\n\n  const highContrast = parseStoredBoolean(readLocalStorageValue('highContrast'));\n  if (highContrast !== null) {\n    preferences.highContrast = highContrast;\n  }\n\n  const reduceMotion = parseStoredBoolean(readLocalStorageValue('reduceMotion'));\n  if (reduceMotion !== null) {\n    preferences.reduceMotion = reduceMotion;\n  }\n\n  const relaxedSpacing = parseStoredBoolean(readLocalStorageValue('relaxedSpacing'));\n  if (relaxedSpacing !== null) {\n    preferences.relaxedSpacing = relaxedSpacing;\n  }\n\n  const showAutoBackups = parseStoredBoolean(readLocalStorageValue('showAutoBackups'));\n  if (showAutoBackups !== null) {\n    preferences.showAutoBackups = showAutoBackups;\n  }\n\n  const accentColor = readLocalStorageValue('accentColor');\n  if (accentColor) {\n    preferences.accentColor = accentColor;\n  }\n\n  const fontSize = readLocalStorageValue('fontSize');\n  if (fontSize) {\n    preferences.fontSize = fontSize;\n  }\n\n  const fontFamily = readLocalStorageValue('fontFamily');\n  if (fontFamily) {\n    preferences.fontFamily = fontFamily;\n  }\n\n  const language = readLocalStorageValue('language');\n  if (language) {\n    preferences.language = language;\n  }\n\n  const mountVoltageKey = getMountVoltageStorageKeyName();\n  const mountVoltages = readLocalStorageValue(mountVoltageKey);\n  if (mountVoltages) {\n    if (mountVoltages === '[object Object]' || String(mountVoltages).includes('[object Object]')) {\n      if (typeof DEFAULT_MOUNT_VOLTAGES !== 'undefined') {\n        preferences.mountVoltages = DEFAULT_MOUNT_VOLTAGES;\n      } else {\n        preferences.mountVoltages = {\n          'V-Mount': { high: 14.4, low: 12 },\n          'Gold-Mount': { high: 14.4, low: 12 },\n          'B-Mount': { high: 33.6, low: 21.6 }\n        };\n      }\n    } else {\n      try {\n        preferences.mountVoltages = JSON.parse(mountVoltages);\n      } catch (voltageParseError) {\n        console.warn('Failed to parse stored mount voltages for backup', voltageParseError);\n        // Fallback to defaults if parsing fails\n        if (typeof DEFAULT_MOUNT_VOLTAGES !== 'undefined') {\n          preferences.mountVoltages = DEFAULT_MOUNT_VOLTAGES;\n        } else {\n          preferences.mountVoltages = {\n            'V-Mount': { high: 14.4, low: 12 },\n            'Gold-Mount': { high: 14.4, low: 12 },\n            'B-Mount': { high: 33.6, low: 21.6 }\n          };\n        }\n      }\n    }\n  }\n\n  const iosPwaHelpShown = parseStoredBoolean(readLocalStorageValue('iosPwaHelpShown'));\n  if (iosPwaHelpShown !== null) {\n    preferences.iosPwaHelpShown = iosPwaHelpShown;\n  }\n\n  const temperatureUnit = readLocalStorageValue(TEMPERATURE_UNIT_STORAGE_KEY_NAME);\n  if (temperatureUnit) {\n    preferences.temperatureUnit = temperatureUnit;\n  }\n\n  const focusScale = readLocalStorageValue(FOCUS_SCALE_STORAGE_KEY_NAME);\n  if (focusScale) {\n    preferences.focusScale = focusScale;\n  }\n\n  const cameraColorsRaw = readLocalStorageValue(CAMERA_COLOR_STORAGE_KEY);\n  if (cameraColorsRaw) {\n    let parsedCameraColors = null;\n    if (typeof cameraColorsRaw === 'string') {\n      const trimmedCameraColors = cameraColorsRaw.trim();\n      if (trimmedCameraColors) {\n        try {\n          parsedCameraColors = JSON.parse(trimmedCameraColors);\n        } catch (cameraColorParseError) {\n          console.warn('Failed to parse stored camera color preferences for backup', cameraColorParseError);\n          parsedCameraColors = null;\n        }\n      }\n    }\n\n    if (parsedCameraColors && typeof parsedCameraColors === 'object') {\n      preferences.cameraColors = storageJsonDeepClone(parsedCameraColors);\n    } else if (typeof cameraColorsRaw === 'string' && cameraColorsRaw.trim()) {\n      preferences.cameraColors = cameraColorsRaw;\n    }\n  }\n\n  const printPreferencesRaw = readLocalStorageValue(PRINT_PREFERENCES_STORAGE_KEY);\n  if (printPreferencesRaw !== null && printPreferencesRaw !== undefined) {\n    const interpretedPrintPreferences = interpretPrintPreferencesValue(printPreferencesRaw);\n    if (interpretedPrintPreferences) {\n      if (interpretedPrintPreferences.normalized) {\n        preferences[PRINT_PREFERENCES_STORAGE_KEY] = storageJsonDeepClone(\n          interpretedPrintPreferences.normalized,\n        );\n      } else if (interpretedPrintPreferences.serialized) {\n        preferences[PRINT_PREFERENCES_STORAGE_KEY] = interpretedPrintPreferences.serialized;\n      }\n    }\n  }\n\n  return preferences;\n}\n\nfunction normalizeCustomFontEntries(entries) {\n  if (!Array.isArray(entries)) {\n    return [];\n  }\n  return entries\n    .map((entry) => ({\n      id: entry && typeof entry.id === 'string' ? entry.id : null,\n      name: entry && typeof entry.name === 'string' ? entry.name : '',\n      data: entry && typeof entry.data === 'string' ? entry.data : '',\n    }))\n    .filter((entry) => entry.id && entry.name && entry.data);\n}\n\nfunction readStoredCustomFonts() {\n  const raw = readLocalStorageValue(getCustomFontStorageKeyName());\n  if (!raw) {\n    return [];\n  }\n\n  try {\n    const parsed = JSON.parse(raw);\n    return normalizeCustomFontEntries(parsed);\n  } catch (error) {\n    console.warn('Failed to parse stored custom fonts for backup', error);\n    return [];\n  }\n}\n\nlet backupVaultRecordCache = [];\n\nfunction normalizeBackupVaultMetadata(metadata) {\n  if (!metadata || typeof metadata !== 'object') {\n    return null;\n  }\n  const normalized = {};\n  if (typeof metadata.source === 'string' && metadata.source) {\n    normalized.source = metadata.source;\n  }\n  if (typeof metadata.reason === 'string' && metadata.reason) {\n    normalized.reason = metadata.reason;\n  }\n  if (typeof metadata.permissionState === 'string' && metadata.permissionState) {\n    normalized.permissionState = metadata.permissionState;\n  }\n  return Object.keys(normalized).length ? normalized : null;\n}\n\nfunction normalizeBackupVaultRecord(record) {\n  if (!record || typeof record !== 'object') {\n    return null;\n  }\n  const id = typeof record.id === 'string' ? record.id.trim() : '';\n  if (!id) {\n    return null;\n  }\n  const fileName = typeof record.fileName === 'string' && record.fileName\n    ? record.fileName\n    : 'cine-power-planner-backup.json';\n  const createdAtMs = typeof record.createdAtMs === 'number' && Number.isFinite(record.createdAtMs)\n    ? record.createdAtMs\n    : null;\n  const createdAt = typeof record.createdAt === 'string' && record.createdAt\n    ? record.createdAt\n    : (createdAtMs !== null ? new Date(createdAtMs).toISOString() : null);\n  let normalizedCreatedAtMs = createdAtMs;\n  if (normalizedCreatedAtMs === null && createdAt) {\n    const parsedTime = Date.parse(createdAt);\n    if (Number.isFinite(parsedTime)) {\n      normalizedCreatedAtMs = parsedTime;\n    }\n  }\n  if (normalizedCreatedAtMs === null) {\n    normalizedCreatedAtMs = Date.now();\n  }\n  const metadata = normalizeBackupVaultMetadata(record.metadata);\n  return {\n    id,\n    fileName,\n    payload: record.payload,\n    createdAt: createdAt || new Date(normalizedCreatedAtMs).toISOString(),\n    createdAtMs: normalizedCreatedAtMs,\n    metadata: metadata || {},\n  };\n}\n\nfunction normalizeBackupVaultRecordList(records) {\n  if (!records) {\n    return [];\n  }\n  let parsed = records;\n  if (typeof records === 'string') {\n    const parsedResult = tryParseJSONLike(records);\n    if (parsedResult && parsedResult.success) {\n      parsed = parsedResult.parsed;\n    }\n  }\n  const list = Array.isArray(parsed) ? parsed : [];\n  const normalized = [];\n  list.forEach((entry) => {\n    const normalizedEntry = normalizeBackupVaultRecord(entry);\n    if (normalizedEntry) {\n      normalized.push(normalizedEntry);\n    }\n  });\n  return normalized;\n}\n\nfunction scoreBackupVaultRecord(record) {\n  if (!record) {\n    return 0;\n  }\n  let score = 0;\n  if (record.payload !== null && record.payload !== undefined) {\n    score += 3;\n  }\n  if (typeof record.fileName === 'string' && record.fileName) {\n    score += 1;\n  }\n  if (typeof record.createdAt === 'string' && record.createdAt) {\n    score += 1;\n  }\n  if (typeof record.createdAtMs === 'number' && Number.isFinite(record.createdAtMs)) {\n    score += 1;\n  }\n  if (record.metadata && typeof record.metadata === 'object') {\n    score += 1;\n  }\n  return score;\n}\n\nfunction mergeBackupVaultRecords(existingList, incomingList) {\n  const merged = new Map();\n  const mergeList = (records) => {\n    if (!Array.isArray(records)) {\n      return;\n    }\n    records.forEach((record) => {\n      const normalized = normalizeBackupVaultRecord(record);\n      if (!normalized) {\n        return;\n      }\n      const existing = merged.get(normalized.id);\n      if (!existing || scoreBackupVaultRecord(normalized) >= scoreBackupVaultRecord(existing)) {\n        merged.set(normalized.id, normalized);\n      }\n    });\n  };\n  mergeList(existingList);\n  mergeList(incomingList);\n  return Array.from(merged.values());\n}\n\nfunction readBackupVaultFallbackRecords() {\n  const raw = readLocalStorageValue('cineBackupVaultFallbackRecords');\n  return normalizeBackupVaultRecordList(raw);\n}\n\nfunction resolveBackupVaultApi() {\n  if (GLOBAL_SCOPE && GLOBAL_SCOPE.cineFeatureBackup && typeof GLOBAL_SCOPE.cineFeatureBackup === 'object') {\n    return GLOBAL_SCOPE.cineFeatureBackup;\n  }\n  if (GLOBAL_SCOPE && typeof GLOBAL_SCOPE.getQueuedBackupPayloads === 'function') {\n    return GLOBAL_SCOPE;\n  }\n  return null;\n}\n\nfunction refreshBackupVaultRecordCache() {\n  const api = resolveBackupVaultApi();\n  if (!api) {\n    return;\n  }\n  const loader = typeof api.listBackupVaultRecords === 'function'\n    ? api.listBackupVaultRecords\n    : typeof api.getQueuedBackupPayloads === 'function'\n      ? api.getQueuedBackupPayloads\n      : null;\n  if (!loader) {\n    return;\n  }\n  let response = null;\n  try {\n    response = loader();\n  } catch (error) {\n    console.warn('Unable to load backup vault records for export', error);\n    return;\n  }\n  if (Array.isArray(response)) {\n    backupVaultRecordCache = normalizeBackupVaultRecordList(response);\n    return;\n  }\n  if (response && typeof response.then === 'function') {\n    return response.then((records) => {\n      backupVaultRecordCache = normalizeBackupVaultRecordList(records);\n      return backupVaultRecordCache;\n    }).catch((error) => {\n      console.warn('Unable to load backup vault records for export', error);\n      return [];\n    });\n  }\n  return Promise.resolve(backupVaultRecordCache);\n}\n\nasync function prepareBackupForExport() {\n  const records = await refreshBackupVaultRecordCache();\n  return records;\n}\n\nfunction exportAllData() {\n  refreshBackupVaultRecordCache();\n  const payload = {\n    devices: loadDeviceData(),\n    setups: loadSetups(),\n    session: loadSessionState(),\n    feedback: loadFeedback(),\n    project: loadProject(),\n    favorites: loadFavorites(),\n    contacts: loadContacts(),\n    ownGear: loadOwnGear(),\n    userProfile: null,\n    autoGearRules: loadAutoGearRules(),\n    autoGearBackups: loadAutoGearBackups(),\n    autoGearSeeded: loadAutoGearSeedFlag(),\n    autoGearPresets: loadAutoGearPresets(),\n    autoGearMonitorDefaults: loadAutoGearMonitorDefaults(),\n    autoGearActivePresetId: loadAutoGearActivePresetId(),\n    autoGearAutoPresetId: loadAutoGearAutoPresetId(),\n    autoGearShowBackups: loadAutoGearBackupVisibility(),\n    autoGearBackupRetention: loadAutoGearBackupRetention(),\n    fullBackupHistory: loadFullBackupHistory(),\n  };\n\n  const documentationTracker = loadDocumentationTracker();\n  if (\n    documentationTracker &&\n    Array.isArray(documentationTracker.releases) &&\n    documentationTracker.releases.length\n  ) {\n    payload.documentationTracker = documentationTracker;\n  }\n\n  const preferences = collectPreferenceSnapshot();\n  if (Object.keys(preferences).length) {\n    payload.preferences = preferences;\n  }\n\n  const profile = loadUserProfile();\n  if (\n    profile\n    && typeof profile === 'object'\n    && (\n      (typeof profile.name === 'string' && profile.name)\n      || (typeof profile.role === 'string' && profile.role)\n      || (typeof profile.avatar === 'string' && profile.avatar)\n      || (typeof profile.phone === 'string' && profile.phone)\n      || (typeof profile.email === 'string' && profile.email)\n    )\n  ) {\n    payload.userProfile = profile;\n  } else {\n    delete payload.userProfile;\n  }\n\n  const customLogo = readLocalStorageValue(CUSTOM_LOGO_STORAGE_KEY);\n  if (customLogo) {\n    payload.customLogo = customLogo;\n  }\n\n  const customFonts = readStoredCustomFonts();\n  if (customFonts.length) {\n    payload.customFonts = customFonts;\n  }\n\n  const schemaCache = readLocalStorageValue(DEVICE_SCHEMA_CACHE_KEY);\n  if (schemaCache !== null && schemaCache !== undefined) {\n    payload.schemaCache = schemaCache;\n  }\n\n  const fallbackVaultRecords = readBackupVaultFallbackRecords();\n  const combinedVaultRecords = mergeBackupVaultRecords(\n    backupVaultRecordCache,\n    fallbackVaultRecords,\n  );\n  if (combinedVaultRecords.length) {\n    payload.backupVaultRecords = combinedVaultRecords.map((record) => storageJsonDeepClone(record));\n  }\n\n  return payload;\n}\n\nfunction safeSetLocalStorage(key, value) {\n  const storage = getSafeLocalStorage();\n  if (!storage) return;\n  const useBackup = RAW_STORAGE_BACKUP_KEYS.has(key);\n  const backupKey = `${key}${STORAGE_BACKUP_SUFFIX}`;\n  const isIndexedDB = Boolean(\n    storageRepo\n    && storageRepo.driver\n    && storageRepo.driver.constructor\n    && storageRepo.driver.constructor.name === 'IndexedDBAdapter',\n  );\n\n  const clearCacheForKey = () => {\n    if (key === CUSTOM_FONT_STORAGE_KEY_DEFAULT) { customFontsCache = null; }\n    if (key === CUSTOM_LOGO_STORAGE_KEY) { customLogoCache = null; }\n    if (key === CAMERA_COLOR_STORAGE_KEY) { cameraColorsCache = null; }\n    if (key === PRINT_PREFERENCES_STORAGE_KEY) { printPreferencesCache = null; }\n    if (key === CONTACTS_STORAGE_KEY) { contactsCache = null; }\n    if (key === OWN_GEAR_STORAGE_KEY) { ownGearCache = null; }\n    if (key === USER_PROFILE_STORAGE_KEY) { userProfileCache = null; }\n    if (key === FAVORITES_STORAGE_KEY) { favoritesCache = null; }\n    if (key === TEMPERATURE_UNIT_STORAGE_KEY_NAME) { temperatureUnitCache = null; }\n    if (key === FOCUS_SCALE_STORAGE_KEY_NAME) { focusScaleCache = null; }\n    if (key === getMountVoltageStorageKeyName()) { mountVoltagesCache = null; }\n  };\n\n  const writeLegacyStorage = (storedValue) => {\n    storage.setItem(key, storedValue);\n    if (useBackup) {\n      try {\n        storage.setItem(backupKey, storedValue);\n      } catch (backupError) {\n        console.warn('Unable to update backup key during import', backupKey, backupError);\n        downgradeSafeLocalStorageToMemory('write access', backupError, storage);\n        alertStorageError();\n      }\n    }\n  };\n\n  try {\n    if (value === null || value === undefined) {\n      clearCacheForKey();\n      if (storageRepo) {\n        storageRepo.removeItem(key).catch(e => console.warn('Failed to remove key from repo', key, e));\n      }\n      storage.removeItem(key);\n      if (useBackup) {\n        try {\n          storage.removeItem(backupKey);\n        } catch (backupError) {\n          console.warn('Unable to remove backup key during import', backupKey, backupError);\n          downgradeSafeLocalStorageToMemory('deletion', backupError, storage);\n        }\n      }\n    } else {\n      const storedValue = String(value);\n\n      // [Agent Refactor] Intercept & Persist Branding Keys\n      if (key === CUSTOM_FONT_STORAGE_KEY_DEFAULT) { customFontsCache = storedValue; }\n      if (key === CUSTOM_LOGO_STORAGE_KEY) { customLogoCache = storedValue; }\n      if (key === CAMERA_COLOR_STORAGE_KEY) { cameraColorsCache = storedValue; }\n      if (key === PRINT_PREFERENCES_STORAGE_KEY) { printPreferencesCache = storedValue; }\n      if (key === CONTACTS_STORAGE_KEY) { contactsCache = storedValue; }\n      if (key === OWN_GEAR_STORAGE_KEY) { ownGearCache = storedValue; }\n      if (key === USER_PROFILE_STORAGE_KEY) { userProfileCache = storedValue; }\n      if (key === FAVORITES_STORAGE_KEY) { favoritesCache = storedValue; }\n      if (key === TEMPERATURE_UNIT_STORAGE_KEY_NAME) { temperatureUnitCache = storedValue; }\n      if (key === FOCUS_SCALE_STORAGE_KEY_NAME) { focusScaleCache = storedValue; }\n      if (key === getMountVoltageStorageKeyName()) { mountVoltagesCache = storedValue; }\n\n      if (storageRepo) {\n        storageRepo.setItem(key, storedValue).catch(e => {\n          console.warn('Failed to save key to repo', key, e);\n          try {\n            writeLegacyStorage(storedValue);\n          } catch (legacyError) {\n            console.warn('Unable to persist fallback legacy storage key during repo failure', key, legacyError);\n            downgradeSafeLocalStorageToMemory('write access', legacyError, storage);\n            if (useBackup) {\n              alertStorageError();\n            }\n          }\n        });\n      }\n\n      if (isIndexedDB) {\n        return;\n      }\n\n      writeLegacyStorage(storedValue);\n    }\n  } catch (error) {\n    console.warn('Unable to persist storage key during import', key, error);\n    downgradeSafeLocalStorageToMemory('write access', error, storage);\n    if (useBackup) {\n      alertStorageError();\n    }\n  }\n}\n\nfunction normalizeImportedBoolean(value) {\n  if (typeof value === \"boolean\") {\n    return value;\n  }\n\n  if (typeof value === \"string\") {\n    const normalized = value.trim().toLowerCase();\n    if (!normalized) {\n      return null;\n    }\n    if (normalized === \"true\" || normalized === \"1\" || normalized === \"yes\" || normalized === \"on\") {\n      return true;\n    }\n    if (normalized === \"false\" || normalized === \"0\" || normalized === \"no\" || normalized === \"off\") {\n      return false;\n    }\n    return null;\n  }\n\n  if (typeof value === \"number\") {\n    if (Number.isNaN(value)) {\n      return null;\n    }\n    return value !== 0;\n  }\n\n  if (Array.isArray(value)) {\n    for (let i = 0; i < value.length; i += 1) {\n      const normalized = normalizeImportedBoolean(value[i]);\n      if (normalized !== null) {\n        return normalized;\n      }\n    }\n    return null;\n  }\n\n  if (isPlainObject(value)) {\n    if (Object.prototype.hasOwnProperty.call(value, \"value\")) {\n      return normalizeImportedBoolean(value.value);\n    }\n    if (Object.prototype.hasOwnProperty.call(value, \"enabled\")) {\n      return normalizeImportedBoolean(value.enabled);\n    }\n  }\n\n  return null;\n}\n\nfunction normalizeImportedArray(value, fallbackKeys = [], filterFn = null) {\n  if (isMapLike(value)) {\n    const converted = convertMapLikeToObject(value);\n    if (converted) {\n      return normalizeImportedArray(converted, fallbackKeys, filterFn);\n    }\n    return [];\n  }\n\n  if (Array.isArray(value)) {\n    return filterFn\n      ? value.filter((entry) => filterFn(entry))\n      : value.filter((entry) => entry !== null && entry !== undefined);\n  }\n\n  if (typeof value === \"string\") {\n    const parsed = tryParseJSONLike(value);\n    if (parsed.success) {\n      return normalizeImportedArray(parsed.parsed, fallbackKeys, filterFn);\n    }\n    return [];\n  }\n\n  if (isPlainObject(value)) {\n    for (let i = 0; i < fallbackKeys.length; i += 1) {\n      const key = fallbackKeys[i];\n      if (!Object.prototype.hasOwnProperty.call(value, key)) {\n        continue;\n      }\n      const extracted = normalizeImportedArray(value[key], fallbackKeys, filterFn);\n      if (extracted.length) {\n        return extracted;\n      }\n    }\n\n    const entries = Object.values(value);\n    if (entries.length) {\n      return filterFn\n        ? entries.filter((entry) => filterFn(entry))\n        : entries.filter((entry) => entry !== null && entry !== undefined);\n    }\n  }\n\n  return [];\n}\n\nfunction normalizeImportedContacts(value) {\n  const entries = normalizeImportedArray(\n    value,\n    ['contacts', 'entries', 'items', 'list', 'values', 'data'],\n    (entry) => entry && typeof entry === 'object',\n  );\n  if (!Array.isArray(entries)) {\n    return [];\n  }\n  return normalizeContactsList(entries);\n}\n\nfunction normalizeImportedAutoGearRules(value) {\n  const rules = normalizeImportedArray(\n    value,\n    [\"rules\", \"items\", \"entries\", \"list\", \"values\", \"data\"],\n    (entry) => entry !== null && typeof entry === \"object\",\n  );\n  if (!Array.isArray(rules)) {\n    return [];\n  }\n  return normalizeLegacyLongGopStructure(rules);\n}\n\nfunction normalizeImportedAutoGearBackups(value) {\n  const backups = normalizeImportedArray(\n    value,\n    [\"backups\", \"entries\", \"items\", \"list\", \"values\", \"data\"],\n    (entry) => entry !== null && typeof entry === \"object\",\n  );\n  if (!Array.isArray(backups)) {\n    return [];\n  }\n  const { normalized } = normalizeLegacyLongGopBackups(backups);\n  return normalized;\n}\n\nfunction normalizeImportedAutoGearBackupRetention(value) {\n  if (value === null || value === undefined) {\n    return null;\n  }\n  if (typeof value === 'number') {\n    return clampAutoGearBackupRetention(value);\n  }\n  if (typeof value === 'string') {\n    const trimmed = value.trim();\n    if (!trimmed) {\n      return null;\n    }\n    const direct = Number(trimmed);\n    if (Number.isFinite(direct)) {\n      return clampAutoGearBackupRetention(direct);\n    }\n    const parsed = tryParseJSONLike(trimmed);\n    if (parsed && parsed.success) {\n      return normalizeImportedAutoGearBackupRetention(parsed.parsed);\n    }\n    return null;\n  }\n  if (Array.isArray(value)) {\n    for (let i = 0; i < value.length; i += 1) {\n      const candidate = normalizeImportedAutoGearBackupRetention(value[i]);\n      if (typeof candidate === 'number') {\n        return candidate;\n      }\n    }\n    return null;\n  }\n  if (isPlainObject(value)) {\n    const candidateKeys = ['value', 'retention', 'limit', 'count'];\n    for (let i = 0; i < candidateKeys.length; i += 1) {\n      const key = candidateKeys[i];\n      if (!Object.prototype.hasOwnProperty.call(value, key)) {\n        continue;\n      }\n      const candidate = normalizeImportedAutoGearBackupRetention(value[key]);\n      if (typeof candidate === 'number') {\n        return candidate;\n      }\n    }\n    return null;\n  }\n  if (typeof value === 'boolean') {\n    return value ? AUTO_GEAR_BACKUP_RETENTION_MIN : null;\n  }\n  return null;\n}\n\nfunction normalizeImportedAutoGearPresets(value) {\n  const presets = normalizeImportedArray(\n    value,\n    [\"presets\", \"entries\", \"items\", \"list\", \"values\", \"data\"],\n    (entry) => entry !== null && typeof entry === \"object\",\n  );\n  if (!Array.isArray(presets)) {\n    return [];\n  }\n  return normalizeLegacyLongGopStructure(presets);\n}\n\nfunction normalizeImportedAutoGearMonitorDefaults(value) {\n  if (!value || typeof value !== 'object') {\n    return {};\n  }\n  const normalized = {};\n  Object.entries(value).forEach(([key, val]) => {\n    if (typeof val !== 'string') return;\n    const trimmed = val.trim();\n    if (!trimmed) return;\n    normalized[key] = trimmed;\n  });\n  const legacyNormalized = normalizeLegacyLongGopStructure(normalized);\n  return isPlainObject(legacyNormalized) ? legacyNormalized : normalized;\n}\n\nfunction normalizeImportedPresetId(value) {\n  if (typeof value === \"string\") {\n    return value;\n  }\n  if (typeof value === \"number\") {\n    return Number.isNaN(value) ? \"\" : String(value);\n  }\n  if (Array.isArray(value)) {\n    for (let i = 0; i < value.length; i += 1) {\n      const candidate = normalizeImportedPresetId(value[i]);\n      if (candidate) {\n        return candidate;\n      }\n    }\n    return \"\";\n  }\n  if (isPlainObject(value)) {\n    if (typeof value.id === \"string\" && value.id) {\n      return value.id;\n    }\n    if (typeof value.value === \"string\") {\n      return value.value;\n    }\n    if (Object.prototype.hasOwnProperty.call(value, \"name\")) {\n      return normalizeImportedPresetId(value.name);\n    }\n  }\n  return \"\";\n}\n\nfunction normalizeImportedBackupVaultRecords(value) {\n  const records = normalizeImportedArray(\n    value,\n    ['backupVaultRecords', 'backupVault', 'vault', 'records', 'entries', 'items', 'list', 'values', 'data'],\n    (entry) => entry && typeof entry === 'object',\n  );\n  return normalizeBackupVaultRecordList(records);\n}\n\nfunction importBackupVaultRecords(records) {\n  const normalized = normalizeBackupVaultRecordList(records);\n  if (!normalized.length) {\n    return;\n  }\n\n  const existingFallback = readBackupVaultFallbackRecords();\n  const mergedFallback = mergeBackupVaultRecords(existingFallback, normalized);\n  try {\n    safeSetLocalStorage('cineBackupVaultFallbackRecords', JSON.stringify(mergedFallback));\n  } catch (storageError) {\n    console.warn('Unable to persist imported backup vault fallback records', storageError);\n  }\n\n  const api = resolveBackupVaultApi();\n  if (!api || typeof api.queueBackupPayloadForVault !== 'function') {\n    return;\n  }\n\n  const queueRecord = (record) => {\n    api.queueBackupPayloadForVault(\n      record.fileName,\n      record.payload,\n      {\n        id: record.id,\n        createdAt: record.createdAt,\n        createdAtMs: record.createdAtMs,\n        source: record.metadata && record.metadata.source ? record.metadata.source : undefined,\n        reason: record.metadata && record.metadata.reason ? record.metadata.reason : undefined,\n        permissionState: record.metadata && record.metadata.permissionState\n          ? record.metadata.permissionState\n          : undefined,\n      },\n    );\n  };\n\n  const loader = typeof api.listBackupVaultRecords === 'function'\n    ? api.listBackupVaultRecords\n    : typeof api.getQueuedBackupPayloads === 'function'\n      ? api.getQueuedBackupPayloads\n      : null;\n\n  if (!loader) {\n    normalized.forEach(queueRecord);\n    return;\n  }\n\n  try {\n    const response = loader();\n    if (Array.isArray(response)) {\n      const existingIds = new Set(response.map((entry) => (entry && entry.id ? entry.id : null)));\n      normalized.forEach((record) => {\n        if (!existingIds.has(record.id)) {\n          queueRecord(record);\n        }\n      });\n      return;\n    }\n    if (response && typeof response.then === 'function') {\n      response.then((existing) => {\n        const existingIds = new Set(\n          Array.isArray(existing)\n            ? existing.map((entry) => (entry && entry.id ? entry.id : null))\n            : [],\n        );\n        normalized.forEach((record) => {\n          if (!existingIds.has(record.id)) {\n            queueRecord(record);\n          }\n        });\n      }).catch((error) => {\n        console.warn('Unable to inspect backup vault before import', error);\n        normalized.forEach(queueRecord);\n      });\n      return;\n    }\n    normalized.forEach(queueRecord);\n  } catch (error) {\n    console.warn('Unable to import backup vault records via backup module', error);\n    normalized.forEach(queueRecord);\n  }\n}\n\nfunction getSnapshotKeyVariants(key) {\n  return getStorageKeyVariants(key);\n}\n\nfunction readSnapshotEntry(snapshot, key) {\n  if (!isPlainObject(snapshot)) {\n    return null;\n  }\n\n  const variants = getSnapshotKeyVariants(key);\n  for (let i = 0; i < variants.length; i += 1) {\n    const candidate = variants[i];\n    if (Object.prototype.hasOwnProperty.call(snapshot, candidate)) {\n      return { key: candidate, value: snapshot[candidate], type: 'primary' };\n    }\n  }\n\n  for (let i = 0; i < variants.length; i += 1) {\n    const candidate = `${variants[i]}${STORAGE_BACKUP_SUFFIX}`;\n    if (Object.prototype.hasOwnProperty.call(snapshot, candidate)) {\n      return { key: candidate, value: snapshot[candidate], type: 'backup' };\n    }\n  }\n\n  for (let i = 0; i < variants.length; i += 1) {\n    const candidate = `${variants[i]}${STORAGE_MIGRATION_BACKUP_SUFFIX}`;\n    if (Object.prototype.hasOwnProperty.call(snapshot, candidate)) {\n      return { key: candidate, value: snapshot[candidate], type: 'migration-backup' };\n    }\n  }\n\n  return null;\n}\n\nfunction extractSnapshotStoredValue(entry) {\n  if (!entry) {\n    return undefined;\n  }\n\n  let raw = entry.value;\n  if (entry.type === 'migration-backup') {\n    try {\n      const parsed = typeof raw === 'string' ? JSON.parse(raw) : raw;\n      if (parsed && typeof parsed === 'object') {\n        const compressionToken = typeof parsed.compression === 'string' ? parsed.compression.trim() : '';\n        const encodingToken = typeof parsed.encoding === 'string' ? parsed.encoding.trim() : '';\n        const isModernCompression =\n          compressionToken === MIGRATION_BACKUP_COMPRESSION_ALGORITHM\n          && encodingToken === MIGRATION_BACKUP_COMPRESSION_ENCODING;\n        const isLegacyLongGopCompression =\n          LEGACY_LONG_GOP_TOKEN_REGEX.test(compressionToken)\n          || LEGACY_LONG_GOP_TOKEN_REGEX.test(encodingToken);\n\n        if ((isModernCompression || isLegacyLongGopCompression) && typeof parsed.data === 'string') {\n          if (canUseMigrationBackupCompression()) {\n            let preferredVariant = typeof parsed.compressionVariant === 'string'\n              && parsed.compressionVariant\n              ? parsed.compressionVariant\n              : null;\n            if (!preferredVariant) {\n              if (isLegacyLongGopCompression) {\n                preferredVariant = inferLegacyLongGopCompressionVariant(encodingToken)\n                  || inferLegacyLongGopCompressionVariant(compressionToken)\n                  || 'utf16';\n              } else {\n                preferredVariant = 'utf16';\n              }\n            }\n            const decoded = tryDecompressWithStrategies(\n              parsed.data,\n              MIGRATION_BACKUP_COMPRESSION_VARIANTS,\n              preferredVariant,\n              'migration backup entry',\n            );\n            if (decoded.success && typeof decoded.value === 'string') {\n              try {\n                const payload = JSON.parse(decoded.value);\n                if (payload && typeof payload === 'object' && Object.prototype.hasOwnProperty.call(payload, 'data')) {\n                  raw = payload.data;\n                } else {\n                  raw = null;\n                }\n              } catch (parseError) {\n                console.warn('Unable to parse migration backup entry during import', entry.key, parseError);\n                raw = null;\n              }\n            } else {\n              console.warn('Unable to decompress migration backup entry during import', entry && entry.key, decoded.error);\n              raw = null;\n            }\n          } else {\n            console.warn('Compression support is unavailable while reading migration backup entry', entry && entry.key);\n            raw = null;\n          }\n        } else if (Object.prototype.hasOwnProperty.call(parsed, 'data')) {\n          raw = parsed.data;\n        } else {\n          raw = null;\n        }\n      } else {\n        raw = null;\n      }\n    } catch (error) {\n      console.warn('Unable to parse migration backup entry during import', entry.key, error);\n      raw = null;\n    }\n  }\n\n  return raw;\n}\n\nfunction parseSnapshotJSONValue(entry) {\n  const raw = extractSnapshotStoredValue(entry);\n  if (raw === undefined) {\n    return undefined;\n  }\n  if (raw === null) {\n    return null;\n  }\n  if (typeof raw === 'string') {\n    const decoded = decodeStoredValue(raw);\n    if (decoded === null) {\n      return null;\n    }\n    if (decoded === undefined) {\n      return undefined;\n    }\n    if (typeof decoded !== 'string') {\n      return decoded;\n    }\n    const trimmed = decoded.trim();\n    if (!trimmed) {\n      return '';\n    }\n    try {\n      return JSON.parse(trimmed);\n    } catch {\n      return decoded;\n    }\n  }\n  return raw;\n}\n\nfunction parseSnapshotStringValue(entry) {\n  const raw = extractSnapshotStoredValue(entry);\n  if (raw === undefined) {\n    return undefined;\n  }\n  if (raw === null) {\n    return null;\n  }\n  if (typeof raw === 'string') {\n    const decoded = decodeStoredValue(raw);\n    if (decoded === null) {\n      return null;\n    }\n    if (decoded === undefined) {\n      return undefined;\n    }\n    if (typeof decoded === 'string') {\n      return decoded;\n    }\n    if (typeof decoded === 'number' || typeof decoded === 'boolean') {\n      return String(decoded);\n    }\n    if (Array.isArray(decoded) || (decoded && typeof decoded === 'object')) {\n      try {\n        return JSON.stringify(decoded);\n      } catch (serializationError) {\n        console.warn('Unable to serialize snapshot entry during import', entry && entry.key, serializationError);\n        return null;\n      }\n    }\n    return null;\n  }\n  if (typeof raw === 'number' || typeof raw === 'boolean') {\n    return String(raw);\n  }\n  if (Array.isArray(raw) || (raw && typeof raw === 'object')) {\n    try {\n      return JSON.stringify(raw);\n    } catch (serializationError) {\n      console.warn('Unable to serialize snapshot entry during import', entry && entry.key, serializationError);\n      return null;\n    }\n  }\n  return null;\n}\n\nfunction convertStorageSnapshotToData(snapshot) {\n  if (!isPlainObject(snapshot)) {\n    return null;\n  }\n\n  const exportStructureKeys = [\n    'devices',\n    'setups',\n    'session',\n    'feedback',\n    'favorites',\n    'contacts',\n    'preferences',\n    'project',\n    'projects',\n    'autoGearRules',\n    'autoGearBackups',\n    'autoGearPresets',\n    'autoGearMonitorDefaults',\n    'autoGearSeeded',\n    'autoGearActivePresetId',\n    'autoGearAutoPresetId',\n    'autoGearBackupRetention',\n    'autoGearShowBackups',\n    'fullBackupHistory',\n    'fullBackups',\n    'backupVaultRecords',\n  ];\n\n  const resemblesExportPayload = exportStructureKeys.some((key) =>\n    Object.prototype.hasOwnProperty.call(snapshot, key),\n  );\n\n  if (resemblesExportPayload) {\n    return null;\n  }\n\n  const data = {};\n  let hasAssignments = false;\n  let hasSnapshotKeys = false;\n\n  const preferenceKeys = [\n    'darkMode',\n    'pinkMode',\n    'highContrast',\n    'reduceMotion',\n    'relaxedSpacing',\n    'showAutoBackups',\n    'accentColor',\n    'fontSize',\n    'fontFamily',\n    'language',\n    'iosPwaHelpShown',\n    CAMERA_COLOR_STORAGE_KEY,\n    PRINT_PREFERENCES_STORAGE_KEY,\n  ];\n\n  const mountVoltageKeyName = getMountVoltageStorageKeyName();\n  const simpleSnapshotKeys = new Set(\n    [CUSTOM_LOGO_STORAGE_KEY, ...preferenceKeys, mountVoltageKeyName].filter(\n      (key) => typeof key === 'string' && key,\n    ),\n  );\n\n  const booleanPreferenceKeys = new Set([\n    'darkMode',\n    'pinkMode',\n    'highContrast',\n    'reduceMotion',\n    'relaxedSpacing',\n    'showAutoBackups',\n    'iosPwaHelpShown',\n  ]);\n\n  const markSnapshotEntry = (entry) => {\n    if (!entry || typeof entry.key !== 'string') {\n      return;\n    }\n    if (\n      entry.key.startsWith('cameraPowerPlanner_') ||\n      entry.key.startsWith('cinePowerPlanner_') ||\n      entry.key.endsWith(STORAGE_BACKUP_SUFFIX) ||\n      entry.key.endsWith(STORAGE_MIGRATION_BACKUP_SUFFIX)\n    ) {\n      hasSnapshotKeys = true;\n      return;\n    }\n\n    const normalizedKey = entry.key.replace(/(?:__backup|__legacyMigrationBackup)$/u, '');\n    if (simpleSnapshotKeys.has(normalizedKey)) {\n      hasSnapshotKeys = true;\n    }\n  };\n\n  const assignJSONValue = (storageKey, targetKey) => {\n    const entry = readSnapshotEntry(snapshot, storageKey);\n    if (!entry) {\n      return;\n    }\n    markSnapshotEntry(entry);\n    const value = parseSnapshotJSONValue(entry);\n    if (value === undefined) {\n      return;\n    }\n    data[targetKey] = value;\n    hasAssignments = true;\n  };\n\n  assignJSONValue(DEVICE_STORAGE_KEY, 'devices');\n  assignJSONValue(SETUP_STORAGE_KEY, 'setups');\n  assignJSONValue(SESSION_STATE_KEY, 'session');\n  assignJSONValue(FEEDBACK_STORAGE_KEY, 'feedback');\n  assignJSONValue(PROJECT_STORAGE_KEY, 'project');\n  assignJSONValue(FAVORITES_STORAGE_KEY, 'favorites');\n  assignJSONValue(CONTACTS_STORAGE_KEY, 'contacts');\n  assignJSONValue(OWN_GEAR_STORAGE_KEY, 'ownGear');\n  assignJSONValue(USER_PROFILE_STORAGE_KEY, 'userProfile');\n  assignJSONValue(DOCUMENTATION_TRACKER_STORAGE_KEY, 'documentationTracker');\n  assignJSONValue(AUTO_GEAR_RULES_STORAGE_KEY, 'autoGearRules');\n  assignJSONValue(AUTO_GEAR_BACKUPS_STORAGE_KEY, 'autoGearBackups');\n  assignJSONValue(AUTO_GEAR_PRESETS_STORAGE_KEY, 'autoGearPresets');\n  assignJSONValue(AUTO_GEAR_MONITOR_DEFAULTS_STORAGE_KEY, 'autoGearMonitorDefaults');\n  assignJSONValue(AUTO_GEAR_BACKUP_RETENTION_STORAGE_KEY, 'autoGearBackupRetention');\n\n  const schemaEntry = readSnapshotEntry(snapshot, DEVICE_SCHEMA_CACHE_KEY);\n  if (schemaEntry) {\n    markSnapshotEntry(schemaEntry);\n    const cacheValue = parseSnapshotStringValue(schemaEntry);\n    if (cacheValue !== undefined) {\n      data.schemaCache = cacheValue;\n      hasAssignments = true;\n    }\n  }\n\n  const customFontsEntry = readSnapshotEntry(snapshot, getCustomFontStorageKeyName());\n  if (customFontsEntry) {\n    markSnapshotEntry(customFontsEntry);\n    const fontsValue = parseSnapshotJSONValue(customFontsEntry);\n    if (fontsValue !== undefined) {\n      data.customFonts = fontsValue;\n      hasAssignments = true;\n    }\n  }\n\n  const customLogoEntry = readSnapshotEntry(snapshot, CUSTOM_LOGO_STORAGE_KEY);\n  if (customLogoEntry) {\n    markSnapshotEntry(customLogoEntry);\n    const logoValue = parseSnapshotStringValue(customLogoEntry);\n    if (logoValue !== undefined) {\n      data.customLogo = logoValue;\n      hasAssignments = true;\n    }\n  }\n\n  const seedEntry = readSnapshotEntry(snapshot, AUTO_GEAR_SEEDED_STORAGE_KEY);\n  if (seedEntry) {\n    markSnapshotEntry(seedEntry);\n    data.autoGearSeeded = extractSnapshotStoredValue(seedEntry);\n    hasAssignments = true;\n  }\n\n  const activePresetEntry = readSnapshotEntry(snapshot, AUTO_GEAR_ACTIVE_PRESET_STORAGE_KEY);\n  if (activePresetEntry) {\n    markSnapshotEntry(activePresetEntry);\n    data.autoGearActivePresetId = parseSnapshotStringValue(activePresetEntry);\n    hasAssignments = true;\n  }\n\n  const autoPresetEntry = readSnapshotEntry(snapshot, AUTO_GEAR_AUTO_PRESET_STORAGE_KEY);\n  if (autoPresetEntry) {\n    markSnapshotEntry(autoPresetEntry);\n    data.autoGearAutoPresetId = parseSnapshotStringValue(autoPresetEntry);\n    hasAssignments = true;\n  }\n\n  const backupsVisibilityEntry = readSnapshotEntry(snapshot, AUTO_GEAR_BACKUP_VISIBILITY_STORAGE_KEY);\n  if (backupsVisibilityEntry) {\n    markSnapshotEntry(backupsVisibilityEntry);\n    data.autoGearShowBackups = extractSnapshotStoredValue(backupsVisibilityEntry);\n    hasAssignments = true;\n  }\n\n  const preferences = {};\n\n  preferenceKeys.forEach((key) => {\n    const entry = readSnapshotEntry(snapshot, key);\n    if (!entry) {\n      return;\n    }\n    markSnapshotEntry(entry);\n    if (key === PRINT_PREFERENCES_STORAGE_KEY) {\n      const snapshotPrintValue = parseSnapshotStringValue(entry);\n      if (snapshotPrintValue !== undefined) {\n        const interpretedPreferences = interpretPrintPreferencesValue(snapshotPrintValue);\n        if (interpretedPreferences) {\n          if (interpretedPreferences.normalized) {\n            preferences[key] = storageJsonDeepClone(interpretedPreferences.normalized);\n            hasAssignments = true;\n            return;\n          }\n          if (interpretedPreferences.serialized) {\n            preferences[key] = interpretedPreferences.serialized;\n            hasAssignments = true;\n            return;\n          }\n        }\n      }\n      return;\n    }\n    const raw = extractSnapshotStoredValue(entry);\n    if (booleanPreferenceKeys.has(key)) {\n      const normalized = normalizeImportedBoolean(raw);\n      if (normalized !== null) {\n        preferences[key] = normalized;\n        hasAssignments = true;\n        return;\n      }\n    }\n    const stringValue = parseSnapshotStringValue(entry);\n    if (stringValue !== undefined) {\n      preferences[key] = stringValue;\n      hasAssignments = true;\n    }\n  });\n\n  const temperatureUnitEntry = readSnapshotEntry(snapshot, TEMPERATURE_UNIT_STORAGE_KEY_NAME);\n  if (temperatureUnitEntry) {\n    markSnapshotEntry(temperatureUnitEntry);\n    const storedUnit = parseSnapshotStringValue(temperatureUnitEntry);\n    if (typeof storedUnit === 'string') {\n      const normalizedUnit = storedUnit.trim();\n      if (normalizedUnit) {\n        preferences.temperatureUnit = normalizedUnit;\n        hasAssignments = true;\n      }\n    }\n  }\n\n  const focusScaleEntry = readSnapshotEntry(snapshot, FOCUS_SCALE_STORAGE_KEY_NAME);\n  if (focusScaleEntry) {\n    markSnapshotEntry(focusScaleEntry);\n    const storedScale = parseSnapshotStringValue(focusScaleEntry);\n    if (typeof storedScale === 'string') {\n      const normalizedScale = storedScale.trim();\n      if (normalizedScale) {\n        preferences.focusScale = normalizedScale;\n        hasAssignments = true;\n      }\n    }\n  }\n\n  const cameraColorsEntry = readSnapshotEntry(snapshot, CAMERA_COLOR_STORAGE_KEY);\n  if (cameraColorsEntry) {\n    markSnapshotEntry(cameraColorsEntry);\n    const storedCameraColors = parseSnapshotJSONValue(cameraColorsEntry);\n    if (storedCameraColors !== undefined) {\n      preferences.cameraColors = storedCameraColors;\n      hasAssignments = true;\n    }\n  }\n\n  const mountVoltageEntry = readSnapshotEntry(snapshot, mountVoltageKeyName);\n  if (mountVoltageEntry) {\n    markSnapshotEntry(mountVoltageEntry);\n    const storedVoltages = parseSnapshotJSONValue(mountVoltageEntry);\n    if (storedVoltages !== undefined) {\n      preferences.mountVoltages = storedVoltages;\n      hasAssignments = true;\n    }\n  }\n\n  if (Object.keys(preferences).length > 0) {\n    data.preferences = preferences;\n  }\n\n  if (!hasAssignments || !hasSnapshotKeys) {\n    return null;\n  }\n\n  return data;\n}\n\nfunction importAllData(allData, options = {}) {\n  if (Array.isArray(allData)) {\n    importProjectCollection(allData, () => createProjectImporter());\n    return;\n  }\n\n  if (!isPlainObject(allData)) {\n    return;\n  }\n\n  const { skipSnapshotConversion = false } = options || {};\n\n  if (!skipSnapshotConversion) {\n    const converted = convertStorageSnapshotToData(allData);\n    if (converted) {\n      importAllData(converted, { skipSnapshotConversion: true });\n      return;\n    }\n  }\n\n  const hasOwn = (key) => Object.prototype.hasOwnProperty.call(allData, key);\n  const mountVoltageKeyName = getMountVoltageStorageKeyName();\n  const cameraColorKeyName = CAMERA_COLOR_STORAGE_KEY;\n\n  if (hasOwn('devices')) {\n    saveDeviceData(allData.devices);\n  }\n  if (hasOwn('setups')) {\n    saveSetups(allData.setups);\n  }\n  if (hasOwn('session')) {\n    saveSessionState(allData.session, { disableCompression: true });\n  }\n  if (hasOwn('feedback')) {\n    saveFeedback(allData.feedback);\n  }\n  if (hasOwn('favorites')) {\n    saveFavorites(allData.favorites);\n  }\n  if (hasOwn('contacts')) {\n    if (allData.contacts === null) {\n      saveContacts(null);\n    } else {\n      const contacts = normalizeImportedContacts(allData.contacts);\n      saveContacts(contacts);\n    }\n  }\n  if (hasOwn('ownGear')) {\n    const entries = normalizeImportedArray(\n      allData.ownGear,\n      ['items', 'entries', 'list', 'values', 'data'],\n      (entry) => entry && typeof entry === 'object',\n    );\n    saveOwnGear(entries);\n  }\n  if (hasOwn('userProfile')) {\n    if (allData.userProfile === null) {\n      saveUserProfile(null);\n    } else if (isPlainObject(allData.userProfile)) {\n      const profile = normalizeUserProfile(allData.userProfile);\n      if (profile) {\n        saveUserProfile(profile);\n      } else {\n        saveUserProfile(null);\n      }\n    }\n  }\n  if (isPlainObject(allData.preferences)) {\n    const prefs = allData.preferences;\n    const booleanPrefs = [\n      'darkMode',\n      'pinkMode',\n      'highContrast',\n      'reduceMotion',\n      'relaxedSpacing',\n      'showAutoBackups',\n      'iosPwaHelpShown',\n    ];\n    booleanPrefs.forEach((key) => {\n      if (Object.prototype.hasOwnProperty.call(prefs, key) && typeof prefs[key] === 'boolean') {\n        safeSetLocalStorage(key, prefs[key]);\n      }\n    });\n    const stringPrefs = ['accentColor', 'fontSize', 'fontFamily', 'language'];\n    stringPrefs.forEach((key) => {\n      if (Object.prototype.hasOwnProperty.call(prefs, key)) {\n        const value = prefs[key];\n        if (typeof value === 'string' && value) {\n          safeSetLocalStorage(key, value);\n        }\n      }\n    });\n\n    if (Object.prototype.hasOwnProperty.call(prefs, 'temperatureUnit')) {\n      const unit = prefs.temperatureUnit;\n      if (typeof unit === 'string') {\n        const normalizedUnit = unit.trim();\n        if (normalizedUnit) {\n          safeSetLocalStorage(TEMPERATURE_UNIT_STORAGE_KEY_NAME, normalizedUnit);\n        }\n      } else if (unit === null) {\n        safeSetLocalStorage(TEMPERATURE_UNIT_STORAGE_KEY_NAME, null);\n      }\n    }\n    if (Object.prototype.hasOwnProperty.call(prefs, 'focusScale')) {\n      const scale = prefs.focusScale;\n      if (typeof scale === 'string') {\n        const normalizedScale = scale.trim();\n        if (normalizedScale) {\n          safeSetLocalStorage(FOCUS_SCALE_STORAGE_KEY_NAME, normalizedScale);\n          if (typeof window !== 'undefined' && typeof window.applyFocusScalePreference === 'function') {\n            try {\n              window.applyFocusScalePreference(normalizedScale, { persist: false, forceUpdate: true });\n            } catch (focusScaleError) {\n              console.warn('Unable to apply imported focus scale preference', focusScaleError);\n            }\n          }\n        }\n      } else if (scale === null) {\n        safeSetLocalStorage(FOCUS_SCALE_STORAGE_KEY_NAME, null);\n      }\n    }\n    if (Object.prototype.hasOwnProperty.call(prefs, PRINT_PREFERENCES_STORAGE_KEY)) {\n      const rawPrintPreferences = prefs[PRINT_PREFERENCES_STORAGE_KEY];\n      if (rawPrintPreferences === null) {\n        safeSetLocalStorage(PRINT_PREFERENCES_STORAGE_KEY, null);\n      } else {\n        const interpretedPreferences = interpretPrintPreferencesValue(rawPrintPreferences);\n        if (interpretedPreferences) {\n          if (interpretedPreferences.normalized) {\n            const normalizedPrintPreferences = storageJsonDeepClone(\n              interpretedPreferences.normalized,\n            );\n            let serializedPrintPreferences = null;\n            try {\n              serializedPrintPreferences = JSON.stringify(normalizedPrintPreferences);\n            } catch (printPreferenceSerializationError) {\n              console.warn(\n                'Unable to serialize imported print preferences',\n                printPreferenceSerializationError,\n              );\n              serializedPrintPreferences = null;\n            }\n            if (serializedPrintPreferences !== null) {\n              try {\n                safeSetLocalStorage(PRINT_PREFERENCES_STORAGE_KEY, serializedPrintPreferences);\n              } catch (printPreferencePersistError) {\n                console.warn(\n                  'Unable to persist imported print preferences',\n                  printPreferencePersistError,\n                );\n              }\n            }\n            if (typeof window !== 'undefined' && typeof window.savePrintPreferences === 'function') {\n              try {\n                window.savePrintPreferences(normalizedPrintPreferences);\n              } catch (printPreferenceApplyError) {\n                console.warn(\n                  'Unable to apply imported print preferences',\n                  printPreferenceApplyError,\n                );\n              }\n            }\n          } else if (interpretedPreferences.serialized) {\n            try {\n              safeSetLocalStorage(\n                PRINT_PREFERENCES_STORAGE_KEY,\n                interpretedPreferences.serialized,\n              );\n            } catch (printPreferenceStringPersistError) {\n              console.warn(\n                'Unable to store imported print preferences string value',\n                printPreferenceStringPersistError,\n              );\n            }\n          }\n        }\n      }\n    }\n    if (Object.prototype.hasOwnProperty.call(prefs, 'mountVoltages')) {\n      const rawVoltages = prefs.mountVoltages;\n      if (rawVoltages && typeof rawVoltages === 'object') {\n        try {\n          safeSetLocalStorage(mountVoltageKeyName, JSON.stringify(rawVoltages));\n        } catch (voltStoreError) {\n          console.warn('Unable to store imported mount voltages', voltStoreError);\n        }\n        if (typeof window !== 'undefined' && typeof window.applyMountVoltagePreferences === 'function') {\n          window.applyMountVoltagePreferences(rawVoltages, { persist: false, triggerUpdate: true });\n        }\n      } else if (typeof rawVoltages === 'string') {\n        safeSetLocalStorage(mountVoltageKeyName, rawVoltages);\n        if (typeof window !== 'undefined' && typeof window.parseStoredMountVoltages === 'function') {\n          try {\n            const parsedVoltages = window.parseStoredMountVoltages(rawVoltages);\n            if (parsedVoltages && typeof window.applyMountVoltagePreferences === 'function') {\n              window.applyMountVoltagePreferences(parsedVoltages, { persist: false, triggerUpdate: true });\n            }\n          } catch (voltParseError) {\n            console.warn('Unable to parse imported mount voltages', voltParseError);\n          }\n        }\n      } else if (rawVoltages === null) {\n        safeSetLocalStorage(mountVoltageKeyName, null);\n        if (typeof window !== 'undefined' && typeof window.resetMountVoltagePreferences === 'function') {\n          window.resetMountVoltagePreferences({ persist: false, triggerUpdate: true });\n        }\n      }\n    }\n    if (Object.prototype.hasOwnProperty.call(prefs, 'cameraColors')) {\n      const rawCameraColors = prefs.cameraColors;\n      const applyImportedCameraColors = (palette) => {\n        if (!palette || typeof palette !== 'object') {\n          return false;\n        }\n\n        let applied = false;\n        if (typeof window !== 'undefined' && window && typeof window.setCameraLetterColors === 'function') {\n          try {\n            window.setCameraLetterColors(palette);\n            applied = true;\n          } catch (cameraColorApplyError) {\n            console.warn('Unable to apply imported camera color preferences', cameraColorApplyError);\n            applied = false;\n          }\n        }\n\n        let serializedPalette = null;\n        try {\n          serializedPalette = JSON.stringify(palette);\n        } catch (cameraColorSerializeError) {\n          console.warn('Unable to serialize imported camera color preferences', cameraColorSerializeError);\n          serializedPalette = null;\n        }\n\n        if (serializedPalette) {\n          try {\n            safeSetLocalStorage(cameraColorKeyName, serializedPalette);\n          } catch (cameraColorPersistError) {\n            console.warn('Unable to persist imported camera color preferences', cameraColorPersistError);\n          }\n        }\n\n        return applied;\n      };\n\n      if (rawCameraColors && typeof rawCameraColors === 'object') {\n        applyImportedCameraColors(rawCameraColors);\n      } else if (typeof rawCameraColors === 'string') {\n        const trimmedCameraColors = rawCameraColors.trim();\n        if (trimmedCameraColors) {\n          let parsedCameraColors = null;\n          try {\n            parsedCameraColors = JSON.parse(trimmedCameraColors);\n          } catch (cameraColorParseError) {\n            console.warn('Unable to parse imported camera color palette', cameraColorParseError);\n            parsedCameraColors = null;\n          }\n          if (parsedCameraColors && typeof parsedCameraColors === 'object') {\n            applyImportedCameraColors(parsedCameraColors);\n          } else {\n            try {\n              safeSetLocalStorage(cameraColorKeyName, trimmedCameraColors);\n            } catch (cameraColorStoreError) {\n              console.warn('Unable to store raw imported camera color palette', cameraColorStoreError);\n            }\n          }\n        }\n      } else if (rawCameraColors === null) {\n        safeSetLocalStorage(cameraColorKeyName, null);\n      }\n    }\n  }\n  if (Object.prototype.hasOwnProperty.call(allData, 'customLogo')) {\n    const logo = allData.customLogo;\n    if (typeof logo === 'string' && logo) {\n      safeSetLocalStorage(CUSTOM_LOGO_STORAGE_KEY, logo);\n    } else {\n      safeSetLocalStorage(CUSTOM_LOGO_STORAGE_KEY, null);\n    }\n  }\n  if (Object.prototype.hasOwnProperty.call(allData, 'customFonts')) {\n    const fonts = normalizeCustomFontEntries(allData.customFonts);\n    if (fonts.length) {\n      try {\n        safeSetLocalStorage(\n          getCustomFontStorageKeyName(),\n          JSON.stringify(fonts)\n        );\n      } catch (error) {\n        console.warn('Unable to store imported custom fonts', error);\n      }\n    } else {\n      safeSetLocalStorage(getCustomFontStorageKeyName(), null);\n    }\n  }\n  if (Object.prototype.hasOwnProperty.call(allData, 'schemaCache')) {\n    const cache = allData.schemaCache;\n    if (typeof cache === 'string' || cache === null) {\n      safeSetLocalStorage(DEVICE_SCHEMA_CACHE_KEY, cache);\n    } else if (cache && typeof cache === 'object') {\n      try {\n        safeSetLocalStorage(DEVICE_SCHEMA_CACHE_KEY, JSON.stringify(cache));\n      } catch (schemaError) {\n        console.warn('Unable to store imported schema cache', schemaError);\n      }\n    }\n  }\n  if (Object.prototype.hasOwnProperty.call(allData, 'documentationTracker')) {\n    const trackerState = normalizeDocumentationTrackerState(allData.documentationTracker);\n    saveDocumentationTracker(trackerState);\n  } else if (Object.prototype.hasOwnProperty.call(allData, 'documentationLogs')) {\n    const trackerFromLogs = normalizeDocumentationTrackerState({ releases: allData.documentationLogs });\n    saveDocumentationTracker(trackerFromLogs);\n  } else if (Object.prototype.hasOwnProperty.call(allData, 'documentationUpdateLog')) {\n    const trackerFromLegacy = normalizeDocumentationTrackerState(allData.documentationUpdateLog);\n    saveDocumentationTracker(trackerFromLegacy);\n  }\n  if (Object.prototype.hasOwnProperty.call(allData, 'autoGearRules')) {\n    const rules = normalizeImportedAutoGearRules(allData.autoGearRules);\n    saveAutoGearRules(rules);\n  }\n  if (Object.prototype.hasOwnProperty.call(allData, 'autoGearBackups')) {\n    const backups = normalizeImportedAutoGearBackups(allData.autoGearBackups);\n    saveAutoGearBackups(backups);\n  }\n  if (Object.prototype.hasOwnProperty.call(allData, 'autoGearSeeded')) {\n    const flag = normalizeImportedBoolean(allData.autoGearSeeded);\n    if (flag === null) {\n      saveAutoGearSeedFlag(false);\n    } else {\n      saveAutoGearSeedFlag(flag);\n    }\n  }\n  if (Object.prototype.hasOwnProperty.call(allData, 'autoGearPresets')) {\n    const presets = normalizeImportedAutoGearPresets(allData.autoGearPresets);\n    saveAutoGearPresets(presets);\n  }\n  if (Object.prototype.hasOwnProperty.call(allData, 'autoGearMonitorDefaults')) {\n    const defaults = normalizeImportedAutoGearMonitorDefaults(allData.autoGearMonitorDefaults);\n    saveAutoGearMonitorDefaults(defaults);\n  }\n  if (Object.prototype.hasOwnProperty.call(allData, 'autoGearActivePresetId')) {\n    const presetId = normalizeImportedPresetId(allData.autoGearActivePresetId);\n    saveAutoGearActivePresetId(typeof presetId === 'string' ? presetId : '');\n  }\n  if (Object.prototype.hasOwnProperty.call(allData, 'autoGearAutoPresetId')) {\n    saveAutoGearAutoPresetId(\n      typeof allData.autoGearAutoPresetId === 'string' ? allData.autoGearAutoPresetId : ''\n    );\n  }\n  if (Object.prototype.hasOwnProperty.call(allData, 'autoGearShowBackups')) {\n    const visibility = normalizeImportedBoolean(allData.autoGearShowBackups);\n    if (visibility === null) {\n      saveAutoGearBackupVisibility(false);\n    } else {\n      saveAutoGearBackupVisibility(visibility);\n    }\n  }\n  if (Object.prototype.hasOwnProperty.call(allData, 'autoGearBackupRetention')) {\n    const retention = normalizeImportedAutoGearBackupRetention(allData.autoGearBackupRetention);\n    if (typeof retention === 'number' && Number.isFinite(retention)) {\n      saveAutoGearBackupRetention(retention);\n    }\n  }\n\n  if (Object.prototype.hasOwnProperty.call(allData, 'fullBackupHistory')) {\n    const history = normalizeImportedFullBackupHistory(allData.fullBackupHistory);\n    saveFullBackupHistory(history);\n  } else if (Object.prototype.hasOwnProperty.call(allData, 'fullBackups')) {\n    const history = normalizeImportedFullBackupHistory(allData.fullBackups);\n    saveFullBackupHistory(history);\n  }\n  if (Object.prototype.hasOwnProperty.call(allData, 'backupVaultRecords')) {\n    const backupRecords = normalizeImportedBackupVaultRecords(allData.backupVaultRecords);\n    importBackupVaultRecords(backupRecords);\n  } else if (Object.prototype.hasOwnProperty.call(allData, 'backupVault')) {\n    const backupRecords = normalizeImportedBackupVaultRecords(allData.backupVault);\n    importBackupVaultRecords(backupRecords);\n  }\n\n  let importProjectEntry = null;\n  const ensureProjectImporter = () => {\n    if (!importProjectEntry) {\n      importProjectEntry = createProjectImporter();\n    }\n    return importProjectEntry;\n  };\n\n  let projectImported = false;\n  const getTrackedImporter = () => {\n    const importer = ensureProjectImporter();\n    return (name, project, fallback) => {\n      projectImported = true;\n      importer(name, project, fallback);\n    };\n  };\n\n  const importTrackedCollection = (collection, fallbackLabel) => {\n    const wrapped = () => getTrackedImporter();\n    const result = importProjectCollection(collection, wrapped, fallbackLabel);\n    if (result) {\n      projectImported = true;\n    }\n    return result;\n  };\n\n  if (allData.project) {\n    importTrackedCollection(allData.project, \"\");\n  }\n  if (allData.projects) {\n    // Legacy plural key. Accept object map or array of named projects.\n    importTrackedCollection(allData.projects);\n  } else if (!allData.project && typeof allData.gearList === \"string\") {\n    // Legacy export format stored just the gear list HTML\n    getTrackedImporter()(\"\", { gearList: allData.gearList });\n    projectImported = true;\n  }\n\n  if (!projectImported) {\n    const legacyCollections = collectLegacyProjectCollections(allData);\n    legacyCollections.forEach((collection, index) => {\n      if (collection && typeof collection === \"object\" && !Array.isArray(collection)) {\n        const normalized = isNormalizedProjectEntry(collection)\n          ? collection\n          : normalizeProject(collection);\n        if (normalized && isNormalizedProjectEntry(normalized)) {\n          getTrackedImporter()(\"\", normalized, `Imported project ${index + 1}`);\n          projectImported = true;\n          return;\n        }\n      }\n\n      const imported = importProjectCollection(\n        collection,\n        () => getTrackedImporter(),\n        `Imported project ${index + 1}`,\n      );\n      if (imported) {\n        projectImported = true;\n      }\n    });\n  }\n}\n\n\n/**\n * Expose internal project cache for synchronous reads (LegacyShim support)\n */\nfunction getProjectMemoryCache() {\n  return projectMemoryCache;\n}\n\nvar STORAGE_API = {\n  getSafeLocalStorage,\n  loadDeviceData,\n  saveDeviceData,\n  loadSetups,\n  saveSetups,\n  saveSetup,\n  loadSetup,\n  deleteSetup,\n  renameSetup,\n  safeSetLocalStorage,\n  readLocalStorageValue,\n  getMountVoltageStorageKeyName,\n  getMountVoltageStorageBackupKeyName,\n  getProjectStorageRevisionKeyName,\n  loadProjectStorageRevision,\n  loadProject,\n  loadProjectMetadata,\n  saveProject,\n  deleteProject,\n  renameProject,\n  createProjectDeletionBackup,\n  loadSessionState,\n  saveSessionState,\n  loadFavorites,\n  saveFavorites,\n  loadContacts,\n  saveContacts,\n  loadOwnGear,\n  saveOwnGear,\n  loadUserProfile,\n  saveUserProfile,\n  loadDocumentationTracker,\n  saveDocumentationTracker,\n  loadAutoGearBackups,\n  saveAutoGearBackups,\n  loadFeedback,\n  saveFeedback,\n  clearAllData,\n  exportAllData,\n  prepareBackupForExport,\n  importAllData,\n  loadAutoGearRules,\n  saveAutoGearRules,\n  loadAutoGearSeedFlag,\n  saveAutoGearSeedFlag,\n  loadAutoGearPresets,\n  saveAutoGearPresets,\n  loadAutoGearMonitorDefaults,\n  saveAutoGearMonitorDefaults,\n  loadAutoGearActivePresetId,\n  saveAutoGearActivePresetId,\n  loadAutoGearAutoPresetId,\n  saveAutoGearAutoPresetId,\n  loadAutoGearBackupVisibility,\n  saveAutoGearBackupVisibility,\n  loadAutoGearBackupRetention,\n  saveAutoGearBackupRetention,\n  getAutoGearBackupRetentionDefault,\n  loadFullBackupHistory,\n  saveFullBackupHistory,\n  recordFullBackupHistoryEntry,\n  requestPersistentStorage,\n  clearUiCacheStorageEntries,\n  ensureCriticalStorageBackups,\n  getLastCriticalStorageGuardResult,\n  decodeStoredValue,\n  getCompressionLogSnapshot,\n  setActiveProjectCompressionHold,\n  clearActiveProjectCompressionHold,\n  invalidateProjectReadCache,\n  getProjectMemoryCache,\n  storageRepo,\n};\n\nvar TEST_ONLY_AUTO_BACKUP_COMPRESSION_CACHE = {\n  flag: AUTO_BACKUP_PAYLOAD_COMPRESSION_FLAG,\n  read: readAutoBackupCompressionCache,\n  write: writeAutoBackupCompressionCache,\n  clear: resetAutoBackupCompressionCache,\n};\n\ntry {\n  Object.defineProperty(STORAGE_API, '__testAutoBackupCompressionCache', {\n    configurable: false,\n    enumerable: false,\n    writable: false,\n    value: TEST_ONLY_AUTO_BACKUP_COMPRESSION_CACHE,\n  });\n} catch (testHelperDefinitionError) {\n  STORAGE_API.__testAutoBackupCompressionCache = TEST_ONLY_AUTO_BACKUP_COMPRESSION_CACHE;\n  void testHelperDefinitionError;\n}\n\nif (typeof module !== \"undefined\" && module.exports) {\n  module.exports = STORAGE_API;\n}\n\nconsole.log('DEBUG: storage.js: starting global export loop');\nif (GLOBAL_SCOPE && typeof GLOBAL_SCOPE === 'object') {\n\n  Object.keys(STORAGE_API).forEach((key) => {\n    const value = STORAGE_API[key];\n    if (typeof value !== 'function') {\n      return;\n    }\n    if (typeof GLOBAL_SCOPE[key] === 'function') {\n      return;\n    }\n    try {\n      GLOBAL_SCOPE[key] = value;\n    } catch (assignmentError) {\n      void assignmentError;\n      try {\n        Object.defineProperty(GLOBAL_SCOPE, key, {\n          configurable: true,\n          writable: true,\n          value,\n        });\n      } catch (definitionError) {\n        if (typeof console !== 'undefined' && typeof console.warn === 'function') {\n          console.warn(`Unable to expose storage helper ${key} globally.`, definitionError);\n        }\n      }\n    }\n  });\n\n  try {\n    if (typeof GLOBAL_SCOPE.recordFullBackupHistoryEntry !== 'function') {\n      GLOBAL_SCOPE.recordFullBackupHistoryEntry = recordFullBackupHistoryEntry;\n    }\n    if (typeof GLOBAL_SCOPE.loadFullBackupHistory !== 'function') {\n      GLOBAL_SCOPE.loadFullBackupHistory = loadFullBackupHistory;\n    }\n  } catch (ex) {\n    void ex;\n  }\n}\n\nif (GLOBAL_SCOPE) {\n  try {\n    Object.defineProperty(GLOBAL_SCOPE, '__cineStorageApi', {\n      configurable: true,\n      writable: true,\n      value: STORAGE_API,\n    });\n  } catch (storageApiExposeError) {\n    GLOBAL_SCOPE.__cineStorageApi = STORAGE_API;\n    void storageApiExposeError;\n  }\n}\n\nconsole.log('DEBUG: storage.js execution finished');\n// }) ();\n\nexport const cineStorage = STORAGE_API;\nexport default STORAGE_API;\n","/**\n * The persistence module centralises every interaction with the underlying\n * storage helpers. The goal is to make it obvious which execution context is\n * currently responsible for safeguarding the project data. By explaining each\n * discovery step we help future maintainers reason about why data looks for a\n * specific bridge or linker before touching user content.\n */\n\nimport cineModules from './registry.js';\nimport * as cineStorage from '../storage.js';\nimport { detectGlobalScope } from './helpers/scope-utils.js';\n\n/**\n * DEEP DIVE: Persistence Layer vs Storage Layer\n *\n * It is crucial to distinguish `persistence.js` from `storage.js`:\n *\n * 1. storage.js (The \"Driver\"):\n *    - Handles raw I/O (localStorage.getItem, JSON.parse).\n *    - Doesn't know *when* or *why* to save, only *how*.\n *\n * 2. persistence.js (The \"Manager\"):\n *    - Defines the POLICY (Auto-save on change? Throttle saves? Retry on failure?).\n *    - Orchestrates the flow between the application state and the storage driver.\n *    - Handles cross-cutting concerns like migration triggers and error boundaries.\n */\nconst FALLBACK_SCOPE = detectGlobalScope();\n\n/**\n * Locate the module linker that wires the loosely coupled runtime together.\n * We rely on global scope injection for legacy linker support.\n */\nfunction resolveModuleLinker(scope) {\n  const candidates = [scope];\n  if (typeof globalThis !== 'undefined' && candidates.indexOf(globalThis) === -1) candidates.push(globalThis);\n  if (typeof window !== 'undefined' && candidates.indexOf(window) === -1) candidates.push(window);\n  if (typeof self !== 'undefined' && candidates.indexOf(self) === -1) candidates.push(self);\n  if (typeof global !== 'undefined' && candidates.indexOf(global) === -1) candidates.push(global);\n\n  for (let index = 0; index < candidates.length; index += 1) {\n    const candidate = candidates[index];\n    try {\n      const linker = candidate && candidate.cineModuleLinker;\n      if (linker && typeof linker === 'object') {\n        return linker;\n      }\n    } catch (error) {\n      void error;\n    }\n  }\n\n  return null;\n}\n\n/**\n * If the linker cannot provide an environment instance we still want to keep\n * the storage layer operational. The fallback loader walks through familiar\n * scopes and reuses the environment that was already injected there.\n */\nfunction fallbackLoadModuleEnvironment(scope) {\n  const candidates = [scope];\n  if (typeof globalThis !== 'undefined' && candidates.indexOf(globalThis) === -1) candidates.push(globalThis);\n  if (typeof window !== 'undefined' && candidates.indexOf(window) === -1) candidates.push(window);\n  if (typeof self !== 'undefined' && candidates.indexOf(self) === -1) candidates.push(self);\n  if (typeof global !== 'undefined' && candidates.indexOf(global) === -1) candidates.push(global);\n\n  for (let index = 0; index < candidates.length; index += 1) {\n    const candidate = candidates[index];\n    if (candidate && typeof candidate.cineModuleEnvironment === 'object') {\n      return candidate.cineModuleEnvironment;\n    }\n  }\n\n  return null;\n}\n\n/**\n * The environment bridge contains helpers for cross-context communication.\n * When it is not injected by the linker we replicate the same discovery\n * strategy as with the environment itself so offline mode keeps functioning.\n */\nfunction fallbackLoadEnvironmentBridge(scope) {\n  const candidates = [scope];\n  if (typeof globalThis !== 'undefined' && candidates.indexOf(globalThis) === -1) candidates.push(globalThis);\n  if (typeof window !== 'undefined' && candidates.indexOf(window) === -1) candidates.push(window);\n  if (typeof self !== 'undefined' && candidates.indexOf(self) === -1) candidates.push(self);\n  if (typeof global !== 'undefined' && candidates.indexOf(global) === -1) candidates.push(global);\n\n  for (let index = 0; index < candidates.length; index += 1) {\n    const candidate = candidates[index];\n    if (candidate && typeof candidate.cineEnvironmentBridge === 'object') {\n      return candidate.cineEnvironmentBridge;\n    }\n  }\n\n  return null;\n}\n\nconst MODULE_LINKER = resolveModuleLinker(FALLBACK_SCOPE);\n\nconst MODULE_ENV = MODULE_LINKER && typeof MODULE_LINKER.getModuleEnvironment === 'function'\n  ? MODULE_LINKER.getModuleEnvironment()\n  : fallbackLoadModuleEnvironment(FALLBACK_SCOPE);\n\nconst ENV_BRIDGE = MODULE_LINKER && typeof MODULE_LINKER.getEnvironmentBridge === 'function'\n  ? MODULE_LINKER.getEnvironmentBridge()\n  : fallbackLoadEnvironmentBridge(FALLBACK_SCOPE);\n\nconst GLOBAL_SCOPE = (MODULE_LINKER && typeof MODULE_LINKER.getGlobalScope === 'function'\n  ? MODULE_LINKER.getGlobalScope()\n  : null)\n  || (ENV_BRIDGE && typeof ENV_BRIDGE.getGlobalScope === 'function'\n    ? ENV_BRIDGE.getGlobalScope()\n    : null)\n  || (MODULE_ENV && typeof MODULE_ENV.getGlobalScope === 'function'\n    ? MODULE_ENV.getGlobalScope()\n    : null)\n  || FALLBACK_SCOPE;\n\n/**\n * Module globals store shared singletons such as the persistence registry.\n * Accessing them through this helper keeps accidental global mutations away\n * from user projects because we never touch a missing object directly.\n */\nfunction fallbackResolveModuleGlobals() {\n  const candidates = [GLOBAL_SCOPE];\n  if (typeof globalThis !== 'undefined' && candidates.indexOf(globalThis) === -1) candidates.push(globalThis);\n  if (typeof window !== 'undefined' && candidates.indexOf(window) === -1) candidates.push(window);\n  if (typeof self !== 'undefined' && candidates.indexOf(self) === -1) candidates.push(self);\n  if (typeof global !== 'undefined' && candidates.indexOf(global) === -1) candidates.push(global);\n\n  for (let index = 0; index < candidates.length; index += 1) {\n    const candidate = candidates[index];\n    if (candidate && typeof candidate.cineModuleGlobals === 'object') {\n      return candidate.cineModuleGlobals;\n    }\n  }\n\n  return null;\n}\n\nconst MODULE_GLOBALS = (MODULE_LINKER && typeof MODULE_LINKER.getModuleGlobals === 'function'\n  ? MODULE_LINKER.getModuleGlobals()\n  : null)\n  || fallbackResolveModuleGlobals();\n\n/**\n * Let the runtime know which APIs are available so other modules can reuse\n * them without creating duplicate instances. The explicit guard rails ensure\n * the registration is a no-op when the host does not support bookkeeping.\n */\nfunction informModuleGlobals(name, api) {\n  if (MODULE_LINKER && typeof MODULE_LINKER.recordModule === 'function') {\n    MODULE_LINKER.recordModule(name, api);\n  }\n\n  if (!MODULE_GLOBALS || typeof MODULE_GLOBALS.recordModule !== 'function') {\n    return;\n  }\n\n  try {\n    MODULE_GLOBALS.recordModule(name, api);\n  } catch (error) {\n    void error;\n  }\n}\n\nfunction fallbackTryRequire(modulePath) {\n  // ESM cannot support synchronous dynamic require.\n  // This fallback assumes the module is not available if not imported via ESM.\n  return null;\n}\n\nconst tryRequire = (function resolveTryRequire() {\n  if (MODULE_LINKER && typeof MODULE_LINKER.tryRequire === 'function') {\n    return MODULE_LINKER.tryRequire;\n  }\n\n  if (MODULE_GLOBALS && typeof MODULE_GLOBALS.tryRequire === 'function') {\n    return MODULE_GLOBALS.tryRequire;\n  }\n\n  if (ENV_BRIDGE && typeof ENV_BRIDGE.tryRequire === 'function') {\n    return function bridgeTryRequire(modulePath) {\n      const result = ENV_BRIDGE.tryRequire(modulePath);\n      return typeof result === 'undefined' ? fallbackTryRequire(modulePath) : result;\n    };\n  }\n\n  if (MODULE_ENV && typeof MODULE_ENV.tryRequire === 'function') {\n    return MODULE_ENV.tryRequire;\n  }\n\n  return fallbackTryRequire;\n})();\n\nfunction resolveModuleRegistry(scope) {\n  const targetScope = scope || GLOBAL_SCOPE;\n\n  if (MODULE_LINKER && typeof MODULE_LINKER.getModuleRegistry === 'function') {\n    const linked = MODULE_LINKER.getModuleRegistry(targetScope);\n    if (linked) {\n      return linked;\n    }\n  }\n\n  if (MODULE_GLOBALS && typeof MODULE_GLOBALS.resolveModuleRegistry === 'function') {\n    try {\n      const resolved = MODULE_GLOBALS.resolveModuleRegistry(targetScope);\n      if (resolved) {\n        return resolved;\n      }\n    } catch (error) {\n      void error;\n    }\n  }\n\n  if (ENV_BRIDGE && typeof ENV_BRIDGE.getModuleRegistry === 'function') {\n    try {\n      const bridged = ENV_BRIDGE.getModuleRegistry(targetScope);\n      if (bridged) {\n        return bridged;\n      }\n    } catch (error) {\n      void error;\n    }\n  }\n\n  if (MODULE_ENV && typeof MODULE_ENV.resolveModuleRegistry === 'function') {\n    try {\n      const provided = MODULE_ENV.resolveModuleRegistry(targetScope);\n      if (provided) {\n        return provided;\n      }\n    } catch (error) {\n      void error;\n    }\n  }\n\n  // Use imported cineModules if available\n  if (cineModules && typeof cineModules === 'object') {\n    return cineModules;\n  }\n\n\n  const scopes = [targetScope];\n  if (typeof globalThis !== 'undefined' && scopes.indexOf(globalThis) === -1) scopes.push(globalThis);\n  if (typeof window !== 'undefined' && scopes.indexOf(window) === -1) scopes.push(window);\n  if (typeof self !== 'undefined' && scopes.indexOf(self) === -1) scopes.push(self);\n  if (typeof global !== 'undefined' && scopes.indexOf(global) === -1) scopes.push(global);\n\n  for (let index = 0; index < scopes.length; index += 1) {\n    const candidate = scopes[index];\n    if (candidate && typeof candidate.cineModules === 'object') {\n      return candidate.cineModules;\n    }\n  }\n\n  return null;\n}\n\nconst MODULE_REGISTRY = (function () {\n  if (MODULE_LINKER && typeof MODULE_LINKER.getModuleRegistry === 'function') {\n    const linkedRegistry = MODULE_LINKER.getModuleRegistry(GLOBAL_SCOPE);\n    if (linkedRegistry) {\n      return linkedRegistry;\n    }\n  }\n\n  if (MODULE_GLOBALS && typeof MODULE_GLOBALS.getModuleRegistry === 'function') {\n    try {\n      const shared = MODULE_GLOBALS.getModuleRegistry(GLOBAL_SCOPE);\n      if (shared) {\n        return shared;\n      }\n    } catch (error) {\n      void error;\n    }\n  }\n\n  if (ENV_BRIDGE && typeof ENV_BRIDGE.getModuleRegistry === 'function') {\n    try {\n      const bridged = ENV_BRIDGE.getModuleRegistry(GLOBAL_SCOPE);\n      if (bridged) {\n        return bridged;\n      }\n    } catch (error) {\n      void error;\n    }\n  }\n\n  if (MODULE_ENV && typeof MODULE_ENV.getModuleRegistry === 'function') {\n    try {\n      const provided = MODULE_ENV.getModuleRegistry(GLOBAL_SCOPE);\n      if (provided) {\n        return provided;\n      }\n    } catch (error) {\n      void error;\n    }\n  }\n\n  return resolveModuleRegistry(GLOBAL_SCOPE);\n})();\n\nconst PENDING_QUEUE_KEY = (function resolvePendingKey() {\n  if (MODULE_LINKER && typeof MODULE_LINKER.getPendingQueueKey === 'function') {\n    const linkedKey = MODULE_LINKER.getPendingQueueKey();\n    if (typeof linkedKey === 'string' && linkedKey) {\n      return linkedKey;\n    }\n  }\n\n  if (MODULE_GLOBALS && typeof MODULE_GLOBALS.getPendingQueueKey === 'function') {\n    try {\n      const sharedKey = MODULE_GLOBALS.getPendingQueueKey();\n      if (typeof sharedKey === 'string' && sharedKey) {\n        return sharedKey;\n      }\n    } catch (error) {\n      void error;\n    }\n  }\n\n  if (ENV_BRIDGE && typeof ENV_BRIDGE.getPendingQueueKey === 'function') {\n    try {\n      const bridgedKey = ENV_BRIDGE.getPendingQueueKey();\n      if (typeof bridgedKey === 'string' && bridgedKey) {\n        return bridgedKey;\n      }\n    } catch (error) {\n      void error;\n    }\n  }\n\n  if (MODULE_ENV && typeof MODULE_ENV.PENDING_QUEUE_KEY === 'string') {\n    return MODULE_ENV.PENDING_QUEUE_KEY;\n  }\n\n  return '__cinePendingModuleRegistrations__';\n})();\n\nfunction cloneOptions(options) {\n  if (!options || typeof options !== 'object') {\n    return {};\n  }\n\n  const copy = {};\n  const keys = Object.keys(options);\n  for (let index = 0; index < keys.length; index += 1) {\n    const key = keys[index];\n    copy[key] = options[key];\n  }\n\n  return copy;\n}\n\nfunction queueModuleRegistration(name, api, options) {\n  if (MODULE_GLOBALS && typeof MODULE_GLOBALS.queueModuleRegistration === 'function') {\n    try {\n      if (MODULE_GLOBALS.queueModuleRegistration(name, api, options, GLOBAL_SCOPE)) {\n        return true;\n      }\n    } catch (error) {\n      void error;\n    }\n  }\n\n  if (ENV_BRIDGE && typeof ENV_BRIDGE.queueModuleRegistration === 'function') {\n    try {\n      const bridged = ENV_BRIDGE.queueModuleRegistration(name, api, options);\n      if (bridged) {\n        return true;\n      }\n    } catch (error) {\n      void error;\n    }\n  }\n\n  if (MODULE_ENV && typeof MODULE_ENV.queueModuleRegistration === 'function') {\n    return MODULE_ENV.queueModuleRegistration(name, api, options, GLOBAL_SCOPE);\n  }\n\n  if (!GLOBAL_SCOPE || typeof GLOBAL_SCOPE !== 'object') {\n    return false;\n  }\n\n  const payload = Object.freeze({\n    name,\n    api,\n    options: Object.freeze(cloneOptions(options)),\n  });\n\n  let queue = GLOBAL_SCOPE[PENDING_QUEUE_KEY];\n  if (!Array.isArray(queue)) {\n    try {\n      Object.defineProperty(GLOBAL_SCOPE, PENDING_QUEUE_KEY, {\n        configurable: true,\n        enumerable: false,\n        writable: true,\n        value: [],\n      });\n      queue = GLOBAL_SCOPE[PENDING_QUEUE_KEY];\n    } catch (error) {\n      void error;\n      try {\n        if (!Array.isArray(GLOBAL_SCOPE[PENDING_QUEUE_KEY])) {\n          GLOBAL_SCOPE[PENDING_QUEUE_KEY] = [];\n        }\n        queue = GLOBAL_SCOPE[PENDING_QUEUE_KEY];\n      } catch (assignmentError) {\n        void assignmentError;\n        return false;\n      }\n    }\n  }\n\n  try {\n    queue.push(payload);\n  } catch (error) {\n    void error;\n    queue[queue.length] = payload;\n  }\n\n  return true;\n}\n\nfunction fallbackRegisterOrQueue(name, api, options, onError) {\n  if (MODULE_REGISTRY && typeof MODULE_REGISTRY.register === 'function') {\n    try {\n      MODULE_REGISTRY.register(name, api, options);\n      return true;\n    } catch (error) {\n      if (typeof onError === 'function') {\n        try {\n          onError(error);\n        } catch (callbackError) {\n          void callbackError;\n        }\n      } else {\n        void error;\n      }\n    }\n  }\n\n  queueModuleRegistration(name, api, options);\n  return false;\n}\n\nconst registerOrQueueModule = (function resolveRegisterOrQueue() {\n  if (MODULE_GLOBALS && typeof MODULE_GLOBALS.registerOrQueueModule === 'function') {\n    return function registerOrQueueModule(name, api, options, onError) {\n      try {\n        const registered = MODULE_GLOBALS.registerOrQueueModule(\n          name,\n          api,\n          options,\n          onError,\n          GLOBAL_SCOPE,\n          MODULE_REGISTRY,\n        );\n        if (registered) {\n          return true;\n        }\n      } catch (error) {\n        void error;\n      }\n\n      return fallbackRegisterOrQueue(name, api, options, onError);\n    };\n  }\n\n  if (ENV_BRIDGE && typeof ENV_BRIDGE.registerOrQueueModule === 'function') {\n    return function registerOrQueueModule(name, api, options, onError) {\n      try {\n        const bridged = ENV_BRIDGE.registerOrQueueModule(name, api, options, onError, GLOBAL_SCOPE, MODULE_REGISTRY);\n        if (bridged) {\n          return true;\n        }\n      } catch (error) {\n        void error;\n      }\n\n      return fallbackRegisterOrQueue(name, api, options, onError);\n    };\n  }\n\n  if (MODULE_ENV && typeof MODULE_ENV.registerOrQueueModule === 'function') {\n    return function registerOrQueueModule(name, api, options, onError) {\n      return MODULE_ENV.registerOrQueueModule(name, api, options, onError, GLOBAL_SCOPE, MODULE_REGISTRY);\n    };\n  }\n\n  return fallbackRegisterOrQueue;\n})();\n\n\n\nfunction isNodeProcessReference(value) {\n  if (!value) {\n    return false;\n  }\n\n  if (typeof process === 'undefined' || !process) {\n    return false;\n  }\n\n  if (value === process) {\n    return true;\n  }\n\n  if (typeof value === 'object') {\n    try {\n      if (value.constructor && value.constructor.name === 'process') {\n        return true;\n      }\n    } catch (processInspectionError) {\n      void processInspectionError;\n    }\n\n    if (\n      typeof value.pid === 'number' &&\n      typeof value.nextTick === 'function' &&\n      typeof value.emit === 'function' &&\n      typeof value.binding === 'function'\n    ) {\n      return true;\n    }\n  }\n\n  if (typeof value === 'function') {\n    if (\n      value === process.binding ||\n      value === process._linkedBinding ||\n      value === process.dlopen\n    ) {\n      return true;\n    }\n\n    try {\n      const functionName = value.name || '';\n      if (functionName && (functionName === 'binding' || functionName === 'dlopen')) {\n        const source = Function.prototype.toString.call(value);\n        if (source && source.indexOf('[native code]') !== -1) {\n          return true;\n        }\n      }\n    } catch (functionInspectionError) {\n      void functionInspectionError;\n    }\n  }\n\n  return false;\n}\n\nfunction shouldBypassDeepFreeze(value) {\n  if (!value || typeof value === 'function' || (typeof value !== 'object' && typeof value !== 'function')) {\n    return false;\n  }\n\n  if (isNodeProcessReference(value)) {\n    return true;\n  }\n\n  if (\n    typeof process !== 'undefined' &&\n    process &&\n    process.release &&\n    process.release.name === 'node'\n  ) {\n    return true;\n  }\n\n  try {\n    if (typeof value.pipe === 'function' && typeof value.unpipe === 'function') {\n      return true;\n    }\n\n    if (typeof value.on === 'function' && typeof value.emit === 'function') {\n      if (typeof value.write === 'function' || typeof value.read === 'function') {\n        return true;\n      }\n\n      const ctorName = value.constructor && value.constructor.name;\n      if (ctorName && /Stream|Emitter|Port/i.test(ctorName)) {\n        return true;\n      }\n    }\n\n    if (typeof Symbol !== 'undefined' && value[Symbol.toStringTag]) {\n      const tag = value[Symbol.toStringTag];\n      if (typeof tag === 'string' && /Stream|Port/i.test(tag)) {\n        return true;\n      }\n    }\n  } catch (inspectionError) {\n    void inspectionError;\n  }\n\n  return false;\n}\n\nfunction fallbackResolveSeenTracker(seen) {\n  if (seen && typeof seen.has === 'function' && typeof seen.add === 'function') {\n    return seen;\n  }\n\n  if (Array.isArray(seen)) {\n    return {\n      has(value) {\n        return seen.indexOf(value) !== -1;\n      },\n      add(value) {\n        if (seen.indexOf(value) === -1) {\n          seen.push(value);\n        }\n      },\n    };\n  }\n\n  if (typeof WeakSet === 'function') {\n    try {\n      return new WeakSet();\n    } catch (trackerError) {\n      void trackerError;\n    }\n  }\n\n  const tracked = [];\n  return {\n    has(value) {\n      return tracked.indexOf(value) !== -1;\n    },\n    add(value) {\n      if (tracked.indexOf(value) === -1) {\n        tracked.push(value);\n      }\n    },\n  };\n}\n\nfunction fallbackFreezeDeep(value, seen) {\n  if (!value || typeof value === 'function' || (typeof value !== 'object' && typeof value !== 'function')) {\n    return value;\n  }\n\n  if (shouldBypassDeepFreeze(value)) {\n    return value;\n  }\n\n  if (typeof process !== 'undefined' && process && process.env && process.env.JEST_WORKER_ID) {\n    try {\n      if (typeof Object.freeze === 'function') {\n        Object.freeze(value);\n      }\n    } catch (freezeError) {\n      void freezeError;\n    }\n    return value;\n  }\n\n  const tracker = fallbackResolveSeenTracker(seen);\n\n  if (tracker.has(value)) {\n    return value;\n  }\n\n  tracker.add(value);\n\n  const keys = Object.getOwnPropertyNames(value);\n  for (let index = 0; index < keys.length; index += 1) {\n    const key = keys[index];\n    let child;\n    try {\n      child = value[key];\n    } catch (accessError) {\n      void accessError;\n      child = undefined;\n    }\n    if (!child || typeof child === 'function' || (typeof child !== 'object' && typeof child !== 'function')) {\n      continue;\n    }\n    fallbackFreezeDeep(child, tracker);\n  }\n\n  try {\n    return Object.freeze(value);\n  } catch (freezeError) {\n    void freezeError;\n    return value;\n  }\n}\n\nconst freezeDeep = (function resolveFreezeDeep() {\n  if (MODULE_GLOBALS && typeof MODULE_GLOBALS.freezeDeep === 'function') {\n    return MODULE_GLOBALS.freezeDeep;\n  }\n\n  if (ENV_BRIDGE && typeof ENV_BRIDGE.freezeDeep === 'function') {\n    return function bridgeFreezeDeep(value, seen) {\n      try {\n        return ENV_BRIDGE.freezeDeep(value, seen);\n      } catch (error) {\n        void error;\n        return fallbackFreezeDeep(value, seen);\n      }\n    };\n  }\n\n  if (MODULE_ENV && typeof MODULE_ENV.freezeDeep === 'function') {\n    return MODULE_ENV.freezeDeep;\n  }\n\n  return fallbackFreezeDeep;\n})();\n\nfunction fallbackSafeWarn(message, detail) {\n  if (typeof console === 'undefined' || typeof console.warn !== 'function') {\n    return;\n  }\n\n  try {\n    if (typeof detail === 'undefined') {\n      console.warn(message);\n    } else {\n      console.warn(message, detail);\n    }\n  } catch (error) {\n    void error;\n  }\n}\n\nconst safeWarn = (function resolveSafeWarn() {\n  if (MODULE_GLOBALS && typeof MODULE_GLOBALS.safeWarn === 'function') {\n    return MODULE_GLOBALS.safeWarn;\n  }\n\n  if (ENV_BRIDGE && typeof ENV_BRIDGE.safeWarn === 'function') {\n    return function bridgeSafeWarn(message, detail) {\n      try {\n        ENV_BRIDGE.safeWarn(message, detail);\n      } catch (error) {\n        void error;\n        fallbackSafeWarn(message, detail);\n      }\n    };\n  }\n\n  if (MODULE_ENV && typeof MODULE_ENV.safeWarn === 'function') {\n    return MODULE_ENV.safeWarn;\n  }\n\n  return fallbackSafeWarn;\n})();\n\nfunction fallbackExposeGlobal(name, value) {\n  if (!GLOBAL_SCOPE || typeof GLOBAL_SCOPE !== 'object') {\n    return false;\n  }\n  try {\n    Object.defineProperty(GLOBAL_SCOPE, name, {\n      configurable: true,\n      enumerable: false,\n      value,\n      writable: false,\n    });\n    return true;\n  } catch (error) {\n    void error;\n    try {\n      GLOBAL_SCOPE[name] = value;\n      return true;\n    } catch (assignmentError) {\n      void assignmentError;\n      return false;\n    }\n  }\n}\n\nconst exposeGlobal = (function resolveExposeGlobal() {\n  if (MODULE_GLOBALS && typeof MODULE_GLOBALS.exposeGlobal === 'function') {\n    return function moduleGlobalsExpose(name, value, options) {\n      try {\n        return MODULE_GLOBALS.exposeGlobal(name, value, options);\n      } catch (error) {\n        void error;\n        return fallbackExposeGlobal(name, value);\n      }\n    };\n  }\n\n  if (ENV_BRIDGE && typeof ENV_BRIDGE.exposeGlobal === 'function') {\n    return function bridgeExposeGlobal(name, value, options) {\n      try {\n        return ENV_BRIDGE.exposeGlobal(name, value, options);\n      } catch (error) {\n        void error;\n        return fallbackExposeGlobal(name, value);\n      }\n    };\n  }\n\n  if (MODULE_ENV && typeof MODULE_ENV.exposeGlobal === 'function') {\n    return function exposeGlobal(name, value, options) {\n      return MODULE_ENV.exposeGlobal(name, value, GLOBAL_SCOPE, options);\n    };\n  }\n\n  return fallbackExposeGlobal;\n})();\n\nconst providerModules = [];\n\nfunction addProviderModule(reference, label) {\n  if (!reference || typeof reference !== 'object') {\n    return;\n  }\n\n  providerModules.push({\n    ref: reference,\n    name: label || null,\n  });\n}\n\naddProviderModule(GLOBAL_SCOPE, 'global');\n\n// Import and register Storage as a provider\nif (cineStorage && typeof cineStorage === 'object') {\n  addProviderModule(cineStorage, 'storage');\n}\n\n\n// We no longer require these via tryRequire inside ESM\n// Instead, we assume they might be present in GLOBAL_SCOPE if they are legacy scripts.\n// If they are converted to ESM, we should import them.\n// Currently assuming they are either globals or not present.\n// If existing global objects are found, we add them.\n// (e.g. if loader.js loaded them).\n\nif (GLOBAL_SCOPE.cineAppSession) {\n  addProviderModule(GLOBAL_SCOPE.cineAppSession, 'session');\n}\n\nif (GLOBAL_SCOPE.cineAppSetups) {\n  addProviderModule(GLOBAL_SCOPE.cineAppSetups, 'setups');\n}\n\n\nconst bindingState = Object.create(null);\nconst bindingNames = [];\n\nfunction identifyProvider(providerEntry) {\n  if (!providerEntry) {\n    return null;\n  }\n\n  if (providerEntry.name) {\n    return providerEntry.name;\n  }\n\n  const ref = providerEntry.ref;\n  if (!ref || typeof ref !== 'object') {\n    return null;\n  }\n\n  if (ref === GLOBAL_SCOPE) {\n    return 'global';\n  }\n\n  if (typeof ref.constructor === 'function' && ref.constructor.name) {\n    return ref.constructor.name;\n  }\n\n  return null;\n}\n\nfunction ensureBindingEntry(bindingKey, implementationName) {\n  const key = String(bindingKey);\n  let entry = bindingState[key];\n  if (!entry) {\n    entry = {\n      name: key,\n      implementationName: implementationName || key,\n      available: false,\n      providerIndex: -1,\n      providerName: null,\n      lastChecked: null,\n      implementation: null,\n    };\n    bindingState[key] = entry;\n    bindingNames.push(key);\n  } else if (implementationName && entry.implementationName !== implementationName) {\n    entry.implementationName = implementationName;\n  }\n\n  return entry;\n}\n\nfunction resolveBinding(name, options = {}) {\n  const refresh = options && Object.prototype.hasOwnProperty.call(options, 'refresh')\n    ? options.refresh\n    : true;\n\n  const entry = ensureBindingEntry(name);\n  const implementationName = entry.implementationName || String(name);\n  if (!refresh && entry.implementation && typeof entry.implementation === 'function') {\n    return entry;\n  }\n\n  let resolved = null;\n\n  for (let index = 0; index < providerModules.length; index += 1) {\n    const providerEntry = providerModules[index];\n    const provider = providerEntry && providerEntry.ref;\n    if (!provider || typeof provider !== 'object') {\n      continue;\n    }\n\n    const candidate = provider[implementationName];\n    if (typeof candidate === 'function') {\n      resolved = {\n        implementation: candidate,\n        providerIndex: index,\n        providerName: identifyProvider(providerEntry),\n      };\n      break;\n    }\n  }\n\n  entry.available = !!resolved;\n  entry.providerIndex = resolved ? resolved.providerIndex : -1;\n  entry.providerName = resolved ? resolved.providerName : null;\n  entry.lastChecked = Date.now();\n  entry.implementation = resolved ? resolved.implementation : null;\n\n  return entry;\n}\n\nfunction requireBinding(name) {\n  const detail = resolveBinding(name, { refresh: true });\n  if (!detail || typeof detail.implementation !== 'function') {\n    const error = new Error(`cinePersistence could not resolve function \"${name}\".`);\n    error.code = 'CINE_PERSISTENCE_BINDING_MISSING';\n    error.binding = name;\n    error.detail = {\n      name,\n      available: detail ? detail.available : false,\n      providerName: detail ? detail.providerName : null,\n    };\n    throw error;\n  }\n  return detail.implementation;\n}\n\nfunction snapshotBinding(detail) {\n  if (!detail) {\n    return null;\n  }\n\n  return Object.freeze({\n    name: detail.name,\n    available: !!detail.available,\n    providerIndex: typeof detail.providerIndex === 'number' ? detail.providerIndex : -1,\n    providerName: detail.providerName || null,\n    lastChecked: detail.lastChecked || null,\n    implementation: detail.implementationName || detail.name,\n  });\n}\n\nfunction createWrapper(name, alias) {\n  const bindingKey = alias || name;\n  ensureBindingEntry(bindingKey, name);\n  return function persistenceWrapper() {\n    const fn = requireBinding(bindingKey);\n    return fn.apply(this, arguments);\n  };\n}\n\nfunction inspectBinding(name, options = {}) {\n  const normalized = String(name);\n  const refresh = options && Object.prototype.hasOwnProperty.call(options, 'refresh')\n    ? options.refresh\n    : true;\n  const detail = resolveBinding(normalized, { refresh });\n  return snapshotBinding(detail);\n}\n\nfunction inspectAllBindings(options = {}) {\n  const refresh = options && Object.prototype.hasOwnProperty.call(options, 'refresh')\n    ? options.refresh\n    : true;\n\n  if (refresh) {\n    for (let index = 0; index < bindingNames.length; index += 1) {\n      resolveBinding(bindingNames[index], { refresh: true });\n    }\n  }\n\n  const snapshot = {};\n  for (let index = 0; index < bindingNames.length; index += 1) {\n    const name = bindingNames[index];\n    snapshot[name] = snapshotBinding(bindingState[name]);\n  }\n  return freezeDeep(snapshot);\n}\n\nfunction listBindings() {\n  return bindingNames.slice();\n}\n\nconst persistenceAPI = {\n  bindings: {\n    saveSession: createWrapper('saveCurrentSession', 'saveSession'),\n    autoSaveSetup: createWrapper('autoSaveCurrentSetup', 'autoSaveSetup'),\n    saveGearList: createWrapper('saveCurrentGearList', 'saveGearList'),\n    restoreSessionState: createWrapper('restoreSessionState'),\n    collectFullBackupData: createWrapper('collectFullBackupData'),\n    createSettingsBackup: createWrapper('createSettingsBackup'),\n    captureStorageSnapshot: createWrapper('captureStorageSnapshot'),\n    sanitizeBackupPayload: createWrapper('sanitizeBackupPayload'),\n    autoBackup: createWrapper('autoBackup'),\n    formatFullBackupFilename: createWrapper('formatFullBackupFilename'),\n    downloadPayload: createWrapper('downloadBackupPayload', 'downloadPayload'),\n    recordFullBackupHistoryEntry: createWrapper('recordFullBackupHistoryEntry'),\n    encodeSharedSetup: createWrapper('encodeSharedSetup'),\n    decodeSharedSetup: createWrapper('decodeSharedSetup'),\n    applySharedSetup: createWrapper('applySharedSetup'),\n    applySharedSetupFromUrl: createWrapper('applySharedSetupFromUrl'),\n    downloadProject: createWrapper('downloadSharedProject', 'downloadProject'),\n    saveProject: createWrapper('saveProject'),\n    proceed: createWrapper('handleRestoreRehearsalProceed', 'proceed'),\n    abort: createWrapper('handleRestoreRehearsalAbort', 'abort'),\n  },\n  storage: {\n    loadDeviceData: createWrapper('loadDeviceData'),\n    saveDeviceData: createWrapper('saveDeviceData'),\n    loadSetups: createWrapper('loadSetups'),\n    saveSetups: createWrapper('saveSetups'),\n    saveSetup: createWrapper('saveSetup'),\n    loadSetup: createWrapper('loadSetup'),\n    deleteSetup: createWrapper('deleteSetup'),\n    renameSetup: createWrapper('renameSetup'),\n    loadSessionState: createWrapper('loadSessionState'),\n    saveSessionState: createWrapper('saveSessionState'),\n    loadFeedback: createWrapper('loadFeedback'),\n    saveFeedback: createWrapper('saveFeedback'),\n    saveProject: createWrapper('saveProject'),\n    loadProject: createWrapper('loadProject'),\n    deleteProject: createWrapper('deleteProject'),\n    loadFavorites: createWrapper('loadFavorites'),\n    saveFavorites: createWrapper('saveFavorites'),\n    exportAllData: createWrapper('exportAllData'),\n    importAllData: createWrapper('importAllData'),\n    clearAllData: createWrapper('clearAllData'),\n    loadAutoGearRules: createWrapper('loadAutoGearRules'),\n    saveAutoGearRules: createWrapper('saveAutoGearRules'),\n    loadAutoGearBackups: createWrapper('loadAutoGearBackups'),\n    saveAutoGearBackups: createWrapper('saveAutoGearBackups'),\n    loadAutoGearSeedFlag: createWrapper('loadAutoGearSeedFlag'),\n    saveAutoGearSeedFlag: createWrapper('saveAutoGearSeedFlag'),\n    loadAutoGearBackupRetention: createWrapper('loadAutoGearBackupRetention'),\n    saveAutoGearBackupRetention: createWrapper('saveAutoGearBackupRetention'),\n    getAutoGearBackupRetentionDefault: createWrapper('getAutoGearBackupRetentionDefault'),\n    loadAutoGearPresets: createWrapper('loadAutoGearPresets'),\n    saveAutoGearPresets: createWrapper('saveAutoGearPresets'),\n    loadAutoGearActivePresetId: createWrapper('loadAutoGearActivePresetId'),\n    saveAutoGearActivePresetId: createWrapper('saveAutoGearActivePresetId'),\n    loadAutoGearAutoPresetId: createWrapper('loadAutoGearAutoPresetId'),\n    saveAutoGearAutoPresetId: createWrapper('saveAutoGearAutoPresetId'),\n    loadAutoGearMonitorDefaults: createWrapper('loadAutoGearMonitorDefaults'),\n    saveAutoGearMonitorDefaults: createWrapper('saveAutoGearMonitorDefaults'),\n    loadAutoGearBackupVisibility: createWrapper('loadAutoGearBackupVisibility'),\n    saveAutoGearBackupVisibility: createWrapper('saveAutoGearBackupVisibility'),\n    loadFullBackupHistory: createWrapper('loadFullBackupHistory'),\n    saveFullBackupHistory: createWrapper('saveFullBackupHistory'),\n    recordFullBackupHistoryEntry: createWrapper('recordFullBackupHistoryEntry'),\n    requestPersistentStorage: createWrapper('requestPersistentStorage'),\n    clearUiCacheStorageEntries: createWrapper('clearUiCacheStorageEntries'),\n    ensureCriticalStorageBackups: createWrapper('ensureCriticalStorageBackups'),\n    getLastCriticalStorageGuardResult: createWrapper('getLastCriticalStorageGuardResult'),\n    saveSession: createWrapper('saveCurrentSession', 'saveSession'),\n    autoSaveSetup: createWrapper('autoSaveCurrentSetup', 'autoSaveSetup'),\n    proceed: createWrapper('handleRestoreRehearsalProceed', 'proceed'),\n    abort: createWrapper('handleRestoreRehearsalAbort', 'abort'),\n  },\n  autosave: {\n    saveSession: createWrapper('saveCurrentSession', 'saveSession'),\n    autoSaveSetup: createWrapper('autoSaveCurrentSetup', 'autoSaveSetup'),\n    saveGearList: createWrapper('saveCurrentGearList', 'saveGearList'),\n    restoreSessionState: createWrapper('restoreSessionState'),\n  },\n  backups: {\n    collectFullBackupData: createWrapper('collectFullBackupData'),\n    createSettingsBackup: createWrapper('createSettingsBackup'),\n    captureStorageSnapshot: createWrapper('captureStorageSnapshot'),\n    sanitizeBackupPayload: createWrapper('sanitizeBackupPayload'),\n    autoBackup: createWrapper('autoBackup'),\n    formatFullBackupFilename: createWrapper('formatFullBackupFilename'),\n    downloadPayload: createWrapper('downloadBackupPayload', 'downloadPayload'),\n    recordFullBackupHistoryEntry: createWrapper('recordFullBackupHistoryEntry'),\n  },\n  restore: {\n    proceed: createWrapper('handleRestoreRehearsalProceed', 'proceed'),\n    abort: createWrapper('handleRestoreRehearsalAbort', 'abort'),\n  },\n  share: {\n    downloadProject: createWrapper('downloadSharedProject', 'downloadProject'),\n    encodeSharedSetup: createWrapper('encodeSharedSetup'),\n    decodeSharedSetup: createWrapper('decodeSharedSetup'),\n    applySharedSetup: createWrapper('applySharedSetup'),\n    applySharedSetupFromUrl: createWrapper('applySharedSetupFromUrl'),\n  },\n\n  __internal: freezeDeep({\n    listBindings,\n    inspectBinding(name, options) {\n      return inspectBinding(name, options) || null;\n    },\n    inspectAllBindings,\n  }),\n};\n\nfreezeDeep(persistenceAPI);\n\naddProviderModule(persistenceAPI.bindings, 'bindings');\ninformModuleGlobals('cinePersistence', persistenceAPI);\n\nregisterOrQueueModule('cinePersistence', persistenceAPI, {\n  category: 'persistence',\n  description: 'Data integrity facade for storage, autosave, backups, restore, and share flows.',\n  replace: true,\n  connections: ['cineModuleGlobals', 'cineModuleEnvironment', 'cineEnvironmentBridge', 'cineModuleContext'],\n}, (error) => {\n  safeWarn('Unable to register cinePersistence module.', error);\n});\n\nif (GLOBAL_SCOPE && typeof GLOBAL_SCOPE === 'object') {\n  let existingPersistence = null;\n  try {\n    existingPersistence = GLOBAL_SCOPE.cinePersistence || null;\n  } catch (error) {\n    void error;\n    existingPersistence = null;\n  }\n\n  if (existingPersistence !== persistenceAPI) {\n    const exposed = exposeGlobal('cinePersistence', persistenceAPI, {\n      configurable: true,\n      enumerable: false,\n      writable: false,\n    });\n\n    if (!exposed && typeof console !== 'undefined' && typeof console.warn === 'function') {\n      console.warn('Unable to expose cinePersistence globally.');\n    }\n  }\n}\n\nexport const cinePersistence = persistenceAPI;\n","import { storageRepo } from '../storage/StorageRepository.js';\n\n/**\n * Service for managing project data.\n * Decouples the V2 Dashboard from legacy global storage functions.\n */\nexport class ProjectService {\n\n    /**\n     * Load a specific project by ID (name)\n     * @param {string} projectId \n     * @returns {Promise<Object|null>}\n     */\n    async getProject(projectId) {\n        if (!projectId) return null;\n        try {\n            const result = await storageRepo.loadProject(projectId);\n            return result ? result.data : null;\n        } catch (e) {\n            console.error('[ProjectService] Failed to load project:', projectId, e);\n            return null;\n        }\n    }\n\n    /**\n     * Get all available projects with their metadata\n     * @returns {Promise<Array<string>>} List of project names\n     */\n    async getProjectNames() {\n        try {\n            return await storageRepo.getProjectKeys();\n        } catch (e) {\n            console.error('[ProjectService] Failed to get project names:', e);\n            return [];\n        }\n    }\n\n    /**\n     * Get metadata for a specific project\n     * @param {string} projectId \n     * @returns {Promise<Object>} Metadata object or empty default\n     */\n    async getProjectMetadata(projectId) {\n        if (!projectId) return {};\n        try {\n            // First try to get lightweight metadata\n            const meta = await storageRepo.getProjectMeta(projectId);\n            if (meta) {\n                // Return legacy-compatible metadata structure if needed,\n                // or just the meta object. For now, let's load the project to be safe\n                // as the dashboard checks specific fields like 'color', 'icon', 'dates'.\n                // Optimization: StorageRepository.loadProject loads everything.\n                // Ideally we'd have a lightweight way to get these fields without full load.\n                // For now, we fallback to full load to ensure compatibility.\n            }\n\n            const result = await storageRepo.loadProject(projectId);\n            if (result && result.data) {\n                return result.data;\n            }\n        } catch (e) {\n            console.error('[ProjectService] Failed to get project metadata:', projectId, e);\n        }\n        return {};\n    }\n\n    /**\n     * Save a project\n     * @param {string} projectId \n     * @param {Object} projectData \n     * @returns {Promise<boolean>}\n     */\n    async saveProject(projectId, projectData) {\n        if (!projectId || !projectData) return false;\n\n        try {\n            // Basic structural validation/normalization could go here\n            if (typeof projectData !== 'object') {\n                console.warn('[ProjectService] Invalid project data');\n                return false;\n            }\n\n            // Ensure lastModified is set\n            if (!projectData.lastModified) {\n                projectData.lastModified = new Date().toISOString();\n            }\n\n            const result = await storageRepo.saveProject(projectId, projectData);\n            return result.success;\n        } catch (e) {\n            console.error('[ProjectService] Failed to save project:', projectId, e);\n            return false;\n        }\n    }\n\n    /**\n     * Create a new project\n     * @param {string} projectId \n     * @returns {Promise<boolean>}\n     */\n    async createProject(projectId) {\n        if (!projectId) return false;\n\n        const newProject = {\n            created: new Date().toISOString(),\n            lastModified: new Date().toISOString(),\n            gearList: '',\n            projectInfo: null,\n            gearListAndProjectRequirementsGenerated: false,\n            color: 'blue', // Default color\n            icon: ''   // Default icon\n        };\n\n        return this.saveProject(projectId, newProject);\n    }\n\n    /**\n     * Delete a project\n     * @param {string} projectId \n     * @returns {Promise<boolean>}\n     */\n    async deleteProject(projectId) {\n        if (!projectId) return false;\n        try {\n            await storageRepo.removeProject(projectId);\n            return true;\n        } catch (e) {\n            console.error('[ProjectService] Failed to delete project:', projectId, e);\n            return false;\n        }\n    }\n\n    /**\n     * Duplicate a project\n     * @param {string} sourceId \n     * @returns {Promise<{success: boolean, newId?: string}>}\n     */\n    async duplicateProject(sourceId) {\n        try {\n            const cleanSourceId = sourceId.trim();\n            const sourceProject = await this.getProject(cleanSourceId);\n\n            if (!sourceProject) {\n                return { success: false };\n            }\n\n            // Generate unique name\n            const existingNames = await this.getProjectNames();\n            let newName = `${cleanSourceId} (Copy)`;\n            let counter = 2;\n            while (existingNames.includes(newName)) {\n                newName = `${cleanSourceId} (Copy ${counter})`;\n                counter++;\n            }\n\n            // Clone data\n            const newData = JSON.parse(JSON.stringify(sourceProject));\n            newData.created = new Date().toISOString();\n            newData.lastModified = new Date().toISOString();\n\n            // Save\n            const saved = await this.saveProject(newName, newData);\n            return { success: saved, newId: newName };\n\n        } catch (e) {\n            console.error('[ProjectService] Failed to duplicate project:', e);\n            return { success: false };\n        }\n    }\n}\n\nexport const projectService = new ProjectService();\n"],"file":"core-modules-Be_U3JJE.js"}